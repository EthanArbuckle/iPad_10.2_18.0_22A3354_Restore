uint64_t llvm::createLintLegacyPassPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4E96FCC(v1);
}

llvm::UndefValue *llvm::FindAvailableLoadedValue(llvm::MemoryLocation *a1, uint64_t a2, uint64_t **a3, int a4, uint64_t a5, _BYTE *a6, _DWORD *a7)
{
  llvm::Type *v15;
  char isAtomic;
  _QWORD v17[6];

  if ((*((_WORD *)a1 + 9) & 0x301) != 0)
    return 0;
  llvm::MemoryLocation::get(a1, v17);
  v15 = *(llvm::Type **)a1;
  isAtomic = llvm::Instruction::isAtomic(a1);
  return llvm::findAvailablePtrLoadStore((uint64_t)v17, v15, isAtomic, a2, a3, a4, a5, a6, a7);
}

llvm::UndefValue *llvm::findAvailablePtrLoadStore(uint64_t a1, llvm::Type *a2, char a3, uint64_t a4, uint64_t **a5, int a6, uint64_t a7, _BYTE *a8, _DWORD *a9)
{
  uint64_t v13;
  llvm::Value *v14;
  uint64_t *v15;
  unsigned __int8 *v16;
  __int32 **v17;
  int v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t *v21;
  llvm::UndefValue *result;
  int v23;
  uint64_t v24;
  llvm::Value *v25;
  int v26;
  int v27;
  BOOL v28;
  __int128 v30;
  llvm::Value *v31;
  uint64_t *v32;
  unsigned int IndexTypeSizeInBits;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL isEmptySet;
  uint64_t v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  int v43;
  unint64_t v44;
  void *v45;
  void *v46;
  uint64_t v47;
  __int128 v52[3];
  char v53;
  const void *v54[4];
  void *v55;
  unsigned int v56;
  void *v57;
  unsigned int v58;
  void *v59;
  unsigned int v60;
  _BYTE v61[32];
  void *v62;
  unsigned int v63;
  void *v64;
  unsigned int v65;
  void *v66;
  unsigned int v67;
  void *v68;
  unsigned int v69;
  void *v70;
  unsigned int v71;

  v13 = *(_QWORD *)(*(_QWORD *)(a4 + 56) + 40);
  v14 = llvm::Value::stripPointerCasts(*(llvm::Value **)a1);
  v15 = *a5;
  if (*a5 != *(uint64_t **)(a4 + 48))
  {
    v16 = (unsigned __int8 *)v14;
    v17 = (__int32 **)(v13 + 272);
    if (a6)
      v18 = a6;
    else
      v18 = -1;
    while (1)
    {
      v19 = *v15;
      *a5 = (uint64_t *)*v15;
      if (v19)
        v20 = (unsigned __int8 *)(v19 - 24);
      else
        v20 = 0;
      if (sub_1C4D99D08((uint64_t)v20) || sub_1C509DDB0((uint64_t)v20))
        goto LABEL_10;
      v21 = (uint64_t *)(*a5)[1];
      *a5 = v21;
      if (a9)
        ++*a9;
      if (!v18)
        return 0;
      *a5 = (uint64_t *)*v21;
      result = sub_1C4E9A560((uint64_t)v20, v16, a2, a3, v17, a8);
      if (result)
        return result;
      --v18;
      v23 = v20[16];
      if (v23 == 61)
        v24 = (uint64_t)v20;
      else
        v24 = 0;
      if (!v19 || v23 != 61)
      {
        if (llvm::Instruction::mayWriteToMemory((llvm::Instruction *)v20))
        {
          if (!a7)
            goto LABEL_67;
          v30 = *(_OWORD *)(a1 + 16);
          v52[0] = *(_OWORD *)a1;
          v52[1] = v30;
          v52[2] = *(_OWORD *)(a1 + 32);
          v53 = 1;
          if ((sub_1C4D90C64(a7, (uint64_t)v20, v52) & 2) != 0)
            goto LABEL_67;
        }
        goto LABEL_10;
      }
      v25 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v24 - 32));
      v26 = v16[16];
      if (v26 == 59 || v26 == 3)
      {
        v27 = *((unsigned __int8 *)v25 + 16);
        v28 = v27 == 59 || v27 == 3;
        if (v28 && v16 != (unsigned __int8 *)v25)
          goto LABEL_10;
      }
      if (a7)
      {
        if ((llvm::AAResults::getModRefInfo(a7, v24, (_QWORD *)a1) & 2) != 0)
          goto LABEL_67;
        goto LABEL_10;
      }
      v31 = *(llvm::Value **)a1;
      v32 = *(uint64_t **)(v24 - 32);
      v47 = **(_QWORD **)(v24 - 64);
      IndexTypeSizeInBits = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)v17, **(_QWORD **)a1);
      sub_1C4832EA4((llvm::APInt *)&v70, IndexTypeSizeInBits, 0, 0);
      v34 = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)v17, *v32);
      sub_1C4832EA4((llvm::APInt *)&v68, v34, 0, 0);
      v36 = llvm::Value::stripAndAccumulateConstantOffsets((uint64_t)v31, (llvm::DataLayout *)v17, (const void **)&v70, 0, 0, 0, v35);
      isEmptySet = 0;
      if (v36 == llvm::Value::stripAndAccumulateConstantOffsets((uint64_t)v32, (llvm::DataLayout *)v17, (const void **)&v68, 0, 0, 0, v37))break;
LABEL_39:
      if (v69 >= 0x41 && v68)
        MEMORY[0x1CAA32F9C](v68, 0x1000C8000313F17);
      if (v71 >= 0x41)
      {
        if (v70)
          MEMORY[0x1CAA32F9C](v70, 0x1000C8000313F17);
      }
      if (!isEmptySet)
      {
LABEL_67:
        result = 0;
        *a5 = (uint64_t *)(*a5)[1];
        return result;
      }
LABEL_10:
      v15 = *a5;
      if (*a5 == *(uint64_t **)(a4 + 48))
        return 0;
    }
    sub_1C4768AD0((uint64_t)v17, (uint64_t)a2);
    if (v40 == 1)
      v41 = -2;
    else
      v41 = (unint64_t)(v39 + 7) >> 3;
    sub_1C4768AD0((uint64_t)v17, v47);
    if (v43 == 1)
      v44 = -2;
    else
      v44 = (unint64_t)(v42 + 7) >> 3;
    v67 = v71;
    if (v71 > 0x40)
    {
      v66 = (void *)operator new[]();
      v45 = v70;
      memcpy(v66, v70, (((unint64_t)v67 + 63) >> 3) & 0x3FFFFFF8);
      v63 = v71;
      if (v71 > 0x40)
      {
        v62 = (void *)operator new[]();
        memcpy(v62, v70, (((unint64_t)v63 + 63) >> 3) & 0x3FFFFFF8);
        goto LABEL_47;
      }
    }
    else
    {
      v45 = v70;
      v66 = v70;
      v63 = v71;
    }
    v62 = v45;
LABEL_47:
    llvm::APInt::operator+=((uint64_t)&v62, v41);
    v65 = v63;
    v64 = v62;
    v63 = 0;
    llvm::ConstantRange::ConstantRange((uint64_t)v52, (uint64_t)&v66, (uint64_t)&v64);
    if (v65 >= 0x41 && v64)
      MEMORY[0x1CAA32F9C](v64, 0x1000C8000313F17);
    if (v63 >= 0x41 && v62)
      MEMORY[0x1CAA32F9C](v62, 0x1000C8000313F17);
    if (v67 >= 0x41 && v66)
      MEMORY[0x1CAA32F9C](v66, 0x1000C8000313F17);
    v60 = v69;
    if (v69 > 0x40)
    {
      v59 = (void *)operator new[]();
      v46 = v68;
      memcpy(v59, v68, (((unint64_t)v60 + 63) >> 3) & 0x3FFFFFF8);
      v56 = v69;
      if (v69 > 0x40)
      {
        v55 = (void *)operator new[]();
        memcpy(v55, v68, (((unint64_t)v56 + 63) >> 3) & 0x3FFFFFF8);
LABEL_52:
        llvm::APInt::operator+=((uint64_t)&v55, v44);
        v58 = v56;
        v57 = v55;
        v56 = 0;
        llvm::ConstantRange::ConstantRange((uint64_t)v61, (uint64_t)&v59, (uint64_t)&v57);
        if (v58 >= 0x41 && v57)
          MEMORY[0x1CAA32F9C](v57, 0x1000C8000313F17);
        if (v56 >= 0x41 && v55)
          MEMORY[0x1CAA32F9C](v55, 0x1000C8000313F17);
        if (v60 >= 0x41 && v59)
          MEMORY[0x1CAA32F9C](v59, 0x1000C8000313F17);
        llvm::ConstantRange::intersectWith((uint64_t)v52, (llvm::ConstantRange *)v61, 0, (uint64_t)v54);
        isEmptySet = llvm::ConstantRange::isEmptySet(v54);
        sub_1C4E8C6FC((uint64_t)v54);
        sub_1C4E8C6FC((uint64_t)v61);
        sub_1C4E8C6FC((uint64_t)v52);
        goto LABEL_39;
      }
    }
    else
    {
      v46 = v68;
      v59 = v68;
      v56 = v69;
    }
    v55 = v46;
    goto LABEL_52;
  }
  return 0;
}

BOOL llvm::VectorizerParams::isInterleaveForced(llvm::VectorizerParams *this)
{
  return word_1ED7F2378 != 0;
}

int8x16_t *llvm::RuntimeCheckingPtrGroup::RuntimeCheckingPtrGroup(int8x16_t *this, unsigned __int32 a2, llvm::RuntimePointerChecking *a3)
{
  int8x16_t v3;
  uint64_t v4;
  unsigned int v5;

  v3 = *(int8x16_t *)(*((_QWORD *)a3 + 1) + ((unint64_t)a2 << 6) + 24);
  *this = vextq_s8(v3, v3, 8uLL);
  this[1].i64[0] = (uint64_t)this[2].i64;
  this[1].i64[1] = 0x200000000;
  v4 = **(_QWORD **)(*((_QWORD *)a3 + 1) + ((unint64_t)a2 << 6) + 16);
  v5 = *(_DWORD *)(v4 + 8);
  if ((v5 & 0xFE) == 0x12)
    v5 = *(_DWORD *)(**(_QWORD **)(v4 + 16) + 8);
  this[2].i32[2] = v5 >> 8;
  this[2].i32[0] = a2;
  this[1].i32[2] = 1;
  return this;
}

uint64_t sub_1C619DDB0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v4;
  uint64_t v5;

  v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
    return sub_1C4EA2E4C(a1, a2, a3, a4);
  v5 = *(_QWORD *)a1 + 24 * v4;
  *(_QWORD *)v5 = a2;
  *(_QWORD *)(v5 + 8) = a3;
  *(_DWORD *)(v5 + 16) = a4;
  *(_DWORD *)(a1 + 8) = v4 + 1;
  return a1;
}

void llvm::RuntimePointerChecking::generateChecks(llvm::RuntimePointerChecking *a1, uint64_t a2, char a3)
{
  void *v4[2];
  _QWORD v5[9];

  v5[8] = *MEMORY[0x1E0C80C00];
  llvm::RuntimePointerChecking::groupChecks((uint64_t)a1, a2, a3);
  llvm::RuntimePointerChecking::generateChecks(a1, (uint64_t)v4);
  sub_1C486F510((uint64_t)a1 + 280, (uint64_t)v4);
  if (v4[0] != v5)
    free(v4[0]);
}

uint64_t llvm::RuntimeCheckingPtrGroup::addPointer(llvm::RuntimeCheckingPtrGroup *this, unsigned int a2, llvm::RuntimePointerChecking *a3, uint64_t a4, unsigned int a5)
{
  unint64_t v5;

  v5 = *((_QWORD *)a3 + 1) + ((unint64_t)a2 << 6);
  return llvm::RuntimeCheckingPtrGroup::addPointer(this, a2, *(const llvm::SCEV **)(v5 + 24), *(const llvm::SCEV **)(v5 + 32), a5, *((llvm::ScalarEvolution **)a3 + 34));
}

uint64_t sub_1C619DE84(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t result;

  v3 = sub_1C4EA2F20(a1, a2);
  v4 = *(_QWORD *)a1;
  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_QWORD *)a1 + 48 * v5;
  *(_OWORD *)v6 = *(_OWORD *)v3;
  *(_QWORD *)(v6 + 24) = 0x200000000;
  *(_QWORD *)(v6 + 16) = v6 + 32;
  result = v6 + 16;
  if (*(_DWORD *)(v3 + 24))
    result = sub_1C4EA2F88(result, v3 + 16);
  *(_DWORD *)(v4 + 48 * v5 + 40) = *(_DWORD *)(v3 + 40);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

BOOL llvm::RuntimePointerChecking::arePointersInSamePartition(_QWORD *a1, unsigned int a2, unsigned int a3)
{
  int v3;

  v3 = *(_DWORD *)(*a1 + 4 * a2);
  return v3 != -1 && v3 == *(_DWORD *)(*a1 + 4 * a3);
}

llvm::raw_ostream *llvm::RuntimePointerChecking::printChecks(llvm::raw_ostream *result, llvm::raw_ostream *this, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  llvm::raw_ostream *v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  llvm::raw_ostream *v15;
  llvm::raw_ostream *v16;
  llvm::raw_ostream *v17;
  unint64_t v18;
  llvm::raw_ostream *v19;
  llvm::raw_ostream *v20;
  llvm::raw_ostream *v21;
  unint64_t v22;
  uint64_t v23;

  v4 = *(unsigned int *)(a3 + 8);
  if ((_DWORD)v4)
  {
    v6 = (uint64_t)result;
    v7 = 0;
    v8 = *(unint64_t **)a3;
    v23 = *(_QWORD *)a3 + 16 * v4;
    v9 = a4 + 2;
    do
    {
      v10 = *v8;
      v11 = v8[1];
      v12 = llvm::raw_ostream::indent(this, a4);
      v13 = sub_1C4816AD8(v12, "Check ");
      v14 = llvm::raw_ostream::operator<<(v13, v7);
      sub_1C4816AD8(v14, ":\n");
      v15 = llvm::raw_ostream::indent(this, v9);
      v16 = sub_1C4816AD8(v15, "Comparing group (");
      v17 = llvm::raw_ostream::operator<<(v16, *v8);
      sub_1C4816AD8(v17, "):\n");
      if (*(_DWORD *)(v10 + 24))
      {
        v18 = 0;
        do
        {
          llvm::raw_ostream::indent(this, v9);
          llvm::Value::print(*(llvm::Value **)(*(_QWORD *)(v6 + 8)+ ((unint64_t)*(unsigned int *)(*(_QWORD *)(v10 + 16) + 4 * v18) << 6)+ 16), this, 0);
          sub_1C4816AD8(this, "\n");
          ++v18;
        }
        while (v18 < *(unsigned int *)(v10 + 24));
      }
      v19 = llvm::raw_ostream::indent(this, v9);
      v20 = sub_1C4816AD8(v19, "Against group (");
      v21 = llvm::raw_ostream::operator<<(v20, v8[1]);
      result = sub_1C4816AD8(v21, "):\n");
      if (*(_DWORD *)(v11 + 24))
      {
        v22 = 0;
        do
        {
          llvm::raw_ostream::indent(this, v9);
          llvm::Value::print(*(llvm::Value **)(*(_QWORD *)(v6 + 8)+ ((unint64_t)*(unsigned int *)(*(_QWORD *)(v11 + 16) + 4 * v22) << 6)+ 16), this, 0);
          result = sub_1C4816AD8(this, "\n");
          ++v22;
        }
        while (v22 < *(unsigned int *)(v11 + 24));
      }
      ++v7;
      v8 += 2;
    }
    while (v8 != (unint64_t *)v23);
  }
  return result;
}

llvm::raw_ostream *llvm::RuntimePointerChecking::print(llvm::RuntimePointerChecking *this, llvm::raw_ostream *a2, unsigned int a3)
{
  llvm::raw_ostream *v6;
  llvm::raw_ostream *result;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  llvm::raw_ostream *v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  llvm::raw_ostream *v15;
  llvm::raw_ostream *v16;
  llvm::raw_ostream *v17;
  unint64_t v18;
  unint64_t v19;
  llvm::raw_ostream *v20;
  llvm::raw_ostream *v21;
  unsigned int v22;

  llvm::raw_ostream::indent(a2, a3);
  sub_1C4816AD8(a2, "Run-time memory checks:\n");
  llvm::RuntimePointerChecking::printChecks(this, a2, (uint64_t)this + 280, a3);
  v6 = llvm::raw_ostream::indent(a2, a3);
  result = sub_1C4816AD8(v6, "Grouped accesses:\n");
  if (*((_DWORD *)this + 40))
  {
    v8 = 0;
    v22 = a3 + 2;
    v9 = a3 + 4;
    v10 = a3 + 6;
    do
    {
      v11 = *((_QWORD *)this + 19) + 48 * v8;
      v12 = llvm::raw_ostream::indent(a2, v22);
      v13 = sub_1C4816AD8(v12, "Group ");
      v14 = llvm::raw_ostream::operator<<(v13, v11);
      sub_1C4816AD8(v14, ":\n");
      v15 = llvm::raw_ostream::indent(a2, v9);
      v16 = sub_1C4816AD8(v15, "(Low: ");
      llvm::SCEV::print(*(_QWORD *)(v11 + 8));
      v17 = sub_1C4816AD8(v16, " High: ");
      llvm::SCEV::print(*(_QWORD *)v11);
      result = sub_1C4816AD8(v17, ")\n");
      if (*(_DWORD *)(v11 + 24))
      {
        v18 = 0;
        v19 = v11 + 16;
        do
        {
          v20 = llvm::raw_ostream::indent(a2, v10);
          v21 = sub_1C4816AD8(v20, "Member: ");
          llvm::SCEV::print(*(_QWORD *)(*((_QWORD *)this + 1)
                                      + ((unint64_t)*(unsigned int *)(*(_QWORD *)v19 + 4 * v18) << 6)
                                      + 56));
          result = sub_1C4816AD8(v21, "\n");
          ++v18;
        }
        while (v18 < *(unsigned int *)(v19 + 8));
      }
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 40));
  }
  return result;
}

BOOL llvm::MemoryDepChecker::Dependence::isPossiblyBackward(llvm::MemoryDepChecker::Dependence *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 2);
  return v1 > 3 || v1 == 1;
}

llvm::raw_ostream *llvm::MemoryDepChecker::Dependence::print(unsigned int *a1, llvm::raw_ostream *this, unsigned int a3, _QWORD *a4)
{
  unsigned int v5;
  llvm::raw_ostream *v8;

  v5 = a3;
  llvm::raw_ostream::indent(this, a3);
  v8 = sub_1C4816AD8(this, llvm::MemoryDepChecker::Dependence::DepName[a1[2]]);
  sub_1C4816AD8(v8, ":\n");
  v5 += 2;
  llvm::raw_ostream::indent(this, v5);
  llvm::Value::print(*(llvm::Value **)(*a4 + 8 * *a1), this, 0);
  sub_1C4816AD8(this, " -> \n");
  llvm::raw_ostream::indent(this, v5);
  llvm::Value::print(*(llvm::Value **)(*a4 + 8 * a1[1]), this, 0);
  return sub_1C4816AD8(this, "\n");
}

BOOL llvm::LoopAccessInfo::blockNeedsPredication(llvm::LoopAccessInfo *this, llvm::BasicBlock *a2, llvm::Loop *a3, llvm::DominatorTree *a4)
{
  uint64_t LoopLatch;

  LoopLatch = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch((uint64_t)a2);
  return !llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates((uint64_t)a3, (uint64_t)this, LoopLatch);
}

_QWORD *sub_1C619E3C0(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  *(_BYTE *)result = 0;
  v2 = *((unsigned int *)result + 4);
  if ((_DWORD)v2)
  {
    v3 = result[1];
    v4 = v2 << 6;
    do
    {
      v5 = *(_QWORD *)(v3 + v4 - 48);
      if (v5 != -8192 && v5 != -4096 && v5 != 0)
        result = llvm::ValueHandleBase::RemoveFromUseList((_QWORD *)(v3 + v4 - 64));
      v4 -= 64;
    }
    while (v4);
  }
  *((_DWORD *)v1 + 4) = 0;
  *((_DWORD *)v1 + 72) = 0;
  return result;
}

llvm::LoopAccessLegacyAnalysis *llvm::LoopAccessLegacyAnalysis::LoopAccessLegacyAnalysis(llvm::LoopAccessLegacyAnalysis *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::LoopAccessLegacyAnalysis::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E8138C98;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E048);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EA194C;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E048, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeLoopAccessLegacyAnalysisPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E048);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EA194C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E048, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::LoopAccessLegacyAnalysis::getInfo(llvm::LoopAccessLegacyAnalysis *this, llvm::Loop *a2)
{
  _QWORD *v3;
  uint64_t result;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  llvm::Loop *v8;

  v8 = a2;
  v3 = sub_1C619F8F8((uint64_t)this + 32, (uint64_t *)&v8);
  result = v3[1];
  if (!result)
  {
    v5 = operator new();
    result = llvm::LoopAccessInfo::LoopAccessInfo(v5, v8, *((llvm::ScalarEvolution **)this + 7), *((uint64_t **)this + 8), *((_QWORD *)this + 9), *((_QWORD *)this + 10), *((_QWORD *)this + 11));
    v6 = (uint64_t *)v3[1];
    v3[1] = result;
    if (v6)
    {
      v7 = sub_1C4EA401C(v6);
      MEMORY[0x1CAA32FC0](v7, 0x10E0C402B7C74A4);
      return v3[1];
    }
  }
  return result;
}

uint64_t llvm::LoopAccessLegacyAnalysis::runOnFunction(llvm::LoopAccessLegacyAnalysis *this, llvm::Function *a2)
{
  char **v4;
  char *v5;
  uint64_t AnalysisIfAvailable;
  char **v7;
  char *v8;
  char **v9;
  char *v10;
  char **v11;
  char *v12;

  v4 = (char **)**((_QWORD **)this + 1);
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != llvm::ScalarEvolutionWrapperPass::ID);
  *((_QWORD *)this + 7) = *(_QWORD *)((*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), llvm::ScalarEvolutionWrapperPass::ID)+ 32);
  AnalysisIfAvailable = llvm::AnalysisResolver::getAnalysisIfAvailable(*((llvm::PMDataManager ***)this + 1), llvm::TargetLibraryInfoWrapperPass::ID);
  if (AnalysisIfAvailable)
  {
    AnalysisIfAvailable = (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)AnalysisIfAvailable + 96))(AnalysisIfAvailable, llvm::TargetLibraryInfoWrapperPass::ID);
    if (AnalysisIfAvailable)
      AnalysisIfAvailable = sub_1C4D914E8(AnalysisIfAvailable, (uint64_t)a2);
  }
  *((_QWORD *)this + 8) = AnalysisIfAvailable;
  v7 = (char **)**((_QWORD **)this + 1);
  do
  {
    v8 = *v7;
    v7 += 2;
  }
  while (v8 != llvm::AAResultsWrapperPass::ID);
  *((_QWORD *)this + 9) = *(_QWORD *)((*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v7 - 1) + 96))(*(v7 - 1), llvm::AAResultsWrapperPass::ID)+ 32);
  v9 = (char **)**((_QWORD **)this + 1);
  do
  {
    v10 = *v9;
    v9 += 2;
  }
  while (v10 != llvm::DominatorTreeWrapperPass::ID);
  *((_QWORD *)this + 10) = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v9 - 1) + 96))(*(v9 - 1), llvm::DominatorTreeWrapperPass::ID)+ 32;
  v11 = (char **)**((_QWORD **)this + 1);
  do
  {
    v12 = *v11;
    v11 += 2;
  }
  while (v12 != llvm::LoopInfoWrapperPass::ID);
  *((_QWORD *)this + 11) = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v11 - 1) + 96))(*(v11 - 1), llvm::LoopInfoWrapperPass::ID)+ 32;
  return 0;
}

llvm::AnalysisUsage *llvm::LoopAccessLegacyAnalysis::getAnalysisUsage(llvm::LoopAccessLegacyAnalysis *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage *result;

  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::ScalarEvolutionWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AAResultsWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::DominatorTreeWrapperPass::ID);
  result = llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::LoopInfoWrapperPass::ID);
  *((_BYTE *)a2 + 160) = 1;
  return result;
}

void sub_1C619E78C(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E8138C98;
  sub_1C619EE18((uint64_t)a1 + 32);
  MEMORY[0x1CAA32FB4](*((_QWORD *)a1 + 4), 8);
  llvm::Pass::~Pass(a1);
}

void sub_1C619E7C8(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E8138C98;
  sub_1C619EE18((uint64_t)a1 + 32);
  MEMORY[0x1CAA32FB4](*((_QWORD *)a1 + 4), 8);
  llvm::Pass::~Pass(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C619E818(uint64_t a1)
{
  return sub_1C619EE8C((_QWORD *)(a1 + 32));
}

uint64_t sub_1C619E820(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  int v11;

  v11 = 0;
  v8 = llvm::cl::parser<unsigned int>::parse(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v11);
  if ((v8 & 1) != 0)
    return v8;
  **(_DWORD **)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 184);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v11);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C619E89C();
}

uint64_t sub_1C619E89C()
{
  return 2;
}

void sub_1C619E8A4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &unk_1E8138D38;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      sub_1C47A80D0(a1);
      JUMPOUT(0x1CAA32FC0);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_6;
}

uint64_t sub_1C619E918(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1C619E924(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

void sub_1C619E934(uint64_t a1, int a2, int a3)
{
  unsigned int v3;
  uint64_t (**v4)();
  int v5;
  char v6;

  if (a3)
  {
    v3 = **(_DWORD **)(a1 + 128);
LABEL_3:
    v5 = *(_DWORD *)(a1 + 144);
    v6 = *(_BYTE *)(a1 + 148);
    v4 = &off_1E7F952A8;
    llvm::cl::parser<unsigned int>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, v3, (uint64_t)&v4, a2);
    return;
  }
  if (*(_BYTE *)(a1 + 148))
  {
    v3 = **(_DWORD **)(a1 + 128);
    if (*(_DWORD *)(a1 + 144) != v3)
      goto LABEL_3;
  }
}

uint64_t sub_1C619E9AC(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 148);
  if (*(_BYTE *)(result + 148))
    v1 = *(_DWORD *)(result + 144);
  **(_DWORD **)(result + 128) = v1;
  return result;
}

void sub_1C619E9C8(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 208, &v5);
  sub_1C619EA34(a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

uint64_t sub_1C619EA34(uint64_t result, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_DWORD *)(result + 8);
  if (v2)
  {
    v4 = result;
    v5 = *(_QWORD *)result;
    v6 = 208 * v2;
    do
    {
      result = sub_1C4EA1CD0(a2, v5);
      v5 += 208;
      a2 += 208;
      v6 -= 208;
    }
    while (v6);
    v7 = *(_DWORD *)(v4 + 8);
    if (v7)
    {
      v8 = *(_QWORD *)v4;
      v9 = 208 * v7;
      v10 = v8 - 208;
      do
      {
        result = sub_1C4EA1D5C(v10 + v9);
        v9 -= 208;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t sub_1C619EAB4(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  void *v6;
  _DWORD *v7;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a1 != a2)
  {
    v5 = (const void *)(a2 + 16);
    v4 = *(const void **)a2;
    if (v4 != v5)
    {
      v6 = *(void **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *(const void **)a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_6;
    }
    v7 = (_DWORD *)(a2 + 8);
    v9 = *(unsigned int *)(a2 + 8);
    v10 = *(unsigned int *)(a1 + 8);
    if (v10 >= v9)
    {
      if ((_DWORD)v9)
        memmove(*(void **)a1, v4, 16 * v9 - 3);
      goto LABEL_16;
    }
    if (*(_DWORD *)(a1 + 12) >= v9)
    {
      if ((_DWORD)v10)
      {
        memmove(*(void **)a1, v4, 16 * v10 - 3);
LABEL_12:
        v11 = *v7;
        if (v10 != v11)
          memcpy((void *)(*(_QWORD *)a1 + 16 * v10), (const void *)(*(_QWORD *)a2 + 16 * v10), *(_QWORD *)a2 + 16 * v11 - (*(_QWORD *)a2 + 16 * v10));
LABEL_16:
        *(_DWORD *)(a1 + 8) = v9;
LABEL_6:
        *v7 = 0;
        return a1;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v9, 16);
    }
    v10 = 0;
    goto LABEL_12;
  }
  return a1;
}

uint64_t sub_1C619EBD0(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a1 != a2)
  {
    v4 = *(unsigned int *)(a2 + 8);
    v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if ((_DWORD)v4)
        memmove(*(void **)a1, *(const void **)a2, 16 * v4 - 3);
      goto LABEL_10;
    }
    if (*(_DWORD *)(a1 + 12) >= v4)
    {
      if ((_DWORD)v5)
      {
        memmove(*(void **)a1, *(const void **)a2, 16 * v5 - 3);
LABEL_6:
        v6 = *(unsigned int *)(a2 + 8);
        if (v5 != v6)
          memcpy((void *)(*(_QWORD *)a1 + 16 * v5), (const void *)(*(_QWORD *)a2 + 16 * v5), *(_QWORD *)a2 + 16 * v6 - (*(_QWORD *)a2 + 16 * v5));
LABEL_10:
        *(_DWORD *)(a1 + 8) = v4;
        return a1;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v4, 16);
    }
    v5 = 0;
    goto LABEL_6;
  }
  return a1;
}

uint64_t sub_1C619ECA0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v11;
  _QWORD *v12;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if (*(_QWORD *)a2 != -16 && v9 != -4)
    {
      v12 = 0;
      result = sub_1C4EA2044(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      v11 = v12;
      *v12 = *(_QWORD *)a2;
      *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1C619ED4C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      result = sub_1C4EA246C(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      v10 = v12;
      v11 = a2[1];
      *v12 = *a2;
      v10[1] = v11;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

llvm::LoopAccessLegacyAnalysis *llvm::callDefaultCtor<llvm::LoopAccessLegacyAnalysis>()
{
  llvm::LoopAccessLegacyAnalysis *v0;

  v0 = (llvm::LoopAccessLegacyAnalysis *)operator new();
  return llvm::LoopAccessLegacyAnalysis::LoopAccessLegacyAnalysis(v0);
}

uint64_t sub_1C619EE18(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;

  v1 = *(unsigned int *)(result + 16);
  if ((_DWORD)v1)
  {
    v2 = 16 * v1;
    v3 = (uint64_t *)(*(_QWORD *)result + 8);
    do
    {
      if ((*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        result = *v3;
        *v3 = 0;
        if (result)
        {
          v4 = sub_1C4EA401C((uint64_t *)result);
          result = MEMORY[0x1CAA32FC0](v4, 0x10E0C402B7C74A4);
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
  return result;
}

_QWORD *sub_1C619EE8C(_QWORD *result)
{
  _QWORD *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  uint64_t v6;
  uint64_t *v7;

  v1 = result;
  v2 = *((_DWORD *)result + 2);
  if (v2 || *((_DWORD *)result + 3))
  {
    v3 = *((unsigned int *)result + 4);
    if (v3 > 4 * v2 && v3 >= 0x41)
      return sub_1C4EA2B1C(result);
    if (!(_DWORD)v3)
    {
LABEL_13:
      v1[1] = 0;
      return result;
    }
    v4 = 16 * v3;
    v5 = (_QWORD **)(*result + 8);
    while (1)
    {
      v6 = (uint64_t)*(v5 - 1);
      if (v6 == -8192)
        goto LABEL_11;
      if (v6 != -4096)
        break;
LABEL_12:
      v5 += 2;
      v4 -= 16;
      if (!v4)
        goto LABEL_13;
    }
    result = *v5;
    *v5 = 0;
    if (result)
    {
      v7 = sub_1C4EA401C(result);
      result = (_QWORD *)MEMORY[0x1CAA32FC0](v7, 0x10E0C402B7C74A4);
    }
LABEL_11:
    *(v5 - 1) = (_QWORD *)-4096;
    goto LABEL_12;
  }
  return result;
}

void sub_1C619EF4C(_WORD *a1, __int128 *a2, _DWORD **a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F22B0, 0, 0);
  byte_1ED7F2344 = 0;
  qword_1ED7F2330 = 0;
  unk_1ED7F2338 = &off_1E7F952A8;
  qword_1ED7F22B0 = (uint64_t)&unk_1E8138D38;
  qword_1ED7F2348 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F2350 = (uint64_t)&unk_1E8138DA0;
  qword_1ED7F2368 = (uint64_t)&qword_1ED7F2350;
  sub_1C619EFF0(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F22B0);
}

uint64_t sub_1C619EFF0(_WORD *a1, __int128 *a2, _DWORD **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F22B0, "force-vector-width", 0x12uLL);
  word_1ED7F22BA = (32 * (*a1 & 3)) | word_1ED7F22BA & 0xFF9F;
  xmmword_1ED7F22D0 = *a2;
  return sub_1C4EA2D4C((uint64_t)&qword_1ED7F2330, &qword_1ED7F22B0, *a3);
}

void sub_1C619F068()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C619F07C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_1E8138DA0;
  return result;
}

void sub_1C619F0A4(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_1E8138DA0;
}

void sub_1C619F0C0(_WORD *a1, __int128 *a2, _DWORD **a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F2370, 0, 0);
  byte_1ED7F2404 = 0;
  qword_1ED7F23F0 = 0;
  unk_1ED7F23F8 = &off_1E7F952A8;
  qword_1ED7F2370 = (uint64_t)&unk_1E8138D38;
  qword_1ED7F2408 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F2410 = (uint64_t)&unk_1E8138DA0;
  qword_1ED7F2428 = (uint64_t)&qword_1ED7F2410;
  sub_1C619F164(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F2370);
}

uint64_t sub_1C619F164(_WORD *a1, __int128 *a2, _DWORD **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F2370, "force-vector-interleave", 0x17uLL);
  word_1ED7F237A = (32 * (*a1 & 3)) | word_1ED7F237A & 0xFF9F;
  xmmword_1ED7F2390 = *a2;
  return sub_1C4EA2D4C((uint64_t)&qword_1ED7F23F0, &qword_1ED7F2370, *a3);
}

void sub_1C619F1D8(_WORD *a1, __int128 *a2, _DWORD **a3, int **a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F2430, 0, 0);
  byte_1ED7F24C4 = 0;
  qword_1ED7F24B0 = 0;
  unk_1ED7F24B8 = &off_1E7F952A8;
  qword_1ED7F2430 = (uint64_t)&unk_1E8138D38;
  qword_1ED7F24C8 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F24D0 = (uint64_t)&unk_1E8138DA0;
  qword_1ED7F24E8 = (uint64_t)&qword_1ED7F24D0;
  sub_1C619F28C(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F2430);
}

uint64_t sub_1C619F28C(_WORD *a1, __int128 *a2, _DWORD **a3, int **a4)
{
  uint64_t result;
  int v9;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F2430, "runtime-memory-check-threshold", 0x1EuLL);
  word_1ED7F243A = (32 * (*a1 & 3)) | word_1ED7F243A & 0xFF9F;
  xmmword_1ED7F2450 = *a2;
  result = sub_1C4EA2D4C((uint64_t)&qword_1ED7F24B0, &qword_1ED7F2430, *a3);
  v9 = **a4;
  *(_DWORD *)qword_1ED7F24B0 = v9;
  byte_1ED7F24C4 = 1;
  dword_1ED7F24C0 = v9;
  return result;
}

void sub_1C619F32C(_WORD *a1, __int128 *a2, int **a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F25B0, 0, 0);
  dword_1ED7F2630 = 0;
  qword_1ED7F2638 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F2640 = 0;
  qword_1ED7F25B0 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F2648 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F2650 = (uint64_t)&off_1E7F95260;
  qword_1ED7F2668 = (uint64_t)&qword_1ED7F2650;
  llvm::cl::Option::setArgStr(v6, "max-dependences", 0xFuLL);
  word_1ED7F25BA = (32 * (*a1 & 3)) | word_1ED7F25BA & 0xFF9F;
  xmmword_1ED7F25D0 = *a2;
  dword_1ED7F2630 = **a3;
  byte_1ED7F2644 = 1;
  dword_1ED7F2640 = dword_1ED7F2630;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F25B0);
}

void sub_1C619F408(_WORD *a1, __n128 *a2, char **a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F2730, 0, 0);
  byte_1ED7F27B0 = 0;
  qword_1ED7F27B8 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F27C0 = 0;
  qword_1ED7F2730 = (uint64_t)&unk_1E819E898;
  qword_1ED7F27C8 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F27D0 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F27E8 = (uint64_t)&qword_1ED7F27D0;
  sub_1C4EA2DC8(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F2730);
}

void sub_1C619F4AC(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  int v5;
  unint64_t v6;

  v6 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 48, &v6);
  sub_1C619F51C((uint64_t *)a1, (uint64_t)v3);
  v4 = v6;
  if (*(_QWORD *)a1 != a1 + 16)
  {
    v5 = v6;
    free(*(void **)a1);
    v4 = v5;
  }
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C619F51C(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v5 = 0;
    v6 = *a1;
    v7 = *a1 + 48 * v2;
    do
    {
      v8 = v6 + v5;
      v9 = a2 + v5;
      *(_OWORD *)v9 = *(_OWORD *)(v6 + v5);
      *(_QWORD *)(a2 + v5 + 16) = a2 + v5 + 32;
      *(_QWORD *)(v9 + 24) = 0x200000000;
      if (*(_DWORD *)(v6 + v5 + 24))
        sub_1C4EA2F88(a2 + v5 + 16, v8 + 16);
      *(_DWORD *)(v9 + 40) = *(_DWORD *)(v8 + 40);
      v5 += 48;
    }
    while (v8 + 48 != v7);
    v10 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v10)
    {
      v11 = *a1;
      v12 = 48 * v10;
      do
      {
        v13 = *(void **)(v11 + v12 - 32);
        if ((void *)(v11 + v12 - 16) != v13)
          free(v13);
        v12 -= 48;
      }
      while (v12);
    }
  }
}

uint64_t sub_1C619F5FC(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t result;

  v3 = sub_1C4EA2F20(a1, a2);
  v4 = *(_QWORD *)a1;
  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_QWORD *)a1 + 48 * v5;
  *(_OWORD *)v6 = *(_OWORD *)v3;
  *(_QWORD *)(v6 + 24) = 0x200000000;
  *(_QWORD *)(v6 + 16) = v6 + 32;
  result = v6 + 16;
  if (*(_DWORD *)(v3 + 24))
    result = sub_1C4EA3168(result, v3 + 16);
  *(_DWORD *)(v4 + 48 * v5 + 40) = *(_DWORD *)(v3 + 40);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1C619F680(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v11;
  _QWORD *v12;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 32 * v6;
    do
    {
      *v7 = -4;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if (*(_QWORD *)a2 != -16 && v9 != -4)
    {
      v12 = 0;
      result = sub_1C4EA2C2C(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      v11 = v12;
      *v12 = *(_QWORD *)a2;
      v11[1] = 0;
      v11[2] = 0;
      v11[3] = 0;
      *(_OWORD *)(v11 + 1) = *(_OWORD *)(a2 + 8);
      v11[3] = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

_QWORD *sub_1C619F740(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4E5818C(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C619F79C((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C619F79C(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_3:
    sub_1C4EA3D04(a1, v7);
    v9 = 0;
    sub_1C4E5818C((uint64_t *)a1, a3, &v9);
    a4 = v9;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
    goto LABEL_3;
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C619F84C(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v10 = 0;
      result = sub_1C4E5818C((uint64_t *)v5, a2, &v10);
      v9 = v10;
      *v10 = *a2;
      v9[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

_QWORD *sub_1C619F8F8(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C6144BDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C619F960(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C619F960(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EA3F64(a1, v6);
  v8 = 0;
  sub_1C6144BDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C619FA10(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v13 = 0;
      sub_1C6144BDC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v13);
      v10 = v13;
      *v13 = *a2;
      v11 = a2[1];
      a2[1] = 0;
      v10[1] = v11;
      ++*(_DWORD *)(v5 + 8);
      result = a2[1];
      a2[1] = 0;
      if (result)
      {
        v12 = sub_1C4EA401C((uint64_t *)result);
        result = MEMORY[0x1CAA32FC0](v12, 0x10E0C402B7C74A4);
      }
    }
    a2 += 2;
  }
  return result;
}

BOOL llvm::IndexedReference::isAliased(uint64_t ****this, uint64_t ****a2, llvm::AAResults *a3)
{
  _OWORD v6[3];
  _OWORD v7[3];
  __int128 v8;
  __int128 v9;
  __int128 v10;

  llvm::MemoryLocation::getOrNone(this[1], (uint64_t)&v8);
  v7[0] = v8;
  v7[1] = v9;
  v7[2] = v10;
  llvm::MemoryLocation::getOrNone(a2[1], (uint64_t)&v8);
  v6[0] = v8;
  v6[1] = v9;
  v6[2] = v10;
  return llvm::AAResults::alias((uint64_t)a3, (uint64_t)v7, (uint64_t)v6) == 3;
}

uint64_t llvm::IndexedReference::isLoopInvariant(llvm::IndexedReference *this, const llvm::Loop *a2)
{
  uint64_t v4;
  int v5;
  BOOL v6;
  llvm::Value *v7;
  uint64_t v8;
  llvm::ScalarEvolution *v9;
  const llvm::SCEV *SCEV;
  uint64_t result;
  uint64_t v12;
  const llvm::Loop ***v13;
  uint64_t v14;
  const llvm::Loop **v15;

  v4 = *((_QWORD *)this + 1);
  v5 = *(unsigned __int8 *)(v4 + 16);
  if (v4)
    v6 = (v5 - 62) > 0xFFFFFFFD;
  else
    v6 = 0;
  if (v6)
  {
    v8 = -1;
  }
  else
  {
    v7 = 0;
    if (!v4 || v5 != 62)
      goto LABEL_10;
    v8 = -(uint64_t)(*(_DWORD *)(v4 + 20) & 0x7FFFFFF);
  }
  v7 = *(llvm::Value **)(v4 + 32 * v8);
LABEL_10:
  v9 = (llvm::ScalarEvolution *)*((_QWORD *)this + 13);
  SCEV = (const llvm::SCEV *)llvm::ScalarEvolution::getSCEV(v9, v7);
  result = llvm::ScalarEvolution::getLoopDisposition(v9, SCEV, a2);
  if ((_DWORD)result == 1)
    return result;
  v12 = *((unsigned int *)this + 8);
  if (!(_DWORD)v12)
    return 1;
  v13 = (const llvm::Loop ***)*((_QWORD *)this + 3);
  v14 = 8 * v12;
  while (1)
  {
    v15 = *v13;
    if (*((_WORD *)*v13 + 12) != 7)
      break;
    if (v15[6] == a2)
      return 0;
LABEL_17:
    ++v13;
    v14 -= 8;
    if (!v14)
      return 1;
  }
  if (llvm::ScalarEvolution::getLoopDisposition(*((llvm::ScalarEvolution **)this + 13), (const llvm::SCEV *)v15, a2) == 1)goto LABEL_17;
  return 0;
}

BOOL llvm::IndexedReference::isSimpleAddRecurrence(llvm::ScalarEvolution **this, const llvm::SCEV *a2, const llvm::Loop *a3)
{
  const llvm::SCEV *v5;
  const llvm::SCEV *v6;

  if (*((_WORD *)a2 + 12) == 7
    && *((_QWORD *)a2 + 5) == 2
    && (v5 = (const llvm::SCEV *)**((_QWORD **)a2 + 4),
        v6 = (const llvm::SCEV *)sub_1C4E0C3BC((uint64_t)a2, (uint64_t *)this[13]),
        llvm::ScalarEvolution::getLoopDisposition(this[13], v5, a3) == 1))
  {
    return llvm::ScalarEvolution::getLoopDisposition(this[13], v6, a3) == 1;
  }
  else
  {
    return 0;
  }
}

void llvm::CacheCost::getCacheCost(_QWORD *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  _QWORD **v9;
  uint64_t v10;
  uint64_t v11;
  llvm::ScalarEvolution *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  void *v17[38];
  _QWORD **v18;
  uint64_t v19;
  _QWORD v20[9];

  v20[8] = *MEMORY[0x1E0C80C00];
  if (*a1)
  {
    *a5 = 0;
  }
  else
  {
    v18 = (_QWORD **)v20;
    v19 = 0x800000000;
    v16 = a1;
    sub_1C619FF38((uint64_t *)&v16, (uint64_t)v17);
    sub_1C619FE58((unsigned int *)&v18, (llvm::SmallPtrSetImplBase *)v17);
    sub_1C61A01F4(v17);
    v9 = v18;
    v10 = (uint64_t)sub_1C4EA7C50(v18, v19);
    if (v10)
    {
      v11 = a2[3];
      v12 = (llvm::ScalarEvolution *)a2[4];
      v13 = a2[6];
      v14 = *a2;
      v15 = operator new();
      v10 = llvm::CacheCost::CacheCost(v15, (uint64_t)&v18, v11, v12, v13, v14, a3, a4);
      v9 = v18;
    }
    *a5 = v10;
    if (v9 != v20)
      free(v9);
  }
}

void sub_1C619FE58(unsigned int *a1, llvm::SmallPtrSetImplBase *a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  const void *v7;
  _DWORD v8[14];
  void *v9;
  void *v10;
  const void *v11;
  _DWORD v12[14];

  v4 = *(_QWORD *)a1 + 8 * a1[2];
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v9, &v11, a2);
  sub_1C4EA93E4((uint64_t)v12, (_QWORD *)a2 + 12);
  v12[12] = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v5, &v7, (llvm::SmallPtrSetImplBase *)((char *)a2 + 152));
  sub_1C4EA93E4((uint64_t)v8, (_QWORD *)a2 + 31);
  v8[12] = *((_DWORD *)a2 + 74);
  sub_1C61A0528(a1, v4, (llvm::SmallPtrSetImplBase *)&v9, &v5);
  sub_1C4EA7FDC((uint64_t)v8);
  if (v6 != v5)
    free(v6);
  sub_1C4EA7FDC((uint64_t)v12);
  if (v10 != v9)
    free(v10);
}

void sub_1C619FF38(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  char *v3;
  char *v4;
  uint64_t v5;
  _OWORD v6[8];
  void *v7;
  void *v8;
  uint64_t v9;

  sub_1C61A03E0((uint64_t)&v7, *a1);
  memset(v6, 0, sizeof(v6));
  v3 = (char *)v6 + 8;
  v4 = (char *)v6 + 8;
  v5 = 8;
  sub_1C61A0244((uint64_t)&v7, (uint64_t)&v3, a2);
  sub_1C4EA7FDC((uint64_t)&v6[4] + 8);
  if (v4 != v3)
    free(v4);
  sub_1C4EA7FDC((uint64_t)&v9);
  if (v8 != v7)
    free(v8);
}

uint64_t llvm::CacheCost::computeLoopCacheCost(uint64_t a1, llvm::Loop *this, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  llvm::ScalarEvolution ****v12;
  uint64_t v13;
  llvm::ScalarEvolution ***v14;
  llvm::ScalarEvolution **v15;

  if (!llvm::Loop::isLoopSimplifyForm(this))
    return -1;
  v6 = *(unsigned int *)(a1 + 88);
  if ((_DWORD)v6)
  {
    v7 = 16 * v6;
    v8 = (unsigned int *)(*(_QWORD *)(a1 + 80) + 8);
    v9 = 1;
    do
    {
      if (*((llvm::Loop **)v8 - 1) != this)
        v9 *= *v8;
      v8 += 4;
      v7 -= 16;
    }
    while (v7);
  }
  else
  {
    v9 = 1;
  }
  v10 = *(unsigned int *)(a3 + 8);
  if (!(_DWORD)v10)
    return 0;
  v11 = 0;
  v12 = *(llvm::ScalarEvolution *****)a3;
  v13 = 80 * v10;
  do
  {
    v14 = *v12;
    v12 += 10;
    v15 = *v14;
    (*(void (**)(_QWORD))(***(_QWORD ***)(a1 + 232) + 760))(**(_QWORD **)(a1 + 232));
    v11 += llvm::IndexedReference::computeRefCost(v15, this) * v9;
    v13 -= 80;
  }
  while (v13);
  return v11;
}

_QWORD *sub_1C61A00EC(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  _QWORD *result;

  v3 = sub_1C4EAB3A8(a1, a2);
  result = (_QWORD *)(*(_QWORD *)a1 + 80 * *(unsigned int *)(a1 + 8));
  *result = result + 2;
  result[1] = 0x800000000;
  if (*(_DWORD *)(v3 + 8))
    result = (_QWORD *)sub_1C4EAB410((uint64_t)result, v3);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

_QWORD *llvm::LoopCachePrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int8x16_t v12;
  uint64_t v13;

  v6 = *(_QWORD *)(**(_QWORD **)(a2 + 32) + 56);
  v11 = *(_QWORD *)a3;
  v12 = vextq_s8(*(int8x16_t *)(a3 + 24), *(int8x16_t *)(a3 + 24), 8uLL);
  v13 = v6;
  llvm::CacheCost::getCacheCost((_QWORD *)a2, (uint64_t *)a3, (uint64_t)&v11, 0, &v10);
  v7 = v10;
  if (v10)
  {
    llvm::operator<<(*a1, v10);
    v9 = sub_1C61A0D8C(v7);
    MEMORY[0x1CAA32FC0](v9, 0x10E0C40BBC1AD8BLL);
  }
  return llvm::InstCountPass::run(a4);
}

void **sub_1C61A01F4(void **a1)
{
  void *v2;
  void *v3;

  sub_1C4EA7FDC((uint64_t)(a1 + 31));
  v2 = a1[20];
  if (v2 != a1[19])
    free(v2);
  sub_1C4EA7FDC((uint64_t)(a1 + 12));
  v3 = a1[1];
  if (v3 != *a1)
    free(v3);
  return a1;
}

void sub_1C61A0244(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  const void *v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  _BYTE *v15;
  int v16;
  int v17;
  int v18;
  _BYTE v19[64];
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  int v24;
  _BYTE *v25;
  _BYTE *v26;
  int v27;
  int v28;
  int v29;
  _BYTE v30[64];
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  int v35;

  v25 = v30;
  v7 = *(const void **)a1;
  v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    v26 = v30;
    v8 = *(unsigned int *)(a1 + 20);
    if ((_DWORD)v8)
      memmove(v30, v6, 8 * v8);
  }
  else
  {
    v26 = *(_BYTE **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  v27 = *(_DWORD *)(a1 + 16);
  v28 = v8;
  v29 = *(_DWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  v31 = *(_OWORD *)(a1 + 96);
  v9 = *(_QWORD *)(a1 + 120);
  v32 = *(_QWORD *)(a1 + 112);
  v33 = v9;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  v34 = *(_OWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  v35 = *(_DWORD *)(a1 + 144);
  v14 = v19;
  v11 = *(const void **)a2;
  v10 = *(const void **)(a2 + 8);
  if (v10 == *(const void **)a2)
  {
    v15 = v19;
    v12 = *(unsigned int *)(a2 + 20);
    if ((_DWORD)v12)
      memmove(v19, v10, 8 * v12);
  }
  else
  {
    v15 = *(_BYTE **)(a2 + 8);
    *(_QWORD *)(a2 + 8) = v11;
    LODWORD(v12) = *(_DWORD *)(a2 + 20);
  }
  v16 = *(_DWORD *)(a2 + 16);
  v17 = v12;
  v18 = *(_DWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  v20 = *(_OWORD *)(a2 + 96);
  v13 = *(_QWORD *)(a2 + 120);
  v21 = *(_QWORD *)(a2 + 112);
  v22 = v13;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  v23 = *(_OWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 136) = 0;
  v24 = *(_DWORD *)(a2 + 144);
  sub_1C4EA8B08(a3, (uint64_t *)&v25, (uint64_t *)&v14);
  sub_1C4EA7FDC((uint64_t)&v20);
  if (v15 != v14)
    free(v15);
  sub_1C4EA7FDC((uint64_t)&v31);
  if (v26 != v25)
    free(v26);
}

uint64_t sub_1C61A03E0(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  __int128 v6;
  char v7;
  char v8;

  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 32;
  *(_QWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  v4 = (_QWORD *)(a1 + 96);
  sub_1C4774094((llvm::SmallPtrSetImplBase *)a1, a2);
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)&v6 = a2;
  BYTE8(v6) = 0;
  v7 = 0;
  v8 = 1;
  sub_1C61A047C(v4, &v6);
  LOBYTE(v6) = 0;
  v8 = 0;
  sub_1C61A047C(v4, &v6);
  return a1;
}

void sub_1C61A047C(_QWORD *a1, __int128 *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1C4EA8C70((uint64_t)a1);
    v5 = a1[1];
    v7 = a1[4] + a1[5];
  }
  v8 = *(_QWORD *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F);
  *(_BYTE *)v8 = 0;
  *(_BYTE *)(v8 + 24) = 0;
  if (*((_BYTE *)a2 + 24))
  {
    v9 = *a2;
    *(_QWORD *)(v8 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v8 = v9;
    *(_BYTE *)(v8 + 24) = 1;
  }
  ++a1[5];
}

char *sub_1C61A0528(unsigned int *a1, uint64_t a2, llvm::SmallPtrSetImplBase *a3, _DWORD *a4)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  char *v10;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  char *v18;
  void *v19;
  void *v20;
  char *v21;
  void *v22;
  void *v23;
  const void *v24;
  _DWORD v25[14];
  _QWORD v26[4];
  const void *v27;
  _DWORD v28[14];
  void *v29;
  void *v30;
  const void *v31;
  _DWORD v32[14];
  _QWORD v33[4];
  const void *v34;
  _DWORD v35[14];
  void *v36;
  void *v37;
  const void *v38;
  _DWORD v39[14];
  void *v40;
  void *v41;
  const void *v42;
  _DWORD v43[14];
  void *v44;
  void *v45;
  const void *v46;
  _DWORD v47[14];
  void *v48;
  void *v49;
  const void *v50;
  _DWORD v51[14];
  void *v52;
  void *v53;
  const void *v54;
  _DWORD v55[14];
  void *v56;
  void *v57;
  const void *v58;
  _DWORD v59[16];

  v7 = (a2 - *(_QWORD *)a1) >> 3;
  v8 = (_QWORD *)((char *)a3 + 96);
  v9 = a4 + 24;
  if (*(_QWORD *)a1 + 8 * a1[2] == a2)
  {
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v56, &v58, a3);
    sub_1C4EA93E4((uint64_t)v59, v8);
    v59[12] = *((_DWORD *)a3 + 36);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v52, &v54, (const llvm::SmallPtrSetImplBase *)a4);
    sub_1C4EA93E4((uint64_t)v55, v9);
    v55[12] = a4[36];
    sub_1C61A0954((uint64_t)a1, (llvm::SmallPtrSetImplBase *)&v56, (uint64_t)&v52);
    sub_1C4EA7FDC((uint64_t)v55);
    if (v53 != v52)
      free(v53);
    sub_1C4EA7FDC((uint64_t)v59);
    if (v57 != v56)
      free(v57);
    return (char *)(*(_QWORD *)a1 + 8 * v7);
  }
  else
  {
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v48, &v50, a3);
    sub_1C4EA93E4((uint64_t)v51, v8);
    v51[12] = *((_DWORD *)a3 + 36);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v44, &v46, (const llvm::SmallPtrSetImplBase *)a4);
    v12 = sub_1C4EA93E4((uint64_t)v47, v9);
    v47[12] = a4[36];
    sub_1C4EA7FDC(v12);
    if (v45 != v44)
      free(v45);
    sub_1C4EA7FDC((uint64_t)v51);
    if (v49 != v48)
      free(v49);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v40, &v42, a3);
    sub_1C4EA93E4((uint64_t)v43, v8);
    v43[12] = *((_DWORD *)a3 + 36);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v36, &v38, (const llvm::SmallPtrSetImplBase *)a4);
    sub_1C4EA93E4((uint64_t)v39, v9);
    v39[12] = a4[36];
    v13 = sub_1C4EA8F38((uint64_t)&v40, (uint64_t)&v36);
    sub_1C4EA7FDC((uint64_t)v39);
    if (v37 != v36)
      free(v37);
    sub_1C4EA7FDC((uint64_t)v43);
    if (v41 != v40)
      free(v41);
    v14 = a1[2];
    if (v13 + v14 > a1[3])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v13 + v14, 8);
      v14 = a1[2];
    }
    v15 = *(_QWORD *)a1;
    v10 = (char *)(*(_QWORD *)a1 + 8 * v7);
    v16 = (char *)(*(_QWORD *)a1 + 8 * v14);
    v17 = (v16 - v10) >> 3;
    if (v17 >= v13)
    {
      v21 = &v16[-8 * v13];
      sub_1C6177054(a1, v21, (char *)(*(_QWORD *)a1 + 8 * v14));
      if (v21 != v10)
        memmove(&v16[-(v21 - v10)], v10, v21 - v10);
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)v33, &v34, a3);
      sub_1C4EA93E4((uint64_t)v35, v8);
      v35[12] = *((_DWORD *)a3 + 36);
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v29, &v31, (const llvm::SmallPtrSetImplBase *)a4);
      sub_1C4EA93E4((uint64_t)v32, v9);
      v32[12] = a4[36];
      sub_1C4EA91EC((uint64_t)v33, (uint64_t)&v29, v10);
      sub_1C4EA7FDC((uint64_t)v32);
      if (v30 != v29)
        free(v30);
      sub_1C4EA7FDC((uint64_t)v35);
      v20 = (void *)v33[0];
      v19 = (void *)v33[1];
    }
    else
    {
      a1[2] = v14 + v13;
      if (v7 != v14)
      {
        memcpy((void *)(v15 + 8 * (v14 + v13) - 8 * v17), v10, v16 - v10);
        v18 = v10;
        do
        {
          *(_QWORD *)v18 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a3 + 13)
                                                 + ((*((_QWORD *)a3 + 16) >> 4) & 0xFFFFFFFFFFFFFF8))
                                     + 32 * (*((_QWORD *)a3 + 16) & 0x7FLL));
          v18 += 8;
          sub_1C61A0C64(a3);
          --v17;
        }
        while (v17);
      }
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)v26, &v27, a3);
      sub_1C4EA93E4((uint64_t)v28, v8);
      v28[12] = *((_DWORD *)a3 + 36);
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v22, &v24, (const llvm::SmallPtrSetImplBase *)a4);
      sub_1C4EA93E4((uint64_t)v25, v9);
      v25[12] = a4[36];
      sub_1C61A0B90((llvm::SmallPtrSetImplBase *)v26, (uint64_t)&v22, v16);
      sub_1C4EA7FDC((uint64_t)v25);
      if (v23 != v22)
        free(v23);
      sub_1C4EA7FDC((uint64_t)v28);
      v20 = (void *)v26[0];
      v19 = (void *)v26[1];
    }
    if (v19 != v20)
      free(v19);
  }
  return v10;
}

void sub_1C61A0954(uint64_t a1, llvm::SmallPtrSetImplBase *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  void *v10;
  const void *v11;
  _DWORD v12[14];
  void *v13;
  void *v14;
  const void *v15;
  _DWORD v16[14];
  void *v17;
  void *v18;
  const void *v19;
  _DWORD v20[14];
  void *v21;
  void *v22;
  const void *v23;
  _DWORD v24[14];
  void *v25;
  void *v26;
  const void *v27;
  _DWORD v28[14];
  void *v29;
  void *v30;
  const void *v31;
  _DWORD v32[14];

  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v29, &v31, a2);
  sub_1C4EA93E4((uint64_t)v32, (_QWORD *)a2 + 12);
  v32[12] = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v25, &v27, (const llvm::SmallPtrSetImplBase *)a3);
  v6 = sub_1C4EA93E4((uint64_t)v28, (_QWORD *)(a3 + 96));
  v28[12] = *(_DWORD *)(a3 + 144);
  sub_1C4EA7FDC(v6);
  if (v26 != v25)
    free(v26);
  sub_1C4EA7FDC((uint64_t)v32);
  if (v30 != v29)
    free(v30);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v21, &v23, a2);
  sub_1C4EA93E4((uint64_t)v24, (_QWORD *)a2 + 12);
  v24[12] = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v17, &v19, (const llvm::SmallPtrSetImplBase *)a3);
  sub_1C4EA93E4((uint64_t)v20, (_QWORD *)(a3 + 96));
  v20[12] = *(_DWORD *)(a3 + 144);
  v7 = sub_1C4EA8F38((uint64_t)&v21, (uint64_t)&v17);
  sub_1C4EA7FDC((uint64_t)v20);
  if (v18 != v17)
    free(v18);
  sub_1C4EA7FDC((uint64_t)v24);
  if (v22 != v21)
    free(v22);
  v8 = v7 + *(unsigned int *)(a1 + 8);
  if (v8 > *(unsigned int *)(a1 + 12))
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v8, 8);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v13, &v15, a2);
  sub_1C4EA93E4((uint64_t)v16, (_QWORD *)a2 + 12);
  v16[12] = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v9, &v11, (const llvm::SmallPtrSetImplBase *)a3);
  sub_1C4EA93E4((uint64_t)v12, (_QWORD *)(a3 + 96));
  v12[12] = *(_DWORD *)(a3 + 144);
  sub_1C61A0B90((llvm::SmallPtrSetImplBase *)&v13, (uint64_t)&v9, (_QWORD *)(*(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 8)));
  sub_1C4EA7FDC((uint64_t)v12);
  if (v10 != v9)
    free(v10);
  sub_1C4EA7FDC((uint64_t)v16);
  if (v14 != v13)
    free(v14);
  *(_DWORD *)(a1 + 8) += v7;
}

void sub_1C61A0B90(llvm::SmallPtrSetImplBase *a1, uint64_t a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  const void *v8;
  _DWORD v9[14];
  void *v10;
  void *v11;
  const void *v12;
  _DWORD v13[14];

  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v10, &v12, a1);
  sub_1C4EA93E4((uint64_t)v13, (_QWORD *)a1 + 12);
  v13[12] = *((_DWORD *)a1 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v6, &v8, (const llvm::SmallPtrSetImplBase *)a2);
  sub_1C4EA93E4((uint64_t)v9, (_QWORD *)(a2 + 96));
  v9[12] = *(_DWORD *)(a2 + 144);
  sub_1C4EAAFB0((uint64_t)&v10, (uint64_t)&v6, a3);
  sub_1C4EA7FDC((uint64_t)v9);
  if (v7 != v6)
    free(v7);
  sub_1C4EA7FDC((uint64_t)v13);
  if (v11 != v10)
    free(v11);
}

void sub_1C61A0C64(llvm::SmallPtrSetImplBase *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  __int128 v9;
  char v10;
  char v11;

  v2 = (_QWORD *)((char *)this + 96);
  v3 = *(_QWORD *)(*((_QWORD *)this + 13) + ((*((_QWORD *)this + 16) >> 4) & 0xFFFFFFFFFFFFFF8))
     + 32 * (*((_QWORD *)this + 16) & 0x7FLL);
  v4 = *(_QWORD *)v3;
  if (!*(_BYTE *)(v3 + 16))
    v3 = *(_QWORD *)v3;
  v5 = *(uint64_t **)(v3 + 8);
  while (v5 != *(uint64_t **)(v4 + 16))
  {
    v7 = *v5++;
    v6 = v7;
    sub_1C4774094(this, v7);
    if (v8)
    {
      *(_QWORD *)&v9 = v6;
      BYTE8(v9) = 0;
      v10 = 0;
      v11 = 1;
      sub_1C61A047C(v2, &v9);
    }
  }
  sub_1C4EAAF34(v2);
  if (*((_QWORD *)this + 17)
    && !*(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 13) + ((*((_QWORD *)this + 16) >> 4) & 0xFFFFFFFFFFFFFF8))
                 + 32 * (*((_QWORD *)this + 16) & 0x7FLL)
                 + 24))
  {
    ++*((_DWORD *)this + 36);
    sub_1C4EAAF34(v2);
    if (*((_QWORD *)this + 17))
    {
      LOBYTE(v9) = 0;
      v11 = 0;
      sub_1C61A047C(v2, &v9);
    }
  }
}

uint64_t sub_1C61A0D8C(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 144);
  if (v2 != (void *)(a1 + 160))
    free(v2);
  v3 = *(void **)(a1 + 80);
  if (v3 != (void *)(a1 + 96))
    free(v3);
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  return a1;
}

void sub_1C61A0DE8(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 8, &v5);
  sub_1C61A0E54((uint64_t **)a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

uint64_t **sub_1C61A0E54(uint64_t **result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *((unsigned int *)result + 2);
  if ((_DWORD)v2)
  {
    v3 = *result;
    v4 = 8 * v2;
    v5 = 8 * v2;
    do
    {
      v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    v7 = (uint64_t)(*result - 1);
    do
    {
      result = *(uint64_t ***)(v7 + v4);
      *(_QWORD *)(v7 + v4) = 0;
      if (result)
        result = (uint64_t **)sub_1C4EAB348(result);
      v4 -= 8;
    }
    while (v4);
  }
  return result;
}

char **sub_1C61A0EB4(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  _QWORD *v6;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *(_QWORD **)&v5[v4];
      *(_QWORD *)&v5[v4] = 0;
      if (v6)
        sub_1C4EAB348(v6);
      v4 -= 8;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

void sub_1C61A0F1C(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 80, &v5);
  sub_1C61A0F88(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

uint64_t sub_1C61A0F88(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(unsigned int *)(result + 8);
  if ((_DWORD)v2)
  {
    v4 = result;
    v5 = *(_QWORD *)result;
    v6 = 80 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x800000000;
      if (*(_DWORD *)(v5 + 8))
        result = sub_1C4EAB410((uint64_t)a2, v5);
      v5 += 80;
      a2 += 10;
      v6 -= 80;
    }
    while (v6);
    v7 = *(unsigned int *)(v4 + 8);
    if ((_DWORD)v7)
    {
      v8 = *(_QWORD *)v4;
      v9 = 80 * v7;
      v10 = v8 - 80;
      do
      {
        result = (uint64_t)sub_1C61A0EB4((char **)(v10 + v9));
        v9 -= 80;
      }
      while (v9);
    }
  }
  return result;
}

double sub_1C61A102C(char **a1, char **a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  _QWORD *v8;
  double result;

  v4 = *a1;
  v5 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v5)
  {
    v6 = 8 * v5;
    v7 = v4 - 8;
    do
    {
      v8 = *(_QWORD **)&v7[v6];
      *(_QWORD *)&v7[v6] = 0;
      if (v8)
        sub_1C4EAB348(v8);
      v6 -= 8;
    }
    while (v6);
    v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2))
    free(v4);
  *a1 = *a2;
  result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

llvm::LoopNest *llvm::LoopNest::LoopNest(llvm::LoopNest *this, llvm::Loop *a2, llvm::ScalarEvolution *a3, llvm::ScalarEvolution *a4)
{
  int v7;
  llvm::Loop *v8;
  const llvm::Loop **v9;
  const llvm::Loop *v10;
  int v11;
  llvm::Loop *v13;
  void *v14[38];

  v7 = 1;
  v8 = a2;
  while (1)
  {
    v9 = (const llvm::Loop **)*((_QWORD *)v8 + 1);
    if (*((_QWORD *)v8 + 2) - (_QWORD)v9 != 8)
      break;
    v10 = *v9;
    v11 = llvm::LoopNest::analyzeLoopNestForPerfectNest(v8, *v9, a3, a4);
    ++v7;
    v8 = v10;
    if (v11)
    {
      --v7;
      break;
    }
  }
  *(_DWORD *)this = v7;
  *((_QWORD *)this + 1) = (char *)this + 24;
  *((_QWORD *)this + 2) = 0x800000000;
  v13 = a2;
  sub_1C619FF38((uint64_t *)&v13, (uint64_t)v14);
  sub_1C619FE58((unsigned int *)this + 2, (llvm::SmallPtrSetImplBase *)v14);
  sub_1C61A01F4(v14);
  return this;
}

llvm::LoopNest *llvm::LoopNest::getLoopNest@<X0>(llvm::LoopNest *this@<X0>, llvm::Loop *a2@<X1>, llvm::LoopNest **a3@<X8>)
{
  llvm::LoopNest *v7;
  llvm::ScalarEvolution *v8;
  llvm::LoopNest *result;

  v7 = (llvm::LoopNest *)operator new();
  result = llvm::LoopNest::LoopNest(v7, this, a2, v8);
  *a3 = result;
  return result;
}

_QWORD *llvm::LoopNestPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, llvm::Loop *a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  llvm::ScalarEvolution *v7;
  llvm::LoopNest *v8;
  llvm::ScalarEvolution *v9;
  llvm::raw_ostream *v10;
  _QWORD *v11;

  v7 = *(llvm::ScalarEvolution **)(a3 + 32);
  v8 = (llvm::LoopNest *)operator new();
  llvm::LoopNest::LoopNest(v8, a2, v7, v9);
  v10 = llvm::operator<<(*a1, (int *)v8);
  sub_1C4816AD8(v10, "\n");
  v11 = (_QWORD *)*((_QWORD *)v8 + 1);
  if (v11 != (_QWORD *)((char *)v8 + 24))
    free(v11);
  MEMORY[0x1CAA32FC0](v8, 0x1080C40AE5A6257);
  return llvm::InstCountPass::run(a4);
}

uint64_t sub_1C61A126C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  unsigned int v6;

  v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
    return sub_1C4EB69AC(a1, *a2, *a3);
  v4 = *(_QWORD *)a1;
  v5 = (uint64_t *)(*(_QWORD *)a1 + 16 * v3);
  *v5 = *a2;
  v5[1] = *a3;
  v6 = v3 + 1;
  *(_DWORD *)(a1 + 8) = v6;
  return v4 + 16 * v6 - 16;
}

uint64_t llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::replaceChildLoopWith(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3;
  _QWORD *v4;

  v3 = *(_QWORD **)(result + 8);
  v4 = *(_QWORD **)(result + 16);
  if (v3 != v4)
  {
    while ((_QWORD *)*v3 != a2)
    {
      if (++v3 == v4)
      {
        v3 = *(_QWORD **)(result + 16);
        break;
      }
    }
  }
  *v3 = a3;
  *a2 = 0;
  *a3 = result;
  return result;
}

uint64_t llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::verifyLoopNest(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE v9[24];

  v8 = a1;
  result = sub_1C6190580((uint64_t)v9, a2, &v8);
  v6 = *(uint64_t **)(a1 + 8);
  v5 = *(uint64_t **)(a1 + 16);
  while (v6 != v5)
  {
    v7 = *v6++;
    result = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::verifyLoopNest(v7, a2);
  }
  return result;
}

{
  return __ZNK4llvm8LoopBaseINS_10BasicBlockENS_4LoopEE14verifyLoopNestEPNS_8DenseSetIPKS2_NS_12DenseMapInfoIS6_vEEEE(a1, a2);
}

uint64_t llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(llvm::Loop *a1, llvm::raw_ostream *a2, int a3, char a4, int a5)
{
  llvm::raw_ostream *v8;
  unint64_t v9;
  llvm::Loop *v10;
  llvm::raw_ostream *v11;
  uint64_t result;
  llvm::Value **v13;
  unint64_t v14;
  unsigned int v15;
  llvm::Value *v16;
  llvm::Value *v17;
  uint64_t *i;
  uint64_t *v19;
  uint64_t v20;

  llvm::raw_ostream::indent(a2, 2 * a5);
  if (llvm::Loop::isAnnotatedParallel(a1))
    sub_1C4816AD8(a2, "Parallel ");
  v8 = sub_1C4816AD8(a2, "Loop at depth ");
  LODWORD(v9) = 0;
  v10 = a1;
  do
  {
    v10 = *(llvm::Loop **)v10;
    v9 = (v9 + 1);
  }
  while (v10);
  v11 = llvm::raw_ostream::operator<<(v8, v9);
  result = (uint64_t)sub_1C4816AD8(v11, " containing: ");
  v13 = (llvm::Value **)*((_QWORD *)a1 + 4);
  if (*((llvm::Value ***)a1 + 5) != v13)
  {
    v14 = 0;
    v15 = 1;
    v16 = *v13;
    do
    {
      v17 = v13[v14];
      if ((a3 & 1) != 0)
      {
        sub_1C4816AD8(a2, "\n");
      }
      else
      {
        if (v15 != 1)
          sub_1C4816AD8(a2, ",");
        llvm::Value::printAsOperand(v17, a2, 0, 0);
      }
      if (v17 == v16)
        sub_1C4816AD8(a2, "<header>");
      if (llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::isLoopLatch((uint64_t)a1, (uint64_t)v17))
        sub_1C4816AD8(a2, "<latch>");
      result = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::isLoopExiting((uint64_t)a1, (uint64_t)v17);
      if ((_DWORD)result)
        result = (uint64_t)sub_1C4816AD8(a2, "<exiting>");
      if (a3)
        result = (uint64_t)llvm::BasicBlock::print(v17, a2, 0, 0, 0);
      v14 = v15;
      v13 = (llvm::Value **)*((_QWORD *)a1 + 4);
      ++v15;
    }
    while (v14 < (uint64_t)(*((_QWORD *)a1 + 5) - (_QWORD)v13) >> 3);
  }
  if ((a4 & 1) != 0)
  {
    result = (uint64_t)sub_1C4816AD8(a2, "\n");
    v19 = (uint64_t *)*((_QWORD *)a1 + 1);
    for (i = (uint64_t *)*((_QWORD *)a1 + 2);
          v19 != i;
          result = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(v20, a2, 0, 1, (a5 + 2)))
    {
      v20 = *v19++;
    }
  }
  return result;
}

{
  return __ZNK4llvm8LoopBaseINS_10BasicBlockENS_4LoopEE5printERNS_11raw_ostreamEbbj(a1, a2, a3, a4, a5);
}

uint64_t llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::verify(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[2];
  int v7;

  v6[0] = 0;
  v6[1] = 0;
  v7 = 0;
  v1 = *(uint64_t **)(a1 + 24);
  v2 = *(uint64_t **)(a1 + 32);
  if (v1 == v2)
  {
    v4 = 0;
  }
  else
  {
    do
    {
      v3 = *v1++;
      llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::verifyLoopNest(v3, (uint64_t)v6);
    }
    while (v1 != v2);
    v4 = v6[0];
  }
  return MEMORY[0x1CAA32FB4](v4, 8);
}

{
  return __ZNK4llvm12LoopInfoBaseINS_10BasicBlockENS_4LoopEE6verifyERKNS_17DominatorTreeBaseIS1_Lb0EEE(a1);
}

uint64_t llvm::Loop::getLatchCmpInst(llvm::Loop *this)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  result = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch((uint64_t)this);
  if (result)
  {
    v2 = *(_QWORD *)(result + 40);
    if (v2 == result + 40)
      return 0;
    result = 0;
    if (v2)
      v3 = v2 - 24;
    else
      v3 = 0;
    if (*(_BYTE *)(v3 + 16) == 30)
    {
      if ((*(_DWORD *)(v3 + 20) & 0x7FFFFFF) == 3)
      {
        v4 = *(_QWORD *)(v3 - 96);
        if (*(_BYTE *)(v4 + 16) == 81)
          return v4;
        else
          return 0;
      }
      return 0;
    }
  }
  return result;
}

uint64_t llvm::Loop::isLCSSAForm(llvm::Loop *this, const llvm::DominatorTree *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  BOOL v9;

  v2 = (uint64_t *)*((_QWORD *)this + 4);
  v3 = *((_QWORD *)this + 5) - (_QWORD)v2;
  if (!v3)
    return 1;
  v6 = 8 * (v3 >> 3) - 8;
  do
  {
    v7 = *v2++;
    result = sub_1C4EB78B4((uint64_t)this, v7, (uint64_t)a2);
    if ((_DWORD)result)
      v9 = v6 == 0;
    else
      v9 = 1;
    v6 -= 8;
  }
  while (!v9);
  return result;
}

uint64_t llvm::Loop::isRecursivelyLCSSAForm(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *(uint64_t **)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40) - (_QWORD)v3;
  if (!v4)
    return 1;
  v7 = 8 * (v4 >> 3) - 8;
  do
  {
    v8 = *v3++;
    v11 = 0;
    v12 = v8;
    sub_1C4926528(a3, &v12, &v11);
    result = sub_1C4EB78B4(*(_QWORD *)(v11 + 8), v8, a2);
    if ((_DWORD)result)
      v10 = v7 == 0;
    else
      v10 = 1;
    v7 -= 8;
  }
  while (!v10);
  return result;
}

unsigned __int8 *llvm::findOptionMDForLoop(llvm::Loop *a1, void *a2, size_t a3)
{
  uint64_t LoopID;

  LoopID = llvm::Loop::getLoopID(a1);
  return llvm::findOptionMDForLoopID(LoopID, a2, a3);
}

uint64_t llvm::Loop::dump(llvm::Loop *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(this, v2, 0, 1, 0);
}

uint64_t llvm::Loop::dumpVerbose(llvm::Loop *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(this, v2, 1, 1, 0);
}

_QWORD *llvm::LoopPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t ResultImpl;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  llvm::raw_ostream *v10;
  unsigned int v11;

  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::LoopAnalysis::Key, a2);
  v7 = *(_QWORD *)(ResultImpl + 32);
  if (*(_QWORD *)(ResultImpl + 40) != v7)
  {
    v8 = ResultImpl;
    v9 = 0;
    v10 = *a1;
    v11 = 1;
    do
    {
      llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(*(llvm::Loop **)(v7 + 8 * v9), v10, 0, 1, 0);
      v9 = v11;
      v7 = *(_QWORD *)(v8 + 32);
      ++v11;
    }
    while (v9 < (*(_QWORD *)(v8 + 40) - v7) >> 3);
  }
  return llvm::InstCountPass::run(a4);
}

void llvm::printLoop(uint64_t a1, llvm::raw_ostream *a2, uint64_t a3)
{
  int v6;
  char v7;
  BOOL v8;
  const char *v9;
  size_t v10;
  size_t v11;
  const std::string *Module;
  uint64_t LoopPreheader;
  llvm::BasicBlock *v14;
  llvm::BasicBlock **v15;
  uint64_t v16;
  uint64_t v17;
  llvm::BasicBlock **v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[9];

  v22[8] = *MEMORY[0x1E0C80C00];
  v6 = llvm::forcePrintModuleIR((llvm *)a1);
  v7 = *(_BYTE *)(a3 + 23);
  v8 = v7 < 0;
  if (v7 >= 0)
    v9 = (const char *)a3;
  else
    v9 = *(const char **)a3;
  v10 = v7 & 0x7F;
  if (v8)
    v11 = *(_QWORD *)(a3 + 8);
  else
    v11 = v10;
  llvm::raw_ostream::write(a2, v9, v11);
  if (v6)
  {
    sub_1C4816AD8(a2, " (loop: ");
    llvm::Value::printAsOperand(**(llvm::Value ***)(a1 + 32), a2, 0, 0);
    sub_1C4816AD8(a2, ")\n");
    Module = (const std::string *)llvm::BasicBlock::getModule(**(llvm::BasicBlock ***)(a1 + 32));
    llvm::Module::print(Module, a2, 0, 0, 0);
  }
  else
  {
    LoopPreheader = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPreheader(a1);
    if (LoopPreheader)
    {
      v14 = (llvm::BasicBlock *)LoopPreheader;
      sub_1C4816AD8(a2, "\n; Preheader:");
      llvm::BasicBlock::print(v14, a2, 0, 0, 0);
      sub_1C4816AD8(a2, "\n; Loop:");
    }
    v15 = *(llvm::BasicBlock ***)(a1 + 32);
    v16 = *(_QWORD *)(a1 + 40) - (_QWORD)v15;
    if (v16)
    {
      v17 = 8 * (v16 >> 3);
      do
      {
        if (*v15)
          llvm::BasicBlock::print(*v15, a2, 0, 0, 0);
        else
          sub_1C4816AD8(a2, "Printing <null> block");
        ++v15;
        v17 -= 8;
      }
      while (v17);
    }
    v20 = v22;
    v21 = 0x800000000;
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getExitBlocks((_QWORD *)a1, (uint64_t)&v20);
    if ((_DWORD)v21)
    {
      sub_1C4816AD8(a2, "\n; Exit blocks");
      if ((_DWORD)v21)
      {
        v18 = (llvm::BasicBlock **)v20;
        v19 = 8 * v21;
        do
        {
          if (*v18)
            llvm::BasicBlock::print(*v18, a2, 0, 0, 0);
          else
            sub_1C4816AD8(a2, "Printing <null> block");
          ++v18;
          v19 -= 8;
        }
        while (v19);
      }
    }
    if (v20 != v22)
      free(v20);
  }
}

llvm::LoopInfoWrapperPass *llvm::LoopInfoWrapperPass::LoopInfoWrapperPass(llvm::LoopInfoWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::LoopInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E8138E18;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = (char *)this + 112;
  *((_QWORD *)this + 13) = 0x400000000;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 18) = (char *)this + 160;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 21) = 1;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E050);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EB59B4;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E050, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::LoopInfoWrapperPass::verifyAnalysis(uint64_t this)
{
  uint64_t v1;
  char **v2;
  char *v3;

  if (llvm::VerifyLoopInfo)
  {
    v1 = this;
    v2 = **(char ****)(this + 8);
    do
    {
      v3 = *v2;
      v2 += 2;
    }
    while (v3 != llvm::DominatorTreeWrapperPass::ID);
    (*(void (**)(_QWORD, char *))(*(_QWORD *)*(v2 - 1) + 96))(*(v2 - 1), llvm::DominatorTreeWrapperPass::ID);
    return llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::verify(v1 + 32);
  }
  return this;
}

llvm::AnalysisUsage *llvm::LoopInfoWrapperPass::getAnalysisUsage(llvm::LoopInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::DominatorTreeWrapperPass::ID);
}

uint64_t llvm::LoopInfoWrapperPass::print(uint64_t this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;

  v3 = *(_QWORD *)(this + 56);
  if (*(_QWORD *)(this + 64) != v3)
  {
    v5 = this;
    v6 = 0;
    v7 = 1;
    do
    {
      this = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(*(llvm::Loop **)(v3 + 8 * v6), a2, 0, 1, 0);
      v6 = v7;
      v3 = *(_QWORD *)(v5 + 56);
      ++v7;
    }
    while (v6 < (*(_QWORD *)(v5 + 64) - v3) >> 3);
  }
  return this;
}

_QWORD *llvm::LoopVerifierPass::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6;

  v6 = llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::LoopAnalysis::Key, a1) + 8;
  llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::DominatorTreeAnalysis::Key, a1);
  llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::verify(v6);
  return llvm::InstCountPass::run(a3);
}

void sub_1C61A1D14(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E8138E18;
  llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase((_QWORD *)a1 + 4);
  llvm::Pass::~Pass(a1);
}

void sub_1C61A1D44(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E8138E18;
  llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase((_QWORD *)a1 + 4);
  llvm::Pass::~Pass(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A1D88(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  char v11;

  v11 = 0;
  v8 = llvm::cl::parser<BOOL>::parse(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v11);
  if ((v8 & 1) != 0)
    return v8;
  **(_BYTE **)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 184);
  if (v9)
  {
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v9 + 48))(v9, &v11);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C61A1E04();
}

uint64_t sub_1C61A1E04()
{
  return 1;
}

void sub_1C61A1E0C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &unk_1E8138EB8;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_4;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_4:
  sub_1C47A80D0(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A1E80(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1C61A1E8C(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

void sub_1C61A1E9C(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t (**v4)();
  __int16 v5;

  if (a3)
  {
    v3 = **(unsigned __int8 **)(a1 + 128);
LABEL_3:
    v5 = *(_WORD *)(a1 + 144);
    v4 = &off_1E7F9E8D8;
    llvm::cl::parser<BOOL>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, v3 != 0, (uint64_t)&v4, a2);
    return;
  }
  if (*(_BYTE *)(a1 + 145))
  {
    v3 = **(unsigned __int8 **)(a1 + 128);
    if (*(unsigned __int8 *)(a1 + 144) != v3)
      goto LABEL_3;
  }
}

llvm::LoopInfoWrapperPass *llvm::callDefaultCtor<llvm::LoopInfoWrapperPass>()
{
  llvm::LoopInfoWrapperPass *v0;

  v0 = (llvm::LoopInfoWrapperPass *)operator new();
  return llvm::LoopInfoWrapperPass::LoopInfoWrapperPass(v0);
}

llvm::cl::Option *sub_1C61A1F40(llvm::cl::Option *a1, char *a2, _BYTE **a3, _WORD *a4, __n128 *a5)
{
  uint64_t v10;

  v10 = sub_1C47AD050((uint64_t)a1, 0, 0);
  *(_BYTE *)(v10 + 145) = 0;
  *(_QWORD *)(v10 + 128) = 0;
  *(_QWORD *)(v10 + 136) = &off_1E7F9E8D8;
  *(_QWORD *)v10 = &unk_1E8138EB8;
  *(_QWORD *)(v10 + 152) = &off_1E819E9A0;
  *(_QWORD *)(v10 + 160) = &unk_1E8138F20;
  *(_QWORD *)(v10 + 184) = v10 + 160;
  sub_1C61A1FF4(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1C61A1FF4(uint64_t a1, char *__s, _BYTE **a3, _WORD *a4, __n128 *a5)
{
  size_t v10;
  __n128 result;

  v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  sub_1C4EB7838((llvm *)(a1 + 128), (_QWORD *)a1, *a3);
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  result = *a5;
  *(__n128 *)(a1 + 32) = *a5;
  return result;
}

void sub_1C61A207C()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A2090()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_1E8138F20;
  return result;
}

void sub_1C61A20B8(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_1E8138F20;
}

void llvm::LPPassManager::addLoop(llvm::LPPassManager *this, llvm::Loop *a2)
{
  int64x2_t *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char **v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  llvm::Loop *v15;

  v3 = (int64x2_t *)((char *)this + 416);
  if (*(_QWORD *)a2)
  {
    v4 = *((_QWORD *)this + 53);
    if (*((_QWORD *)this + 54) != v4)
    {
      v5 = *((_QWORD *)this + 56);
      v6 = *((_QWORD *)this + 57);
      v7 = (char **)(v4 + 8 * (v5 >> 9));
      v8 = *v7;
      v9 = &(*v7)[8 * (v5 & 0x1FF)];
      v10 = *(_QWORD *)(v4 + (((v6 + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v6 + v5) & 0x1FF);
      while (v9 != (char *)v10)
      {
        v11 = *(_QWORD *)v9;
        v9 += 8;
        v12 = (char *)(v9 - v8);
        if (v11 == *(_QWORD *)a2)
        {
          if (v12 == (char *)4096)
          {
            v14 = v7[1];
            ++v7;
            v9 = v14;
          }
          v15 = a2;
          sub_1C61A2214(v3, (char *)v7, (uint64_t)v9, 1uLL, &v15);
          return;
        }
        if (v12 == (char *)4096)
        {
          v13 = v7[1];
          ++v7;
          v8 = v13;
          v9 = v13;
        }
      }
    }
  }
  else
  {
    v15 = a2;
    sub_1C61A2194(v3, &v15);
  }
}

void sub_1C61A2194(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = a1[4];
  if (!v4)
  {
    sub_1C61A2F38((uint64_t)a1);
    v4 = a1[4];
  }
  v5 = a1[1];
  v6 = (_QWORD *)(v5 + 8 * (v4 >> 9));
  if (a1[2] == v5)
    v7 = 0;
  else
    v7 = *v6 + 8 * (v4 & 0x1FF);
  if (v7 == *v6)
    v7 = *(v6 - 1) + 4096;
  *(_QWORD *)(v7 - 8) = *a2;
  v8 = a1[5] + 1;
  a1[4] = v4 - 1;
  a1[5] = v8;
}

_QWORD *sub_1C61A2214(int64x2_t *a1, char *a2, uint64_t a3, unint64_t a4, _QWORD *a5)
{
  unint64_t v6;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  char *v36;
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  char *v48;
  char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  _QWORD *v54;
  char *v55;
  uint64_t v56;
  _QWORD *result;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  _QWORD *v65;

  v6 = a4;
  v8 = a1[2].u64[0];
  v9 = v8 >> 9;
  v10 = a1->i64[1];
  v11 = a1[1].i64[0];
  v12 = (char *)(v10 + 8 * (v8 >> 9));
  if (v11 == v10)
    v13 = 0;
  else
    v13 = *(_QWORD *)v12 + 8 * (a1[2].i64[0] & 0x1FF);
  if (a3 == v13)
    v14 = 0;
  else
    v14 = ((a3 - *(_QWORD *)a2) >> 3) + ((a2 - v12) << 6) - ((v13 - *(_QWORD *)v12) >> 3);
  v15 = a1[2].i64[1];
  if (v14 >= v15 - v14)
  {
    v25 = ((v11 - v10) << 6) - 1;
    if (v11 == v10)
      v25 = 0;
    v26 = v15 + v8;
    v27 = v25 - v26;
    if (a4 > v27)
    {
      sub_1C4EB94D4((uint64_t)a1, a4 - v27);
      v15 = a1[2].i64[1];
      v10 = a1->i64[1];
      v11 = a1[1].i64[0];
      v26 = a1[2].i64[0] + v15;
    }
    v28 = (char *)(v10 + 8 * (v26 >> 9));
    if (v11 == v10)
      v29 = 0;
    else
      v29 = (char *)(*(_QWORD *)v28 + 8 * (v26 & 0x1FF));
    v30 = v15 - v14;
    v31 = v6 - (v15 - v14);
    if (v6 <= v15 - v14)
    {
      v33 = v29;
      v32 = v28;
    }
    else
    {
      v32 = v28;
      v33 = v29;
      do
      {
        *v33++ = *a5;
        if ((_QWORD *)((char *)v33 - *(_QWORD *)v32) == (_QWORD *)4096)
        {
          v34 = (_QWORD *)*((_QWORD *)v32 + 1);
          v32 += 8;
          v33 = v34;
        }
        --v31;
      }
      while (v31);
      a1[2].i64[1] = v14 + v6;
      v6 = v15 - v14;
    }
    if (v6)
    {
      v65 = a5;
      v35 = ((uint64_t)&v29[-*(_QWORD *)v28] >> 3) - v6;
      if (v35 < 1)
      {
        v60 = 511 - v35;
        v36 = &v28[-8 * (v60 >> 9)];
        v37 = (char *)(*(_QWORD *)v36 + 8 * (~(_WORD)v60 & 0x1FF));
      }
      else
      {
        v36 = &v28[8 * ((unint64_t)v35 >> 9)];
        v37 = (char *)(*(_QWORD *)v36 + 8 * (v35 & 0x1FF));
      }
      sub_1C4EB99F4((uint64_t)a1, v36, (unint64_t)v37, v28, (uint64_t)v29, v32, v33, (unint64_t *)&v65);
      if (v6 < v30)
      {
        v38 = ((uint64_t)&v29[-*(_QWORD *)v28] >> 3) - v30;
        if (v38 < 1)
        {
          v63 = 511 - v38;
          v39 = &v28[-8 * (v63 >> 9)];
          v40 = (char *)(*(_QWORD *)v39 + 8 * (~(_WORD)v63 & 0x1FF));
        }
        else
        {
          v39 = &v28[8 * ((unint64_t)v38 >> 9)];
          v40 = (char *)(*(_QWORD *)v39 + 8 * (v38 & 0x1FF));
        }
        v28 = sub_1C4EB9B64(v39, v40, v36, v37, v28, v29, (unint64_t *)&v65);
        v29 = v41;
      }
      v42 = ((uint64_t)&v29[-*(_QWORD *)v28] >> 3) - v6;
      if (v42 < 1)
      {
        v61 = 511 - v42;
        LOWORD(v42) = ~(511 - v42);
        v43 = &v28[-8 * (v61 >> 9)];
      }
      else
      {
        v43 = &v28[8 * ((unint64_t)v42 >> 9)];
      }
      v44 = (_QWORD *)(*(_QWORD *)v43 + 8 * (v42 & 0x1FF));
      v45 = v65;
      do
      {
        *v44++ = *v45;
        if ((_QWORD *)((char *)v44 - *(_QWORD *)v43) == (_QWORD *)4096)
        {
          v46 = (_QWORD *)*((_QWORD *)v43 + 1);
          v43 += 8;
          v44 = v46;
        }
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    if (a4 > v8)
    {
      sub_1C4EB8CCC((uint64_t)a1, a4 - v8);
      v8 = a1[2].u64[0];
      v10 = a1->i64[1];
      v11 = a1[1].i64[0];
      v9 = v8 >> 9;
    }
    v16 = (char *)(v10 + 8 * v9);
    if (v11 == v10)
      v17 = 0;
    else
      v17 = (char *)(*(_QWORD *)v16 + 8 * (v8 & 0x1FF));
    v18 = (uint64_t)v17;
    v19 = (char *)(v10 + 8 * v9);
    v20 = v14 - v6;
    if (v14 >= v6)
    {
      v21 = v6;
    }
    else
    {
      v21 = v14;
      v22 = v6 - v14;
      if (v6 != v14)
      {
        v23 = a1[2].i64[1];
        v19 = v16;
        v18 = (uint64_t)v17;
        do
        {
          if (v18 == *(_QWORD *)v19)
          {
            v24 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            v18 = v24 + 4096;
          }
          *(_QWORD *)(v18 - 8) = *a5;
          v18 -= 8;
          --v6;
        }
        while (v14 != v6);
        a1[2].i64[0] = v20 + v8;
        a1[2].i64[1] = v22 + v23;
        v21 = v14;
      }
    }
    if (v21)
    {
      v65 = a5;
      v47 = v21 + ((uint64_t)&v17[-*(_QWORD *)v16] >> 3);
      if (v47 < 1)
      {
        v62 = 511 - v47;
        v48 = &v16[-8 * (v62 >> 9)];
        v49 = (char *)(*(_QWORD *)v48 + 8 * (~(_WORD)v62 & 0x1FF));
      }
      else
      {
        v48 = &v16[8 * ((unint64_t)v47 >> 9)];
        v49 = (char *)(*(_QWORD *)v48 + 8 * (v47 & 0x1FF));
      }
      sub_1C4EB9134(a1, v16, (uint64_t)v17, v48, (unint64_t)v49, v19, v18, (unint64_t *)&v65);
      if (v21 < v14)
      {
        v50 = v14 + ((uint64_t)&v17[-*(_QWORD *)v16] >> 3);
        if (v50 < 1)
        {
          v64 = 511 - v50;
          v51 = &v16[-8 * (v64 >> 9)];
          v52 = (char *)(*(_QWORD *)v51 + 8 * (~(_WORD)v64 & 0x1FF));
        }
        else
        {
          v51 = &v16[8 * ((unint64_t)v50 >> 9)];
          v52 = (char *)(*(_QWORD *)v51 + 8 * (v50 & 0x1FF));
        }
        v16 = sub_1C4EB92D0(v48, v49, v51, v52, v16, v17, (unint64_t *)&v65);
        v17 = v53;
      }
      v54 = v65;
      do
      {
        *(_QWORD *)v17 = *v54;
        v17 += 8;
        if (&v17[-*(_QWORD *)v16] == (char *)4096)
        {
          v55 = (char *)*((_QWORD *)v16 + 1);
          v16 += 8;
          v17 = v55;
        }
        --v21;
      }
      while (v21);
    }
  }
  v56 = a1->i64[1];
  result = (_QWORD *)(v56 + 8 * ((unint64_t)a1[2].i64[0] >> 9));
  if (a1[1].i64[0] == v56)
    v58 = 0;
  else
    v58 = *result + 8 * (a1[2].i64[0] & 0x1FF);
  if (v14)
  {
    v59 = v14 + ((v58 - *result) >> 3);
    if (v59 < 1)
      result -= (unint64_t)(511 - v59) >> 9;
    else
      result += (unint64_t)v59 >> 9;
  }
  return result;
}

llvm::AnalysisUsage *llvm::LPPassManager::getAnalysisUsage(llvm::LPPassManager *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage *result;

  llvm::AnalysisUsage::addRequiredID(a2, llvm::LoopInfoWrapperPass::ID);
  result = llvm::AnalysisUsage::addRequiredID(a2, llvm::DominatorTreeWrapperPass::ID);
  *((_BYTE *)a2 + 160) = 1;
  return result;
}

void llvm::LPPassManager::dumpPassStructure(llvm::LPPassManager *this, int a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  unint64_t v6;
  uint64_t v7;
  llvm::Pass *v8;

  v4 = (llvm::raw_ostream *)llvm::errs(this);
  v5 = llvm::raw_ostream::indent(v4, 2 * a2);
  sub_1C4816AD8(v5, "Loop Pass Manager\n");
  if (*((_DWORD *)this + 14))
  {
    v6 = 0;
    v7 = (a2 + 1);
    do
    {
      v8 = *(llvm::Pass **)(*((_QWORD *)this + 6) + 8 * v6);
      (*(void (**)(llvm::Pass *, uint64_t))(*(_QWORD *)v8 + 128))(v8, v7);
      llvm::PMDataManager::dumpLastUses((llvm::LPPassManager *)((char *)this + 32), v8, v7);
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 14));
  }
}

double llvm::LoopPass::preparePassManager(llvm::LoopPass *this, llvm::PMStack *a2)
{
  uint64_t v4;
  uint64_t i;
  double result;

  v4 = *(_QWORD *)a2;
  for (i = *((_QWORD *)a2 + 1); v4 != i; i = *((_QWORD *)a2 + 1))
  {
    if ((*(int (**)(_QWORD))(**(_QWORD **)(i - 8) + 40))(*(_QWORD *)(i - 8)) <= 4)
    {
      v4 = *((_QWORD *)a2 + 1);
      break;
    }
    llvm::PMStack::pop(a2);
    v4 = *(_QWORD *)a2;
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v4 - 8) + 40))(*(_QWORD *)(v4 - 8)) == 4
    && (llvm::PMDataManager::preserveHigherLevelAnalysis(*(llvm::PMTopLevelManager ***)(*((_QWORD *)a2 + 1) - 8), this) & 1) == 0)
  {
    return llvm::PMStack::pop(a2);
  }
  return result;
}

void llvm::LoopPass::assignPassManager(llvm::Pass *a1, llvm::PMStack *a2)
{
  uint64_t v4;
  uint64_t i;
  int v6;
  uint64_t v7;
  uint64_t v8;
  llvm::PMDataManager *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  int32x2_t *v15;
  uint64_t v16;
  const void **v17;

  v4 = *(_QWORD *)a2;
  for (i = *((_QWORD *)a2 + 1); v4 != i; i = *((_QWORD *)a2 + 1))
  {
    if ((*(int (**)(_QWORD))(**(_QWORD **)(i - 8) + 40))(*(_QWORD *)(i - 8)) <= 4)
    {
      v4 = *((_QWORD *)a2 + 1);
      break;
    }
    llvm::PMStack::pop(a2);
    v4 = *(_QWORD *)a2;
  }
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 - 8) + 40))(*(_QWORD *)(v4 - 8));
  v7 = *(_QWORD *)(*((_QWORD *)a2 + 1) - 8);
  if (v6 == 4)
  {
    if (v7)
      v8 = v7 - 32;
    else
      v8 = 0;
  }
  else
  {
    v8 = operator new();
    *(_QWORD *)(v8 + 16) = &llvm::LPPassManager::ID;
    *(_DWORD *)(v8 + 24) = 2;
    *(_QWORD *)(v8 + 32) = &unk_1E8139018;
    v9 = (llvm::PMDataManager *)(v8 + 32);
    *(_QWORD *)(v8 + 40) = 0;
    *(_QWORD *)(v8 + 48) = v8 + 64;
    *(_QWORD *)(v8 + 56) = 0x1000000000;
    *(_QWORD *)(v8 + 240) = 0;
    *(_QWORD *)(v8 + 248) = 0;
    *(_DWORD *)(v8 + 256) = 0;
    *(_QWORD *)(v8 + 264) = v8 + 280;
    *(_QWORD *)(v8 + 272) = 0x1000000000;
    *(_DWORD *)(v8 + 408) = 0;
    *(_OWORD *)(v8 + 192) = 0u;
    *(_OWORD *)(v8 + 208) = 0u;
    *(_OWORD *)(v8 + 224) = 0u;
    *(_QWORD *)v8 = &off_1E8138F68;
    *(_QWORD *)(v8 + 8) = 0;
    *(_OWORD *)(v8 + 448) = 0u;
    *(_OWORD *)(v8 + 464) = 0u;
    *(_OWORD *)(v8 + 416) = 0u;
    *(_OWORD *)(v8 + 432) = 0u;
    v11 = *(_QWORD *)a2;
    v10 = *((_QWORD *)a2 + 1);
    if (v10 != *(_QWORD *)a2)
    {
      v12 = 0;
      do
      {
        v13 = *(_QWORD *)(v10 - 8);
        v10 -= 8;
        v14 = (char *)v9 + 8 * v12++;
        *((_QWORD *)v14 + 20) = v13 + 208;
      }
      while (v10 != v11);
    }
    v15 = *(int32x2_t **)(v7 + 8);
    v16 = v15[15].u32[0];
    if (v16 >= v15[15].i32[1])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15[14], (uint64_t)&v15[16], v16 + 1, 8);
      LODWORD(v16) = v15[15].i32[0];
    }
    *(_QWORD *)(*(_QWORD *)&v15[14] + 8 * v16) = v9;
    ++v15[15].i32[0];
    v17 = (const void **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 144))(v8);
    llvm::PMTopLevelManager::schedulePass(v15, v17);
    llvm::PMStack::push(a2, v9);
  }
  llvm::PMDataManager::add((llvm::PMDataManager *)(v8 + 32), a1, 1);
}

llvm::LCSSAVerificationPass *llvm::LCSSAVerificationPass::LCSSAVerificationPass(llvm::LCSSAVerificationPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::LCSSAVerificationPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E8139058;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E058);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EB87B0;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E058, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeLCSSAVerificationPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E058);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EB87B0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E058, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C61A2B2C(_QWORD *a1)
{
  llvm::PMDataManager *v2;

  *a1 = &off_1E8138F68;
  a1[4] = &unk_1E8139018;
  v2 = (llvm::PMDataManager *)(a1 + 4);
  sub_1C484143C((uint64_t)(a1 + 52));
  llvm::PMDataManager::~PMDataManager(v2);
  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1C61A2B74(_QWORD *a1)
{
  llvm::PMDataManager *v2;

  *a1 = &off_1E8138F68;
  a1[4] = &unk_1E8139018;
  v2 = (llvm::PMDataManager *)(a1 + 4);
  sub_1C484143C((uint64_t)(a1 + 52));
  llvm::PMDataManager::~PMDataManager(v2);
  llvm::Pass::~Pass((llvm::Pass *)a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A2BD0(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1C61A2BDC()
{
  return 4;
}

void sub_1C61A2BE4(llvm::PMDataManager *a1)
{
  llvm::Pass *v2;

  *((_QWORD *)a1 - 4) = &off_1E8138F68;
  v2 = (llvm::PMDataManager *)((char *)a1 - 32);
  *(_QWORD *)a1 = &unk_1E8139018;
  sub_1C484143C((uint64_t)a1 + 384);
  llvm::PMDataManager::~PMDataManager(a1);
  llvm::Pass::~Pass(v2);
}

void sub_1C61A2C2C(uint64_t a1)
{
  sub_1C61A2B74((_QWORD *)(a1 - 32));
}

uint64_t sub_1C61A2C34(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_1C61A2C3C()
{
  return 4;
}

void sub_1C61A2C48(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61A2C6C(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

void sub_1C61A2C78(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  char *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  char *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;

  v2 = a1;
  v3 = *(char **)(a1 + 16);
  if (v3 == *(char **)(a1 + 24))
  {
    v21 = a2;
    v5 = *(char **)a1;
    v4 = *(char **)(a1 + 8);
    if ((unint64_t)v4 <= *(_QWORD *)a1)
    {
      if (v3 == v5)
        v13 = 1;
      else
        v13 = (v3 - v5) >> 2;
      if (v13 >> 61)
        sub_1C4764EE4();
      v14 = (char *)operator new(8 * v13);
      v15 = &v14[8 * (v13 >> 2)];
      v17 = v3 - v4;
      v16 = v3 == v4;
      v3 = v15;
      if (!v16)
      {
        v3 = &v15[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = &v14[8 * (v13 >> 2)];
        do
        {
          v20 = *(_QWORD *)v4;
          v4 += 8;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      a2 = v21;
      v2 = a1;
      *(_QWORD *)a1 = v14;
      *(_QWORD *)(a1 + 8) = v15;
      *(_QWORD *)(a1 + 16) = v3;
      *(_QWORD *)(a1 + 24) = &v14[8 * v13];
      if (v5)
      {
        operator delete(v5);
        a2 = v21;
        v2 = a1;
        v3 = *(char **)(a1 + 16);
      }
    }
    else
    {
      v6 = (uint64_t)&v4[-*(_QWORD *)a1] >> 3;
      if (v6 >= -1)
        v7 = v6 + 1;
      else
        v7 = v6 + 2;
      v8 = -(v7 >> 1);
      v9 = v7 >> 1;
      v10 = &v4[-8 * v9];
      v11 = v3 - v4;
      if (v3 != v4)
      {
        memmove(&v4[-8 * v9], v4, v3 - v4);
        v3 = *(char **)(a1 + 8);
      }
      v12 = &v3[8 * v8];
      v3 = &v10[v11];
      a2 = v21;
      v2 = a1;
      *(_QWORD *)(a1 + 8) = v12;
      *(_QWORD *)(a1 + 16) = &v10[v11];
    }
  }
  *(_QWORD *)v3 = *a2;
  *(_QWORD *)(v2 + 16) += 8;
}

void sub_1C61A2DAC(const void **a1, _QWORD *a2)
{
  const void **v2;
  char *v3;
  char *v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t *v19;
  uint64_t v20;
  char *__dst;
  _QWORD *v22;
  _QWORD *__src;

  v2 = a1;
  v3 = (char *)a1[1];
  if (v3 == *a1)
  {
    __src = a1[1];
    v22 = a2;
    v6 = a1[2];
    v5 = a1[3];
    if (v6 >= v5)
    {
      v11 = v5 - v3;
      v10 = v11 == 0;
      v12 = v11 >> 2;
      if (v10)
        v13 = 1;
      else
        v13 = v12;
      if (v13 >> 61)
        sub_1C4764EE4();
      v14 = (char *)operator new(8 * v13);
      v15 = &v14[(2 * v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      v4 = v15;
      v16 = v6 - (_BYTE *)__src;
      if (v6 != (_BYTE *)__src)
      {
        v15 += v16 & 0xFFFFFFFFFFFFFFF8;
        v17 = 8 * (v16 >> 3);
        v18 = &v14[(2 * v13 + 6) & 0xFFFFFFFFFFFFFFF8];
        v19 = __src;
        do
        {
          v20 = *v19++;
          *(_QWORD *)v18 = v20;
          v18 += 8;
          v17 -= 8;
        }
        while (v17);
      }
      a2 = v22;
      v2 = a1;
      *a1 = v14;
      a1[1] = v4;
      a1[2] = v15;
      a1[3] = &v14[8 * v13];
      if (__src)
      {
        operator delete(__src);
        a2 = v22;
        v2 = a1;
        v4 = (char *)a1[1];
      }
    }
    else
    {
      v7 = (v5 - v6) >> 3;
      if (v7 >= -1)
        v8 = v7 + 1;
      else
        v8 = v7 + 2;
      v9 = v8 >> 1;
      __dst = &v3[8 * (v8 >> 1)];
      if (v6 != v3)
      {
        memmove(__dst, v3, v6 - v3);
        __src = a1[2];
      }
      a2 = v22;
      v2 = a1;
      v4 = __dst;
      a1[1] = __dst;
      a1[2] = &__src[v9];
    }
  }
  else
  {
    v4 = (char *)a1[1];
  }
  *((_QWORD *)v4 - 1) = *a2;
  v2[1] = (char *)v2[1] - 8;
}

llvm::LCSSAVerificationPass *llvm::callDefaultCtor<llvm::LCSSAVerificationPass>()
{
  llvm::LCSSAVerificationPass *v0;

  v0 = (llvm::LCSSAVerificationPass *)operator new();
  return llvm::LCSSAVerificationPass::LCSSAVerificationPass(v0);
}

void sub_1C61A2F38(uint64_t a1)
{
  char *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;

  v2 = *(char **)(a1 + 8);
  v3 = *(_BYTE **)(a1 + 16);
  if (v3 == v2)
    v4 = 0;
  else
    v4 = ((v3 - v2) << 6) - 1;
  v5 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v4 - (*(_QWORD *)(a1 + 40) + v5)) < 0x200)
  {
    v6 = *(char **)(a1 + 24);
    v7 = *(char **)a1;
    v8 = (uint64_t)&v6[-*(_QWORD *)a1];
    if (v3 - v2 >= (unint64_t)v8)
    {
      if (v6 == v7)
        v10 = 1;
      else
        v10 = v8 >> 2;
      v23 = a1 + 24;
      if (v10 >> 61)
        sub_1C4764EE4();
      v20 = (char *)operator new(8 * v10);
      v21 = v20;
      *(_QWORD *)&v22 = v20;
      *((_QWORD *)&v22 + 1) = &v20[8 * v10];
      v19 = operator new(0x1000uLL);
      sub_1C61A2C78((uint64_t)&v20, &v19);
      v11 = *(char **)(a1 + 8);
      if (v11 == *(char **)(a1 + 16))
      {
        v12 = *(char **)(a1 + 8);
      }
      else
      {
        do
        {
          sub_1C4DBA538((uint64_t)&v20, v11);
          v11 += 8;
        }
        while (v11 != *(char **)(a1 + 16));
        v12 = *(char **)(a1 + 8);
      }
      v13 = *(char **)a1;
      v14 = v21;
      *(_QWORD *)a1 = v20;
      *(_QWORD *)(a1 + 8) = v14;
      v20 = v13;
      v21 = v12;
      v15 = *(_QWORD *)(a1 + 24);
      v16 = v22;
      *(_OWORD *)(a1 + 16) = v22;
      *(_QWORD *)&v22 = v11;
      *((_QWORD *)&v22 + 1) = v15;
      if (v16 - (_QWORD)v14 == 8)
        v17 = 256;
      else
        v17 = *(_QWORD *)(a1 + 32) + 512;
      *(_QWORD *)(a1 + 32) = v17;
      if (v11 != v12)
        *(_QWORD *)&v22 = &v11[(v12 - v11 + 7) & 0xFFFFFFFFFFFFFFF8];
      if (v13)
        operator delete(v13);
    }
    else
    {
      if (v2 == v7)
      {
        v20 = (char *)operator new(0x1000uLL);
        sub_1C61351F0(a1, &v20);
        v9 = *(_QWORD *)(a1 + 16);
        v20 = *(char **)(v9 - 8);
        *(_QWORD *)(a1 + 16) = v9 - 8;
      }
      else
      {
        v20 = (char *)operator new(0x1000uLL);
      }
      sub_1C6135314((void **)a1, &v20);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
        v18 = 256;
      else
        v18 = *(_QWORD *)(a1 + 32) + 512;
      *(_QWORD *)(a1 + 32) = v18;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 32) = v5 + 512;
    v20 = (char *)*((_QWORD *)v3 - 1);
    *(_QWORD *)(a1 + 16) = v3 - 8;
    sub_1C6135314((void **)a1, &v20);
  }
}

uint64_t sub_1C61A3124(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v12;

  v12 = 0;
  llvm::cl::parser<float>::parse(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, (float *)&v12);
  v9 = v8;
  if ((v8 & 1) != 0)
    return v9;
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v10 = *(_QWORD *)(a1 + 184);
  if (v10)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v10 + 48))(v10, &v12);
    return v9;
  }
  sub_1C485C2F0();
  return sub_1C61A319C();
}

uint64_t sub_1C61A319C()
{
  return 2;
}

void sub_1C61A31A4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &unk_1E8139308;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      sub_1C47A80D0(a1);
      JUMPOUT(0x1CAA32FC0);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_6;
}

uint64_t sub_1C61A3218(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1C61A3224(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

float sub_1C61A3234(uint64_t a1, int a2, int a3, float result)
{
  void *v4;
  int v5;
  char v6;

  if (a3)
  {
    result = *(float *)(a1 + 128);
LABEL_3:
    v5 = *(_DWORD *)(a1 + 144);
    v6 = *(_BYTE *)(a1 + 148);
    v4 = &unk_1E8139370;
    llvm::cl::parser<float>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, (uint64_t)&v4, a2, result);
    return result;
  }
  if (*(_BYTE *)(a1 + 148))
  {
    result = *(float *)(a1 + 128);
    if (*(float *)(a1 + 144) != result)
      goto LABEL_3;
  }
  return result;
}

BOOL sub_1C61A32A8(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 12) && *(_BYTE *)(a1 + 12) && *(float *)(a1 + 8) != *(float *)(a2 + 8);
}

void sub_1C61A32D8()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A32EC()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_1E8139390;
  return result;
}

void sub_1C61A3314(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_1E8139390;
}

uint64_t llvm::createMemDepPrinter(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EBD450(v1);
}

uint64_t llvm::createMemDerefPrinter(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EBEBE8(v1);
}

BOOL llvm::isAllocationFn(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  int v5;
  uint64_t v6;
  _BOOL8 result;
  uint64_t *v8;
  int v9;
  _BYTE v10[31];
  char v11;

  v5 = byte_1ED82E438;
  v11 = 0;
  v6 = sub_1C4EC05F4(a1, &v11);
  result = 0;
  if (v6 && !v11)
  {
    v8 = (uint64_t *)a2(a3, v6);
    if (v5)
      v9 = 59;
    else
      v9 = 63;
    sub_1C4EBF928(v6, v9, v8, (uint64_t)v10);
    return v10[24] != 0;
  }
  return result;
}

uint64_t llvm::isAllocRemovable(uint64_t a1, uint64_t *a2)
{
  int v3;
  _BYTE v5[28];

  if (byte_1ED82E438)
    v3 = 43;
  else
    v3 = 47;
  sub_1C4EBF808(a1, v3, a2, v5);
  return v5[24];
}

llvm::UndefValue *llvm::getInitialValueOfAllocation(uint64_t a1, uint64_t *a2, llvm::UndefValue *a3)
{
  llvm::Type *v6;
  llvm::Type *v8;
  _BYTE v9[24];
  char v10;

  sub_1C4EBF808(a1, 3, a2, v9);
  if (v10)
    return llvm::UndefValue::get(a3, v6);
  if (!byte_1ED82E438)
  {
    sub_1C4EBF808(a1, 4, a2, v9);
    if (v10)
      return llvm::UndefValue::get(a3, v6);
  }
  sub_1C4EBF808(a1, 8, a2, v9);
  if (v10)
    return (llvm::UndefValue *)llvm::Constant::getNullValue(a3, v8);
  else
    return 0;
}

BOOL llvm::isLibFreeFunction(_QWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v2 = 0;
  while (dword_1C85F4458[v2] != a2)
  {
    v2 += 3;
    if (v2 == 90)
      return 0;
  }
  v4 = a1[3];
  v5 = *(_QWORD **)(v4 + 16);
  if (*(_BYTE *)(*v5 + 8) != 7 || *(_DWORD *)(v4 + 12) - 1 != dword_1C85F4458[v2 + 1])
    return 0;
  v6 = v5[1];
  return v6 == llvm::PointerType::get((llvm::PointerType *)(**(_QWORD **)*a1 + 1912), 0);
}

llvm::ValueHandleBase *llvm::lowerObjectSizeCall(uint64_t a1, llvm::DataLayout *a2, llvm::DataLayout *a3, int a4)
{
  return llvm::lowerObjectSizeCall(a1, a2, a3, 0, a4);
}

uint64_t sub_1C61A361C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;

  v6 = 0;
  if ((sub_1C61A413C(a1, a2, &v6) & 1) != 0)
    return v6;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = a1 + 8;
    v5 = 8;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 16);
  }
  return v4 + 40 * v5;
}

uint64_t llvm::ObjectSizeOffsetVisitor::visitSelectInst@<X0>(llvm::ObjectSizeOffsetVisitor *this@<X0>, llvm::Value **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7[4];
  uint64_t v8[4];

  llvm::ObjectSizeOffsetVisitor::compute(v8, this, *(a2 - 8));
  llvm::ObjectSizeOffsetVisitor::compute(v7, this, *(a2 - 4));
  llvm::ObjectSizeOffsetVisitor::combineSizeOffset((uint64_t)this, (uint64_t)v8, (uint64_t)v7, a3);
  sub_1C48C0CF0((uint64_t)v7);
  return sub_1C48C0CF0((uint64_t)v8);
}

uint64_t llvm::ObjectSizeOffsetEvaluator::ObjectSizeOffsetEvaluator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v9;
  uint64_t v10;
  void (**v11)(void);
  _QWORD v13[2];
  _QWORD v14[3];
  _QWORD *v15;
  void (**v16)(llvm::IRBuilderCallbackInserter *__hidden);
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  v13[0] = &unk_1E8135C10;
  v13[1] = a2;
  v14[0] = &off_1E8139580;
  v14[1] = a1;
  v15 = v14;
  v16 = &off_1E8167568;
  v17[0] = &off_1E8139580;
  v18 = v17;
  v17[1] = a1;
  sub_1C4EC49B8(a1 + 24, a4, (uint64_t)v13, (uint64_t)&v16);
  v16 = &off_1E8167568;
  v9 = v18;
  if (v18 == v17)
  {
    v10 = 4;
    v9 = v17;
LABEL_3:
    (*(void (**)(void))(*v9 + 8 * v10))();
    goto LABEL_4;
  }
  if (v18)
  {
    v10 = 5;
    goto LABEL_3;
  }
LABEL_4:
  if (v15 == v14)
  {
    v11 = (void (**)(void))(v14[0] + 32);
    goto LABEL_7;
  }
  if (v15)
  {
    v11 = (void (**)(void))(*v15 + 40);
LABEL_7:
    (*v11)();
  }
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = a1 + 272;
  *(_QWORD *)(a1 + 248) = a1 + 272;
  *(_QWORD *)(a1 + 256) = 8;
  *(_DWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 336) = a5;
  *(_QWORD *)(a1 + 344) = a6;
  *(_QWORD *)(a1 + 352) = a1 + 384;
  *(_QWORD *)(a1 + 360) = a1 + 384;
  *(_QWORD *)(a1 + 368) = 8;
  *(_DWORD *)(a1 + 376) = 0;
  return a1;
}

uint64_t llvm::ObjectSizeOffsetEvaluator::visitGEPOperator(llvm::ObjectSizeOffsetEvaluator *this, llvm::GEPOperator *a2)
{
  int v4;
  llvm::Value **v5;
  uint64_t v6;
  _QWORD *v7;
  BOOL v8;
  uint64_t v10;
  _QWORD *v11;
  llvm::Value **v12;
  llvm::Value *v13;
  _WORD v14[20];
  _BYTE v15[32];
  __int16 v16;

  v4 = *((_DWORD *)a2 + 5);
  if ((v4 & 0x40000000) != 0)
    v5 = (llvm::Value **)*((_QWORD *)a2 - 1);
  else
    v5 = (llvm::Value **)((char *)a2 - 32 * (v4 & 0x7FFFFFF));
  v6 = llvm::ObjectSizeOffsetEvaluator::compute_(this, *v5);
  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8)
    return 0;
  v10 = v6;
  v11 = v7;
  v12 = sub_1C61A3B04((uint64_t)this + 24, *(llvm::DataLayout **)this, a2, 1u);
  v14[16] = 257;
  if (!(*(uint64_t (**)(_QWORD, _QWORD *, llvm::Value **, _QWORD, _QWORD))(**((_QWORD **)this + 12) + 16))(*((_QWORD *)this + 12), v11, v12, 0, 0))
  {
    v16 = 257;
    v13 = llvm::BinaryOperator::Create(13, v11, (uint64_t)v12, (uint64_t)v15, 0);
    sub_1C4773754((uint64_t *)this + 3, (uint64_t)v13, (uint64_t)v14);
  }
  return v10;
}

uint64_t sub_1C61A3954(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)())((char *)sub_1C61A3974 + 4 * byte_1C85F4413[*(unsigned __int8 *)(a2 + 16) - 29]))();
}

uint64_t sub_1C61A3974()
{
  return 0;
}

uint64_t llvm::ObjectSizeOffsetEvaluator::visitAllocaInst(llvm::ObjectSizeOffsetEvaluator *this, llvm::AllocaInst *a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned __int8 *v6;
  _QWORD *IntPtrType;
  unsigned __int8 *v8;
  llvm::ConstantInt *v9;
  llvm::DataLayout *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  BOOL v15;
  const char *v16;
  char v17;
  uint64_t v18;
  llvm::Value **v19;
  _BYTE v22[32];
  __int16 v23;

  v4 = *((_QWORD *)a2 + 8);
  v5 = *(unsigned __int8 *)(v4 + 8);
  if (v5 > 0x11)
    goto LABEL_9;
  if (((1 << v5) & 0xAC7F) == 0)
  {
    if (((1 << v5) & 0x30000) != 0)
    {
LABEL_7:
      if (llvm::Type::isSizedDerivedType(v4, 0))
        goto LABEL_3;
      return 0;
    }
LABEL_9:
    if ((v5 & 0xFE) != 0x12 && v5 != 21)
      return 0;
    goto LABEL_7;
  }
LABEL_3:
  v6 = (unsigned __int8 *)*((_QWORD *)a2 - 4);
  IntPtrType = llvm::DataLayout::getIntPtrType(*(llvm::DataLayout **)this, **(llvm::LLVMContext ***)a2, 0);
  v23 = 257;
  v8 = sub_1C4773690((uint64_t *)this + 3, v6, (uint64_t)IntPtrType, (uint64_t)v22);
  v9 = *(llvm::ConstantInt **)v8;
  v10 = *(llvm::DataLayout **)this;
  v11 = *((_QWORD *)a2 + 8);
  sub_1C4768AD0(*(_QWORD *)this, v11);
  v13 = (unint64_t)(v12 + 7) >> 3;
  v15 = v14 == 1;
  llvm::DataLayout::getAlignment((uint64_t)v10, v11);
  v18 = ((1 << v17) + v13 - 1) & -(1 << v17);
  if (v15)
  v19 = llvm::ConstantInt::get(v9, v18, 0);
  v23 = 257;
  return sub_1C4EC4040((uint64_t)this + 24, (uint64_t)v19, (uint64_t)v8, (uint64_t)v22, 0, 0);
}

llvm::Value **sub_1C61A3B04(uint64_t a1, llvm::DataLayout *a2, llvm::GEPOperator *this, unsigned __int8 a4)
{
  int v8;
  uint64_t ****v9;
  uint64_t SourceElementType;
  int v11;
  char *v12;
  llvm::UndefValue **v13;
  uint64_t v14;
  llvm::Type *v15;
  char *Name;
  std::string::size_type v17;
  uint64_t v18;

  v8 = *((_DWORD *)this + 5);
  if ((v8 & 0x40000000) != 0)
    v9 = (uint64_t ****)*((_QWORD *)this - 1);
  else
    v9 = (uint64_t ****)((char *)this - 32 * (v8 & 0x7FFFFFF));
  SourceElementType = llvm::GEPOperator::getSourceElementType(this);
  v11 = *((_DWORD *)this + 5);
  if ((v11 & 0x40000000) != 0)
    v12 = (char *)*((_QWORD *)this - 1);
  else
    v12 = (char *)this - 32 * (v11 & 0x7FFFFFF);
  v13 = (llvm::UndefValue **)(v12 + 32);
  v14 = SourceElementType | 4;
  v15 = *(llvm::Type **)this;
  Name = llvm::Value::getName(this);
  return sub_1C4EC4C18(a1, a2, v13, v14, v9 + 4, &v9[4 * (v8 & 0x7FFFFFF)], v15, v18, Name, v17, (*((_BYTE *)this + 17) & 2) != 0, a4);
}

llvm::UndefValue *llvm::ObjectSizeOffsetEvaluator::visitPHINode(llvm::ObjectSizeOffsetEvaluator *this, llvm::PHINode *a2)
{
  char *v4;
  uint64_t v5;
  int v6;
  llvm::PHINode *v7;
  uint64_t v8;
  int v9;
  llvm::PHINode *v10;
  _QWORD *v11;
  llvm::Type *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  llvm::PHINode *v18;
  uint64_t FirstInsertionPt;
  uint64_t v20;
  int v21;
  llvm::PHINode *v22;
  llvm::ValueHandleBase *v23;
  llvm::Type *v24;
  uint64_t v26;
  int v27;
  char *v28;
  int v29;
  char *v30;
  llvm::UndefValue *v31;
  llvm::Type *v32;
  llvm::UndefValue *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  llvm::UndefValue *v37;
  _QWORD *v38;
  llvm::Type *v39;
  uint64_t v40;
  uint64_t v41;
  llvm::UndefValue *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  llvm::UndefValue *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v50[4];
  __int16 v51;

  v4 = (char *)this + 24;
  v5 = *((_QWORD *)this + 25);
  v6 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  v51 = 257;
  v7 = (llvm::PHINode *)sub_1C4867E94((uint64_t)this + 24, v5, v6, (uint64_t)v50);
  v8 = *((_QWORD *)this + 25);
  v9 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  v51 = 257;
  v10 = (llvm::PHINode *)sub_1C4867E94((uint64_t)v4, v8, v9, (uint64_t)v50);
  v50[0] = (uint64_t)a2;
  v11 = sub_1C61A4690((uint64_t)this + 216, v50);
  sub_1C4E3D39C((llvm::ValueHandleBase *)(v11 + 1), (uint64_t)v7);
  sub_1C4E3D39C((llvm::ValueHandleBase *)(v11 + 4), (uint64_t)v10);
  v13 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  if ((_DWORD)v13)
  {
    v14 = 0;
    v15 = 0;
    v16 = 32 * v13;
    while (1)
    {
      v17 = *((_DWORD *)a2 + 5);
      v18 = (v17 & 0x40000000) != 0
          ? (llvm::PHINode *)*((_QWORD *)a2 - 1)
          : (llvm::PHINode *)((char *)a2 - 32 * (v17 & 0x7FFFFFF));
      FirstInsertionPt = llvm::BasicBlock::getFirstInsertionPt(*(llvm::BasicBlock **)((char *)v18
                                                                                    + 32 * *((unsigned int *)a2 + 15)
                                                                                    + v14));
      v20 = FirstInsertionPt ? FirstInsertionPt - 24 : 0;
      sub_1C4EC1900((uint64_t)v4, v20);
      v21 = *((_DWORD *)a2 + 5);
      v22 = (v21 & 0x40000000) != 0
          ? (llvm::PHINode *)*((_QWORD *)a2 - 1)
          : (llvm::PHINode *)((char *)a2 - 32 * (v21 & 0x7FFFFFF));
      v23 = llvm::ObjectSizeOffsetEvaluator::compute_(this, *(llvm::Value **)((char *)v22 + v15));
      if (!v23 || v24 == 0)
        break;
      v26 = (uint64_t)v24;
      v27 = *((_DWORD *)a2 + 5);
      if ((v27 & 0x40000000) != 0)
        v28 = (char *)*((_QWORD *)a2 - 1);
      else
        v28 = (char *)a2 - 32 * (v27 & 0x7FFFFFF);
      sub_1C477667C(v7, (uint64_t)v23, *(_QWORD *)&v28[32 * *((unsigned int *)a2 + 15) + v14]);
      v29 = *((_DWORD *)a2 + 5);
      if ((v29 & 0x40000000) != 0)
        v30 = (char *)*((_QWORD *)a2 - 1);
      else
        v30 = (char *)a2 - 32 * (v29 & 0x7FFFFFF);
      sub_1C477667C(v10, v26, *(_QWORD *)&v30[32 * *((unsigned int *)a2 + 15) + v14]);
      v15 += 32;
      v14 += 8;
      if (v16 == v15)
        goto LABEL_23;
    }
    v37 = llvm::UndefValue::get(*((llvm::UndefValue **)this + 25), v24);
    llvm::Value::doRAUW(v10, v37, (llvm::Value *)1);
    llvm::Instruction::eraseFromParent(v10);
    v38 = sub_1C477672C((uint64_t)this + 352, (uint64_t)v10);
    v40 = *((_QWORD *)this + 45);
    v41 = 368;
    if (v40 == *((_QWORD *)this + 44))
      v41 = 372;
    if (v38 != (_QWORD *)(v40 + 8 * *(unsigned int *)((char *)this + v41)))
    {
      *v38 = -2;
      ++*((_DWORD *)this + 94);
    }
    v42 = llvm::UndefValue::get(*((llvm::UndefValue **)this + 25), v39);
    llvm::Value::doRAUW(v7, v42, (llvm::Value *)1);
    llvm::Instruction::eraseFromParent(v7);
    v43 = sub_1C477672C((uint64_t)this + 352, (uint64_t)v7);
    v44 = *((_QWORD *)this + 45);
    v45 = 368;
    if (v44 == *((_QWORD *)this + 44))
      v45 = 372;
    if (v43 == (_QWORD *)(v44 + 8 * *(unsigned int *)((char *)this + v45)))
      return 0;
    v33 = 0;
    goto LABEL_41;
  }
LABEL_23:
  v31 = llvm::PHINode::hasConstantValue(v7, v12);
  if (v31)
  {
    v33 = v31;
    llvm::Value::doRAUW(v7, v31, (llvm::Value *)1);
    llvm::Instruction::eraseFromParent(v7);
    v34 = sub_1C477672C((uint64_t)this + 352, (uint64_t)v7);
    v35 = *((_QWORD *)this + 45);
    v36 = 368;
    if (v35 == *((_QWORD *)this + 44))
      v36 = 372;
    if (v34 != (_QWORD *)(v35 + 8 * *(unsigned int *)((char *)this + v36)))
    {
      *v34 = -2;
      ++*((_DWORD *)this + 94);
    }
  }
  else
  {
    v33 = v7;
  }
  v46 = llvm::PHINode::hasConstantValue(v10, v32);
  if (v46)
  {
    llvm::Value::doRAUW(v10, v46, (llvm::Value *)1);
    llvm::Instruction::eraseFromParent(v10);
    v43 = sub_1C477672C((uint64_t)this + 352, (uint64_t)v10);
    v47 = *((_QWORD *)this + 45);
    v48 = 368;
    if (v47 == *((_QWORD *)this + 44))
      v48 = 372;
    if (v43 != (_QWORD *)(v47 + 8 * *(unsigned int *)((char *)this + v48)))
    {
LABEL_41:
      *v43 = -2;
      ++*((_DWORD *)this + 94);
    }
  }
  return v33;
}

uint64_t *llvm::ObjectSizeOffsetEvaluator::visitSelectInst(llvm::ObjectSizeOffsetEvaluator *this, llvm::Value **a2)
{
  uint64_t *Select;
  uint64_t *v5;
  uint64_t *v6;
  llvm::ValueHandleBase *v7;
  uint64_t *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[32];
  __int16 v18;

  Select = (uint64_t *)llvm::ObjectSizeOffsetEvaluator::compute_(this, *(a2 - 8));
  v6 = v5;
  v7 = llvm::ObjectSizeOffsetEvaluator::compute_(this, *(a2 - 4));
  if (Select)
    v9 = v6 == 0;
  else
    v9 = 1;
  if (v9)
    return 0;
  v10 = (uint64_t)v8;
  if (!v7 || v8 == 0)
    return 0;
  if (Select != (uint64_t *)v7 || v6 != v8)
  {
    v14 = (uint64_t *)((char *)this + 24);
    v15 = (uint64_t)*(a2 - 12);
    v18 = 257;
    Select = (uint64_t *)llvm::IRBuilderBase::CreateSelect(v14, v15, Select, (uint64_t)v7, (uint64_t)v17, 0);
    v16 = (uint64_t)*(a2 - 12);
    v18 = 257;
    llvm::IRBuilderBase::CreateSelect(v14, v16, v6, v10, (uint64_t)v17, 0);
  }
  return Select;
}

void **sub_1C61A4038(void **a1)
{
  void **v2;
  void **v3;

  v3 = a1 + 2;
  v2 = (void **)*a1;
  if (v2 != v3)
    free(v2);
  return a1;
}

llvm::ValueHandleBase *sub_1C61A406C(llvm::ValueHandleBase *this)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *((_QWORD *)this + 5);
  if (v2 != -8192 && v2 != -4096 && v2 != 0)
    llvm::ValueHandleBase::RemoveFromUseList((_QWORD *)this + 3);
  v4 = *((_QWORD *)this + 2);
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(this);
  return this;
}

_QWORD *sub_1C61A40CC(_DWORD *a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;

  v8 = 0;
  v4 = sub_1C61A413C((uint64_t)a1, *a2, &v8);
  v5 = v8;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61A41F0(a1, a2, v8);
    v7 = *a2;
    *((_DWORD *)v5 + 4) = 1;
    *v5 = v7;
    v5[1] = 0;
    *((_DWORD *)v5 + 8) = 1;
    v5[3] = 0;
  }
  return v5;
}

uint64_t sub_1C61A413C(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 8;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 40 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 40 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61A41F0(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  uint64_t v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 8;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= (3 * v6))
  {
    v6 = (2 * v6);
  }
  else if ((int)v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C4EC45D0((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61A413C((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

uint64_t sub_1C61A42AC(uint64_t result, uint64_t a2, uint64_t a3)
{
  _DWORD *v5;
  int v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 328);
  }
  else
  {
    v7 = *(_DWORD *)(result + 16);
    if (!v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[5 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 5;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      sub_1C61A413C((uint64_t)v5, v10, &v12);
      v11 = v12;
      *v12 = *(_QWORD *)a2;
      *((_DWORD *)v11 + 4) = *(_DWORD *)(a2 + 16);
      v11[1] = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 16) = 0;
      *((_DWORD *)v11 + 8) = *(_DWORD *)(a2 + 32);
      v11[3] = *(_QWORD *)(a2 + 24);
      *(_DWORD *)(a2 + 32) = 0;
      *v5 += 2;
      result = sub_1C48C0CF0(a2 + 8);
    }
    a2 += 40;
  }
  return result;
}

void sub_1C61A43A0(_DWORD **a1, __int128 *a2)
{
  uint64_t v4;

  v4 = sub_1C47AD050((uint64_t)qword_1ED82E3B8, 0, 0);
  byte_1ED82E438 = 0;
  qword_1ED82E440 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED82E448 = 0;
  qword_1ED82E3B8[0] = (uint64_t)&unk_1E819E898;
  qword_1ED82E450 = (uint64_t)&off_1E819E9A0;
  qword_1ED82E458 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED82E470 = (uint64_t)&qword_1ED82E458;
  llvm::cl::Option::setArgStr(v4, "disable-aligned-alloc-awareness", 0x1FuLL);
  byte_1ED82E438 = **a1 != 0;
  byte_1ED82E449 = 1;
  byte_1ED82E448 = byte_1ED82E438;
  xmmword_1ED82E3D8 = *a2;
  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1ED82E3B8);
}

void sub_1C61A4468(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 32, &v5);
  sub_1C61A44D4(a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

uint64_t sub_1C61A44D4(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(unsigned int *)(result + 8);
  if ((_DWORD)v2)
  {
    v3 = a2 + 16;
    v4 = (_DWORD *)(*(_QWORD *)result + 24);
    v5 = 32 * v2;
    do
    {
      *(_DWORD *)(v3 - 8) = *(v4 - 4);
      *(_QWORD *)(v3 - 16) = *((_QWORD *)v4 - 3);
      *(v4 - 4) = 0;
      *(_DWORD *)(v3 + 8) = *v4;
      *(_QWORD *)v3 = *((_QWORD *)v4 - 1);
      v3 += 32;
      *v4 = 0;
      v4 += 8;
      v5 -= 32;
    }
    while (v5);
    v6 = *(unsigned int *)(result + 8);
    if ((_DWORD)v6)
    {
      v7 = 32 * v6;
      v8 = *(_QWORD *)result - 32;
      do
      {
        result = sub_1C48C0CF0(v8 + v7);
        v7 -= 32;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t sub_1C61A4558(uint64_t a1)
{
  sub_1C61A4590(a1);
  if ((*(_BYTE *)a1 & 1) == 0)
    MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 8), 8);
  return a1;
}

uint64_t sub_1C61A4590(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if ((*(_BYTE *)result & 1) != 0)
  {
    v2 = result + 8;
    v1 = 8;
  }
  else
  {
    v1 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v1)
      return result;
    v2 = *(_QWORD *)(result + 8);
  }
  v3 = 40 * v1;
  result = v2 + 8;
  do
  {
    if ((*(_QWORD *)(result - 8) | 0x1000) != 0xFFFFFFFFFFFFF000)
      result = sub_1C48C0CF0(result);
    result += 40;
    v3 -= 40;
  }
  while (v3);
  return result;
}

uint64_t sub_1C61A45F4(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 56 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 56 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61A4690(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61A4708(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 6;
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 6;
    v5[5] = 0;
    v5[6] = 0;
  }
  return v5;
}

_QWORD *sub_1C61A4708(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EC4A88(a1, v6);
  v8 = 0;
  sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

llvm::ValueHandleBase *sub_1C61A47B8(llvm::ValueHandleBase *result, uint64_t *a2, uint64_t *a3)
{
  llvm::ValueHandleBase *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;

  v5 = result;
  *((_QWORD *)result + 1) = 0;
  v6 = *((unsigned int *)result + 4);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 56 * v6;
    do
    {
      *v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      sub_1C61A45F4(*(_QWORD *)v5, *((_DWORD *)v5 + 4), v9, &v11);
      v10 = v11;
      *v11 = *a2;
      sub_1C4EC4B4C((unint64_t *)v10 + 1, a2 + 1);
      ++*((_DWORD *)v5 + 2);
      result = sub_1C61A406C((llvm::ValueHandleBase *)(a2 + 1));
    }
    a2 += 7;
  }
  return result;
}

uint64_t sub_1C61A487C(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;

  v13 = 0;
  result = sub_1C4ECB0EC(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *a3, &v13);
  v9 = v13;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61A4D18(a2, a3, v13);
    v9 = (_QWORD *)result;
    *(_QWORD *)result = *a3;
    v12 = *a4;
    *(_QWORD *)(result + 24) = *((_QWORD *)a4 + 2);
    *(_OWORD *)(result + 8) = v12;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 32 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

void llvm::initializeMemoryDependenceWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E538);
  if (v2 != -1)
  {
    v5[0] = sub_1C4ECA1DC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E538, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::MemoryDependenceWrapperPass *llvm::MemoryDependenceWrapperPass::MemoryDependenceWrapperPass(llvm::MemoryDependenceWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::MemoryDependenceWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E8139610;
  *((_BYTE *)this + 32) = 0;
  *((_BYTE *)this + 440) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E538);
  if (v2 != -1)
  {
    v6[0] = sub_1C4ECA1DC;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E538, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::MemoryDependenceWrapperPass::releaseMemory(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)(this + 440))
  {
    v1 = this;
    this = sub_1C4ECAE14(this + 32);
    *(_BYTE *)(v1 + 440) = 0;
  }
  return this;
}

llvm::AnalysisUsage *llvm::MemoryDependenceWrapperPass::getAnalysisUsage(llvm::MemoryDependenceWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AssumptionCacheTracker::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::DominatorTreeWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::PhiValuesWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AAResultsWrapperPass::ID);
  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
}

uint64_t llvm::MemoryDependenceWrapperPass::runOnFunction(llvm::MemoryDependenceWrapperPass *this, llvm::Function *a2)
{
  char **v4;
  char *v5;
  uint64_t v6;
  char **v7;
  char *v8;
  llvm::AssumptionCacheTracker *v9;
  uint64_t AssumptionCache;
  char **v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char **v15;
  char *v16;
  uint64_t v17;
  char **v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = (char **)**((_QWORD **)this + 1);
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != llvm::AAResultsWrapperPass::ID);
  v6 = *(_QWORD *)((*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), llvm::AAResultsWrapperPass::ID)+ 32);
  v7 = (char **)**((_QWORD **)this + 1);
  do
  {
    v8 = *v7;
    v7 += 2;
  }
  while (v8 != llvm::AssumptionCacheTracker::ID);
  v9 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v7 - 1) + 96))(*(v7 - 1), llvm::AssumptionCacheTracker::ID);
  AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v9, a2);
  v11 = (char **)**((_QWORD **)this + 1);
  do
  {
    v12 = *v11;
    v11 += 2;
  }
  while (v12 != llvm::TargetLibraryInfoWrapperPass::ID);
  v13 = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v11 - 1) + 96))(*(v11 - 1), llvm::TargetLibraryInfoWrapperPass::ID);
  v14 = sub_1C4D914E8(v13, (uint64_t)a2);
  v15 = (char **)**((_QWORD **)this + 1);
  do
  {
    v16 = *v15;
    v15 += 2;
  }
  while (v16 != llvm::DominatorTreeWrapperPass::ID);
  v17 = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v15 - 1) + 96))(*(v15 - 1), llvm::DominatorTreeWrapperPass::ID);
  v18 = (char **)**((_QWORD **)this + 1);
  do
  {
    v19 = *v18;
    v18 += 2;
  }
  while (v19 != llvm::PhiValuesWrapperPass::ID);
  v20 = *(_QWORD *)((*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v18 - 1) + 96))(*(v18 - 1), llvm::PhiValuesWrapperPass::ID)+ 32);
  v21 = (char *)this + 32;
  if (*((_BYTE *)this + 440))
    v21 = (char *)sub_1C4ECAE14((uint64_t)v21);
  sub_1C4ECAD80((uint64_t)v21, v6, AssumptionCache, v14, v17 + 32, v20, dword_1ED82E4F8);
  *((_BYTE *)this + 440) = 1;
  return 0;
}

llvm::MemoryDependenceWrapperPass *llvm::callDefaultCtor<llvm::MemoryDependenceWrapperPass>()
{
  llvm::MemoryDependenceWrapperPass *v0;

  v0 = (llvm::MemoryDependenceWrapperPass *)operator new();
  return llvm::MemoryDependenceWrapperPass::MemoryDependenceWrapperPass(v0);
}

_QWORD *sub_1C61A4D18(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4ECB180(a1, v6);
  v8 = 0;
  sub_1C4ECB0EC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61A4DC8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  __int128 v11;
  _QWORD *v12;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 32 * v6;
    do
    {
      *v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      result = sub_1C4ECB0EC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      v10 = v12;
      *v12 = *(_QWORD *)a2;
      v11 = *(_OWORD *)(a2 + 8);
      v10[3] = *(_QWORD *)(a2 + 24);
      *(_OWORD *)(v10 + 1) = v11;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

_QWORD *sub_1C61A4E7C(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61A4EFC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61A4F98(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 5;
    v5[2] = v5 + 5;
    v5[3] = 4;
    *((_DWORD *)v5 + 8) = 0;
  }
  return v5;
}

uint64_t sub_1C61A4EFC(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 72 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 72 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61A4F98(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4ECB238(a1, v6);
  v8 = 0;
  sub_1C61A4EFC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61A5048(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  void *v11;
  void *v12;
  uint64_t *v13;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 72 * v6;
    do
    {
      *v7 = -4096;
      v7 += 9;
      v8 -= 72;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v13 = 0;
      sub_1C61A4EFC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      v10 = v13;
      v11 = v13 + 5;
      *v13 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v11, 4, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      v12 = (void *)a2[2];
      if (v12 != (void *)a2[1])
        free(v12);
    }
    a2 += 9;
  }
}

void sub_1C61A5118(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  int v5;
  unint64_t v6;

  v6 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 88, &v6);
  sub_1C4ECCC70((uint64_t *)a1, (uint64_t)v3);
  v4 = v6;
  if (*(_QWORD *)a1 != a1 + 16)
  {
    v5 = v6;
    free(*(void **)a1);
    v4 = v5;
  }
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

_QWORD *sub_1C61A5188(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v8;

  v8 = 0;
  v4 = sub_1C4B04B98(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  v5 = v8;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C4ECB878(a1, a2, v8);
    v6 = *a2;
    *((_BYTE *)v5 + 32) = 0;
    v5[2] = 0;
    v5[3] = 0;
    *v5 = v6;
    v5[1] = 0;
  }
  return v5;
}

llvm::raw_ostream *llvm::LocationSize::print(llvm::LocationSize *this, llvm::raw_ostream *a2)
{
  char *v4;
  char *v5;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *result;
  _BYTE *v8;

  sub_1C4816AD8(a2, "LocationSize::");
  switch(*(_QWORD *)this)
  {
    case 0xFFFFFFFFFFFFFFFCLL:
      v4 = "mapTombstone";
      goto LABEL_10;
    case 0xFFFFFFFFFFFFFFFDLL:
      v4 = "mapEmpty";
      goto LABEL_10;
    case 0xFFFFFFFFFFFFFFFELL:
      v4 = "afterPointer";
      goto LABEL_10;
    case 0xFFFFFFFFFFFFFFFFLL:
      v4 = "beforeOrAfterPointer";
LABEL_10:
      result = sub_1C4816AD8(a2, v4);
      break;
    default:
      if ((*(_QWORD *)this & 0x8000000000000000) != 0)
        v5 = "upperBound(";
      else
        v5 = "precise(";
      v6 = sub_1C4816AD8(a2, v5);
      result = llvm::raw_ostream::operator<<(v6, *(_QWORD *)this & 0x7FFFFFFFFFFFFFFFLL);
      v8 = (_BYTE *)*((_QWORD *)result + 4);
      if ((unint64_t)v8 >= *((_QWORD *)result + 3))
      {
        result = llvm::raw_ostream::write(result, 41);
      }
      else
      {
        *((_QWORD *)result + 4) = v8 + 1;
        *v8 = 41;
      }
      break;
  }
  return result;
}

uint64_t ***llvm::MemoryLocation::get@<X0>(uint64_t ***a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t ***result;

  v3 = (uint64_t)*(a1 - 4);
  result = llvm::Instruction::getAAMetadata(a1, a2 + 2);
  *a2 = v3;
  a2[1] = -2;
  return result;
}

void llvm::initializeMemorySSAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E540);
  if (v2 != -1)
  {
    v5[0] = sub_1C4ECDA68;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E540, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

_QWORD *llvm::MemorySSA::moveTo(int32x2_t *a1, uint64_t a2, llvm::BasicBlock *a3, _QWORD *a4)
{
  llvm::MemorySSA::prepareForMoveTo(a1, a2, (uint64_t)a3);
  return llvm::MemorySSA::insertIntoListsBefore((llvm::MemorySSA *)a1, a2, a3, a4);
}

_QWORD *llvm::MemorySSA::dump(llvm::Function **this)
{
  llvm *v2;
  _QWORD v4[2];

  v2 = llvm::dbgs((llvm *)this);
  v4[0] = &off_1E8139860;
  v4[1] = this;
  return llvm::Function::print(this[2], v2, (llvm::AssemblyAnnotationWriter *)v4, 0, 0);
}

llvm::raw_ostream *llvm::MemoryAccess::print(llvm::MemoryPhi *this, llvm::raw_ostream **a2)
{
  int v2;

  v2 = *((unsigned __int8 *)this + 16);
  if (v2 == 27)
    return llvm::MemoryPhi::print(this, a2);
  if (v2 == 25)
    return llvm::MemoryUse::print(this, (llvm::raw_ostream *)a2);
  return llvm::MemoryDef::print(this, (llvm::raw_ostream *)a2);
}

llvm::raw_ostream *llvm::MemoryDef::print(llvm::MemoryDef *this, llvm::raw_ostream *a2)
{
  llvm::MemoryDef *v4;
  uint64_t *v5;
  uint64_t v6;
  llvm::raw_ostream *result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  llvm::raw_ostream *v11;

  if (*((_BYTE *)this + 16) == 25)
    v4 = this;
  else
    v4 = 0;
  if (v4)
    v5 = (uint64_t *)((char *)v4 - 32);
  else
    v5 = (uint64_t *)((char *)this - 64);
  v6 = *v5;
  sub_1C5E21910(a2, *((unsigned int *)this + 22), 0, 0, 0);
  sub_1C4816AD8(a2, " = MemoryDef(");
  sub_1C4ED2C2C(a2, v6);
  result = sub_1C4816AD8(a2, ")");
  v8 = *((_QWORD *)this - 4);
  if (v8)
  {
    v9 = 72;
    if (*(_BYTE *)(v8 + 16) == 26)
      v9 = 88;
    if (*((_DWORD *)this + 23) == *(_DWORD *)(v8 + v9))
    {
      sub_1C4816AD8(a2, "->");
      sub_1C4ED2C2C(a2, *((_QWORD *)this - 4));
      result = (llvm::raw_ostream *)sub_1C4ED5384((uint64_t)this);
      if ((_DWORD)result)
      {
        v10 = *((_QWORD *)this + 10);
        if ((v10 & 0xFF00000000) != 0)
        {
          v11 = sub_1C4816AD8(a2, " ");
          return llvm::operator<<(v11, v10);
        }
      }
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MemoryUse::print(llvm::MemoryUse *this, llvm::raw_ostream *a2)
{
  llvm::MemoryUse *v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned int v7;
  _BYTE *v8;
  llvm::raw_ostream *result;
  uint64_t v10;
  llvm::raw_ostream *v11;

  if (*((_BYTE *)this + 16) == 25)
    v4 = this;
  else
    v4 = 0;
  if (v4)
    v5 = (uint64_t *)((char *)v4 - 32);
  else
    v5 = (uint64_t *)((char *)this - 64);
  v6 = *v5;
  sub_1C4816AD8(a2, "MemoryUse(");
  if (v6)
  {
    if (*(_BYTE *)(v6 + 16) == 26)
    {
      v7 = *(_DWORD *)(v6 + 88);
      if (v7)
      {
LABEL_10:
        sub_1C5E21910(a2, v7, 0, 0, 0);
        goto LABEL_13;
      }
    }
    else
    {
      v7 = *(_DWORD *)(v6 + 72);
      if (v7)
        goto LABEL_10;
    }
  }
  sub_1C4816AD8(a2, "liveOnEntry");
LABEL_13:
  v8 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v8 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 41);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v8 + 1;
    *v8 = 41;
  }
  result = (llvm::raw_ostream *)sub_1C4ED5384((uint64_t)this);
  if ((_DWORD)result)
  {
    v10 = *((_QWORD *)this + 10);
    if ((v10 & 0xFF00000000) != 0)
    {
      v11 = sub_1C4816AD8(a2, " ");
      return llvm::operator<<(v11, v10);
    }
  }
  return result;
}

_QWORD *llvm::MemorySSAWalkerPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, llvm::Value *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  llvm::MemorySSA *v7;
  llvm::raw_ostream *v8;
  size_t v9;
  char *Name;
  size_t v11;
  void *v12;
  _QWORD v14[3];

  v7 = *(llvm::MemorySSA **)(llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::MemorySSAAnalysis::Key, (uint64_t)a2)+ 8);
  v8 = sub_1C4816AD8(*a1, "MemorySSA (walker) for function: ");
  Name = llvm::Value::getName(a2);
  v11 = v9;
  v12 = (void *)*((_QWORD *)v8 + 4);
  if (v9 <= *((_QWORD *)v8 + 3) - (_QWORD)v12)
  {
    if (v9)
    {
      memcpy(v12, Name, v9);
      *((_QWORD *)v8 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, Name, v9);
  }
  sub_1C4816AD8(v8, "\n");
  v14[0] = &off_1E81398A8;
  v14[1] = v7;
  v14[2] = llvm::MemorySSA::getWalkerImpl(v7);
  llvm::Function::print(a2, *a1, (llvm::AssemblyAnnotationWriter *)v14, 0, 0);
  return llvm::InstCountPass::run(a4);
}

_QWORD *llvm::MemorySSAVerifierPass::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::MemorySSAAnalysis::Key, a1);
  return llvm::InstCountPass::run(a3);
}

uint64_t llvm::MemorySSAWrapperPass::MemorySSAWrapperPass(uint64_t this)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD v7[2];

  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = &llvm::MemorySSAWrapperPass::ID;
  *(_DWORD *)(this + 24) = 2;
  *(_QWORD *)this = &off_1E8139750;
  *(_QWORD *)(this + 32) = 0;
  if (!atomic_load(qword_1ED830BC0))
  {
    v3 = this;
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED830BC0, (void *(*)(void))sub_1C624602C, (void (*)(void *))sub_1C62460B0);
    this = v3;
  }
  v5 = qword_1ED830BC0[0];
  v2 = atomic_load(&qword_1ED82E540);
  if (v2 != -1)
  {
    v7[0] = sub_1C4ECDA68;
    v7[1] = &v5;
    v6 = v7;
    v4 = this;
    std::__call_once(&qword_1ED82E540, &v6, (void (__cdecl *)(void *))sub_1C4776838);
    return v4;
  }
  return this;
}

llvm::AnalysisUsage *llvm::MemorySSAWrapperPass::getAnalysisUsage(llvm::MemorySSAWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::DominatorTreeWrapperPass::ID);
  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AAResultsWrapperPass::ID);
}

_QWORD *llvm::MemorySSAWrapperPass::print(llvm::MemorySSAWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v3;
  _QWORD v5[2];

  v3 = *((_QWORD *)this + 4);
  v5[0] = &off_1E8139860;
  v5[1] = v3;
  return llvm::Function::print(*(llvm::Function **)(v3 + 16), a2, (llvm::AssemblyAnnotationWriter *)v5, 0, 0);
}

void sub_1C61A58D8(llvm::Pass *a1)
{
  sub_1C61A5924(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t llvm::callDefaultCtor<llvm::MemorySSAWrapperPass>()
{
  uint64_t v0;

  v0 = operator new();
  return llvm::MemorySSAWrapperPass::MemorySSAWrapperPass(v0);
}

void sub_1C61A5924(llvm::Pass *this)
{
  llvm::MemorySSA *v2;
  llvm::Pass *v3;

  *(_QWORD *)this = &off_1E8139750;
  v2 = (llvm::MemorySSA *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
  {
    v3 = this;
    llvm::MemorySSA::~MemorySSA(v2);
    MEMORY[0x1CAA32FC0]();
    llvm::Pass::~Pass(v3);
  }
  else
  {
    llvm::Pass::~Pass(this);
  }
}

void sub_1C61A5980(_WORD *a1, int **a2, __int128 *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F2BB0, 0, 0);
  dword_1ED7F2C30 = 0;
  qword_1ED7F2C38 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F2C40 = 0;
  qword_1ED7F2BB0 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F2C48 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F2C50 = (uint64_t)&off_1E7F95260;
  qword_1ED7F2C68 = (uint64_t)&qword_1ED7F2C50;
  llvm::cl::Option::setArgStr(v6, "memssa-check-limit", 0x12uLL);
  word_1ED7F2BBA = (32 * (*a1 & 3)) | word_1ED7F2BBA & 0xFF9F;
  dword_1ED7F2C30 = **a2;
  byte_1ED7F2C44 = 1;
  dword_1ED7F2C40 = dword_1ED7F2C30;
  xmmword_1ED7F2BD0 = *a3;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F2BB0);
}

void sub_1C61A5A64()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61A5A78()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A5A8C(uint64_t a1, uint64_t a2, __int128 *a3)
{
  int v4;

  v4 = dword_1ED7F2C30;
  return sub_1C4ED8F7C(*(_QWORD *)(a1 + 16), a2, a3, &v4);
}

uint64_t sub_1C61A5ABC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;

  v12 = 0;
  result = sub_1C4926528(a1, a2, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C4ED90AC(a1, (uint64_t)a2, a2, v12);
    v9 = (_QWORD *)result;
    *(_QWORD *)result = *a2;
    *(_QWORD *)(result + 8) = *a3;
    v10 = 1;
  }
  v11 = *(_QWORD *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a4 = v9;
  *(_QWORD *)(a4 + 8) = v11;
  *(_BYTE *)(a4 + 16) = v10;
  return result;
}

void sub_1C61A5B4C()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A5B60(uint64_t a1, uint64_t a2)
{
  int v3;

  v3 = dword_1ED7F2C30;
  return sub_1C4ED4CC4(*(_QWORD *)(a1 + 16), a2, &v3, 1);
}

uint64_t sub_1C61A5B94(uint64_t a1, uint64_t a2, __int128 *a3)
{
  int v4;

  v4 = dword_1ED7F2C30;
  return sub_1C4ED93A4(*(_QWORD *)(a1 + 16), a2, a3, &v4);
}

llvm::raw_ostream *sub_1C61A5BC4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  llvm::Value *v6;

  sub_1C4ED9448((llvm::raw_ostream **)a1, a2);
  v3 = ***(_QWORD ***)(a1 + 8);
  v4 = v3 + 72;
  for (i = *(_QWORD *)(v3 + 80); i != v4; i = *(_QWORD *)(i + 8))
  {
    if (i)
      v6 = (llvm::Value *)(i - 24);
    else
      v6 = 0;
    sub_1C4ED99E8((llvm::raw_ostream **)a1, v6);
  }
  return sub_1C4816AD8(*(llvm::raw_ostream **)a1, "}\n");
}

_QWORD *sub_1C61A5C30(uint64_t a1, llvm::raw_ostream *a2, llvm::BasicBlock *a3)
{
  return llvm::BasicBlock::print(a3, a2, (llvm::AssemblyAnnotationWriter *)(*(_QWORD *)a1 + 8), 1, 1);
}

void sub_1C61A5C4C(int a1, std::string *__str, _DWORD *a3, unsigned int a4)
{
  sub_1C4EDA980(__str, a3, a4);
}

uint64_t llvm::MemorySSAUpdater::removeDuplicatePhiEdgesBetween(llvm::MemorySSAUpdater *this, const llvm::BasicBlock *a2, const llvm::BasicBlock *a3)
{
  uint64_t v5;
  uint64_t result;
  _DWORD *v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  const llvm::BasicBlock *v14;

  v5 = *(_QWORD *)this + 24;
  v13 = 0;
  v14 = a3;
  result = sub_1C4926528(v5, &v14, &v13);
  if ((result & 1) != 0)
  {
    v7 = *(_DWORD **)(v13 + 8);
    if (v7)
    {
      v8 = v7[5];
      v9 = v8 & 0x7FFFFFF;
      if ((v8 & 0x7FFFFFF) != 0)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((v8 & 0x40000000) != 0)
            v12 = (_DWORD *)*((_QWORD *)v7 - 1);
          else
            v12 = &v7[-8 * (v8 & 0x7FFFFFF)];
          if (*(const llvm::BasicBlock **)&v12[8 * v7[19] + 2 * v10] == a2)
          {
            if (v11)
            {
              sub_1C4EDF39C((uint64_t)v7, v10);
              v8 = v7[5];
              v9 = v8 & 0x7FFFFFF;
              --v10;
            }
            v11 = 1;
          }
          ++v10;
        }
        while (v10 != v9);
      }
      return llvm::MemorySSAUpdater::tryRemoveTrivialPhi(this, (llvm::MemoryPhi *)v7);
    }
  }
  return result;
}

void llvm::MemorySSAUpdater::updateExitBlocksForClonedLoop(int32x2_t **a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *v5;
  uint64_t *v6;

  v6 = (uint64_t *)*MEMORY[0x1E0C80C00];
  v5 = a4;
  sub_1C4EE0074(a1, a2, a3, &v5, &v6, a5);
}

void *sub_1C61A5D94(uint64_t a1, uint64_t *a2)
{
  void *result;
  uint64_t v5;
  uint64_t v6;
  _BYTE v7[24];

  result = sub_1C61A63A8((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    v5 = *a2;
    v6 = *(unsigned int *)(a1 + 48);
    if (v6 >= *(_DWORD *)(a1 + 52))
    {
      result = llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 40, a1 + 56, v6 + 1, 8);
      LODWORD(v6) = *(_DWORD *)(a1 + 48);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 48);
  }
  return result;
}

void llvm::MemorySSAUpdater::moveAfter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1C4EE2E28(a1, a2, *(llvm::BasicBlock **)(a3 + 64), *(_QWORD **)(a3 + 40));
}

uint64_t llvm::MemorySSAUpdater::moveAllAfterSpliceBlocks(int32x2_t **this, llvm::BasicBlock *a2, llvm::BasicBlock **a3, llvm::Instruction *a4)
{
  uint64_t result;
  llvm::BasicBlock *v8;
  unsigned __int8 *v9;
  int v10;
  unsigned int i;
  uint64_t Successor;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  result = (uint64_t)llvm::MemorySSAUpdater::moveAllAccesses(this, a2, (llvm::BasicBlock *)a3, a4);
  v8 = a3[5];
  if (v8 != (llvm::BasicBlock *)(a3 + 5))
  {
    v9 = v8 ? (unsigned __int8 *)v8 - 24 : 0;
    if (v9[16] - 29 <= 0xA)
    {
      result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v9);
      if ((_DWORD)result)
      {
        v10 = result;
        for (i = 0; i != v10; ++i)
        {
          Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v9, i);
          v13 = (uint64_t)&(*this)[3];
          v20 = 0;
          v21 = Successor;
          result = sub_1C4926528(v13, &v21, &v20);
          if ((result & 1) != 0)
          {
            v14 = *(_QWORD *)(v20 + 8);
            if (v14)
            {
              v15 = *(_DWORD *)(v14 + 20);
              v16 = v15 & 0x7FFFFFF;
              if ((v15 & 0x7FFFFFF) != 0)
              {
                v17 = 0;
                while (1)
                {
                  v18 = v14 - 32 * v16;
                  if ((v15 & 0x40000000) != 0)
                    v18 = *(_QWORD *)(v14 - 8);
                  if (*(llvm::BasicBlock **)(v18 + 32 * *(unsigned int *)(v14 + 76) + 8 * v17) == a2)
                    break;
                  if (v16 == ++v17)
                    goto LABEL_16;
                }
              }
              else
              {
LABEL_16:
                LODWORD(v17) = -1;
              }
              if ((v15 & 0x40000000) != 0)
                v19 = *(_QWORD *)(v14 - 8);
              else
                v19 = v14 - 32 * v16;
              *(_QWORD *)(v19 + 32 * *(unsigned int *)(v14 + 76) + 8 * v17) = a3;
            }
          }
        }
      }
    }
  }
  return result;
}

char *llvm::MemorySSAUpdater::createMemoryAccessBefore(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *DefinedAccess;

  DefinedAccess = llvm::MemorySSA::createDefinedAccess(*a1, a2, a3, 0);
  llvm::MemorySSA::insertIntoListsBefore((llvm::MemorySSA *)*a1, (uint64_t)DefinedAccess, *(llvm::BasicBlock **)(a4 + 64), (_QWORD *)(a4 + 32));
  return DefinedAccess;
}

char *llvm::MemorySSAUpdater::createMemoryAccessAfter(uint64_t **this, llvm::Instruction *a2, llvm::MemoryAccess *a3, llvm::BasicBlock **a4)
{
  char *DefinedAccess;

  DefinedAccess = llvm::MemorySSA::createDefinedAccess(*this, (uint64_t)a2, (uint64_t)a3, 0);
  llvm::MemorySSA::insertIntoListsBefore((llvm::MemorySSA *)*this, (uint64_t)DefinedAccess, a4[8], a4[5]);
  return DefinedAccess;
}

_QWORD *sub_1C61A5FF8(_QWORD *a1, unsigned int a2)
{
  uint64_t v3;
  _QWORD *result;
  int v5;
  _QWORD *v6;

  if (a2 <= 4)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    v3 = a2;
    result = operator new(8 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      v6 = &result[v3];
      goto LABEL_6;
    }
  }
  result = a1 + 1;
  v6 = a1 + 5;
  do
LABEL_6:
    *result++ = -4096;
  while (result != v6);
  return result;
}

void sub_1C61A6078(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  int v5;
  unint64_t v6;

  v6 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 24, &v6);
  sub_1C4EE47F0(*(_QWORD *)a1, *(_DWORD *)(a1 + 8), (uint64_t)v3);
  v4 = v6;
  if (*(_QWORD *)a1 != a1 + 16)
  {
    v5 = v6;
    free(*(void **)a1);
    v4 = v5;
  }
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

unint64_t *sub_1C61A60EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t *result;
  unint64_t v11;

  v7 = a2 + 8;
  v8 = operator new(0x38uLL);
  *(_QWORD *)a1 = v8;
  *(_QWORD *)(a1 + 8) = v7;
  v9 = v8;
  v8[6] = a4;
  v8[4] = 4;
  result = v8 + 4;
  v9[5] = 0;
  v11 = (unint64_t)(v9 + 5);
  if (a4 != -8192 && a4 != -4096)
  {
    if (a4)
    {
      *(_QWORD *)v11 = *(_QWORD *)(a3 & 0xFFFFFFFFFFFFFFF8);
      *(_QWORD *)(a3 & 0xFFFFFFFFFFFFFFF8) = result;
      *result = a3 & 0xFFFFFFFFFFFFFFF8 | 4;
      if (*(_QWORD *)v11)
        **(_QWORD **)v11 = **(_QWORD **)v11 & 7 | v11;
    }
  }
  *(_BYTE *)(a1 + 16) = 1;
  return result;
}

void sub_1C61A6188(uint64_t a1, unint64_t a2)
{
  _QWORD *v2;
  uint64_t *v3;
  unint64_t v4;
  BOOL v5;
  _QWORD *v6;

  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v3 = (uint64_t *)(a1 + 8);
    do
    {
      v4 = v2[4];
      v5 = v4 >= a2;
      if (v4 >= a2)
        v6 = v2;
      else
        v6 = v2 + 1;
      if (v5)
        v3 = v2;
      v2 = (_QWORD *)*v6;
    }
    while (*v6);
    if (v3 != (uint64_t *)(a1 + 8) && v3[4] <= a2)
    {
      sub_1C49C7D1C((uint64_t **)a1, v3);
      operator delete(v3);
    }
  }
}

uint64_t sub_1C61A61F8(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 72);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[2 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C4EE5368((uint64_t)v5, a2, &v11);
      v10 = v11;
      *v11 = *a2;
      v10[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1C61A62BC(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1 == *(_QWORD *)(a1 + 32))
    return 0;
  else
    return v1 - 8;
}

uint64_t sub_1C61A62D4(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 16) == *(_QWORD *)(a1 + 40))
    return 0;
  else
    return *(_QWORD *)(a1 + 16);
}

uint64_t sub_1C61A62E8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 72);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[2 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      result = sub_1C4EE6120((uint64_t)v5, v10, &v12);
      v11 = v12;
      *v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

_QWORD *sub_1C61A63A8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *result;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v14 = 0;
  result = (_QWORD *)sub_1C61A6464(a2, *a3, &v14);
  v7 = v14;
  if ((_DWORD)result)
  {
    v12 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v13 = 4;
    }
    else
    {
      v12 = *(_QWORD *)(a2 + 8);
      v13 = *(unsigned int *)(a2 + 16);
    }
    v11 = 0;
    v10 = v12 + 8 * v13;
  }
  else
  {
    result = sub_1C61A6508((_DWORD *)a2, a3, v14);
    v7 = result;
    *result = *a3;
    v8 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v9 = 4;
    }
    else
    {
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(unsigned int *)(a2 + 16);
    }
    v10 = v8 + 8 * v9;
    v11 = 1;
  }
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v10;
  *(_BYTE *)(a1 + 16) = v11;
  return result;
}

uint64_t sub_1C61A6464(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t result;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_8;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 8 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
LABEL_17:
    result = 1;
  }
  else
  {
    v9 = 0;
    v10 = 1;
    while (v8 != -4096)
    {
      if (v9)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v9 = v7;
      v13 = v6 + v10++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 8 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_17;
    }
    result = 0;
    if (v9)
      v7 = v9;
  }
LABEL_8:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61A6508(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v3;
  unsigned int v4;
  uint64_t v7;
  _QWORD *v8;

  v3 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v4 = 4;
  else
    v4 = a1[4];
  if (4 * v3 + 4 >= 3 * v4)
  {
    v4 *= 2;
  }
  else if (v4 + ~v3 - a1[1] > v4 >> 3)
  {
    goto LABEL_5;
  }
  v7 = (uint64_t)a1;
  sub_1C4EE6344((uint64_t)a1, v4);
  v8 = 0;
  sub_1C61A6464(v7, *a2, &v8);
  a1 = (_DWORD *)v7;
  a3 = v8;
LABEL_5:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

uint64_t sub_1C61A65C8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 40);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C61A6464((uint64_t)v5, v10, &v11);
      *v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

void sub_1C61A6688(unsigned int *a1, char *a2, char *a3)
{
  char *v4;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  llvm::ValueHandleBase *v9;
  uint64_t v10;

  v4 = a2;
  v6 = a3 - a2;
  v7 = a1[2];
  v8 = v7 + ((a3 - a2) >> 3);
  if (v8 > a1[3])
  {
    sub_1C4EE49E4(a1, v8);
    LODWORD(v7) = a1[2];
  }
  if (v4 != a3)
  {
    v9 = (llvm::ValueHandleBase *)(*(_QWORD *)a1 + 24 * v7);
    do
    {
      v10 = *(_QWORD *)v4;
      *(_QWORD *)v9 = 4;
      *((_QWORD *)v9 + 1) = 0;
      *((_QWORD *)v9 + 2) = v10;
      if (v10 != -8192 && v10 != -4096 && v10 != 0)
        llvm::ValueHandleBase::AddToUseList(v9);
      v4 += 8;
      v9 = (llvm::ValueHandleBase *)((char *)v9 + 24);
    }
    while (v4 != a3);
    LODWORD(v7) = a1[2];
  }
  a1[2] = v7 + (v6 >> 3);
}

_QWORD *sub_1C61A6740(_QWORD *result)
{
  int v1;
  _QWORD *v2;
  _QWORD *v3;
  int v4;
  uint64_t v5;

  v1 = *(_DWORD *)result;
  if (*(_DWORD *)result > 1u || *((_DWORD *)result + 1))
  {
    if ((v1 & 1) != 0)
    {
      v2 = result + 1;
      v3 = result + 5;
    }
    else
    {
      v5 = *((unsigned int *)result + 4);
      if (((2 * v1) & 0xFFFFFFFC) < v5)
      {
        if (v5 > 0x40)
          return sub_1C61A67BC(result);
      }
      else if (!(_DWORD)v5)
      {
        v4 = 0;
LABEL_6:
        *(_DWORD *)result = v4;
        *((_DWORD *)result + 1) = 0;
        return result;
      }
      v2 = (_QWORD *)result[1];
      v3 = &v2[v5];
    }
    do
      *v2++ = -4096;
    while (v2 != v3);
    v4 = *(_DWORD *)result & 1;
    goto LABEL_6;
  }
  return result;
}

_QWORD *sub_1C61A67BC(_QWORD *result)
{
  _QWORD *v1;
  unsigned int v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD *v7;

  v1 = result;
  v2 = *(_DWORD *)result;
  v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if (v3 - 28 >= 3)
    v4 = 1 << (33 - v3);
  else
    v4 = 64;
  if (v2 >= 2)
    v5 = v4;
  else
    v5 = 0;
  if ((v2 & 1) != 0 && v5 < 5)
  {
    v6 = result + 1;
    *result = 1;
    v7 = result + 5;
    goto LABEL_10;
  }
  if ((v2 & 1) != 0)
    return sub_1C61A5FF8(v1, v5);
  if (v5 != *((_DWORD *)result + 4))
  {
    MEMORY[0x1CAA32FB4](result[1], 8);
    return sub_1C61A5FF8(v1, v5);
  }
  *result = 0;
  if (!v5)
    return result;
  v6 = (_QWORD *)result[1];
  v7 = &v6[v5];
  do
LABEL_10:
    *v6++ = -4096;
  while (v6 != v7);
  return result;
}

uint64_t sub_1C61A6880(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 8;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  v7 = (_QWORD *)(v3 + 8 * v6);
  v8 = *v7;
  if (*a2 == *v7)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 8 * (v13 & v5));
      v8 = *v7;
      if (*a2 == *v7)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t llvm::createModuleDebugInfoPrinterPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EE65A0(v1);
}

double llvm::ModuleDebugInfoPrinterPass::ModuleDebugInfoPrinterPass(llvm::ModuleDebugInfoPrinterPass *this, llvm::raw_ostream *a2)
{
  double result;

  *(_QWORD *)this = (char *)this + 16;
  *((_QWORD *)this + 1) = 0x800000000;
  *((_QWORD *)this + 10) = (char *)this + 96;
  *((_QWORD *)this + 11) = 0x800000000;
  *((_QWORD *)this + 20) = (char *)this + 176;
  *((_QWORD *)this + 21) = 0x800000000;
  *((_QWORD *)this + 30) = (char *)this + 256;
  *((_QWORD *)this + 31) = 0x800000000;
  *((_QWORD *)this + 40) = (char *)this + 336;
  *((_QWORD *)this + 41) = 0x800000000;
  *((_QWORD *)this + 50) = (char *)this + 432;
  *((_QWORD *)this + 51) = (char *)this + 432;
  *(_QWORD *)&result = 32;
  *((_QWORD *)this + 52) = 32;
  *((_DWORD *)this + 106) = 0;
  *((_QWORD *)this + 86) = a2;
  return result;
}

_QWORD *llvm::ModuleDebugInfoPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, const llvm::Module *a2@<X1>, uint64_t a3@<X8>)
{
  llvm::DebugInfoFinder::processModule((llvm::DebugInfoFinder *)a1, a2);
  sub_1C4EE6728(a1[86], (unsigned __int8 ***)a1);
  return llvm::InstCountPass::run(a3);
}

uint64_t llvm::ModuleSummaryIndexAnalysis::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  void (**v8)(void);
  uint64_t result;
  uint64_t (**v10)(void);
  _QWORD v11[3];
  _QWORD *v12;
  _QWORD v13[3];
  _QWORD *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v6 = llvm::AnalysisManager<llvm::Module>::getResultImpl(a2, &llvm::ProfileSummaryAnalysis::Key, a1) + 8;
  v7 = *(_QWORD *)(llvm::AnalysisManager<llvm::Module>::getResultImpl(a2, &llvm::InnerAnalysisManagerProxy<llvm::AnalysisManager<llvm::Function>,llvm::Module>::Key, a1)+ 8);
  v13[0] = &off_1E8139D00;
  v13[1] = v7;
  v14 = v13;
  v11[0] = &off_1E8139D48;
  v11[1] = v7;
  v11[2] = llvm::needsParamAccessSummary(a1);
  v12 = v11;
  llvm::buildModuleSummaryIndex(a1, (uint64_t)v13, v6, v11, a3);
  if (v12 == v11)
  {
    v8 = (void (**)(void))(v11[0] + 32);
  }
  else
  {
    if (!v12)
      goto LABEL_5;
    v8 = (void (**)(void))(*v12 + 40);
  }
  (*v8)();
LABEL_5:
  result = (uint64_t)v14;
  if (v14 == v13)
  {
    v10 = (uint64_t (**)(void))(v13[0] + 32);
  }
  else
  {
    if (!v14)
      return result;
    v10 = (uint64_t (**)(void))(*v14 + 40);
  }
  return (*v10)();
}

void llvm::initializeModuleSummaryIndexWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E898);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EE9F88;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E898, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::ModuleSummaryIndexWrapperPass *llvm::ModuleSummaryIndexWrapperPass::ModuleSummaryIndexWrapperPass(llvm::ModuleSummaryIndexWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::ModuleSummaryIndexWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E8139A78;
  *((_BYTE *)this + 32) = 0;
  *((_BYTE *)this + 336) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E898);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EE9F88;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E898, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::ModuleSummaryIndexWrapperPass::runOnModule(llvm::ModuleSummaryIndexWrapperPass *this, llvm::Module *a2)
{
  char **v4;
  char *v5;
  uint64_t v6;
  void (**v7)(void);
  void (**v8)(void);
  char v10;
  _QWORD v11[3];
  _QWORD *v12;
  _QWORD v13[3];
  _QWORD *v14;
  _BYTE v15[304];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = (char **)**((_QWORD **)this + 1);
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != llvm::ProfileSummaryInfoWrapperPass::ID);
  v6 = *(_QWORD *)((*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);
  v10 = llvm::needsParamAccessSummary((uint64_t)a2);
  v13[0] = &off_1E8139D90;
  v13[1] = this;
  v14 = v13;
  v11[0] = &off_1E8139DD8;
  v11[1] = &v10;
  v11[2] = this;
  v12 = v11;
  llvm::buildModuleSummaryIndex((uint64_t)a2, (uint64_t)v13, v6, v11, (uint64_t)v15);
  if (*((_BYTE *)this + 336))
  {
    sub_1C61A8910((uint64_t)this + 32);
    *((_BYTE *)this + 336) = 0;
  }
  sub_1C61A8F54((uint64_t)this + 32, (uint64_t)v15);
  *((_BYTE *)this + 336) = 1;
  sub_1C61A8910((uint64_t)v15);
  if (v12 == v11)
  {
    v7 = (void (**)(void))(v11[0] + 32);
  }
  else
  {
    if (!v12)
      goto LABEL_9;
    v7 = (void (**)(void))(*v12 + 40);
  }
  (*v7)();
LABEL_9:
  if (v14 == v13)
  {
    v8 = (void (**)(void))(v13[0] + 32);
    goto LABEL_12;
  }
  if (v14)
  {
    v8 = (void (**)(void))(*v14 + 40);
LABEL_12:
    (*v8)();
  }
  return 0;
}

uint64_t llvm::ModuleSummaryIndexWrapperPass::doFinalization(llvm::ModuleSummaryIndexWrapperPass *this, llvm::Module *a2)
{
  if (*((_BYTE *)this + 336))
  {
    sub_1C61A8910((uint64_t)this + 32);
    *((_BYTE *)this + 336) = 0;
  }
  return 0;
}

llvm::AnalysisUsage *llvm::ModuleSummaryIndexWrapperPass::getAnalysisUsage(llvm::ModuleSummaryIndexWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, llvm::BlockFrequencyInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::ProfileSummaryInfoWrapperPass::ID);
  return llvm::AnalysisUsage::addRequiredID(a2, llvm::StackSafetyInfoWrapperPass::ID);
}

llvm::ImmutableModuleSummaryIndexWrapperPass *llvm::ImmutableModuleSummaryIndexWrapperPass::ImmutableModuleSummaryIndexWrapperPass(llvm::ImmutableModuleSummaryIndexWrapperPass *this, const llvm::ModuleSummaryIndex *a2)
{
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::ImmutableModuleSummaryIndexWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E8139B18;
  *((_QWORD *)this + 4) = a2;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v3 = atomic_load(&qword_1ED82E8A0);
  if (v3 != -1)
  {
    v7[0] = sub_1C4EEA05C;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82E8A0, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeImmutableModuleSummaryIndexWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E8A0);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EEA05C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E8A0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::ImmutableModuleSummaryIndexWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

llvm::ImmutableModuleSummaryIndexWrapperPass *llvm::createImmutableModuleSummaryIndexWrapperPass(llvm *this, const llvm::ModuleSummaryIndex *a2)
{
  llvm::ImmutableModuleSummaryIndexWrapperPass *v3;

  v3 = (llvm::ImmutableModuleSummaryIndexWrapperPass *)operator new();
  return llvm::ImmutableModuleSummaryIndexWrapperPass::ImmutableModuleSummaryIndexWrapperPass(v3, this);
}

void sub_1C61A6F7C(llvm::ModulePass *this)
{
  *(_QWORD *)this = &off_1E8139A78;
  if (*((_BYTE *)this + 336))
  {
    sub_1C61A8910((uint64_t)this + 32);
    *((_BYTE *)this + 336) = 0;
  }
  llvm::ModulePass::~ModulePass(this);
}

void sub_1C61A6FC0(llvm::ModulePass *this)
{
  *(_QWORD *)this = &off_1E8139A78;
  if (*((_BYTE *)this + 336))
  {
    sub_1C61A8910((uint64_t)this + 32);
    *((_BYTE *)this + 336) = 0;
  }
  llvm::ModulePass::~ModulePass(this);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61A701C(llvm::ImmutablePass *a1)
{
  llvm::ImmutablePass::~ImmutablePass(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A7040(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  *a1 = off_1E8139BC0;
  v2 = a1 + 71;
  v3 = (_QWORD *)a1[74];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
LABEL_3:
    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_4;
  }
  if (v3)
  {
    v4 = 5;
    goto LABEL_3;
  }
LABEL_4:
  a1[19] = &off_1E8139C28;
  v5 = (_QWORD *)a1[21];
  if (v5 != a1 + 23)
    free(v5);
  return sub_1C47A80D0(a1);
}

_QWORD *sub_1C61A70C0(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E8139C28;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

uint64_t sub_1C61A7100(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int v12;

  v12 = 0;
  v8 = sub_1C6159B48(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v12);
  if ((v8 & 1) != 0)
    return v8;
  **(_DWORD **)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C61A717C(v11);
}

uint64_t sub_1C61A717C(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 160) + 24))
    return 2;
  else
    return 3;
}

void sub_1C61A7194(_QWORD *a1)
{
  sub_1C61A7040(a1);
  JUMPOUT(0x1CAA32FC0);
}

unint64_t sub_1C61A71B8(uint64_t a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth(a1 + 152, a1);
}

uint64_t sub_1C61A71C4(uint64_t a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::generic_parser_base *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C61A71D4(llvm::raw_ostream *result, int a2, int a3)
{
  int v3;
  uint64_t (**v4)();
  int v5;
  char v6;

  if (a3)
  {
    v3 = **((_DWORD **)result + 16);
LABEL_3:
    v4 = &off_1E8139C78;
    v6 = 1;
    v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((_BYTE *)result + 148))
  {
    v3 = **((_DWORD **)result + 16);
    if (*((_DWORD *)result + 36) != v3)
      goto LABEL_3;
  }
  return result;
}

uint64_t sub_1C61A7248(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 148);
  if (*(_BYTE *)(result + 148))
    v1 = *(_DWORD *)(result + 144);
  **(_DWORD **)(result + 128) = v1;
  return result;
}

_QWORD *sub_1C61A7260(uint64_t a1, uint64_t a2)
{
  return sub_1C4B03438((_QWORD *)(a1 + 152), a2);
}

void sub_1C61A7268(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E8139C28;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A72B8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1C61A72C0(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1C61A72D4(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1C61A72E8(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1C61A72FC(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 12) && *(_BYTE *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

double sub_1C61A7328(uint64_t a1, char a2, char a3)
{
  double result;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = a1 + 8;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0x2800000000;
  *(_QWORD *)(a1 + 56) = a1 + 64;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a1 + 88;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = a1 + 112;
  *(_DWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 132) = 0;
  *(_BYTE *)(a1 + 133) = a2;
  *(_BYTE *)(a1 + 134) = a3;
  *(_WORD *)(a1 + 135) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 144) = a1 + 152;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = a1 + 176;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = a1 + 200;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = a1 + 232;
  *(_QWORD *)(a1 + 224) = 0x400000000;
  *(_QWORD *)(a1 + 264) = a1 + 280;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)&result = 1;
  *(_OWORD *)(a1 + 288) = xmmword_1C64169E0;
  return result;
}

uint64_t sub_1C61A73D0(uint64_t a1, unint64_t *a2)
{
  uint64_t v4;
  _OWORD *v5;
  _OWORD *v6;
  unsigned int v7;
  uint64_t v8;
  __int128 v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  int v14;

  v13 = *a2;
  v14 = 0;
  sub_1C61A7E70((uint64_t)&v11, a1, &v13, &v14);
  v4 = v11;
  if (v12)
  {
    v10 = *a2;
    v5 = *(_OWORD **)(a1 + 32);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 40))
    {
      v6 = sub_1C4E3D7FC((void **)(a1 + 24), &v10);
    }
    else
    {
      *v5 = v10;
      v6 = v5 + 1;
    }
    *(_QWORD *)(a1 + 32) = v6;
    v8 = *(_QWORD *)(a1 + 24);
    v7 = (((unint64_t)v6 - v8) >> 4) - 1;
    *(_DWORD *)(v4 + 8) = v7;
  }
  else
  {
    v7 = *(_DWORD *)(v11 + 8);
    v8 = *(_QWORD *)(a1 + 24);
  }
  return v8 + 16 * v7 + 8;
}

uint64_t sub_1C61A748C(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  int64_t v7;
  _QWORD *v9;

  v9 = 0;
  v4 = sub_1C61A7654((uint64_t *)a1, a2, &v9);
  if ((_DWORD)v4)
  {
    *v9 = -16;
    *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    v6 = *(char **)(a1 + 24);
    v5 = *(char **)(a1 + 32);
    if (v6 != v5)
    {
      while ((*(_QWORD *)v6 & 0xFFFFFFFFFFFFFFF8) != (*a2 & 0xFFFFFFFFFFFFFFF8))
      {
        v6 += 8;
        if (v6 == v5)
        {
          v6 = *(char **)(a1 + 32);
          break;
        }
      }
    }
    v7 = v5 - (v6 + 8);
    if (v5 != v6 + 8)
      memmove(v6, v6 + 8, v5 - (v6 + 8));
    *(_QWORD *)(a1 + 32) = &v6[v7];
  }
  return v4;
}

uint64_t sub_1C61A7548(uint64_t a1, llvm::GlobalValue *a2, uint64_t *a3)
{
  unint64_t v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;

  v6 = sub_1C4EE9DE0(a2);
  v7 = sub_1C4EEA81C(a1, v6);
  *((_QWORD *)v7 + 1) = a2;
  v8 = (unint64_t)v7 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(a1 + 133);
  v9 = *a3;
  *a3 = 0;
  v11 = v9;
  sub_1C4EEBD40(a1, v8, &v11);
  result = v11;
  v11 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_1C61A75D0@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61A7654((uint64_t *)a1, a2, &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61A76F8(a1, (uint64_t)a2, a2, v10);
    v7 = (_QWORD *)result;
    *(_QWORD *)result = *a2;
    v8 = 1;
  }
  v9 = *(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v9;
  *(_BYTE *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1C61A7654(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t result;
  _QWORD *v11;
  int v12;
  BOOL v13;
  unsigned int v14;

  v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = *a2 & 0xFFFFFFFFFFFFFFF8;
    v7 = (v3 - 1) & *a2 & 0xFFFFFFF8;
    v8 = (_QWORD *)(*a1 + 8 * v7);
    v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
    if (v6 == v9)
    {
      result = 1;
    }
    else
    {
      v11 = 0;
      v12 = 1;
      result = 1;
      while (v9 != -8)
      {
        if (v11)
          v13 = 0;
        else
          v13 = v9 == -16;
        if (v13)
          v11 = v8;
        v14 = v7 + v12++;
        v7 = v14 & v5;
        v8 = (_QWORD *)(v4 + 8 * (v14 & v5));
        v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
        if (v6 == v9)
          goto LABEL_4;
      }
      result = 0;
      if (v11)
        v8 = v11;
    }
  }
  else
  {
    v8 = 0;
    result = 0;
  }
LABEL_4:
  *a3 = v8;
  return result;
}

_QWORD *sub_1C61A76F8(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EEA75C(a1, v7);
  v9 = 0;
  sub_1C61A7654((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if ((~*a4 & 0xFFFFFFFFFFFFFFF8) != 0)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

void sub_1C61A77A8(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  _QWORD *v7;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
    memset_pattern16(*(void **)a1, &unk_1C85F4BC0, 8 * v6);
  for (; a2 != a3; ++a2)
  {
    if ((~*a2 & 0xFFFFFFFFFFFFFFF0) != 0)
    {
      v7 = 0;
      sub_1C61A7654((uint64_t *)a1, a2, &v7);
      *v7 = *a2;
      ++*(_DWORD *)(a1 + 8);
    }
  }
}

_QWORD *sub_1C61A7854@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD *result;
  uint64_t v10;
  char v11;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  v6 = *(_DWORD *)(a1 + 16);
  if (!v6)
  {
    v12 = 0;
LABEL_6:
    result = sub_1C61A7938(a1, (uint64_t)a2, a2, v12);
    *result = *a2;
    v7 = *(_QWORD *)a1;
    v6 = *(_DWORD *)(a1 + 16);
    v11 = 1;
    goto LABEL_4;
  }
  v7 = *(_QWORD *)a1;
  v8 = (37 * *a2) & (v6 - 1);
  result = (_QWORD *)(*(_QWORD *)a1 + 8 * v8);
  v10 = *result;
  if (*a2 != *result)
  {
    v13 = 0;
    v14 = 1;
    while (v10 != -1)
    {
      if (v13)
        v15 = 0;
      else
        v15 = v10 == -2;
      if (v15)
        v13 = result;
      v16 = v8 + v14++;
      v8 = v16 & (v6 - 1);
      result = (_QWORD *)(v7 + 8 * v8);
      v10 = *result;
      if (*a2 == *result)
        goto LABEL_3;
    }
    if (v13)
      v12 = v13;
    else
      v12 = result;
    goto LABEL_6;
  }
LABEL_3:
  v11 = 0;
LABEL_4:
  *(_QWORD *)a3 = result;
  *(_QWORD *)(a3 + 8) = v7 + 8 * v6;
  *(_BYTE *)(a3 + 16) = v11;
  return result;
}

_QWORD *sub_1C61A7938(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  unsigned int v22;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1C4EEAEBC(a1, 2 * v7);
    v8 = *a3;
    v10 = *(_DWORD *)(a1 + 16) - 1;
    v11 = (37 * *a3) & v10;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 8 * v11);
    v12 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v14 = 1;
      while (v12 != -1)
      {
        if (v13)
          v15 = 0;
        else
          v15 = v12 == -2;
        if (v15)
          v13 = a4;
        v16 = v11 + v14++;
        v11 = v16 & v10;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 8 * v11);
        v12 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      v8 = *a4;
      goto LABEL_4;
    }
    sub_1C4EEAEBC(a1, v7);
    v8 = *a3;
    v17 = *(_DWORD *)(a1 + 16) - 1;
    v18 = (37 * *a3) & v17;
    a4 = (_QWORD *)(*(_QWORD *)a1 + 8 * v18);
    v19 = *a4;
    if (*a3 != *a4)
    {
      v13 = 0;
      v20 = 1;
      while (v19 != -1)
      {
        if (v13)
          v21 = 0;
        else
          v21 = v19 == -2;
        if (v21)
          v13 = a4;
        v22 = v18 + v20++;
        v18 = v22 & v17;
        a4 = (_QWORD *)(*(_QWORD *)a1 + 8 * v18);
        v19 = *a4;
        if (v8 == *a4)
          goto LABEL_4;
      }
LABEL_20:
      if (v13)
        a4 = v13;
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

_QWORD *sub_1C61A7AAC(_QWORD *result, uint64_t *a2, uint64_t *a3)
{
  _QWORD *v5;
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  char *v12;
  uint64_t v13;
  char *v14;
  int v15;
  BOOL v16;
  unsigned int v17;

  v5 = result;
  result[1] = 0;
  v6 = (char *)*result;
  v7 = *((unsigned int *)result + 4);
  if ((_DWORD)v7)
    result = memset((void *)*result, 255, 8 * v7);
  if (a2 != a3)
  {
    v8 = 0;
    v9 = v7 - 1;
    do
    {
      v10 = *a2;
      if ((unint64_t)*a2 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v11 = (37 * v10) & v9;
        v12 = &v6[8 * v11];
        v13 = *(_QWORD *)v12;
        if (v10 != *(_QWORD *)v12)
        {
          v14 = 0;
          v15 = 1;
          while (v13 != -1)
          {
            if (v14)
              v16 = 0;
            else
              v16 = v13 == -2;
            if (v16)
              v14 = v12;
            v17 = v11 + v15++;
            v11 = v17 & v9;
            v12 = &v6[8 * (v17 & v9)];
            v13 = *(_QWORD *)v12;
            if (v10 == *(_QWORD *)v12)
              goto LABEL_7;
          }
          if (v14)
            v12 = v14;
        }
LABEL_7:
        *(_QWORD *)v12 = v10;
        *((_DWORD *)v5 + 2) = ++v8;
      }
      ++a2;
    }
    while (a2 != a3);
  }
  return result;
}

uint64_t sub_1C61A7B9C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61A7C2C(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61A7CC8(a2, a3, v10);
    v7 = (_QWORD *)result;
    *(_OWORD *)result = *(_OWORD *)a3;
    v8 = 1;
  }
  v9 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v9;
  *(_BYTE *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1C61A7C2C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  _QWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v17;

  if (a2)
  {
    v5 = a2 - 1;
    v6 = (a2 - 1) & a3;
    v7 = (_QWORD *)(a1 + 16 * v6);
    v8 = *v7;
    v9 = v7[1];
    if (*v7 == a3 && v9 == a4)
    {
      v11 = 1;
    }
    else
    {
      v13 = 0;
      v14 = 1;
      while (v8 || v9 != -1)
      {
        if (v13)
          v15 = 0;
        else
          v15 = v9 == -2;
        if (v15 && v8 == 0)
          v13 = v7;
        v17 = v6 + v14++;
        v6 = v17 & v5;
        v7 = (_QWORD *)(a1 + 16 * (v17 & v5));
        v8 = *v7;
        v9 = v7[1];
        v11 = 1;
        if (*v7 == a3 && v9 == a4)
          goto LABEL_8;
      }
      v11 = 0;
      if (v13)
        v7 = v13;
    }
  }
  else
  {
    v7 = 0;
    v11 = 0;
  }
LABEL_8:
  *a5 = v7;
  return v11;
}

_QWORD *sub_1C61A7CC8(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  BOOL v7;
  _QWORD *v9;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EEAF78(a1, v6);
  v9 = 0;
  sub_1C61A7C2C(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3)
    v7 = 0;
  else
    v7 = a3[1] == -1;
  if (!v7)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t *sub_1C61A7D7C(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *result;
  v3 = result[1];
  v4 = a2[1];
  if (v3 == *result)
  {
    v5 = a2[1];
  }
  else
  {
    do
    {
      v5 = v4 - 40;
      *(_OWORD *)(v4 - 40) = *(_OWORD *)(v3 - 40);
      *(_QWORD *)(v4 - 16) = 0;
      *(_QWORD *)(v4 - 8) = 0;
      *(_QWORD *)(v4 - 24) = 0;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(_QWORD *)(v4 - 8) = *(_QWORD *)(v3 - 8);
      *(_QWORD *)(v3 - 24) = 0;
      *(_QWORD *)(v3 - 16) = 0;
      *(_QWORD *)(v3 - 8) = 0;
      v3 -= 40;
      v4 -= 40;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  v6 = *result;
  *result = v5;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1C61A7E10(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 40;
    v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(_QWORD *)(v2 - 16) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1C61A7E70(uint64_t a1, uint64_t a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;

  v12 = 0;
  result = sub_1C61A7F08((uint64_t *)a2, a3, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61A7FAC(a2, (uint64_t)a3, a3, v12);
    v9 = (_QWORD *)result;
    *(_QWORD *)result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1C61A7F08(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t result;
  _QWORD *v11;
  int v12;
  BOOL v13;
  unsigned int v14;

  v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = *a2 & 0xFFFFFFFFFFFFFFF8;
    v7 = (v3 - 1) & *a2 & 0xFFFFFFF8;
    v8 = (_QWORD *)(*a1 + 16 * v7);
    v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
    if (v6 == v9)
    {
      result = 1;
    }
    else
    {
      v11 = 0;
      v12 = 1;
      result = 1;
      while (v9 != -8)
      {
        if (v11)
          v13 = 0;
        else
          v13 = v9 == -16;
        if (v13)
          v11 = v8;
        v14 = v7 + v12++;
        v7 = v14 & v5;
        v8 = (_QWORD *)(v4 + 16 * (v14 & v5));
        v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
        if (v6 == v9)
          goto LABEL_4;
      }
      result = 0;
      if (v11)
        v8 = v11;
    }
  }
  else
  {
    v8 = 0;
    result = 0;
  }
LABEL_4:
  *a3 = v8;
  return result;
}

_QWORD *sub_1C61A7FAC(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EEB574(a1, v7);
  v9 = 0;
  sub_1C61A7F08((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if ((~*a4 & 0xFFFFFFFFFFFFFFF8) != 0)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C61A805C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;

  v4 = a2;
  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -8;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      if ((~*(_QWORD *)v4 & 0xFFFFFFFFFFFFFFF0) != 0)
      {
        v10 = 0;
        result = sub_1C61A7F08((uint64_t *)v5, (_QWORD *)v4, &v10);
        v9 = v10;
        *v10 = *(_QWORD *)v4;
        *((_DWORD *)v9 + 2) = *(_DWORD *)(v4 + 8);
        ++*(_DWORD *)(v5 + 8);
      }
      v4 += 16;
    }
    while (v4 != a3);
  }
  return result;
}

void sub_1C61A8114(uint64_t a1)
{
  int v2;
  uint64_t v3;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 <= 4 * v2 || v3 < 0x41)
    {
      if ((_DWORD)v3)
        memset_pattern16(*(void **)a1, &unk_1C85F4BC0, 8 * v3);
      *(_QWORD *)(a1 + 8) = 0;
    }
    else
    {
      sub_1C4EEB62C(a1);
    }
  }
}

void sub_1C61A8184(void **a1)
{
  char *v1;
  char *v3;
  void *v4;
  void **v5;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = (void **)(v3 - 24);
        sub_1C4EEB714(&v5);
        sub_1C4E8C6FC((uint64_t)(v3 - 56));
        v3 -= 64;
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1C61A8204(uint64_t result, int a2, int a3, int a4, uint64_t a5, __int128 *a6, uint64_t a7, uint64_t *a8, __int128 *a9, __int128 *a10, __int128 *a11, __int128 *a12, uint64_t a13)
{
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void **v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  void **v38[15];

  v13 = *((_QWORD *)a6 + 2);
  v14 = *a6;
  *((_QWORD *)a6 + 1) = 0;
  *((_QWORD *)a6 + 2) = 0;
  *(_QWORD *)a6 = 0;
  *(_DWORD *)(result + 8) = 1;
  *(_DWORD *)(result + 12) = a2;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_OWORD *)(result + 40) = v14;
  *(_QWORD *)(result + 56) = v13;
  *(_QWORD *)result = &unk_1E8139E60;
  *(_DWORD *)(result + 64) = a3;
  *(_DWORD *)(result + 68) = a4;
  *(_QWORD *)(result + 72) = a5;
  *(_QWORD *)(result + 80) = 0;
  *(_QWORD *)(result + 88) = 0;
  *(_QWORD *)(result + 96) = 0;
  *(_OWORD *)(result + 80) = *(_OWORD *)a7;
  *(_QWORD *)(result + 96) = *(_QWORD *)(a7 + 16);
  *(_QWORD *)a7 = 0;
  *(_QWORD *)(a7 + 8) = 0;
  *(_QWORD *)(a7 + 16) = 0;
  *(_QWORD *)(result + 104) = 0;
  *(_QWORD *)(result + 112) = 0;
  v15 = *a8;
  v16 = a8[1];
  if (*a8 != v16
    || *(_QWORD *)a9 != *((_QWORD *)a9 + 1)
    || *(_QWORD *)a10 != *((_QWORD *)a10 + 1)
    || *(_QWORD *)a11 != *((_QWORD *)a11 + 1)
    || *(_QWORD *)a12 != *((_QWORD *)a12 + 1))
  {
    v36 = result;
    v17 = a8[2];
    *a8 = 0;
    a8[1] = 0;
    a8[2] = 0;
    v18 = *((_QWORD *)a9 + 2);
    v19 = *a9;
    *((_QWORD *)a9 + 1) = 0;
    *((_QWORD *)a9 + 2) = 0;
    *(_QWORD *)a9 = 0;
    v20 = *((_QWORD *)a10 + 2);
    v34 = v19;
    v35 = *a10;
    *((_QWORD *)a10 + 1) = 0;
    *((_QWORD *)a10 + 2) = 0;
    *(_QWORD *)a10 = 0;
    v21 = *((_QWORD *)a11 + 2);
    v22 = *a11;
    *((_QWORD *)a11 + 1) = 0;
    *((_QWORD *)a11 + 2) = 0;
    *(_QWORD *)a11 = 0;
    v23 = *((_QWORD *)a12 + 2);
    v32 = *a12;
    v33 = v22;
    *((_QWORD *)a12 + 1) = 0;
    *((_QWORD *)a12 + 2) = 0;
    *(_QWORD *)a12 = 0;
    v24 = (uint64_t *)(result + 104);
    v25 = v15;
    v26 = v16;
    v27 = operator new();
    *(_QWORD *)v27 = v25;
    *(_QWORD *)(v27 + 8) = v26;
    *(_QWORD *)(v27 + 16) = v17;
    v38[0] = 0;
    v38[1] = 0;
    *(_OWORD *)(v27 + 24) = v34;
    *(_QWORD *)(v27 + 40) = v18;
    memset(&v38[2], 0, 32);
    *(_OWORD *)(v27 + 48) = v35;
    *(_QWORD *)(v27 + 64) = v20;
    v38[6] = 0;
    v38[7] = 0;
    *(_OWORD *)(v27 + 72) = v33;
    *(_QWORD *)(v27 + 88) = v21;
    memset(&v38[8], 0, 32);
    *(_OWORD *)(v27 + 96) = v32;
    *(_QWORD *)(v27 + 112) = v23;
    memset(&v38[12], 0, 24);
    v28 = *v24;
    *v24 = v27;
    if (v28)
    {
      v29 = sub_1C61A8534(v28);
      MEMORY[0x1CAA32FC0](v29, 0x30C4045335465);
    }
    sub_1C61A8534((uint64_t)v38);
    result = v36;
  }
  if (*(_QWORD *)a13 != *(_QWORD *)(a13 + 8))
  {
    v37 = result;
    v30 = operator new();
    result = v37;
    *(_OWORD *)v30 = *(_OWORD *)a13;
    *(_QWORD *)(v30 + 16) = *(_QWORD *)(a13 + 16);
    *(_QWORD *)a13 = 0;
    *(_QWORD *)(a13 + 8) = 0;
    *(_QWORD *)(a13 + 16) = 0;
    v31 = *(void ***)(v37 + 112);
    *(_QWORD *)(v37 + 112) = v30;
    if (v31)
    {
      v38[0] = v31;
      sub_1C4EEB7D8(v38);
      MEMORY[0x1CAA32FC0](v31, 0x20C40960023A9);
      return v37;
    }
  }
  return result;
}

void sub_1C61A8480(_QWORD *a1)
{
  sub_1C61A85AC(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A84A4(_QWORD *a1)
{
  void *v2;

  *a1 = &unk_1E8139E80;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1C61A84E4(_QWORD *a1)
{
  void *v2;

  *a1 = &unk_1E8139E80;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A8534(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void **v6;

  v6 = (void **)(a1 + 96);
  sub_1C4EEBCC8(&v6);
  v6 = (void **)(a1 + 72);
  sub_1C4EEBCC8(&v6);
  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

_QWORD *sub_1C61A85AC(_QWORD *result)
{
  void **v1;
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  void **v10;

  *result = &unk_1E8139E60;
  v1 = (void **)result[14];
  result[14] = 0;
  if (v1)
  {
    v8 = result;
    v10 = v1;
    sub_1C4EEB7D8(&v10);
    MEMORY[0x1CAA32FC0](v1, 0x20C40960023A9);
    result = v8;
  }
  v2 = result[13];
  result[13] = 0;
  if (v2)
  {
    v9 = result;
    v5 = sub_1C61A8534(v2);
    MEMORY[0x1CAA32FC0](v5, 0x30C4045335465);
    result = v9;
  }
  v3 = (void *)result[10];
  if (v3)
  {
    result[11] = v3;
    v6 = result;
    operator delete(v3);
    result = v6;
  }
  *result = &unk_1E8139E80;
  v4 = (void *)result[5];
  if (v4)
  {
    result[6] = v4;
    v7 = result;
    operator delete(v4);
    return v7;
  }
  return result;
}

unsigned int *sub_1C61A8698(unsigned int *result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;

  if (*((_QWORD *)result + 1))
  {
    v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if ((_DWORD)v1)
      {
        v2 = *(_QWORD **)result;
        v3 = 16 * v1;
        do
        {
          *v2 = -8;
          v2 += 2;
          v3 -= 16;
        }
        while (v3);
      }
      *((_QWORD *)result + 1) = 0;
    }
    else
    {
      return sub_1C4EEB8AC(result);
    }
  }
  return result;
}

_QWORD *sub_1C61A86E8(_QWORD *result)
{
  _QWORD *v1;
  int v2;
  uint64_t v3;

  v1 = result;
  v2 = *((_DWORD *)result + 2);
  if (v2 || *((_DWORD *)result + 3))
  {
    v3 = *((unsigned int *)result + 4);
    if (v3 <= 4 * v2 || v3 < 0x41)
    {
      if ((_DWORD)v3)
        result = memset((void *)*result, 255, 8 * v3);
      v1[1] = 0;
    }
    else
    {
      return sub_1C4EEB9A8(result);
    }
  }
  return result;
}

unsigned int *sub_1C61A8754(unsigned int *result)
{
  uint64_t v1;
  _OWORD *v2;
  uint64_t v3;

  if (*((_QWORD *)result + 1))
  {
    v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if ((_DWORD)v1)
      {
        v2 = *(_OWORD **)result;
        v3 = 16 * v1;
        do
        {
          *v2++ = xmmword_1C640F7C0;
          v3 -= 16;
        }
        while (v3);
      }
      *((_QWORD *)result + 1) = 0;
    }
    else
    {
      return sub_1C4EEBA40(result);
    }
  }
  return result;
}

void sub_1C61A87A8(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;
  _OWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  v2 = a1[2];
  if (v2 || a1[3])
  {
    v3 = a1[4];
    if (v3 <= 4 * v2 || v3 < 0x41)
    {
      if (v3)
      {
        v4 = *(_OWORD **)a1;
        v5 = *(_QWORD *)a1 + 40 * v3;
        do
        {
          v6 = v4 + 1;
          *v4 = xmmword_1C640F7C0;
          v4 = (_OWORD *)((char *)v4 + 40);
          sub_1C4DE4490(v6, 0, 0, 0);
        }
        while (v4 != (_OWORD *)v5);
      }
      *((_QWORD *)a1 + 1) = 0;
    }
    else
    {
      sub_1C4EEBB44(a1);
    }
  }
}

void sub_1C61A885C(_QWORD *a1)
{
  sub_1C4EEC59C(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A8880(_QWORD *a1)
{
  void *v2;

  *a1 = &unk_1E8139E80;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1C61A88C0(_QWORD *a1)
{
  void *v2;

  *a1 = &unk_1E8139E80;
  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61A8910(uint64_t a1)
{
  sub_1C4926AE8(a1 + 200);
  sub_1C47653C0(a1 + 168, *(char **)(a1 + 176));
  sub_1C47653C0(a1 + 144, *(char **)(a1 + 152));
  sub_1C47655E8(a1 + 104, *(_QWORD **)(a1 + 112));
  sub_1C61A8988(a1 + 80, *(_QWORD **)(a1 + 88));
  sub_1C4EEC6C4(a1 + 56, *(char **)(a1 + 64));
  sub_1C61A8A20(a1 + 24);
  sub_1C61A8A90(a1, *(char **)(a1 + 8));
  return a1;
}

void sub_1C61A8988(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1C61A8988(a1, *a2);
    sub_1C61A8988(a1, a2[1]);
    sub_1C4EEC55C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1C61A89D0(uint64_t a1, _QWORD *a2)
{
  void *v4;

  if (a2)
  {
    sub_1C61A89D0(a1, *a2);
    sub_1C61A89D0(a1, a2[1]);
    v4 = (void *)a2[4];
    if (v4)
    {
      a2[5] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

uint64_t sub_1C61A8A20(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_DWORD *)(a1 + 12))
  {
    v2 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = 8 * v2;
      do
      {
        v5 = *(_QWORD *)(*(_QWORD *)a1 + v3);
        if (v5 != -8 && v5 != 0)
          MEMORY[0x1CAA32FB4]();
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)a1);
  return a1;
}

void sub_1C61A8A90(uint64_t a1, char *a2)
{
  void **v2;
  void **v3;
  void **v6[5];

  if (a2)
  {
    v6[3] = v2;
    v6[4] = v3;
    sub_1C61A8A90(a1, *(_QWORD *)a2);
    sub_1C61A8A90(a1, *((_QWORD *)a2 + 1));
    v6[0] = (void **)(a2 + 56);
    sub_1C4764BBC(v6);
    operator delete(a2);
  }
}

llvm::ModuleSummaryIndexWrapperPass *llvm::callDefaultCtor<llvm::ModuleSummaryIndexWrapperPass>()
{
  llvm::ModuleSummaryIndexWrapperPass *v0;

  v0 = (llvm::ModuleSummaryIndexWrapperPass *)operator new();
  return llvm::ModuleSummaryIndexWrapperPass::ModuleSummaryIndexWrapperPass(v0);
}

llvm::ImmutableModuleSummaryIndexWrapperPass *llvm::callDefaultCtor<llvm::ImmutableModuleSummaryIndexWrapperPass>()
{
  llvm::ImmutableModuleSummaryIndexWrapperPass *v0;

  v0 = (llvm::ImmutableModuleSummaryIndexWrapperPass *)operator new();
  return llvm::ImmutableModuleSummaryIndexWrapperPass::ImmutableModuleSummaryIndexWrapperPass(v0, 0);
}

void sub_1C61A8B40(_WORD *a1, llvm **a2, __int128 *a3, uint64_t a4)
{
  sub_1C47AD050((uint64_t)&FSEC, 0, 0);
  byte_1ED82E5EC = 0;
  qword_1ED82E5D8 = 0;
  unk_1ED82E5E0 = &off_1E8139C78;
  FSEC = (uint64_t)off_1E8139BC0;
  qword_1ED82E5F0 = (uint64_t)&off_1E8139C28;
  qword_1ED82E5F8 = (uint64_t)&FSEC;
  qword_1ED82E600 = (uint64_t)&unk_1ED82E610;
  qword_1ED82E608 = 0x800000000;
  qword_1ED82E790 = (uint64_t)&off_1E8139CB8;
  qword_1ED82E7A8 = (uint64_t)&qword_1ED82E790;
  sub_1C61A8BF8(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&FSEC);
}

void sub_1C61A8BF8(_WORD *a1, llvm **a2, __int128 *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&FSEC, "force-summary-edges-cold", 0x18uLL);
  word_1ED82E562 = (32 * (*a1 & 3)) | word_1ED82E562 & 0xFF9F;
  sub_1C61A8CD4(*a2);
  xmmword_1ED82E578 = *a3;
  sub_1C4EEC77C(*(_QWORD *)a4, *(_DWORD *)(a4 + 8));
}

void sub_1C61A8C80()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A8C94()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E8139CB8;
  return result;
}

void sub_1C61A8CB8(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E8139CB8;
}

llvm *sub_1C61A8CD4(llvm *result)
{
  llvm::raw_ostream *v1;
  const char *v2;
  __int16 v3;

  if (qword_1ED82E5D8)
  {
    v2 = "cl::location(x) specified more than once!";
    v3 = 259;
    v1 = (llvm::raw_ostream *)llvm::errs(result);
    return (llvm *)llvm::cl::Option::error(&FSEC, (llvm::Twine *)&v2, 0, 0, v1);
  }
  else
  {
    qword_1ED82E5D8 = (uint64_t)result;
    byte_1ED82E5EC = 1;
    dword_1ED82E5E8 = *(_DWORD *)result;
  }
  return result;
}

void sub_1C61A8D4C(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  char v10;
  _QWORD v11[5];
  int v12;
  char v13;

  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  v11[3] = a5;
  v11[4] = &off_1E8139C78;
  v13 = 1;
  v12 = a3;
  v7 = sub_1C4EEC7C0((unint64_t)v11);
  v8 = qword_1ED82E600 + 48 * qword_1ED82E608;
  v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(_QWORD *)(v8 + 32) = &off_1E8139C98;
  v10 = *(_BYTE *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(_BYTE *)(v8 + 44) = v10;
  *(_QWORD *)(v8 + 32) = &off_1E8139C78;
  LODWORD(qword_1ED82E608) = qword_1ED82E608 + 1;
  llvm::cl::AddLiteralOption(qword_1ED82E5F8, a1, a2);
}

void sub_1C61A8E00(unint64_t a1)
{
  _OWORD *v1;
  _OWORD *v2;
  uint64_t v3;
  _OWORD *v4;
  __int128 v5;
  int v6;
  int v7;
  unint64_t v8;

  v8 = 0;
  v1 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)&qword_1ED82E600, a1, 48, &v8);
  v2 = (_OWORD *)qword_1ED82E600;
  if ((_DWORD)qword_1ED82E608)
  {
    v3 = qword_1ED82E600 + 48 * qword_1ED82E608;
    v4 = v1;
    do
    {
      v5 = v2[1];
      *v4 = *v2;
      v4[1] = v5;
      *((_QWORD *)v4 + 4) = &off_1E8139C98;
      v6 = *((_DWORD *)v2 + 10);
      *((_BYTE *)v4 + 44) = *((_BYTE *)v2 + 44);
      *((_DWORD *)v4 + 10) = v6;
      *((_QWORD *)v4 + 4) = &off_1E8139C78;
      v2 += 3;
      v4 += 3;
    }
    while (v2 != (_OWORD *)v3);
    v2 = (_OWORD *)qword_1ED82E600;
  }
  v7 = v8;
  if (v2 != (_OWORD *)&unk_1ED82E610)
    free(v2);
  qword_1ED82E600 = (uint64_t)v1;
  HIDWORD(qword_1ED82E608) = v7;
}

__n128 sub_1C61A8ECC(const char **a1, _WORD *a2, __int128 *a3, __n128 *a4)
{
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&ModuleSummaryDotFile, "module-summary-dot-file", 0x17uLL);
  sub_1C49C7D74(a1, (uint64_t)&ModuleSummaryDotFile);
  word_1ED82E7BA = (32 * (*a2 & 3)) | word_1ED82E7BA & 0xFF9F;
  xmmword_1ED82E7E0 = *a3;
  result = *a4;
  xmmword_1ED82E7D0 = (__int128)*a4;
  return result;
}

uint64_t sub_1C61A8F54(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v4 = (_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = v5;
  v6 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = v7;
  if (v7)
  {
    *(_QWORD *)(v5 + 16) = v6;
    *(_QWORD *)a2 = v4;
    *v4 = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    *(_QWORD *)a1 = v6;
  }
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  v8 = (_QWORD *)(a2 + 64);
  v9 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 64) = v9;
  v10 = a1 + 64;
  v11 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 72) = v11;
  if (v11)
  {
    *(_QWORD *)(v9 + 16) = v10;
    *(_QWORD *)(a2 + 56) = v8;
    *v8 = 0;
    *(_QWORD *)(a2 + 72) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 56) = v10;
  }
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v12 = (_QWORD *)(a2 + 88);
  v13 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 88) = v13;
  v14 = a1 + 88;
  v15 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 96) = v15;
  if (v15)
  {
    *(_QWORD *)(v13 + 16) = v14;
    *(_QWORD *)(a2 + 80) = v12;
    *v12 = 0;
    *(_QWORD *)(a2 + 96) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 80) = v14;
  }
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  v16 = (_QWORD *)(a2 + 112);
  v17 = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 112) = v17;
  v18 = a1 + 112;
  v19 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 120) = v19;
  if (v19)
  {
    *(_QWORD *)(v17 + 16) = v18;
    *(_QWORD *)(a2 + 104) = v16;
    *v16 = 0;
    *(_QWORD *)(a2 + 120) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 104) = v18;
  }
  v20 = *(_QWORD *)(a2 + 128);
  *(_BYTE *)(a1 + 136) = *(_BYTE *)(a2 + 136);
  *(_QWORD *)(a1 + 128) = v20;
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  v21 = (_QWORD *)(a2 + 152);
  v22 = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 152) = v22;
  v23 = a1 + 152;
  v24 = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(a1 + 160) = v24;
  if (v24)
  {
    *(_QWORD *)(v22 + 16) = v23;
    *(_QWORD *)(a2 + 144) = v21;
    *v21 = 0;
    *(_QWORD *)(a2 + 160) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 144) = v23;
  }
  *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
  v25 = (_QWORD *)(a2 + 176);
  v26 = *(_QWORD *)(a2 + 176);
  *(_QWORD *)(a1 + 176) = v26;
  v27 = a1 + 176;
  v28 = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a1 + 184) = v28;
  if (v28)
  {
    *(_QWORD *)(v26 + 16) = v27;
    *(_QWORD *)(a2 + 168) = v25;
    *v25 = 0;
    *(_QWORD *)(a2 + 184) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 168) = v27;
  }
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
  sub_1C4E854AC(a1 + 200, a2 + 200);
  *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
  return a1;
}

unint64_t *llvm::LoopSafetyInfo::copyColors(llvm::LoopSafetyInfo *this, llvm::BasicBlock *a2, llvm::BasicBlock *a3)
{
  uint64_t *v3;
  unint64_t *v4;
  _QWORD *v5;
  llvm::BasicBlock *v7;
  llvm::BasicBlock *v8;

  v7 = a3;
  v8 = a2;
  v3 = (uint64_t *)((char *)this + 8);
  v4 = sub_1C61912D8((uint64_t *)this + 1, &v8) + 1;
  v5 = sub_1C61912D8(v3, &v7);
  return sub_1C4EED4C0(v4, v5 + 1);
}

uint64_t llvm::SimpleLoopSafetyInfo::blockMayThrow(llvm::SimpleLoopSafetyInfo *this, const llvm::BasicBlock *a2)
{
  return (*(uint64_t (**)(llvm::SimpleLoopSafetyInfo *))(*(_QWORD *)this + 8))(this);
}

uint64_t llvm::SimpleLoopSafetyInfo::anyBlockMayThrow(llvm::SimpleLoopSafetyInfo *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t *llvm::SimpleLoopSafetyInfo::computeLoopSafetyInfo(llvm::SimpleLoopSafetyInfo *this, llvm ***a2)
{
  const llvm::BasicBlock *v4;
  char v5;
  llvm **v6;
  uint64_t v7;
  llvm **v9;
  uint64_t v10;
  llvm *v11;

  v5 = llvm::isGuaranteedToTransferExecutionToSuccessor(*a2[4], (const llvm::BasicBlock *)a2) ^ 1;
  *((_BYTE *)this + 33) = v5;
  *((_BYTE *)this + 32) = v5;
  v6 = a2[4];
  v7 = (char *)a2[5] - (char *)v6;
  if (v7 != 8)
  {
    v9 = v6 + 1;
    v10 = 8 * (v7 >> 3) - 8;
    do
    {
      if (v5)
        break;
      v11 = *v9++;
      v5 = *((_BYTE *)this + 32) | llvm::isGuaranteedToTransferExecutionToSuccessor(v11, v4) ^ 1;
      *((_BYTE *)this + 32) = v5;
      v10 -= 8;
    }
    while (v10);
  }
  return llvm::LoopSafetyInfo::computeBlockColors((uint64_t *)this, (const llvm::Loop *)a2);
}

uint64_t *sub_1C61A9204(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  int v8;
  int v9;

  v4 = *((unsigned int *)a1 + 4);
  v5 = *a1;
  if ((_DWORD)v4)
  {
    v6 = 16 * v4;
    v7 = (uint64_t *)(v5 + 8);
    do
    {
      if ((*(v7 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
        v7 = sub_1C619127C(v7);
      v7 += 2;
      v6 -= 16;
    }
    while (v6);
    v5 = *a1;
  }
  MEMORY[0x1CAA32FB4](v5, 8);
  *a1 = 0;
  a1[1] = 0;
  *((_DWORD *)a1 + 4) = 0;
  *a1 = *a2;
  *a2 = 0;
  *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = 0;
  v8 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v8;
  v9 = *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = v9;
  return a1;
}

uint64_t llvm::SimpleLoopSafetyInfo::isGuaranteedToExecute(llvm::SimpleLoopSafetyInfo *this, const llvm::Instruction *a2, const llvm::DominatorTree *a3, const llvm::BasicBlock ***a4)
{
  const llvm::BasicBlock *v5;

  v5 = (const llvm::BasicBlock *)*((_QWORD *)a2 + 5);
  if (v5 != *a4[4])
    return llvm::LoopSafetyInfo::allLoopPathsLeadToBlock(this, a4, v5, a3);
  if (*((_BYTE *)this + 33))
    return llvm::BasicBlock::getFirstNonPHIOrDbg(*((llvm::BasicBlock **)a2 + 5), 1) == (char *)a2;
  return 1;
}

BOOL llvm::ICFLoopSafetyInfo::doesNotWriteMemoryBefore(int32x2_t *this, const llvm::Instruction *a2, const llvm::BasicBlock ***a3)
{
  const llvm::BasicBlock *v5;

  v5 = (const llvm::BasicBlock *)*((_QWORD *)a2 + 5);
  return (llvm::InstructionPrecedenceTracking::isPreceededBySpecialInstruction(this + 9, (const llvm::BasicBlock **)a2) & 1) == 0
      && llvm::ICFLoopSafetyInfo::doesNotWriteMemoryBefore(this, v5, a3);
}

uint64_t llvm::createMustExecutePrinter(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EEE3FC(v1);
}

uint64_t llvm::createMustBeExecutedContextPrinter(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EEE5CC(v1);
}

llvm::BasicBlock *llvm::MustBeExecutedContextExplorer::getMustBeExecutedNextInstruction(llvm::MustBeExecutedContextExplorer *this, llvm::MustBeExecutedIterator *a2, const llvm::BasicBlock **a3)
{
  int NumSuccessors;
  llvm::BasicBlock *result;
  uint64_t v7;
  const llvm::BasicBlock *v8;
  BOOL v9;

  if (!a3)
    return 0;
  if (!*(_BYTE *)this && *((unsigned __int8 *)a3 + 16) - 29 < 0xB
    || !llvm::isGuaranteedToTransferExecutionToSuccessor((llvm *)a3, a2))
  {
    return 0;
  }
  if (*((unsigned __int8 *)a3 + 16) - 29 >= 0xB)
  {
    v8 = a3[4];
    if (v8)
      v9 = v8 == (const llvm::BasicBlock *)((char *)a3[5] + 40);
    else
      v9 = 1;
    if (v9)
      return 0;
    else
      return (const llvm::BasicBlock *)((char *)v8 - 24);
  }
  NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)a3);
  if (!NumSuccessors)
    return 0;
  if (NumSuccessors == 1)
  {
    result = (llvm::BasicBlock *)llvm::Instruction::getSuccessor((llvm::Instruction *)a3, 0);
  }
  else
  {
    result = llvm::MustBeExecutedContextExplorer::findForwardJoinPoint(this, a3[5]);
    if (!result)
      return result;
  }
  v7 = *((_QWORD *)result + 6);
  if (v7)
    return (llvm::BasicBlock *)(v7 - 24);
  else
    return 0;
}

uint64_t llvm::MustBeExecutedIterator::resetInstruction(llvm::MustBeExecutedIterator *this, unint64_t a2)
{
  unint64_t *v4;
  unint64_t v5;
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  _BYTE v9[31];

  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 5) = 0;
  v4 = (unint64_t *)((char *)this + 40);
  *((_QWORD *)this + 6) = 0;
  v5 = a2 & 0xFFFFFFFFFFFFFFFBLL;
  v8 = a2 | 4;
  sub_1C61AAF34((uint64_t)this, &v8, (uint64_t)v9);
  v8 = v5;
  result = sub_1C61AAF34((uint64_t)this, &v8, (uint64_t)v9);
  v7 = *((_QWORD *)this + 3);
  if (*(_BYTE *)(v7 + 1))
    *v4 = a2;
  if (*(_BYTE *)(v7 + 2))
    *((_QWORD *)this + 6) = a2;
  return result;
}

uint64_t llvm::MustBeExecutedIterator::advance(llvm::MustBeExecutedIterator *this, llvm::MustBeExecutedIterator *a2)
{
  llvm::BasicBlock *MustBeExecutedNextInstruction;
  llvm::MustBeExecutedIterator *v4;
  llvm::BasicBlock *MustBeExecutedPrevInstruction;
  uint64_t result;
  unint64_t v7;
  _BYTE v8[16];
  char v9;

  MustBeExecutedNextInstruction = llvm::MustBeExecutedContextExplorer::getMustBeExecutedNextInstruction(*((llvm::MustBeExecutedContextExplorer **)this + 3), a2, *((const llvm::BasicBlock ***)this + 5));
  *((_QWORD *)this + 5) = MustBeExecutedNextInstruction;
  if (MustBeExecutedNextInstruction)
  {
    v7 = (unint64_t)MustBeExecutedNextInstruction | 4;
    sub_1C61AAF34((uint64_t)this, &v7, (uint64_t)v8);
    if (v9)
      return *((_QWORD *)this + 5);
  }
  *((_QWORD *)this + 5) = 0;
  MustBeExecutedPrevInstruction = llvm::MustBeExecutedContextExplorer::getMustBeExecutedPrevInstruction(*((llvm::MustBeExecutedContextExplorer **)this + 3), v4, *((const llvm::Instruction **)this + 6));
  *((_QWORD *)this + 6) = MustBeExecutedPrevInstruction;
  if (MustBeExecutedPrevInstruction)
  {
    v7 = (unint64_t)MustBeExecutedPrevInstruction & 0xFFFFFFFFFFFFFFFBLL;
    sub_1C61AAF34((uint64_t)this, &v7, (uint64_t)v8);
    if (v9)
      return *((_QWORD *)this + 6);
  }
  result = 0;
  *((_QWORD *)this + 6) = 0;
  return result;
}

uint64_t llvm::MustExecutePrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, llvm::Function *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t *v8;
  uint64_t ResultImpl;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t (**v15)();
  uint64_t v16;
  unsigned int v17;

  v8 = (uint64_t *)(llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::LoopAnalysis::Key, (uint64_t)a2) + 8);
  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::DominatorTreeAnalysis::Key, (uint64_t)a2);
  sub_1C4EEF324((uint64_t)&v15, (uint64_t)a2, (const llvm::DominatorTree *)(ResultImpl + 8), v8);
  llvm::Function::print(a2, *a1, (llvm::AssemblyAnnotationWriter *)&v15, 0, 0);
  llvm::InstCountPass::run(a4);
  v15 = &off_1E813A210;
  v10 = v16;
  if (v17)
  {
    v11 = 56 * v17;
    v12 = (_QWORD *)(v16 + 24);
    do
    {
      if ((*(v12 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = (_QWORD *)*(v12 - 2);
        if (v12 != v13)
          free(v13);
      }
      v12 += 7;
      v11 -= 56;
    }
    while (v11);
    v10 = v16;
  }
  return MEMORY[0x1CAA32FB4](v10, 8);
}

void sub_1C61A9718(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  __int128 v6;
  uint64_t v7[2];
  int v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11[2];
  int v12;
  __int128 v13;
  __int128 v14;

  v5 = sub_1C61AA84C(a2, a3);
  v11[0] = 0;
  v11[1] = 0;
  v12 = 0;
  sub_1C4DFE328((uint64_t)v11, v5);
  v6 = *(_OWORD *)(v5 + 40);
  v13 = *(_OWORD *)(v5 + 24);
  v14 = v6;
  v7[0] = 0;
  v7[1] = 0;
  v8 = 0;
  sub_1C4DFE328((uint64_t)v7, a2 + 176);
  v9 = *(_OWORD *)(a2 + 200);
  v10 = *(_OWORD *)(a2 + 216);
  sub_1C61AA7C0(a1, v11, v7);
}

_QWORD *sub_1C61A97C4(_QWORD *a1)
{
  *a1 = &unk_1E813A258;
  sub_1C4EF1108(a1 + 1);
  return a1;
}

void sub_1C61A97F8(_QWORD *a1)
{
  *a1 = &unk_1E813A258;
  sub_1C4EF1108(a1 + 1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61A9840(_QWORD *a1)
{
  sub_1C4EF1098(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61A9864(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 8, &v5);
  sub_1C61A98D0(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61A98D0(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v3 = *(uint64_t **)a1;
    v4 = 8 * v2;
    v5 = 8 * v2;
    do
    {
      v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    v7 = *(_QWORD *)a1 - 8;
    do
    {
      v8 = *(_QWORD *)(v7 + v4);
      *(_QWORD *)(v7 + v4) = 0;
      if (v8)
        sub_1C4DC4DE4(v7 + v4, v8);
      v4 -= 8;
    }
    while (v4);
  }
}

void sub_1C61A9934(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 8, &v5);
  sub_1C61A99A0(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

uint64_t sub_1C61A99A0(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v2 = *(unsigned int *)(result + 8);
  if ((_DWORD)v2)
  {
    v3 = *(uint64_t **)result;
    v4 = 8 * v2;
    v5 = 8 * v2;
    do
    {
      v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    v7 = *(_QWORD *)result - 8;
    do
    {
      result = *(_QWORD *)(v7 + v4);
      *(_QWORD *)(v7 + v4) = 0;
      if (result)
      {
        v8 = llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase((_QWORD *)result);
        result = MEMORY[0x1CAA32FC0](v8, 0x10B0C40D29300ECLL);
      }
      v4 -= 8;
    }
    while (v4);
  }
  return result;
}

void sub_1C61A9A14(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 8, &v5);
  sub_1C61A9A80(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61A9A80(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v3 = *(uint64_t **)a1;
    v4 = 8 * v2;
    v5 = 8 * v2;
    do
    {
      v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    v7 = *(_QWORD *)a1 - 8;
    do
    {
      v8 = *(_QWORD *)(v7 + v4);
      *(_QWORD *)(v7 + v4) = 0;
      if (v8)
        sub_1C4DC4E98(v7 + v4, v8);
      v4 -= 8;
    }
    while (v4);
  }
}

_QWORD *sub_1C61A9AE4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E813A138;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1C61A9B40(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E813A138;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A9BAC(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = operator new(0x28uLL);
  *v2 = &off_1E813A138;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      v2[4] = v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    }
    else
    {
      v2[4] = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
    }
  }
  else
  {
    v2[4] = 0;
  }
  return v2;
}

uint64_t sub_1C61A9C28(uint64_t result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;

  *a2 = &off_1E813A138;
  v3 = a2 + 1;
  v4 = *(_QWORD *)(result + 32);
  if (v4)
  {
    if (v4 == result + 8)
    {
      a2[4] = v3;
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 32) + 24))(*(_QWORD *)(result + 32));
    }
    else
    {
      result = (*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)v4 + 16))(*(_QWORD *)(result + 32), v3);
      a2[4] = result;
    }
  }
  else
  {
    a2[4] = 0;
  }
  return result;
}

_QWORD *sub_1C61A9C9C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1C61A9CD0(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

_QWORD *sub_1C61A9D20(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  sub_1C485C2F0();
  return sub_1C61A9D44(v3);
}

_QWORD *sub_1C61A9D44(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E813A180;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1C61A9DA0(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E813A180;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61A9E0C(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = operator new(0x28uLL);
  *v2 = &off_1E813A180;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      v2[4] = v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    }
    else
    {
      v2[4] = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
    }
  }
  else
  {
    v2[4] = 0;
  }
  return v2;
}

uint64_t sub_1C61A9E88(uint64_t result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;

  *a2 = &off_1E813A180;
  v3 = a2 + 1;
  v4 = *(_QWORD *)(result + 32);
  if (v4)
  {
    if (v4 == result + 8)
    {
      a2[4] = v3;
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 32) + 24))(*(_QWORD *)(result + 32));
    }
    else
    {
      result = (*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)v4 + 16))(*(_QWORD *)(result + 32), v3);
      a2[4] = result;
    }
  }
  else
  {
    a2[4] = 0;
  }
  return result;
}

_QWORD *sub_1C61A9EFC(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1C61A9F30(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

_QWORD *sub_1C61A9F80(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  sub_1C485C2F0();
  return sub_1C61A9FA4(v3);
}

_QWORD *sub_1C61A9FA4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E813A1C8;
  v2 = a1 + 1;
  v3 = (_QWORD *)a1[4];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void sub_1C61AA000(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E813A1C8;
  v1 = a1 + 1;
  v2 = (_QWORD *)a1[4];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61AA06C(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = operator new(0x28uLL);
  *v2 = &off_1E813A1C8;
  v3 = v2 + 1;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      v2[4] = v3;
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
    }
    else
    {
      v2[4] = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 16))(v4, v3);
    }
  }
  else
  {
    v2[4] = 0;
  }
  return v2;
}

uint64_t sub_1C61AA0E8(uint64_t result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;

  *a2 = &off_1E813A1C8;
  v3 = a2 + 1;
  v4 = *(_QWORD *)(result + 32);
  if (v4)
  {
    if (v4 == result + 8)
    {
      a2[4] = v3;
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 32) + 24))(*(_QWORD *)(result + 32));
    }
    else
    {
      result = (*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)v4 + 16))(*(_QWORD *)(result + 32), v3);
      a2[4] = result;
    }
  }
  else
  {
    a2[4] = 0;
  }
  return result;
}

_QWORD *sub_1C61AA15C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 8);
  result = *(_QWORD **)(a1 + 32);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1C61AA190(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 8;
  v3 = (char *)*((_QWORD *)__p + 4);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

char **sub_1C61AA1E0(uint64_t a1)
{
  uint64_t v1;
  char **v3;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    return (char **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
  sub_1C485C2F0();
  return sub_1C61AA204(v3);
}

char **sub_1C61AA204(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  _QWORD *v6;
  _QWORD *v7;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *(_QWORD **)&v5[v4];
      *(_QWORD *)&v5[v4] = 0;
      if (v6)
      {
        v7 = llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase(v6);
        MEMORY[0x1CAA32FC0](v7, 0x10B0C40D29300ECLL);
      }
      v4 -= 8;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

char **sub_1C61AA280(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *(_QWORD *)&v5[v4];
      *(_QWORD *)&v5[v4] = 0;
      if (v6)
        sub_1C4DC4DE4((uint64_t)&v5[v4], v6);
      v4 -= 8;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

char **sub_1C61AA2EC(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *(_QWORD *)&v5[v4];
      *(_QWORD *)&v5[v4] = 0;
      if (v6)
        sub_1C4DC4E98((uint64_t)&v5[v4], v6);
      v4 -= 8;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

_QWORD *sub_1C61AA364(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61AA3DC(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x400000000;
  }
  return v5;
}

_QWORD *sub_1C61AA3DC(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EF0ED8(a1, v6);
  v8 = 0;
  sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61AA48C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 56 * v6;
    do
    {
      *v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C614D378(v11, v4 + 8);
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

double sub_1C61AA584(_QWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5;
  double result;
  uint64_t v7;

  v7 = 0;
  if (sub_1C61A45F4(a2, a3, a4, &v7))
  {
    v5 = v7;
    *a1 = a1 + 2;
    *(_QWORD *)&result = 0x400000000;
    a1[1] = 0x400000000;
    if (*(_DWORD *)(v5 + 16))
      llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)a1, v5 + 8);
  }
  else
  {
    *a1 = a1 + 2;
    *(_QWORD *)&result = 0x400000000;
    a1[1] = 0x400000000;
  }
  return result;
}

void sub_1C61AA614(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v1 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v1)
  {
    v2 = 56 * v1;
    v3 = *(_QWORD *)a1 + 24;
    do
    {
      if ((*(_QWORD *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4)
          free(v4);
      }
      v3 += 56;
      v2 -= 56;
    }
    while (v2);
  }
}

uint64_t sub_1C61AA678(uint64_t a1, char a2, char a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_BYTE *)a1 = a2;
  *(_BYTE *)(a1 + 1) = a3;
  *(_BYTE *)(a1 + 2) = a4;
  v10 = *(_QWORD *)(a5 + 24);
  if (v10)
  {
    if (v10 == a5)
    {
      *(_QWORD *)(a1 + 32) = a1 + 8;
      (*(void (**)(_QWORD))(**(_QWORD **)(a5 + 24) + 24))(*(_QWORD *)(a5 + 24));
    }
    else
    {
      *(_QWORD *)(a1 + 32) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 32) = 0;
  }
  v11 = *(_QWORD *)(a6 + 24);
  if (v11)
  {
    if (v11 == a6)
    {
      *(_QWORD *)(a1 + 64) = a1 + 40;
      (*(void (**)(_QWORD))(**(_QWORD **)(a6 + 24) + 24))(*(_QWORD *)(a6 + 24));
    }
    else
    {
      *(_QWORD *)(a1 + 64) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 64) = 0;
  }
  v12 = *(_QWORD *)(a7 + 24);
  if (v12)
  {
    if (v12 == a7)
    {
      *(_QWORD *)(a1 + 96) = a1 + 72;
      (*(void (**)(_QWORD))(**(_QWORD **)(a7 + 24) + 24))(*(_QWORD *)(a7 + 24));
    }
    else
    {
      *(_QWORD *)(a1 + 96) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 96) = 0;
  }
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 200) = a1;
  *(_QWORD *)(a1 + 208) = 0;
  sub_1C61AAEC4(a1 + 176);
  llvm::MustBeExecutedIterator::resetInstruction((llvm::MustBeExecutedIterator *)(a1 + 176), 0);
  return a1;
}

void sub_1C61AA7C0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;

  v3 = *a2;
  *a2 = 0;
  v4 = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = 0;
  v5 = *a3;
  *(_QWORD *)a1 = v3;
  v6 = a2[1];
  a2[1] = 0;
  LODWORD(v3) = *((_DWORD *)a3 + 4);
  *((_DWORD *)a3 + 4) = 0;
  *(_QWORD *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 3);
  v7 = *(_OWORD *)(a2 + 5);
  *a3 = 0;
  *(_OWORD *)(a1 + 40) = v7;
  *(_QWORD *)(a1 + 56) = v5;
  *(_QWORD *)&v7 = a3[1];
  a3[1] = 0;
  *(_QWORD *)(a1 + 64) = v7;
  *(_DWORD *)(a1 + 72) = v3;
  v8 = *(_OWORD *)(a3 + 5);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a3 + 3);
  *(_OWORD *)(a1 + 96) = v8;
  MEMORY[0x1CAA32FB4](0, 8);
  JUMPOUT(0x1CAA32FB4);
}

uint64_t sub_1C61AA84C(uint64_t a1, unint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v6;
  _QWORD *v7;
  unint64_t v8;

  v8 = a2;
  v3 = sub_1C61AA8F0((uint64_t *)(a1 + 152), &v8) + 1;
  v4 = *v3;
  if (!*v3)
  {
    v4 = operator new();
    v6 = v8;
    *(_QWORD *)v4 = 0;
    *(_QWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_QWORD *)(v4 + 24) = a1;
    *(_QWORD *)(v4 + 32) = v6;
    sub_1C61AAEC4(v4);
    llvm::MustBeExecutedIterator::resetInstruction((llvm::MustBeExecutedIterator *)v4, v6);
    v7 = (_QWORD *)*v3;
    *v3 = v4;
    if (v7)
    {
      sub_1C4EF1054((uint64_t)v3, v7);
      return *v3;
    }
  }
  return v4;
}

_QWORD *sub_1C61AA8F0(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61252B8(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61AA950((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61AA950(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EF0F9C(a1, v7);
  v9 = 0;
  sub_1C61252B8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

void sub_1C61AA9FC(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;

  *(_QWORD *)(a1 + 8) = 0;
  v5 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v5)
  {
    v6 = *(_QWORD **)a1;
    v7 = 16 * v5;
    do
    {
      *v6 = -4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    v8 = a2 + 1;
    do
    {
      if ((*(v8 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61252B8((uint64_t *)a1, v8 - 1, &v13);
        v10 = v13;
        *v13 = *(v8 - 1);
        v11 = (_QWORD *)*v8;
        *v8 = 0;
        v10[1] = v11;
        ++*(_DWORD *)(a1 + 8);
        v12 = (_QWORD *)*v8;
        *v8 = 0;
        if (v12)
          sub_1C4EF1054((uint64_t)v8, v12);
      }
      v9 = v8 + 1;
      v8 += 2;
    }
    while (v9 != a3);
  }
}

_QWORD *sub_1C61AAAD0(_QWORD *a1)
{
  MEMORY[0x1CAA32FB4](a1[7], 8);
  MEMORY[0x1CAA32FB4](*a1, 8);
  return a1;
}

uint64_t sub_1C61AAB08(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 176), 8);
  sub_1C61AABF0((unsigned int *)(a1 + 152));
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 152), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 128), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 104), 8);
  v2 = *(_QWORD **)(a1 + 96);
  if (v2 == (_QWORD *)(a1 + 72))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 72);
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  v4 = *(_QWORD **)(a1 + 64);
  if (v4 == (_QWORD *)(a1 + 40))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 40);
  }
  else
  {
    if (!v4)
      goto LABEL_11;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_11:
  v6 = *(_QWORD **)(a1 + 32);
  if (v6 == (_QWORD *)(a1 + 8))
  {
    v7 = 4;
    v6 = (_QWORD *)(a1 + 8);
    goto LABEL_15;
  }
  if (v6)
  {
    v7 = 5;
LABEL_15:
    (*(void (**)(void))(*v6 + 8 * v7))();
  }
  return a1;
}

void sub_1C61AABF0(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;

  v1 = a1[4];
  if ((_DWORD)v1)
  {
    v2 = 16 * v1;
    v3 = (_QWORD *)(*(_QWORD *)a1 + 8);
    do
    {
      if ((*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v4 = (_QWORD *)*v3;
        *v3 = 0;
        if (v4)
          sub_1C4EF1054((uint64_t)v3, v4);
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
}

_QWORD *sub_1C61AAC54(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C6144BDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61AACC0(a1, a2, v7);
    *v5 = *a2;
    *((_WORD *)v5 + 4) = 0;
  }
  return v5;
}

_QWORD *sub_1C61AACC0(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EF1170(a1, v6);
  v8 = 0;
  sub_1C6144BDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61AAD70(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C6144BDC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_QWORD *)a2;
      *((_WORD *)v10 + 4) = *(_WORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

unsigned int *sub_1C61AAE24(unsigned int *result, llvm::Instruction *this, unsigned int a3, uint64_t a4, int a5)
{
  unsigned int v6;
  unsigned int *v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  unsigned int v13;

  v6 = a3;
  v8 = result;
  v9 = a5 - a3;
  v10 = result[2];
  v11 = v10 + (int)(a5 - a3);
  if (v11 > result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v11, 8);
    v10 = v8[2];
  }
  if (v6 != a5)
  {
    v12 = (_QWORD *)(*(_QWORD *)v8 + 8 * v10);
    v13 = v6;
    do
    {
      result = (unsigned int *)llvm::Instruction::getSuccessor(this, v13);
      *v12++ = result;
      v13 = ++v6;
    }
    while (v6 != a5);
  }
  v8[2] = v10 + v9;
  return result;
}

void sub_1C61AAEC4(uint64_t a1)
{
  int v2;
  uint64_t v3;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 <= 4 * v2 || v3 < 0x41)
    {
      if ((_DWORD)v3)
        memset_pattern16(*(void **)a1, &unk_1C85F4BD0, 8 * v3);
      *(_QWORD *)(a1 + 8) = 0;
    }
    else
    {
      sub_1C4EF1228(a1);
    }
  }
}

uint64_t sub_1C61AAF34@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61AAFC0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61AB054(a1, a2, v10);
    v7 = (_QWORD *)result;
    *(_QWORD *)result = *a2;
    v8 = 1;
  }
  v9 = *(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v9;
  *(_BYTE *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1C61AAFC0(uint64_t a1, int a2, unint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = (a2 - 1) & ((a3 >> 9) ^ a3);
    v6 = (_QWORD *)(a1 + 8 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -16;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 8 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61AB054(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EF1310(a1, v6);
  v8 = 0;
  sub_1C61AAFC0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61AB104(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t *v9;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
    memset_pattern16(*(void **)a1, &unk_1C85F4BD0, 8 * v6);
  while (a2 != a3)
  {
    v7 = *a2;
    if (*a2 != -16 && v7 != -4)
    {
      v9 = 0;
      sub_1C61AAFC0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v7, &v9);
      *v9 = *a2;
      ++*(_DWORD *)(a1 + 8);
    }
    ++a2;
  }
}

uint64_t llvm::objcarc::ObjCARCAAResult::alias(uint64_t a1, llvm::Value **a2, llvm::Value **a3)
{
  llvm *v5;
  llvm *v6;

  if (llvm::objcarc::EnableARCOpts)
  {
    v5 = sub_1C61AB204(*a2);
    v6 = sub_1C61AB204(*a3);
    sub_1C61AB258(v5);
    sub_1C61AB258(v6);
  }
  return 1;
}

llvm::Value *sub_1C61AB204(llvm::Value *a1)
{
  llvm::Value *v1;
  const llvm::Function *v2;
  char v3;
  const llvm::Function *v4;
  char v5;

  v1 = llvm::Value::stripPointerCasts(a1);
  v3 = sub_1C4EF1580((uint64_t)v1, v2);
  if (llvm::objcarc::IsForwarding(v3))
  {
    do
    {
      v1 = llvm::Value::stripPointerCasts(*((llvm::Value **)v1 - 4 * (*((_DWORD *)v1 + 5) & 0x7FFFFFF)));
      v5 = sub_1C4EF1580((uint64_t)v1, v4);
    }
    while ((llvm::objcarc::IsForwarding(v5) & 1) != 0);
  }
  return v1;
}

llvm *sub_1C61AB258(llvm *a1)
{
  llvm *UnderlyingObject;
  const llvm::Function *v2;
  char v3;
  const llvm::Function *v4;
  char v5;

  UnderlyingObject = llvm::getUnderlyingObject(a1, (const llvm::Value *)6);
  v3 = sub_1C4EF1580((uint64_t)UnderlyingObject, v2);
  if (llvm::objcarc::IsForwarding(v3))
  {
    do
    {
      UnderlyingObject = llvm::getUnderlyingObject(*((llvm **)UnderlyingObject - 4 * (*((_DWORD *)UnderlyingObject + 5) & 0x7FFFFFF)), (const llvm::Value *)6);
      v5 = sub_1C4EF1580((uint64_t)UnderlyingObject, v4);
    }
    while ((llvm::objcarc::IsForwarding(v5) & 1) != 0);
  }
  return UnderlyingObject;
}

uint64_t llvm::objcarc::ObjCARCAAResult::pointsToConstantMemory(uint64_t a1, llvm::Value **a2)
{
  llvm *v3;

  if (llvm::objcarc::EnableARCOpts)
  {
    v3 = sub_1C61AB204(*a2);
    sub_1C61AB258(v3);
  }
  return 0;
}

uint64_t llvm::objcarc::ObjCARCAAResult::getModRefBehavior(llvm::objcarc::ObjCARCAAResult *this, const llvm::Function *a2)
{
  uint64_t v2;

  v2 = 63;
  if (llvm::objcarc::EnableARCOpts)
  {
    if (llvm::objcarc::GetFunctionClass(a2, a2) == 9)
      return 4;
    else
      return 63;
  }
  return v2;
}

uint64_t llvm::objcarc::ObjCARCAAResult::getModRefInfo(uint64_t a1, const llvm::Function *a2)
{
  unsigned int v2;

  if (llvm::objcarc::EnableARCOpts && (v2 = sub_1C4EF1580((uint64_t)a2, a2), v2 <= 0xB))
    return byte_1C85F4C47[v2];
  else
    return 7;
}

uint64_t llvm::objcarc::ObjCARCAA::run@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = llvm::Module::getDataLayout(*(llvm::Module **)(a1 + 40));
  *a2 = 0;
  a2[1] = result;
  return result;
}

void llvm::initializeObjCARCAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E8B8);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EF15D4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E8B8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::objcarc::ObjCARCAAWrapperPass *llvm::createObjCARCAAWrapperPass(llvm *this)
{
  llvm::objcarc::ObjCARCAAWrapperPass *v1;

  v1 = (llvm::objcarc::ObjCARCAAWrapperPass *)operator new();
  return llvm::objcarc::ObjCARCAAWrapperPass::ObjCARCAAWrapperPass(v1);
}

llvm::objcarc::ObjCARCAAWrapperPass *llvm::objcarc::ObjCARCAAWrapperPass::ObjCARCAAWrapperPass(llvm::objcarc::ObjCARCAAWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::objcarc::ObjCARCAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813A370;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E8B8);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EF15D4;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E8B8, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::objcarc::ObjCARCAAWrapperPass::doInitialization(llvm::objcarc::ObjCARCAAWrapperPass *this, llvm::Module *a2)
{
  _QWORD *v4;
  uint64_t DataLayout;
  uint64_t v6;

  v4 = (_QWORD *)operator new();
  DataLayout = llvm::Module::getDataLayout(a2);
  *v4 = 0;
  v4[1] = DataLayout;
  v6 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v4;
  if (v6)
    MEMORY[0x1CAA32FC0](v6, 0x60C40FAFB2B2FLL);
  return 0;
}

uint64_t llvm::objcarc::ObjCARCAAWrapperPass::doFinalization(llvm::objcarc::ObjCARCAAWrapperPass *this, llvm::Module *a2)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v3)
    MEMORY[0x1CAA32FC0](v3, 0x60C40FAFB2B2FLL);
  return 0;
}

void llvm::objcarc::ObjCARCAAWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

void sub_1C61AB574(llvm::ImmutablePass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813A370;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x60C40FAFB2B2FLL);
  llvm::ImmutablePass::~ImmutablePass(this);
}

void sub_1C61AB5C0(llvm::ImmutablePass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813A370;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x60C40FAFB2B2FLL);
  llvm::ImmutablePass::~ImmutablePass(this);
  JUMPOUT(0x1CAA32FC0);
}

llvm::objcarc::ObjCARCAAWrapperPass *llvm::callDefaultCtor<llvm::objcarc::ObjCARCAAWrapperPass>()
{
  llvm::objcarc::ObjCARCAAWrapperPass *v0;

  v0 = (llvm::objcarc::ObjCARCAAWrapperPass *)operator new();
  return llvm::objcarc::ObjCARCAAWrapperPass::ObjCARCAAWrapperPass(v0);
}

void sub_1C61AB648(__int128 *a1, _BYTE **a2, char **a3, _WORD *a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F2E18, 0, 0);
  byte_1ED7F2EA9 = 0;
  qword_1ED7F2E98 = 0;
  unk_1ED7F2EA0 = &off_1E7F9E8D8;
  qword_1ED7F2E18 = (uint64_t)&unk_1E8138EB8;
  qword_1ED7F2EB0 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F2EB8 = (uint64_t)&unk_1E8138F20;
  qword_1ED7F2ED0 = (uint64_t)&qword_1ED7F2EB8;
  sub_1C61AB6FC(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F2E18);
}

uint64_t sub_1C61AB6FC(__int128 *a1, _BYTE **a2, char **a3, _WORD *a4)
{
  uint64_t result;
  char *v9;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F2E18, "enable-objc-arc-opts", 0x14uLL);
  xmmword_1ED7F2E38 = *a1;
  result = sub_1C4EB7838((llvm *)&qword_1ED7F2E98, &qword_1ED7F2E18, *a2);
  v9 = *a3;
  *(_BYTE *)qword_1ED7F2E98 = **a3;
  byte_1ED7F2EA9 = 1;
  byte_1ED7F2EA8 = *v9;
  word_1ED7F2E22 = (32 * (*a4 & 3)) | word_1ED7F2E22 & 0xFF9F;
  return result;
}

uint64_t llvm::objcarc::GetFunctionClass(llvm::objcarc *this, const llvm::Function *a2)
{
  int v2;

  v2 = *((_DWORD *)this + 9) - 204;
  if (v2 > 0x1F)
    return 21;
  else
    return dword_1C85F4CB0[v2];
}

uint64_t sub_1C61AB7C8(uint64_t a1)
{
  llvm::Argument **v2;
  uint64_t v3;
  llvm::Argument **v4;
  BOOL v5;
  unsigned int v6;
  unsigned int v7;

  v2 = (llvm::Argument **)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF));
  v3 = sub_1C4DD000C(a1);
  if (v2 == (llvm::Argument **)v3)
  {
LABEL_5:
    v5 = sub_1C4DD007C(a1, 45) == 0;
    v6 = 22;
    v7 = 24;
  }
  else
  {
    v4 = (llvm::Argument **)v3;
    while (!sub_1C4EF2064(*v2))
    {
      v2 += 4;
      if (v2 == v4)
        goto LABEL_5;
    }
    v5 = sub_1C4DD007C(a1, 45) == 0;
    v6 = 21;
    v7 = 23;
  }
  if (v5)
    return v6;
  else
    return v7;
}

BOOL llvm::objcarc::IsRetain(unsigned int a1)
{
  return a1 < 2;
}

BOOL llvm::objcarc::IsAutorelease(int a1)
{
  return (a1 - 5) < 2;
}

uint64_t llvm::objcarc::IsForwarding(char a1)
{
  return (0x267u >> a1) & 1;
}

BOOL llvm::objcarc::IsNoopOnNull(unsigned int a1)
{
  return a1 < 7;
}

uint64_t llvm::objcarc::IsNoopOnGlobal(char a1)
{
  return (0xC7Fu >> a1) & 1;
}

uint64_t llvm::objcarc::IsAlwaysTail(char a1)
{
  return (0x47u >> a1) & 1;
}

BOOL llvm::objcarc::IsNeverTail(int a1)
{
  return a1 == 5;
}

uint64_t llvm::objcarc::IsNoThrow(char a1)
{
  return (0x1F7u >> a1) & 1;
}

uint64_t llvm::objcarc::CanInterruptRV(char a1)
{
  return (0x600D60u >> a1) & 1;
}

uint64_t llvm::objcarc::CanDecrementRefCount(char a1)
{
  return (0x6FF19Cu >> a1) & 1;
}

unint64_t llvm::OptimizationRemarkEmitter::emit(llvm::OptimizationRemarkEmitter *this, llvm::DiagnosticInfoOptimizationBase *a2)
{
  const llvm::BasicBlock *v4;
  uint64_t *BlockProfileCount;
  uint64_t v6;
  unint64_t v7;
  unint64_t result;

  v4 = (const llvm::BasicBlock *)*((_QWORD *)a2 + 45);
  if (v4)
  {
    BlockProfileCount = (uint64_t *)*((_QWORD *)this + 1);
    if (BlockProfileCount)
      BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount((uint64_t **)BlockProfileCount, v4, 0);
    else
      v6 = 0;
    *((_QWORD *)a2 + 8) = BlockProfileCount;
    *((_QWORD *)a2 + 9) = v6;
  }
  else
  {
    BlockProfileCount = (uint64_t *)*((_QWORD *)a2 + 8);
    LOBYTE(v6) = *((_BYTE *)a2 + 72);
  }
  if ((_BYTE)v6)
    v7 = (unint64_t)BlockProfileCount;
  else
    v7 = 0;
  result = llvm::LLVMContext::getDiagnosticsHotnessThreshold(***(llvm::LLVMContext ****)this);
  if (v7 >= result)
    return llvm::LLVMContext::diagnose(***(_QWORD ***)this, a2);
  return result;
}

llvm::OptimizationRemarkEmitterWrapperPass *llvm::OptimizationRemarkEmitterWrapperPass::OptimizationRemarkEmitterWrapperPass(llvm::OptimizationRemarkEmitterWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::OptimizationRemarkEmitterWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E813A418;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E8C8);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EF25EC;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E8C8, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeOptimizationRemarkEmitterWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E8C8);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EF25EC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E8C8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::AnalysisUsage *llvm::OptimizationRemarkEmitterWrapperPass::getAnalysisUsage(llvm::OptimizationRemarkEmitterWrapperPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage *result;

  llvm::LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(a2, a2);
  result = llvm::AnalysisUsage::addRequiredID(a2, llvm::ProfileSummaryInfoWrapperPass::ID);
  *((_BYTE *)a2 + 160) = 1;
  return result;
}

void sub_1C61ABAC4(llvm::Pass *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E813A418;
  v4 = *((_QWORD *)this + 4);
  v2 = (_QWORD *)((char *)this + 32);
  v3 = v4;
  *v2 = 0;
  if (v4)
    sub_1C4EF268C((uint64_t)v2, v3);
  llvm::Pass::~Pass(this);
}

void sub_1C61ABB00(llvm::Pass *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E813A418;
  v4 = *((_QWORD *)this + 4);
  v2 = (_QWORD *)((char *)this + 32);
  v3 = v4;
  *v2 = 0;
  if (v4)
    sub_1C4EF268C((uint64_t)v2, v3);
  llvm::Pass::~Pass(this);
  JUMPOUT(0x1CAA32FC0);
}

llvm::OptimizationRemarkEmitterWrapperPass *llvm::callDefaultCtor<llvm::OptimizationRemarkEmitterWrapperPass>()
{
  llvm::OptimizationRemarkEmitterWrapperPass *v0;

  v0 = (llvm::OptimizationRemarkEmitterWrapperPass *)operator new();
  return llvm::OptimizationRemarkEmitterWrapperPass::OptimizationRemarkEmitterWrapperPass(v0);
}

uint64_t sub_1C61ABB78(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  _BYTE v18[8];
  uint64_t v19[3];

  v8 = sub_1C4D91F84(*a1, a2);
  v9 = *a1;
  v10 = *a1 + 8;
  if ((*(_BYTE *)*a1 & 1) != 0)
  {
    v11 = 8;
  }
  else
  {
    v10 = *(_QWORD *)(v9 + 8);
    v11 = *(unsigned int *)(v9 + 16);
  }
  if (v10 + 16 * v11 == v8)
  {
    v13 = a1[1];
    v19[0] = a2;
    v19[1] = a3;
    v17 = 0;
    if (sub_1C4D920B0((uint64_t *)v13, v19, &v17))
      v14 = v17;
    else
      v14 = *(_QWORD *)v13 + 24 * *(unsigned int *)(v13 + 16);
    v15 = *a1;
    v16 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *))(**(_QWORD **)(*(_QWORD *)(v14 + 16) + 24)
                                                                         + 16))(*(_QWORD *)(*(_QWORD *)(v14 + 16) + 24), a3, a4, a1);
    v17 = a2;
    v18[0] = v16;
    sub_1C4D921A4(v15, &v17, v18, (uint64_t)v19);
    v8 = v19[0];
  }
  return *(unsigned __int8 *)(v8 + 8);
}

llvm *llvm::PHITransAddr::dump(llvm::PHITransAddr *this)
{
  uint64_t v2;
  llvm *v3;
  llvm::raw_ostream *v4;
  llvm *result;
  uint64_t v6;
  unint64_t i;
  llvm *v8;
  llvm::raw_ostream *v9;
  llvm::raw_ostream *v10;

  v2 = *(_QWORD *)this;
  v3 = llvm::dbgs(this);
  if (!v2)
    return sub_1C4816AD8(v3, "PHITransAddr: null\n");
  v4 = sub_1C4816AD8(v3, "PHITransAddr: ");
  llvm::Value::print(*(llvm::Value **)this, v4, 0);
  result = sub_1C4816AD8(v4, "\n");
  v6 = *((unsigned int *)this + 10);
  if ((_DWORD)v6)
  {
    for (i = 0; i != v6; ++i)
    {
      v8 = llvm::dbgs(result);
      v9 = sub_1C4816AD8(v8, "  Input #");
      sub_1C5E21910(v9, i, 0, 0, 0);
      v10 = sub_1C4816AD8(v9, " is ");
      llvm::Value::print(*(llvm::Value **)(*((_QWORD *)this + 4) + 8 * i), v10, 0);
      result = sub_1C4816AD8(v10, "\n");
    }
  }
  return result;
}

llvm::raw_ostream *sub_1C61ABD88(llvm::raw_ostream *a1, llvm::Value *this)
{
  llvm::Value::print(this, a1, 0);
  return a1;
}

llvm::raw_ostream *sub_1C61ABDB8(llvm::raw_ostream *result, char a2)
{
  char *v2;

  v2 = (char *)*((_QWORD *)result + 4);
  if ((unint64_t)v2 >= *((_QWORD *)result + 3))
    return llvm::raw_ostream::write(result, a2);
  *((_QWORD *)result + 4) = v2 + 1;
  *v2 = a2;
  return result;
}

void llvm::PhiValues::PhiValuesCallbackVH::deleted(llvm::PhiValues **this)
{
  llvm::PhiValues::invalidateValue(this[4], this[3]);
}

void llvm::PhiValues::PhiValuesCallbackVH::allUsesReplacedWith(llvm::PhiValues **this, llvm::Value *a2)
{
  llvm::PhiValues::invalidateValue(this[4], this[3]);
}

void *sub_1C61ABE04(uint64_t a1, uint64_t *a2)
{
  void *result;
  uint64_t v5;
  uint64_t v6;
  _BYTE v7[24];

  result = sub_1C61540B4((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    v5 = *a2;
    v6 = *(unsigned int *)(a1 + 48);
    if (v6 >= *(_DWORD *)(a1 + 52))
    {
      result = llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 40, a1 + 56, v6 + 1, 8);
      LODWORD(v6) = *(_DWORD *)(a1 + 48);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 48);
  }
  return result;
}

void *sub_1C61ABE84(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BYTE v11[24];
  uint64_t v12;
  uint64_t v13;

  if (a2 != a3)
  {
    v12 = v3;
    v13 = v4;
    v6 = a2;
    v7 = (uint64_t)result;
    v8 = (uint64_t)result + 40;
    do
    {
      result = sub_1C61540B4((uint64_t)v11, v7, v6);
      if (v11[16])
      {
        v9 = *v6;
        v10 = *(unsigned int *)(v7 + 48);
        if (v10 >= *(unsigned int *)(v7 + 52))
        {
          result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v7 + 56, v10 + 1, 8);
          v10 = *(unsigned int *)(v7 + 48);
        }
        *(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * v10) = v9;
        ++*(_DWORD *)(v7 + 48);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

_DWORD *llvm::PhiValues::getValuesForPhi(llvm::PhiValues *this, const llvm::PHINode *a2)
{
  uint64_t *v4;
  int v5;
  int v7;
  uint64_t v8;
  const llvm::PHINode *v9;
  void *v10[2];
  _QWORD v11[9];

  v11[8] = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t *)((char *)this + 8);
  v9 = 0;
  v10[0] = a2;
  if ((sub_1C61252B8((uint64_t *)this + 1, v10, &v9) & 1) == 0 || (v7 = *((_DWORD *)v9 + 2)) == 0)
  {
    v10[0] = v11;
    v10[1] = (void *)0x800000000;
    llvm::PhiValues::processPhi((uint64_t *)this, (uint64_t)a2, (uint64_t)v10);
    v8 = 0;
    v9 = a2;
    if (sub_1C61252B8(v4, &v9, &v8))
      v5 = *(_DWORD *)(v8 + 8);
    else
      v5 = 0;
    v7 = v5;
    if (v10[0] != v11)
      free(v10[0]);
  }
  return sub_1C61ACC58((uint64_t)this + 32, &v7) + 2;
}

int32x2_t sub_1C61AC02C(uint64_t a1, int a2)
{
  int32x2_t result;
  uint64_t v4;
  void *v5;
  uint64_t v6;

  v6 = 0;
  if (sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, &v6))
  {
    v4 = v6;
    v5 = *(void **)(v6 + 48);
    if (v5 != (void *)(v6 + 64))
      free(v5);
    if ((*(_BYTE *)(v4 + 8) & 1) == 0)
      MEMORY[0x1CAA32FB4](*(_QWORD *)(v4 + 16), 8);
    *(_DWORD *)v4 = -2;
    result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

int32x2_t sub_1C61AC0B8(uint64_t a1, int a2)
{
  int32x2_t result;
  uint64_t v4;
  void *v5;
  uint64_t v6;

  v6 = 0;
  if (sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, &v6))
  {
    v4 = v6;
    v5 = *(void **)(v6 + 48);
    if (v5 != (void *)(v6 + 64))
      free(v5);
    if ((*(_BYTE *)(v4 + 8) & 1) == 0)
      MEMORY[0x1CAA32FB4](*(_QWORD *)(v4 + 16), 8);
    *(_DWORD *)v4 = -2;
    result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

void sub_1C61AC140(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  void *v7;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C4EF55FC(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_15:
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
    v4 = *(_QWORD *)a1 + 64;
    v5 = 96 * v3;
    while (1)
    {
      v6 = *(_DWORD *)(v4 - 64);
      if (v6 == -2)
        goto LABEL_13;
      if (v6 != -1)
        break;
LABEL_14:
      v4 += 96;
      v5 -= 96;
      if (!v5)
        goto LABEL_15;
    }
    v7 = *(void **)(v4 - 16);
    if ((void *)v4 != v7)
      free(v7);
    if ((*(_BYTE *)(v4 - 56) & 1) == 0)
      MEMORY[0x1CAA32FB4](*(_QWORD *)(v4 - 48), 8);
LABEL_13:
    *(_DWORD *)(v4 - 64) = -1;
    goto LABEL_14;
  }
}

void sub_1C61AC208(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  void *v7;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C4EF577C(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_15:
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
    v4 = *(_QWORD *)a1 + 64;
    v5 = 96 * v3;
    while (1)
    {
      v6 = *(_DWORD *)(v4 - 64);
      if (v6 == -2)
        goto LABEL_13;
      if (v6 != -1)
        break;
LABEL_14:
      v4 += 96;
      v5 -= 96;
      if (!v5)
        goto LABEL_15;
    }
    v7 = *(void **)(v4 - 16);
    if ((void *)v4 != v7)
      free(v7);
    if ((*(_BYTE *)(v4 - 56) & 1) == 0)
      MEMORY[0x1CAA32FB4](*(_QWORD *)(v4 - 48), 8);
LABEL_13:
    *(_DWORD *)(v4 - 64) = -1;
    goto LABEL_14;
  }
}

llvm::PhiValuesWrapperPass *llvm::PhiValuesWrapperPass::PhiValuesWrapperPass(llvm::PhiValuesWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::PhiValuesWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E813A4B8;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E8D0);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EF5028;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E8D0, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializePhiValuesWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82E8D0);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EF5028;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82E8D0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::PhiValuesWrapperPass::runOnFunction(llvm::PhiValuesWrapperPass *this, llvm::Function *a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  v4 = operator new();
  *(_DWORD *)v4 = 1;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 48) = 0;
  *(_QWORD *)(v4 + 56) = 0;
  *(_QWORD *)(v4 + 64) = 0;
  *(_DWORD *)(v4 + 72) = 0;
  *(_QWORD *)(v4 + 80) = 0;
  *(_QWORD *)(v4 + 88) = 0;
  *(_DWORD *)(v4 + 96) = 0;
  *(_QWORD *)(v4 + 104) = a2;
  v5 = (_QWORD *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v4;
  if (v5)
  {
    v6 = sub_1C4EF58FC(v5);
    MEMORY[0x1CAA32FC0](v6, 0x1060C4015D4655FLL);
  }
  return 0;
}

void llvm::PhiValuesWrapperPass::releaseMemory(llvm::PhiValuesWrapperPass *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 4);
  sub_1C61446F0((unsigned int *)(v1 + 8));
  sub_1C61AC140(v1 + 32);
  sub_1C61AC208(v1 + 56);
}

void llvm::PhiValuesWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

void sub_1C61AC494(llvm::Pass *a1)
{
  sub_1C61AC4E0(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::PhiValuesWrapperPass *llvm::callDefaultCtor<llvm::PhiValuesWrapperPass>()
{
  llvm::PhiValuesWrapperPass *v0;

  v0 = (llvm::PhiValuesWrapperPass *)operator new();
  return llvm::PhiValuesWrapperPass::PhiValuesWrapperPass(v0);
}

void sub_1C61AC4E0(llvm::Pass *this)
{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_1E813A4B8;
  v2 = (_QWORD *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
  {
    v3 = sub_1C4EF58FC(v2);
    MEMORY[0x1CAA32FC0](v3, 0x1060C4015D4655FLL);
  }
  llvm::Pass::~Pass(this);
}

_QWORD *sub_1C61AC530(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61252B8(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61AC590((uint64_t)a1, a2, v7);
    *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

_QWORD *sub_1C61AC590(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C47A8B04(a1, v6);
  v8 = 0;
  sub_1C61252B8((uint64_t *)a1, a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

unint64_t sub_1C61AC63C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t result;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;

  v10 = 0;
  result = sub_1C61AC6DC(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), a3[3], &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    v7 = sub_1C61AC778(a2, (uint64_t)a3, v10);
    result = sub_1C4D98DE0((unint64_t *)(v7 + 8), a3 + 1);
    *(_QWORD *)(v7 + 32) = a3[4];
    v8 = 1;
  }
  v9 = *(_QWORD *)a2 + 40 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v9;
  *(_BYTE *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1C61AC6DC(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = a1 + 40 * v5;
    v7 = *(_QWORD *)(v6 + 24);
    if (v7 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = a1 + 40 * (v13 & v4);
        v7 = *(_QWORD *)(v6 + 24);
        v8 = 1;
        if (v7 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

uint64_t sub_1C61AC778(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  unsigned int v6;
  uint64_t v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EF50BC(a1, v6);
  v8 = 0;
  sub_1C61AC6DC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *(_QWORD *)(a2 + 24), &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(_QWORD *)(a3 + 24) != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61AC828(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = (37 * a3) & (a2 - 1);
    v6 = (_DWORD *)(a1 + 96 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -2;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_DWORD *)(a1 + 96 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1C61AC8C4(uint64_t a1, int *a2)
{
  char v4;
  _DWORD *v5;
  int64x2_t v7;
  _DWORD *v8;

  v8 = 0;
  v4 = sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  v5 = v8;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61AC96C(a1, a2, v8);
    *v5 = *a2;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_QWORD *)v5 + 1) = 1;
    v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    *((int64x2_t *)v5 + 1) = v7;
    *((int64x2_t *)v5 + 2) = v7;
    *((_QWORD *)v5 + 6) = v5 + 16;
    *((_QWORD *)v5 + 7) = 0x400000000;
  }
  return v5;
}

_DWORD *sub_1C61AC96C(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EF5474(a1, v6);
  v8 = 0;
  sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61ACA1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  void *v11;
  _DWORD *v12;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_DWORD **)a1;
    v8 = 96 * v6;
    do
    {
      *v7 = -1;
      v7 += 24;
      v8 -= 96;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      v12 = 0;
      sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      v10 = v12;
      *v12 = *(_DWORD *)a2;
      sub_1C61ACAFC((uint64_t)(v10 + 2), (unsigned int *)(a2 + 8));
      ++*(_DWORD *)(a1 + 8);
      v11 = *(void **)(a2 + 48);
      if ((void *)(a2 + 64) != v11)
        free(v11);
      if ((*(_BYTE *)(a2 + 8) & 1) == 0)
        MEMORY[0x1CAA32FB4](*(_QWORD *)(a2 + 16), 8);
    }
    a2 += 96;
  }
}

uint64_t sub_1C61ACAFC(uint64_t a1, unsigned int *a2)
{
  int64x2_t v4;

  *(_QWORD *)a1 = 1;
  v4 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  *(int64x2_t *)(a1 + 8) = v4;
  *(int64x2_t *)(a1 + 24) = v4;
  sub_1C61ACB6C((unsigned int *)a1, a2);
  *(_QWORD *)(a1 + 40) = a1 + 56;
  *(_QWORD *)(a1 + 48) = 0x400000000;
  if (a2[12])
    sub_1C614D378(a1 + 40, (uint64_t)(a2 + 10));
  return a1;
}

unsigned int *sub_1C61ACB6C(unsigned int *result, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t i;
  uint64_t v8;
  int *v9;
  int *v10;
  uint64_t v11;
  __int128 v12;

  v2 = *a2;
  *a2 = *result & 0xFFFFFFFE | *a2 & 1;
  v3 = result[1];
  *result = v2 & 0xFFFFFFFE | *result & 1;
  result[1] = a2[1];
  a2[1] = v3;
  v4 = *a2;
  if ((*result & 1) == 0)
  {
    if ((v4 & 1) == 0)
    {
      v5 = *((_QWORD *)result + 1);
      *((_QWORD *)result + 1) = *((_QWORD *)a2 + 1);
      *((_QWORD *)a2 + 1) = v5;
      LODWORD(v5) = result[4];
      result[4] = a2[4];
      a2[4] = v5;
      return result;
    }
    v4 = *result;
    v6 = result;
    result = a2;
    goto LABEL_7;
  }
  if ((v4 & 1) == 0)
  {
    v6 = a2;
LABEL_7:
    v12 = *(_OWORD *)(v6 + 2);
    *v6 = v4 | 1;
    for (i = 2; i != 10; i += 2)
      *(_QWORD *)&v6[i] = *(_QWORD *)&result[i];
    *result &= ~1u;
    *(_OWORD *)(result + 2) = v12;
    return result;
  }
  v8 = 0;
  v9 = (int *)(result + 2);
  v10 = (int *)(a2 + 2);
  do
  {
    v11 = *(_QWORD *)&v9[v8];
    *(_QWORD *)&v9[v8] = *(_QWORD *)&v10[v8];
    *(_QWORD *)&v10[v8] = v11;
    v8 += 2;
  }
  while (v8 != 8);
  return result;
}

_DWORD *sub_1C61ACC58(uint64_t a1, int *a2)
{
  char v4;
  _DWORD *v5;
  int64x2_t v7;
  _DWORD *v8;

  v8 = 0;
  v4 = sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  v5 = v8;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61ACD00(a1, a2, v8);
    *v5 = *a2;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_QWORD *)v5 + 1) = 1;
    v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    *((int64x2_t *)v5 + 1) = v7;
    *((int64x2_t *)v5 + 2) = v7;
    *((_QWORD *)v5 + 6) = v5 + 16;
    *((_QWORD *)v5 + 7) = 0x400000000;
  }
  return v5;
}

_DWORD *sub_1C61ACD00(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4EF5538(a1, v6);
  v8 = 0;
  sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61ACDB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  void *v11;
  _DWORD *v12;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_DWORD **)a1;
    v8 = 96 * v6;
    do
    {
      *v7 = -1;
      v7 += 24;
      v8 -= 96;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      v12 = 0;
      sub_1C61AC828(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      v10 = v12;
      *v12 = *(_DWORD *)a2;
      sub_1C4E44570(v10 + 2, (unsigned int *)(a2 + 8));
      ++*(_DWORD *)(a1 + 8);
      v11 = *(void **)(a2 + 48);
      if ((void *)(a2 + 64) != v11)
        free(v11);
      if ((*(_BYTE *)(a2 + 8) & 1) == 0)
        MEMORY[0x1CAA32FB4](*(_QWORD *)(a2 + 16), 8);
    }
    a2 += 96;
  }
}

int32x2_t sub_1C61ACE8C(int32x2_t *a1, uint64_t a2)
{
  uint64_t v4;
  int32x2_t result;
  uint64_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[1] = 0;
  v8 = -8192;
  v7[0] = 2;
  v9 = 0;
  sub_1C4D98DE0((unint64_t *)(a2 + 8), v7);
  v4 = v8;
  *(_QWORD *)(a2 + 32) = v9;
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

llvm::PostDominatorTreeWrapperPass *llvm::PostDominatorTreeWrapperPass::PostDominatorTreeWrapperPass(llvm::PostDominatorTreeWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::PostDominatorTreeWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E813A580;
  *((_QWORD *)this + 4) = (char *)this + 48;
  *((_QWORD *)this + 5) = 0x400000000;
  *((_DWORD *)this + 31) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_BYTE *)this + 120) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82E8D8);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EF5A2C;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82E8D8, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

llvm::raw_ostream *llvm::PostDominatorTreeWrapperPass::print(llvm::PostDominatorTreeWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  return llvm::DominatorTreeBase<llvm::BasicBlock,true>::print((uint64_t)this + 32, a2);
}

llvm::PostDominatorTreeWrapperPass *llvm::createPostDomTree(llvm *this)
{
  llvm::PostDominatorTreeWrapperPass *v1;

  v1 = (llvm::PostDominatorTreeWrapperPass *)operator new();
  return llvm::PostDominatorTreeWrapperPass::PostDominatorTreeWrapperPass(v1);
}

_QWORD *llvm::PostDominatorTreePrinterPass::PostDominatorTreePrinterPass(_QWORD *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

_QWORD *llvm::PostDominatorTreePrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, llvm::Value *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  llvm::raw_ostream *v8;
  size_t v9;
  char *Name;
  size_t v11;
  void *v12;
  uint64_t ResultImpl;

  v8 = sub_1C4816AD8(*a1, "PostDominatorTree for function: ");
  Name = llvm::Value::getName(a2);
  v11 = v9;
  v12 = (void *)*((_QWORD *)v8 + 4);
  if (v9 <= *((_QWORD *)v8 + 3) - (_QWORD)v12)
  {
    if (v9)
    {
      memcpy(v12, Name, v9);
      *((_QWORD *)v8 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, Name, v9);
  }
  sub_1C4816AD8(v8, "\n");
  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::PostDominatorTreeAnalysis::Key, (uint64_t)a2);
  llvm::DominatorTreeBase<llvm::BasicBlock,true>::print(ResultImpl + 8, *a1);
  return llvm::InstCountPass::run(a4);
}

void sub_1C61AD0F4(uint64_t *a1)
{
  sub_1C4EF5C50(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61AD118(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

llvm::PostDominatorTreeWrapperPass *llvm::callDefaultCtor<llvm::PostDominatorTreeWrapperPass>()
{
  llvm::PostDominatorTreeWrapperPass *v0;

  v0 = (llvm::PostDominatorTreeWrapperPass *)operator new();
  return llvm::PostDominatorTreeWrapperPass::PostDominatorTreeWrapperPass(v0);
}

llvm::raw_ostream *sub_1C61AD14C(uint64_t a1, llvm::raw_ostream *a2, unsigned int a3)
{
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm::raw_ostream *v9;
  llvm::raw_ostream *result;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = llvm::raw_ostream::indent(a2, 2 * a3);
  v7 = sub_1C4816AD8(v6, "[");
  v8 = llvm::raw_ostream::operator<<(v7, a3);
  v9 = sub_1C4816AD8(v8, "] ");
  result = sub_1C61AD1D8(v9, a1);
  v11 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v11)
  {
    v12 = *(uint64_t **)(a1 + 24);
    v13 = a3 + 1;
    v14 = 8 * v11;
    do
    {
      v15 = *v12++;
      result = (llvm::raw_ostream *)sub_1C61AD14C(v15, a2, v13);
      v14 -= 8;
    }
    while (v14);
  }
  return result;
}

llvm::raw_ostream *sub_1C61AD1D8(llvm::raw_ostream *a1, uint64_t a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm::raw_ostream *v9;

  if (*(_QWORD *)a2)
    llvm::Value::printAsOperand(*(llvm::Value **)a2, a1, 0, 0);
  else
    sub_1C4816AD8(a1, " <<exit node>>");
  v4 = sub_1C4816AD8(a1, " {");
  v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)(a2 + 72));
  v6 = sub_1C4816AD8(v5, ",");
  v7 = llvm::raw_ostream::operator<<(v6, *(unsigned int *)(a2 + 76));
  v8 = sub_1C4816AD8(v7, "} [");
  v9 = llvm::raw_ostream::operator<<(v8, *(unsigned int *)(a2 + 16));
  sub_1C4816AD8(v9, "]\n");
  return a1;
}

unint64_t llvm::ProfileSummaryInfo::getProfileCount(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock **a2, uint64_t **a3, int a4)
{
  _DWORD *v4;
  int v5;
  unint64_t v6;
  uint64_t *BlockProfileCount;
  unint64_t v9;

  v4 = (_DWORD *)*((_QWORD *)this + 1);
  if (v4 && *v4 == 2)
  {
    v9 = 0;
    v5 = llvm::Instruction::extractProfTotalWeight((llvm::Instruction *)a2, &v9);
    v6 = v9 & 0xFFFFFFFFFFFFFF00;
    if (v5)
    {
      LOBYTE(BlockProfileCount) = v9;
    }
    else
    {
      v6 = 0;
      LOBYTE(BlockProfileCount) = 0;
    }
  }
  else if (a3)
  {
    BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a3, a2[5], a4);
    v6 = (unint64_t)BlockProfileCount & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    v6 = 0;
    LOBYTE(BlockProfileCount) = 0;
  }
  return BlockProfileCount | v6;
}

BOOL llvm::ProfileSummaryInfo::isHotCount(llvm::ProfileSummaryInfo *this, unint64_t a2)
{
  return *((_BYTE *)this + 24) && *((_QWORD *)this + 2) <= a2;
}

BOOL llvm::ProfileSummaryInfo::isColdCount(llvm::ProfileSummaryInfo *this, unint64_t a2)
{
  return *((_BYTE *)this + 40) && *((_QWORD *)this + 4) >= a2;
}

BOOL llvm::ProfileSummaryInfo::isColdBlock(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock *a2, uint64_t **a3)
{
  uint64_t *BlockProfileCount;
  char v5;

  BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a3, a2, 0);
  return v5 && *((_BYTE *)this + 40) && *((_QWORD *)this + 4) >= (unint64_t)BlockProfileCount;
}

BOOL llvm::ProfileSummaryInfo::isFunctionHotnessUnknown(llvm::ProfileSummaryInfo *this, uint64_t ***a2)
{
  _BYTE v3[24];

  llvm::Function::getEntryCount(a2, 0, (uint64_t)v3);
  return v3[16] == 0;
}

BOOL llvm::ProfileSummaryInfo::hasPartialSampleProfile(llvm::ProfileSummaryInfo *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (!v1 || *(_DWORD *)v1 != 2)
    return 0;
  if (byte_1ED82E960)
    return 1;
  return *(_BYTE *)(v1 + 72) != 0;
}

BOOL llvm::ProfileSummaryInfo::hasLargeWorkingSetSize(llvm::ProfileSummaryInfo *this)
{
  return *((_BYTE *)this + 51) && *((_BYTE *)this + 50) != 0;
}

BOOL llvm::ProfileSummaryInfo::isHotCountNthPercentile(llvm::ProfileSummaryInfo *this, int a2, unint64_t a3)
{
  unint64_t v4;
  char v5;
  BOOL v6;

  v4 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
  if (v5)
    v6 = v4 > a3;
  else
    v6 = 1;
  return !v6;
}

BOOL llvm::ProfileSummaryInfo::isColdCountNthPercentile(llvm::ProfileSummaryInfo *this, int a2, unint64_t a3)
{
  unint64_t v4;
  char v5;

  v4 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
  return v5 && v4 >= a3;
}

uint64_t llvm::ProfileSummaryInfo::getOrCompColdCountThreshold(llvm::ProfileSummaryInfo *this)
{
  if (*((_BYTE *)this + 40))
    return *((_QWORD *)this + 4);
  else
    return 0;
}

BOOL llvm::ProfileSummaryInfo::isHotBlockNthPercentile(llvm::ProfileSummaryInfo *this, int a2, const llvm::BasicBlock *a3, uint64_t **a4)
{
  uint64_t *BlockProfileCount;
  char v7;
  uint64_t *v8;
  unint64_t v9;
  char v10;
  BOOL v11;

  BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a4, a3, 0);
  if (!v7)
    return 0;
  v8 = BlockProfileCount;
  v9 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
  if (v10)
    v11 = v9 > (unint64_t)v8;
  else
    v11 = 1;
  return !v11;
}

BOOL llvm::ProfileSummaryInfo::isColdBlockNthPercentile(llvm::ProfileSummaryInfo *this, int a2, const llvm::BasicBlock *a3, uint64_t **a4)
{
  uint64_t *BlockProfileCount;
  char v7;
  uint64_t *v8;
  unint64_t v9;
  char v10;

  BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a4, a3, 0);
  if (!v7)
    return 0;
  v8 = BlockProfileCount;
  v9 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
  return v10 && v9 >= (unint64_t)v8;
}

BOOL llvm::ProfileSummaryInfo::isHotCallSite(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock **a2, uint64_t **a3)
{
  unint64_t ProfileCount;
  char v5;

  ProfileCount = llvm::ProfileSummaryInfo::getProfileCount(this, a2, a3, 0);
  return v5 && *((_BYTE *)this + 24) && *((_QWORD *)this + 2) <= ProfileCount;
}

BOOL llvm::ProfileSummaryInfo::isColdCallSite(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock **a2, uint64_t **a3)
{
  unint64_t ProfileCount;
  char v6;
  _DWORD *v8;
  uint64_t ***Caller;
  _BYTE v10[24];

  ProfileCount = llvm::ProfileSummaryInfo::getProfileCount(this, a2, a3, 0);
  if (v6)
  {
    if (*((_BYTE *)this + 40))
      return *((_QWORD *)this + 4) >= ProfileCount;
  }
  else
  {
    v8 = (_DWORD *)*((_QWORD *)this + 1);
    if (v8 && *v8 == 2)
    {
      Caller = (uint64_t ***)llvm::CallBase::getCaller((llvm::CallBase *)a2);
      llvm::Function::getEntryCount(Caller, 0, (uint64_t)v10);
      return v10[16] != 0;
    }
  }
  return 0;
}

void llvm::initializeProfileSummaryInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82EA60);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EF693C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82EA60, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::ProfileSummaryInfoWrapperPass *llvm::ProfileSummaryInfoWrapperPass::ProfileSummaryInfoWrapperPass(llvm::ProfileSummaryInfoWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::ProfileSummaryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813A620;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EA60);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EF693C;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EA60, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void sub_1C61AD74C(llvm::ImmutablePass *a1)
{
  sub_1C61AD7A4(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61AD770(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

llvm::ProfileSummaryInfoWrapperPass *llvm::callDefaultCtor<llvm::ProfileSummaryInfoWrapperPass>()
{
  llvm::ProfileSummaryInfoWrapperPass *v0;

  v0 = (llvm::ProfileSummaryInfoWrapperPass *)operator new();
  return llvm::ProfileSummaryInfoWrapperPass::ProfileSummaryInfoWrapperPass(v0);
}

void sub_1C61AD7A4(llvm::ImmutablePass *this)
{
  uint64_t v2;
  uint64_t v3;
  llvm::ImmutablePass *v4;

  *(_QWORD *)this = &off_1E813A620;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
  {
    v4 = this;
    v3 = sub_1C4EF6F9C(v2);
    MEMORY[0x1CAA32FC0](v3, 0x1060C40BAADE331);
    llvm::ImmutablePass::~ImmutablePass(v4);
  }
  else
  {
    llvm::ImmutablePass::~ImmutablePass(this);
  }
}

void sub_1C61AD800(_WORD *a1, char **a2, __n128 *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED82E8E0, 0, 0);
  byte_1ED82E960 = 0;
  qword_1ED82E968 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED82E970 = 0;
  qword_1ED82E8E0 = (uint64_t)&unk_1E819E898;
  qword_1ED82E978 = (uint64_t)&off_1E819E9A0;
  qword_1ED82E980 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED82E998 = (uint64_t)&qword_1ED82E980;
  sub_1C4EF6E94(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED82E8E0);
}

void sub_1C61AD8A4(_WORD *a1, uint64_t **a2, __n128 *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F2ED8, 0, 0);
  xmmword_1ED7F2F58 = 0u;
  *(_OWORD *)&qword_1ED7F2F68 = 0u;
  *((_QWORD *)&xmmword_1ED7F2F58 + 1) = &unk_1E8134CB8;
  qword_1ED7F2ED8 = (uint64_t)&unk_1E8134C50;
  qword_1ED7F2F78 = (uint64_t)&unk_1E819E320;
  qword_1ED7F2F80 = (uint64_t)&unk_1E8134CD8;
  qword_1ED7F2F98 = (uint64_t)&qword_1ED7F2F80;
  sub_1C4EF6F18(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F2ED8);
}

unint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyWalk(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v5;
  unint64_t result;
  uint64_t *v7;
  unsigned int v8;
  llvm::Instruction *v9;
  int v10;
  unsigned int v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t **v14;
  unint64_t v15;
  BOOL v16;
  uint64_t **v17;
  uint64_t *v18;

  v18 = a2;
  v5 = a1[4];
  sub_1C47BC21C(a3, (unint64_t *)&v18, &v18);
  result = llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyBBInRegion(a1, (uint64_t)v18);
  v7 = (uint64_t *)v18[5];
  if (v7 != v18 + 5)
  {
    result = v7 ? (unint64_t)(v7 - 3) : 0;
    v8 = *(unsigned __int8 *)(result + 16) - 29;
    v9 = v8 >= 0xB ? 0 : (llvm::Instruction *)result;
    if (v8 <= 0xA)
    {
      result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)result);
      if ((_DWORD)result)
      {
        v10 = result;
        v11 = 0;
        v12 = a3 + 1;
        do
        {
          result = llvm::Instruction::getSuccessor(v9, v11);
          if (result != v5)
          {
            v13 = *v12;
            if (!*v12)
              goto LABEL_25;
            v14 = a3 + 1;
            do
            {
              v15 = v13[4];
              v16 = v15 >= result;
              if (v15 >= result)
                v17 = (uint64_t **)v13;
              else
                v17 = (uint64_t **)(v13 + 1);
              if (v16)
                v14 = (uint64_t **)v13;
              v13 = *v17;
            }
            while (*v17);
            if (v14 == v12 || result < (unint64_t)v14[4])
LABEL_25:
              result = llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyWalk(a1, result, a3);
          }
          ++v11;
        }
        while (v10 != v11);
      }
    }
  }
  return result;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE10verifyWalkEPNS_10BasicBlockEPNSt3__13setIS6_NS7_4lessIS6_EENS7_9allocatorIS6_EEEE(a1, a2, a3);
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegionNest(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;

  v2 = (uint64_t *)a1[5];
  v3 = (uint64_t *)a1[6];
  while (v2 != v3)
  {
    v4 = *v2++;
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegionNest(v4);
  }
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegion(a1);
}

{
  __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE16verifyRegionNestEv(a1);
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegion(uint64_t *a1)
{
  uint64_t *v1;
  _QWORD *v2[2];

  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::VerifyRegionInfo)
  {
    v2[0] = 0;
    v2[1] = 0;
    v1 = (uint64_t *)v2;
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyWalk(a1, (uint64_t *)(*a1 & 0xFFFFFFFFFFFFFFF8), &v1);
    sub_1C47655E8((uint64_t)&v1, v2[0]);
  }
}

{
  __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE12verifyRegionEv(a1);
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::replaceExit(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::replaceEntryRecursive(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;

  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = *a1;
  v11 = a1;
  v4 = sub_1C4DFEA3C((void **)&v12, &v11);
  v13 = v4;
  v5 = v12;
  if (v12 != v4)
  {
    v6 = v3 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v7 = (uint64_t *)*--v4;
      v13 = v4;
      *v7 = *v7 & 7 | a2;
      v8 = (_QWORD *)v7[5];
      v9 = (_QWORD *)v7[6];
      if (v8 != v9)
      {
        do
        {
          v10 = (_QWORD *)*v8;
          if ((*(_QWORD *)*v8 & 0xFFFFFFFFFFFFFFF8) == v6)
          {
            v11 = (_QWORD *)*v8;
            if ((unint64_t)v4 >= v14)
              v4 = sub_1C4DFEA3C((void **)&v12, &v11);
            else
              *v4++ = v10;
            v13 = v4;
          }
          ++v8;
        }
        while (v8 != v9);
        v5 = v12;
      }
    }
    while (v5 != v4);
  }
  if (v4)
  {
    v13 = v4;
    operator delete(v4);
  }
}

{
  __ZN4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE21replaceEntryRecursiveEPNS_10BasicBlockE(a1, a2);
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getDepth(uint64_t result)
{
  uint64_t v1;

  v1 = result;
  LODWORD(result) = -1;
  do
  {
    v1 = *(_QWORD *)(v1 + 8);
    result = (result + 1);
  }
  while (v1);
  return result;
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::getRegionFor(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v4 = 0;
  v5 = a2;
  v2 = sub_1C61252B8((uint64_t *)(a1 + 40), &v5, &v4);
  result = 0;
  if (v2)
    return *(_QWORD *)(v4 + 8);
  return result;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::isSimple(_QWORD *a1)
{
  uint64_t result;

  if (!a1[4])
    return 0;
  result = llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getEnteringBlock(a1);
  if (result)
    return llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getExitingBlock(a1) != 0;
  return result;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE8isSimpleEv(a1);
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::elements(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  _OWORD v8[4];
  uint64_t v9;
  void *__p;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  sub_1C4EFA0F0((uint64_t)&v13, a1);
  v4 = *a1 & 0xFFFFFFFFFFFFFFF8;
  if (!llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getSubRegionNode(a1, v4))
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode((uint64_t)a1, v4);
  v9 = 0;
  __p = 0;
  memset(v8, 0, sizeof(v8));
  v5 = (char *)v8 + 8;
  v6 = (char *)v8 + 8;
  v7 = 8;
  v11 = 0;
  v12 = 0;
  sub_1C61AE17C(a2, (uint64_t)&v13, (uint64_t)&v5);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  if (v6 != v5)
    free(v6);
  if (v15)
  {
    v16 = v15;
    operator delete(v15);
  }
  if (v14 != v13)
    free(v14);
}

{
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  _OWORD v8[4];
  uint64_t v9;
  void *__p;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  sub_1C4EFA010((uint64_t)&v13, a1);
  v4 = *a1 & 0xFFFFFFFFFFFFFFF8;
  if (!llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getSubRegionNode(a1, v4))
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode((uint64_t)a1, v4);
  v9 = 0;
  __p = 0;
  memset(v8, 0, sizeof(v8));
  v5 = (char *)v8 + 8;
  v6 = (char *)v8 + 8;
  v7 = 8;
  v11 = 0;
  v12 = 0;
  sub_1C61AE008((uint64_t)&v13, (uint64_t)&v5, a2);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  if (v6 != v5)
    free(v6);
  if (v15)
  {
    v16 = v15;
    operator delete(v15);
  }
  if (v14 != v13)
    free(v14);
}

{
  __ZN4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE8elementsEv(a1, a2);
}

{
  __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE8elementsEv(a1, a2);
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains(_QWORD *a1, _QWORD *a2)
{
  uint64_t result;

  if (a1[4])
  {
    result = llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains(a1, *a2 & 0xFFFFFFFFFFFFFFF8);
    if (!(_DWORD)result)
      return result;
    if (!llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains(a1, a2[4]))
      return a2[4] == a1[4];
  }
  return 1;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE8containsEPKNS_6RegionE(a1, a2);
}

uint64_t *llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode(uint64_t a1, unint64_t a2)
{
  _QWORD *v4;
  uint64_t **v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  uint64_t **v9;
  _QWORD *v10;
  uint64_t v11;
  __int128 v13;

  v4 = *(_QWORD **)(a1 + 72);
  if (!v4)
    goto LABEL_12;
  v5 = (uint64_t **)(a1 + 72);
  do
  {
    v6 = v4[4];
    v7 = v6 >= a2;
    if (v6 >= a2)
      v8 = v4;
    else
      v8 = v4 + 1;
    if (v7)
      v5 = (uint64_t **)v4;
    v4 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v5 == (uint64_t **)(a1 + 72) || (unint64_t)v5[4] > a2)
  {
LABEL_12:
    v9 = (uint64_t **)(a1 + 64);
    v10 = (_QWORD *)operator new();
    *v10 = a2 & 0xFFFFFFFFFFFFFFFBLL;
    v10[1] = a1;
    *(_QWORD *)&v13 = a2;
    *((_QWORD *)&v13 + 1) = v10;
    v5 = sub_1C4EFBDA0(v9, (unint64_t *)&v13, &v13);
    v11 = *((_QWORD *)&v13 + 1);
    *((_QWORD *)&v13 + 1) = 0;
    if (v11)
      MEMORY[0x1CAA32FC0](v11, 0x1020C405730B0C9);
  }
  return v5[5];
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE9getBBNodeEPNS_10BasicBlockE(a1, a2);
}

_QWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::setRegionFor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v5;

  v5 = a2;
  result = sub_1C6180A54(a1 + 40, &v5);
  result[1] = a3;
  return result;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::clearNodeCache(uint64_t a1)
{
  _QWORD *v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;

  v1 = (_QWORD *)(a1 + 72);
  sub_1C61AF404(a1 + 64, *(_QWORD **)(a1 + 72));
  *(v1 - 1) = v1;
  *v1 = 0;
  v1[1] = 0;
  v3 = (uint64_t *)*(v1 - 4);
  v2 = (uint64_t *)*(v1 - 3);
  while (v3 != v2)
  {
    v4 = *v3++;
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::clearNodeCache(v4);
  }
}

{
  __ZN4llvm10RegionBaseINS_12RegionTraitsINS_8FunctionEEEE14clearNodeCacheEv(a1);
}

void sub_1C61AE008(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  const void *v6;
  const void *v7;
  uint64_t v8;
  const void *v9;
  const void *v10;
  uint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  int v14;
  int v15;
  int v16;
  _BYTE v17[64];
  void *__p[2];
  uint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  int v22;
  int v23;
  int v24;
  _BYTE v25[64];
  void *v26[2];
  uint64_t v27;

  v20 = v25;
  v7 = *(const void **)a1;
  v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    v21 = v25;
    v8 = *(unsigned int *)(a1 + 20);
    if ((_DWORD)v8)
      memmove(v25, v6, 8 * v8);
  }
  else
  {
    v21 = *(_BYTE **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  v22 = *(_DWORD *)(a1 + 16);
  v23 = v8;
  v24 = *(_DWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_OWORD *)v26 = *(_OWORD *)(a1 + 96);
  v27 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v12 = v17;
  v10 = *(const void **)a2;
  v9 = *(const void **)(a2 + 8);
  if (v9 == *(const void **)a2)
  {
    v13 = v17;
    v11 = *(unsigned int *)(a2 + 20);
    if ((_DWORD)v11)
      memmove(v17, v9, 8 * v11);
  }
  else
  {
    v13 = *(_BYTE **)(a2 + 8);
    *(_QWORD *)(a2 + 8) = v10;
    LODWORD(v11) = *(_DWORD *)(a2 + 20);
  }
  v14 = *(_DWORD *)(a2 + 16);
  v15 = v11;
  v16 = *(_DWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  *(_OWORD *)__p = *(_OWORD *)(a2 + 96);
  v19 = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  sub_1C6187DA4(a3, (uint64_t)&v20, (uint64_t)&v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v13 != v12)
    free(v13);
  if (v26[0])
  {
    v26[1] = v26[0];
    operator delete(v26[0]);
  }
  if (v21 != v20)
    free(v21);
}

void sub_1C61AE17C(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  const void *v7;
  uint64_t v8;
  const void *v9;
  const void *v10;
  uint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  int v14;
  int v15;
  int v16;
  _BYTE v17[64];
  void *__p[2];
  uint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  int v22;
  int v23;
  int v24;
  _BYTE v25[64];
  void *v26[2];
  uint64_t v27;

  v20 = v25;
  v6 = *(const void **)(a2 + 8);
  v7 = *(const void **)a2;
  if (v6 == *(const void **)a2)
  {
    v21 = v25;
    v8 = *(unsigned int *)(a2 + 20);
    if ((_DWORD)v8)
      memmove(v25, v6, 8 * v8);
  }
  else
  {
    v21 = v6;
    *(_QWORD *)(a2 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a2 + 20);
  }
  v22 = *(_DWORD *)(a2 + 16);
  v23 = v8;
  v24 = *(_DWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  *(_OWORD *)v26 = *(_OWORD *)(a2 + 96);
  v27 = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  v12 = v17;
  v10 = *(const void **)a3;
  v9 = *(const void **)(a3 + 8);
  if (v9 == *(const void **)a3)
  {
    v13 = v17;
    v11 = *(unsigned int *)(a3 + 20);
    if ((_DWORD)v11)
      memmove(v17, v9, 8 * v11);
  }
  else
  {
    v13 = *(_BYTE **)(a3 + 8);
    *(_QWORD *)(a3 + 8) = v10;
    LODWORD(v11) = *(_DWORD *)(a3 + 20);
  }
  v14 = *(_DWORD *)(a3 + 16);
  v15 = v11;
  v16 = *(_DWORD *)(a3 + 24);
  *(_QWORD *)(a3 + 16) = 8;
  *(_DWORD *)(a3 + 24) = 0;
  *(_OWORD *)__p = *(_OWORD *)(a3 + 96);
  v19 = *(_QWORD *)(a3 + 112);
  *(_QWORD *)(a3 + 96) = 0;
  *(_QWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 112) = 0;
  sub_1C6187DA4(a1, (uint64_t)&v20, (uint64_t)&v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v13 != v12)
    free(v13);
  if (v26[0])
  {
    v26[1] = v26[0];
    operator delete(v26[0]);
  }
  if (v21 != v20)
    free(v21);
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::RegionInfoBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = &unk_1E813A6C8;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = v4;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 48) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a2 + 52) = v4;
  LODWORD(v4) = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a2 + 56) = v4;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  sub_1C6125098((_DWORD *)(a2 + 40));
  return a1;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEEC2EOS4_(a1, a2);
}

_QWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::~RegionInfoBase(_QWORD *a1)
{
  *a1 = &unk_1E813A6C8;
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::releaseMemory((uint64_t)a1);
  MEMORY[0x1CAA32FB4](a1[5], 8);
  return a1;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEED2Ev(a1);
}

_DWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::releaseMemory(uint64_t a1)
{
  _DWORD *result;
  uint64_t v3;
  void **v4;

  result = sub_1C6125098((_DWORD *)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    sub_1C61AF404(v3 + 64, *(_QWORD **)(v3 + 72));
    *(_QWORD *)(v3 + 64) = v3 + 72;
    *(_QWORD *)(v3 + 80) = 0;
    *(_QWORD *)(v3 + 72) = 0;
    v4 = (void **)(v3 + 40);
    sub_1C4EFB84C(&v4);
    result = (_DWORD *)MEMORY[0x1CAA32FC0](v3, 0x1020C406A19994FLL);
  }
  *(_QWORD *)(a1 + 32) = 0;
  return result;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEE13releaseMemoryEv(a1);
}

_QWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::insertShortCut(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = a3;
  v7 = a2;
  v8 = a3;
  v9 = 0;
  if (sub_1C61252B8((uint64_t *)a4, &v8, &v9) && v9 != *(_QWORD *)a4 + 16 * *(unsigned int *)(a4 + 16))
    v5 = *(_QWORD *)(v9 + 8);
  result = sub_1C4E5D0EC((uint64_t *)a4, &v7);
  result[1] = v5;
  return result;
}

{
  return __ZNK4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEE14insertShortCutEPNS_10BasicBlockES6_PNS_8DenseMapIS6_S6_NS_12DenseMapInfoIS6_vEENS_6detail12DenseMapPairIS6_S6_EEEE(a1, a2, a3, a4);
}

BOOL llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::isTrivialRegion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  llvm::Instruction *v5;
  llvm::Instruction *v6;
  unsigned __int8 *v7;
  unsigned int NumSuccessors;

  v4 = *(_QWORD *)(a2 + 40);
  if (v4 == a2 + 40)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = (llvm::Instruction *)(v4 - 24);
    if (v4)
      v7 = (unsigned __int8 *)(v4 - 24);
    else
      v7 = 0;
    if (v7[16] - 29 <= 0xA)
    {
      NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v7);
      v5 = v6;
      if (NumSuccessors > 1)
        return 0;
    }
  }
  return llvm::Instruction::getSuccessor(v5, 0) == a3;
}

{
  return __ZNK4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEE15isTrivialRegionEPNS_10BasicBlockES6_(a1, a2, a3);
}

_QWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::createRegion(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v8;
  _BYTE v9[24];
  uint64_t v10;
  _QWORD *v11;

  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::isTrivialRegion((uint64_t)a1, a2, a3))
    return 0;
  v6 = (_QWORD *)operator new();
  v8 = a1[1];
  *v6 = a2 | 4;
  v6[1] = 0;
  v6[2] = a1;
  v6[3] = v8;
  v6[4] = a3;
  v6[5] = 0;
  v6[6] = 0;
  v6[7] = 0;
  v6[10] = 0;
  v6[9] = 0;
  v6[8] = v6 + 9;
  v10 = a2;
  v11 = v6;
  sub_1C6187718((uint64_t)v9, (uint64_t)(a1 + 5), &v10, &v11);
  (*(void (**)(_QWORD *, _QWORD *))(*a1 + 16))(a1, v6);
  return v6;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEE12createRegionEPNS_10BasicBlockES6_(a1, a2, a3);
}

void sub_1C61AE614(uint64_t a1, uint64_t a2)
{
  char *v3;
  char *v4;
  uint64_t v5;
  _OWORD v6[4];
  void *v7[2];
  _OWORD v8[8];
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  _QWORD v13[17];

  v13[16] = *MEMORY[0x1E0C80C00];
  sub_1C4EB6E94((uint64_t)&v10, a2);
  v7[0] = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  memset(v6, 0, sizeof(v6));
  v3 = (char *)v6 + 8;
  v4 = (char *)v6 + 8;
  v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  sub_1C61AF830(a1, (uint64_t)&v10, (uint64_t)&v3);
  if (v7[1] != (char *)v8 + 8)
    free(v7[1]);
  if (v4 != v3)
    free(v4);
  if (v12 != v13)
    free(v12);
  if (v11 != v10)
    free(v11);
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::buildRegionsTree(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t **v3;
  uint64_t v6;
  uint64_t *i;
  uint64_t **v8;
  uint64_t **v9;
  uint64_t **v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = a3;
  v6 = *(_QWORD *)a2;
  v15 = *(_QWORD *)a2;
  for (i = a3[4]; (uint64_t *)v6 == i; i = v3[4])
    v3 = (uint64_t **)v3[1];
  v16 = v6;
  v17 = 0;
  if (!sub_1C61252B8((uint64_t *)(a1 + 40), &v16, &v17)
    || v17 == *(_QWORD *)(a1 + 40) + 16 * *(unsigned int *)(a1 + 56))
  {
    sub_1C6180A54(a1 + 40, &v15)[1] = v3;
  }
  else
  {
    v8 = *(uint64_t ***)(v17 + 8);
    v9 = v8;
    do
    {
      v10 = v9;
      v9 = (uint64_t **)v9[1];
    }
    while (v9);
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::addSubRegion(v3, v10, 0);
    v3 = v8;
  }
  v11 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v11)
  {
    v12 = *(uint64_t **)(a2 + 24);
    v13 = 8 * v11;
    do
    {
      v14 = *v12++;
      llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::buildRegionsTree(a1, v14, v3);
      v13 -= 8;
    }
    while (v13);
  }
}

{
  __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEE16buildRegionsTreeEPNS_15DomTreeNodeBaseINS_10BasicBlockEEEPNS_6RegionE(a1, a2, a3);
}

llvm::raw_ostream *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::dump(llvm *a1)
{
  llvm *v2;

  v2 = llvm::dbgs(a1);
  sub_1C4816AD8(v2, "Region tree:\n");
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::print(*((_QWORD **)a1 + 4), v2, 1, 0, llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::printStyle);
  return sub_1C4816AD8(v2, "End region tree\n");
}

{
  return __ZNK4llvm14RegionInfoBaseINS_12RegionTraitsINS_8FunctionEEEE4dumpEv(a1);
}

void llvm::RegionInfo::~RegionInfo(llvm::RegionInfo *this)
{
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::~RegionInfoBase(this);
  JUMPOUT(0x1CAA32FC0);
}

BOOL llvm::RegionInfo::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  _QWORD v8[2];
  BOOL v9;

  v8[0] = a3;
  v8[1] = &llvm::RegionInfoAnalysis::Key;
  v4 = sub_1C477672C(a3 + 48, (uint64_t)&llvm::RegionInfoAnalysis::Key);
  v5 = *(_QWORD *)(a3 + 56);
  if (v5 == *(_QWORD *)(a3 + 48))
    v6 = (unsigned int *)(a3 + 68);
  else
    v6 = (unsigned int *)(a3 + 64);
  v9 = v4 != (_QWORD *)(v5 + 8 * *v6);
  return !sub_1C4DAA35C((uint64_t)v8) && !sub_1C4DAA3F8((uint64_t)v8) && !sub_1C4DAA49C((uint64_t)v8);
}

void llvm::RegionInfo::updateStatistics(llvm::RegionInfo *this, llvm::Region *a2)
{
  if (*((_QWORD *)a2 + 4))
  {
    if (llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getEnteringBlock(a2))
      llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getExitingBlock(a2);
  }
}

uint64_t llvm::RegionInfo::recalculate(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;

  a1[1] = a3;
  a1[2] = a4;
  a1[3] = a5;
  v7 = operator new();
  v8 = *(_QWORD *)(a2 + 80);
  v9 = v8 - 24;
  v10 = v8 == 0;
  v11 = a1[1];
  if (v10)
    v9 = 0;
  *(_QWORD *)v7 = v9 | 4;
  *(_QWORD *)(v7 + 8) = 0;
  *(_QWORD *)(v7 + 16) = a1;
  *(_QWORD *)(v7 + 24) = v11;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 48) = 0u;
  *(_QWORD *)(v7 + 80) = 0;
  *(_QWORD *)(v7 + 72) = 0;
  *(_QWORD *)(v7 + 64) = v7 + 72;
  a1[4] = v7;
  return llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::calculate((uint64_t)a1, a2);
}

llvm::RegionInfoPass *llvm::RegionInfoPass::RegionInfoPass(llvm::RegionInfoPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::RegionInfoPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E813A718;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_QWORD *)this + 4) = &off_1E813A6F0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EA68);
  if (v2 != -1)
  {
    v6[0] = sub_1C4EFB67C;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EA68, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeRegionInfoPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82EA68);
  if (v2 != -1)
  {
    v5[0] = sub_1C4EFB67C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82EA68, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::RegionInfoPass::runOnFunction(char ****this, llvm::Function *a2)
{
  char **v4;
  char *v5;
  uint64_t v6;
  char **v7;
  char *v8;
  uint64_t v9;
  void **v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  ((void (*)(char ****))(*this)[11])(this);
  v4 = *this[1];
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != llvm::DominatorTreeWrapperPass::ID);
  v6 = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), llvm::DominatorTreeWrapperPass::ID);
  v7 = *this[1];
  do
  {
    v8 = *v7;
    v7 += 2;
  }
  while (v8 != llvm::PostDominatorTreeWrapperPass::ID);
  v9 = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v7 - 1) + 96))(*(v7 - 1), llvm::PostDominatorTreeWrapperPass::ID);
  v10 = (void **)*this[1];
  do
  {
    v11 = *v10;
    v10 += 2;
  }
  while (v11 != &llvm::DominanceFrontierWrapperPass::ID);
  v12 = v9 + 32;
  v13 = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v10 - 1) + 96))(*(v10 - 1), &llvm::DominanceFrontierWrapperPass::ID);
  llvm::RegionInfo::recalculate(this + 4, (uint64_t)a2, v6 + 32, v12, v13 + 32);
  return 0;
}

_DWORD *llvm::RegionInfoPass::releaseMemory(llvm::RegionInfoPass *this)
{
  return llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::releaseMemory((uint64_t)this + 32);
}

void llvm::RegionInfoPass::verifyAnalysis(uint64_t **this)
{
  char *v2;

  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::VerifyRegionInfo)
  {
    v2 = (char *)(this + 4);
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegionNest(this[8]);
    llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::verifyBBMap((uint64_t)v2, this[8]);
  }
}

llvm::AnalysisUsage *llvm::RegionInfoPass::getAnalysisUsage(llvm::RegionInfoPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::DominatorTreeWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::PostDominatorTreeWrapperPass::ID);
  return llvm::AnalysisUsage::addRequiredID(a2, llvm::DominanceFrontierWrapperPass::ID);
}

llvm::raw_ostream *llvm::RegionInfoPass::print(llvm::RegionInfoPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  sub_1C4816AD8(a2, "Region tree:\n");
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::print(*((_QWORD **)this + 8), a2, 1, 0, llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::printStyle);
  return sub_1C4816AD8(a2, "End region tree\n");
}

llvm::raw_ostream *llvm::RegionInfoPass::dump(llvm::RegionInfoPass *this)
{
  return llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::dump((llvm::RegionInfoPass *)((char *)this + 32));
}

llvm::RegionInfoPass *llvm::createRegionInfoPass(llvm *this)
{
  llvm::RegionInfoPass *v1;

  v1 = (llvm::RegionInfoPass *)operator new();
  return llvm::RegionInfoPass::RegionInfoPass(v1);
}

uint64_t llvm::RegionInfoAnalysis::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_QWORD *)a3 = &off_1E813A6F0;
  v6 = llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::DominatorTreeAnalysis::Key, a1) + 8;
  v7 = llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::PostDominatorTreeAnalysis::Key, a1) + 8;
  v8 = llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::DominanceFrontierAnalysis::Key, a1) + 8;
  return llvm::RegionInfo::recalculate((_QWORD *)a3, a1, v6, v7, v8);
}

_QWORD *llvm::RegionInfoPrinterPass::RegionInfoPrinterPass(_QWORD *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

_QWORD *llvm::RegionInfoPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, llvm::Value *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  llvm::raw_ostream *v8;
  size_t v9;
  char *Name;
  size_t v11;
  void *v12;
  uint64_t ResultImpl;
  llvm::raw_ostream *v14;

  v8 = sub_1C4816AD8(*a1, "Region Tree for function: ");
  Name = llvm::Value::getName(a2);
  v11 = v9;
  v12 = (void *)*((_QWORD *)v8 + 4);
  if (v9 <= *((_QWORD *)v8 + 3) - (_QWORD)v12)
  {
    if (v9)
    {
      memcpy(v12, Name, v9);
      *((_QWORD *)v8 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, Name, v9);
  }
  sub_1C4816AD8(v8, "\n");
  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::RegionInfoAnalysis::Key, (uint64_t)a2);
  v14 = *a1;
  sub_1C4816AD8(v14, "Region tree:\n");
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::print(*(_QWORD **)(ResultImpl + 40), v14, 1, 0, llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::printStyle);
  sub_1C4816AD8(v14, "End region tree\n");
  return llvm::InstCountPass::run(a4);
}

_QWORD *llvm::RegionInfoVerifierPass::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t ResultImpl;
  uint64_t v6;
  uint64_t v7;

  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::RegionInfoAnalysis::Key, a1);
  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::VerifyRegionInfo)
  {
    v6 = ResultImpl;
    v7 = ResultImpl + 8;
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegionNest(*(uint64_t **)(ResultImpl + 40));
    llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::verifyBBMap(v7, *(_QWORD **)(v6 + 40));
  }
  return llvm::InstCountPass::run(a3);
}

uint64_t sub_1C61AEFB4(uint64_t a1, uint64_t a2)
{
  void **v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  char *v8;
  _OWORD v10[2];
  uint64_t v11;

  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 32;
  *(_QWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v4 = (void **)(a1 + 96);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)a1, a2);
  *(_QWORD *)&v10[0] = a2;
  BYTE8(v10[0]) = 0;
  LOBYTE(v11) = 0;
  v5 = *(_QWORD *)(a1 + 104);
  if (v5 >= *(_QWORD *)(a1 + 112))
  {
    v8 = sub_1C4EFB72C(v4, (uint64_t)v10);
  }
  else
  {
    v6 = v10[0];
    v7 = v10[1];
    *(_QWORD *)(v5 + 32) = v11;
    *(_OWORD *)v5 = v6;
    *(_OWORD *)(v5 + 16) = v7;
    v8 = (char *)(v5 + 40);
  }
  *(_QWORD *)(a1 + 104) = v8;
  return a1;
}

uint64_t sub_1C61AF054(uint64_t a1, uint64_t a2)
{
  void **v4;
  unint64_t v5;
  __int128 v6;
  char *v7;
  _OWORD v9[2];
  uint64_t v10;

  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 32;
  *(_QWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v4 = (void **)(a1 + 96);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)a1, a2);
  *(_QWORD *)&v9[0] = a2;
  BYTE8(v9[0]) = 0;
  LOBYTE(v10) = 0;
  v5 = *(_QWORD *)(a1 + 104);
  if (v5 >= *(_QWORD *)(a1 + 112))
  {
    v7 = sub_1C4EFB72C(v4, (uint64_t)v9);
  }
  else
  {
    v6 = v9[1];
    *(_OWORD *)v5 = v9[0];
    *(_OWORD *)(v5 + 16) = v6;
    *(_QWORD *)(v5 + 32) = v10;
    v7 = (char *)(v5 + 40);
  }
  *(_QWORD *)(a1 + 104) = v7;
  return a1;
}

_QWORD *sub_1C61AF0F4(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  *a1 = off_1E813A7B8;
  v2 = a1 + 71;
  v3 = (_QWORD *)a1[74];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
LABEL_3:
    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_4;
  }
  if (v3)
  {
    v4 = 5;
    goto LABEL_3;
  }
LABEL_4:
  a1[19] = &off_1E813A820;
  v5 = (_QWORD *)a1[21];
  if (v5 != a1 + 23)
    free(v5);
  return sub_1C47A80D0(a1);
}

_QWORD *sub_1C61AF174(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E813A820;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

uint64_t sub_1C61AF1B4(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int v12;

  v12 = 0;
  v8 = sub_1C6159B48(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v12);
  if ((v8 & 1) != 0)
    return v8;
  **(_DWORD **)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C61AF230(v11);
}

uint64_t sub_1C61AF230(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 160) + 24))
    return 2;
  else
    return 3;
}

void sub_1C61AF248(_QWORD *a1)
{
  sub_1C61AF0F4(a1);
  JUMPOUT(0x1CAA32FC0);
}

unint64_t sub_1C61AF26C(uint64_t a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth(a1 + 152, a1);
}

uint64_t sub_1C61AF278(uint64_t a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::generic_parser_base *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C61AF288(llvm::raw_ostream *result, int a2, int a3)
{
  int v3;
  uint64_t (**v4)();
  int v5;
  char v6;

  if (a3)
  {
    v3 = **((_DWORD **)result + 16);
LABEL_3:
    v4 = &off_1E813A870;
    v6 = 1;
    v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((_BYTE *)result + 148))
  {
    v3 = **((_DWORD **)result + 16);
    if (*((_DWORD *)result + 36) != v3)
      goto LABEL_3;
  }
  return result;
}

uint64_t sub_1C61AF2FC(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 148);
  if (*(_BYTE *)(result + 148))
    v1 = *(_DWORD *)(result + 144);
  **(_DWORD **)(result + 128) = v1;
  return result;
}

_QWORD *sub_1C61AF314(uint64_t a1, uint64_t a2)
{
  return sub_1C4B03438((_QWORD *)(a1 + 152), a2);
}

void sub_1C61AF31C(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E813A820;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61AF36C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1C61AF374(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1C61AF388(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1C61AF39C(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1C61AF3B0(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 12) && *(_BYTE *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

llvm::RegionInfoPass *llvm::callDefaultCtor<llvm::RegionInfoPass>()
{
  llvm::RegionInfoPass *v0;

  v0 = (llvm::RegionInfoPass *)operator new();
  return llvm::RegionInfoPass::RegionInfoPass(v0);
}

void sub_1C61AF404(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;

  if (a2)
  {
    sub_1C61AF404(a1, *a2);
    sub_1C61AF404(a1, a2[1]);
    v4 = a2[5];
    a2[5] = 0;
    if (v4)
      MEMORY[0x1CAA32FC0](v4, 0x1020C405730B0C9);
    operator delete(a2);
  }
}

_OWORD *sub_1C61AF464(void **a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  unsigned __int8 *v7;
  _OWORD *result;
  int v9;
  llvm::Instruction *v10;
  unsigned int v11;
  uint64_t Successor;
  char v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v2 = a1 + 12;
  v3 = (uint64_t)a1[13];
  while (2)
  {
    v4 = *(_QWORD *)(v3 - 32);
    if (!*(_BYTE *)(v3 - 8))
    {
      v15 = *(_QWORD *)(v4 + 40);
      if (v15 == v4 + 40)
      {
        v16 = 0;
      }
      else
      {
        if (v15)
          v16 = v15 - 24;
        else
          v16 = 0;
        if (*(unsigned __int8 *)(v16 + 16) - 29 >= 0xB)
          v16 = 0;
      }
      *(_QWORD *)(v3 - 24) = v16;
      *(_QWORD *)(v3 - 16) = 0;
      *(_BYTE *)(v3 - 8) = 1;
    }
    v5 = (_QWORD *)(v4 + 40);
    while (1)
    {
      v6 = (_QWORD *)*v5;
      if ((_QWORD *)*v5 == v5
        || (v6 ? (v7 = (unsigned __int8 *)(v6 - 3)) : (v7 = 0), v7[16] - 29 > 0xA))
      {
        result = 0;
      }
      else
      {
        result = (_OWORD *)llvm::Instruction::getNumSuccessors((llvm::Instruction *)v7);
      }
      v9 = *(_DWORD *)(v3 - 16);
      if (v9 == (_DWORD)result)
        break;
      v10 = *(llvm::Instruction **)(v3 - 24);
      v11 = *(_DWORD *)(v3 - 16);
      *(_DWORD *)(v3 - 16) = v9 + 1;
      Successor = llvm::Instruction::getSuccessor(v10, v11);
      sub_1C4774094((llvm::SmallPtrSetImplBase *)a1, Successor);
      if (v13)
      {
        *(_QWORD *)&v19 = Successor;
        BYTE8(v19) = 0;
        BYTE8(v20) = 0;
        v17 = a1[13];
        if (v17 >= a1[14])
        {
          result = sub_1C4DD17E8(v2, &v19);
        }
        else
        {
          v18 = v20;
          *v17 = v19;
          v17[1] = v18;
          result = v17 + 2;
        }
        a1[13] = result;
        return result;
      }
    }
    v14 = a1[12];
    v3 = (uint64_t)a1[13] - 32;
    a1[13] = (void *)v3;
    if (v14 != (void *)v3)
      continue;
    break;
  }
  return result;
}

unint64_t *sub_1C61AF5B4(unint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  unsigned __int8 *v7;
  llvm::Instruction *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unint64_t v15;
  int i;
  int v17;

  v3 = *(_QWORD *)a2;
  v4 = (*(_QWORD *)a2 >> 1) & 2;
  *a1 = v4 | a2 & 0xFFFFFFFFFFFFFFF9;
  v6 = (_QWORD *)((v3 & 0xFFFFFFFFFFFFFFF8) + 40);
  v5 = (_QWORD *)*v6;
  if ((_QWORD *)*v6 == v6)
  {
    v8 = 0;
  }
  else
  {
    if (v5)
      v7 = (unsigned __int8 *)(v5 - 3);
    else
      v7 = 0;
    if (v7[16] - 29 >= 0xB)
      v8 = 0;
    else
      v8 = (llvm::Instruction *)v7;
  }
  a1[1] = (unint64_t)v8;
  a1[2] = 0;
  if (v4)
  {
    if (*(_QWORD *)(*(_QWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 8) + 32) == *(_QWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 32))
      *a1 = a2 & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  else
  {
    v9 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFF8;
    v12 = *(_QWORD *)(v9 + 40);
    v10 = v9 + 40;
    v11 = v12;
    v13 = (unsigned __int8 *)(v12 - 24);
    if (v12)
      v14 = v13;
    else
      v14 = 0;
    v15 = a2 & 0xFFFFFFFFFFFFFFF8;
    for (i = 1; ; ++i)
    {
      v17 = v11 == v10 || v14[16] - 29 > 0xA
          ? 0
          : llvm::Instruction::getNumSuccessors((llvm::Instruction *)v14);
      if (i - 1 == v17 || *(_QWORD *)(*(_QWORD *)(v15 + 8) + 32) != llvm::Instruction::getSuccessor(v8, i - 1))
        break;
      *((_DWORD *)a1 + 4) = i;
    }
  }
  return a1;
}

unint64_t *sub_1C61AF6D8(unint64_t *a1)
{
  unint64_t v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned int v11;
  int NumSuccessors;
  uint64_t Successor;

  v2 = *a1;
  if ((*a1 & 6) != 0)
  {
    *a1 = v2 & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  else
  {
    v4 = v2 & 0xFFFFFFFFFFFFFFF8;
    v5 = *(_QWORD *)(v2 & 0xFFFFFFFFFFFFFFF8) & 0xFFFFFFFFFFFFFFF8;
    v8 = *(_QWORD *)(v5 + 40);
    v6 = v5 + 40;
    v7 = v8;
    v9 = (unsigned __int8 *)(v8 - 24);
    if (v8)
      v10 = v9;
    else
      v10 = 0;
    v11 = *((_DWORD *)a1 + 4) + 1;
    do
    {
      *((_DWORD *)a1 + 4) = v11;
      if (v7 == v6 || v10[16] - 29 > 0xA)
        NumSuccessors = 0;
      else
        NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v10);
      if (v11 == NumSuccessors)
        break;
      Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)a1[1], v11++);
    }
    while (*(_QWORD *)(*(_QWORD *)(v4 + 8) + 32) == Successor);
  }
  return a1;
}

uint64_t sub_1C61AF79C(uint64_t a1, uint64_t a2)
{
  void **v4;
  _OWORD *v5;
  __int128 v6;
  _OWORD *v7;
  __int128 v9;
  __int128 v10;

  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 32;
  *(_QWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v4 = (void **)(a1 + 96);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)a1, a2);
  *(_QWORD *)&v9 = a2;
  BYTE8(v9) = 0;
  BYTE8(v10) = 0;
  v5 = *(_OWORD **)(a1 + 104);
  if ((unint64_t)v5 >= *(_QWORD *)(a1 + 112))
  {
    v7 = sub_1C4DD17E8(v4, &v9);
  }
  else
  {
    v6 = v10;
    *v5 = v9;
    v5[1] = v6;
    v7 = v5 + 2;
  }
  *(_QWORD *)(a1 + 104) = v7;
  return a1;
}

void sub_1C61AF830(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  _QWORD v12[17];

  v12[16] = *MEMORY[0x1E0C80C00];
  sub_1C61AF908((uint64_t)&v9, a2);
  sub_1C61AF908((uint64_t)&v5, a3);
  sub_1C61AF908(a1, (uint64_t)&v9);
  sub_1C61AF908(a1 + 240, (uint64_t)&v5);
  if (v7 != &v8)
    free(v7);
  if (v6 != v5)
    free(v6);
  if (v11 != v12)
    free(v11);
  if (v10 != v9)
    free(v10);
}

uint64_t sub_1C61AF908(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a1, (void *)(a1 + 32), 8, (uint64_t *)a2);
  *(_QWORD *)(v4 + 96) = v4 + 112;
  v5 = v4 + 96;
  *(_QWORD *)(v5 + 8) = 0x800000000;
  if (*(_DWORD *)(a2 + 104))
    sub_1C486F510(v5, a2 + 96);
  return a1;
}

const void **sub_1C61AF960(const void **a1, llvm::SmallPtrSetImplBase *a2)
{
  llvm::SmallPtrSetImplBase *v4;
  uint64_t v5;

  v4 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)a1, a1 + 4, a2);
  *((_QWORD *)v4 + 12) = (char *)v4 + 112;
  v5 = (uint64_t)v4 + 96;
  *(_QWORD *)(v5 + 8) = 0x800000000;
  if (*((_DWORD *)a2 + 26))
    sub_1C49DA288(v5, (uint64_t)a2 + 96);
  return a1;
}

void sub_1C61AF9B4(_BYTE **a1, __int128 *a2)
{
  uint64_t v4;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F2FA0, 0, 0);
  qword_1ED7F3020 = 0;
  byte_1ED7F3031 = 0;
  qword_1ED7F3028 = (uint64_t)&off_1E7F9E8D8;
  qword_1ED7F2FA0 = (uint64_t)&unk_1E8138EB8;
  qword_1ED7F3038 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F3040 = (uint64_t)&unk_1E8138F20;
  qword_1ED7F3058 = (uint64_t)&qword_1ED7F3040;
  llvm::cl::Option::setArgStr(v4, "verify-region-info", 0x12uLL);
  sub_1C4EB7838((llvm *)&qword_1ED7F3020, &qword_1ED7F2FA0, *a1);
  xmmword_1ED7F2FC0 = *a2;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F2FA0);
}

void sub_1C61AFA74(llvm **a1, _WORD *a2, __int128 *a3, uint64_t a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F3060, 0, 0);
  byte_1ED7F30F4 = 0;
  qword_1ED7F30E0 = 0;
  unk_1ED7F30E8 = &off_1E813A870;
  qword_1ED7F3060 = (uint64_t)off_1E813A7B8;
  qword_1ED7F30F8 = (uint64_t)&off_1E813A820;
  qword_1ED7F3100 = (uint64_t)&qword_1ED7F3060;
  qword_1ED7F3108 = (uint64_t)&unk_1ED7F3118;
  qword_1ED7F3110 = 0x800000000;
  qword_1ED7F3298 = (uint64_t)&off_1E813A8B0;
  qword_1ED7F32B0 = (uint64_t)&qword_1ED7F3298;
  sub_1C61AFB2C(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F3060);
}

void sub_1C61AFB2C(llvm **a1, _WORD *a2, __int128 *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F3060, "print-region-style", 0x12uLL);
  sub_1C61AFC08(*a1);
  word_1ED7F306A = (32 * (*a2 & 3)) | word_1ED7F306A & 0xFF9F;
  xmmword_1ED7F3080 = *a3;
  sub_1C4EFC680(*(_QWORD *)a4, *(_DWORD *)(a4 + 8));
}

void sub_1C61AFBB4()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61AFBC8()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E813A8B0;
  return result;
}

void sub_1C61AFBEC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E813A8B0;
}

llvm *sub_1C61AFC08(llvm *result)
{
  llvm::raw_ostream *v1;
  const char *v2;
  __int16 v3;

  if (qword_1ED7F30E0)
  {
    v2 = "cl::location(x) specified more than once!";
    v3 = 259;
    v1 = (llvm::raw_ostream *)llvm::errs(result);
    return (llvm *)llvm::cl::Option::error(&qword_1ED7F3060, (llvm::Twine *)&v2, 0, 0, v1);
  }
  else
  {
    qword_1ED7F30E0 = (uint64_t)result;
    byte_1ED7F30F4 = 1;
    dword_1ED7F30F0 = *(_DWORD *)result;
  }
  return result;
}

void sub_1C61AFC80(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  char v10;
  _QWORD v11[5];
  int v12;
  char v13;

  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  v11[3] = a5;
  v11[4] = &off_1E813A870;
  v13 = 1;
  v12 = a3;
  v7 = sub_1C4EFC6C4((unint64_t)v11);
  v8 = qword_1ED7F3108 + 48 * qword_1ED7F3110;
  v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(_QWORD *)(v8 + 32) = &off_1E813A890;
  v10 = *(_BYTE *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(_BYTE *)(v8 + 44) = v10;
  *(_QWORD *)(v8 + 32) = &off_1E813A870;
  LODWORD(qword_1ED7F3110) = qword_1ED7F3110 + 1;
  llvm::cl::AddLiteralOption(qword_1ED7F3100, a1, a2);
}

void sub_1C61AFD34(unint64_t a1)
{
  _OWORD *v1;
  _OWORD *v2;
  uint64_t v3;
  _OWORD *v4;
  __int128 v5;
  int v6;
  int v7;
  unint64_t v8;

  v8 = 0;
  v1 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)&qword_1ED7F3108, a1, 48, &v8);
  v2 = (_OWORD *)qword_1ED7F3108;
  if ((_DWORD)qword_1ED7F3110)
  {
    v3 = qword_1ED7F3108 + 48 * qword_1ED7F3110;
    v4 = v1;
    do
    {
      v5 = v2[1];
      *v4 = *v2;
      v4[1] = v5;
      *((_QWORD *)v4 + 4) = &off_1E813A890;
      v6 = *((_DWORD *)v2 + 10);
      *((_BYTE *)v4 + 44) = *((_BYTE *)v2 + 44);
      *((_DWORD *)v4 + 10) = v6;
      *((_QWORD *)v4 + 4) = &off_1E813A870;
      v2 += 3;
      v4 += 3;
    }
    while (v2 != (_OWORD *)v3);
    v2 = (_OWORD *)qword_1ED7F3108;
  }
  v7 = v8;
  if (v2 != (_OWORD *)&unk_1ED7F3118)
    free(v2);
  qword_1ED7F3108 = (uint64_t)v1;
  HIDWORD(qword_1ED7F3110) = v7;
}

llvm::AnalysisUsage *llvm::RGPassManager::getAnalysisUsage(llvm::RGPassManager *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage *result;

  result = llvm::AnalysisUsage::addRequiredID(a2, llvm::RegionInfoPass::ID);
  *((_BYTE *)a2 + 160) = 1;
  return result;
}

void llvm::RGPassManager::dumpPassStructure(llvm::RGPassManager *this, int a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  unint64_t v6;
  uint64_t v7;
  llvm::Pass *v8;

  v4 = (llvm::raw_ostream *)llvm::errs(this);
  v5 = llvm::raw_ostream::indent(v4, 2 * a2);
  sub_1C4816AD8(v5, "Region Pass Manager\n");
  if (*((_DWORD *)this + 14))
  {
    v6 = 0;
    v7 = (a2 + 1);
    do
    {
      v8 = *(llvm::Pass **)(*((_QWORD *)this + 6) + 8 * v6);
      (*(void (**)(llvm::Pass *, uint64_t))(*(_QWORD *)v8 + 128))(v8, v7);
      llvm::PMDataManager::dumpLastUses((llvm::RGPassManager *)((char *)this + 32), v8, v7);
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 14));
  }
}

double llvm::RegionPass::preparePassManager(llvm::RegionPass *this, llvm::PMStack *a2)
{
  uint64_t v4;
  uint64_t i;
  double result;

  v4 = *(_QWORD *)a2;
  for (i = *((_QWORD *)a2 + 1); v4 != i; i = *((_QWORD *)a2 + 1))
  {
    if ((*(int (**)(_QWORD))(**(_QWORD **)(i - 8) + 40))(*(_QWORD *)(i - 8)) <= 5)
    {
      v4 = *((_QWORD *)a2 + 1);
      break;
    }
    llvm::PMStack::pop(a2);
    v4 = *(_QWORD *)a2;
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v4 - 8) + 40))(*(_QWORD *)(v4 - 8)) == 5
    && (llvm::PMDataManager::preserveHigherLevelAnalysis(*(llvm::PMTopLevelManager ***)(*((_QWORD *)a2 + 1) - 8), this) & 1) == 0)
  {
    return llvm::PMStack::pop(a2);
  }
  return result;
}

void llvm::RegionPass::assignPassManager(llvm::Pass *a1, llvm::PMStack *a2)
{
  uint64_t v4;
  uint64_t i;
  int v6;
  uint64_t v7;
  uint64_t v8;
  llvm::PMDataManager *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  int32x2_t *v15;
  uint64_t v16;

  v4 = *(_QWORD *)a2;
  for (i = *((_QWORD *)a2 + 1); v4 != i; i = *((_QWORD *)a2 + 1))
  {
    if ((*(int (**)(_QWORD))(**(_QWORD **)(i - 8) + 40))(*(_QWORD *)(i - 8)) <= 5)
    {
      v4 = *((_QWORD *)a2 + 1);
      break;
    }
    llvm::PMStack::pop(a2);
    v4 = *(_QWORD *)a2;
  }
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 - 8) + 40))(*(_QWORD *)(v4 - 8));
  v7 = *(_QWORD *)(*((_QWORD *)a2 + 1) - 8);
  if (v6 == 5)
  {
    if (v7)
      v8 = v7 - 32;
    else
      v8 = 0;
  }
  else
  {
    v8 = operator new();
    *(_QWORD *)(v8 + 16) = &llvm::RGPassManager::ID;
    *(_DWORD *)(v8 + 24) = 2;
    *(_QWORD *)(v8 + 32) = &unk_1E813A9A8;
    v9 = (llvm::PMDataManager *)(v8 + 32);
    *(_QWORD *)(v8 + 40) = 0;
    *(_QWORD *)(v8 + 48) = v8 + 64;
    *(_QWORD *)(v8 + 56) = 0x1000000000;
    *(_QWORD *)(v8 + 240) = 0;
    *(_QWORD *)(v8 + 248) = 0;
    *(_DWORD *)(v8 + 256) = 0;
    *(_QWORD *)(v8 + 264) = v8 + 280;
    *(_QWORD *)(v8 + 272) = 0x1000000000;
    *(_DWORD *)(v8 + 408) = 0;
    *(_OWORD *)(v8 + 192) = 0u;
    *(_OWORD *)(v8 + 208) = 0u;
    *(_OWORD *)(v8 + 224) = 0u;
    *(_QWORD *)v8 = &off_1E813A8F8;
    *(_QWORD *)(v8 + 8) = 0;
    *(_OWORD *)(v8 + 448) = 0u;
    *(_OWORD *)(v8 + 464) = 0u;
    *(_OWORD *)(v8 + 416) = 0u;
    *(_OWORD *)(v8 + 432) = 0u;
    v11 = *(_QWORD *)a2;
    v10 = *((_QWORD *)a2 + 1);
    if (v10 != *(_QWORD *)a2)
    {
      v12 = 0;
      do
      {
        v13 = *(_QWORD *)(v10 - 8);
        v10 -= 8;
        v14 = (char *)v9 + 8 * v12++;
        *((_QWORD *)v14 + 20) = v13 + 208;
      }
      while (v10 != v11);
    }
    v15 = *(int32x2_t **)(v7 + 8);
    v16 = v15[15].u32[0];
    if (v16 >= v15[15].i32[1])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15[14], (uint64_t)&v15[16], v16 + 1, 8);
      LODWORD(v16) = v15[15].i32[0];
    }
    *(_QWORD *)(*(_QWORD *)&v15[14] + 8 * v16) = v9;
    ++v15[15].i32[0];
    llvm::PMTopLevelManager::schedulePass(v15, (const void **)v8);
    llvm::PMStack::push(a2, v9);
  }
  llvm::PMDataManager::add((llvm::PMDataManager *)(v8 + 32), a1, 1);
}

uint64_t sub_1C61B017C()
{
  return 5;
}

uint64_t sub_1C61B0184()
{
  return 0;
}

uint64_t sub_1C61B018C()
{
  return 0;
}

void sub_1C61B0194(_QWORD *a1)
{
  llvm::PMDataManager *v2;

  *a1 = &off_1E813A8F8;
  a1[4] = &unk_1E813A9A8;
  v2 = (llvm::PMDataManager *)(a1 + 4);
  sub_1C484143C((uint64_t)(a1 + 52));
  llvm::PMDataManager::~PMDataManager(v2);
  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1C61B01DC(_QWORD *a1)
{
  llvm::PMDataManager *v2;

  *a1 = &off_1E813A8F8;
  a1[4] = &unk_1E813A9A8;
  v2 = (llvm::PMDataManager *)(a1 + 4);
  sub_1C484143C((uint64_t)(a1 + 52));
  llvm::PMDataManager::~PMDataManager(v2);
  llvm::Pass::~Pass((llvm::Pass *)a1);
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C61B0238()
{
  return "Region Pass Manager";
}

uint64_t sub_1C61B0248(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1C61B0254()
{
  return 5;
}

void sub_1C61B025C(llvm::PMDataManager *a1)
{
  llvm::Pass *v2;

  *((_QWORD *)a1 - 4) = &off_1E813A8F8;
  v2 = (llvm::PMDataManager *)((char *)a1 - 32);
  *(_QWORD *)a1 = &unk_1E813A9A8;
  sub_1C484143C((uint64_t)a1 + 384);
  llvm::PMDataManager::~PMDataManager(a1);
  llvm::Pass::~Pass(v2);
}

void sub_1C61B02A4(uint64_t a1)
{
  sub_1C61B01DC((_QWORD *)(a1 - 32));
}

uint64_t sub_1C61B02AC(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_1C61B02B4()
{
  return 5;
}

uint64_t llvm::createRegionPrinterPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EFDEC4(v1);
}

uint64_t llvm::createRegionOnlyPrinterPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EFDFA0(v1);
}

uint64_t llvm::createRegionViewerPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EFE07C(v1);
}

uint64_t llvm::createRegionOnlyViewerPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C4EFE158(v1);
}

llvm::raw_ostream *sub_1C61B035C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  sub_1C4EFEA90((llvm::raw_ostream **)a1, a2);
  sub_1C4EFEE64((uint64_t *)a1);
  v3 = **(_QWORD **)(a1 + 8);
  sub_1C4816AD8(*(llvm::raw_ostream **)a1, "\tcolorscheme = \"paired12\"\n");
  sub_1C4EFFBE8(*(_QWORD **)(v3 + 32), (llvm::raw_ostream **)a1, 4);
  return sub_1C4816AD8(*(llvm::raw_ostream **)a1, "}\n");
}

void sub_1C61B03B4(_QWORD *a1, uint64_t a2)
{
  uint64_t *BBNode;
  char *v5;
  char *v6;
  uint64_t v7;
  _OWORD v8[4];
  uint64_t v9;
  void *__p;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  BBNode = llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode(*(_QWORD *)(*(_QWORD *)a2 + 32), **(_QWORD **)(*(_QWORD *)a2 + 32) & 0xFFFFFFFFFFFFFFF8);
  sub_1C61AF054((uint64_t)&v13, (uint64_t)BBNode);
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode(*(_QWORD *)(*(_QWORD *)a2 + 32), **(_QWORD **)(*(_QWORD *)a2 + 32) & 0xFFFFFFFFFFFFFFF8);
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  __p = 0;
  v5 = (char *)v8 + 8;
  v6 = (char *)v8 + 8;
  v7 = 8;
  v11 = 0;
  v12 = 0;
  sub_1C61AE17C(a1, (uint64_t)&v13, (uint64_t)&v5);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  if (v6 != v5)
    free(v6);
  if (v15)
  {
    v16 = v15;
    operator delete(v15);
  }
  if (v14 != v13)
    free(v14);
}

uint64_t sub_1C61B049C(uint64_t a1)
{
  unsigned int v2;
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int NumSuccessors;
  uint64_t v8;

  do
  {
    v2 = *(_DWORD *)(a1 + 16) + 1;
    *(_DWORD *)(a1 + 16) = v2;
    v3 = *(_QWORD **)a1;
    v4 = **(_QWORD **)a1 & 0xFFFFFFFFFFFFFFF8;
    v5 = *(_QWORD *)(v4 + 40);
    if (v5 == v4 + 40 || (v5 ? (v6 = (unsigned __int8 *)(v5 - 24)) : (v6 = 0), v6[16] - 29 > 0xA))
      NumSuccessors = 0;
    else
      NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v6);
    if (v2 == NumSuccessors)
      break;
    v8 = *(_QWORD *)(v3[1] + 32);
  }
  while (v8 == llvm::Instruction::getSuccessor(*(llvm::Instruction **)(a1 + 8), v2));
  return a1;
}

uint64_t sub_1C61B0534(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  int NumSuccessors;
  uint64_t v12;

  v2 = a2;
  *(_QWORD *)a1 = a2;
  v4 = *a2 & 0xFFFFFFFFFFFFFFF8;
  v5 = *(_QWORD *)(v4 + 40);
  if (v5 == v4 + 40)
  {
    v6 = 0;
  }
  else
  {
    if (v5)
      v6 = v5 - 24;
    else
      v6 = 0;
    if (*(unsigned __int8 *)(v6 + 16) - 29 >= 0xB)
      v6 = 0;
  }
  v7 = 0;
  *(_QWORD *)(a1 + 8) = v6;
  *(_QWORD *)(a1 + 16) = 0;
  while (1)
  {
    v8 = *v2 & 0xFFFFFFFFFFFFFFF8;
    v9 = *(_QWORD *)(v8 + 40);
    if (v9 == v8 + 40 || (v9 ? (v10 = (unsigned __int8 *)(v9 - 24)) : (v10 = 0), v10[16] - 29 > 0xA))
      NumSuccessors = 0;
    else
      NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v10);
    if (NumSuccessors == v7)
      break;
    v12 = *(_QWORD *)(v2[1] + 32);
    if (v12 != llvm::Instruction::getSuccessor(*(llvm::Instruction **)(a1 + 8), v7))
      break;
    v7 = *(_DWORD *)(a1 + 16) + 1;
    *(_DWORD *)(a1 + 16) = v7;
    v2 = *(_QWORD **)a1;
  }
  return a1;
}

void sub_1C61B0618(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  char v3;

  if ((a3 & 4) != 0)
  {
    *(_BYTE *)(a1 + 23) = 15;
    strcpy((char *)a1, "Not implemented");
  }
  else if (*a2)
  {
    sub_1C4DCA780((llvm::Value *)(a3 & 0xFFFFFFFFFFFFFFF8), (_QWORD *)a1);
  }
  else
  {
    sub_1C4DCA9C4((llvm::Value *)(a3 & 0xFFFFFFFFFFFFFFF8), (void (*)(uint64_t, void (***)(llvm::raw_ostream *__hidden), llvm::Value *))sub_1C617F190, (uint64_t)&v3, (void (*)(uint64_t, std::string *, unsigned int *, std::string::size_type))sub_1C617F19C, (uint64_t)sub_1C617F158, (std::string *)a1);
  }
}

uint64_t sub_1C61B06AC(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  unint64_t Successor;
  uint64_t result;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;

  Successor = llvm::Instruction::getSuccessor(*(llvm::Instruction **)(a3 + 8), *(_DWORD *)(a3 + 16));
  result = (uint64_t)llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode(*(_QWORD *)(*(_QWORD *)a3 + 8), Successor);
  if ((*a2 & 4) == 0)
  {
    v10 = *(_QWORD *)result;
    if ((*(_QWORD *)result & 4) == 0)
    {
      v11 = *a2 & 0xFFFFFFFFFFFFFFF8;
      v12 = v10 & 0xFFFFFFFFFFFFFFF8;
      v14 = 0;
      v15 = v10 & 0xFFFFFFFFFFFFFFF8;
      result = sub_1C61252B8((uint64_t *)(a4 + 40), &v15, &v14);
      v13 = 0;
      if ((_DWORD)result)
        v13 = *(_QWORD **)(v14 + 8);
      while (v13)
      {
        result = (uint64_t)v13;
        v13 = (_QWORD *)v13[1];
        if (!v13 || (*v13 & 0xFFFFFFFFFFFFFFF8) != v12)
        {
          if ((*(_QWORD *)result & 0xFFFFFFFFFFFFFFF8) == v12)
          {
            result = llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains((_QWORD *)result, v11);
            if ((_DWORD)result)
            {
              *(_BYTE *)(a1 + 23) = 16;
              *(_OWORD *)a1 = *(_OWORD *)"constraint=false";
              a1 += 16;
              goto LABEL_4;
            }
          }
          break;
        }
      }
    }
  }
  *(_BYTE *)(a1 + 23) = 0;
LABEL_4:
  *(_BYTE *)a1 = 0;
  return result;
}

char *sub_1C61B079C(void **a1)
{
  void **v2;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  char *result;
  unsigned int v9;
  _QWORD *v10;
  llvm::Instruction *v12;
  unint64_t Successor;
  uint64_t *BBNode;
  char v15;
  void *v16;
  __int128 v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v2 = a1 + 12;
  v3 = (uint64_t)a1[13];
  while (2)
  {
    v4 = *(_QWORD **)(v3 - 40);
    if (!*(_BYTE *)(v3 - 8))
    {
      sub_1C61B0534((uint64_t)&v19, *(_QWORD **)(v3 - 40));
      if (*(_BYTE *)(v3 - 8))
        *(_BYTE *)(v3 - 8) = 0;
      v17 = v19;
      *(_QWORD *)(v3 - 16) = v20;
      *(_OWORD *)(v3 - 32) = v17;
      *(_BYTE *)(v3 - 8) = 1;
    }
    while (1)
    {
      v5 = *v4 & 0xFFFFFFFFFFFFFFF8;
      v6 = *(_QWORD *)(v5 + 40);
      if (v6 == v5 + 40 || (v6 ? (v7 = (unsigned __int8 *)(v6 - 24)) : (v7 = 0), v7[16] - 29 > 0xA))
        result = 0;
      else
        result = (char *)llvm::Instruction::getNumSuccessors((llvm::Instruction *)v7);
      v9 = *(_DWORD *)(v3 - 16);
      v10 = *(_QWORD **)(v3 - 32);
      if (v9 == (_DWORD)result && v10 == v4)
        break;
      v12 = *(llvm::Instruction **)(v3 - 24);
      sub_1C61B049C(v3 - 32);
      Successor = llvm::Instruction::getSuccessor(v12, v9);
      BBNode = llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode(v10[1], Successor);
      sub_1C4774094((llvm::SmallPtrSetImplBase *)a1, (uint64_t)BBNode);
      if (v15)
      {
        *(_QWORD *)&v19 = BBNode;
        BYTE8(v19) = 0;
        LOBYTE(v21) = 0;
        v18 = (char *)a1[13];
        if (v18 >= a1[14])
        {
          result = sub_1C4EFB72C(v2, (uint64_t)&v19);
        }
        else
        {
          *(_OWORD *)v18 = v19;
          *((_OWORD *)v18 + 1) = v20;
          *((_QWORD *)v18 + 4) = v21;
          result = v18 + 40;
        }
        a1[13] = result;
        return result;
      }
    }
    v16 = a1[12];
    v3 = (uint64_t)a1[13] - 40;
    a1[13] = (void *)v3;
    if (v16 != (void *)v3)
      continue;
    break;
  }
  return result;
}

llvm::cl::Option *sub_1C61B091C(llvm::cl::Option *a1, char *a2, __n128 *a3, _WORD *a4, _BYTE **a5)
{
  uint64_t v10;

  v10 = sub_1C47AD050((uint64_t)a1, 0, 0);
  *(_BYTE *)(v10 + 128) = 0;
  *(_QWORD *)(v10 + 136) = &off_1E7F9E8D8;
  *(_QWORD *)(v10 + 144) = 0;
  *(_QWORD *)v10 = &unk_1E819E898;
  *(_QWORD *)(v10 + 152) = &off_1E819E9A0;
  *(_QWORD *)(v10 + 160) = &off_1E7F9E8F8;
  *(_QWORD *)(v10 + 184) = v10 + 160;
  sub_1C4F01484(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

uint64_t llvm::getReplayInlineAdvisor@<X0>(const llvm::Module *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, __int128 *a5@<X4>, char a6@<W5>, uint64_t *a7@<X8>)
{
  uint64_t result;
  uint64_t v9;
  char v10;

  v10 = a6;
  sub_1C4F01AC8(a1, a2, a3, a4, a5, &v10, &v9);
  result = v9;
  if (!*(_BYTE *)(v9 + 40))
  {
    v9 = 0;
    (*(void (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    result = v9;
  }
  *a7 = result;
  return result;
}

void sub_1C61B0A2C(llvm::InlineAdvisor *a1)
{
  sub_1C61B0A50(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61B0A50(llvm::InlineAdvisor *a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &off_1E813B088;
  sub_1C4F02264((uint64_t)a1 + 120);
  sub_1C4F02264((uint64_t)a1 + 88);
  v2 = *((_QWORD *)a1 + 4);
  *((_QWORD *)a1 + 4) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  llvm::InlineAdvisor::~InlineAdvisor(a1);
}

llvm *llvm::SCEV::dump(llvm::SCEV *this)
{
  llvm *v2;
  llvm *result;
  _BYTE *v4;

  llvm::dbgs(this);
  llvm::SCEV::print((uint64_t)this);
  result = llvm::dbgs(v2);
  v4 = (_BYTE *)*((_QWORD *)result + 4);
  if ((unint64_t)v4 >= *((_QWORD *)result + 3))
    return llvm::raw_ostream::write(result, 10);
  *((_QWORD *)result + 4) = v4 + 1;
  *v4 = 10;
  return result;
}

uint64_t sub_1C61B0AFC(uint64_t a1, uint64_t a2)
{
  llvm::SCEV::print(a2);
  return a1;
}

uint64_t llvm::ScalarEvolution::getCouldNotCompute(llvm::ScalarEvolution *this)
{
  return *((_QWORD *)this + 6);
}

BOOL llvm::ScalarEvolution::isAvailableAtLoopEntry(llvm::ScalarEvolution *this, const llvm::SCEV *a2, const llvm::BasicBlock ***a3)
{
  return llvm::ScalarEvolution::getLoopDisposition(this, a2, (const llvm::Loop *)a3) == 1
      && llvm::ScalarEvolution::getBlockDisposition(this, a2, *a3[4]) == 2;
}

void gcd(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;

  sub_1C4DA6CE8((const void **)(*(_QWORD *)(a1 + 32) + 24), (uint64_t)&v15);
  sub_1C4DA6CE8((const void **)(*(_QWORD *)(a2 + 32) + 24), (uint64_t)&v13);
  v5 = v16;
  v6 = v14;
  if (v16 <= v14)
  {
    if (v16 < v14)
    {
      llvm::APInt::zext((llvm::APInt *)&v15, v14, (uint64_t)&v11);
      if (v16 >= 0x41 && v15)
        MEMORY[0x1CAA32F9C](v15, 0x1000C8000313F17);
      v15 = v11;
      v5 = v12;
      v6 = v14;
    }
  }
  else
  {
    llvm::APInt::zext((llvm::APInt *)&v13, v16, (uint64_t)&v11);
    if (v14 >= 0x41 && v13)
      MEMORY[0x1CAA32F9C](v13, 0x1000C8000313F17);
    v13 = v11;
    v6 = v12;
    v5 = v16;
  }
  v10 = v5;
  v9 = v15;
  v16 = 0;
  v8 = v6;
  v7 = v13;
  v14 = 0;
  llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v9, (uint64_t)&v7, a3);
  if (v8 >= 0x41 && v7)
    MEMORY[0x1CAA32F9C](v7, 0x1000C8000313F17);
  if (v10 >= 0x41 && v9)
    MEMORY[0x1CAA32F9C](v9, 0x1000C8000313F17);
  if (v14 >= 0x41 && v13)
    MEMORY[0x1CAA32F9C](v13, 0x1000C8000313F17);
  if (v16 >= 0x41)
  {
    if (v15)
      MEMORY[0x1CAA32F9C](v15, 0x1000C8000313F17);
  }
}

uint64_t llvm::ScalarEvolution::getSMaxExpr(uint64_t a1, uint64_t **a2)
{
  return llvm::ScalarEvolution::getMinMaxExpr(a1, 9, a2);
}

uint64_t llvm::ScalarEvolution::getUMaxExpr(uint64_t a1, uint64_t **a2)
{
  return llvm::ScalarEvolution::getMinMaxExpr(a1, 8, a2);
}

uint64_t llvm::ScalarEvolution::getSMinExpr(uint64_t a1, uint64_t **a2)
{
  return llvm::ScalarEvolution::getMinMaxExpr(a1, 11, a2);
}

uint64_t llvm::ScalarEvolution::getUMinExpr(uint64_t a1, unsigned int *a2, int a3)
{
  if (a3)
    return llvm::ScalarEvolution::getSequentialMinMaxExpr(a1, 12, a2);
  else
    return llvm::ScalarEvolution::getMinMaxExpr(a1, 10, (uint64_t **)a2);
}

unint64_t llvm::ScalarEvolution::getSizeOfScalableVectorExpr(llvm::ScalarEvolution *a1, llvm::ConstantInt *a2, llvm::Type *this)
{
  llvm::Constant *PointerTo;
  llvm::Type *v7;
  uint64_t *NullValue;
  uint64_t ElementPtr;
  llvm::UndefValue *v10;
  llvm::Value **v12;

  PointerTo = (llvm::Constant *)llvm::Type::getPointerTo(this, 0);
  NullValue = (uint64_t *)llvm::Constant::getNullValue(PointerTo, v7);
  v12 = llvm::ConstantInt::get(a2, 1, 0);
  ElementPtr = llvm::ConstantExpr::getGetElementPtr(this, NullValue, (llvm::Value *)&v12, 1, 0, 0, 0);
  v10 = sub_1C537D3B8((llvm *)0x2F, ElementPtr, a2, 0);
  return llvm::ScalarEvolution::getUnknown(a1, v10);
}

BOOL llvm::ScalarEvolution::instructionCouldExistWitthOperands(llvm::DominatorTree **this, const llvm::SCEV *a2, const llvm::SCEV *a3)
{
  const llvm::Value *DefiningScopeBound;
  const llvm::Instruction *v6;
  _BOOL8 result;
  BOOL v8;
  __int16 v9;
  uint64_t v10[2];

  v10[1] = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10[0] = (uint64_t)a2;
  DefiningScopeBound = llvm::ScalarEvolution::getDefiningScopeBound(this, v10, 1, (_BYTE *)&v9 + 1);
  v10[0] = (uint64_t)a3;
  v6 = llvm::ScalarEvolution::getDefiningScopeBound(this, v10, 1, &v9);
  result = 0;
  if (HIBYTE(v9))
    v8 = v9 == 0;
  else
    v8 = 1;
  if (!v8)
    return DefiningScopeBound == v6
        || llvm::DominatorTree::dominates(this[4], DefiningScopeBound, v6)
        || llvm::DominatorTree::dominates(this[4], v6, DefiningScopeBound);
  return result;
}

const llvm::SCEV *llvm::ScalarEvolution::getNoopOrAnyExtend(llvm::ScalarEvolution *this, const llvm::SCEV *a2, llvm::Type *a3)
{
  llvm::Type *Type;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  Type = (llvm::Type *)llvm::SCEV::getType(a2);
  llvm::ScalarEvolution::getTypeSizeInBits(this, Type);
  v8 = v7;
  llvm::ScalarEvolution::getTypeSizeInBits(this, a3);
  if (v8 == v9)
    return a2;
  else
    return (const llvm::SCEV *)llvm::ScalarEvolution::getAnyExtendExpr(this, a2, a3);
}

unint64_t llvm::ScalarEvolution::getWrapPredicate(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v6;
  uint64_t v7;
  _QWORD *NodeOrInsertPos;
  unint64_t v9;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  _DWORD v17[32];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v15 = v17;
  v17[0] = 2;
  v16 = 0x2000000001;
  sub_1C4F52194((uint64_t)&v15, a2);
  v6 = v16;
  if (v16 >= HIDWORD(v16))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15, (uint64_t)v17, v16 + 1, 4);
    v6 = v16;
  }
  *((_DWORD *)v15 + v6) = a3;
  LODWORD(v16) = v16 + 1;
  v14 = 0;
  v7 = a1 + 848;
  NodeOrInsertPos = llvm::FoldingSetBase::FindNodeOrInsertPos(a1 + 848, (uint64_t)&v15, &v14, (uint64_t)off_1E813B360);
  if (NodeOrInsertPos)
  {
    v9 = (unint64_t)(NodeOrInsertPos - 1);
  }
  else
  {
    v11 = a1 + 864;
    v9 = sub_1C484358C(a1 + 864, 56, 3);
    v12 = llvm::FoldingSetNodeID::Intern((uint64_t)&v15, v11);
    *(_QWORD *)(v9 + 8) = 0;
    *(_QWORD *)(v9 + 16) = v12;
    *(_QWORD *)(v9 + 24) = v13;
    *(_DWORD *)(v9 + 32) = 2;
    *(_QWORD *)v9 = &off_1E813B1F8;
    *(_QWORD *)(v9 + 40) = a2;
    *(_DWORD *)(v9 + 48) = a3;
    llvm::FoldingSetBase::InsertNode(v7, (uint64_t *)(v9 + 8), v14, (uint64_t)off_1E813B360);
  }
  if (v15 != v17)
    free(v15);
  return v9;
}

uint64_t llvm::PredicatedScalarEvolution::areAddRecsEqualWithPreds(uint64_t **this, const llvm::SCEVAddRecExpr *a2, const llvm::SCEVAddRecExpr *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11[7];

  if (a2 == a3)
    return 1;
  v11[5] = v3;
  v11[6] = v4;
  v11[0] = (uint64_t)this;
  result = sub_1C4F1E9CC(v11, **((_QWORD **)a2 + 4), **((_QWORD **)a3 + 4));
  if ((_DWORD)result)
  {
    v9 = sub_1C4E0C3BC((uint64_t)a2, this[11]);
    v10 = sub_1C4E0C3BC((uint64_t)a3, this[11]);
    return sub_1C4F1E9CC(v11, v9, v10);
  }
  return result;
}

uint64_t llvm::ScalarEvolution::getSmallConstantTripCount(llvm::ScalarEvolution *this, const llvm::Loop *a2)
{
  const llvm::Loop **BackedgeTakenInfo;
  uint64_t Exact;

  BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(this, a2);
  Exact = llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, (uint64_t)a2, (uint64_t)this, 0);
  if (*(_WORD *)(Exact + 24))
    Exact = 0;
  return sub_1C4F308CC(Exact);
}

uint64_t llvm::ScalarEvolution::getPredicatedBackedgeTakenCount(llvm::ScalarEvolution *a1, const llvm::Loop *a2, uint64_t a3)
{
  const llvm::Loop **PredicatedBackedgeTakenInfo;

  PredicatedBackedgeTakenInfo = llvm::ScalarEvolution::getPredicatedBackedgeTakenInfo(a1, a2);
  return llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)PredicatedBackedgeTakenInfo, (uint64_t)a2, (uint64_t)a1, a3);
}

void llvm::ScalarEvolution::forgetAllLoops(llvm::ScalarEvolution *this)
{
  sub_1C4F32F90((uint64_t)this + 544);
  sub_1C4F32F90((uint64_t)this + 568);
  sub_1C61B129C((unsigned int *)this + 148);
  sub_1C61446F0((unsigned int *)this + 178);
  sub_1C61446F0((unsigned int *)this + 154);
  sub_1C4F330BC((uint64_t)this + 104);
  sub_1C61B1348((uint64_t)this + 640);
  sub_1C61B1348((uint64_t)this + 664);
  sub_1C4F3333C((_DWORD *)this + 172);
  sub_1C61B13F8((uint64_t)this + 736);
  sub_1C61B14A8((unsigned int *)this + 196);
  sub_1C61B14A8((unsigned int *)this + 202);
  sub_1C4F333F4((uint64_t)this + 80);
  sub_1C4A5A548((unsigned int *)this + 14);
  sub_1C61446F0((unsigned int *)this + 130);
  sub_1C61B154C((uint64_t)this + 984);
}

void sub_1C61B129C(unsigned int *a1)
{
  unsigned int v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;

  v2 = a1[2];
  if (v2 || a1[3])
  {
    v3 = a1[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C4F5D2B4(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_13:
      *((_QWORD *)a1 + 1) = 0;
      return;
    }
    v4 = *(_QWORD **)a1;
    v5 = 72 * v3;
    while (1)
    {
      if (*v4 == -8192)
        goto LABEL_11;
      if (*v4 != -4096)
        break;
LABEL_12:
      v4 += 9;
      v5 -= 72;
      if (!v5)
        goto LABEL_13;
    }
    v6 = (void *)v4[2];
    if (v6 != (void *)v4[1])
      free(v6);
LABEL_11:
    *v4 = -4096;
    goto LABEL_12;
  }
}

void sub_1C61B1348(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C4F5D540(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_13:
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
    v4 = 56 * v3;
    v5 = *(_QWORD *)a1 + 24;
    while (1)
    {
      v6 = *(_QWORD *)(v5 - 24);
      if (v6 == -8192)
        goto LABEL_11;
      if (v6 != -4096)
        break;
LABEL_12:
      v5 += 56;
      v4 -= 56;
      if (!v4)
        goto LABEL_13;
    }
    v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7)
      free(v7);
LABEL_11:
    *(_QWORD *)(v5 - 24) = -4096;
    goto LABEL_12;
  }
}

void sub_1C61B13F8(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C4F5D7A8(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_13:
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
    v4 = 40 * v3;
    v5 = *(_QWORD *)a1 + 24;
    while (1)
    {
      v6 = *(_QWORD *)(v5 - 24);
      if (v6 == -8192)
        goto LABEL_11;
      if (v6 != -4096)
        break;
LABEL_12:
      v5 += 40;
      v4 -= 40;
      if (!v4)
        goto LABEL_13;
    }
    v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7)
      free(v7);
LABEL_11:
    *(_QWORD *)(v5 - 24) = -4096;
    goto LABEL_12;
  }
}

unsigned int *sub_1C61B14A8(unsigned int *result)
{
  unsigned int *v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  v2 = result[2];
  if (v2 || result[3])
  {
    v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
      return sub_1C4F5D8B4(result);
    if (!(_DWORD)v3)
    {
LABEL_12:
      *((_QWORD *)v1 + 1) = 0;
      return result;
    }
    v4 = 40 * v3;
    result = (unsigned int *)(*(_QWORD *)result + 8);
    while (1)
    {
      v5 = *((_QWORD *)result - 1);
      if (v5 == -8192)
        goto LABEL_10;
      if (v5 != -4096)
        break;
LABEL_11:
      result += 10;
      v4 -= 40;
      if (!v4)
        goto LABEL_12;
    }
    result = (unsigned int *)sub_1C4E8C6FC((uint64_t)result);
LABEL_10:
    *((_QWORD *)result - 1) = -4096;
    goto LABEL_11;
  }
  return result;
}

void sub_1C61B154C(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 <= 4 * v2 || v3 < 0x41)
    {
      if ((_DWORD)v3)
      {
        v4 = v3 << 6;
        v5 = *(_QWORD *)a1 + 40;
        do
        {
          v7 = *(_QWORD *)(v5 - 40);
          v6 = *(_QWORD *)(v5 - 32);
          if (v7 != -4096 || v6 != -4096)
          {
            if (v7 != -8192 || v6 != -8192)
            {
              v8 = *(void **)(v5 - 16);
              if ((void *)v5 != v8)
                free(v8);
            }
            *(_QWORD *)(v5 - 40) = -4096;
            *(_QWORD *)(v5 - 32) = -4096;
          }
          v5 += 64;
          v4 -= 64;
        }
        while (v4);
      }
      *(_QWORD *)(a1 + 8) = 0;
    }
    else
    {
      sub_1C4F5DAD4(a1);
    }
  }
}

uint64_t sub_1C61B1608(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t *v4;

  v3 = *(unsigned int *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12))
    return sub_1C4EB69AC(result, a2, *a3);
  v4 = (uint64_t *)(*(_QWORD *)result + 16 * v3);
  *v4 = a2;
  v4[1] = *a3;
  *(_DWORD *)(result + 8) = v3 + 1;
  return result;
}

uint64_t llvm::ScalarEvolution::isKnownPredicateAt(uint64_t ****a1, uint64_t a2, const llvm::SCEV *a3, const llvm::SCEV *a4, uint64_t a5)
{
  if ((llvm::ScalarEvolution::isKnownPredicate(a1, a2, a3, a4) & 1) != 0)
    return 1;
  else
    return llvm::ScalarEvolution::isBasicBlockEntryGuardedByCond((uint64_t)a1, *(llvm::BasicBlock **)(a5 + 40), a2, (uint64_t)a3, (uint64_t)a4);
}

BOOL llvm::ScalarEvolution::canIVOverflowOnGT(llvm::ScalarEvolution *this, const llvm::SCEV *a2, const llvm::SCEV *a3, int a4)
{
  llvm::Type *Type;
  unsigned int v9;
  unsigned int v10;
  llvm::Type *v11;
  unint64_t Constant;
  llvm::APInt *v13;
  uint64_t v14;
  llvm::ConstantRange *v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t RangeRef;
  uint64_t v21;
  llvm::ConstantRange *v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t *v36;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;

  Type = (llvm::Type *)llvm::SCEV::getType(a2);
  llvm::ScalarEvolution::getTypeSizeInBits(this, Type);
  v10 = v9;
  v11 = (llvm::Type *)llvm::SCEV::getType(a3);
  Constant = llvm::ScalarEvolution::getConstant(this, v11, 1, 0);
  if (a4)
  {
    RangeRef = llvm::ScalarEvolution::getRangeRef(this, a2, 1, 0);
    llvm::ConstantRange::getSignedMin(RangeRef, (llvm::APInt *)&v40);
    sub_1C4DE965C(v10, (llvm::APInt *)&v38);
    llvm::ScalarEvolution::getMinusSCEV((uint64_t)this, (uint64_t)a3, Constant);
    v22 = (llvm::ConstantRange *)llvm::ScalarEvolution::getRangeRef(this, v21, 1, 0);
    llvm::ConstantRange::getSignedMax(v22, (llvm::APInt *)&v36);
    v33 = v39;
    v32 = v38;
    v39 = 0;
    llvm::APInt::operator+=((uint64_t)&v32, &v36);
    v23 = v33;
    v35 = v33;
    v24 = v32;
    v34 = v32;
    v33 = 0;
    v18 = llvm::APInt::compareSigned((llvm::APInt *)&v34, (const llvm::APInt *)&v40);
    if (v23 >= 0x41)
    {
      if (v24)
      {
        v25 = v18;
        MEMORY[0x1CAA32F9C](v24, 0x1000C8000313F17);
        v18 = v25;
        if (v33 >= 0x41)
        {
          v26 = v32;
          if (v32)
            goto LABEL_21;
        }
      }
    }
  }
  else
  {
    v13 = (llvm::APInt *)llvm::ScalarEvolution::getRangeRef(this, a2, 0, 0);
    llvm::ConstantRange::getUnsignedMin(v13, (llvm::APInt *)&v40);
    sub_1C4832EA4((llvm::APInt *)&v38, v10, 0, 0);
    llvm::ScalarEvolution::getMinusSCEV((uint64_t)this, (uint64_t)a3, Constant);
    v15 = (llvm::ConstantRange *)llvm::ScalarEvolution::getRangeRef(this, v14, 0, 0);
    llvm::ConstantRange::getUnsignedMax(v15, (llvm::APInt *)&v36);
    v31 = v39;
    v30 = v38;
    v39 = 0;
    llvm::APInt::operator+=((uint64_t)&v30, &v36);
    v16 = v31;
    v35 = v31;
    v17 = v30;
    v34 = v30;
    v31 = 0;
    v18 = llvm::APInt::compare((llvm::APInt *)&v34, (const llvm::APInt *)&v40);
    if (v16 >= 0x41)
    {
      if (v17)
      {
        v25 = v18;
        MEMORY[0x1CAA32F9C](v17, 0x1000C8000313F17);
        v18 = v25;
        if (v31 >= 0x41)
        {
          v26 = v30;
          if (v30)
          {
LABEL_21:
            MEMORY[0x1CAA32F9C](v26, 0x1000C8000313F17);
            v18 = v25;
          }
        }
      }
    }
  }
  if (v37 >= 0x41 && v36)
  {
    v27 = v18;
    MEMORY[0x1CAA32F9C](v36, 0x1000C8000313F17);
    v18 = v27;
  }
  if (v39 >= 0x41 && v38)
  {
    v28 = v18;
    MEMORY[0x1CAA32F9C](v38, 0x1000C8000313F17);
    v18 = v28;
  }
  if (v41 >= 0x41 && v40)
  {
    v29 = v18;
    MEMORY[0x1CAA32F9C](v40, 0x1000C8000313F17);
    v18 = v29;
  }
  return v18 > 0;
}

uint64_t llvm::ScalarEvolution::containsUndefs(llvm::ScalarEvolution *this, const llvm::SCEV *a2)
{
  uint64_t v2;
  unsigned __int8 v4;
  unsigned __int8 *v5;
  void *v6;
  uint64_t v7;
  _BYTE v8[64];
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  _QWORD v13[9];

  v13[8] = *MEMORY[0x1E0C80C00];
  v4 = 0;
  v5 = &v4;
  v6 = v8;
  v7 = 0x800000000;
  v9 = v13;
  v10 = v13;
  v11 = 8;
  v12 = 0;
  sub_1C4E036E4((uint64_t)&v5, (uint64_t)a2);
  if ((_DWORD)v7 && !*v5)
  {
    v2 = *((_QWORD *)v6 + v7 - 1);
    LODWORD(v7) = v7 - 1;
    __asm { BR              X10 }
  }
  if (v10 != v9)
    free(v10);
  if (v6 != v8)
    free(v6);
  return v4;
}

BOOL llvm::ScalarEvolution::hasLoopInvariantBackedgeTakenCount(llvm::ScalarEvolution *this, const llvm::Loop *a2)
{
  const llvm::Loop **BackedgeTakenInfo;

  BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(this, a2);
  return *(unsigned __int16 *)(llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, (uint64_t)a2, (uint64_t)this, 0)+ 24) != 15;
}

void sub_1C61B1B68(_QWORD *a1, uint64_t a2)
{
  char *v3;
  char *v4;
  uint64_t v5;
  _OWORD v6[4];
  uint64_t v7;
  void *__p;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  sub_1C6187E38((uint64_t)&v11, a2);
  v7 = 0;
  __p = 0;
  memset(v6, 0, sizeof(v6));
  v3 = (char *)v6 + 8;
  v4 = (char *)v6 + 8;
  v5 = 8;
  v9 = 0;
  v10 = 0;
  sub_1C61AE17C(a1, (uint64_t)&v11, (uint64_t)&v3);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  if (v4 != v3)
    free(v4);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  if (v12 != v11)
    free(v12);
}

llvm::raw_ostream *sub_1C61B1C18(llvm::raw_ostream *a1, llvm::Loop *a2)
{
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(a2, a1, 0, 1, 0);
  return a1;
}

_QWORD *llvm::ScalarEvolutionVerifierPass::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t ResultImpl;

  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::ScalarEvolutionAnalysis::Key, a1);
  llvm::ScalarEvolution::verify((llvm::ScalarEvolution *)(ResultImpl + 8));
  return llvm::InstCountPass::run(a3);
}

_QWORD *llvm::ScalarEvolutionPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, llvm::Value *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  llvm::raw_ostream *v8;
  size_t v9;
  char *Name;
  size_t v11;
  void *v12;
  uint64_t ResultImpl;

  v8 = sub_1C4816AD8(*a1, "Printing analysis 'Scalar Evolution Analysis' for function '");
  Name = llvm::Value::getName(a2);
  v11 = v9;
  v12 = (void *)*((_QWORD *)v8 + 4);
  if (v9 <= *((_QWORD *)v8 + 3) - (_QWORD)v12)
  {
    if (v9)
    {
      memcpy(v12, Name, v9);
      *((_QWORD *)v8 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, Name, v9);
  }
  sub_1C4816AD8(v8, "':\n");
  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::ScalarEvolutionAnalysis::Key, (uint64_t)a2);
  llvm::ScalarEvolution::print((llvm::Value **)(ResultImpl + 8), *a1);
  return llvm::InstCountPass::run(a4);
}

void llvm::initializeScalarEvolutionWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82EA90);
  if (v2 != -1)
  {
    v5[0] = sub_1C4F4F0EC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82EA90, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::ScalarEvolutionWrapperPass *llvm::ScalarEvolutionWrapperPass::ScalarEvolutionWrapperPass(llvm::ScalarEvolutionWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::ScalarEvolutionWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E813B0F8;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EA90);
  if (v2 != -1)
  {
    v6[0] = sub_1C4F4F0EC;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EA90, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::ScalarEvolutionWrapperPass::print(llvm::Value ***this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  llvm::ScalarEvolution::print(this[4], a2);
}

void llvm::ScalarEvolutionWrapperPass::verifyAnalysis(llvm::ScalarEvolution **this)
{
  if (llvm::VerifySCEV)
    llvm::ScalarEvolution::verify(this[4]);
}

llvm::AnalysisUsage *llvm::ScalarEvolutionWrapperPass::getAnalysisUsage(llvm::ScalarEvolutionWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AssumptionCacheTracker::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::LoopInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::DominatorTreeWrapperPass::ID);
  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
}

unint64_t llvm::ScalarEvolution::getEqualPredicate(llvm::ScalarEvolution *this, const llvm::SCEV *a2, const llvm::SCEV *a3)
{
  return llvm::ScalarEvolution::getComparePredicate((uint64_t)this, 32, (uint64_t)a2, (uint64_t)a3);
}

unint64_t llvm::ScalarEvolution::getComparePredicate(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _QWORD *NodeOrInsertPos;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v15;
  void *v16[2];
  _DWORD v17[32];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v16[0] = v17;
  v17[0] = 1;
  v17[1] = a2;
  v16[1] = (void *)0x2000000002;
  sub_1C4F52194((uint64_t)v16, a3);
  sub_1C4F52194((uint64_t)v16, a4);
  v15 = 0;
  v8 = a1 + 848;
  NodeOrInsertPos = llvm::FoldingSetBase::FindNodeOrInsertPos(a1 + 848, (uint64_t)v16, &v15, (uint64_t)off_1E813B360);
  if (NodeOrInsertPos)
  {
    v11 = (unint64_t)(NodeOrInsertPos - 1);
  }
  else
  {
    v10 = a1 + 864;
    v11 = sub_1C484358C(a1 + 864, 56, 3);
    v12 = llvm::FoldingSetNodeID::Intern((uint64_t)v16, v10);
    *(_QWORD *)(v11 + 8) = 0;
    *(_QWORD *)(v11 + 16) = v12;
    *(_QWORD *)(v11 + 24) = v13;
    *(_QWORD *)v11 = &off_1E813B1C8;
    *(_DWORD *)(v11 + 32) = 1;
    *(_DWORD *)(v11 + 36) = a2;
    *(_QWORD *)(v11 + 40) = a3;
    *(_QWORD *)(v11 + 48) = a4;
    llvm::FoldingSetBase::InsertNode(v8, (uint64_t *)(v11 + 8), v15, (uint64_t)off_1E813B360);
  }
  if (v16[0] != v17)
    free(v16[0]);
  return v11;
}

uint64_t llvm::SCEVComparePredicate::isAlwaysTrue(llvm::SCEVComparePredicate *this)
{
  return 0;
}

llvm::raw_ostream *llvm::SCEVComparePredicate::print(llvm::SCEVComparePredicate *this, llvm::raw_ostream *a2, unsigned int a3)
{
  int v5;
  llvm::raw_ostream *v6;
  char *v7;
  llvm::raw_ostream *v8;
  size_t v9;
  const char *PredicateName;
  size_t v11;
  void *v12;
  llvm::raw_ostream *v13;

  v5 = *((_DWORD *)this + 9);
  llvm::raw_ostream::indent(a2, a3);
  if (v5 == 32)
  {
    v6 = sub_1C4816AD8(a2, "Equal predicate: ");
    llvm::SCEV::print(*((_QWORD *)this + 5));
    v7 = " == ";
  }
  else
  {
    v8 = sub_1C4816AD8(a2, "Compare predicate: ");
    llvm::SCEV::print(*((_QWORD *)this + 5));
    v6 = sub_1C4816AD8(v8, " ");
    PredicateName = llvm::CmpInst::getPredicateName(*((_DWORD *)this + 9));
    v11 = v9;
    v12 = (void *)*((_QWORD *)v6 + 4);
    if (v9 <= *((_QWORD *)v6 + 3) - (_QWORD)v12)
    {
      if (v9)
      {
        memcpy(v12, PredicateName, v9);
        *((_QWORD *)v6 + 4) += v11;
      }
    }
    else
    {
      llvm::raw_ostream::write(v6, PredicateName, v9);
    }
    v7 = ") ";
  }
  v13 = sub_1C4816AD8(v6, v7);
  llvm::SCEV::print(*((_QWORD *)this + 6));
  return sub_1C4816AD8(v13, "\n");
}

uint64_t llvm::SCEVWrapPredicate::getExpr(llvm::SCEVWrapPredicate *this)
{
  return *((_QWORD *)this + 5);
}

BOOL llvm::SCEVWrapPredicate::isAlwaysTrue(llvm::SCEVWrapPredicate *this)
{
  int v1;
  unsigned int v2;

  v1 = *(_WORD *)(*((_QWORD *)this + 5) + 28) & 7;
  if ((v1 | 4) == v1)
    v2 = *((_DWORD *)this + 12) & 0xFFFFFFFD;
  else
    v2 = *((_DWORD *)this + 12);
  return v2 == 0;
}

llvm::raw_ostream *llvm::SCEVWrapPredicate::print(llvm::SCEVWrapPredicate *this, llvm::raw_ostream *a2, unsigned int a3)
{
  int v5;

  llvm::raw_ostream::indent(a2, a3);
  llvm::SCEV::print(*((_QWORD *)this + 5));
  sub_1C4816AD8(a2, " Added Flags: ");
  v5 = *((_DWORD *)this + 12);
  if ((v5 & 1) != 0)
  {
    sub_1C4816AD8(a2, "<nusw>");
    v5 = *((_DWORD *)this + 12);
  }
  if ((v5 & 2) != 0)
    sub_1C4816AD8(a2, "<nssw>");
  return sub_1C4816AD8(a2, "\n");
}

uint64_t llvm::SCEVUnionPredicate::isAlwaysTrue(llvm::SCEVUnionPredicate *this)
{
  uint64_t v1;
  uint64_t result;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;

  v1 = *((unsigned int *)this + 12);
  if (!(_DWORD)v1)
    return 1;
  v3 = (uint64_t *)*((_QWORD *)this + 5);
  v4 = 8 * v1 - 8;
  do
  {
    v5 = *v3++;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    if ((_DWORD)result)
      v6 = v4 == 0;
    else
      v6 = 1;
    v4 -= 8;
  }
  while (!v6);
  return result;
}

uint64_t llvm::SCEVUnionPredicate::print(uint64_t this, llvm::raw_ostream *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *(unsigned int *)(this + 48);
  if ((_DWORD)v3)
  {
    v6 = *(uint64_t **)(this + 40);
    v7 = 8 * v3;
    do
    {
      v8 = *v6++;
      this = (*(uint64_t (**)(uint64_t, llvm::raw_ostream *, uint64_t))(*(_QWORD *)v8 + 24))(v8, a2, a3);
      v7 -= 8;
    }
    while (v7);
  }
  return this;
}

void llvm::PredicatedScalarEvolution::addPredicate(int8x16_t *a1, uint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  _QWORD v16[5];

  v16[4] = *MEMORY[0x1E0C80C00];
  if ((llvm::SCEVUnionPredicate::implies(a1[6].i64[1], a2) & 1) == 0)
  {
    v4 = a1[6].i64[1];
    v5 = *(_BYTE **)(v4 + 40);
    v6 = &v5[8 * *(unsigned int *)(v4 + 48)];
    v14 = v16;
    v15 = 0x400000000;
    sub_1C4DFE610((unsigned int *)&v14, v5, v6);
    v7 = v15;
    if (v15 >= HIDWORD(v15))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, (uint64_t)v16, v15 + 1, 8);
      v7 = v15;
    }
    *((_QWORD *)v14 + v7) = a2;
    LODWORD(v15) = v15 + 1;
    sub_1C4F4FBF0((uint64_t)&v14, &v13);
    v8 = v13;
    v13 = 0;
    v9 = a1[6].i64[1];
    a1[6].i64[1] = v8;
    if (v9)
    {
      v10 = *(void **)(v9 + 40);
      if (v10 != (void *)(v9 + 56))
        free(v10);
      MEMORY[0x1CAA32FC0](v9, 0x10D1C407D0B9851);
      v11 = v13;
      v13 = 0;
      if (v11)
      {
        v12 = *(void **)(v11 + 40);
        if (v12 != (void *)(v11 + 56))
          free(v12);
        MEMORY[0x1CAA32FC0](v11, 0x10D1C407D0B9851);
      }
    }
    llvm::PredicatedScalarEvolution::updateGeneration(a1);
    if (v14 != v16)
      free(v14);
  }
}

uint64_t llvm::PredicatedScalarEvolution::getPredicate(llvm::PredicatedScalarEvolution *this)
{
  return *((_QWORD *)this + 13);
}

void llvm::PredicatedScalarEvolution::setNoOverflow(uint64_t a1, llvm::Value *a2, int a3)
{
  llvm::SCEVWrapPredicate *SCEV;
  llvm::ScalarEvolution *v7;
  unsigned int v8;
  unint64_t WrapPredicate;
  llvm::Value *v10;
  unsigned int v11;
  uint64_t v12;
  char v13;

  SCEV = (llvm::SCEVWrapPredicate *)llvm::PredicatedScalarEvolution::getSCEV((int8x16_t *)a1, a2);
  v8 = a3 & ~llvm::SCEVWrapPredicate::getImpliedFlags(SCEV, *(const llvm::SCEVAddRecExpr **)(a1 + 88), v7);
  WrapPredicate = llvm::ScalarEvolution::getWrapPredicate(*(_QWORD *)(a1 + 88), (uint64_t)SCEV, v8);
  llvm::PredicatedScalarEvolution::addPredicate((int8x16_t *)a1, WrapPredicate);
  v10 = a2;
  v11 = v8;
  sub_1C61B24E0(a1 + 24, (uint64_t *)&v10, (uint64_t)&v12);
  if (!v13)
    *(_DWORD *)(v12 + 40) |= v8;
}

double sub_1C61B24E0@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  BOOL v10;
  double result;
  _QWORD v12[2];
  uint64_t v13;
  uint64_t v14;
  uint64_t (**v15)(llvm::CallbackVH *__hidden);
  unint64_t v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  __int128 v21;
  char v22;

  v6 = *a2;
  v7 = 2;
  v12[0] = 2;
  v12[1] = 0;
  v13 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v12);
    v7 = v12[0];
    v6 = v13;
  }
  v14 = a1;
  v16 = v7 & 6;
  v17 = 0;
  v18 = v6;
  v9 = a1;
  if (v6 != -8192)
  {
    v10 = v6 == -4096 || v6 == 0;
    v9 = a1;
    if (!v10)
    {
      v17 = *(unint64_t **)(v7 & 0xFFFFFFFFFFFFFFF8);
      *(_QWORD *)(v7 & 0xFFFFFFFFFFFFFFF8) = &v16;
      v16 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if (v17)
        *v17 = *v17 & 7 | (unint64_t)&v17;
      v9 = v14;
    }
  }
  v15 = &off_1E813B388;
  v19 = v9;
  v20 = *((_DWORD *)a2 + 2);
  sub_1C61B3B00((uint64_t)&v21, a1, (uint64_t *)&v15, &v20);
  if (v18 != -8192 && v18 != -4096 && v18)
    llvm::ValueHandleBase::RemoveFromUseList(&v16);
  if (v13 != -8192 && v13 != -4096 && v13)
    llvm::ValueHandleBase::RemoveFromUseList(v12);
  result = *(double *)&v21;
  *(_OWORD *)a3 = v21;
  *(_BYTE *)(a3 + 16) = v22;
  return result;
}

void sub_1C61B2648(llvm::Pass *a1)
{
  sub_1C61B2A7C(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61B266C()
{
  return 1;
}

uint64_t sub_1C61B2674(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_1C61B267C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 24 * v6;
    do
    {
      *v7 = -4096;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C4F54554(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_QWORD *)a2;
      *((_DWORD *)v10 + 4) = *(_DWORD *)(a2 + 16);
      v10[1] = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 16) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

uint64_t sub_1C61B2738(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 != a2)
  {
    v3 = *(unsigned int *)(a2 + 8);
    v4 = *(unsigned int *)(a1 + 8);
    if (v4 >= v3)
    {
      if ((_DWORD)v3)
        memmove(*(void **)a1, *(const void **)a2, 8 * v3);
      goto LABEL_8;
    }
    if (*(_DWORD *)(a1 + 12) < v3)
    {
      *(_DWORD *)(a1 + 8) = 0;
      v9 = a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v3, 8);
      a2 = v9;
    }
    else if ((_DWORD)v4)
    {
      v8 = *(unsigned int *)(a1 + 8);
      v10 = a2;
      memmove(*(void **)a1, *(const void **)a2, 8 * v4);
      v5 = v8;
      a2 = v10;
LABEL_6:
      v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6)
        memcpy((void *)(*(_QWORD *)a1 + 8 * v5), (const void *)(*(_QWORD *)a2 + 8 * v5), *(_QWORD *)a2 + 8 * v6 - (*(_QWORD *)a2 + 8 * v5));
LABEL_8:
      *(_DWORD *)(a1 + 8) = v3;
      return a1;
    }
    v5 = 0;
    goto LABEL_6;
  }
  return a1;
}

uint64_t sub_1C61B2818(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void *v4;
  uint64_t v5;

  if (*(_BYTE *)(a1 + 48))
  {
    v5 = a2;
    v4 = *(void **)(a1 + 8);
    if (v4 != (void *)(a1 + 24))
      free(v4);
    *(_BYTE *)(a1 + 48) = 0;
    a2 = v5;
  }
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = a1 + 24;
  result = a1 + 8;
  *(_QWORD *)(a1 + 16) = 0x300000000;
  if (*(_DWORD *)(a2 + 16))
    result = sub_1C4F54B2C(result, a2 + 8);
  *(_BYTE *)(a1 + 48) = 1;
  return result;
}

uint64_t sub_1C61B28A0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    v2 = *(_QWORD *)(a1 + 48);
    if (v2)
      MEMORY[0x1CAA32F9C](v2, 0x1000C8000313F17);
  }
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
      MEMORY[0x1CAA32F9C](v3, 0x1000C8000313F17);
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if (v4)
      MEMORY[0x1CAA32F9C](v4, 0x1000C8000313F17);
  }
  if (*(_DWORD *)(a1 + 8) >= 0x41u && *(_QWORD *)a1)
    MEMORY[0x1CAA32F9C](*(_QWORD *)a1, 0x1000C8000313F17);
  return a1;
}

uint64_t sub_1C61B2960(uint64_t result, uint64_t a2)
{
  uint64_t v3;

  v3 = result;
  if (*(_BYTE *)(result + 16))
  {
    if (*(_DWORD *)(result + 8) >= 0x41u)
    {
      result = *(_QWORD *)result;
      if (*(_QWORD *)v3)
        result = MEMORY[0x1CAA32F9C]();
    }
    *(_BYTE *)(v3 + 16) = 0;
  }
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
  *(_QWORD *)v3 = *(_QWORD *)a2;
  *(_DWORD *)(a2 + 8) = 0;
  *(_BYTE *)(v3 + 16) = 1;
  return result;
}

_DWORD *sub_1C61B29D0(_DWORD *this, llvm::APInt *a2)
{
  uint64_t v3;
  unsigned int v4;

  v3 = (uint64_t)this;
  if (*((_BYTE *)this + 16))
  {
    if (this[2] >= 0x41u)
    {
      this = *(_DWORD **)this;
      if (*(_QWORD *)v3)
        this = (_DWORD *)MEMORY[0x1CAA32F9C]();
    }
    *(_BYTE *)(v3 + 16) = 0;
  }
  v4 = *((_DWORD *)a2 + 2);
  *(_DWORD *)(v3 + 8) = v4;
  if (v4 > 0x40)
    this = llvm::APInt::initSlowCase((llvm::APInt *)v3, (const void **)a2);
  else
    *(_QWORD *)v3 = *(_QWORD *)a2;
  *(_BYTE *)(v3 + 16) = 1;
  return this;
}

llvm::ScalarEvolutionWrapperPass *llvm::callDefaultCtor<llvm::ScalarEvolutionWrapperPass>()
{
  llvm::ScalarEvolutionWrapperPass *v0;

  v0 = (llvm::ScalarEvolutionWrapperPass *)operator new();
  return llvm::ScalarEvolutionWrapperPass::ScalarEvolutionWrapperPass(v0);
}

void sub_1C61B2A7C(llvm::Pass *this)
{
  llvm::ScalarEvolution *v2;
  llvm::Pass *v3;

  *(_QWORD *)this = &off_1E813B0F8;
  v2 = (llvm::ScalarEvolution *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
  {
    v3 = this;
    llvm::ScalarEvolution::~ScalarEvolution(v2);
    MEMORY[0x1CAA32FC0]();
    llvm::Pass::~Pass(v3);
  }
  else
  {
    llvm::Pass::~Pass(this);
  }
}

void sub_1C61B2AD8(_WORD *a1, _WORD *a2, __n128 *a3, int **a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F3378, 0, 0);
  dword_1ED7F33F8 = 0;
  qword_1ED7F3400 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F3408 = 0;
  qword_1ED7F3378 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F3410 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F3418 = (uint64_t)&off_1E7F95260;
  qword_1ED7F3430 = (uint64_t)&qword_1ED7F3418;
  sub_1C61B2B8C(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F3378);
}

__n128 sub_1C61B2B8C(_WORD *a1, _WORD *a2, __n128 *a3, int **a4)
{
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F3378, "scalar-evolution-max-iterations", 0x1FuLL);
  word_1ED7F3382 = word_1ED7F3382 & 0xFF9F | (32 * (*a1 & 3));
  word_1ED7F3382 = word_1ED7F3382 & 0xFFF8 | *a2 & 7;
  result = *a3;
  xmmword_1ED7F3398 = (__int128)*a3;
  dword_1ED7F33F8 = **a4;
  byte_1ED7F340C = 1;
  dword_1ED7F3408 = dword_1ED7F33F8;
  return result;
}

void sub_1C61B2C1C(_WORD *a1, _BYTE **a2, __n128 *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F3438, 0, 0);
  byte_1ED7F34C9 = 0;
  qword_1ED7F34B8 = 0;
  unk_1ED7F34C0 = &off_1E7F9E8D8;
  qword_1ED7F3438 = (uint64_t)&unk_1E8138EB8;
  qword_1ED7F34D0 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F34D8 = (uint64_t)&unk_1E8138F20;
  qword_1ED7F34F0 = (uint64_t)&qword_1ED7F34D8;
  sub_1C61B2CC0(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F3438);
}

__n128 sub_1C61B2CC0(_WORD *a1, _BYTE **a2, __n128 *a3)
{
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F3438, "verify-scev", 0xBuLL);
  word_1ED7F3442 = (32 * (*a1 & 3)) | word_1ED7F3442 & 0xFF9F;
  sub_1C4EB7838((llvm *)&qword_1ED7F34B8, &qword_1ED7F3438, *a2);
  result = *a3;
  xmmword_1ED7F3458 = (__int128)*a3;
  return result;
}

uint64_t sub_1C61B2D38(uint64_t a1, char *a2, _WORD *a3, _OWORD *a4)
{
  uint64_t v8;
  size_t v9;

  v8 = sub_1C47AD050(a1, 0, 0);
  *(_BYTE *)(v8 + 128) = 0;
  *(_QWORD *)(v8 + 136) = &off_1E7F9E8D8;
  *(_QWORD *)(v8 + 144) = 0;
  *(_QWORD *)v8 = &unk_1E819E898;
  *(_QWORD *)(v8 + 152) = &off_1E819E9A0;
  *(_QWORD *)(v8 + 160) = &off_1E7F9E8F8;
  *(_QWORD *)(v8 + 184) = v8 + 160;
  v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  *(_WORD *)(a1 + 10) = (32 * (*a3 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1C61B2E04(_WORD *a1, __int128 *a2, int **a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F3978, 0, 0);
  dword_1ED7F39F8 = 0;
  qword_1ED7F3A00 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F3A08 = 0;
  qword_1ED7F3978 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F3A10 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F3A18 = (uint64_t)&off_1E7F95260;
  qword_1ED7F3A30 = (uint64_t)&qword_1ED7F3A18;
  llvm::cl::Option::setArgStr(v6, "scalar-evolution-max-scev-operations-implication-depth", 0x36uLL);
  word_1ED7F3982 = (32 * (*a1 & 3)) | word_1ED7F3982 & 0xFF9F;
  xmmword_1ED7F3998 = *a2;
  dword_1ED7F39F8 = **a3;
  byte_1ED7F3A0C = 1;
  dword_1ED7F3A08 = dword_1ED7F39F8;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F3978);
}

void sub_1C61B2EE0(_WORD *a1, __int128 *a2, int **a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F3BB8, 0, 0);
  dword_1ED7F3C38 = 0;
  qword_1ED7F3C40 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F3C48 = 0;
  qword_1ED7F3BB8 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F3C50 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F3C58 = (uint64_t)&off_1E7F95260;
  qword_1ED7F3C70 = (uint64_t)&qword_1ED7F3C58;
  llvm::cl::Option::setArgStr(v6, "scalar-evolution-max-constant-evolving-depth", 0x2CuLL);
  word_1ED7F3BC2 = (32 * (*a1 & 3)) | word_1ED7F3BC2 & 0xFF9F;
  xmmword_1ED7F3BD8 = *a2;
  dword_1ED7F3C38 = **a3;
  byte_1ED7F3C4C = 1;
  dword_1ED7F3C48 = dword_1ED7F3C38;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F3BB8);
}

void sub_1C61B2FBC(_WORD *a1, char **a2, __n128 *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F4038, 0, 0);
  byte_1ED7F40B8 = 0;
  qword_1ED7F40C0 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F40C8 = 0;
  qword_1ED7F4038 = (uint64_t)&unk_1E819E898;
  qword_1ED7F40D0 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F40D8 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F40F0 = (uint64_t)&qword_1ED7F40D8;
  sub_1C4F5AA58(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F4038);
}

void sub_1C61B3060(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1C61B3068(*(_BYTE **)(a2 + 8), *(_QWORD *)(a2 + 16), a3);
}

void sub_1C61B3068(_BYTE *__src, uint64_t a2, uint64_t a3)
{
  void *v4[2];
  _QWORD v5[17];

  v5[16] = *MEMORY[0x1E0C80C00];
  v4[0] = v5;
  v4[1] = (void *)0x2000000000;
  sub_1C4860A74((unsigned int *)v4, __src, &__src[4 * a2]);
  sub_1C4EA2F88(a3, (uint64_t)v4);
  if (v4[0] != v5)
    free(v4[0]);
}

void sub_1C61B3100(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  int64x2_t *v7;
  uint64_t v8;
  int64x2_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  __int128 v14;
  uint64_t v15;
  void *v16;
  _QWORD *v17;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(int64x2_t **)a1;
    v8 = v6 << 6;
    v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *v7 = v9;
      v7 += 4;
      v8 -= 64;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v10 = *(_QWORD *)v4;
      v11 = *(_QWORD *)(v4 + 8);
      if ((*(_QWORD *)v4 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
      {
        v17 = 0;
        sub_1C4F5C768(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v10, v11, &v17);
        v12 = v17;
        v13 = v17;
        *v17 = *(_QWORD *)v4;
        v14 = *(_OWORD *)(v4 + 8);
        v12[3] = v13 + 5;
        v15 = (uint64_t)(v12 + 3);
        *(_OWORD *)(v15 - 16) = v14;
        *(_QWORD *)(v15 + 8) = 0x300000000;
        if (*(_DWORD *)(v4 + 32))
          sub_1C4F54B2C(v15, v4 + 24);
        ++*(_DWORD *)(a1 + 8);
        v16 = *(void **)(v4 + 24);
        if ((void *)(v4 + 40) != v16)
          free(v16);
      }
      v4 += 64;
    }
    while (v4 != a3);
  }
}

void sub_1C61B3210(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  char *v6;
  char *v7;
  char v8;
  int v9;
  unint64_t v10;

  v10 = 0;
  v6 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, 0, 96, &v10);
  v7 = &v6[96 * *(unsigned int *)(a1 + 8)];
  *(_QWORD *)v7 = *a2;
  v8 = *(_BYTE *)(a3 + 16);
  *(_OWORD *)(v7 + 8) = *(_OWORD *)a3;
  v7[24] = v8;
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)(v7 + 32), (const void **)v7 + 8, (const llvm::SmallPtrSetImplBase *)(a3 + 24));
  sub_1C61B32D0((uint64_t *)a1, (uint64_t)v6);
  v9 = v10;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v6;
  ++*(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 12) = v9;
}

void sub_1C61B32D0(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  __int128 v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v4 = *a1;
    v5 = *a1 + 96 * v2;
    v6 = a2 + 32;
    v7 = (uint64_t *)(v4 + 32);
    do
    {
      *(_QWORD *)(v6 - 32) = *(v7 - 4);
      v8 = *(_OWORD *)(v7 - 3);
      *(_BYTE *)(v6 - 8) = *((_BYTE *)v7 - 8);
      *(_OWORD *)(v6 - 24) = v8;
      v6 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(v6, (void *)(v6 + 32), 4, v7) + 96;
      v9 = v7 + 8;
      v7 += 12;
    }
    while (v9 != (uint64_t *)v5);
    v10 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v10)
    {
      v11 = *a1;
      v12 = 96 * v10;
      do
      {
        v13 = *(void **)(v11 + v12 - 56);
        if (v13 != *(void **)(v11 + v12 - 64))
          free(v13);
        v12 -= 96;
      }
      while (v12);
    }
  }
}

_QWORD *sub_1C61B3380(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4F5D06C(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61B33E4(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61B33E4(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
LABEL_3:
    sub_1C4F5E2E4(a1, v6);
    v8 = 0;
    sub_1C4F5D06C(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    a3 = v8;
    goto LABEL_4;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
    goto LABEL_3;
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61B3498(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C4F5D06C(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

char *sub_1C61B3544(char *this)
{
  llvm::SmallPtrSetImplBase *v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;

  v1 = (llvm::SmallPtrSetImplBase *)this;
  v2 = (void **)(this + 96);
  v3 = *((_QWORD *)this + 13);
  while (2)
  {
    v4 = *(_QWORD *)(v3 - 24);
    if (!*(_BYTE *)(v3 - 8))
    {
      *(_QWORD *)(v3 - 16) = *(_QWORD *)(v4 + 8);
      *(_BYTE *)(v3 - 8) = 1;
    }
    while (1)
    {
      v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 16))
        break;
      *(_QWORD *)(v3 - 16) = v5 + 1;
      v6 = *v5;
      this = (char *)sub_1C4774094(v1, *v5);
      if (v7)
      {
        *(_QWORD *)&v10 = v6;
        BYTE8(v10) = 0;
        LOBYTE(v11) = 0;
        v9 = *((_QWORD *)v1 + 13);
        if (v9 >= *((_QWORD *)v1 + 14))
        {
          this = sub_1C4D8DBBC(v2, (uint64_t)&v10);
        }
        else
        {
          *(_OWORD *)v9 = v10;
          *(_QWORD *)(v9 + 16) = v11;
          this = (char *)(v9 + 24);
        }
        *((_QWORD *)v1 + 13) = this;
        return this;
      }
    }
    v8 = *((_QWORD *)v1 + 12);
    v3 = *((_QWORD *)v1 + 13) - 24;
    *((_QWORD *)v1 + 13) = v3;
    if (v8 != v3)
      continue;
    break;
  }
  return this;
}

uint64_t sub_1C61B3628(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = a2;
  if (sub_1C4E487E4(a1, &v7, &v6))
    return v6;
  v4 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v5 = 4;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 8 * v5;
}

void sub_1C61B3688(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = a2 - 8;
  if (!a2)
    v3 = 0;
  sub_1C61B3068(*(_BYTE **)(v3 + 16), *(_QWORD *)(v3 + 24), a3);
}

BOOL sub_1C61B369C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  if (a2)
    v3 = a2 - 8;
  else
    v3 = 0;
  v4 = *(_QWORD *)(v3 + 24);
  return v4 == *(_DWORD *)(a3 + 8) && memcmp(*(const void **)a3, *(const void **)(v3 + 16), 4 * v4) == 0;
}

unint64_t sub_1C61B36E8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2 - 8;
  if (!a2)
    v2 = 0;
  return sub_1C4F5AB38(*(_QWORD **)(v2 + 16), *(_QWORD *)(v2 + 16) + 4 * *(_QWORD *)(v2 + 24));
}

void sub_1C61B3710(uint64_t a1)
{
  _QWORD v3[2];
  uint64_t v4;
  uint64_t v5;

  sub_1C4E42548(v3, (_QWORD *)(a1 + 8));
  v5 = *(_QWORD *)(a1 + 32);
  sub_1C61B3868(v5, v4);
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(v3);
}

void sub_1C61B3784(uint64_t a1, uint64_t a2)
{
  int32x2_t *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[3];
  uint64_t v8[3];
  _QWORD v9[2];
  uint64_t v10;
  int32x2_t *v11;

  sub_1C4E42548(v9, (_QWORD *)(a1 + 8));
  v4 = *(int32x2_t **)(a1 + 32);
  v8[2] = (uint64_t)&off_1E813B388;
  v11 = v4;
  v7[0] = 0;
  if (sub_1C61B391C((uint64_t)*v4, v4[2].i32[0], v10, v7))
    v5 = v7[0];
  else
    v5 = *(_QWORD *)v4 + 48 * v4[2].u32[0];
  if (*(_QWORD *)v11 + 48 * v11[2].u32[0] != v5)
  {
    v6 = *(unsigned int *)(v5 + 40);
    sub_1C61B39B8(v11, v5);
    v8[0] = a2;
    v8[1] = v6;
    sub_1C61B24E0((uint64_t)v11, v8, (uint64_t)v7);
  }
  if (v10 != -8192 && v10 != -4096)
  {
    if (v10)
      llvm::ValueHandleBase::RemoveFromUseList(v9);
  }
}

int32x2_t sub_1C61B3868(uint64_t a1, uint64_t a2)
{
  int32x2_t result;
  uint64_t (**v4)(llvm::CallbackVH *__hidden);
  uint64_t v5;
  uint64_t (**v6)(llvm::CallbackVH *__hidden);
  uint64_t v7[2];
  uint64_t v8;
  uint64_t (*v9)(llvm::CallbackVH *__hidden);

  v6 = 0;
  if (sub_1C61B391C(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, &v6))
  {
    v4 = v6;
    v7[1] = 0;
    v8 = -8192;
    v6 = &off_1E813B388;
    v7[0] = 2;
    v9 = 0;
    sub_1C4D98DE0((unint64_t *)v4 + 1, v7);
    v5 = v8;
    v4[4] = v9;
    if (v5 != -8192 && v5 != -4096)
    {
      if (v5)
        llvm::ValueHandleBase::RemoveFromUseList(v7);
    }
    result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

uint64_t sub_1C61B391C(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = a1 + 48 * v5;
    v7 = *(_QWORD *)(v6 + 24);
    if (v7 == a3)
    {
      v10 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      while (v7 != -4096)
      {
        if (v8)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v8 = v6;
        v13 = v5 + v9++;
        v5 = v13 & v4;
        v6 = a1 + 48 * (v13 & v4);
        v7 = *(_QWORD *)(v6 + 24);
        v10 = 1;
        if (v7 == a3)
          goto LABEL_7;
      }
      v10 = 0;
      if (v8)
        v6 = v8;
    }
  }
  else
  {
    v6 = 0;
    v10 = 0;
  }
LABEL_7:
  *a4 = v6;
  return v10;
}

int32x2_t sub_1C61B39B8(int32x2_t *a1, uint64_t a2)
{
  uint64_t v4;
  int32x2_t result;
  uint64_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[1] = 0;
  v8 = -8192;
  v7[0] = 2;
  v9 = 0;
  sub_1C4D98DE0((unint64_t *)(a2 + 8), v7);
  v4 = v8;
  *(_QWORD *)(a2 + 32) = v9;
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

uint64_t sub_1C61B3A50(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 24 * v6;
    do
    {
      *v7 = -4096;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v10 = 0;
      result = sub_1C4F5F734((uint64_t *)v5, (_QWORD *)a2, &v10);
      v9 = v10;
      *v10 = *(_QWORD *)a2;
      *(_OWORD *)(v9 + 1) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

unint64_t sub_1C61B3B00(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  unint64_t result;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;

  v12 = 0;
  result = sub_1C61B391C(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), a3[3], &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    v9 = sub_1C61B3BB4((_DWORD *)a2, (uint64_t)a3, v12);
    result = sub_1C4D98DE0((unint64_t *)(v9 + 8), a3 + 1);
    *(_QWORD *)(v9 + 32) = a3[4];
    *(_DWORD *)(v9 + 40) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 48 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1C61B3BB4(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  unsigned int v4;
  _DWORD *v7;
  uint64_t v8;

  v3 = a1[2];
  v4 = a1[4];
  if (4 * v3 + 4 >= 3 * v4)
  {
    v4 *= 2;
  }
  else if (v4 + ~v3 - a1[3] > v4 >> 3)
  {
    goto LABEL_3;
  }
  v7 = a1;
  sub_1C4F5F948((unint64_t)a1, v4);
  v8 = 0;
  sub_1C61B391C(*(_QWORD *)v7, v7[4], *(_QWORD *)(a2 + 24), &v8);
  a1 = v7;
  a3 = v8;
LABEL_3:
  ++a1[2];
  if (*(_QWORD *)(a3 + 24) != -4096)
    --a1[3];
  return a3;
}

unint64_t sub_1C61B3C70(unint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = 48 * v6;
    v8 = (_QWORD *)(*(_QWORD *)result + 16);
    do
    {
      *v8 = 0;
      v8[1] = -4096;
      *(v8 - 2) = &off_1E813B388;
      *(v8 - 1) = 2;
      v8[2] = 0;
      v8 += 6;
      v7 -= 48;
    }
    while (v7);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)(a2 + 24);
    if ((v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      sub_1C61B391C(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      v11 = v12;
      result = sub_1C4D98DE0((unint64_t *)(v12 + 8), (uint64_t *)(a2 + 8));
      v9 = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(v11 + 32) = *(_QWORD *)(a2 + 32);
      *(_DWORD *)(v11 + 40) = *(_DWORD *)(a2 + 40);
      ++*(_DWORD *)(v5 + 8);
    }
    if (v9 != -8192 && v9 != -4096 && v9 != 0)
      result = (unint64_t)llvm::ValueHandleBase::RemoveFromUseList((_QWORD *)(a2 + 8));
    a2 += 48;
  }
  return result;
}

uint64_t llvm::SCEVAAResult::invalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return sub_1C4DA944C(a4, (uint64_t)&llvm::ScalarEvolutionAnalysis::Key, a2, a3);
}

uint64_t llvm::SCEVAA::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t result;

  result = llvm::AnalysisManager<llvm::Function>::getResultImpl(a2, &llvm::ScalarEvolutionAnalysis::Key, a1);
  *a3 = 0;
  a3[1] = result + 8;
  return result;
}

void llvm::initializeSCEVAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82EA98);
  if (v2 != -1)
  {
    v5[0] = sub_1C4F60F78;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82EA98, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::SCEVAAWrapperPass *llvm::createSCEVAAWrapperPass(llvm *this)
{
  llvm::SCEVAAWrapperPass *v1;

  v1 = (llvm::SCEVAAWrapperPass *)operator new();
  return llvm::SCEVAAWrapperPass::SCEVAAWrapperPass(v1);
}

llvm::SCEVAAWrapperPass *llvm::SCEVAAWrapperPass::SCEVAAWrapperPass(llvm::SCEVAAWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::SCEVAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E813B3C8;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EA98);
  if (v2 != -1)
  {
    v6[0] = sub_1C4F60F78;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EA98, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

llvm::AnalysisUsage *llvm::SCEVAAWrapperPass::getAnalysisUsage(llvm::SCEVAAWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::AnalysisUsage::addRequiredID(a2, llvm::ScalarEvolutionWrapperPass::ID);
}

void sub_1C61B3EF8(llvm::Pass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813B3C8;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C40A4A59CD2);
  llvm::Pass::~Pass(this);
}

void sub_1C61B3F44(llvm::Pass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813B3C8;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C40A4A59CD2);
  llvm::Pass::~Pass(this);
  JUMPOUT(0x1CAA32FC0);
}

llvm::SCEVAAWrapperPass *llvm::callDefaultCtor<llvm::SCEVAAWrapperPass>()
{
  llvm::SCEVAAWrapperPass *v0;

  v0 = (llvm::SCEVAAWrapperPass *)operator new();
  return llvm::SCEVAAWrapperPass::SCEVAAWrapperPass(v0);
}

uint64_t sub_1C61B3FCC(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)())((char *)nullsub_1722 + 4 * byte_1C85F628C[*(unsigned __int16 *)(a2 + 24)]))();
}

unint64_t llvm::SCEVDivision::visitAddRecExpr(unint64_t this, llvm::ScalarEvolution ***a2, uint64_t a3, uint64_t a4, uint64_t a5, const llvm::SCEV **a6)
{
  const llvm::SCEVAddRecExpr *v6;
  uint64_t v7;
  uint64_t *v8;
  llvm::ScalarEvolution *v9;
  const llvm::SCEV **v10;
  uint64_t Type;
  llvm::SCEV *v12;
  llvm::SCEV *v13;
  llvm::SCEV *v14;
  llvm::SCEV *v15;
  llvm::SCEV *v16;
  llvm::SCEV *v17;
  llvm::SCEV *v18;
  llvm::SCEV *v19;

  v6 = (const llvm::SCEVAddRecExpr *)a2;
  v7 = this;
  if (a2[5] != (llvm::ScalarEvolution **)2)
    goto LABEL_3;
  v18 = 0;
  v19 = 0;
  v16 = 0;
  v17 = 0;
  llvm::SCEVDivision::divide(*(llvm::SCEVDivision **)this, *a2[4], *(const llvm::SCEV ****)(this + 8), (const llvm::SCEV *)&v19, &v18, a6);
  v8 = *(uint64_t **)v7;
  v9 = (llvm::ScalarEvolution *)sub_1C4E0C3BC((uint64_t)v6, *(uint64_t **)v7);
  llvm::SCEVDivision::divide((llvm::SCEVDivision *)v8, v9, *(const llvm::SCEV ****)(v7 + 8), (const llvm::SCEV *)&v17, &v16, v10);
  Type = llvm::SCEV::getType(*(llvm::SCEV **)(v7 + 8));
  v12 = v19;
  this = llvm::SCEV::getType(v19);
  if (Type != this)
    goto LABEL_3;
  v13 = v18;
  this = llvm::SCEV::getType(v18);
  if (Type == this
    && (v14 = v17, this = llvm::SCEV::getType(v17), Type == this)
    && (v15 = v16, this = llvm::SCEV::getType(v16), Type == this))
  {
    *(_QWORD *)(v7 + 16) = llvm::ScalarEvolution::getAddRecExpr(*(uint64_t **)v7, (uint64_t)v12, (uint64_t)v14, *((uint64_t ***)v6 + 6));
    this = llvm::ScalarEvolution::getAddRecExpr(*(uint64_t **)v7, (uint64_t)v13, (uint64_t)v15, *((uint64_t ***)v6 + 6));
    v6 = (const llvm::SCEVAddRecExpr *)this;
  }
  else
  {
LABEL_3:
    *(_QWORD *)(v7 + 16) = *(_QWORD *)(v7 + 32);
  }
  *(_QWORD *)(v7 + 24) = v6;
  return this;
}

void llvm::SCEVDivision::visitAddExpr(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  const llvm::SCEV **v5;
  uint64_t v6;
  uint64_t v7;
  llvm::ScalarEvolution **v8;
  uint64_t v9;
  llvm::ScalarEvolution *v10;
  llvm::SCEV *v11;
  llvm::SCEV *v12;
  uint64_t v13;
  uint64_t v14;
  llvm::SCEV *v15;
  llvm::SCEV *v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  void *v20;
  uint64_t v21;
  _QWORD v22[3];

  v22[2] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x200000000;
  v17 = v19;
  v18 = 0x200000000;
  Type = llvm::SCEV::getType(*(llvm::SCEV **)(a1 + 8));
  v6 = *(_QWORD *)(a2 + 40);
  if (v6)
  {
    v7 = Type;
    v8 = *(llvm::ScalarEvolution ***)(a2 + 32);
    v9 = 8 * v6;
    while (1)
    {
      v10 = *v8;
      v15 = 0;
      v16 = 0;
      llvm::SCEVDivision::divide(*(llvm::SCEVDivision **)a1, v10, *(const llvm::SCEV ****)(a1 + 8), (const llvm::SCEV *)&v16, &v15, v5);
      v11 = v16;
      if (v7 != llvm::SCEV::getType(v16))
        break;
      v12 = v15;
      if (v7 != llvm::SCEV::getType(v15))
        break;
      v13 = v21;
      if (v21 >= (unint64_t)HIDWORD(v21))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, (uint64_t)v22, v21 + 1, 8);
        v13 = v21;
      }
      *((_QWORD *)v20 + v13) = v11;
      LODWORD(v21) = v21 + 1;
      v14 = v18;
      if (v18 >= (unint64_t)HIDWORD(v18))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, (uint64_t)v19, v18 + 1, 8);
        v14 = v18;
      }
      *((_QWORD *)v17 + v14) = v12;
      LODWORD(v18) = v18 + 1;
      ++v8;
      v9 -= 8;
      if (!v9)
        goto LABEL_10;
    }
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 24) = a2;
  }
  else
  {
LABEL_10:
    if ((_DWORD)v21 == 1)
    {
      *(_QWORD *)(a1 + 16) = *(_QWORD *)v20;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)v17;
    }
    else
    {
      *(_QWORD *)(a1 + 16) = llvm::ScalarEvolution::getAddExpr(*(_QWORD *)a1, (uint64_t)&v20, 0, 0);
      *(_QWORD *)(a1 + 24) = llvm::ScalarEvolution::getAddExpr(*(_QWORD *)a1, (uint64_t)&v17, 0, 0);
    }
  }
  if (v17 != v19)
    free(v17);
  if (v20 != v22)
    free(v20);
}

void llvm::SCEVDivision::visitMulExpr(uint64_t a1, uint64_t a2)
{
  uint64_t Type;
  uint64_t v5;
  uint64_t v6;
  llvm::SCEV **v7;
  llvm::ScalarEvolution *v8;
  const llvm::SCEV **v9;
  char v10;
  llvm::SCEV **v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  llvm::SCEV *v17;
  uint64_t v18;
  llvm::ScalarEvolution *v19;
  int v20;
  const llvm::SCEV **v21;
  const llvm::SCEV *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const llvm::SCEV *v26;
  llvm::SCEV *v27[2];
  int v28;
  llvm::SCEV *v29;
  void *v30;
  uint64_t v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v30 = v32;
  v31 = 0x200000000;
  Type = llvm::SCEV::getType(*(llvm::SCEV **)(a1 + 8));
  v5 = *(_QWORD *)(a2 + 40);
  if (v5)
  {
    v6 = Type;
    v7 = *(llvm::SCEV ***)(a2 + 32);
    v8 = *v7;
    if (Type == llvm::SCEV::getType(*v7))
    {
      v10 = 0;
      v11 = &v7[v5];
      while (1)
      {
        if ((v10 & 1) == 0)
        {
          v27[0] = 0;
          v29 = 0;
          llvm::SCEVDivision::divide(*(llvm::SCEVDivision **)a1, v8, *(const llvm::SCEV ****)(a1 + 8), (const llvm::SCEV *)v27, &v29, v9);
          if (!llvm::SCEV::isZero(v29))
          {
            v14 = v31;
            if (v31 >= (unint64_t)HIDWORD(v31))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, (uint64_t)v32, v31 + 1, 8);
              v14 = v31;
            }
            *((_QWORD *)v30 + v14) = v8;
            LODWORD(v31) = v31 + 1;
            if (++v7 == v11)
              goto LABEL_18;
            v10 = 0;
            goto LABEL_9;
          }
          v8 = v27[0];
          if (v6 != llvm::SCEV::getType(v27[0]))
            goto LABEL_19;
        }
        v12 = v31;
        if (v31 >= (unint64_t)HIDWORD(v31))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, (uint64_t)v32, v31 + 1, 8);
          v12 = v31;
        }
        *((_QWORD *)v30 + v12) = v8;
        v13 = v31 + 1;
        LODWORD(v31) = v31 + 1;
        if (++v7 == v11)
        {
          *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 32);
          if (v13 == 1)
            *(_QWORD *)(a1 + 16) = *(_QWORD *)v30;
          else
            *(_QWORD *)(a1 + 16) = llvm::ScalarEvolution::getMulExpr(*(_QWORD *)a1, (uint64_t)&v30, 0, 0);
          goto LABEL_20;
        }
        v10 = 1;
LABEL_9:
        v8 = *v7;
        if (v6 != llvm::SCEV::getType(*v7))
          goto LABEL_19;
      }
    }
    goto LABEL_19;
  }
LABEL_18:
  v15 = *(_QWORD *)(a1 + 8);
  if (*(_WORD *)(v15 + 24) != 14)
  {
LABEL_19:
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 24) = a2;
    goto LABEL_20;
  }
  v27[0] = 0;
  v27[1] = 0;
  v28 = 0;
  v16 = *(_QWORD *)(a1 + 32);
  v29 = *(llvm::SCEV **)(v15 - 8);
  sub_1C6180A54((uint64_t)v27, (uint64_t *)&v29)[1] = v16;
  v17 = (llvm::SCEV *)sub_1C61B465C(a2, *(_QWORD *)a1, (uint64_t)v27);
  *(_QWORD *)(a1 + 24) = v17;
  if (llvm::SCEV::isZero(v17))
  {
    v23 = *(_QWORD *)(a1 + 40);
    v24 = *(_QWORD *)(a1 + 8);
    if (v24)
      v25 = v24 - 32;
    else
      v25 = 0;
    v29 = *(llvm::SCEV **)(v25 + 24);
    sub_1C6180A54((uint64_t)v27, (uint64_t *)&v29)[1] = v23;
    *(_QWORD *)(a1 + 16) = sub_1C61B465C(a2, *(_QWORD *)a1, (uint64_t)v27);
    goto LABEL_30;
  }
  v29 = 0;
  v26 = 0;
  llvm::ScalarEvolution::getMinusSCEV(*(_QWORD *)a1, a2, (uint64_t)v17);
  v19 = (llvm::ScalarEvolution *)v18;
  v20 = sub_1C4F614A8(v18);
  if (v20 <= (int)sub_1C4F614A8(a2))
  {
    llvm::SCEVDivision::divide(*(llvm::SCEVDivision **)a1, v19, *(const llvm::SCEV ****)(a1 + 8), (const llvm::SCEV *)&v29, &v26, v21);
    v22 = *(const llvm::SCEV **)(a1 + 32);
    if (v26 == v22)
    {
      *(_QWORD *)(a1 + 16) = v29;
      goto LABEL_30;
    }
  }
  else
  {
    v22 = *(const llvm::SCEV **)(a1 + 32);
  }
  *(_QWORD *)(a1 + 16) = v22;
  *(_QWORD *)(a1 + 24) = a2;
LABEL_30:
  MEMORY[0x1CAA32FB4](v27[0], 8);
LABEL_20:
  if (v30 != v32)
    free(v30);
}

uint64_t sub_1C61B465C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v6 = 0;
  v7 = 0;
  v5 = a2;
  v8 = 0;
  v9 = a3;
  v3 = sub_1C61B4734((uint64_t)&v5, a1);
  MEMORY[0x1CAA32FB4](v6, 8);
  return v3;
}

llvm::SCEVDivision *llvm::SCEVDivision::SCEVDivision(llvm::SCEVDivision *this, llvm::ScalarEvolution *a2, const llvm::SCEV *a3, const llvm::SCEV *a4)
{
  llvm::Type *Type;
  llvm::ScalarEvolution *v9;
  llvm::Type *v10;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a4;
  Type = (llvm::Type *)llvm::SCEV::getType(a4);
  *((_QWORD *)this + 4) = llvm::ScalarEvolution::getConstant(a2, Type, 0, 0);
  v9 = *(llvm::ScalarEvolution **)this;
  v10 = (llvm::Type *)llvm::SCEV::getType(a4);
  *((_QWORD *)this + 5) = llvm::ScalarEvolution::getConstant(v9, v10, 1, 0);
  *((_QWORD *)this + 2) = *((_QWORD *)this + 4);
  *((_QWORD *)this + 3) = a3;
  return this;
}

uint64_t sub_1C61B4734(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[3];
  uint64_t v8;
  uint64_t v9;

  v8 = a2;
  v9 = a2;
  v4 = a1 + 8;
  v7[0] = 0;
  if (!sub_1C4DA97DC((uint64_t *)(a1 + 8), &v9, v7)
    || (v5 = v7[0], v7[0] == *(_QWORD *)(a1 + 8) + 16 * *(unsigned int *)(a1 + 24)))
  {
    v9 = sub_1C61B47CC(a1, a2);
    sub_1C4F61600((uint64_t)v7, v4, &v8, &v9);
    v5 = v7[0];
  }
  return *(_QWORD *)(v5 + 8);
}

uint64_t sub_1C61B47CC(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)(void))((char *)sub_1C61B47E8 + 4 * byte_1C85F62AB[*(unsigned __int16 *)(a2 + 24)]))();
}

uint64_t sub_1C61B47E8(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1C61B4824(uint64_t a1, uint64_t a2)
{
  return sub_1C61B482C(a1, a2 - 32);
}

uint64_t sub_1C61B482C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(a2 + 24);
  v8 = 0;
  if ((sub_1C6144BDC(*(_QWORD *)v4, *(_DWORD *)(v4 + 16), v5, &v8) & 1) != 0)
    v6 = v8;
  else
    v6 = *(_QWORD *)v4 + 16 * *(unsigned int *)(v4 + 16);
  if (v6 == **(_QWORD **)(a1 + 32) + 16 * *(unsigned int *)(*(_QWORD *)(a1 + 32) + 16))
    return a2 + 32;
  else
    return *(_QWORD *)(v6 + 8);
}

uint64_t llvm::normalizeForPostIncUse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  BOOL (*v10)(uint64_t *, uint64_t);
  uint64_t *v11;
  uint64_t v12;

  v12 = a2;
  v6 = 0;
  v7 = 0;
  v5 = a3;
  v9 = 0;
  v8 = 0;
  v10 = sub_1C4F62CB4;
  v11 = &v12;
  v3 = sub_1C4F6231C((uint64_t)&v5, a1);
  MEMORY[0x1CAA32FB4](v6, 8);
  return v3;
}

uint64_t llvm::normalizeForPostIncUseIf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v7 = 0;
  v8 = 0;
  v6 = a4;
  v10 = 0;
  v9 = 0;
  v11 = a2;
  v12 = a3;
  v4 = sub_1C4F6231C((uint64_t)&v6, a1);
  MEMORY[0x1CAA32FB4](v7, 8);
  return v4;
}

uint64_t llvm::denormalizeForPostIncUse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  BOOL (*v10)(uint64_t *, uint64_t);
  uint64_t *v11;
  uint64_t v12;

  v12 = a2;
  v6 = 0;
  v7 = 0;
  v5 = a3;
  v8 = 0;
  v9 = 1;
  v10 = sub_1C4F62D00;
  v11 = &v12;
  v3 = sub_1C4F6231C((uint64_t)&v5, a1);
  MEMORY[0x1CAA32FB4](v6, 8);
  return v3;
}

uint64_t llvm::StackLifetime::getLiveRange(llvm::StackLifetime *this, const llvm::AllocaInst *a2)
{
  uint64_t v3;
  uint64_t v5;
  const llvm::AllocaInst *v6;

  v5 = 0;
  v6 = a2;
  if (sub_1C61252B8((uint64_t *)this + 77, &v6, &v5))
    v3 = v5;
  else
    v3 = *((_QWORD *)this + 77) + 16 * *((unsigned int *)this + 158);
  return *((_QWORD *)this + 80) + 72 * *(unsigned int *)(v3 + 8);
}

BOOL llvm::StackLifetime::isReachable(llvm::StackLifetime *this, const llvm::Instruction *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;

  v3 = *((_QWORD *)a2 + 5);
  v8 = 0;
  v9 = v3;
  if (sub_1C61252B8((uint64_t *)this + 71, &v9, &v8))
  {
    v4 = v8;
    v5 = *((_QWORD *)this + 71);
    v6 = *((unsigned int *)this + 146);
  }
  else
  {
    v5 = *((_QWORD *)this + 71);
    v6 = *((unsigned int *)this + 146);
    v4 = v5 + 16 * v6;
  }
  return v4 != v5 + 16 * v6;
}

uint64_t llvm::StackLifetime::isAliveAfter(llvm::StackLifetime *this, const llvm::AllocaInst *a2, const llvm::Instruction *a3)
{
  const llvm::AllocaInst *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const llvm::Instruction **v12;
  const llvm::Instruction **v13;
  const llvm::Instruction *v14;
  uint64_t v15;
  uint64_t v17;
  const llvm::AllocaInst *v18;

  v6 = (const llvm::AllocaInst *)*((_QWORD *)a3 + 5);
  v17 = 0;
  v18 = v6;
  if (sub_1C61252B8((uint64_t *)this + 71, &v18, &v17))
    v7 = v17;
  else
    v7 = *((_QWORD *)this + 71) + 16 * *((unsigned int *)this + 146);
  v8 = *((_QWORD *)this + 5);
  v9 = v8 + 8 * *(unsigned int *)(v7 + 8) + 8;
  v10 = 8 * *(unsigned int *)(v7 + 12) - (8 * *(unsigned int *)(v7 + 8) + 8);
  if (v10)
  {
    v11 = v10 >> 3;
    do
    {
      v12 = (const llvm::Instruction **)(v9 + 8 * (v11 >> 1));
      v14 = *v12;
      v13 = v12 + 1;
      if (llvm::Instruction::comesBefore(a3, v14))
      {
        v11 >>= 1;
      }
      else
      {
        v9 = (uint64_t)v13;
        v11 += ~(v11 >> 1);
      }
    }
    while (v11);
    v8 = *((_QWORD *)this + 5);
  }
  v17 = 0;
  v18 = a2;
  if (sub_1C61252B8((uint64_t *)this + 77, &v18, &v17))
    v15 = v17;
  else
    v15 = *((_QWORD *)this + 77) + 16 * *((unsigned int *)this + 158);
  return (*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 80) + 72 * *(unsigned int *)(v15 + 8))
                    + 8 * (((unint64_t)(v9 - v8 - 8) >> 9) & 0x3FFFFFF)) >> ((unint64_t)(v9 - v8 - 8) >> 3)) & 1;
}

void sub_1C61B4BCC(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;
  void *__p;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  if (a2)
    v3 = a2 - 24;
  else
    v3 = 0;
  sub_1C61AF79C((uint64_t)&v12, v3);
  v8 = 0;
  __p = 0;
  memset(v7, 0, sizeof(v7));
  v4 = (char *)v7 + 8;
  v5 = (char *)v7 + 8;
  v6 = 8;
  v10 = 0;
  v11 = 0;
  sub_1C6187CC0(a1, (uint64_t)&v12, (uint64_t)&v4);
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }
  if (v5 != v4)
    free(v5);
  if (v14)
  {
    v15 = v14;
    operator delete(v14);
  }
  if (v13 != v12)
    free(v13);
}

uint64_t sub_1C61B4C88(uint64_t a1, uint64_t a2, uint64_t *a3, int *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;

  v12 = 0;
  result = sub_1C61B5C98(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *a3, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    v9 = sub_1C61B5D34(a2, a3, v12);
    *v9 = *a3;
    result = sub_1C61B5F80((uint64_t)(v9 + 1), *a4);
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 296 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

int *sub_1C61B4D30(int *a1)
{
  int v2;
  int *v3;
  uint64_t v4;
  int *result;
  uint64_t v6;
  int *v7;

  v2 = *a1;
  if (*a1 > 1)
  {
    if ((v2 & 1) != 0)
    {
      result = a1 + 2;
      v7 = a1 + 18;
LABEL_9:
      while ((*(_QWORD *)result | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        result += 4;
        if (result == v7)
          return v7;
      }
    }
    else
    {
      result = (int *)*((_QWORD *)a1 + 1);
      v6 = a1[4];
      if ((_DWORD)v6)
      {
        v7 = &result[4 * v6];
        goto LABEL_9;
      }
    }
  }
  else
  {
    if (v2)
    {
      v3 = a1 + 2;
      v4 = 4;
    }
    else
    {
      v3 = (int *)*((_QWORD *)a1 + 1);
      v4 = a1[4];
    }
    return &v3[4 * v4];
  }
  return result;
}

uint64_t sub_1C61B4DA4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v6 = 0;
  if ((sub_1C61B5A68(a1, a2, &v6) & 1) != 0)
    return v6;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = a1 + 8;
    v5 = 4;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 16 * v5;
}

llvm *llvm::StackLifetime::dumpAllocas(llvm::StackLifetime *this)
{
  llvm *v2;
  llvm *result;
  unint64_t v4;
  llvm *v5;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;

  v2 = llvm::dbgs(this);
  result = sub_1C4816AD8(v2, "Allocas:\n");
  if (*((_DWORD *)this + 152))
  {
    v4 = 0;
    do
    {
      v5 = llvm::dbgs(result);
      v6 = sub_1C4816AD8(v5, "  ");
      sub_1C5E21910(v6, v4, 0, 0, 0);
      v7 = sub_1C4816AD8(v6, ": ");
      llvm::Value::print(*(llvm::Value **)(*((_QWORD *)this + 74) + 8 * v4), v7, 0);
      result = sub_1C4816AD8(v7, "\n");
      ++v4;
    }
    while (v4 < *((unsigned int *)this + 152));
  }
  return result;
}

llvm *llvm::StackLifetime::dumpLiveRanges(llvm::StackLifetime *this)
{
  llvm *v2;
  llvm *result;
  uint64_t v4;
  unint64_t v5;
  llvm *v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm::raw_ostream *v9;

  v2 = llvm::dbgs(this);
  result = sub_1C4816AD8(v2, "Alloca liveness:\n");
  if (*((_DWORD *)this + 152))
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = llvm::dbgs(result);
      v7 = sub_1C4816AD8(v6, "  ");
      sub_1C5E21910(v7, v5, 0, 0, 0);
      v8 = sub_1C4816AD8(v7, ": ");
      v9 = sub_1C4F64FB4(v8, *((_QWORD *)this + 80) + v4);
      result = sub_1C4816AD8(v9, "\n");
      ++v5;
      v4 += 72;
    }
    while (v5 < *((unsigned int *)this + 152));
  }
  return result;
}

llvm::StackLifetime *llvm::StackLifetime::StackLifetime(llvm::StackLifetime *this, uint64_t a2, _QWORD *a3, uint64_t a4, int a5)
{
  uint64_t *v6;
  _QWORD *v7;
  unint64_t v8;

  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = a5;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = (char *)this + 56;
  *((_QWORD *)this + 6) = 0x4000000000;
  *((_DWORD *)this + 146) = 0;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((_QWORD *)this + 74) = a3;
  *((_QWORD *)this + 75) = a4;
  *((_DWORD *)this + 152) = a4;
  v6 = (uint64_t *)((char *)this + 616);
  *((_DWORD *)this + 158) = 0;
  *(_OWORD *)((char *)this + 616) = 0u;
  *((_QWORD *)this + 80) = (char *)this + 656;
  *((_QWORD *)this + 81) = 0x800000000;
  *((_QWORD *)this + 154) = (char *)this + 1248;
  *((_QWORD *)this + 155) = 0x600000000;
  *((_DWORD *)this + 324) = 0;
  *((_BYTE *)this + 1328) = 0;
  *((_DWORD *)this + 330) = 0;
  *(_OWORD *)((char *)this + 1304) = 0u;
  if ((_DWORD)a4)
  {
    v7 = a3;
    v8 = 0;
    do
      *((_DWORD *)sub_1C61AC530(v6, v7++) + 2) = v8++;
    while (v8 < *((unsigned int *)this + 152));
  }
  llvm::StackLifetime::collectMarkers(this);
  return this;
}

void llvm::StackLifetime::run(llvm::StackLifetime *this)
{
  int v2;
  unint64_t v3;
  int v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  char *v9;
  unint64_t v10;
  int v11;
  void *v12;
  char *v13;
  unint64_t v14;
  void *v15;
  uint64_t v16;
  _BYTE v17[48];
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 1328))
  {
    v2 = *((_DWORD *)this + 2);
    if (v2 == 1)
    {
      v9 = (char *)this + 640;
      v10 = *((unsigned int *)this + 152);
      v11 = *((_DWORD *)this + 12);
      v15 = v17;
      v16 = 0x600000000;
      sub_1C4765AA4((char *)&v15, (v11 + 63) >> 6, 0);
      v18 = v11;
      sub_1C61B5280((uint64_t)v9, v10, (unint64_t)&v15);
      v12 = v15;
      if (v15 != v17)
LABEL_19:
        free(v12);
    }
    else if (!v2)
    {
      v13 = (char *)this + 640;
      v14 = *((unsigned int *)this + 152);
      sub_1C496F858((uint64_t)&v15, *((_DWORD *)this + 12), 1);
      sub_1C61B5280((uint64_t)v13, v14, (unint64_t)&v15);
      v12 = v15;
      if (v15 != v17)
        goto LABEL_19;
    }
  }
  else
  {
    v3 = *((unsigned int *)this + 152);
    v4 = *((_DWORD *)this + 12);
    v15 = v17;
    v16 = 0x600000000;
    sub_1C4765AA4((char *)&v15, (v4 + 63) >> 6, 0);
    v18 = v4;
    sub_1C61B5280((uint64_t)this + 640, v3, (unint64_t)&v15);
    if (v15 != v17)
      free(v15);
    v5 = *((unsigned int *)this + 152);
    if ((_DWORD)v5)
    {
      v6 = 0;
      v7 = 64;
      do
      {
        if (((*(_QWORD *)(*((_QWORD *)this + 154) + 8 * (v6 >> 6)) >> v6) & 1) == 0)
        {
          sub_1C496F858((uint64_t)&v15, *((_DWORD *)this + 12), 1);
          v8 = (_DWORD *)(*((_QWORD *)this + 80) + v7);
          sub_1C476B4F4((uint64_t)(v8 - 16), (uint64_t)&v15);
          *v8 = v18;
          if (v15 != v17)
            free(v15);
          v5 = *((unsigned int *)this + 152);
        }
        ++v6;
        v7 += 72;
      }
      while (v6 < v5);
    }
    llvm::StackLifetime::calculateLocalLiveness(this);
    llvm::StackLifetime::calculateLiveIntervals((uint64_t)this);
  }
}

void sub_1C61B5280(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v8;
  void **v9;
  uint64_t v10;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6)
  {
    if (v5)
    {
      sub_1C61B6368(a1, v6, a3);
    }
    else
    {
      v8 = 9 * v4;
      v9 = (void **)(*(_QWORD *)a1 + 8 * v8 - 72);
      v10 = 72 * a2 - 8 * v8;
      do
      {
        if (v9 + 2 != *v9)
          free(*v9);
        v9 -= 9;
        v10 += 72;
      }
      while (v10);
      *(_DWORD *)(a1 + 8) = a2;
    }
  }
}

llvm::raw_ostream *llvm::StackLifetimePrinterPass::printPipeline(_DWORD *a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, char *, uint64_t), uint64_t a4)
{
  char *v6;

  sub_1C61B538C(a2, a3, a4);
  sub_1C4816AD8(a2, "<");
  if (!*a1)
  {
    v6 = "may";
    goto LABEL_5;
  }
  if (*a1 == 1)
  {
    v6 = "must";
LABEL_5:
    sub_1C4816AD8(a2, v6);
  }
  return sub_1C4816AD8(a2, ">");
}

llvm::raw_ostream *sub_1C61B538C(llvm::raw_ostream *a1, uint64_t (*a2)(uint64_t, char *, uint64_t), uint64_t a3)
{
  char *v6;
  uint64_t v7;
  size_t v8;
  const char *v9;
  size_t v10;
  llvm::raw_ostream *result;

  v6 = sub_1C4F662C8();
  v9 = (const char *)a2(a3, v6, v7);
  v10 = v8;
  result = (llvm::raw_ostream *)*((_QWORD *)a1 + 4);
  if (v8 > *((_QWORD *)a1 + 3) - (_QWORD)result)
    return llvm::raw_ostream::write(a1, v9, v8);
  if (v8)
  {
    result = (llvm::raw_ostream *)memcpy(result, v9, v8);
    *((_QWORD *)a1 + 4) += v10;
  }
  return result;
}

uint64_t sub_1C61B5424(uint64_t a1, _DWORD *a2)
{
  int v4;
  int v5;
  int v6;

  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0x600000000;
  if (a2[2])
    sub_1C49DA960(a1, (uint64_t)a2);
  v4 = a2[16];
  *(_QWORD *)(a1 + 72) = a1 + 88;
  *(_DWORD *)(a1 + 64) = v4;
  *(_QWORD *)(a1 + 80) = 0x600000000;
  if (a2[20])
    sub_1C49DA960(a1 + 72, (uint64_t)(a2 + 18));
  v5 = a2[34];
  *(_QWORD *)(a1 + 144) = a1 + 160;
  *(_DWORD *)(a1 + 136) = v5;
  *(_QWORD *)(a1 + 152) = 0x600000000;
  if (a2[38])
    sub_1C49DA960(a1 + 144, (uint64_t)(a2 + 36));
  v6 = a2[52];
  *(_QWORD *)(a1 + 216) = a1 + 232;
  *(_DWORD *)(a1 + 208) = v6;
  *(_QWORD *)(a1 + 224) = 0x600000000;
  if (a2[56])
    sub_1C49DA960(a1 + 216, (uint64_t)(a2 + 54));
  *(_DWORD *)(a1 + 280) = a2[70];
  return a1;
}

uint64_t sub_1C61B54F8(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = *(void **)(a1 + 216);
  if (v2 != (void *)(a1 + 232))
    free(v2);
  v3 = *(void **)(a1 + 144);
  if (v3 != (void *)(a1 + 160))
    free(v3);
  v4 = *(void **)(a1 + 72);
  if (v4 != (void *)(a1 + 88))
    free(v4);
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  return a1;
}

void sub_1C61B5568()
{
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61B557C(uint64_t a1, uint64_t a2, llvm::raw_ostream *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = *(_QWORD *)(a1 + 8);
  v7 = 0;
  v8 = a2;
  if (sub_1C61252B8((uint64_t *)(v5 + 568), &v8, &v7))
    v6 = v7;
  else
    v6 = *(_QWORD *)(v5 + 568) + 16 * *(unsigned int *)(v5 + 584);
  if (v6 != *(_QWORD *)(*(_QWORD *)(a1 + 8) + 568) + 16 * *(unsigned int *)(*(_QWORD *)(a1 + 8) + 584))
    sub_1C4F65798(a1, *(_DWORD *)(v6 + 8), a3);
}

uint64_t sub_1C61B5604(uint64_t a1, uint64_t a2)
{
  char v5;
  char v6;

  if (sub_1C4E4FA7C((uint64_t)&v6, a1, a2))
    return 0xFFFFFFFFLL;
  else
    return sub_1C4E4FA7C((uint64_t)&v5, a2, a1);
}

void sub_1C61B5658(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v1 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v1)
  {
    v2 = 72 * v1;
    v3 = *(_QWORD *)a1 + 24;
    do
    {
      if ((*(_QWORD *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4)
          free(v4);
      }
      v3 += 72;
      v2 -= 72;
    }
    while (v2);
  }
}

char **sub_1C61B56BC(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 72 * v3;
    do
    {
      v5 = *(char **)&v2[v4 - 72];
      if (&v2[v4 - 56] != v5)
        free(v5);
      v4 -= 72;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

_QWORD *sub_1C61B5730(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;
  uint64_t i;
  _QWORD *v9;

  v9 = 0;
  v4 = sub_1C61B57BC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v9);
  v5 = v9;
  if ((v4 & 1) == 0)
  {
    v7 = sub_1C61B5858(a1, a2, v9);
    v5 = v7;
    *v7 = *a2;
    v7[1] = 1;
    for (i = 2; i != 10; i += 2)
      v7[i] = -4096;
  }
  return v5;
}

uint64_t sub_1C61B57BC(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 80 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 80 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61B5858(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4F65BC0(a1, v6);
  v8 = 0;
  sub_1C61B57BC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

unsigned int *sub_1C61B5908(unsigned int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unsigned int *v13;
  _QWORD *v14;

  v4 = a2;
  v5 = result;
  *((_QWORD *)result + 1) = 0;
  v6 = result[4];
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 80 * v6;
    do
    {
      *v7 = -4096;
      v7 += 10;
      v8 -= 80;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v14 = 0;
        sub_1C61B57BC(*(_QWORD *)v5, v5[4], v9, &v14);
        v10 = 0;
        v11 = v14;
        *v14 = *(_QWORD *)v4;
        v12 = v11 + 2;
        v11[1] = 1;
        v13 = (unsigned int *)(v11 + 1);
        do
        {
          v12[v10] = -4096;
          v10 += 2;
        }
        while (v10 != 8);
        result = sub_1C4F65C84(v13, (unsigned int *)(v4 + 8));
        ++v5[2];
        if ((*(_BYTE *)(v4 + 8) & 1) == 0)
          result = (unsigned int *)MEMORY[0x1CAA32FB4](*(_QWORD *)(v4 + 16), 8);
      }
      v4 += 80;
    }
    while (v4 != a3);
  }
  return result;
}

_QWORD *sub_1C61B5A08(_DWORD *a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61B5A68((uint64_t)a1, *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61B5B14(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t sub_1C61B5A68(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 16 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 16 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61B5B14(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 4;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C4F65E04((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61B5A68((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

uint64_t sub_1C61B5BD0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 72);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[2 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      result = sub_1C61B5A68((uint64_t)v5, v10, &v12);
      v11 = v12;
      *v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1C61B5C98(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 296 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 296 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61B5D34(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4F65F7C(a1, v6);
  v8 = 0;
  sub_1C61B5C98(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61B5DE4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 296 * v6;
    do
    {
      *v7 = -4096;
      v7 += 37;
      v8 -= 296;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      sub_1C61B5C98(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_QWORD *)a2;
      sub_1C61B5EAC((uint64_t)(v10 + 1), (_DWORD *)(a2 + 8));
      ++*(_DWORD *)(v5 + 8);
      result = sub_1C61B54F8(a2 + 8);
    }
    a2 += 296;
  }
  return result;
}

uint64_t sub_1C61B5EAC(uint64_t a1, _DWORD *a2)
{
  int v4;
  int v5;
  int v6;

  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0x600000000;
  if (a2[2])
    sub_1C476B4F4(a1, (uint64_t)a2);
  v4 = a2[16];
  *(_QWORD *)(a1 + 72) = a1 + 88;
  *(_DWORD *)(a1 + 64) = v4;
  *(_QWORD *)(a1 + 80) = 0x600000000;
  if (a2[20])
    sub_1C476B4F4(a1 + 72, (uint64_t)(a2 + 18));
  v5 = a2[34];
  *(_QWORD *)(a1 + 144) = a1 + 160;
  *(_DWORD *)(a1 + 136) = v5;
  *(_QWORD *)(a1 + 152) = 0x600000000;
  if (a2[38])
    sub_1C476B4F4(a1 + 144, (uint64_t)(a2 + 36));
  v6 = a2[52];
  *(_QWORD *)(a1 + 216) = a1 + 232;
  *(_DWORD *)(a1 + 208) = v6;
  *(_QWORD *)(a1 + 224) = 0x600000000;
  if (a2[56])
    sub_1C476B4F4(a1 + 216, (uint64_t)(a2 + 54));
  *(_DWORD *)(a1 + 280) = a2[70];
  return a1;
}

uint64_t sub_1C61B5F80(uint64_t a1, int a2)
{
  unint64_t v4;

  v4 = (a2 + 63) >> 6;
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0x600000000;
  sub_1C4765AA4((char *)a1, v4, 0);
  *(_DWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a1 + 88;
  *(_QWORD *)(a1 + 80) = 0x600000000;
  sub_1C4765AA4((char *)(a1 + 72), v4, 0);
  *(_DWORD *)(a1 + 136) = a2;
  *(_QWORD *)(a1 + 144) = a1 + 160;
  *(_QWORD *)(a1 + 152) = 0x600000000;
  sub_1C4765AA4((char *)(a1 + 144), v4, 0);
  *(_DWORD *)(a1 + 208) = a2;
  *(_QWORD *)(a1 + 216) = a1 + 232;
  *(_QWORD *)(a1 + 224) = 0x600000000;
  sub_1C4765AA4((char *)(a1 + 216), v4, 0);
  *(_DWORD *)(a1 + 280) = a2;
  return a1;
}

_QWORD *sub_1C61B6040(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61252B8(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61B60A0((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61B60A0(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4DFEC00(a1, v7);
  v9 = 0;
  sub_1C61252B8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

_QWORD *sub_1C61B614C(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61A4EFC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61B61C4(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x400000000;
  }
  return v5;
}

_QWORD *sub_1C61B61C4(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4F66044(a1, v6);
  v8 = 0;
  sub_1C61A4EFC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61B6274(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 72 * v6;
    do
    {
      *v7 = -4096;
      v7 += 9;
      v8 -= 72;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61A4EFC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C4F66108(v11, (uint64_t *)(v4 + 8));
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 72;
    }
    while (v4 != a3);
  }
}

unint64_t sub_1C61B6368(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1C4F66260(a1, a3, a2);
  if (a2)
  {
    v6 = result;
    v7 = *(_QWORD *)a1 + 72 * *(unsigned int *)(a1 + 8);
    v8 = a2;
    do
    {
      *(_QWORD *)v7 = v7 + 16;
      *(_QWORD *)(v7 + 8) = 0x600000000;
      if (*(_DWORD *)(v6 + 8))
        result = sub_1C49DA960(v7, v6);
      *(_DWORD *)(v7 + 64) = *(_DWORD *)(v6 + 64);
      v7 += 72;
      --v8;
    }
    while (v8);
  }
  *(_DWORD *)(a1 + 8) += a2;
  return result;
}

void sub_1C61B6410(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 72, &v5);
  sub_1C61B647C(a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61B647C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v5 = *(_QWORD *)a1;
    v6 = 72 * v2;
    do
    {
      *(_QWORD *)a2 = a2 + 16;
      *(_QWORD *)(a2 + 8) = 0x600000000;
      if (*(_DWORD *)(v5 + 8))
        sub_1C476B4F4(a2, v5);
      *(_DWORD *)(a2 + 64) = *(_DWORD *)(v5 + 64);
      v5 += 72;
      a2 += 72;
      v6 -= 72;
    }
    while (v6);
    v7 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v7)
    {
      v8 = *(_QWORD *)a1;
      v9 = 72 * v7;
      do
      {
        v10 = *(void **)(v8 + v9 - 72);
        if ((void *)(v8 + v9 - 56) != v10)
          free(v10);
        v9 -= 72;
      }
      while (v9);
    }
  }
}

llvm::raw_ostream *llvm::StackSafetyInfo::print(llvm::StackSafetyInfo *this, llvm::raw_ostream *a2)
{
  uint64_t *Info;
  llvm::Value *v5;
  char *Name;
  size_t v7;

  Info = llvm::StackSafetyInfo::getInfo(this);
  v5 = *(llvm::Value **)this;
  Name = llvm::Value::getName(v5);
  sub_1C4F66D18(Info, a2, Name, v7, (uint64_t)v5);
  return sub_1C4816AD8(a2, "\n");
}

char *sub_1C61B6668(uint64_t *a1, unsigned int a2, uint64_t a3)
{
  _QWORD *v4;
  char *result;

  v4 = (_QWORD *)a1[1];
  if ((unint64_t)v4 >= a1[2])
  {
    result = sub_1C4F6F230(a1, a2, a3);
  }
  else
  {
    *v4 = a2;
    sub_1C4E94384((uint64_t)(v4 + 1), a3);
    result = (char *)(v4 + 8);
    v4[5] = 0;
    v4[6] = 0;
    v4[7] = 0;
  }
  a1[1] = (uint64_t)result;
  return result;
}

void sub_1C61B66C0(uint64_t a1, unint64_t a2)
{
  _BYTE *v2;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;

  v2 = *(_BYTE **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556)
      abort();
    v4 = *(_BYTE **)(a1 + 8);
    v5 = 3 * a2;
    v6 = (char *)operator new(48 * a2);
    v7 = &v6[16 * v5];
    v8 = &v6[v4 - v2];
    if (v4 == v2)
    {
      *(_QWORD *)a1 = v8;
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = v7;
    }
    else
    {
      v9 = 0;
      do
      {
        v10 = &v8[v9];
        v11 = &v4[v9];
        *((_OWORD *)v10 - 3) = *(_OWORD *)&v4[v9 - 48];
        *((_DWORD *)v10 - 6) = *(_DWORD *)&v4[v9 - 24];
        *((_QWORD *)v10 - 4) = *(_QWORD *)&v4[v9 - 32];
        *((_DWORD *)v11 - 6) = 0;
        *((_DWORD *)v10 - 2) = *(_DWORD *)&v4[v9 - 8];
        *((_QWORD *)v10 - 2) = *(_QWORD *)&v4[v9 - 16];
        *((_DWORD *)v11 - 2) = 0;
        v9 -= 48;
      }
      while (&v4[v9] != v2);
      *(_QWORD *)a1 = &v8[v9];
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = v7;
      do
      {
        sub_1C4E8C6FC((uint64_t)(v4 - 32));
        v4 -= 48;
      }
      while (v4 != v2);
    }
    if (v2)
      operator delete(v2);
  }
}

char *sub_1C61B67D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  char *result;

  v5 = *(uint64_t **)(a1 + 8);
  if ((unint64_t)v5 >= *(_QWORD *)(a1 + 16))
  {
    result = sub_1C4F6F488((void **)a1, a2, a3, a4);
  }
  else
  {
    *v5 = a2;
    v5[1] = a3;
    sub_1C4E94384((uint64_t)(v5 + 2), a4);
    result = (char *)(v5 + 6);
  }
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

llvm::StackSafetyGlobalInfo *llvm::StackSafetyGlobalInfo::StackSafetyGlobalInfo(llvm::StackSafetyGlobalInfo *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;

  *(_QWORD *)a1 = a2;
  v6 = (_QWORD *)((char *)a1 + 8);
  v7 = *(_QWORD *)(a3 + 24);
  if (v7)
  {
    if (v7 == a3)
    {
      *((_QWORD *)a1 + 4) = v6;
      (*(void (**)(_QWORD))(**(_QWORD **)(a3 + 24) + 24))(*(_QWORD *)(a3 + 24));
    }
    else
    {
      *((_QWORD *)a1 + 4) = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 16))(v7, v6);
    }
  }
  else
  {
    *((_QWORD *)a1 + 4) = 0;
  }
  *((_QWORD *)a1 + 5) = a4;
  *((_QWORD *)a1 + 6) = 0;
  if (byte_1ED7F4478)
    llvm::StackSafetyGlobalInfo::getInfo(a1);
  return a1;
}

_QWORD *llvm::StackSafetyGlobalInfo::operator=(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

  *a1 = *a2;
  sub_1C48AAFD8(a1 + 1, (uint64_t)(a2 + 1));
  a1[5] = a2[5];
  v4 = a2[6];
  a2[6] = 0;
  v5 = a1[6];
  a1[6] = v4;
  if (v5)
  {
    v7 = sub_1C61B7C5C(v5);
    MEMORY[0x1CAA32FC0](v7, 0x10E0C40953490F3);
  }
  return a1;
}

void llvm::StackSafetyGlobalInfo::~StackSafetyGlobalInfo(llvm::StackSafetyGlobalInfo *this)
{
  uint64_t v2;
  llvm::StackSafetyGlobalInfo *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
  {
    v5 = sub_1C61B7C5C(v2);
    MEMORY[0x1CAA32FC0](v5, 0x10E0C40953490F3);
  }
  v3 = (llvm::StackSafetyGlobalInfo *)*((_QWORD *)this + 4);
  if (v3 == (llvm::StackSafetyGlobalInfo *)((char *)this + 8))
  {
    v4 = 4;
    v3 = (llvm::StackSafetyGlobalInfo *)((char *)this + 8);
  }
  else
  {
    if (!v3)
      return;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
}

BOOL llvm::StackSafetyGlobalInfo::isSafe(llvm::StackSafetyGlobalInfo *this, const llvm::AllocaInst *a2)
{
  uint64_t Info;
  _QWORD *v4;
  uint64_t v5;
  unsigned int *v6;

  Info = llvm::StackSafetyGlobalInfo::getInfo(this);
  v4 = sub_1C477672C(Info + 24, (uint64_t)a2);
  v5 = *(_QWORD *)(Info + 32);
  if (v5 == *(_QWORD *)(Info + 24))
    v6 = (unsigned int *)(Info + 44);
  else
    v6 = (unsigned int *)(Info + 40);
  return v4 != (_QWORD *)(v5 + 8 * *v6);
}

BOOL llvm::StackSafetyGlobalInfo::stackAccessIsSafe(llvm::StackSafetyGlobalInfo *this, const llvm::Instruction *a2)
{
  uint64_t Info;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  BOOL v9;
  _QWORD *v10;

  Info = llvm::StackSafetyGlobalInfo::getInfo(this);
  v6 = *(_QWORD **)(Info + 128);
  v4 = Info + 128;
  v5 = v6;
  if (!v6)
    goto LABEL_12;
  v7 = (_QWORD *)v4;
  do
  {
    v8 = v5[4];
    v9 = v8 >= (unint64_t)a2;
    if (v8 >= (unint64_t)a2)
      v10 = v5;
    else
      v10 = v5 + 1;
    if (v9)
      v7 = v5;
    v5 = (_QWORD *)*v10;
  }
  while (*v10);
  if (v7 == (_QWORD *)v4 || v7[4] > (unint64_t)a2)
LABEL_12:
    v7 = (_QWORD *)v4;
  return v7 == (_QWORD *)v4;
}

void llvm::StackSafetyGlobalInfo::dump(llvm::StackSafetyGlobalInfo *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  llvm::StackSafetyGlobalInfo::print(this, v2);
}

void llvm::StackSafetyAnalysis::run(uint64_t a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X8>)
{
  *a3 = a1;
  a3[1] = &off_1E813B620;
  a3[2] = a2;
  a3[3] = a1;
  a3[4] = a3 + 1;
  a3[5] = 0;
}

_QWORD *llvm::StackSafetyPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, llvm::Value *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  llvm::raw_ostream *v8;
  size_t v9;
  char *Name;
  size_t v11;
  void *v12;
  uint64_t ResultImpl;

  v8 = sub_1C4816AD8(*a1, "'Stack Safety Local Analysis' for function '");
  Name = llvm::Value::getName(a2);
  v11 = v9;
  v12 = (void *)*((_QWORD *)v8 + 4);
  if (v9 <= *((_QWORD *)v8 + 3) - (_QWORD)v12)
  {
    if (v9)
    {
      memcpy(v12, Name, v9);
      *((_QWORD *)v8 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, Name, v9);
  }
  sub_1C4816AD8(v8, "'\n");
  ResultImpl = llvm::AnalysisManager<llvm::Function>::getResultImpl(a3, &llvm::StackSafetyAnalysis::Key, (uint64_t)a2);
  llvm::StackSafetyInfo::print((llvm::StackSafetyInfo *)(ResultImpl + 8), *a1);
  return llvm::InstCountPass::run(a4);
}

llvm::StackSafetyInfoWrapperPass *llvm::StackSafetyInfoWrapperPass::StackSafetyInfoWrapperPass(llvm::StackSafetyInfoWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::StackSafetyInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(_QWORD *)this = &off_1E813B4B0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EAA0);
  if (v2 != -1)
  {
    v6[0] = sub_1C4F6A950;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EAA0, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeStackSafetyInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82EAA0);
  if (v2 != -1)
  {
    v5[0] = sub_1C4F6A950;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82EAA0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::AnalysisUsage *llvm::StackSafetyInfoWrapperPass::getAnalysisUsage(llvm::StackSafetyInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage *result;

  result = llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::ScalarEvolutionWrapperPass::ID);
  *((_BYTE *)a2 + 160) = 1;
  return result;
}

llvm::raw_ostream *llvm::StackSafetyInfoWrapperPass::print(llvm::StackSafetyInfoWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  return llvm::StackSafetyInfo::print((llvm::StackSafetyInfoWrapperPass *)((char *)this + 32), a2);
}

uint64_t llvm::StackSafetyInfoWrapperPass::runOnFunction(llvm::StackSafetyInfoWrapperPass *this, llvm::Function *a2)
{
  char **v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  void (**v10)(void);
  _QWORD v12[3];
  _QWORD *v13;
  llvm::Function *v14;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v4 = (char **)**((_QWORD **)this + 1);
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != llvm::ScalarEvolutionWrapperPass::ID);
  v6 = *(_QWORD *)((*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), llvm::ScalarEvolutionWrapperPass::ID)+ 32);
  v12[0] = &off_1E813B668;
  v12[1] = v6;
  v13 = v12;
  v14 = a2;
  v15[0] = &off_1E813B668;
  v15[1] = v6;
  v16 = v15;
  v17[0] = 0;
  *((_QWORD *)this + 4) = a2;
  sub_1C48AAFD8((_QWORD *)this + 5, (uint64_t)v15);
  v7 = v17[0];
  v17[0] = 0;
  sub_1C4F66CC4((uint64_t *)this + 9, v7);
  sub_1C4F66CC4(v17, 0);
  v8 = v16;
  if (v16 == v15)
  {
    v9 = 4;
    v8 = v15;
  }
  else
  {
    if (!v16)
      goto LABEL_7;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_7:
  if (v13 == v12)
  {
    v10 = (void (**)(void))(v12[0] + 32);
    goto LABEL_10;
  }
  if (v13)
  {
    v10 = (void (**)(void))(*v13 + 40);
LABEL_10:
    (*v10)();
  }
  return 0;
}

uint64_t llvm::StackSafetyGlobalAnalysis::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, llvm::StackSafetyGlobalInfo *a3@<X8>)
{
  uint64_t v5;
  uint64_t result;
  uint64_t (**v7)(void);
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(llvm::AnalysisManager<llvm::Module>::getResultImpl(a2, &llvm::InnerAnalysisManagerProxy<llvm::AnalysisManager<llvm::Function>,llvm::Module>::Key, a1)+ 8);
  v8[0] = &off_1E813B6B0;
  v8[1] = v5;
  v9 = v8;
  llvm::StackSafetyGlobalInfo::StackSafetyGlobalInfo(a3, a1, (uint64_t)v8, 0);
  result = (uint64_t)v9;
  if (v9 == v8)
  {
    v7 = (uint64_t (**)(void))(v8[0] + 32);
  }
  else
  {
    if (!v9)
      return result;
    v7 = (uint64_t (**)(void))(*v9 + 40);
  }
  return (*v7)();
}

_QWORD *llvm::StackSafetyGlobalPrinterPass::run@<X0>(llvm::raw_ostream **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  llvm::raw_ostream *v8;
  llvm::raw_ostream *v9;
  char v10;
  const void *v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  uint64_t ResultImpl;

  v8 = sub_1C4816AD8(*a1, "'Stack Safety Analysis' for module '");
  v9 = v8;
  v10 = *(_BYTE *)(a2 + 191);
  if (v10 >= 0)
    v11 = (const void *)(a2 + 168);
  else
    v11 = *(const void **)(a2 + 168);
  if (v10 >= 0)
    v12 = v10 & 0x7F;
  else
    v12 = *(_QWORD *)(a2 + 176);
  v14 = *((_QWORD *)v8 + 3);
  v13 = (void *)*((_QWORD *)v8 + 4);
  if (v12 <= v14 - (uint64_t)v13)
  {
    if (v12)
    {
      memcpy(v13, v11, v12);
      *((_QWORD *)v9 + 4) += v12;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, (const char *)v11, v12);
  }
  sub_1C4816AD8(v9, "'\n");
  ResultImpl = llvm::AnalysisManager<llvm::Module>::getResultImpl(a3, &llvm::StackSafetyGlobalAnalysis::Key, a2);
  llvm::StackSafetyGlobalInfo::print((llvm::StackSafetyGlobalInfo *)(ResultImpl + 8), *a1);
  return llvm::InstCountPass::run(a4);
}

llvm::StackSafetyGlobalInfoWrapperPass *llvm::StackSafetyGlobalInfoWrapperPass::StackSafetyGlobalInfoWrapperPass(llvm::StackSafetyGlobalInfoWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::StackSafetyGlobalInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813B550;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EAA8);
  if (v2 != -1)
  {
    v6[0] = sub_1C4F6A9E8;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EAA8, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeStackSafetyGlobalInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82EAA8);
  if (v2 != -1)
  {
    v5[0] = sub_1C4F6A9E8;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82EAA8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::StackSafetyGlobalInfoWrapperPass::print(llvm::StackSafetyGlobalInfoWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  llvm::StackSafetyGlobalInfo::print((llvm::StackSafetyGlobalInfoWrapperPass *)((char *)this + 32), a2);
}

llvm::AnalysisUsage *llvm::StackSafetyGlobalInfoWrapperPass::getAnalysisUsage(llvm::StackSafetyGlobalInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::AnalysisUsage::addRequiredID(a2, llvm::StackSafetyInfoWrapperPass::ID);
}

uint64_t llvm::StackSafetyGlobalInfoWrapperPass::runOnModule(llvm::PMDataManager ***this, llvm::Module *a2)
{
  uint64_t AnalysisIfAvailable;
  uint64_t v5;
  uint64_t v6;
  void (**v7)(void);
  _QWORD v9[3];
  _QWORD *v10;
  _QWORD v11[8];

  v11[7] = *MEMORY[0x1E0C80C00];
  AnalysisIfAvailable = llvm::AnalysisResolver::getAnalysisIfAvailable(this[1], &llvm::ImmutableModuleSummaryIndexWrapperPass::ID);
  if (AnalysisIfAvailable
    && (v5 = (*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)AnalysisIfAvailable + 96))(AnalysisIfAvailable, &llvm::ImmutableModuleSummaryIndexWrapperPass::ID)) != 0)
  {
    v6 = *(_QWORD *)(v5 + 32);
  }
  else
  {
    v6 = 0;
  }
  v9[0] = &off_1E813B6F8;
  v9[1] = this;
  v10 = v9;
  llvm::StackSafetyGlobalInfo::StackSafetyGlobalInfo((llvm::StackSafetyGlobalInfo *)v11, (uint64_t)a2, (uint64_t)v9, v6);
  llvm::StackSafetyGlobalInfo::operator=(this + 4, v11);
  llvm::StackSafetyGlobalInfo::~StackSafetyGlobalInfo((llvm::StackSafetyGlobalInfo *)v11);
  if (v10 == v9)
  {
    v7 = (void (**)(void))(v9[0] + 32);
    goto LABEL_7;
  }
  if (v10)
  {
    v7 = (void (**)(void))(*v10 + 40);
LABEL_7:
    (*v7)();
  }
  return 0;
}

uint64_t sub_1C61B72A0(uint64_t *a1)
{
  unint64_t v2;
  uint64_t v3;

  v2 = a1[1];
  if (v2 >= a1[2])
  {
    v3 = sub_1C4F7378C(a1);
  }
  else
  {
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(_OWORD *)v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    llvm::ConstantRange::ConstantRange((llvm::ConstantRange *)(v2 + 8), 0x40u, 1);
    v3 = v2 + 64;
    *(_QWORD *)(v2 + 40) = 0;
    *(_QWORD *)(v2 + 48) = 0;
    *(_QWORD *)(v2 + 56) = 0;
  }
  a1[1] = v3;
  return v3 - 64;
}

void sub_1C61B7308(_QWORD *a1)
{
  sub_1C61B7830(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61B732C(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a2 < *a1;
}

_QWORD *sub_1C61B7348(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61B73C0(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x400000000;
  }
  return v5;
}

_QWORD *sub_1C61B73C0(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4F6E74C(a1, v6);
  v8 = 0;
  sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61B7470(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 56 * v6;
    do
    {
      *v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C4964480(v11, (const void **)(v4 + 8));
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1C61B7564(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61B75F0(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *a3, &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61B7684(a2, a3, v10);
    v7 = (_QWORD *)result;
    *(_QWORD *)result = *a3;
    v8 = 1;
  }
  v9 = *(_QWORD *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v9;
  *(_BYTE *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1C61B75F0(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 8 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 8 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61B7684(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4F6EC98(a1, v6);
  v8 = 0;
  sub_1C61B75F0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61B7734(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v10 = 0;
      result = sub_1C61B75F0(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v10);
      *v10 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

llvm::StackSafetyInfoWrapperPass *llvm::callDefaultCtor<llvm::StackSafetyInfoWrapperPass>()
{
  llvm::StackSafetyInfoWrapperPass *v0;

  v0 = (llvm::StackSafetyInfoWrapperPass *)operator new();
  return llvm::StackSafetyInfoWrapperPass::StackSafetyInfoWrapperPass(v0);
}

llvm::StackSafetyGlobalInfoWrapperPass *llvm::callDefaultCtor<llvm::StackSafetyGlobalInfoWrapperPass>()
{
  llvm::StackSafetyGlobalInfoWrapperPass *v0;

  v0 = (llvm::StackSafetyGlobalInfoWrapperPass *)operator new();
  return llvm::StackSafetyGlobalInfoWrapperPass::StackSafetyGlobalInfoWrapperPass(v0);
}

void sub_1C61B7830(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E813B4B0;
  sub_1C4F66CC4(a1 + 9, 0);
  v2 = (_QWORD *)a1[8];
  if (v2 == a1 + 5)
  {
    v3 = 4;
    v2 = a1 + 5;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1C61B7894(int **a1, _WORD *a2)
{
  uint64_t v4;
  int *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F4278, 0, 0);
  dword_1ED7F42F8 = 0;
  qword_1ED7F4300 = (uint64_t)&off_1E7FA9DC8;
  *(_QWORD *)&dword_1ED7F4308 = 0;
  qword_1ED7F4278 = (uint64_t)&unk_1E819E418;
  qword_1ED7F4310 = (uint64_t)&unk_1E819E230;
  qword_1ED7F4318 = (uint64_t)&off_1E7FA9D80;
  qword_1ED7F4330 = (uint64_t)&qword_1ED7F4318;
  llvm::cl::Option::setArgStr(v4, "stack-safety-max-iterations", 0x1BuLL);
  v5 = *a1;
  dword_1ED7F42F8 = **a1;
  byte_1ED7F430C = 1;
  dword_1ED7F4308 = *v5;
  word_1ED7F4282 = (32 * (*a2 & 3)) | word_1ED7F4282 & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F4278);
}

void sub_1C61B7960(char **a1, _WORD *a2)
{
  uint64_t v4;
  char *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F4338, 0, 0);
  byte_1ED7F43B8 = 0;
  qword_1ED7F43C0 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F43C8 = 0;
  qword_1ED7F4338 = (uint64_t)&unk_1E819E898;
  qword_1ED7F43D0 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F43D8 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F43F0 = (uint64_t)&qword_1ED7F43D8;
  llvm::cl::Option::setArgStr(v4, "stack-safety-print", 0x12uLL);
  v5 = *a1;
  byte_1ED7F43B8 = **a1;
  byte_1ED7F43C9 = 1;
  byte_1ED7F43C8 = *v5;
  word_1ED7F4342 = (32 * (*a2 & 3)) | word_1ED7F4342 & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F4338);
}

void sub_1C61B7A34(char **a1, _WORD *a2)
{
  uint64_t v4;
  char *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F43F8, 0, 0);
  byte_1ED7F4478 = 0;
  qword_1ED7F4480 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F4488 = 0;
  qword_1ED7F43F8 = (uint64_t)&unk_1E819E898;
  qword_1ED7F4490 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F4498 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F44B0 = (uint64_t)&qword_1ED7F4498;
  llvm::cl::Option::setArgStr(v4, "stack-safety-run", 0x10uLL);
  v5 = *a1;
  byte_1ED7F4478 = **a1;
  byte_1ED7F4489 = 1;
  byte_1ED7F4488 = *v5;
  word_1ED7F4402 = (32 * (*a2 & 3)) | word_1ED7F4402 & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F43F8);
}

void sub_1C61B7B0C()
{
  JUMPOUT(0x1CAA32FC0);
}

llvm::raw_ostream *sub_1C61B7B20(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return sub_1C61B7B28(*(unsigned int **)(a1 + 8), a2, a3, a4);
}

llvm::raw_ostream *sub_1C61B7B28(unsigned int *a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  unint64_t *v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  int v11;
  unsigned int v12;
  size_t v13;
  int v14;
  unsigned __int8 *v15;
  uint64_t v16;
  unint64_t v17;

  v15 = a3;
  v16 = a4;
  v14 = 0;
  if (sub_1C617F438(&v15, &v14))
  {
    v7 = v14;
    v17 = 0;
    if (llvm::consumeUnsignedInteger((llvm *)&v15, (llvm::StringRef *)0xA, &v17, v6))
      v8 = 0;
    else
      v8 = v17;
    if (llvm::isPrefixedHexStyle(v7))
      v9 = v8 + 2;
    else
      v9 = v8;
    return llvm::write_hex(a2, *a1, v14, v9, 1);
  }
  if (v16)
  {
    v11 = 0;
    v12 = *v15;
    if (v12 <= 0x63)
    {
      if (v12 != 68)
      {
        if (v12 != 78)
          goto LABEL_20;
        goto LABEL_17;
      }
LABEL_18:
      v11 = 0;
      ++v15;
      goto LABEL_19;
    }
    if (v12 == 100)
      goto LABEL_18;
    if (v12 == 110)
    {
LABEL_17:
      ++v15;
      v11 = 1;
LABEL_19:
      --v16;
    }
  }
  else
  {
    v11 = 0;
  }
LABEL_20:
  v17 = 0;
  if (llvm::consumeUnsignedInteger((llvm *)&v15, (llvm::StringRef *)0xA, &v17, v6))
    v13 = 0;
  else
    v13 = v17;
  return llvm::write_integer(a2, *a1, v13, v11);
}

uint64_t sub_1C61B7C5C(uint64_t a1)
{
  void *v2;

  sub_1C6143384(*(_QWORD **)(a1 + 128));
  v2 = *(void **)(a1 + 32);
  if (v2 != *(void **)(a1 + 24))
    free(v2);
  sub_1C4F6EDB0(*(_QWORD **)(a1 + 8));
  return a1;
}

uint64_t **sub_1C61B7C9C(_QWORD **a1, _QWORD *a2, unint64_t a3, uint64_t *a4)
{
  uint64_t **result;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  result = (uint64_t **)sub_1C4F6F0A8(a1, a2, &v13, &v12, a3);
  if (!*result)
  {
    v7 = result;
    v8 = (uint64_t *)operator new(0x28uLL);
    v8[4] = *a4;
    v9 = v13;
    *v8 = 0;
    v8[1] = 0;
    v8[2] = v9;
    *v7 = v8;
    v10 = (_QWORD *)**a1;
    if (v10)
    {
      *a1 = v10;
      v11 = *v7;
    }
    else
    {
      v11 = v8;
    }
    result = (uint64_t **)sub_1C4768E74(a1[1], v11);
    a1[2] = (_QWORD *)((char *)a1[2] + 1);
  }
  return result;
}

uint64_t sub_1C61B7D3C(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  void **v5;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 64;
    v5 = (void **)(i - 24);
    sub_1C4EEB714(&v5);
    sub_1C4E8C6FC(i - 56);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

llvm::SyncDependenceAnalysis *llvm::SyncDependenceAnalysis::SyncDependenceAnalysis(llvm::SyncDependenceAnalysis *this, const llvm::DominatorTree *a2, const llvm::PostDominatorTree *a3, const llvm::LoopInfo *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  void (**v12)(_QWORD *);
  void (**v13)(void);
  void *__p;
  _QWORD *v16;
  unint64_t v17;
  _QWORD **v18;
  _QWORD *v19[2];
  _QWORD v20[3];
  _QWORD *v21;
  _QWORD v22[3];
  _QWORD *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 14) = 1065353216;
  *((_QWORD *)this + 8) = a2;
  *((_QWORD *)this + 9) = a3;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = a4;
  *((_QWORD *)this + 11) = (char *)this + 96;
  v6 = *(_QWORD *)(**(_QWORD **)a2 + 56);
  v20[0] = &off_1E813B740;
  v20[1] = this;
  v21 = v20;
  v19[0] = 0;
  v19[1] = 0;
  v17 = 0;
  v18 = v19;
  __p = 0;
  v16 = 0;
  sub_1C4DB1D18((uint64_t)&__p, 0x18uLL);
  v7 = *(_QWORD *)(v6 + 80);
  if (v7)
    v8 = v7 - 24;
  else
    v8 = 0;
  v22[0] = v8;
  v9 = v16;
  if ((unint64_t)v16 >= v17)
  {
    v10 = sub_1C4DFEA3C(&__p, v22);
  }
  else
  {
    *v16 = v8;
    v10 = v9 + 1;
  }
  v16 = v10;
  if (v21)
  {
    if (v21 == v20)
    {
      v23 = v22;
      (*(void (**)(_QWORD *, _QWORD *))(v20[0] + 24))(v20, v22);
    }
    else
    {
      v23 = (_QWORD *)(*(uint64_t (**)(void))(*v21 + 16))();
    }
  }
  else
  {
    v23 = 0;
  }
  sub_1C4F74134(&__p, (uint64_t *)a4, 0, v22, (uint64_t)&v18);
  v11 = v23;
  if (v23 == v22)
  {
    v12 = (void (**)(_QWORD *))(v22[0] + 32);
    v11 = v22;
LABEL_11:
    (*v12)(v11);
    goto LABEL_12;
  }
  if (v23)
  {
    v12 = (void (**)(_QWORD *))(*v23 + 40);
    goto LABEL_11;
  }
LABEL_12:
  if (__p)
  {
    v16 = __p;
    operator delete(__p);
  }
  sub_1C6143384(v19[0]);
  if (v21 == v20)
  {
    v13 = (void (**)(void))(v20[0] + 32);
    goto LABEL_17;
  }
  if (v21)
  {
    v13 = (void (**)(void))(*v21 + 40);
LABEL_17:
    (*v13)();
  }
  return this;
}

uint64_t *llvm::SyncDependenceAnalysis::getJoinBlocks(llvm::SyncDependenceAnalysis *this, const llvm::Instruction *a2)
{
  uint64_t *v4;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  BOOL v9;
  _QWORD *v10;
  void **v11;
  void **v12;
  uint64_t *v13;
  void **v14;
  _QWORD v15[9];

  if (llvm::Instruction::getNumSuccessors(a2) < 2)
    return &llvm::SyncDependenceAnalysis::EmptyDivergenceDesc;
  v6 = (_QWORD *)*((_QWORD *)this + 12);
  if (!v6)
    goto LABEL_16;
  v7 = (_QWORD *)((char *)this + 96);
  do
  {
    v8 = v6[4];
    v9 = v8 >= (unint64_t)a2;
    if (v8 >= (unint64_t)a2)
      v10 = v6;
    else
      v10 = v6 + 1;
    if (v9)
      v7 = v6;
    v6 = (_QWORD *)*v10;
  }
  while (*v10);
  if (v7 != (_QWORD *)((char *)this + 96) && v7[4] <= (unint64_t)a2)
    return (uint64_t *)v7[5];
LABEL_16:
  sub_1C4F74BF8(v15, this, *((_QWORD *)this + 8), *((_QWORD *)this + 9), *((_QWORD *)this + 10), *((_QWORD *)a2 + 5));
  sub_1C4F73994(v15, &v14);
  v13 = (uint64_t *)a2;
  v4 = sub_1C4F75198((uint64_t **)this + 11, (unint64_t *)&v13, &v13, (uint64_t **)&v14)[5];
  v11 = v14;
  v14 = 0;
  if (v11)
  {
    v12 = sub_1C61B80D0(v11);
    MEMORY[0x1CAA32FC0](v12, 0x10C0C408B65D6DCLL);
  }
  sub_1C61B8294(v15);
  return v4;
}

void **sub_1C61B80D0(void **result)
{
  void *v1;
  void *v2;
  void **v3;
  void **v4;

  v1 = result[9];
  if (v1 != result[8])
  {
    v3 = result;
    free(v1);
    result = v3;
  }
  v2 = result[1];
  if (v2 != *result)
  {
    v4 = result;
    free(v2);
    return v4;
  }
  return result;
}

uint64_t sub_1C61B8128(uint64_t a1)
{
  void *v2;

  sub_1C61B8160(a1 + 24);
  v2 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1C61B8160(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

_QWORD *sub_1C61B81A8(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v5;
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v5 == v10)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *sub_1C61B8294(_QWORD *a1)
{
  void **v2;
  void *v3;
  void **v5;

  v2 = (void **)a1[8];
  a1[8] = 0;
  if (v2)
  {
    v5 = sub_1C61B80D0(v2);
    MEMORY[0x1CAA32FC0](v5, 0x10C0C408B65D6DCLL);
  }
  v3 = (void *)a1[5];
  if (v3)
  {
    a1[6] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1C61B82EC(uint64_t a1, _QWORD *a2)
{
  void **v4;
  void **v5;

  if (a2)
  {
    sub_1C61B82EC(a1, *a2);
    sub_1C61B82EC(a1, a2[1]);
    v4 = (void **)a2[5];
    a2[5] = 0;
    if (v4)
    {
      v5 = sub_1C61B80D0(v4);
      MEMORY[0x1CAA32FC0](v5, 0x10C0C408B65D6DCLL);
    }
    operator delete(a2);
  }
}

_QWORD *sub_1C61B8354(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  _QWORD *result;
  unint64_t v7;

  v4 = (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  v7 = a2;
  *((_DWORD *)sub_1C4F74D90((float *)(a1 + 24), a2, &v7) + 6) = v4;
  v7 = a2;
  v5 = *(unint64_t **)(a1 + 8);
  if ((unint64_t)v5 >= *(_QWORD *)(a1 + 16))
  {
    result = sub_1C4DFEA3C((void **)a1, &v7);
  }
  else
  {
    *v5 = a2;
    result = v5 + 1;
  }
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t sub_1C61B83C8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v4 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(_QWORD *)(v2 - 16) = v4;
      operator delete(v4);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1C61B8428(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 24);
  sub_1C4764BBC(&v3);
  return a1;
}

void sub_1C61B8460(__int128 *a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD v2[3];
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  void *__p[3];
  void *v8[3];
  void *v9;
  void *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  void **v16;

  v14 = 0uLL;
  v15 = 0;
  v12 = *a1;
  v13 = *((_QWORD *)a1 + 2);
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  v10 = 0;
  v11 = 0;
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(__p, 0, sizeof(__p));
  v5 = 0uLL;
  v6 = 0;
  v3 = 0uLL;
  v4 = 0;
  memset(v2, 0, sizeof(v2));
  sub_1C61A8204(a2, 193, 0, 0, 0, &v14, (uint64_t)&v12, (uint64_t *)&v9, (__int128 *)v8, (__int128 *)__p, &v5, &v3, (uint64_t)v2);
  v16 = (void **)v2;
  sub_1C4EEB7D8(&v16);
  v16 = (void **)&v3;
  sub_1C4EEBCC8(&v16);
  v16 = (void **)&v5;
  sub_1C4EEBCC8(&v16);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v8[0])
  {
    v8[1] = v8[0];
    operator delete(v8[0]);
  }
  if (v9)
  {
    v10 = v9;
    operator delete(v9);
  }
  if ((_QWORD)v12)
  {
    *((_QWORD *)&v12 + 1) = v12;
    operator delete((void *)v12);
  }
  if ((_QWORD)v14)
  {
    *((_QWORD *)&v14 + 1) = v14;
    operator delete((void *)v14);
  }
}

_QWORD *sub_1C61B85A0(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61A7F08(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61A7FAC((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

uint64_t sub_1C61B8604(uint64_t a1)
{
  return *(_QWORD *)a1;
}

BOOL llvm::TargetLibraryInfoImpl::isCallingConvCCompatible(llvm::TargetLibraryInfoImpl *this, llvm::Function *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *((_QWORD *)this + 5);
  v5 = *(_QWORD *)(v2 + 216);
  v3 = v2 + 216;
  v4 = v5;
  v6 = *(_BYTE *)(v3 + 23);
  if (v6 >= 0)
    v7 = v3;
  else
    v7 = v4;
  v8 = *(_QWORD *)(v3 + 8);
  if (v6 >= 0)
    v9 = v6 & 0x7F;
  else
    v9 = v8;
  return sub_1C4F77630((*((unsigned __int16 *)this + 9) >> 4) & 0x3FF, v7, v9, *((_QWORD *)this + 3));
}

uint64_t llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  *(_QWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  sub_1C4F7AD9C((uint64_t *)(a1 + 120), (uint64_t *)a2 + 15);
  *(_WORD *)(a1 + 144) = *((_WORD *)a2 + 72);
  *(_BYTE *)(a1 + 146) = *((_BYTE *)a2 + 146);
  *(_DWORD *)(a1 + 148) = *((_DWORD *)a2 + 37);
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  v4 = *a2;
  v5 = a2[1];
  v6 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v6;
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  v7 = a2[4];
  v8 = a2[5];
  v9 = a2[6];
  *(_QWORD *)(a1 + 109) = *(_QWORD *)((char *)a2 + 109);
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 64) = v7;
  if ((__int128 *)a1 != a2)
  {
    sub_1C4F7AEAC((_QWORD *)(a1 + 152), *((char **)a2 + 19), *((char **)a2 + 20), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)a2 + 20) - *((_QWORD *)a2 + 19)) >> 3));
    sub_1C4F7AEAC((_QWORD *)(a1 + 176), *((char **)a2 + 22), *((char **)a2 + 23), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)a2 + 23) - *((_QWORD *)a2 + 22)) >> 3));
  }
  return a1;
}

uint64_t llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  _QWORD *v6;

  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = 0;
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 128);
  *(_DWORD *)(a2 + 128) = 0;
  v4 = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(a2 + 132);
  *(_DWORD *)(a2 + 132) = v4;
  v5 = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_DWORD *)(a2 + 136) = v5;
  *(_BYTE *)(a1 + 144) = *(_BYTE *)(a2 + 144);
  *(_BYTE *)(a1 + 145) = *(_BYTE *)(a2 + 145);
  *(_BYTE *)(a1 + 146) = *(_BYTE *)(a2 + 146);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 148);
  *(_OWORD *)(a1 + 152) = 0u;
  v6 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  memmove((void *)a1, (const void *)a2, 0x75uLL);
  if (a1 != a2)
  {
    sub_1C4F7AEAC(v6, *(char **)(a2 + 152), *(char **)(a2 + 160), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 160) - *(_QWORD *)(a2 + 152)) >> 3));
    sub_1C4F7AEAC((_QWORD *)(a1 + 176), *(char **)(a2 + 176), *(char **)(a2 + 184), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 184) - *(_QWORD *)(a2 + 176)) >> 3));
  }
  return a1;
}

double llvm::TargetLibraryInfoImpl::disableAllFunctions(llvm::TargetLibraryInfoImpl *this)
{
  double result;

  *(_QWORD *)((char *)this + 109) = 0;
  result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  return result;
}

void llvm::TargetLibraryInfoImpl::addVectorizableFunctionsFromVecLib()
{
  _QWORD *v0;
  int v1;
  uint64_t v2;
  const char *__src;
  uint64_t v4;
  const char *v5;
  __int128 v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  __int128 v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  __int128 v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int128 v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int128 v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  __int128 v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  __int128 v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  const char *v43;
  __int128 v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  const char *v52;
  __int128 v53;
  const char *v54;
  uint64_t v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  const char *v59;
  uint64_t v60;
  const char *v61;
  __int128 v62;
  const char *v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  const char *v68;
  uint64_t v69;
  const char *v70;
  __int128 v71;
  const char *v72;
  uint64_t v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  const char *v77;
  uint64_t v78;
  const char *v79;
  __int128 v80;
  const char *v81;
  uint64_t v82;
  const char *v83;
  uint64_t v84;
  uint64_t v85;
  const char *v86;
  uint64_t v87;
  const char *v88;
  __int128 v89;
  const char *v90;
  uint64_t v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  const char *v95;
  uint64_t v96;
  const char *v97;
  __int128 v98;
  const char *v99;
  uint64_t v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  uint64_t v105;
  const char *v106;
  __int128 v107;
  const char *v108;
  uint64_t v109;
  const char *v110;
  uint64_t v111;
  uint64_t v112;
  const char *v113;
  uint64_t v114;
  const char *v115;
  __int128 v116;
  const char *v117;
  uint64_t v118;
  const char *v119;
  uint64_t v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  const char *v124;
  __int128 v125;
  const char *v126;
  uint64_t v127;
  const char *v128;
  uint64_t v129;
  uint64_t v130;
  const char *v131;
  uint64_t v132;
  const char *v133;
  __int128 v134;
  const char *v135;
  uint64_t v136;
  const char *v137;
  uint64_t v138;
  uint64_t v139;
  const char *v140;
  uint64_t v141;
  const char *v142;
  __int128 v143;
  const char *v144;
  uint64_t v145;
  const char *v146;
  uint64_t v147;
  uint64_t v148;
  const char *v149;
  uint64_t v150;
  const char *v151;
  __int128 v152;
  const char *v153;
  uint64_t v154;
  const char *v155;
  uint64_t v156;
  uint64_t v157;
  const char *v158;
  uint64_t v159;
  const char *v160;
  __int128 v161;
  const char *v162;
  uint64_t v163;
  const char *v164;
  uint64_t v165;
  uint64_t v166;
  const char *v167;
  uint64_t v168;
  const char *v169;
  __int128 v170;
  const char *v171;
  uint64_t v172;
  const char *v173;
  uint64_t v174;
  uint64_t v175;
  const char *v176;
  uint64_t v177;
  const char *v178;
  __int128 v179;
  const char *v180;
  uint64_t v181;
  const char *v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  uint64_t v186;
  const char *v187;
  __int128 v188;
  const char *v189;
  uint64_t v190;
  const char *v191;
  uint64_t v192;
  uint64_t v193;
  const char *v194;
  uint64_t v195;
  const char *v196;
  __int128 v197;
  const char *v198;
  uint64_t v199;
  const char *v200;
  uint64_t v201;
  uint64_t v202;
  const char *v203;
  uint64_t v204;
  const char *v205;
  __int128 v206;
  const char *v207;
  uint64_t v208;
  const char *v209;
  uint64_t v210;
  uint64_t v211;
  const char *v212;
  uint64_t v213;
  const char *v214;
  __int128 v215;
  const char *v216;
  uint64_t v217;
  const char *v218;
  uint64_t v219;
  uint64_t v220;
  const char *v221;
  uint64_t v222;
  const char *v223;
  __int128 v224;
  const char *v225;
  uint64_t v226;
  const char *v227;
  uint64_t v228;
  uint64_t v229;
  const char *v230;
  uint64_t v231;
  const char *v232;
  __int128 v233;
  const char *v234;
  uint64_t v235;
  const char *v236;
  uint64_t v237;
  uint64_t v238;
  const char *v239;
  uint64_t v240;
  const char *v241;
  __int128 v242;
  const char *v243;
  uint64_t v244;
  const char *v245;
  uint64_t v246;
  uint64_t v247;
  const char *v248;
  uint64_t v249;
  const char *v250;
  __int128 v251;
  const char *v252;
  uint64_t v253;
  const char *v254;
  uint64_t v255;
  uint64_t v256;
  const char *v257;
  uint64_t v258;
  const char *v259;
  __int128 v260;
  const char *v261;
  uint64_t v262;
  const char *v263;
  uint64_t v264;
  uint64_t v265;
  const char *v266;
  uint64_t v267;
  const char *v268;
  __int128 v269;
  const char *v270;
  uint64_t v271;
  const char *v272;
  uint64_t v273;
  uint64_t v274;
  const char *v275;
  uint64_t v276;
  const char *v277;
  __int128 v278;
  const char *v279;
  uint64_t v280;
  const char *v281;
  uint64_t v282;
  uint64_t v283;
  const char *v284;
  uint64_t v285;
  const char *v286;
  __int128 v287;
  const char *v288;
  uint64_t v289;
  const char *v290;
  uint64_t v291;
  uint64_t v292;
  const char *v293;
  uint64_t v294;
  const char *v295;
  __int128 v296;
  const char *v297;
  uint64_t v298;
  const char *v299;
  uint64_t v300;
  uint64_t v301;
  const char *v302;
  uint64_t v303;
  const char *v304;
  __int128 v305;
  const char *v306;
  uint64_t v307;
  const char *v308;
  uint64_t v309;
  uint64_t v310;
  const char *v311;
  uint64_t v312;
  const char *v313;
  __int128 v314;
  const char *v315;
  uint64_t v316;
  const char *v317;
  uint64_t v318;
  uint64_t v319;
  const char *v320;
  uint64_t v321;
  const char *v322;
  __int128 v323;
  const char *v324;
  uint64_t v325;
  const char *v326;
  uint64_t v327;
  uint64_t v328;
  const char *v329;
  uint64_t v330;
  const char *v331;
  __int128 v332;
  const char *v333;
  uint64_t v334;
  const char *v335;
  uint64_t v336;
  uint64_t v337;
  const char *v338;
  uint64_t v339;
  const char *v340;
  __int128 v341;
  const char *v342;
  uint64_t v343;
  const char *v344;
  uint64_t v345;
  uint64_t v346;
  const char *v347;
  uint64_t v348;
  const char *v349;
  __int128 v350;
  const char *v351;
  uint64_t v352;
  const char *v353;
  uint64_t v354;
  uint64_t v355;
  const char *v356;
  uint64_t v357;
  const char *v358;
  __int128 v359;
  const char *v360;
  uint64_t v361;
  const char *v362;
  uint64_t v363;
  uint64_t v364;
  const char *v365;
  uint64_t v366;
  const char *v367;
  __int128 v368;
  const char *v369;
  uint64_t v370;
  const char *v371;
  uint64_t v372;
  uint64_t v373;
  const char *v374;
  uint64_t v375;
  const char *v376;
  __int128 v377;
  const char *v378;
  uint64_t v379;
  const char *v380;
  uint64_t v381;
  uint64_t v382;
  const char *v383;
  uint64_t v384;
  const char *v385;
  __int128 v386;
  const char *v387;
  uint64_t v388;
  const char *v389;
  uint64_t v390;
  uint64_t v391;
  const char *v392;
  uint64_t v393;
  const char *v394;
  __int128 v395;
  const char *v396;
  uint64_t v397;
  const char *v398;
  uint64_t v399;
  uint64_t v400;
  const char *v401;
  uint64_t v402;
  const char *v403;
  __int128 v404;
  const char *v405;
  uint64_t v406;
  const char *v407;
  uint64_t v408;
  uint64_t v409;
  const char *v410;
  uint64_t v411;
  const char *v412;
  __int128 v413;
  const char *v414;
  uint64_t v415;
  const char *v416;
  uint64_t v417;
  uint64_t v418;
  const char *v419;
  uint64_t v420;
  const char *v421;
  __int128 v422;
  const char *v423;
  uint64_t v424;
  const char *v425;
  uint64_t v426;
  uint64_t v427;
  const char *v428;
  uint64_t v429;
  const char *v430;
  __int128 v431;
  const char *v432;
  uint64_t v433;
  const char *v434;
  uint64_t v435;
  uint64_t v436;
  const char *v437;
  uint64_t v438;
  const char *v439;
  __int128 v440;
  const char *v441;
  uint64_t v442;
  const char *v443;
  uint64_t v444;
  uint64_t v445;
  const char *v446;
  uint64_t v447;
  const char *v448;
  __int128 v449;
  const char *v450;
  uint64_t v451;
  const char *v452;
  uint64_t v453;
  uint64_t v454;
  const char *v455;
  uint64_t v456;
  const char *v457;
  __int128 v458;
  const char *v459;
  uint64_t v460;
  const char *v461;
  uint64_t v462;
  uint64_t v463;
  const char *v464;
  uint64_t v465;
  const char *v466;
  __int128 v467;
  const char *v468;
  uint64_t v469;
  const char *v470;
  uint64_t v471;
  uint64_t v472;
  const char *v473;
  uint64_t v474;
  const char *v475;
  __int128 v476;
  const char *v477;
  uint64_t v478;
  const char *v479;
  uint64_t v480;
  uint64_t v481;
  const char *v482;
  uint64_t v483;
  const char *v484;
  __int128 v485;
  const char *v486;
  uint64_t v487;
  const char *v488;
  uint64_t v489;
  uint64_t v490;
  const char *v491;
  uint64_t v492;
  const char *v493;
  __int128 v494;
  const char *v495;
  uint64_t v496;
  const char *v497;
  uint64_t v498;
  uint64_t v499;
  const char *v500;
  uint64_t v501;
  const char *v502;
  __int128 v503;
  const char *v504;
  uint64_t v505;
  const char *v506;
  uint64_t v507;
  uint64_t v508;
  const char *v509;
  uint64_t v510;
  const char *v511;
  __int128 v512;
  const char *v513;
  uint64_t v514;
  const char *v515;
  uint64_t v516;
  uint64_t v517;
  const char *v518;
  uint64_t v519;
  const char *v520;
  __int128 v521;
  const char *v522;
  uint64_t v523;
  const char *v524;
  uint64_t v525;
  uint64_t v526;
  const char *v527;
  uint64_t v528;
  const char *v529;
  __int128 v530;
  const char *v531;
  uint64_t v532;
  const char *v533;
  uint64_t v534;
  uint64_t v535;
  const char *v536;
  uint64_t v537;
  const char *v538;
  __int128 v539;
  const char *v540;
  uint64_t v541;
  const char *v542;
  uint64_t v543;
  uint64_t v544;
  const char *v545;
  uint64_t v546;
  const char *v547;
  __int128 v548;
  const char *v549;
  uint64_t v550;
  const char *v551;
  uint64_t v552;
  uint64_t v553;
  const char *v554;
  uint64_t v555;
  const char *v556;
  __int128 v557;
  const char *v558;
  uint64_t v559;
  const char *v560;
  uint64_t v561;
  uint64_t v562;
  const char *v563;
  uint64_t v564;
  const char *v565;
  __int128 v566;
  const char *v567;
  uint64_t v568;
  const char *v569;
  uint64_t v570;
  uint64_t v571;
  const char *v572;
  uint64_t v573;
  const char *v574;
  __int128 v575;
  const char *v576;
  uint64_t v577;
  const char *v578;
  uint64_t v579;
  uint64_t v580;
  const char *v581;
  uint64_t v582;
  const char *v583;
  __int128 v584;
  const char *v585;
  uint64_t v586;
  const char *v587;
  uint64_t v588;
  uint64_t v589;
  const char *v590;
  uint64_t v591;
  const char *v592;
  __int128 v593;
  const char *v594;
  uint64_t v595;
  const char *v596;
  uint64_t v597;
  uint64_t v598;
  const char *v599;
  uint64_t v600;
  const char *v601;
  __int128 v602;
  const char *v603;
  uint64_t v604;
  const char *v605;
  uint64_t v606;
  uint64_t v607;
  const char *v608;
  uint64_t v609;
  const char *v610;
  __int128 v611;
  const char *v612;
  uint64_t v613;
  const char *v614;
  uint64_t v615;
  uint64_t v616;
  const char *v617;
  uint64_t v618;
  const char *v619;
  __int128 v620;
  const char *v621;
  uint64_t v622;
  const char *v623;
  uint64_t v624;
  uint64_t v625;
  const char *v626;
  uint64_t v627;
  const char *v628;
  __int128 v629;
  const char *v630;
  uint64_t v631;
  const char *v632;
  uint64_t v633;
  uint64_t v634;
  const char *v635;
  uint64_t v636;
  const char *v637;
  __int128 v638;
  const char *v639;
  uint64_t v640;
  const char *v641;
  uint64_t v642;
  uint64_t v643;
  const char *v644;
  uint64_t v645;
  const char *v646;
  __int128 v647;
  uint64_t v648;

  v0 = (_QWORD *)MEMORY[0x1E0C80A78]();
  v648 = *MEMORY[0x1E0C80C00];
  switch(v1)
  {
    case 1:
      __src = "ceilf";
      v4 = 5;
      v5 = "vceilf";
      v6 = xmmword_1C85F6930;
      v7 = "fabsf";
      v8 = 5;
      v9 = "vfabsf";
      v10 = xmmword_1C85F6930;
      v11 = "llvm.fabs.f32";
      v12 = 13;
      v13 = "vfabsf";
      v14 = xmmword_1C85F6930;
      v15 = "floorf";
      v16 = 6;
      v17 = "vfloorf";
      v18 = xmmword_1C85F6880;
      v19 = "sqrtf";
      v20 = 5;
      v22 = xmmword_1C85F6930;
      v21 = "vsqrtf";
      v23 = "llvm.sqrt.f32";
      v24 = 13;
      v25 = "vsqrtf";
      v26 = xmmword_1C85F6930;
      v27 = "expf";
      v28 = 4;
      v29 = "vexpf";
      v30 = 5;
      v31 = 4;
      v32 = "llvm.exp.f32";
      v33 = 12;
      v34 = "vexpf";
      v35 = xmmword_1C85F6940;
      v36 = "expm1f";
      v37 = 6;
      v38 = "vexpm1f";
      v39 = 7;
      v40 = 4;
      v41 = "logf";
      v42 = 4;
      v43 = "vlogf";
      v44 = xmmword_1C85F6940;
      v45 = "llvm.log.f32";
      v46 = 12;
      v47 = "vlogf";
      v48 = 5;
      v49 = 4;
      v50 = "log1pf";
      v51 = 6;
      v52 = "vlog1pf";
      v53 = xmmword_1C85F6880;
      v54 = "log10f";
      v55 = 6;
      v56 = "vlog10f";
      v57 = 7;
      v58 = 4;
      v59 = "llvm.log10.f32";
      v60 = 14;
      v61 = "vlog10f";
      v62 = xmmword_1C85F6880;
      v63 = "logbf";
      v64 = 5;
      v65 = "vlogbf";
      v66 = 6;
      v67 = 4;
      v68 = "sinf";
      v69 = 4;
      v70 = "vsinf";
      v71 = xmmword_1C85F6940;
      v72 = "llvm.sin.f32";
      v73 = 12;
      v74 = "vsinf";
      v75 = 5;
      v76 = 4;
      v77 = "cosf";
      v78 = 4;
      v79 = "vcosf";
      v80 = xmmword_1C85F6940;
      v81 = "llvm.cos.f32";
      v82 = 12;
      v83 = "vcosf";
      v84 = 5;
      v85 = 4;
      v86 = "tanf";
      v87 = 4;
      v88 = "vtanf";
      v89 = xmmword_1C85F6940;
      v90 = "asinf";
      v91 = 5;
      v92 = "vasinf";
      v93 = 6;
      v94 = 4;
      v95 = "acosf";
      v96 = 5;
      v97 = "vacosf";
      v98 = xmmword_1C85F6930;
      v99 = "atanf";
      v100 = 5;
      v101 = "vatanf";
      v102 = 6;
      v103 = 4;
      v104 = "sinhf";
      v105 = 5;
      v106 = "vsinhf";
      v107 = xmmword_1C85F6930;
      v108 = "coshf";
      v109 = 5;
      v110 = "vcoshf";
      v111 = 6;
      v112 = 4;
      v113 = "tanhf";
      v114 = 5;
      v115 = "vtanhf";
      v116 = xmmword_1C85F6930;
      v117 = "asinhf";
      v118 = 6;
      v119 = "vasinhf";
      v120 = 7;
      v121 = 4;
      v122 = "acoshf";
      v123 = 6;
      v124 = "vacoshf";
      v125 = xmmword_1C85F6880;
      v126 = "atanhf";
      v127 = 6;
      v128 = "vatanhf";
      v129 = 7;
      v130 = 4;
      v2 = 29;
      goto LABEL_7;
    case 2:
      __src = "exp";
      v4 = 3;
      v5 = "_simd_exp_d2";
      v6 = xmmword_1C85F68B0;
      v7 = "llvm.exp.f64";
      v8 = 12;
      v9 = "_simd_exp_d2";
      v10 = xmmword_1C85F68B0;
      v11 = "expf";
      v12 = 4;
      v13 = "_simd_exp_f4";
      v14 = xmmword_1C85F67E0;
      v15 = "llvm.exp.f32";
      v16 = 12;
      v17 = "_simd_exp_f4";
      v18 = xmmword_1C85F67E0;
      v19 = "acos";
      v20 = 4;
      v22 = xmmword_1C85F6920;
      v21 = "_simd_acos_d2";
      v23 = "acosf";
      v24 = 5;
      v25 = "_simd_acos_f4";
      v26 = xmmword_1C85F6810;
      v27 = "asin";
      v28 = 4;
      v29 = "_simd_asin_d2";
      v30 = 13;
      v31 = 2;
      v32 = "asinf";
      v33 = 5;
      v34 = "_simd_asin_f4";
      v35 = xmmword_1C85F6810;
      v36 = "atan";
      v37 = 4;
      v38 = "_simd_atan_d2";
      v39 = 13;
      v40 = 2;
      v41 = "atanf";
      v42 = 5;
      v43 = "_simd_atan_f4";
      v44 = xmmword_1C85F6810;
      v45 = "atan2";
      v46 = 5;
      v47 = "_simd_atan2_d2";
      v48 = 14;
      v49 = 2;
      v50 = "atan2f";
      v51 = 6;
      v52 = "_simd_atan2_f4";
      v53 = xmmword_1C85F6830;
      v54 = "cos";
      v55 = 3;
      v56 = "_simd_cos_d2";
      v57 = 12;
      v58 = 2;
      v59 = "llvm.cos.f64";
      v60 = 12;
      v61 = "_simd_cos_d2";
      v62 = xmmword_1C85F68B0;
      v63 = "cosf";
      v64 = 4;
      v65 = "_simd_cos_f4";
      v66 = 12;
      v67 = 4;
      v68 = "llvm.cos.f32";
      v69 = 12;
      v70 = "_simd_cos_f4";
      v71 = xmmword_1C85F67E0;
      v72 = "sin";
      v73 = 3;
      v74 = "_simd_sin_d2";
      v75 = 12;
      v76 = 2;
      v77 = "llvm.sin.f64";
      v78 = 12;
      v79 = "_simd_sin_d2";
      v80 = xmmword_1C85F68B0;
      v81 = "sinf";
      v82 = 4;
      v83 = "_simd_sin_f4";
      v84 = 12;
      v85 = 4;
      v86 = "llvm.sin.f32";
      v87 = 12;
      v88 = "_simd_sin_f4";
      v89 = xmmword_1C85F67E0;
      v90 = "cbrt";
      v91 = 4;
      v92 = "_simd_cbrt_d2";
      v93 = 13;
      v94 = 2;
      v95 = "cbrtf";
      v96 = 5;
      v97 = "_simd_cbrt_f4";
      v98 = xmmword_1C85F6810;
      v99 = "erf";
      v100 = 3;
      v101 = "_simd_erf_d2";
      v102 = 12;
      v103 = 2;
      v104 = "erff";
      v105 = 4;
      v106 = "_simd_erf_f4";
      v107 = xmmword_1C85F67E0;
      v108 = "pow";
      v109 = 3;
      v110 = "_simd_pow_d2";
      v111 = 12;
      v112 = 2;
      v113 = "llvm.pow.f64";
      v114 = 12;
      v115 = "_simd_pow_d2";
      v116 = xmmword_1C85F68B0;
      v117 = "powf";
      v118 = 4;
      v119 = "_simd_pow_f4";
      v120 = 12;
      v121 = 4;
      v122 = "llvm.pow.f32";
      v123 = 12;
      v124 = "_simd_pow_f4";
      v125 = xmmword_1C85F67E0;
      v126 = "sinh";
      v127 = 4;
      v128 = "_simd_sinh_d2";
      v129 = 13;
      v130 = 2;
      v131 = "sinhf";
      v132 = 5;
      v133 = "_simd_sinh_f4";
      v134 = xmmword_1C85F6810;
      v135 = "cosh";
      v136 = 4;
      v137 = "_simd_cosh_d2";
      v138 = 13;
      v139 = 2;
      v140 = "coshf";
      v141 = 5;
      v142 = "_simd_cosh_f4";
      v143 = xmmword_1C85F6810;
      v144 = "tanh";
      v145 = 4;
      v146 = "_simd_tanh_d2";
      v147 = 13;
      v148 = 2;
      v149 = "tanhf";
      v150 = 5;
      v151 = "_simd_tanh_f4";
      v152 = xmmword_1C85F6810;
      v153 = "asinh";
      v154 = 5;
      v155 = "_simd_asinh_d2";
      v156 = 14;
      v157 = 2;
      v158 = "asinhf";
      v159 = 6;
      v160 = "_simd_asinh_f4";
      v161 = xmmword_1C85F6830;
      v162 = "acosh";
      v163 = 5;
      v164 = "_simd_acosh_d2";
      v165 = 14;
      v166 = 2;
      v167 = "acoshf";
      v168 = 6;
      v169 = "_simd_acosh_f4";
      v170 = xmmword_1C85F6830;
      v171 = "atanh";
      v172 = 5;
      v173 = "_simd_atanh_d2";
      v174 = 14;
      v175 = 2;
      v176 = "atanhf";
      v177 = 6;
      v178 = "_simd_atanh_f4";
      v179 = xmmword_1C85F6830;
      v2 = 40;
      goto LABEL_7;
    case 3:
      __src = "sin";
      v4 = 3;
      v5 = "_ZGVbN2v_sin";
      v6 = xmmword_1C85F68B0;
      v7 = "sin";
      v8 = 3;
      v9 = "_ZGVdN4v_sin";
      v10 = xmmword_1C85F67E0;
      v11 = "sinf";
      v12 = 4;
      v13 = "_ZGVbN4v_sinf";
      v14 = xmmword_1C85F6810;
      v15 = "sinf";
      v16 = 4;
      v17 = "_ZGVdN8v_sinf";
      v18 = xmmword_1C85F68C0;
      v19 = "llvm.sin.f64";
      v20 = 12;
      v22 = xmmword_1C85F68B0;
      v21 = "_ZGVbN2v_sin";
      v23 = "llvm.sin.f64";
      v24 = 12;
      v25 = "_ZGVdN4v_sin";
      v26 = xmmword_1C85F67E0;
      v27 = "llvm.sin.f32";
      v28 = 12;
      v29 = "_ZGVbN4v_sinf";
      v30 = 13;
      v31 = 4;
      v32 = "llvm.sin.f32";
      v33 = 12;
      v34 = "_ZGVdN8v_sinf";
      v35 = xmmword_1C85F68C0;
      v36 = "cos";
      v37 = 3;
      v38 = "_ZGVbN2v_cos";
      v39 = 12;
      v40 = 2;
      v41 = "cos";
      v42 = 3;
      v43 = "_ZGVdN4v_cos";
      v44 = xmmword_1C85F67E0;
      v45 = "cosf";
      v46 = 4;
      v47 = "_ZGVbN4v_cosf";
      v48 = 13;
      v49 = 4;
      v50 = "cosf";
      v51 = 4;
      v52 = "_ZGVdN8v_cosf";
      v53 = xmmword_1C85F68C0;
      v54 = "llvm.cos.f64";
      v55 = 12;
      v56 = "_ZGVbN2v_cos";
      v57 = 12;
      v58 = 2;
      v59 = "llvm.cos.f64";
      v60 = 12;
      v61 = "_ZGVdN4v_cos";
      v62 = xmmword_1C85F67E0;
      v63 = "llvm.cos.f32";
      v64 = 12;
      v65 = "_ZGVbN4v_cosf";
      v66 = 13;
      v67 = 4;
      v68 = "llvm.cos.f32";
      v69 = 12;
      v70 = "_ZGVdN8v_cosf";
      v71 = xmmword_1C85F68C0;
      v72 = "pow";
      v73 = 3;
      v74 = "_ZGVbN2vv_pow";
      v75 = 13;
      v76 = 2;
      v77 = "pow";
      v78 = 3;
      v79 = "_ZGVdN4vv_pow";
      v80 = xmmword_1C85F6810;
      v81 = "powf";
      v82 = 4;
      v83 = "_ZGVbN4vv_powf";
      v84 = 14;
      v85 = 4;
      v86 = "powf";
      v87 = 4;
      v88 = "_ZGVdN8vv_powf";
      v89 = xmmword_1C85F68D0;
      v90 = "__pow_finite";
      v91 = 12;
      v92 = "_ZGVbN2vv___pow_finite";
      v93 = 22;
      v94 = 2;
      v95 = "__pow_finite";
      v96 = 12;
      v97 = "_ZGVdN4vv___pow_finite";
      v98 = xmmword_1C85F68E0;
      v99 = "__powf_finite";
      v100 = 13;
      v101 = "_ZGVbN4vv___powf_finite";
      v102 = 23;
      v103 = 4;
      v104 = "__powf_finite";
      v105 = 13;
      v106 = "_ZGVdN8vv___powf_finite";
      v107 = xmmword_1C85F68F0;
      v108 = "llvm.pow.f64";
      v109 = 12;
      v110 = "_ZGVbN2vv_pow";
      v111 = 13;
      v112 = 2;
      v113 = "llvm.pow.f64";
      v114 = 12;
      v115 = "_ZGVdN4vv_pow";
      v116 = xmmword_1C85F6810;
      v117 = "llvm.pow.f32";
      v118 = 12;
      v119 = "_ZGVbN4vv_powf";
      v120 = 14;
      v121 = 4;
      v122 = "llvm.pow.f32";
      v123 = 12;
      v124 = "_ZGVdN8vv_powf";
      v125 = xmmword_1C85F68D0;
      v126 = "exp";
      v127 = 3;
      v128 = "_ZGVbN2v_exp";
      v129 = 12;
      v130 = 2;
      v131 = "exp";
      v132 = 3;
      v133 = "_ZGVdN4v_exp";
      v134 = xmmword_1C85F67E0;
      v135 = "expf";
      v136 = 4;
      v137 = "_ZGVbN4v_expf";
      v138 = 13;
      v139 = 4;
      v140 = "expf";
      v141 = 4;
      v142 = "_ZGVdN8v_expf";
      v143 = xmmword_1C85F68C0;
      v144 = "__exp_finite";
      v145 = 12;
      v146 = "_ZGVbN2v___exp_finite";
      v147 = 21;
      v148 = 2;
      v149 = "__exp_finite";
      v150 = 12;
      v151 = "_ZGVdN4v___exp_finite";
      v152 = xmmword_1C85F6900;
      v153 = "__expf_finite";
      v154 = 13;
      v155 = "_ZGVbN4v___expf_finite";
      v156 = 22;
      v157 = 4;
      v158 = "__expf_finite";
      v159 = 13;
      v160 = "_ZGVdN8v___expf_finite";
      v161 = xmmword_1C85F6910;
      v162 = "llvm.exp.f64";
      v163 = 12;
      v164 = "_ZGVbN2v_exp";
      v165 = 12;
      v166 = 2;
      v167 = "llvm.exp.f64";
      v168 = 12;
      v169 = "_ZGVdN4v_exp";
      v170 = xmmword_1C85F67E0;
      v171 = "llvm.exp.f32";
      v172 = 12;
      v173 = "_ZGVbN4v_expf";
      v174 = 13;
      v175 = 4;
      v176 = "llvm.exp.f32";
      v177 = 12;
      v178 = "_ZGVdN8v_expf";
      v179 = xmmword_1C85F68C0;
      v180 = "log";
      v181 = 3;
      v182 = "_ZGVbN2v_log";
      v183 = 12;
      v184 = 2;
      v185 = "log";
      v186 = 3;
      v187 = "_ZGVdN4v_log";
      v188 = xmmword_1C85F67E0;
      v189 = "logf";
      v190 = 4;
      v191 = "_ZGVbN4v_logf";
      v192 = 13;
      v193 = 4;
      v194 = "logf";
      v195 = 4;
      v196 = "_ZGVdN8v_logf";
      v197 = xmmword_1C85F68C0;
      v198 = "__log_finite";
      v199 = 12;
      v200 = "_ZGVbN2v___log_finite";
      v201 = 21;
      v202 = 2;
      v203 = "__log_finite";
      v204 = 12;
      v205 = "_ZGVdN4v___log_finite";
      v206 = xmmword_1C85F6900;
      v207 = "__logf_finite";
      v208 = 13;
      v209 = "_ZGVbN4v___logf_finite";
      v210 = 22;
      v211 = 4;
      v212 = "__logf_finite";
      v213 = 13;
      v214 = "_ZGVdN8v___logf_finite";
      v215 = xmmword_1C85F6910;
      v216 = "llvm.log.f64";
      v217 = 12;
      v218 = "_ZGVbN2v_log";
      v219 = 12;
      v220 = 2;
      v221 = "llvm.log.f64";
      v222 = 12;
      v223 = "_ZGVdN4v_log";
      v224 = xmmword_1C85F67E0;
      v225 = "llvm.log.f32";
      v226 = 12;
      v227 = "_ZGVbN4v_logf";
      v228 = 13;
      v229 = 4;
      v230 = "llvm.log.f32";
      v231 = 12;
      v232 = "_ZGVdN8v_logf";
      v233 = xmmword_1C85F68C0;
      v2 = 52;
      goto LABEL_7;
    case 4:
      __src = "cbrt";
      v4 = 4;
      v5 = "__cbrtd2";
      v6 = xmmword_1C85F6850;
      v7 = "cbrtf";
      v8 = 5;
      v9 = "__cbrtf4";
      v10 = xmmword_1C85F6860;
      v11 = "pow";
      v12 = 3;
      v13 = "__powd2";
      v14 = xmmword_1C85F6870;
      v15 = "llvm.pow.f64";
      v16 = 12;
      v17 = "__powd2";
      v18 = xmmword_1C85F6870;
      v19 = "powf";
      v20 = 4;
      v22 = xmmword_1C85F6880;
      v21 = "__powf4";
      v23 = "llvm.pow.f32";
      v24 = 12;
      v25 = "__powf4";
      v26 = xmmword_1C85F6880;
      v27 = "exp";
      v28 = 3;
      v29 = "__expd2";
      v30 = 7;
      v31 = 2;
      v32 = "llvm.exp.f64";
      v33 = 12;
      v34 = "__expd2";
      v35 = xmmword_1C85F6870;
      v36 = "expf";
      v37 = 4;
      v38 = "__expf4";
      v39 = 7;
      v40 = 4;
      v41 = "llvm.exp.f32";
      v42 = 12;
      v43 = "__expf4";
      v44 = xmmword_1C85F6880;
      v45 = "exp2";
      v46 = 4;
      v47 = "__exp2d2";
      v48 = 8;
      v49 = 2;
      v50 = "llvm.exp2.f64";
      v51 = 13;
      v52 = "__exp2d2";
      v53 = xmmword_1C85F6850;
      v54 = "exp2f";
      v55 = 5;
      v56 = "__exp2f4";
      v57 = 8;
      v58 = 4;
      v59 = "llvm.exp2.f32";
      v60 = 13;
      v61 = "__exp2f4";
      v62 = xmmword_1C85F6860;
      v63 = "expm1";
      v64 = 5;
      v65 = "__expm1d2";
      v66 = 9;
      v67 = 2;
      v68 = "expm1f";
      v69 = 6;
      v70 = "__expm1f4";
      v71 = xmmword_1C85F6890;
      v72 = "log";
      v73 = 3;
      v74 = "__logd2";
      v75 = 7;
      v76 = 2;
      v77 = "llvm.log.f64";
      v78 = 12;
      v79 = "__logd2";
      v80 = xmmword_1C85F6870;
      v81 = "logf";
      v82 = 4;
      v83 = "__logf4";
      v84 = 7;
      v85 = 4;
      v86 = "llvm.log.f32";
      v87 = 12;
      v88 = "__logf4";
      v89 = xmmword_1C85F6880;
      v90 = "log1p";
      v91 = 5;
      v92 = "__log1pd2";
      v93 = 9;
      v94 = 2;
      v95 = "log1pf";
      v96 = 6;
      v97 = "__log1pf4";
      v98 = xmmword_1C85F6890;
      v99 = "log10";
      v100 = 5;
      v101 = "__log10d2";
      v102 = 9;
      v103 = 2;
      v104 = "llvm.log10.f64";
      v105 = 14;
      v106 = "__log10d2";
      v107 = xmmword_1C85F68A0;
      v108 = "log10f";
      v109 = 6;
      v110 = "__log10f4";
      v111 = 9;
      v112 = 4;
      v113 = "llvm.log10.f32";
      v114 = 14;
      v115 = "__log10f4";
      v116 = xmmword_1C85F6890;
      v117 = "log2";
      v118 = 4;
      v119 = "__log2d2";
      v120 = 8;
      v121 = 2;
      v122 = "llvm.log2.f64";
      v123 = 13;
      v124 = "__log2d2";
      v125 = xmmword_1C85F6850;
      v126 = "log2f";
      v127 = 5;
      v128 = "__log2f4";
      v129 = 8;
      v130 = 4;
      v131 = "llvm.log2.f32";
      v132 = 13;
      v133 = "__log2f4";
      v134 = xmmword_1C85F6860;
      v135 = "sin";
      v136 = 3;
      v137 = "__sind2";
      v138 = 7;
      v139 = 2;
      v140 = "llvm.sin.f64";
      v141 = 12;
      v142 = "__sind2";
      v143 = xmmword_1C85F6870;
      v144 = "sinf";
      v145 = 4;
      v146 = "__sinf4";
      v147 = 7;
      v148 = 4;
      v149 = "llvm.sin.f32";
      v150 = 12;
      v151 = "__sinf4";
      v152 = xmmword_1C85F6880;
      v153 = "cos";
      v154 = 3;
      v155 = "__cosd2";
      v156 = 7;
      v157 = 2;
      v158 = "llvm.cos.f64";
      v159 = 12;
      v160 = "__cosd2";
      v161 = xmmword_1C85F6870;
      v162 = "cosf";
      v163 = 4;
      v164 = "__cosf4";
      v165 = 7;
      v166 = 4;
      v167 = "llvm.cos.f32";
      v168 = 12;
      v169 = "__cosf4";
      v170 = xmmword_1C85F6880;
      v171 = "tan";
      v172 = 3;
      v173 = "__tand2";
      v174 = 7;
      v175 = 2;
      v176 = "tanf";
      v177 = 4;
      v178 = "__tanf4";
      v179 = xmmword_1C85F6880;
      v180 = "asin";
      v181 = 4;
      v182 = "__asind2";
      v183 = 8;
      v184 = 2;
      v185 = "asinf";
      v186 = 5;
      v187 = "__asinf4";
      v188 = xmmword_1C85F6860;
      v189 = "acos";
      v190 = 4;
      v191 = "__acosd2";
      v192 = 8;
      v193 = 2;
      v194 = "acosf";
      v195 = 5;
      v196 = "__acosf4";
      v197 = xmmword_1C85F6860;
      v198 = "atan";
      v199 = 4;
      v200 = "__atand2";
      v201 = 8;
      v202 = 2;
      v203 = "atanf";
      v204 = 5;
      v205 = "__atanf4";
      v206 = xmmword_1C85F6860;
      v207 = "atan2";
      v208 = 5;
      v209 = "__atan2d2";
      v210 = 9;
      v211 = 2;
      v212 = "atan2f";
      v213 = 6;
      v214 = "__atan2f4";
      v215 = xmmword_1C85F6890;
      v216 = "sinh";
      v217 = 4;
      v218 = "__sinhd2";
      v219 = 8;
      v220 = 2;
      v221 = "sinhf";
      v222 = 5;
      v223 = "__sinhf4";
      v224 = xmmword_1C85F6860;
      v225 = "cosh";
      v226 = 4;
      v227 = "__coshd2";
      v228 = 8;
      v229 = 2;
      v230 = "coshf";
      v231 = 5;
      v232 = "__coshf4";
      v233 = xmmword_1C85F6860;
      v234 = "tanh";
      v235 = 4;
      v236 = "__tanhd2";
      v237 = 8;
      v238 = 2;
      v239 = "tanhf";
      v240 = 5;
      v241 = "__tanhf4";
      v242 = xmmword_1C85F6860;
      v243 = "asinh";
      v244 = 5;
      v245 = "__asinhd2";
      v246 = 9;
      v247 = 2;
      v248 = "asinhf";
      v249 = 6;
      v250 = "__asinhf4";
      v251 = xmmword_1C85F6890;
      v252 = "acosh";
      v253 = 5;
      v254 = "__acoshd2";
      v255 = 9;
      v256 = 2;
      v257 = "acoshf";
      v258 = 6;
      v259 = "__acoshf4";
      v260 = xmmword_1C85F6890;
      v261 = "atanh";
      v262 = 5;
      v263 = "__atanhd2";
      v264 = 9;
      v265 = 2;
      v266 = "atanhf";
      v267 = 6;
      v268 = "__atanhf4";
      v269 = xmmword_1C85F6890;
      v2 = 60;
      goto LABEL_7;
    case 5:
      __src = "sin";
      v4 = 3;
      v5 = "__svml_sin2";
      v6 = xmmword_1C85F67B0;
      v7 = "sin";
      v8 = 3;
      v9 = "__svml_sin4";
      v10 = xmmword_1C85F67C0;
      v11 = "sin";
      v12 = 3;
      v13 = "__svml_sin8";
      v14 = xmmword_1C85F67D0;
      v15 = "sinf";
      v16 = 4;
      v17 = "__svml_sinf4";
      v18 = xmmword_1C85F67E0;
      v19 = "sinf";
      v20 = 4;
      v22 = xmmword_1C85F67F0;
      v21 = "__svml_sinf8";
      v23 = "sinf";
      v24 = 4;
      v25 = "__svml_sinf16";
      v26 = xmmword_1C85F6800;
      v27 = "llvm.sin.f64";
      v28 = 12;
      v29 = "__svml_sin2";
      v30 = 11;
      v31 = 2;
      v32 = "llvm.sin.f64";
      v33 = 12;
      v34 = "__svml_sin4";
      v35 = xmmword_1C85F67C0;
      v36 = "llvm.sin.f64";
      v37 = 12;
      v38 = "__svml_sin8";
      v39 = 11;
      v40 = 8;
      v41 = "llvm.sin.f32";
      v42 = 12;
      v43 = "__svml_sinf4";
      v44 = xmmword_1C85F67E0;
      v45 = "llvm.sin.f32";
      v46 = 12;
      v47 = "__svml_sinf8";
      v48 = 12;
      v49 = 8;
      v50 = "llvm.sin.f32";
      v51 = 12;
      v52 = "__svml_sinf16";
      v53 = xmmword_1C85F6800;
      v54 = "cos";
      v55 = 3;
      v56 = "__svml_cos2";
      v57 = 11;
      v58 = 2;
      v59 = "cos";
      v60 = 3;
      v61 = "__svml_cos4";
      v62 = xmmword_1C85F67C0;
      v63 = "cos";
      v64 = 3;
      v65 = "__svml_cos8";
      v66 = 11;
      v67 = 8;
      v68 = "cosf";
      v69 = 4;
      v70 = "__svml_cosf4";
      v71 = xmmword_1C85F67E0;
      v72 = "cosf";
      v73 = 4;
      v74 = "__svml_cosf8";
      v75 = 12;
      v76 = 8;
      v77 = "cosf";
      v78 = 4;
      v79 = "__svml_cosf16";
      v80 = xmmword_1C85F6800;
      v81 = "llvm.cos.f64";
      v82 = 12;
      v83 = "__svml_cos2";
      v84 = 11;
      v85 = 2;
      v86 = "llvm.cos.f64";
      v87 = 12;
      v88 = "__svml_cos4";
      v89 = xmmword_1C85F67C0;
      v90 = "llvm.cos.f64";
      v91 = 12;
      v92 = "__svml_cos8";
      v93 = 11;
      v94 = 8;
      v95 = "llvm.cos.f32";
      v96 = 12;
      v97 = "__svml_cosf4";
      v98 = xmmword_1C85F67E0;
      v99 = "llvm.cos.f32";
      v100 = 12;
      v101 = "__svml_cosf8";
      v102 = 12;
      v103 = 8;
      v104 = "llvm.cos.f32";
      v105 = 12;
      v106 = "__svml_cosf16";
      v107 = xmmword_1C85F6800;
      v108 = "pow";
      v109 = 3;
      v110 = "__svml_pow2";
      v111 = 11;
      v112 = 2;
      v113 = "pow";
      v114 = 3;
      v115 = "__svml_pow4";
      v116 = xmmword_1C85F67C0;
      v117 = "pow";
      v118 = 3;
      v119 = "__svml_pow8";
      v120 = 11;
      v121 = 8;
      v122 = "powf";
      v123 = 4;
      v124 = "__svml_powf4";
      v125 = xmmword_1C85F67E0;
      v126 = "powf";
      v127 = 4;
      v128 = "__svml_powf8";
      v129 = 12;
      v130 = 8;
      v131 = "powf";
      v132 = 4;
      v133 = "__svml_powf16";
      v134 = xmmword_1C85F6800;
      v135 = "__pow_finite";
      v136 = 12;
      v137 = "__svml_pow2";
      v138 = 11;
      v139 = 2;
      v140 = "__pow_finite";
      v141 = 12;
      v142 = "__svml_pow4";
      v143 = xmmword_1C85F67C0;
      v144 = "__pow_finite";
      v145 = 12;
      v146 = "__svml_pow8";
      v147 = 11;
      v148 = 8;
      v149 = "__powf_finite";
      v150 = 13;
      v151 = "__svml_powf4";
      v152 = xmmword_1C85F67E0;
      v153 = "__powf_finite";
      v154 = 13;
      v155 = "__svml_powf8";
      v156 = 12;
      v157 = 8;
      v158 = "__powf_finite";
      v159 = 13;
      v160 = "__svml_powf16";
      v161 = xmmword_1C85F6800;
      v162 = "llvm.pow.f64";
      v163 = 12;
      v164 = "__svml_pow2";
      v165 = 11;
      v166 = 2;
      v167 = "llvm.pow.f64";
      v168 = 12;
      v169 = "__svml_pow4";
      v170 = xmmword_1C85F67C0;
      v171 = "llvm.pow.f64";
      v172 = 12;
      v173 = "__svml_pow8";
      v174 = 11;
      v175 = 8;
      v176 = "llvm.pow.f32";
      v177 = 12;
      v178 = "__svml_powf4";
      v179 = xmmword_1C85F67E0;
      v180 = "llvm.pow.f32";
      v181 = 12;
      v182 = "__svml_powf8";
      v183 = 12;
      v184 = 8;
      v185 = "llvm.pow.f32";
      v186 = 12;
      v187 = "__svml_powf16";
      v188 = xmmword_1C85F6800;
      v189 = "exp";
      v190 = 3;
      v191 = "__svml_exp2";
      v192 = 11;
      v193 = 2;
      v194 = "exp";
      v195 = 3;
      v196 = "__svml_exp4";
      v197 = xmmword_1C85F67C0;
      v198 = "exp";
      v199 = 3;
      v200 = "__svml_exp8";
      v203 = "expf";
      v205 = "__svml_expf4";
      v207 = "expf";
      v209 = "__svml_expf8";
      v212 = "expf";
      v214 = "__svml_expf16";
      v216 = "__exp_finite";
      v218 = "__svml_exp2";
      v221 = "__exp_finite";
      v223 = "__svml_exp4";
      v225 = "__exp_finite";
      v230 = "__expf_finite";
      v232 = "__svml_expf4";
      v234 = "__expf_finite";
      v236 = "__svml_expf8";
      v239 = "__expf_finite";
      v241 = "__svml_expf16";
      v243 = "llvm.exp.f64";
      v245 = "__svml_exp2";
      v248 = "llvm.exp.f64";
      v250 = "__svml_exp4";
      v252 = "llvm.exp.f64";
      v259 = "__svml_expf4";
      v263 = "__svml_expf8";
      v268 = "__svml_expf16";
      v270 = "log";
      v271 = 3;
      v275 = "log";
      v276 = 3;
      v277 = "__svml_log4";
      v279 = "log";
      v280 = 3;
      v281 = "__svml_log8";
      v284 = "logf";
      v288 = "logf";
      v293 = "logf";
      v295 = "__svml_logf16";
      v297 = "__log_finite";
      v302 = "__log_finite";
      v304 = "__svml_log4";
      v306 = "__log_finite";
      v308 = "__svml_log8";
      v311 = "__logf_finite";
      v315 = "__logf_finite";
      v320 = "__logf_finite";
      v322 = "__svml_logf16";
      v331 = "__svml_log4";
      v335 = "__svml_log8";
      v338 = "llvm.log.f32";
      v342 = "llvm.log.f32";
      v347 = "llvm.log.f32";
      v349 = "__svml_logf16";
      v388 = 13;
      v389 = "__svml_log28";
      v390 = 12;
      v384 = 13;
      v385 = "__svml_log24";
      v386 = xmmword_1C85F67E0;
      v387 = "__log2_finite";
      v365 = "log2f";
      v366 = 5;
      v381 = 12;
      v382 = 2;
      v383 = "__log2_finite";
      v377 = xmmword_1C85F6820;
      v378 = "__log2_finite";
      v379 = 13;
      v380 = "__svml_log22";
      v374 = "log2f";
      v375 = 5;
      v376 = "__svml_log2f16";
      v371 = "__svml_log2f8";
      v372 = 13;
      v373 = 8;
      v367 = "__svml_log2f4";
      v368 = xmmword_1C85F6810;
      v369 = "log2f";
      v370 = 5;
      v361 = 4;
      v362 = "__svml_log28";
      v363 = 12;
      v364 = 8;
      v351 = "log2";
      v356 = "log2";
      v357 = 4;
      v358 = "__svml_log24";
      v359 = xmmword_1C85F67E0;
      v360 = "log2";
      v352 = 4;
      v353 = "__svml_log22";
      v354 = 12;
      v355 = 2;
      v201 = 11;
      v290 = "__svml_logf8";
      v317 = "__svml_logf8";
      v346 = 8;
      v348 = 12;
      v350 = xmmword_1C85F6800;
      v344 = "__svml_logf8";
      v341 = xmmword_1C85F67E0;
      v343 = 12;
      v345 = 12;
      v202 = 8;
      v286 = "__svml_logf4";
      v313 = "__svml_logf4";
      v337 = 8;
      v339 = 12;
      v340 = "__svml_logf4";
      v332 = xmmword_1C85F67C0;
      v333 = "llvm.log.f64";
      v334 = 12;
      v336 = 11;
      v204 = 4;
      v324 = "llvm.log.f64";
      v327 = 11;
      v328 = 2;
      v329 = "llvm.log.f64";
      v330 = 12;
      v321 = 13;
      v323 = xmmword_1C85F6800;
      v325 = 12;
      v326 = "__svml_log2";
      v206 = xmmword_1C85F67E0;
      v208 = 4;
      v210 = 12;
      v316 = 13;
      v318 = 12;
      v319 = 8;
      v211 = 8;
      v213 = 4;
      v309 = 11;
      v310 = 8;
      v312 = 13;
      v314 = xmmword_1C85F67E0;
      v215 = xmmword_1C85F6800;
      v217 = 12;
      v219 = 11;
      v303 = 12;
      v305 = xmmword_1C85F67C0;
      v307 = 12;
      v220 = 2;
      v222 = 12;
      v298 = 12;
      v299 = "__svml_log2";
      v300 = 11;
      v301 = 2;
      v224 = xmmword_1C85F67C0;
      v226 = 12;
      v291 = 12;
      v292 = 8;
      v294 = 4;
      v296 = xmmword_1C85F6800;
      v227 = "__svml_exp8";
      v228 = 11;
      v229 = 8;
      v285 = 4;
      v287 = xmmword_1C85F67E0;
      v289 = 4;
      v231 = 13;
      v233 = xmmword_1C85F67E0;
      v235 = 13;
      v237 = 12;
      v282 = 11;
      v283 = 8;
      v238 = 8;
      v240 = 13;
      v242 = xmmword_1C85F6800;
      v273 = 11;
      v274 = 2;
      v278 = xmmword_1C85F67C0;
      v244 = 12;
      v246 = 11;
      v247 = 2;
      v249 = 12;
      v269 = xmmword_1C85F6800;
      v272 = "__svml_log2";
      v264 = 12;
      v265 = 8;
      v266 = "llvm.exp.f32";
      v267 = 12;
      v251 = xmmword_1C85F67C0;
      v253 = 12;
      v258 = 12;
      v260 = xmmword_1C85F67E0;
      v261 = "llvm.exp.f32";
      v262 = 12;
      v254 = "__svml_exp8";
      v255 = 11;
      v256 = 8;
      v257 = "llvm.exp.f32";
      v391 = 8;
      v392 = "__log2f_finite";
      v393 = 14;
      v394 = "__svml_log2f4";
      v395 = xmmword_1C85F6810;
      v396 = "__log2f_finite";
      v397 = 14;
      v398 = "__svml_log2f8";
      v399 = 13;
      v400 = 8;
      v401 = "__log2f_finite";
      v402 = 14;
      v403 = "__svml_log2f16";
      v404 = xmmword_1C85F6820;
      v405 = "llvm.log2.f64";
      v406 = 13;
      v407 = "__svml_log22";
      v408 = 12;
      v409 = 2;
      v410 = "llvm.log2.f64";
      v411 = 13;
      v412 = "__svml_log24";
      v413 = xmmword_1C85F67E0;
      v414 = "llvm.log2.f64";
      v415 = 13;
      v416 = "__svml_log28";
      v417 = 12;
      v418 = 8;
      v419 = "llvm.log2.f32";
      v420 = 13;
      v421 = "__svml_log2f4";
      v422 = xmmword_1C85F6810;
      v423 = "llvm.log2.f32";
      v424 = 13;
      v425 = "__svml_log2f8";
      v426 = 13;
      v427 = 8;
      v428 = "llvm.log2.f32";
      v429 = 13;
      v430 = "__svml_log2f16";
      v431 = xmmword_1C85F6820;
      v432 = "log10";
      v433 = 5;
      v434 = "__svml_log102";
      v435 = 13;
      v436 = 2;
      v437 = "log10";
      v438 = 5;
      v439 = "__svml_log104";
      v440 = xmmword_1C85F6810;
      v441 = "log10";
      v442 = 5;
      v443 = "__svml_log108";
      v444 = 13;
      v445 = 8;
      v446 = "log10f";
      v447 = 6;
      v448 = "__svml_log10f4";
      v449 = xmmword_1C85F6830;
      v450 = "log10f";
      v451 = 6;
      v452 = "__svml_log10f8";
      v453 = 14;
      v454 = 8;
      v455 = "log10f";
      v456 = 6;
      v457 = "__svml_log10f16";
      v458 = xmmword_1C85F6840;
      v459 = "__log10_finite";
      v460 = 14;
      v461 = "__svml_log102";
      v462 = 13;
      v463 = 2;
      v464 = "__log10_finite";
      v465 = 14;
      v466 = "__svml_log104";
      v467 = xmmword_1C85F6810;
      v468 = "__log10_finite";
      v469 = 14;
      v470 = "__svml_log108";
      v471 = 13;
      v472 = 8;
      v473 = "__log10f_finite";
      v474 = 15;
      v475 = "__svml_log10f4";
      v476 = xmmword_1C85F6830;
      v477 = "__log10f_finite";
      v478 = 15;
      v479 = "__svml_log10f8";
      v480 = 14;
      v481 = 8;
      v482 = "__log10f_finite";
      v483 = 15;
      v484 = "__svml_log10f16";
      v485 = xmmword_1C85F6840;
      v486 = "llvm.log10.f64";
      v487 = 14;
      v488 = "__svml_log102";
      v489 = 13;
      v490 = 2;
      v491 = "llvm.log10.f64";
      v492 = 14;
      v493 = "__svml_log104";
      v494 = xmmword_1C85F6810;
      v495 = "llvm.log10.f64";
      v496 = 14;
      v497 = "__svml_log108";
      v498 = 13;
      v499 = 8;
      v500 = "llvm.log10.f32";
      v501 = 14;
      v502 = "__svml_log10f4";
      v503 = xmmword_1C85F6830;
      v504 = "llvm.log10.f32";
      v505 = 14;
      v506 = "__svml_log10f8";
      v507 = 14;
      v508 = 8;
      v509 = "llvm.log10.f32";
      v510 = 14;
      v511 = "__svml_log10f16";
      v512 = xmmword_1C85F6840;
      v513 = "sqrt";
      v514 = 4;
      v515 = "__svml_sqrt2";
      v516 = 12;
      v517 = 2;
      v518 = "sqrt";
      v519 = 4;
      v520 = "__svml_sqrt4";
      v521 = xmmword_1C85F67E0;
      v522 = "sqrt";
      v523 = 4;
      v524 = "__svml_sqrt8";
      v525 = 12;
      v526 = 8;
      v527 = "sqrtf";
      v528 = 5;
      v529 = "__svml_sqrtf4";
      v530 = xmmword_1C85F6810;
      v531 = "sqrtf";
      v532 = 5;
      v533 = "__svml_sqrtf8";
      v534 = 13;
      v535 = 8;
      v536 = "sqrtf";
      v537 = 5;
      v538 = "__svml_sqrtf16";
      v539 = xmmword_1C85F6820;
      v540 = "__sqrt_finite";
      v541 = 13;
      v542 = "__svml_sqrt2";
      v543 = 12;
      v544 = 2;
      v545 = "__sqrt_finite";
      v546 = 13;
      v547 = "__svml_sqrt4";
      v548 = xmmword_1C85F67E0;
      v549 = "__sqrt_finite";
      v550 = 13;
      v551 = "__svml_sqrt8";
      v552 = 12;
      v553 = 8;
      v554 = "__sqrtf_finite";
      v555 = 14;
      v556 = "__svml_sqrtf4";
      v557 = xmmword_1C85F6810;
      v558 = "__sqrtf_finite";
      v559 = 14;
      v560 = "__svml_sqrtf8";
      v561 = 13;
      v562 = 8;
      v563 = "__sqrtf_finite";
      v564 = 14;
      v565 = "__svml_sqrtf16";
      v566 = xmmword_1C85F6820;
      v567 = "exp2";
      v568 = 4;
      v569 = "__svml_exp22";
      v570 = 12;
      v571 = 2;
      v572 = "exp2";
      v573 = 4;
      v574 = "__svml_exp24";
      v575 = xmmword_1C85F67E0;
      v576 = "exp2";
      v577 = 4;
      v578 = "__svml_exp28";
      v579 = 12;
      v580 = 8;
      v581 = "exp2f";
      v582 = 5;
      v583 = "__svml_exp2f4";
      v584 = xmmword_1C85F6810;
      v585 = "exp2f";
      v586 = 5;
      v587 = "__svml_exp2f8";
      v588 = 13;
      v589 = 8;
      v590 = "exp2f";
      v591 = 5;
      v592 = "__svml_exp2f16";
      v593 = xmmword_1C85F6820;
      v594 = "llvm.exp2.f64";
      v595 = 13;
      v596 = "__svml_exp22";
      v597 = 12;
      v598 = 2;
      v599 = "llvm.exp2.f64";
      v600 = 13;
      v601 = "__svml_exp24";
      v602 = xmmword_1C85F67E0;
      v603 = "llvm.exp2.f64";
      v604 = 13;
      v605 = "__svml_exp28";
      v606 = 12;
      v607 = 8;
      v608 = "llvm.exp2.f32";
      v609 = 13;
      v610 = "__svml_exp2f4";
      v611 = xmmword_1C85F6810;
      v612 = "llvm.exp2.f32";
      v613 = 13;
      v614 = "__svml_exp2f8";
      v615 = 13;
      v616 = 8;
      v617 = "llvm.exp2.f32";
      v618 = 13;
      v619 = "__svml_exp2f16";
      v620 = xmmword_1C85F6820;
      v621 = "__exp2_finite";
      v622 = 13;
      v623 = "__svml_exp22";
      v624 = 12;
      v625 = 2;
      v626 = "__exp2_finite";
      v627 = 13;
      v628 = "__svml_exp24";
      v629 = xmmword_1C85F67E0;
      v630 = "__exp2_finite";
      v631 = 13;
      v632 = "__svml_exp28";
      v633 = 12;
      v634 = 8;
      v635 = "__exp2f_finite";
      v636 = 14;
      v637 = "__svml_exp2f4";
      v638 = xmmword_1C85F6810;
      v639 = "__exp2f_finite";
      v640 = 14;
      v641 = "__svml_exp2f8";
      v642 = 13;
      v643 = 8;
      v644 = "__exp2f_finite";
      v645 = 14;
      v646 = "__svml_exp2f16";
      v647 = xmmword_1C85F6820;
      v2 = 144;
LABEL_7:
      llvm::TargetLibraryInfoImpl::addVectorizableFunctions(v0, (char *)&__src, v2);
      break;
    default:
      return;
  }
}

llvm::TargetLibraryInfoWrapperPass *llvm::TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(llvm::TargetLibraryInfoWrapperPass *this)
{
  char *v2;
  uint64_t *v3;
  unint64_t v4;
  unint64_t PassRegistry;
  _QWORD *v7;
  _QWORD v8[2];
  uint64_t v9[26];

  v9[25] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::TargetLibraryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813D4C8;
  v2 = (char *)this + 32;
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((llvm::TargetLibraryInfoImpl *)v9);
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((uint64_t)v2, (uint64_t)v9);
  *((_BYTE *)this + 232) = 1;
  v3 = sub_1C61BB478(v9);
  *((_BYTE *)this + 240) = 0;
  *((_BYTE *)this + 320) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v3);
  v4 = atomic_load(&qword_1ED82EB30);
  if (v4 != -1)
  {
    v8[0] = sub_1C4F7A00C;
    v8[1] = &PassRegistry;
    v7 = v8;
    std::__call_once(&qword_1ED82EB30, &v7, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

llvm::TargetLibraryInfoWrapperPass *llvm::TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(llvm::TargetLibraryInfoWrapperPass *this, const llvm::Triple *a2)
{
  char *v3;
  __int128 v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t PassRegistry;
  _QWORD *v9;
  _QWORD v10[2];
  _OWORD v11[6];
  _BYTE v12[21];
  uint64_t v13;
  uint64_t v14;
  int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::TargetLibraryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813D4C8;
  v3 = (char *)this + 32;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  *(_QWORD *)&v4 = -1;
  *((_QWORD *)&v4 + 1) = -1;
  v11[0] = v4;
  v11[1] = v4;
  v11[2] = v4;
  v11[3] = v4;
  v11[4] = v4;
  v11[5] = v4;
  *(_OWORD *)v12 = v4;
  *(_QWORD *)&v12[13] = -1;
  sub_1C4F777B0((uint64_t)v11, (int *)a2);
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((uint64_t)v3, (uint64_t)v11);
  *((_BYTE *)this + 232) = 1;
  v5 = sub_1C61BB478((uint64_t *)v11);
  *((_BYTE *)this + 240) = 0;
  *((_BYTE *)this + 320) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v5);
  v6 = atomic_load(&qword_1ED82EB30);
  if (v6 != -1)
  {
    v10[0] = sub_1C4F7A00C;
    v10[1] = &PassRegistry;
    v9 = v10;
    std::__call_once(&qword_1ED82EB30, &v9, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

llvm::TargetLibraryInfoWrapperPass *llvm::TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(llvm::TargetLibraryInfoWrapperPass *this, const llvm::TargetLibraryInfoImpl *a2)
{
  char *v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t PassRegistry;
  _QWORD *v8;
  _QWORD v9[2];
  uint64_t v10[26];

  v10[25] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::TargetLibraryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813D4C8;
  v3 = (char *)this + 32;
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((uint64_t)v10, (__int128 *)a2);
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((uint64_t)v3, (uint64_t)v10);
  *((_BYTE *)this + 232) = 1;
  v4 = sub_1C61BB478(v10);
  *((_BYTE *)this + 240) = 0;
  *((_BYTE *)this + 320) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v4);
  v5 = atomic_load(&qword_1ED82EB30);
  if (v5 != -1)
  {
    v9[0] = sub_1C4F7A00C;
    v9[1] = &PassRegistry;
    v8 = v9;
    std::__call_once(&qword_1ED82EB30, &v8, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void sub_1C61BB210(llvm::ImmutablePass *a1)
{
  sub_1C61BB4F0(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61BB234(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E813D5E0;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

uint64_t sub_1C61BB274(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int v12;

  v12 = 0;
  v8 = sub_1C6159B48(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v12);
  if ((v8 & 1) != 0)
    return v8;
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C61BB2EC(v11);
}

uint64_t sub_1C61BB2EC(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 160) + 24))
    return 2;
  else
    return 3;
}

void sub_1C61BB304(_QWORD *a1)
{
  sub_1C4F7A1DC(a1);
  JUMPOUT(0x1CAA32FC0);
}

unint64_t sub_1C61BB328(uint64_t a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth(a1 + 152, a1);
}

uint64_t sub_1C61BB334(uint64_t a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::generic_parser_base *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C61BB344(llvm::raw_ostream *result, int a2, int a3)
{
  int v3;
  uint64_t (**v4)();
  int v5;
  char v6;

  if (a3)
  {
    v3 = *((_DWORD *)result + 32);
LABEL_3:
    v4 = &off_1E813D630;
    v6 = 1;
    v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((_BYTE *)result + 148))
  {
    v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3)
      goto LABEL_3;
  }
  return result;
}

_QWORD *sub_1C61BB3B0(uint64_t a1, uint64_t a2)
{
  return sub_1C4B03438((_QWORD *)(a1 + 152), a2);
}

void sub_1C61BB3B8(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E813D5E0;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61BB408(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1C61BB410(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1C61BB424(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1C61BB438(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1C61BB44C(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 12) && *(_BYTE *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

uint64_t *sub_1C61BB478(uint64_t *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[22];
  if (v2)
  {
    a1[23] = (uint64_t)v2;
    operator delete(v2);
  }
  v3 = (void *)a1[19];
  if (v3)
  {
    a1[20] = (uint64_t)v3;
    operator delete(v3);
  }
  sub_1C4F7A8C4(a1 + 15);
  return a1;
}

llvm::TargetLibraryInfoWrapperPass *llvm::callDefaultCtor<llvm::TargetLibraryInfoWrapperPass>()
{
  llvm::TargetLibraryInfoWrapperPass *v0;

  v0 = (llvm::TargetLibraryInfoWrapperPass *)operator new();
  return llvm::TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(v0);
}

void sub_1C61BB4F0(llvm::ImmutablePass *this)
{
  char *v2;

  *(_QWORD *)this = &off_1E813D4C8;
  if (*((_BYTE *)this + 320))
  {
    v2 = (char *)*((_QWORD *)this + 31);
    if (v2 != (char *)this + 264)
      free(v2);
    *((_BYTE *)this + 320) = 0;
  }
  if (*((_BYTE *)this + 232))
  {
    sub_1C61BB478((uint64_t *)this + 4);
    *((_BYTE *)this + 232) = 0;
  }
  llvm::ImmutablePass::~ImmutablePass(this);
}

void sub_1C61BB550(_WORD *a1, __int128 *a2, int **a3, uint64_t a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F44B8, 0, 0);
  dword_1ED7F4538 = 0;
  qword_1ED7F4540 = (uint64_t)&off_1E813D630;
  *(_QWORD *)&dword_1ED7F4548 = 0;
  qword_1ED7F44B8 = (uint64_t)off_1E813D578;
  qword_1ED7F4550 = (uint64_t)&off_1E813D5E0;
  qword_1ED7F4558 = (uint64_t)&qword_1ED7F44B8;
  qword_1ED7F4560 = (uint64_t)&unk_1ED7F4570;
  qword_1ED7F4568 = 0x800000000;
  qword_1ED7F46F0 = (uint64_t)&off_1E813D670;
  qword_1ED7F4708 = (uint64_t)&qword_1ED7F46F0;
  sub_1C61BB608(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F44B8);
}

void sub_1C61BB608(_WORD *a1, __int128 *a2, int **a3, uint64_t a4)
{
  int *v8;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F44B8, "vector-library", 0xEuLL);
  word_1ED7F44C2 = (32 * (*a1 & 3)) | word_1ED7F44C2 & 0xFF9F;
  xmmword_1ED7F44D8 = *a2;
  v8 = *a3;
  dword_1ED7F4538 = **a3;
  byte_1ED7F454C = 1;
  dword_1ED7F4548 = *v8;
  sub_1C4F7AC48(*(_QWORD *)a4, *(_DWORD *)(a4 + 8));
}

void sub_1C61BB6A4()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61BB6B8()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E813D670;
  return result;
}

void sub_1C61BB6DC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E813D670;
}

void sub_1C61BB6F8(unint64_t a1)
{
  _OWORD *v1;
  _OWORD *v2;
  uint64_t v3;
  _OWORD *v4;
  __int128 v5;
  int v6;
  int v7;
  unint64_t v8;

  v8 = 0;
  v1 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)&qword_1ED7F4560, a1, 48, &v8);
  v2 = (_OWORD *)qword_1ED7F4560;
  if ((_DWORD)qword_1ED7F4568)
  {
    v3 = qword_1ED7F4560 + 48 * qword_1ED7F4568;
    v4 = v1;
    do
    {
      v5 = v2[1];
      *v4 = *v2;
      v4[1] = v5;
      *((_QWORD *)v4 + 4) = &off_1E813D650;
      v6 = *((_DWORD *)v2 + 10);
      *((_BYTE *)v4 + 44) = *((_BYTE *)v2 + 44);
      *((_DWORD *)v4 + 10) = v6;
      *((_QWORD *)v4 + 4) = &off_1E813D630;
      v2 += 3;
      v4 += 3;
    }
    while (v2 != (_OWORD *)v3);
    v2 = (_OWORD *)qword_1ED7F4560;
  }
  v7 = v8;
  if (v2 != (_OWORD *)&unk_1ED7F4570)
    free(v2);
  qword_1ED7F4560 = (uint64_t)v1;
  HIDWORD(qword_1ED7F4568) = v7;
}

uint64_t sub_1C61BB7C4(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 200))
  {
    sub_1C4F789E8((uint64_t *)(a1 + 120), (uint64_t *)(a2 + 120));
    *(_BYTE *)(a1 + 144) = *(_BYTE *)(a2 + 144);
    *(_WORD *)(a1 + 145) = *(_WORD *)(a2 + 145);
    *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 148);
    memmove((void *)a1, (const void *)a2, 0x75uLL);
  }
  else
  {
    llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl(a1, a2);
    *(_BYTE *)(a1 + 200) = 1;
  }
  return a1;
}

uint64_t llvm::HardwareLoopInfo::canAnalyze(llvm::HardwareLoopInfo *this, llvm::LoopInfo *a2)
{
  uint64_t v3;
  _QWORD v5[7];

  sub_1C4DFE414((uint64_t)v5, *(_QWORD *)this);
  llvm::LoopBlocksDFS::perform((llvm::LoopBlocksDFS *)v5, a2);
  v3 = sub_1C4F7C2CC((uint64_t)v5, (uint64_t *)a2) ^ 1;
  sub_1C4F7DAC4(v5);
  return v3;
}

uint64_t llvm::IntrinsicCostAttributes::IntrinsicCostAttributes(uint64_t a1, int a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 16) = a2;
  v6 = a1 + 40;
  *(_QWORD *)(a1 + 24) = a1 + 40;
  v7 = a1 + 24;
  *(_QWORD *)(a1 + 32) = 0x400000000;
  *(_QWORD *)(a1 + 72) = a1 + 88;
  *(_QWORD *)(a1 + 80) = 0x400000000;
  *(_DWORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 128) = xmmword_1C64632D0;
  sub_1C61BB99C((unsigned int *)(a1 + 72), a1 + 88, a4, &a4[a5]);
  v8 = *(unsigned int *)(a1 + 80);
  if (*(_DWORD *)(a1 + 36) < v8)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v7, v6, v8, 8);
    LODWORD(v8) = *(_DWORD *)(a1 + 80);
  }
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = *(_DWORD *)(a1 + 32);
    v11 = 8 * v8;
    do
    {
      v12 = **(_QWORD **)(*(_QWORD *)(a1 + 72) + v9);
      if (v10 >= *(_DWORD *)(a1 + 36))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v7, v6, v10 + 1, 8);
        v10 = *(_DWORD *)(a1 + 32);
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v10) = v12;
      v10 = *(_DWORD *)(a1 + 32) + 1;
      *(_DWORD *)(a1 + 32) = v10;
      v9 += 8;
    }
    while (v11 != v9);
  }
  return a1;
}

_BYTE *sub_1C61BB99C(unsigned int *a1, uint64_t a2, uint64_t *__src, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  unint64_t v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t v17;

  v5 = __src;
  v7 = *(_QWORD *)a1;
  v8 = (a2 - *(_QWORD *)a1) >> 3;
  v9 = a1[2];
  if (*(_QWORD *)a1 + 8 * v9 == a2)
  {
    sub_1C618A450(a1, __src, a4);
    return (_BYTE *)(*(_QWORD *)a1 + 8 * v8);
  }
  else
  {
    v10 = (char *)a4 - (char *)__src;
    v11 = a4 - __src;
    if (v9 + v11 > a1[3])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, (uint64_t)(a1 + 4), v9 + v11, 8);
      v7 = *(_QWORD *)a1;
      v9 = a1[2];
    }
    v12 = (_BYTE *)(v7 + 8 * v8);
    v13 = (_BYTE *)(v7 + 8 * v9);
    v14 = (v13 - v12) >> 3;
    if (v14 >= v11)
    {
      sub_1C6177054(a1, &v13[-8 * v11], (char *)(v7 + 8 * v9));
      if (&v13[-8 * v11] != v12)
        memmove(&v12[8 * v11], v12, &v13[-8 * v11] - v12);
      if (v5 != a4)
        memmove(v12, v5, (char *)a4 - (char *)v5);
    }
    else
    {
      v15 = v9 + (v10 >> 3);
      a1[2] = v15;
      if (v8 != v9)
      {
        memcpy((void *)(v7 + 8 * v15 - 8 * v14), v12, v13 - v12);
        v16 = v12;
        do
        {
          v17 = *v5++;
          *v16++ = v17;
          --v14;
        }
        while (v14);
      }
      if (v5 != a4)
        memcpy(v13, v5, (char *)a4 - (char *)v5);
    }
  }
  return v12;
}

uint64_t llvm::TargetTransformInfo::getGEPCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 24))(*a1);
}

uint64_t llvm::TargetTransformInfo::useGPUDivergenceAnalysis(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 96))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::isSourceOfDivergence(llvm::TargetTransformInfo *this, const llvm::Value *a2)
{
  return (*(uint64_t (**)(_QWORD, const llvm::Value *))(**(_QWORD **)this + 104))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isAlwaysUniform(llvm::TargetTransformInfo *this, const llvm::Value *a2)
{
  return (*(uint64_t (**)(_QWORD, const llvm::Value *))(**(_QWORD **)this + 112))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getFlatAddressSpace(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 120))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::collectFlatAddressOperands(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 128))(*a1);
}

uint64_t llvm::TargetTransformInfo::isNoopAddrSpaceCast(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 136))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getAssumedAddrSpace(llvm::TargetTransformInfo *this, const llvm::Value *a2)
{
  return (*(uint64_t (**)(_QWORD, const llvm::Value *))(**(_QWORD **)this + 152))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::rewriteIntrinsicWithAddressSpace(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 168))(*a1);
}

uint64_t llvm::TargetTransformInfo::isHardwareLoopProfitable(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 200))(*a1);
}

uint64_t llvm::TargetTransformInfo::preferPredicateOverEpilogue(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 208))(*a1);
}

uint64_t llvm::TargetTransformInfo::emitGetActiveLaneMask(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 216))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::isLegalAddImmediate(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 248))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::isLegalICmpImmediate(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 256))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::isLegalAddressingMode(llvm::TargetTransformInfo *this, llvm::Type *a2, llvm::GlobalValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, llvm::Instruction *a8)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *, llvm::GlobalValue *, uint64_t, uint64_t, uint64_t, uint64_t, llvm::Instruction *))(**(_QWORD **)this + 264))(*(_QWORD *)this, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t llvm::TargetTransformInfo::isLSRCostLess(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 272))(*a1);
}

uint64_t llvm::TargetTransformInfo::isNumRegsMajorCostOfLSR(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 280))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::isProfitableLSRChainElement(llvm::TargetTransformInfo *this, llvm::Instruction *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Instruction *))(**(_QWORD **)this + 288))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::canMacroFuseCmp(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 296))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::canSaveCmp(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 304))(*a1);
}

uint64_t llvm::TargetTransformInfo::getPreferredAddressingMode(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 312))(*a1);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedStore(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 320))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedLoad(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 328))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalNTStore(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 336))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalNTLoad(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 344))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalBroadcastLoad(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 352))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedGather(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 368))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedScatter(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 360))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::forceScalarizeMaskedGather(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 376))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::forceScalarizeMaskedScatter(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 384))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedCompressStore(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 392))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedExpandLoad(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 400))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::enableOrderedReductions(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 408))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::hasDivRemOp(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 416))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::hasVolatileVariant(llvm::TargetTransformInfo *this, llvm::Instruction *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Instruction *))(**(_QWORD **)this + 424))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::prefersVectorizedAddressing(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 432))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getScalingFactorCost(llvm::TargetTransformInfo *this, llvm::Type *a2, llvm::GlobalValue *a3)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *, llvm::GlobalValue *))(**(_QWORD **)this + 440))(*(_QWORD *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::LSRWithInstrQueries(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 448))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::useAA(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 472))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::isTypeLegal(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 480))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getRegUsageForType(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 488))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::shouldBuildRelLookupTables(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 512))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getScalarizationOverhead(llvm::TargetTransformInfo *this, llvm::VectorType *a2, const llvm::APInt *a3)
{
  return (*(uint64_t (**)(_QWORD, llvm::VectorType *, const llvm::APInt *))(**(_QWORD **)this + 528))(*(_QWORD *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::getOperandsScalarizationOverhead(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 536))(*a1);
}

uint64_t llvm::TargetTransformInfo::supportsEfficientVectorElementLoadStore(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 544))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::enableAggressiveInterleaving(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 552))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::enableMemCmpExpansion(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 560))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::enableInterleavedAccessVectorization(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 568))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::enableMaskedInterleavedAccessVectorization(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 576))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::shouldDistributeLoopToImproveMemoryThroughput(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 584))(*a1);
}

uint64_t llvm::TargetTransformInfo::isFPVectorizationPotentiallyUnsafe(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 592))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getPopcntSupport(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 608))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::haveFastSqrt(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 616))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isFCmpOrdCheaperThanFCmpZero(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 624))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getIntImmCodeSizeCost(llvm::TargetTransformInfo *this, uint64_t a2, uint64_t a3, const llvm::APInt *a4, llvm::Type *a5)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, const llvm::APInt *, llvm::Type *))(**(_QWORD **)this
                                                                                                + 640))(*(_QWORD *)this, a2, a3, a4, a5);
}

uint64_t llvm::TargetTransformInfo::getIntImmCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 648))(*a1);
}

uint64_t llvm::TargetTransformInfo::getIntImmCostInst(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 656))(*a1);
}

uint64_t llvm::TargetTransformInfo::getIntImmCostIntrin(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 664))(*a1);
}

uint64_t llvm::TargetTransformInfo::getNumberOfRegisters(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 672))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getRegisterClassForType(llvm::TargetTransformInfo *this, uint64_t a2, llvm::Type *a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, llvm::Type *))(**(_QWORD **)this + 680))(*(_QWORD *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::getRegisterBitWidth(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 696))(*a1);
}

uint64_t llvm::TargetTransformInfo::getMinVectorRegisterBitWidth(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 704))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getMaxVScale(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 712))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getVScaleForTuning(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 720))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::shouldMaximizeVectorBandwidth(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 728))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getMinimumVF(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 736))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getMaximumVF(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 744))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getCacheLineSize(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 760))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getPrefetchDistance(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 784))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getMinPrefetchStride(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 792))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getMaxPrefetchIterationsAhead(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 800))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::enableWritePrefetching(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 808))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getMaxInterleaveFactor(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 816))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getShuffleCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 832))(*a1);
}

uint64_t llvm::TargetTransformInfo::getCastInstrCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 840))(*a1);
}

uint64_t llvm::TargetTransformInfo::getExtractWithExtendCost(llvm::TargetTransformInfo *this, uint64_t a2, llvm::Type *a3, llvm::VectorType *a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, llvm::Type *, llvm::VectorType *))(**(_QWORD **)this + 848))(*(_QWORD *)this, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getCFInstrCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 856))(*a1);
}

uint64_t llvm::TargetTransformInfo::getVectorInstrCost(llvm::TargetTransformInfo *this, uint64_t a2, llvm::Type *a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, llvm::Type *))(**(_QWORD **)this + 872))(*(_QWORD *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::getMemoryOpCost(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned __int8 a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)*a1 + 888))(*a1, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getMaskedMemoryOpCost(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned __int8 a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)*a1 + 904))(*a1, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getGatherScatterOpCost(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)*a1 + 912))(*a1, a2, a3, a4, a5, a6);
}

uint64_t llvm::TargetTransformInfo::getInterleavedMemoryOpCost(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)*a1 + 920))(*a1, a2, a3, a4, a5, a6, a7);
}

uint64_t llvm::TargetTransformInfo::getIntrinsicInstrCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 952))(*a1);
}

uint64_t llvm::TargetTransformInfo::getCallInstrCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 960))(*a1);
}

uint64_t llvm::TargetTransformInfo::getNumberOfParts(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 968))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getAddressComputationCost(llvm::TargetTransformInfo *this, llvm::Type *a2, llvm::ScalarEvolution *a3, const llvm::SCEV *a4)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *, llvm::ScalarEvolution *, const llvm::SCEV *))(**(_QWORD **)this + 976))(*(_QWORD *)this, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getArithmeticReductionCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 928))(*a1);
}

uint64_t llvm::TargetTransformInfo::getMinMaxReductionCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 936))(*a1);
}

uint64_t llvm::TargetTransformInfo::getExtendedAddReductionCost(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 944))(*a1);
}

uint64_t llvm::TargetTransformInfo::getCostOfKeepingLiveOverCall(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 984))(*a1);
}

uint64_t llvm::TargetTransformInfo::getAtomicMemIntrinsicMaxElementSize(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 1000))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getOrCreateResultFromMemIntrinsic(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 1008))(*a1);
}

uint64_t llvm::TargetTransformInfo::isIndexedLoadLegal(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 1048))(*a1);
}

uint64_t llvm::TargetTransformInfo::isIndexedStoreLegal(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 1056))(*a1);
}

uint64_t llvm::TargetTransformInfo::isLegalToVectorizeReduction(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 1104))(*a1);
}

uint64_t llvm::TargetTransformInfo::isElementTypeLegalForScalableVector(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(_QWORD, llvm::Type *))(**(_QWORD **)this + 1112))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::preferInLoopReduction(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)*a1 + 1136))(*a1, a2, a3, *(_QWORD *)&a4 & 0xFFFFFFLL);
}

uint64_t llvm::TargetTransformInfo::preferPredicatedReductionSelect(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)*a1 + 1144))(*a1, a2, a3, *(_QWORD *)&a4 & 0xFFFFFFLL);
}

uint64_t llvm::TargetTransformInfo::getVPLegalizationStrategy(llvm::TargetTransformInfo *this, const llvm::VPIntrinsic *a2)
{
  return (*(uint64_t (**)(_QWORD, const llvm::VPIntrinsic *))(**(_QWORD **)this + 1200))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::shouldExpandReduction(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 1152))(*a1);
}

uint64_t llvm::TargetTransformInfo::getGISelRematGlobalCost(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 1160))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::supportsScalableVectors(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 1176))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::enableScalableVectorization(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 1168))(*(_QWORD *)this);
}

uint64_t llvm::TargetTransformInfo::getInstructionLatency(llvm::TargetTransformInfo *this, const llvm::Instruction *a2)
{
  return (*(uint64_t (**)(_QWORD, const llvm::Instruction *))(**(_QWORD **)this + 1192))(*(_QWORD *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getInstructionThroughput(llvm::TargetTransformInfo *this, const llvm::Instruction *a2)
{
  unsigned int v2;
  BOOL v3;
  unint64_t v4;

  v2 = *((unsigned __int8 *)a2 + 16) - 29;
  v3 = v2 > 0x3F;
  v4 = (1 << v2) & 0xF1F3FFE3BFFFF807;
  if (v3 || v4 == 0)
    return -1;
  else
    return sub_1C4DE9CE4(this, (uint64_t)a2);
}

_QWORD *llvm::TargetIRAnalysis::getDefaultTTI@<X0>(llvm::TargetIRAnalysis *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *result;

  v4 = *((_QWORD *)this + 5) + 272;
  result = (_QWORD *)operator new();
  *result = &off_1E813D768;
  result[1] = v4;
  *a2 = result;
  return result;
}

llvm::TargetTransformInfoWrapperPass *llvm::TargetTransformInfoWrapperPass::TargetTransformInfoWrapperPass(llvm::TargetTransformInfoWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = llvm::TargetTransformInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813D6B8;
  *((_QWORD *)this + 4) = &off_1E813DC50;
  *((_QWORD *)this + 5) = llvm::TargetIRAnalysis::getDefaultTTI;
  *((_QWORD *)this + 7) = (char *)this + 32;
  *((_BYTE *)this + 64) = 0;
  *((_BYTE *)this + 72) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EB38);
  if (v2 != -1)
  {
    v6[0] = sub_1C4F7D948;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EB38, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::TargetTransformInfoWrapperPass::TargetTransformInfoWrapperPass(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t PassRegistry;
  _QWORD *v7;
  _QWORD v8[2];

  v2 = a1;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = &llvm::TargetTransformInfoWrapperPass::ID;
  *(_DWORD *)(a1 + 24) = 4;
  *(_QWORD *)a1 = &off_1E813D6B8;
  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 56) = a1 + 32;
      a1 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1 + 32);
    }
    else
    {
      *(_QWORD *)(a1 + 56) = v3;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 56) = 0;
  }
  *(_BYTE *)(v2 + 64) = 0;
  *(_BYTE *)(v2 + 72) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  v4 = atomic_load(&qword_1ED82EB38);
  if (v4 != -1)
  {
    v8[0] = sub_1C4F7D948;
    v8[1] = &PassRegistry;
    v7 = v8;
    std::__call_once(&qword_1ED82EB38, &v7, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return v2;
}

uint64_t llvm::createTargetTransformInfoWrapperPass(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void (**v5)(_QWORD *);
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = operator new();
  v3 = (_QWORD *)a1[3];
  if (v3)
  {
    if (v3 == a1)
    {
      v8 = v7;
      (*(void (**)(_QWORD *, _QWORD *))(*a1 + 24))(a1, v7);
    }
    else
    {
      v8 = (_QWORD *)a1[3];
      a1[3] = 0;
    }
  }
  else
  {
    v8 = 0;
  }
  llvm::TargetTransformInfoWrapperPass::TargetTransformInfoWrapperPass(v2, (uint64_t)v7);
  v4 = v8;
  if (v8 == v7)
  {
    v5 = (void (**)(_QWORD *))(v7[0] + 32);
    v4 = v7;
  }
  else
  {
    if (!v8)
      return v2;
    v5 = (void (**)(_QWORD *))(*v8 + 40);
  }
  (*v5)(v4);
  return v2;
}

void sub_1C61BC658(uint64_t a1)
{
  sub_1C61BC6A4(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::TargetTransformInfoWrapperPass *llvm::callDefaultCtor<llvm::TargetTransformInfoWrapperPass>()
{
  llvm::TargetTransformInfoWrapperPass *v0;

  v0 = (llvm::TargetTransformInfoWrapperPass *)operator new();
  return llvm::TargetTransformInfoWrapperPass::TargetTransformInfoWrapperPass(v0);
}

void sub_1C61BC6A4(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_1E813D6B8;
  if (*(_BYTE *)(a1 + 72))
  {
    v2 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 64) = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *(_BYTE *)(a1 + 72) = 0;
  }
  v3 = *(_QWORD **)(a1 + 56);
  if (v3 == (_QWORD *)(a1 + 32))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 32);
  }
  else
  {
    if (!v3)
      goto LABEL_8;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
}

void sub_1C61BC728()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61BC73C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E813DC50;
  result[1] = v3;
  return result;
}

uint64_t sub_1C61BC770(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E813DC50;
  a2[1] = v2;
  return result;
}

uint64_t sub_1C61BC78C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t llvm::AAMDNodes::merge@<X0>(llvm::MDNode **this@<X0>, llvm::MDNode **a2@<X1>, _QWORD *a3@<X8>)
{
  llvm::MDNode *v6;
  llvm::MDNode *v7;
  llvm::MDNode *v8;
  llvm::MDNode *v9;
  uint64_t result;
  uint64_t v11;

  v6 = *this;
  v7 = *a2;
  v11 = 0;
  sub_1C4F7FD38((uint64_t)v6, (uint64_t)v7, &v11);
  *a3 = v11;
  a3[1] = 0;
  a3[2] = llvm::MDNode::getMostGenericAliasScope(this[2], a2[2], v8);
  result = llvm::MDNode::intersect(this[3], a2[3], v9);
  a3[3] = result;
  return result;
}

uint64_t llvm::AAMDNodes::concat@<X0>(llvm::MDNode **this@<X0>, llvm::MDNode **a2@<X1>, llvm::MDNode *a3@<X2>, _QWORD *a4@<X8>)
{
  llvm::MDNode *v7;
  uint64_t result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = llvm::MDNode::getMostGenericAliasScope(this[2], a2[2], a3);
  result = llvm::MDNode::intersect(this[3], a2[3], v7);
  a4[3] = result;
  return result;
}

void llvm::initializeTypeBasedAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82EC00);
  if (v2 != -1)
  {
    v5[0] = sub_1C4F80104;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82EC00, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::TypeBasedAAWrapperPass *llvm::createTypeBasedAAWrapperPass(llvm *this)
{
  llvm::TypeBasedAAWrapperPass *v1;

  v1 = (llvm::TypeBasedAAWrapperPass *)operator new();
  return llvm::TypeBasedAAWrapperPass::TypeBasedAAWrapperPass(v1);
}

llvm::TypeBasedAAWrapperPass *llvm::TypeBasedAAWrapperPass::TypeBasedAAWrapperPass(llvm::TypeBasedAAWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::TypeBasedAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813DC98;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82EC00);
  if (v2 != -1)
  {
    v6[0] = sub_1C4F80104;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82EC00, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::TypeBasedAAWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

void sub_1C61BC988(llvm::ImmutablePass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813DC98;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C4093837F09);
  llvm::ImmutablePass::~ImmutablePass(this);
}

void sub_1C61BC9D4(llvm::ImmutablePass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813DC98;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C4093837F09);
  llvm::ImmutablePass::~ImmutablePass(this);
  JUMPOUT(0x1CAA32FC0);
}

llvm::TypeBasedAAWrapperPass *llvm::callDefaultCtor<llvm::TypeBasedAAWrapperPass>()
{
  llvm::TypeBasedAAWrapperPass *v0;

  v0 = (llvm::TypeBasedAAWrapperPass *)operator new();
  return llvm::TypeBasedAAWrapperPass::TypeBasedAAWrapperPass(v0);
}

void sub_1C61BCA60(char **a1, _WORD *a2)
{
  uint64_t v4;
  char *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED82EB40, 0, 0);
  byte_1ED82EBC0 = 0;
  qword_1ED82EBC8 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED82EBD0 = 0;
  qword_1ED82EB40 = (uint64_t)&unk_1E819E898;
  qword_1ED82EBD8 = (uint64_t)&off_1E819E9A0;
  qword_1ED82EBE0 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED82EBF8 = (uint64_t)&qword_1ED82EBE0;
  llvm::cl::Option::setArgStr(v4, "enable-tbaa", 0xBuLL);
  v5 = *a1;
  byte_1ED82EBC0 = **a1;
  byte_1ED82EBD1 = 1;
  byte_1ED82EBD0 = *v5;
  word_1ED82EB4A = (32 * (*a2 & 3)) | word_1ED82EB4A & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED82EB40);
}

void llvm::initializeScopedNoAliasAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82ECC8);
  if (v2 != -1)
  {
    v5[0] = sub_1C4F8269C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82ECC8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::ScopedNoAliasAAWrapperPass *llvm::createScopedNoAliasAAWrapperPass(llvm *this)
{
  llvm::ScopedNoAliasAAWrapperPass *v1;

  v1 = (llvm::ScopedNoAliasAAWrapperPass *)operator new();
  return llvm::ScopedNoAliasAAWrapperPass::ScopedNoAliasAAWrapperPass(v1);
}

llvm::ScopedNoAliasAAWrapperPass *llvm::ScopedNoAliasAAWrapperPass::ScopedNoAliasAAWrapperPass(llvm::ScopedNoAliasAAWrapperPass *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::ScopedNoAliasAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E813DD40;
  *((_QWORD *)this + 4) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82ECC8);
  if (v2 != -1)
  {
    v6[0] = sub_1C4F8269C;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82ECC8, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::ScopedNoAliasAAWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

void sub_1C61BCC64(llvm::ImmutablePass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813DD40;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C4093837F09);
  llvm::ImmutablePass::~ImmutablePass(this);
}

void sub_1C61BCCB0(llvm::ImmutablePass *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E813DD40;
  v2 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C4093837F09);
  llvm::ImmutablePass::~ImmutablePass(this);
  JUMPOUT(0x1CAA32FC0);
}

llvm::ScopedNoAliasAAWrapperPass *llvm::callDefaultCtor<llvm::ScopedNoAliasAAWrapperPass>()
{
  llvm::ScopedNoAliasAAWrapperPass *v0;

  v0 = (llvm::ScopedNoAliasAAWrapperPass *)operator new();
  return llvm::ScopedNoAliasAAWrapperPass::ScopedNoAliasAAWrapperPass(v0);
}

uint64_t sub_1C61BCD3C(uint64_t a1, char *a2, _BYTE **a3, _WORD *a4)
{
  uint64_t v8;
  size_t v9;
  _BYTE *v10;

  v8 = sub_1C47AD050(a1, 0, 0);
  *(_BYTE *)(v8 + 128) = 0;
  *(_QWORD *)(v8 + 136) = &off_1E7F9E8D8;
  *(_QWORD *)(v8 + 144) = 0;
  *(_QWORD *)v8 = &unk_1E819E898;
  *(_QWORD *)(v8 + 152) = &off_1E819E9A0;
  *(_QWORD *)(v8 + 160) = &off_1E7F9E8F8;
  *(_QWORD *)(v8 + 184) = v8 + 160;
  v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  v10 = *a3;
  *(_BYTE *)(a1 + 128) = **a3;
  *(_BYTE *)(a1 + 145) = 1;
  *(_BYTE *)(a1 + 144) = *v10;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

uint64_t llvm::isOnlyUsedInZeroEqualityComparison(llvm *this, const llvm::Instruction *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  int *v5;
  int v6;

  v2 = *((_QWORD *)this + 1);
  if (!v2)
    return 0;
  do
  {
    v3 = *(_QWORD *)(v2 + 24);
    v6 = 0;
    v5 = &v6;
    LODWORD(result) = sub_1C4FA47D4(&v5, v3);
    if ((v6 & 0xFFFFFFFE) == 0x20)
      result = result;
    else
      result = 0;
    if ((_DWORD)result != 1)
      break;
    v2 = *(_QWORD *)(v2 + 8);
  }
  while (v2);
  return result;
}

unint64_t llvm::isKnownNonNegative(llvm *this, const llvm::Value *a2, const llvm::DataLayout *a3, uint64_t a4, llvm::AssumptionCache *a5, const llvm::Instruction *a6, const llvm::DominatorTree *a7)
{
  _BOOL8 *v7;
  unint64_t v8;
  _BOOL8 v10;
  unsigned int v11;

  llvm::computeKnownBits(this, a2, a3, a5, a6, 0, a7, a4, &v10, v10);
  if (v11 >= 0x41)
    v7 = (_BOOL8 *)(v10 + 8 * ((v11 - 1) >> 6));
  else
    v7 = &v10;
  v8 = (unint64_t)*v7 >> (v11 - 1);
  sub_1C48C0CF0((uint64_t)&v10);
  return v8 & 1;
}

uint64_t llvm::GetStringLength(llvm *this, const llvm::Value *a2)
{
  uint64_t v2;
  uint64_t v3;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  int v8;
  _BYTE v9[256];

  if (*(_BYTE *)(*(_QWORD *)this + 8) != 15)
    return 0;
  v5 = v9;
  v6 = v9;
  v7 = 32;
  v8 = 0;
  v2 = sub_1C4F89050(this, (llvm::SmallPtrSetImplBase *)&v5, a2);
  if (v2 == -1)
    v3 = 1;
  else
    v3 = v2;
  if (v6 != v5)
    free(v6);
  return v3;
}

BOOL llvm::onlyUsedByLifetimeMarkers(llvm *this, const llvm::Value *a2)
{
  return sub_1C4F8A194((uint64_t)this, 0);
}

uint64_t llvm::computeOverflowForSignedAdd(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t *v6;

  v5 = a1[5];
  if ((v5 & 0x40000000) != 0)
    v6 = (uint64_t *)*((_QWORD *)a1 - 1);
  else
    v6 = (uint64_t *)&a1[-8 * (v5 & 0x7FFFFFF)];
  return sub_1C4F8C45C(*v6, v6[4], (llvm::APInt *)a1, a2, a3, a4, a5);
}

uint64_t llvm::isGuaranteedToTransferExecutionToSuccessor(llvm *this, const llvm::BasicBlock *a2)
{
  char *v2;
  _QWORD *v3;
  llvm *v4;
  uint64_t result;

  v2 = (char *)this + 40;
  v3 = (_QWORD *)*((_QWORD *)this + 6);
  if (v3 == (_QWORD *)((char *)this + 40))
    return 1;
  do
  {
    if (v3)
      v4 = (llvm *)(v3 - 3);
    else
      v4 = 0;
    result = llvm::isGuaranteedToTransferExecutionToSuccessor(v4, a2);
    if ((result & 1) == 0)
      break;
    v3 = (_QWORD *)v3[1];
  }
  while (v3 != (_QWORD *)v2);
  return result;
}

unint64_t llvm::isPointerOffset(llvm *this, const llvm::Value *a2, const llvm::Value *a3, const llvm::DataLayout *a4)
{
  unsigned int IndexTypeSizeInBits;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  unsigned __int8 v17;
  unint64_t v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  _QWORD *v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  char v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const void *v41;
  unsigned int v42;
  const void *v43;
  unsigned int v44;

  IndexTypeSizeInBits = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)a3, *(_QWORD *)this);
  sub_1C4832EA4((llvm::APInt *)&v43, IndexTypeSizeInBits, 0, 0);
  v8 = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)a3, *(_QWORD *)a2);
  sub_1C4832EA4((llvm::APInt *)&v41, v8, 0, 0);
  v10 = llvm::Value::stripAndAccumulateConstantOffsets((uint64_t)this, a3, &v43, 1, 0, 0, v9);
  v12 = llvm::Value::stripAndAccumulateConstantOffsets((uint64_t)a2, a3, &v41, 1, 0, 0, v11);
  if (v10 == v12)
  {
    if (v42 > 0x40)
      v15 = *(_QWORD *)v41;
    else
      v15 = (uint64_t)((_QWORD)v41 << -(uint64_t)v42) >> -(uint64_t)v42;
    if (v44 > 0x40)
      v21 = *(_QWORD *)v43;
    else
      v21 = (uint64_t)((_QWORD)v43 << -(uint64_t)v44) >> -(uint64_t)v44;
LABEL_22:
    v17 = v15 - v21;
    v18 = (v15 - v21) & 0xFFFFFFFFFFFFFF00;
    goto LABEL_29;
  }
  v13 = v12;
  v14 = *(unsigned __int8 *)(v10 + 16);
  if (v14 != 62)
  {
    if (v14 == 5)
    {
      if (*(_WORD *)(v10 + 18) != 34)
        v10 = 0;
    }
    else
    {
      v10 = 0;
    }
  }
  v16 = *(unsigned __int8 *)(v12 + 16);
  if (v16 != 62)
  {
    if (v16 != 5)
      goto LABEL_28;
    if (*(_WORD *)(v12 + 18) != 34)
      v13 = 0;
  }
  v17 = 0;
  if (!v10)
    goto LABEL_48;
  v18 = 0;
  if (v13)
  {
    v19 = *(_DWORD *)(v10 + 20);
    if ((v19 & 0x40000000) != 0)
      v20 = *(uint64_t **)(v10 - 8);
    else
      v20 = (uint64_t *)(v10 - 32 * (v19 & 0x7FFFFFF));
    v22 = *v20;
    v23 = *(_DWORD *)(v13 + 20);
    if ((v23 & 0x40000000) != 0)
      v24 = *(_QWORD **)(v13 - 8);
    else
      v24 = (_QWORD *)(v13 - 32 * (v23 & 0x7FFFFFF));
    if (v22 == *v24)
    {
      v26 = 24;
      if (*(_BYTE *)(v10 + 16) == 62)
        v27 = 64;
      else
        v27 = 24;
      v28 = *(_QWORD *)(v10 + v27);
      if (*(_BYTE *)(v13 + 16) == 62)
        v26 = 64;
      if (v28 == *(_QWORD *)(v13 + v26))
      {
        v29 = v19 & 0x7FFFFFF;
        if ((_DWORD)v29 == 1)
        {
          LODWORD(v30) = 1;
        }
        else
        {
          v30 = v23 & 0x7FFFFFF;
          v37 = 1;
          while ((_DWORD)v30 != v37)
          {
            v38 = v10 - 32 * v29;
            if ((v19 & 0x40000000) != 0)
              v38 = *(_QWORD *)(v10 - 8);
            v39 = v13 - 32 * v30;
            if ((v23 & 0x40000000) != 0)
              v39 = *(_QWORD *)(v13 - 8);
            if (*(_QWORD *)(v38 + 32 * v37) != *(_QWORD *)(v39 + 32 * v37))
            {
              LODWORD(v30) = v37;
              break;
            }
            if ((_DWORD)v29 == ++v37)
            {
              LODWORD(v30) = v19 & 0x7FFFFFF;
              break;
            }
          }
        }
        v31 = sub_1C4F9459C(v10, v30, a3);
        v33 = v32;
        v34 = sub_1C4F9459C(v13, v30, a3);
        v17 = 0;
        if (v33)
        {
          v18 = 0;
          if (!v35)
            goto LABEL_29;
          if (v42 > 0x40)
            v36 = *(_QWORD *)v41;
          else
            v36 = (uint64_t)((_QWORD)v41 << -(uint64_t)v42) >> -(uint64_t)v42;
          if (v44 > 0x40)
            v40 = *(_QWORD *)v43;
          else
            v40 = (uint64_t)((_QWORD)v43 << -(uint64_t)v44) >> -(uint64_t)v44;
          v15 = v34 + v36;
          v21 = v31 + v40;
          goto LABEL_22;
        }
LABEL_48:
        v18 = 0;
        goto LABEL_29;
      }
    }
LABEL_28:
    v17 = 0;
    v18 = 0;
  }
LABEL_29:
  if (v42 >= 0x41 && v41)
    MEMORY[0x1CAA32F9C](v41, 0x1000C8000313F17);
  if (v44 >= 0x41 && v43)
    MEMORY[0x1CAA32F9C](v43, 0x1000C8000313F17);
  return v18 | v17;
}

char *sub_1C61BD4C4(llvm::Type **a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, llvm::Instruction *a6)
{
  _DWORD *v12;
  llvm::Instruction *v13;

  v12 = operator new(0xA0uLL);
  v12[21] = v12[21] & 0x38000000 | 2;
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 1) = 0;
  *((_QWORD *)v12 + 2) = 0;
  *((_QWORD *)v12 + 3) = v12 + 16;
  *((_QWORD *)v12 + 4) = 0;
  *((_QWORD *)v12 + 5) = 0;
  *((_QWORD *)v12 + 6) = 0;
  *((_QWORD *)v12 + 7) = v12 + 16;
  v13 = llvm::Instruction::Instruction((llvm::Instruction *)(v12 + 16), *a1, 65, (llvm::Use *)v12, 2, a6);
  *((_QWORD *)v12 + 16) = v12 + 36;
  *((_QWORD *)v12 + 17) = 0x400000000;
  llvm::InsertValueInst::init((uint64_t)v13, (uint64_t)a1, a2, a3, a4, a5);
  return (char *)(v12 + 16);
}

void sub_1C61BD588(_WORD *a1, int **a2)
{
  uint64_t v4;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F47D0, 0, 0);
  dword_1ED7F4850 = 0;
  qword_1ED7F4858 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F4860 = 0;
  qword_1ED7F47D0 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F4868 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F4870 = (uint64_t)&off_1E7F95260;
  qword_1ED7F4888 = (uint64_t)&qword_1ED7F4870;
  llvm::cl::Option::setArgStr(v4, "dom-conditions-max-uses", 0x17uLL);
  word_1ED7F47DA = (32 * (*a1 & 3)) | word_1ED7F47DA & 0xFF9F;
  dword_1ED7F4850 = **a2;
  byte_1ED7F4864 = 1;
  dword_1ED7F4860 = dword_1ED7F4850;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F47D0);
}

uint64_t llvm::isTriviallyVectorizable(llvm *this)
{
  int v1;
  uint64_t result;
  unsigned int v3;

  v1 = (int)this;
  result = 1;
  if (v1 > 138)
  {
    if (((v1 - 139) > 0x36 || ((1 << (v1 + 117)) & 0x6000700000061BLL) == 0)
      && ((v1 - 201) > 0x3D || ((1 << (v1 + 55)) & 0x2E00006000000007) == 0))
    {
      v3 = v1 - 273;
      if (v3 > 0x26 || ((1 << v3) & 0x4F0880049FLL) == 0)
        return 0;
    }
  }
  else if ((v1 > 0x36 || ((1 << v1) & 0x78000000086302) == 0) && (v1 - 75) >= 2)
  {
    return 0;
  }
  return result;
}

uint64_t sub_1C61BD720(uint64_t **a1, uint64_t *a2)
{
  uint64_t **v3;
  uint64_t v4;

  v3 = sub_1C4F5394C(a1, (unint64_t)a2, a2);
  if (a1 + 1 == v3)
    v4 = 0;
  else
    v4 = sub_1C61BEB54((uint64_t)(v3 + 4));
  return v4 + 16;
}

uint64_t sub_1C61BD764(uint64_t **a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t **v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  v5 = sub_1C4F5394C(a1, (unint64_t)a2, a2);
  v6 = sub_1C4F5394C(a1, *a3, (uint64_t *)*a3);
  v7 = a1 + 1;
  if (v7 == v5)
    v8 = 0;
  else
    v8 = sub_1C61BEB54((uint64_t)(v5 + 4));
  if (v7 == v6)
    result = 0;
  else
    result = sub_1C61BEB54((uint64_t)(v6 + 4));
  if (v8 != result)
  {
    *(_QWORD *)(*(_QWORD *)v8 + 8) = *(_QWORD *)(*(_QWORD *)v8 + 8) & 1 | result;
    v10 = *(_QWORD *)(result + 8);
    *(_QWORD *)v8 = *(_QWORD *)result;
    *(_QWORD *)result = v8;
    *(_QWORD *)(result + 8) = v10 & 0xFFFFFFFFFFFFFFFELL;
  }
  return result;
}

uint64_t llvm::intersectAccessGroups(llvm *this, const llvm::Instruction *a2, const llvm::Instruction *a3)
{
  uint64_t MetadataImpl;
  uint64_t v6;
  uint64_t Impl;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  llvm::Instruction *v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t *v19;
  uint64_t v20;
  unsigned int v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  int v27;
  _BYTE v28[32];
  void *v29;
  uint64_t v30;
  _QWORD v31[5];

  v31[4] = *MEMORY[0x1E0C80C00];
  if ((llvm::Instruction::mayReadFromMemory(this) & 1) == 0)
  {
    v11 = llvm::Instruction::mayWriteToMemory(this);
    if ((llvm::Instruction::mayReadFromMemory(a2) & 1) != 0)
    {
      if ((v11 & 1) != 0)
        goto LABEL_3;
    }
    else
    {
      v14 = llvm::Instruction::mayWriteToMemory(a2);
      if ((v11 | v14) != 1)
        return 0;
      if ((v11 & 1) != 0)
        goto LABEL_19;
    }
    if (!*((_QWORD *)a2 + 6) && (*((_BYTE *)a2 + 23) & 0x20) == 0)
      return 0;
    v12 = a2;
    return llvm::Instruction::getMetadataImpl(v12, 25);
  }
  if ((llvm::Instruction::mayReadFromMemory(a2) & 1) == 0)
  {
    LOBYTE(v14) = llvm::Instruction::mayWriteToMemory(a2);
LABEL_19:
    if ((v14 & 1) != 0)
      goto LABEL_3;
    if (!*((_QWORD *)this + 6) && (*((_BYTE *)this + 23) & 0x20) == 0)
      return 0;
    v12 = this;
    return llvm::Instruction::getMetadataImpl(v12, 25);
  }
LABEL_3:
  if (*((_QWORD *)this + 6) || (*((_BYTE *)this + 23) & 0x20) != 0)
    MetadataImpl = llvm::Instruction::getMetadataImpl(this, 25);
  else
    MetadataImpl = 0;
  if (*((_QWORD *)a2 + 6) || (*((_BYTE *)a2 + 23) & 0x20) != 0)
  {
    v6 = llvm::Instruction::getMetadataImpl(a2, 25);
    Impl = 0;
    if (MetadataImpl)
    {
      v8 = v6;
      if (v6)
      {
        if (MetadataImpl == v6)
        {
          return MetadataImpl;
        }
        else
        {
          v24 = v28;
          v25 = v28;
          v26 = 4;
          v27 = 0;
          v9 = *(unsigned int *)(v6 + 8);
          if ((_DWORD)v9)
          {
            v10 = -8 * v9;
            do
            {
              sub_1C4774094((llvm::SmallPtrSetImplBase *)&v24, *(_QWORD *)(v8 + v10));
              v10 += 8;
            }
            while (v10);
          }
          else
          {
            sub_1C4774094((llvm::SmallPtrSetImplBase *)&v24, v6);
          }
          v29 = v31;
          v30 = 0x400000000;
          v15 = *(unsigned int *)(MetadataImpl + 8);
          if ((_DWORD)v15)
          {
            v16 = -8 * v15;
            do
            {
              v17 = *(_QWORD *)(MetadataImpl + v16);
              v18 = (char *)sub_1C477672C((uint64_t)&v24, v17);
              if (v25 == v24)
                v19 = (uint64_t *)((char *)&v26 + 4);
              else
                v19 = &v26;
              if (v18 != &v25[8 * *(unsigned int *)v19])
              {
                v20 = v30;
                if (v30 >= (unint64_t)HIDWORD(v30))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, (uint64_t)v31, v30 + 1, 8);
                  v20 = v30;
                }
                *((_QWORD *)v29 + v20) = v17;
                LODWORD(v30) = v30 + 1;
              }
              v16 += 8;
            }
            while (v16);
            v21 = v30;
          }
          else
          {
            v22 = (char *)sub_1C477672C((uint64_t)&v24, MetadataImpl);
            if (v25 == v24)
              v23 = (uint64_t *)((char *)&v26 + 4);
            else
              v23 = &v26;
            v21 = v30;
            if (v22 != &v25[8 * *(unsigned int *)v23])
            {
              if (v30 >= HIDWORD(v30))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, (uint64_t)v31, v30 + 1, 8);
                v21 = v30;
              }
              *((_QWORD *)v29 + v21) = MetadataImpl;
              v21 = v30 + 1;
              LODWORD(v30) = v30 + 1;
            }
          }
          if (v21)
          {
            if (v21 == 1)
              Impl = *(_QWORD *)v29;
            else
              Impl = llvm::MDTuple::getImpl(**(uint64_t ***)this, v29, v21, 0, 1);
          }
          else
          {
            Impl = 0;
          }
          if (v29 != v31)
            free(v29);
          if (v25 != v24)
            free(v25);
        }
      }
    }
    return Impl;
  }
  return 0;
}

llvm::UndefValue *llvm::createBitMaskForGaps(uint64_t a1, int a2, unsigned int *a3)
{
  unsigned int v3;
  llvm::UndefValue *v4;
  unsigned int v9;
  int v10;
  uint64_t *v11;
  unsigned int v12;
  _BOOL8 v13;
  llvm::LLVMContext *v14;
  llvm::ConstantInt **Int1Ty;
  llvm::ValueHandleBase *v16;
  uint64_t v17;
  llvm::FixedVectorType ***v18;
  unsigned int v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[17];

  v22[16] = *MEMORY[0x1E0C80C00];
  v3 = *a3;
  if (a3[4] == *a3)
    return 0;
  v20 = v22;
  v21 = 0x1000000000;
  if (a2)
  {
    v9 = 0;
    v10 = 0;
    v11 = (uint64_t *)(a3 + 2);
    do
    {
      if (v3)
      {
        v12 = 0;
        do
        {
          v19 = v12 + a3[8];
          v13 = sub_1C4FA9B60(v11, &v19) != 0;
          Int1Ty = (llvm::ConstantInt **)llvm::Type::getInt1Ty(*(llvm::Type **)(a1 + 64), v14);
          v16 = llvm::ConstantInt::get(Int1Ty, v13, 0);
          v17 = v21;
          if (v21 >= (unint64_t)HIDWORD(v21))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, (uint64_t)v22, v21 + 1, 8);
            v17 = v21;
          }
          *((_QWORD *)v20 + v17) = v16;
          v9 = v21 + 1;
          LODWORD(v21) = v21 + 1;
          ++v12;
          v3 = *a3;
        }
        while (v12 < *a3);
      }
      ++v10;
    }
    while (v10 != a2);
    v18 = (llvm::FixedVectorType ***)v20;
  }
  else
  {
    v9 = 0;
    v18 = (llvm::FixedVectorType ***)v22;
  }
  v4 = llvm::ConstantVector::get(v18, (llvm::Type *)v9);
  if (v20 != v22)
    free(v20);
  return v4;
}

void *llvm::createReplicatedMask@<X0>(void *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  int v6;
  unsigned int v7;
  int i;
  int j;

  v4 = a3 + 16;
  *(_QWORD *)a3 = a3 + 16;
  *(_QWORD *)(a3 + 8) = 0x1000000000;
  if (a2)
  {
    v6 = (int)this;
    v7 = 0;
    for (i = 0; i != a2; ++i)
    {
      for (j = v6; j; --j)
      {
        if (v7 >= *(_DWORD *)(a3 + 12))
        {
          this = llvm::SmallVectorBase<unsigned int>::grow_pod(a3, v4, v7 + 1, 4);
          v7 = *(_DWORD *)(a3 + 8);
        }
        *(_DWORD *)(*(_QWORD *)a3 + 4 * v7) = i;
        v7 = *(_DWORD *)(a3 + 8) + 1;
        *(_DWORD *)(a3 + 8) = v7;
      }
    }
  }
  return this;
}

void *llvm::createInterleaveMask@<X0>(void *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  int v6;
  unsigned int v7;
  int i;
  int v9;
  int j;

  v4 = a3 + 16;
  *(_QWORD *)a3 = a3 + 16;
  *(_QWORD *)(a3 + 8) = 0x1000000000;
  if ((_DWORD)this)
  {
    v6 = (int)this;
    v7 = 0;
    for (i = 0; i != v6; ++i)
    {
      v9 = i;
      for (j = a2; j; --j)
      {
        if (v7 >= *(_DWORD *)(a3 + 12))
        {
          this = llvm::SmallVectorBase<unsigned int>::grow_pod(a3, v4, v7 + 1, 4);
          v7 = *(_DWORD *)(a3 + 8);
        }
        *(_DWORD *)(*(_QWORD *)a3 + 4 * v7) = v9;
        v7 = *(_DWORD *)(a3 + 8) + 1;
        *(_DWORD *)(a3 + 8) = v7;
        v9 += v6;
      }
    }
  }
  return this;
}

void *llvm::createStrideMask@<X0>(void *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  int v6;
  int v8;
  unsigned int v9;

  v5 = a4 + 16;
  *(_QWORD *)a4 = a4 + 16;
  *(_QWORD *)(a4 + 8) = 0x1000000000;
  if (a3)
  {
    v6 = a3;
    v8 = (int)this;
    v9 = 0;
    do
    {
      if (v9 >= *(_DWORD *)(a4 + 12))
      {
        this = llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v5, v9 + 1, 4);
        v9 = *(_DWORD *)(a4 + 8);
      }
      *(_DWORD *)(*(_QWORD *)a4 + 4 * v9) = v8;
      v9 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v9;
      v8 += a2;
      --v6;
    }
    while (v6);
  }
  return this;
}

void *llvm::createSequentialMask@<X0>(void *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;

  v6 = a4 + 16;
  *(_QWORD *)a4 = a4 + 16;
  *(_QWORD *)(a4 + 8) = 0x1000000000;
  if (a2)
  {
    v7 = a2;
    v8 = (int)this;
    v9 = 0;
    do
    {
      if (v9 >= *(_DWORD *)(a4 + 12))
      {
        this = llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v6, v9 + 1, 4);
        v9 = *(_DWORD *)(a4 + 8);
      }
      *(_DWORD *)(*(_QWORD *)a4 + 4 * v9) = v8;
      v9 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v9;
      ++v8;
      --v7;
    }
    while (v7);
  }
  else
  {
    v9 = 0;
  }
  for (; a3; --a3)
  {
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      this = llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v6, v9 + 1, 4);
      v9 = *(_DWORD *)(a4 + 8);
    }
    *(_DWORD *)(*(_QWORD *)a4 + 4 * v9) = -1;
    v9 = *(_DWORD *)(a4 + 8) + 1;
    *(_DWORD *)(a4 + 8) = v9;
  }
  return this;
}

uint64_t llvm::concatenateVectors(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  llvm::PoisonValue **v7;
  uint64_t v8;
  llvm::PoisonValue *v9;
  unsigned int v10;
  unsigned int v11;
  void *v12;
  uint64_t v13;
  llvm::Type *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v23[32];
  __int16 v24;
  void *v25;
  uint64_t v26;
  _BYTE v27[64];
  void *v28;
  uint64_t v29;
  _BYTE v30[64];
  _QWORD *v31;
  unsigned int v32;
  _QWORD v33[10];

  v3 = a3;
  v33[8] = *MEMORY[0x1E0C80C00];
  v28 = v30;
  v29 = 0x800000000;
  sub_1C4FA6FB8((unsigned int *)&v28, a2, &a2[8 * a3]);
  do
  {
    v25 = v27;
    v26 = 0x800000000;
    v4 = v3 - 1;
    if (v3 == 1)
    {
      LODWORD(v18) = 0;
      v19 = *((_QWORD *)v28 + v4);
LABEL_20:
      *((_QWORD *)v25 + v18) = v19;
      LODWORD(v26) = v26 + 1;
      goto LABEL_21;
    }
    v5 = 0;
    do
    {
      v6 = *((_QWORD *)v28 + v5);
      v7 = (llvm::PoisonValue **)*((_QWORD *)v28 + v5 + 1);
      v8 = *(_QWORD *)v6;
      if ((*(_DWORD *)(*(_QWORD *)v6 + 8) & 0xFE) != 0x12)
        v8 = 0;
      v9 = *v7;
      if ((*((_DWORD *)*v7 + 2) & 0xFE) != 0x12)
        v9 = 0;
      v10 = *(_DWORD *)(v8 + 32);
      v11 = *((_DWORD *)v9 + 8);
      if (v10 > v11)
      {
        llvm::createSequentialMask(0, *((_DWORD *)v9 + 8), v10 - v11, (uint64_t)&v31);
        v12 = v31;
        v13 = v32;
        v24 = 257;
        v15 = llvm::PoisonValue::get(*v7, v14);
        v7 = (llvm::PoisonValue **)sub_1C486AD20(a1, (uint64_t)v7, (uint64_t)v15, v12, v13, (uint64_t)v23);
        if (v31 != v33)
          free(v31);
      }
      llvm::createSequentialMask(0, v11 + v10, 0, (uint64_t)&v31);
      v24 = 257;
      v16 = sub_1C486AD20(a1, v6, (uint64_t)v7, v31, v32, (uint64_t)v23);
      if (v31 != v33)
        free(v31);
      v17 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, (uint64_t)v27, v26 + 1, 8);
        v17 = v26;
      }
      *((_QWORD *)v25 + v17) = v16;
      v18 = (v26 + 1);
      LODWORD(v26) = v26 + 1;
      v5 += 2;
    }
    while (v5 < v4);
    if ((v3 & 1) != 0)
    {
      v19 = *((_QWORD *)v28 + v4);
      if (v18 >= HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, (uint64_t)v27, v18 + 1, 8);
        LODWORD(v18) = v26;
      }
      goto LABEL_20;
    }
LABEL_21:
    sub_1C49EEBE4((uint64_t)&v28, (uint64_t)&v25);
    v3 = v29;
    if (v25 != v27)
      free(v25);
  }
  while (v3 > 1);
  v20 = *(_QWORD *)v28;
  if (v28 != v30)
    free(v28);
  return v20;
}

uint64_t sub_1C61BE2B0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  __int128 v6;
  char *v7;
  unsigned int v8;
  uint64_t v9;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  int v17;

  v16 = *a2;
  v17 = 0;
  sub_1C6176E38((_DWORD *)a1, &v16, &v17, (uint64_t)&v14);
  v4 = v14;
  if (v15)
  {
    HIDWORD(v13) = 0;
    *(_DWORD *)((char *)&v13 + 1) = 0;
    v11 = (unint64_t)*a2;
    v12 = 0uLL;
    LOBYTE(v13) = 0;
    v5 = *(_QWORD *)(a1 + 32);
    if (v5 >= *(_QWORD *)(a1 + 40))
    {
      v7 = sub_1C4EFB72C((void **)(a1 + 24), (uint64_t)&v11);
    }
    else
    {
      v6 = v12;
      *(_OWORD *)v5 = v11;
      *(_OWORD *)(v5 + 16) = v6;
      *(_QWORD *)(v5 + 32) = v13;
      v7 = (char *)(v5 + 40);
    }
    *(_QWORD *)(a1 + 32) = v7;
    v9 = *(_QWORD *)(a1 + 24);
    v8 = -858993459 * ((unint64_t)&v7[-v9] >> 3) - 1;
    *(_DWORD *)(v4 + 8) = v8;
  }
  else
  {
    v8 = *(_DWORD *)(v14 + 8);
    v9 = *(_QWORD *)(a1 + 24);
  }
  return v9 + 40 * v8 + 8;
}

_QWORD *sub_1C61BE390(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  unsigned int *v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v1 = result[4];
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 16);
    if (*(_BYTE *)(v2 + 216))
    {
      v3 = *(unsigned int *)(v2 + 232);
      if ((_DWORD)v3)
      {
        v4 = result;
        v5 = *(unsigned int **)(v2 + 224);
        v6 = &v5[4 * v3];
        v7 = (uint64_t)(result + 17);
        do
        {
          v8 = *v5;
          v9 = v5[1];
          v5 += 4;
          v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4[4] + 16) + 40) + 8 * v8);
          v10 = sub_1C61BE588(v7, &v11);
          result = sub_1C4774094((llvm::SmallPtrSetImplBase *)(v10 + 1), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4[4] + 16) + 40) + 8 * v9));
        }
        while (v5 != v6);
      }
    }
  }
  return result;
}

uint64_t sub_1C61BE430(uint64_t a1, uint64_t a2, int a3, char a4)
{
  uint64_t v8;
  int v9;
  _QWORD *v10;
  uint64_t v12;
  int v13;

  v12 = a2;
  v8 = operator new();
  *(_BYTE *)(v8 + 5) = a4;
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 16) = 0;
  *(_DWORD *)(v8 + 24) = 0;
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 40) = a2;
  if (a3 >= 0)
    v9 = a3;
  else
    v9 = -a3;
  *(_DWORD *)v8 = v9;
  *(_BYTE *)(v8 + 4) = a3 < 0;
  v13 = 0;
  *((_QWORD *)sub_1C4FA978C(v8 + 8, &v13) + 1) = a2;
  sub_1C6180A54(a1 + 48, &v12)[1] = v8;
  v10 = sub_1C6180A54(a1 + 48, &v12);
  sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 72), v10[1]);
  return sub_1C6180A54(a1 + 48, &v12)[1];
}

_QWORD *sub_1C61BE50C(uint64_t a1, uint64_t *a2)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  result = (_QWORD *)sub_1C4FAA374((_DWORD *)a1, *a2);
  if ((_DWORD)result)
  {
    result = *(_QWORD **)(a1 + 40);
    v5 = *(unsigned int *)(a1 + 48);
    v6 = &result[v5];
    if ((_DWORD)v5)
    {
      v7 = 8 * v5;
      while (*result != *a2)
      {
        ++result;
        v7 -= 8;
        if (!v7)
        {
          result = v6;
          break;
        }
      }
    }
    if (v6 != result + 1)
    {
      result = memmove(result, result + 1, (char *)v6 - (char *)(result + 1));
      LODWORD(v5) = *(_DWORD *)(a1 + 48);
    }
    *(_DWORD *)(a1 + 48) = v5 - 1;
  }
  return result;
}

_QWORD *sub_1C61BE588(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61BE608(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 5;
    v5[2] = v5 + 5;
    v5[3] = 2;
    *((_DWORD *)v5 + 8) = 0;
  }
  return v5;
}

_QWORD *sub_1C61BE608(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4FA96C8(a1, v6);
  v8 = 0;
  sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61BE6B8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  void *v11;
  void *v12;
  uint64_t *v13;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 56 * v6;
    do
    {
      *v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v13 = 0;
      sub_1C61A45F4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      v10 = v13;
      v11 = v13 + 5;
      *v13 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v11, 2, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      v12 = (void *)a2[2];
      if (v12 != (void *)a2[1])
        free(v12);
    }
    a2 += 7;
  }
}

double sub_1C61BE788(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  double result;
  uint64_t v6;

  v6 = 0;
  if (sub_1C61A45F4(a2, a3, a4, &v6))
  {
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)a1, (const void **)(a1 + 32), (const llvm::SmallPtrSetImplBase *)(v6 + 8));
  }
  else
  {
    *(_QWORD *)a1 = a1 + 32;
    *(_QWORD *)(a1 + 8) = a1 + 32;
    *(_QWORD *)&result = 2;
    *(_QWORD *)(a1 + 16) = 2;
    *(_DWORD *)(a1 + 24) = 0;
  }
  return result;
}

char **sub_1C61BE804(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = v3 << 6;
    do
    {
      v5 = *(char **)&v2[v4 - 64];
      if (&v2[v4 - 48] != v5)
        free(v5);
      v4 -= 64;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

void sub_1C61BE874(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v6 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 80, &v14);
  v7 = v6;
  v8 = a2;
  do
  {
    *v6 = v6 + 2;
    v6[1] = 0x100000000;
    if (*(_DWORD *)(a3 + 8))
      v6 = (_QWORD *)sub_1C4FA9D50((uint64_t)v6, a3);
    v6 += 10;
    --v8;
  }
  while (v8);
  v9 = *(char **)a1;
  v10 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v10)
  {
    v11 = 80 * v10;
    v12 = v9 - 80;
    do
    {
      sub_1C61BE804((char **)&v12[v11]);
      v11 -= 80;
    }
    while (v11);
    v9 = *(char **)a1;
  }
  v13 = v14;
  if (v9 != (char *)(a1 + 16))
    free(v9);
  *(_QWORD *)a1 = v7;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v13;
}

void sub_1C61BE948(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 64, &v5);
  sub_1C61BE9B4(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61BE9B4(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v5 = *(_QWORD *)a1;
    v6 = v2 << 6;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0xC00000000;
      if (*(_DWORD *)(v5 + 8))
        sub_1C614C900((uint64_t)a2, v5);
      v5 += 64;
      a2 += 8;
      v6 -= 64;
    }
    while (v6);
    v7 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v7)
    {
      v8 = *(_QWORD *)a1;
      v9 = v7 << 6;
      do
      {
        v10 = *(void **)(v8 + v9 - 64);
        if ((void *)(v8 + v9 - 48) != v10)
          free(v10);
        v9 -= 64;
      }
      while (v9);
    }
  }
}

void sub_1C61BEA64(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v6 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 64, &v14);
  v7 = v6;
  v8 = a2;
  do
  {
    *v7 = v7 + 2;
    v7[1] = 0xC00000000;
    if (*(_DWORD *)(a3 + 8))
      sub_1C614CA14((uint64_t)v7, a3);
    v7 += 8;
    --v8;
  }
  while (v8);
  v9 = *(char **)a1;
  v10 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v10)
  {
    v11 = v10 << 6;
    do
    {
      v12 = *(char **)&v9[v11 - 64];
      if (&v9[v11 - 48] != v12)
        free(v12);
      v11 -= 64;
    }
    while (v11);
    v9 = *(char **)a1;
  }
  v13 = v14;
  if (v9 != (char *)(a1 + 16))
    free(v9);
  *(_QWORD *)a1 = v6;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t sub_1C61BEB54(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1;
  if ((*(_BYTE *)(a1 + 8) & 1) == 0)
  {
    v2 = *(_QWORD *)a1;
    if ((*(_BYTE *)(*(_QWORD *)v1 + 8) & 1) == 0)
    {
      v2 = sub_1C61BEB54();
      *(_QWORD *)v1 = v2;
    }
    return v2;
  }
  return v1;
}

_QWORD *sub_1C61BEB98(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61252B8(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61BEBF8((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61BEBF8(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4FA9EF4(a1, v7);
  v9 = 0;
  sub_1C61252B8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C61BECA4(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C61252B8((uint64_t *)v5, a2, &v11);
      v9 = v11;
      v10 = a2[1];
      *v11 = *a2;
      v9[1] = v10;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

uint64_t llvm::LLLexer::Error(uint64_t a1, char *a2, llvm::Twine *a3)
{
  _BYTE v5[304];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  llvm::SourceMgr::GetMessage(*(uint64_t **)(a1 + 32), a2, 0, a3, 0, 0, 0, 0, (uint64_t)v5);
  sub_1C4FAB674(*(_QWORD *)(a1 + 24), (uint64_t)v5);
  sub_1C4FAD098((uint64_t)v5);
  return 1;
}

unint64_t llvm::LLLexer::HexIntToVal(llvm::LLLexer *this, const char *a2, const char *a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  if (a2 == a3)
    return 0;
  v10 = v3;
  v11 = v4;
  v5 = 0;
  while (1)
  {
    v6 = 16 * v5 + word_1C85F7092[*(unsigned __int8 *)a2];
    if (v6 < v5)
      break;
    ++a2;
    v5 = v6;
    if (a2 == a3)
      return v6;
  }
  v8 = "constant bigger than 64 bits detected!";
  v9 = 259;
  sub_1C4FAB818((uint64_t)this, (llvm::Twine *)&v8);
  return 0;
}

void llvm::LLLexer::HexToIntPair(llvm::LLLexer *this, const char *a2, const char *a3, unint64_t *a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  __int16 v12;

  *a4 = 0;
  if (a3 - a2 >= 16)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = 16 * v5;
      *a4 = v6;
      v5 = v6 + word_1C85F7092[a2[v4]];
      *a4 = v5;
      ++v4;
    }
    while ((_DWORD)v4 != 16);
    a2 += v4;
  }
  a4[1] = 0;
  if (a2 != a3)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = 16 * v8;
      a4[1] = v9;
      v10 = &a2[v7 + 1];
      v8 = v9 + word_1C85F7092[a2[v7]];
      a4[1] = v8;
      if (v7 > 0xE)
        break;
      ++v7;
    }
    while (v10 != a3);
    if (v10 != a3)
    {
      v11 = "constant bigger than 128 bits detected!";
      v12 = 259;
      sub_1C4FAB818((uint64_t)this, (llvm::Twine *)&v11);
    }
  }
}

void llvm::LLLexer::FP80HexToIntPair(llvm::LLLexer *this, const char *a2, const char *a3, unint64_t *a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  const char *v12;
  const char *v13;
  __int16 v14;

  a4[1] = 0;
  if (a2 != a3)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = 16 * v5;
      a4[1] = v6;
      v7 = &a2[v4 + 1];
      v5 = v6 + word_1C85F7092[a2[v4]];
      a4[1] = v5;
      v8 = v4 + 1;
      if (v4 > 2)
        break;
      ++v4;
    }
    while (v7 != a3);
    a2 += v8;
  }
  *a4 = 0;
  if (a2 != a3)
  {
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = 16 * v10;
      *a4 = v11;
      v12 = &a2[v9 + 1];
      v10 = v11 + word_1C85F7092[a2[v9]];
      *a4 = v10;
      if (v9 > 0xE)
        break;
      ++v9;
    }
    while (v12 != a3);
    if (v12 != a3)
    {
      v13 = "constant bigger than 128 bits detected!";
      v14 = 259;
      sub_1C4FAB818((uint64_t)this, (llvm::Twine *)&v13);
    }
  }
}

uint64_t llvm::LLLexer::LexIdentifier(llvm::LLLexer *this)
{
  std::string::value_type *v2;
  char *v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *i;
  int v8;
  int v9;
  std::string::value_type *v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t VoidTy;
  std::string::value_type *v19;
  unint64_t v20;
  int v21;
  _BOOL4 v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  _BOOL4 v38;
  _BOOL4 v39;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v63;
  char v71;
  int v93;
  int v94;
  int v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v217;
  char v288;
  BOOL v295;
  int v299;
  BOOL v361;
  BOOL v362;
  BOOL v363;
  BOOL v364;
  BOOL v365;
  BOOL v366;
  BOOL v367;
  unsigned __int8 *v368;
  int v369;
  char *v370;
  int v371;
  uint64_t v372;
  char *v373;
  unsigned int v374;
  unsigned int v375;
  int v376;
  BOOL v399;
  BOOL v403;
  BOOL v416;
  unsigned int v424;
  const char *v425;
  BOOL v426;
  uint64_t v427;
  unsigned int v428;
  char hasSetOpaquePointersValue;
  llvm::LLVMContextImpl **v432;
  BOOL v434;
  BOOL v435;
  int v437;
  int v438;
  int v439;
  int v440;
  int v441;
  int v442;
  const char *v443;
  unsigned int v444;
  const char *v445;
  unsigned int v446;
  const char *v447;
  unsigned int v448;
  __int16 v449;

  v2 = 0;
  v3 = *(char **)this;
  v4 = *(_QWORD *)this - 1;
  if (*(_BYTE *)v4 == 105)
    v5 = 0;
  else
    v5 = *(char **)this;
  v6 = MEMORY[0x1E0C80978];
  for (i = *(char **)this; ; *(_QWORD *)this = i)
  {
    v8 = *i;
    v9 = v8;
    if (!(v8 < 0 ? __maskrune(v8, 0x500uLL) : *(_DWORD *)(v6 + 4 * v8 + 60) & 0x500)
      && ((v9 - 36) > 0x3B || ((1 << (v9 - 36)) & 0x800000000000601) == 0))
    {
      break;
    }
    v12 = *(std::string::value_type **)this;
    if (!v5)
    {
      if ((*(_DWORD *)(v6 + 4 * *v12 + 60) & 0x400) != 0)
        v5 = 0;
      else
        v5 = *(char **)this;
    }
    if (!v2)
    {
      v13 = *v12;
      if (*v12 < 0)
      {
        v14 = __maskrune(v13, 0x500uLL);
        v12 = *(std::string::value_type **)this;
      }
      else
      {
        v14 = *(_DWORD *)(v6 + 4 * v13 + 60) & 0x500;
      }
      if (v14)
      {
        v2 = 0;
      }
      else if (*v12 == 95)
      {
        v2 = 0;
      }
      else
      {
        v2 = v12;
      }
    }
    i = v12 + 1;
  }
  if (!*((_BYTE *)this + 152))
  {
    v19 = *(std::string::value_type **)this;
    if (**(_BYTE **)this == 58)
    {
      *(_QWORD *)this = v19 + 1;
      sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v19, (std::string::size_type)&v19[-v4]);
      return 437;
    }
  }
  if (!v5)
    v5 = *(char **)this;
  if (v5 != v3)
  {
    v15 = 0;
    *(_QWORD *)this = v5;
    do
    {
      v16 = v15;
      v15 = *v3 + 10 * v15 - 48;
      if (v15 < v16)
      {
        v447 = "constant bigger than 64 bits detected!";
        v449 = 259;
        sub_1C4FAB818((uint64_t)this, (llvm::Twine *)&v447);
        goto LABEL_75;
      }
      ++v3;
    }
    while (v3 != v5);
    if (v15 - 8388609 > 0xFFFFFFFFFF7FFFFFLL)
    {
      VoidTy = (uint64_t)llvm::IntegerType::get(*((llvm::IntegerType **)this + 5), (llvm::LLVMContext *)v15);
      goto LABEL_36;
    }
LABEL_75:
    v447 = "bitwidth for integer type out of range!";
    v449 = 259;
    sub_1C4FAB818((uint64_t)this, (llvm::Twine *)&v447);
    return 1;
  }
  if (!v2)
    v2 = *(std::string::value_type **)this;
  *(_QWORD *)this = v2;
  v20 = (unint64_t)&v2[-v4];
  if (&v2[-v4] == (std::string::value_type *)4)
  {
    switch(*(_DWORD *)v4)
    {
      case 0x65757274:
        return 19;
      case 0x6B616577:
        return 31;
      case 0x6C6C756E:
        return 53;
      case 0x656E6F6E:
        return 54;
      case 0x6D6F7266:
        return 58;
      case 0x6C696174:
        return 59;
      case 0x6E616E6E:
        return 77;
      case 0x666E696E:
        return 78;
      case 0x70637261:
        return 80;
      case 0x74736166:
        return 84;
      case 0x646C6F63:
        return 173;
      case 0x7473656E:
        return 186;
      case 0x74657273:
        return 224;
      case 0x636E7973:
        return 240;
    }
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    goto LABEL_57;
  }
  v23 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v28 = 0;
  v52 = 0;
  v53 = 0;
  switch(v20)
  {
    case 1uLL:
      goto LABEL_78;
    case 2uLL:
      if (*(_WORD *)v4 == 28532)
        return 55;
      if (*(_WORD *)v4 == 25447)
        return 101;
      if (*(_WORD *)v4 != 25443)
      {
        v23 = 0;
        v47 = 0;
        v46 = 0;
        v44 = 0;
        v51 = 0;
        LODWORD(v28) = 0;
        v52 = 0;
        v53 = 0;
        v45 = 0;
        v50 = 1;
        goto LABEL_1212;
      }
      return 105;
    case 3uLL:
      if (*(_WORD *)v4 == 29550 && *(_BYTE *)(v4 + 2) == 122)
        return 79;
      if (*(_WORD *)v4 == 26209 && *(_BYTE *)(v4 + 2) == 110)
        return 83;
      if (*(_WORD *)v4 == 30062 && *(_BYTE *)(v4 + 2) == 119)
        return 85;
      if (*(_WORD *)v4 == 29550 && *(_BYTE *)(v4 + 2) == 119)
        return 86;
      if (*(_WORD *)v4 == 29537 && *(_BYTE *)(v4 + 2) == 109)
        return 97;
      if (*(_WORD *)v4 == 25443 && *(_BYTE *)(v4 + 2) == 99)
        return 106;
      if (*(_WORD *)v4 == 29555 && *(_BYTE *)(v4 + 2) == 112)
        return 219;
      if (*(_WORD *)v4 != 28257 || *(_BYTE *)(v4 + 2) != 121)
      {
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v31 = 0;
        v32 = 0;
        v33 = 0;
        v34 = 0;
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = 0;
        v39 = 0;
        v43 = 1;
        goto LABEL_393;
      }
      return 245;
    case 4uLL:
    case 0x11uLL:
    case 0x13uLL:
    case 0x15uLL:
      goto LABEL_1212;
    case 5uLL:
      if (*(_DWORD *)v4 == 1936482662 && *(_BYTE *)(v4 + 4) == 101)
        return 20;
      if (*(_DWORD *)v4 == 1701080693 && *(_BYTE *)(v4 + 4) == 102)
        return 51;
      if (*(_DWORD *)v4 == 1667332197 && *(_BYTE *)(v4 + 4) == 116)
        return 87;
      if (*(_DWORD *)v4 == 1734962273 && *(_BYTE *)(v4 + 4) == 110)
        return 90;
      if (*(_DWORD *)v4 == 1634298977 && *(_BYTE *)(v4 + 4) == 115)
        return 94;
      if (*(_DWORD *)v4 == 1853187689 && *(_BYTE *)(v4 + 4) == 99)
        return 95;
      if (*(_DWORD *)v4 != 1667459175 || *(_BYTE *)(v4 + 4) != 99)
      {
        v44 = 0;
        v45 = 0;
        v47 = 0;
        v48 = 0;
        v49 = 0;
        v23 = 1;
        goto LABEL_1423;
      }
      return 146;
    case 6uLL:
      if (*(_DWORD *)v4 == 1768318308 && *(_WORD *)(v4 + 4) == 25966)
        return 22;
      if (*(_DWORD *)v4 == 1651469415 && *(_WORD *)(v4 + 4) == 27745)
        return 23;
      if (*(_DWORD *)v4 == 1835888483 && *(_WORD *)(v4 + 4) == 28271)
        return 36;
      if (*(_DWORD *)v4 == 1684302184 && *(_WORD *)(v4 + 4) == 28261)
        return 39;
      if (*(_DWORD *)v4 == 1936289648 && *(_WORD *)(v4 + 4) == 28271)
        return 52;
      if (*(_DWORD *)v4 == 1819042147 && *(_WORD *)(v4 + 4) == 29285)
        return 56;
      if (*(_DWORD *)v4 == 1752459639 && *(_WORD *)(v4 + 4) == 28265)
        return 57;
      if (*(_DWORD *)v4 == 1635020654 && *(_WORD *)(v4 + 4) == 27753)
        return 61;
      if (*(_DWORD *)v4 == 1735549300 && *(_WORD *)(v4 + 4) == 29797)
        return 62;
      if (*(_DWORD *)v4 == 1885958772 && *(_WORD *)(v4 + 4) == 25964)
        return 63;
      if (*(_DWORD *)v4 == 1769434741 && *(_WORD *)(v4 + 4) == 25710)
        return 65;
      if (*(_DWORD *)v4 == 1836020833 && *(_WORD *)(v4 + 4) == 25449)
        return 69;
      if (*(_DWORD *)v4 == 1969516397 && *(_WORD *)(v4 + 4) == 25964)
        return 96;
      if (*(_DWORD *)v4 == 1717924464 && *(_WORD *)(v4 + 4) == 30825)
        return 102;
      if (*(_DWORD *)v4 == 1953718630 && *(_WORD *)(v4 + 4) == 25443)
        return 107;
      if (*(_DWORD *)v4 == 1684828003 && *(_WORD *)(v4 + 4) == 25443)
        return 108;
      if (*(_DWORD *)v4 == 1836476520 && *(_WORD *)(v4 + 4) == 25443)
        return 148;
      if (*(_DWORD *)v4 == 1818845556 && *(_WORD *)(v4 + 4) == 25443)
        return 160;
      if (*(_DWORD *)v4 == 1919315822 && *(_WORD *)(v4 + 4) == 25957)
        return 193;
      if (*(_DWORD *)v4 == 2037608302 && *(_WORD *)(v4 + 4) == 25454)
        return 203;
      if (*(_DWORD *)v4 != 1919972211 || *(_WORD *)(v4 + 4) != 29029)
      {
        v38 = 0;
        v37 = 0;
        v36 = 0;
        v46 = 0;
        v34 = 0;
        v33 = 0;
        v93 = 0;
        v30 = 0;
        v27 = 0;
        v26 = 0;
        v94 = 0;
        v24 = 0;
        v23 = 0;
        v22 = 0;
        v21 = 0;
        v31 = 1;
        goto LABEL_1373;
      }
      return 220;
    case 7uLL:
      if (*(_DWORD *)v4 == 1818453348 && *(_DWORD *)(v4 + 3) == 1701994860)
        return 21;
      if (*(_DWORD *)v4 == 1986622064 && *(_DWORD *)(v4 + 3) == 1702125942)
        return 27;
      if (*(_DWORD *)v4 == 1634100580 && *(_DWORD *)(v4 + 3) == 1953264993)
        return 38;
      if (*(_DWORD *)v4 == 1970365281 && *(_DWORD *)(v4 + 3) == 1701996917)
        return 72;
      if (*(_DWORD *)v4 == 1701602674 && *(_DWORD *)(v4 + 3) == 1702060389)
        return 73;
      if (*(_DWORD *)v4 == 1601266529 && *(_DWORD *)(v4 + 3) == 1818587743)
        return 74;
      if (*(_DWORD *)v4 == 1601267059 && *(_DWORD *)(v4 + 3) == 1953719135)
        return 75;
      if (*(_DWORD *)v4 == 1935762802 && *(_DWORD *)(v4 + 3) == 1668248435)
        return 82;
      if (*(_DWORD *)v4 == 1634889321 && *(_DWORD *)(v4 + 3) == 1701277281)
        return 89;
      if (*(_DWORD *)v4 == 1952671091 && *(_DWORD *)(v4 + 3) == 1852795252)
        return 92;
      if (*(_DWORD *)v4 == 913205623 && *(_DWORD *)(v4 + 3) == 1667445814)
        return 139;
      if (*(_DWORD *)v4 == 1718187891 && *(_DWORD *)(v4 + 3) == 1667462246)
        return 142;
      if (*(_DWORD *)v4 != 1818850658 || *(_DWORD *)(v4 + 3) != 1852404844)
      {
        v48 = 0;
        v47 = 0;
        v46 = 0;
        v44 = 0;
        LODWORD(v28) = 0;
        v49 = 0;
        v53 = 0;
        v45 = 0;
        v51 = 1;
        goto LABEL_1200;
      }
      return 170;
    case 8uLL:
      switch(*(_QWORD *)v4)
      {
        case 0x746E6174736E6F63:
          return 24;
        case 0x6C616E7265746E69:
          return 28;
        case 0x65636E6F6B6E696CLL:
          return 29;
        case 0x72646F5F6B616577:
          return 32;
        case 0x6C616E7265747865:
          return 45;
        case 0x6C6961747473756DLL:
          return 60;
        case 0x656C6974616C6F76:
          return 68;
        case 0x74636172746E6F63:
          return 81;
        case 0x73646E756F626E69:
          return 88;
        case 0x6575676F6C6F7270:
          return 103;
        case 0x636369745F786761:
          return 128;
        case 0x636373705F786761:
          return 129;
        case 0x636373765F786761:
          return 130;
        case 0x636373735F786761:
          return 131;
        case 0x636366735F786761:
          return 132;
        case 0x636369735F786761:
          return 133;
        case 0x63636C635F786761:
          return 134;
        case 0x636373645F786761:
          return 135;
        case 0x636372705F786761:
          return 136;
        case 0x6363726D5F786761:
          return 137;
        case 0x6363676572796E61:
          return 141;
        case 0x6363635F6D766868:
          return 149;
        case 0x61636F6C6C616E69:
          return 172;
        case 0x656E696C6E696F6ELL:
          return 195;
        case 0x6E72757465726F6ELL:
          return 202;
        case 0x646E69776E756F6ELL:
          return 205;
        case 0x656E6F6E64616572:
          return 213;
        case 0x796C6E6F64616572:
          return 214;
        case 0x64656E7275746572:
          return 215;
      }
      if (*(_QWORD *)v4 != 0x7066746369727473)
      {
        v38 = 0;
        v37 = 0;
        v36 = 0;
        v46 = 0;
        v34 = 0;
        v33 = 0;
        v93 = 0;
        v31 = 0;
        v27 = 0;
        v26 = 0;
        v94 = 0;
        v24 = 0;
        v23 = 0;
        v22 = 0;
        v21 = 0;
        v30 = 1;
        goto LABEL_1373;
      }
      return 228;
    case 9uLL:
      if (*(_QWORD *)v4 == 0x61636F6C5F6F7364 && *(_BYTE *)(v4 + 8) == 108)
        return 25;
      if (*(_QWORD *)v4 == 0x6E69646E65707061 && *(_BYTE *)(v4 + 8) == 103)
        return 33;
      if (*(_QWORD *)v4 == 0x726F706D696C6C64 && *(_BYTE *)(v4 + 8) == 116)
        return 34;
      if (*(_QWORD *)v4 == 0x726F7078656C6C64 && *(_BYTE *)(v4 + 8) == 116)
        return 35;
      if (*(_QWORD *)v4 == 0x65746365746F7270 && *(_BYTE *)(v4 + 8) == 100)
        return 40;
      if (*(_QWORD *)v4 == 0x6578656C61636F6CLL && *(_BYTE *)(v4 + 8) == 99)
        return 49;
      if (*(_QWORD *)v4 == 0x65726564726F6E75 && *(_BYTE *)(v4 + 8) == 100)
        return 70;
      if (*(_QWORD *)v4 == 0x696E6F746F6E6F6DLL && *(_BYTE *)(v4 + 8) == 99)
        return 71;
      if (*(_QWORD *)v4 == 0x706F6373636E7973 && *(_BYTE *)(v4 + 8) == 101)
        return 76;
      if (*(_QWORD *)v4 == 0x6361707372646461 && *(_BYTE *)(v4 + 8) == 101)
        return 91;
      if (*(_QWORD *)v4 == 0x6F69746974726170 && *(_BYTE *)(v4 + 8) == 110)
        return 93;
      if (*(_QWORD *)v4 != 0x6E75665F72697073 || *(_BYTE *)(v4 + 8) != 99)
      {
        v45 = 0;
        v71 = 0;
        v49 = 0;
        v44 = 1;
        goto LABEL_251;
      }
      return 127;
    case 0xAuLL:
      if (*(_QWORD *)v4 == 0x6F79616C61746164 && *(_WORD *)(v4 + 8) == 29813)
        return 67;
      if (*(_QWORD *)v4 == 0x6566666565646973 && *(_WORD *)(v4 + 8) == 29795)
        return 98;
      if (*(_QWORD *)v4 == 0x6174736E67696C61 && *(_WORD *)(v4 + 8) == 27491)
        return 99;
      if (*(_QWORD *)v4 == 0x736370615F6D7261 && *(_WORD *)(v4 + 8) == 25443)
        return 116;
      if (*(_QWORD *)v4 == 0x72746E695F727661 && *(_WORD *)(v4 + 8) == 25443)
        return 122;
      if (*(_QWORD *)v4 == 0x6E72656B5F787470 && *(_WORD *)(v4 + 8) == 27749)
        return 124;
      if (*(_QWORD *)v4 != 0x697665645F787470 || *(_WORD *)(v4 + 8) != 25955)
      {
        v44 = 0;
        v45 = 0;
        v71 = 0;
        v49 = 1;
        goto LABEL_251;
      }
      return 125;
    case 0xBuLL:
      if (*(_QWORD *)v4 == 0x775F6E7265747865 && *(_QWORD *)(v4 + 3) == 0x6B6165775F6E7265)
        return 44;
      if (*(_QWORD *)v4 == 0x656C616974696E69 && *(_QWORD *)(v4 + 3) == 0x636578656C616974)
        return 48;
      if (*(_QWORD *)v4 == 0x637061615F6D7261 && *(_QWORD *)(v4 + 3) == 0x636373637061615FLL)
        return 117;
      if (*(_QWORD *)v4 == 0x72656B5F72697073 && *(_QWORD *)(v4 + 3) == 0x6C656E72656B5F72)
        return 126;
      if (*(_QWORD *)v4 == 0x6A5F74696B626577 && *(_QWORD *)(v4 + 3) == 0x6363736A5F74696BLL)
        return 140;
      if (*(_QWORD *)v4 == 0x6961747466697773 && *(_QWORD *)(v4 + 3) == 0x63636C6961747466)
        return 143;
      if (*(_QWORD *)v4 != 0x74746E656D656C65 || *(_QWORD *)(v4 + 3) != 0x65707974746E656DLL)
      {
        v23 = 0;
        v47 = 0;
        v46 = 0;
        v50 = 0;
        v44 = 0;
        v51 = 0;
        LODWORD(v28) = 0;
        v52 = 0;
        v53 = 0;
        v45 = 0;
        v37 = 1;
        goto LABEL_1222;
      }
      return 178;
    case 0xCuLL:
      if (*(_QWORD *)v4 == 0x65636E6F6B6E696CLL && *(_DWORD *)(v4 + 8) == 1919184735)
        return 30;
      if (*(_QWORD *)v4 == 0x5F64656D616E6E75 && *(_DWORD *)(v4 + 8) == 1919181921)
        return 41;
      if (*(_QWORD *)v4 == 0x6C5F646165726874 && *(_DWORD *)(v4 + 8) == 1818321775)
        return 46;
      if (*(_QWORD *)v4 == 0x6E79646C61636F6CLL && *(_DWORD *)(v4 + 8) == 1667853665)
        return 47;
      if (*(_QWORD *)v4 == 0x6169646C65746E69 && *(_DWORD *)(v4 + 8) == 1952671084)
        return 100;
      if (*(_QWORD *)v4 != 0x6E6769735F727661 || *(_DWORD *)(v4 + 8) != 1667460193)
      {
        v44 = 0;
        v71 = 0;
        v49 = 0;
        v45 = 1;
        goto LABEL_251;
      }
      return 123;
    case 0xDuLL:
      if (*(_QWORD *)v4 == 0x636474735F363878 && *(_QWORD *)(v4 + 5) == 0x63636C6C61636474)
        return 111;
      if (*(_QWORD *)v4 == 0x695F30333470736DLL && *(_QWORD *)(v4 + 5) == 0x636372746E695F30)
        return 121;
      if (*(_QWORD *)v4 == 0x735F34365F363878 && *(_QWORD *)(v4 + 5) == 0x6363767379735F34)
        return 138;
      if (*(_QWORD *)v4 != 0x636765725F363878 || *(_QWORD *)(v4 + 5) != 0x63636C6C61636765)
      {
        v23 = 0;
        v44 = 0;
        v45 = 0;
        v47 = 0;
        v49 = 0;
        v48 = 1;
        goto LABEL_1423;
      }
      return 115;
    case 0xEuLL:
      if (*(_QWORD *)v4 == 0x747361665F363878 && *(_QWORD *)(v4 + 6) == 0x63636C6C61637473)
        return 112;
      if (*(_QWORD *)v4 == 0x736968745F363878 && *(_QWORD *)(v4 + 6) == 0x63636C6C61637369)
        return 113;
      if (*(_QWORD *)v4 == 0x636F5F6C65746E69 && *(_QWORD *)(v4 + 6) == 0x636369625F6C636FLL)
        return 109;
      v44 = 0;
      v45 = 0;
      v49 = 0;
      v71 = 1;
LABEL_251:
      if ((v71 & 1) != 0)
      {
        if (*(_QWORD *)v4 == 0x6576726573657270 && *(_QWORD *)(v4 + 6) == 0x63636C6C615F6576)
          return 145;
        v23 = 0;
        v48 = 0;
        v47 = 1;
      }
      else
      {
        v23 = 0;
        v47 = 0;
        v48 = 0;
      }
LABEL_1423:
      if (v49)
      {
        if (*(_QWORD *)v4 == 0x72746E695F363878 && *(_WORD *)(v4 + 8) == 25443)
          return 147;
      }
      if (v47)
      {
        if (*(_QWORD *)v4 == 0x747361665F787863 && *(_QWORD *)(v4 + 6) == 0x6363736C745F7473)
          return 150;
      }
      if (!v44)
        goto LABEL_1462;
      if (*(_QWORD *)v4 == 0x765F757067646D61 && *(_BYTE *)(v4 + 8) == 115)
        return 151;
      if (*(_QWORD *)v4 == 0x6C5F757067646D61 && *(_BYTE *)(v4 + 8) == 115)
        return 152;
      if (*(_QWORD *)v4 == 0x685F757067646D61 && *(_BYTE *)(v4 + 8) == 115)
        return 153;
      if (*(_QWORD *)v4 == 0x655F757067646D61 && *(_BYTE *)(v4 + 8) == 115)
        return 154;
      if (*(_QWORD *)v4 == 0x675F757067646D61 && *(_BYTE *)(v4 + 8) == 115)
        return 155;
      if (*(_QWORD *)v4 == 0x705F757067646D61 && *(_BYTE *)(v4 + 8) == 115)
        return 156;
      if (*(_QWORD *)v4 == 0x635F757067646D61 && *(_BYTE *)(v4 + 8) == 115)
        return 157;
LABEL_1462:
      if (v48)
      {
        if (*(_QWORD *)v4 == 0x6B5F757067646D61 && *(_QWORD *)(v4 + 5) == 0x6C656E72656B5F75)
          return 158;
LABEL_1467:
        v46 = 0;
        goto LABEL_598;
      }
      if (!v49)
        goto LABEL_1467;
      if (*(_QWORD *)v4 == 0x675F757067646D61 && *(_WORD *)(v4 + 8) == 30822)
        return 159;
      v46 = 0;
      v49 = 1;
LABEL_598:
      if (v20 == 1)
      {
LABEL_78:
        if (*(_BYTE *)v4 == 99)
          return 104;
        v53 = 1;
      }
      else if (v49)
      {
        if (*(_QWORD *)v4 == 0x7475626972747461 && *(_WORD *)(v4 + 8) == 29541)
          return 162;
        v53 = 0;
        v49 = 1;
      }
      else
      {
        v53 = 0;
      }
      if (v45)
      {
        if (*(_QWORD *)v4 == 0x6E69737961776C61 && *(_DWORD *)(v4 + 8) == 1701734764)
          return 165;
      }
      if (v49)
      {
        if (*(_QWORD *)v4 == 0x696C61636F6C6C61 && *(_WORD *)(v4 + 8) == 28263)
          return 163;
      }
      if (v44)
      {
        if (*(_QWORD *)v4 == 0x7A6973636F6C6C61 && *(_BYTE *)(v4 + 8) == 101)
          return 164;
      }
      if (v49)
      {
        if (*(_QWORD *)v4 == 0x6E6F6D656D677261 && *(_WORD *)(v4 + 8) == 31084)
          return 166;
      }
      v51 = 0;
      LODWORD(v28) = v23;
LABEL_1200:
      if ((_DWORD)v28)
      {
        if (*(_DWORD *)v4 == 1635154274 && *(_BYTE *)(v4 + 4) == 108)
          return 171;
      }
      if (v49)
      {
        if (*(_QWORD *)v4 == 0x65677265766E6F63 && *(_WORD *)(v4 + 8) == 29806)
          return 174;
        v50 = 0;
        v52 = 1;
      }
      else
      {
        v50 = 0;
        v52 = 0;
      }
      v23 = v48;
LABEL_1212:
      if (v20 == 33)
      {
        v437 = v53;
        v438 = v28;
        v440 = v45;
        v442 = v50;
        v439 = v52;
        v299 = v47;
        if (!memcmp((const void *)v4, "disable_sanitizer_instrumentation", 0x21uLL))
          return 177;
        v37 = 0;
        v47 = v299;
        v52 = v439;
        v45 = v440;
        v53 = v437;
        LODWORD(v28) = v438;
        v50 = v442;
      }
      else
      {
        if (v20 == 23)
        {
          v295 = *(_QWORD *)v4 == 0x6572656665726564 && *(_QWORD *)(v4 + 8) == 0x5F656C626165636ELL;
          if (v295 && *(_QWORD *)(v4 + 15) == 0x6C6C756E5F726F5FLL)
            return 176;
        }
        v37 = 0;
      }
LABEL_1222:
      if (v20 == 29)
      {
        if (*(_QWORD *)v4 == 0x7373656363616E69
          && *(_QWORD *)(v4 + 8) == 0x5F6D656D656C6269
          && *(_QWORD *)(v4 + 16) == 0x656D6772615F726FLL
          && *(_QWORD *)(v4 + 21) == 0x796C6E6F6D656D67)
        {
          return 180;
        }
        goto LABEL_1245;
      }
      if (v20 != 19)
      {
        if (v52)
        {
          if (*(_QWORD *)v4 == 0x6968656E696C6E69 && *(_WORD *)(v4 + 8) == 29806)
            return 181;
          v24 = 0;
          v52 = 1;
          goto LABEL_1246;
        }
LABEL_1245:
        v24 = 0;
        goto LABEL_1246;
      }
      if (*(_QWORD *)v4 == 0x7373656363616E69
        && *(_QWORD *)(v4 + 8) == 0x6F6D656D656C6269
        && *(_QWORD *)(v4 + 11) == 0x796C6E6F6D656D65)
      {
        return 179;
      }
      v24 = 1;
LABEL_1246:
      if ((_DWORD)v28)
      {
        if (*(_DWORD *)v4 == 1701998185 && *(_BYTE *)(v4 + 4) == 103)
          return 182;
      }
      if (v44)
      {
        if (*(_QWORD *)v4 == 0x6C626174706D756ALL && *(_BYTE *)(v4 + 8) == 101)
          return 183;
      }
      if (v51)
      {
        if (*(_DWORD *)v4 == 1936615789 && *(_DWORD *)(v4 + 3) == 1702521203)
          return 184;
      }
      if ((_DWORD)v28)
      {
        if (*(_DWORD *)v4 == 1701536110 && *(_BYTE *)(v4 + 4) == 100)
          return 185;
      }
      if (v51)
      {
        if (*(_DWORD *)v4 == 1818324846 && *(_DWORD *)(v4 + 3) == 1935763820)
          return 187;
      }
      if (v44)
      {
        if (*(_QWORD *)v4 == 0x69746C6975626F6ELL && *(_BYTE *)(v4 + 8) == 110)
          return 189;
      }
      if (v52)
      {
        if (*(_QWORD *)v4 == 0x61626C6C61636F6ELL && *(_WORD *)(v4 + 8) == 27491)
          return 190;
      }
      if (v44)
      {
        if (*(_QWORD *)v4 == 0x7275747061636F6ELL && *(_BYTE *)(v4 + 8) == 101)
          return 191;
      }
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x63696C7075646F6ELL && *(_QWORD *)(v4 + 3) == 0x65746163696C7075)
          return 192;
      }
      if (v44)
      {
        if (*(_QWORD *)v4 == 0x7372756365726F6ELL && *(_BYTE *)(v4 + 8) == 101)
          return 196;
      }
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x62797A616C6E6F6ELL && *(_QWORD *)(v4 + 3) == 0x646E6962797A616CLL)
          return 197;
      }
      if (v51)
      {
        if (*(_DWORD *)v4 == 1701670766 && *(_DWORD *)(v4 + 3) == 1701278309)
          return 198;
        if (*(_DWORD *)v4 == 1852731246 && *(_DWORD *)(v4 + 3) == 1819047278)
          return 199;
      }
      if (v44)
      {
        if (*(_QWORD *)v4 == 0x6C69666F72706F6ELL && *(_BYTE *)(v4 + 8) == 101)
          return 200;
        if (*(_QWORD *)v4 == 0x6E6F7A6465726F6ELL && *(_BYTE *)(v4 + 8) == 101)
          return 201;
      }
      if (v52)
      {
        if (*(_QWORD *)v4 == 0x6568635F66636F6ELL && *(_WORD *)(v4 + 8) == 27491)
          return 204;
      }
      if (v51)
      {
        if (*(_DWORD *)v4 == 1853189998 && *(_DWORD *)(v4 + 3) == 1717920878)
          return 188;
      }
      v38 = v20 == 17;
      v26 = v53;
      v34 = v50;
      v93 = v28;
      v27 = v52;
      v94 = v45;
      v36 = v47;
      if (v20 == 17)
      {
        if (*(_QWORD *)v4 == 0x6974696E61736F6ELL
          && *(_QWORD *)(v4 + 8) == 0x646E756F625F657ALL
          && *(_BYTE *)(v4 + 16) == 115)
        {
          return 206;
        }
        goto LABEL_1337;
      }
      if (v24)
      {
        if (*(_QWORD *)v4 == 0x6974696E61736F6ELL
          && *(_QWORD *)(v4 + 8) == 0x7265766F635F657ALL
          && *(_QWORD *)(v4 + 11) == 0x6567617265766F63)
        {
          return 207;
        }
        v24 = 1;
LABEL_1337:
        v22 = 0;
        v21 = 0;
        if ((v51 & 1) == 0)
          goto LABEL_1347;
        goto LABEL_1338;
      }
      v22 = v20 == 21;
      if (v20 == 21)
      {
        if (*(_QWORD *)v4 == 0x696F705F6C6C756ELL
          && *(_QWORD *)(v4 + 8) == 0x5F73695F7265746ELL
          && *(_QWORD *)(v4 + 13) == 0x64696C61765F7369)
        {
          return 208;
        }
      }
      else if (v23)
      {
        if (*(_QWORD *)v4 == 0x7566726F6674706FLL && *(_QWORD *)(v4 + 5) == 0x676E697A7A756672)
          return 209;
        v23 = 1;
      }
      v38 = 0;
      v24 = 0;
      v21 = 0;
      if (v51)
      {
LABEL_1338:
        if (*(_DWORD *)v4 == 1853124719 && *(_DWORD *)(v4 + 3) == 1701736302)
          return 210;
        if (*(_DWORD *)v4 == 1937010799 && *(_DWORD *)(v4 + 3) == 1702521203)
          return 211;
        v21 = 1;
      }
LABEL_1347:
      if (v45)
      {
        if (*(_QWORD *)v4 == 0x636F6C6C61657270 && *(_DWORD *)(v4 + 8) == 1684370529)
          return 212;
      }
      if (v23)
      {
        if (*(_QWORD *)v4 == 0x5F736E7275746572 && *(_QWORD *)(v4 + 5) == 0x65636977745F736ELL)
          return 216;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1852270963 && *(_DWORD *)(v4 + 3) == 1954047342)
          return 217;
      }
      if (v45)
      {
        if (*(_QWORD *)v4 == 0x74616C7563657073 && *(_DWORD *)(v4 + 8) == 1701601889)
          return 218;
      }
      if ((v44 & 1) != 0)
      {
        if (*(_QWORD *)v4 == 0x6E6F727473707373 && *(_BYTE *)(v4 + 8) == 103)
          return 221;
        v31 = 0;
        v30 = 0;
        v33 = 1;
LABEL_1373:
        if (v33)
        {
          if (*(_QWORD *)v4 == 0x6361747365666173 && *(_BYTE *)(v4 + 8) == 107)
            return 222;
        }
        v63 = 0;
        v25 = v94;
        v32 = v93;
LABEL_122:
        if (!v46)
        {
          v35 = 0;
          v28 = 0;
LABEL_627:
          if (v63)
          {
            if (*(_QWORD *)v4 == 0x657A6974696E6173 && *(_QWORD *)(v4 + 7) == 0x6761746D656D5F65)
              return 169;
            if (*(_QWORD *)v4 == 0x657A6974696E6173 && *(_QWORD *)(v4 + 7) == 0x6461657268745F65)
              return 225;
            if (*(_QWORD *)v4 == 0x657A6974696E6173 && *(_QWORD *)(v4 + 7) == 0x79726F6D656D5F65)
              return 226;
            v29 = 1;
          }
          else
          {
            v29 = 0;
          }
          goto LABEL_1492;
        }
LABEL_123:
        if (*(_QWORD *)v4 == 0x657A6974696E6173 && *(_QWORD *)(v4 + 8) == 0x737365726464615FLL)
          return 167;
        v28 = 0;
        v35 = 1;
        goto LABEL_627;
      }
      v63 = 0;
      v30 = 0;
      v31 = 0;
      v33 = 0;
      v28 = 0;
      v29 = 0;
      v35 = 0;
      v25 = v94;
      v32 = v93;
      if ((v46 & 1) != 0)
        goto LABEL_123;
LABEL_1492:
      v39 = v20 == 26;
      if (v20 == 26)
      {
        if (*(_QWORD *)v4 == 0x74616C7563657073
          && *(_QWORD *)(v4 + 8) == 0x64616F6C5F657669
          && *(_QWORD *)(v4 + 16) == 0x696E65647261685FLL
          && *(_WORD *)(v4 + 24) == 26478)
        {
          return 227;
        }
      }
      else if (v27)
      {
        if (*(_QWORD *)v4 == 0x7272657466697773 && *(_WORD *)(v4 + 8) == 29295)
          return 229;
        v27 = 1;
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x6C65737466697773 && *(_BYTE *)(v4 + 8) == 102)
          return 230;
      }
      if (v27)
      {
        if (*(_QWORD *)v4 == 0x7973617466697773 && *(_WORD *)(v4 + 8) == 25454)
          return 231;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1635022709 && *(_DWORD *)(v4 + 3) == 1701601889)
          return 232;
      }
      if (v25)
      {
        if (*(_QWORD *)v4 == 0x725F656C61637376 && *(_DWORD *)(v4 + 8) == 1701277281)
          return 233;
      }
      if (v27)
      {
        if (*(_QWORD *)v4 == 0x757465726C6C6977 && *(_WORD *)(v4 + 8) == 28274)
          return 234;
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x6C6E6F6574697277 && *(_BYTE *)(v4 + 8) == 121)
          return 235;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1869768058 && *(_DWORD *)(v4 + 3) == 1954047343)
          return 236;
      }
      if (v31)
      {
        if (*(_DWORD *)v4 == 1634561385 && *(_WORD *)(v4 + 4) == 26482)
          return 237;
      }
      if (v32)
      {
        if (*(_DWORD *)v4 == 1702000994 && *(_BYTE *)(v4 + 4) == 102)
          return 238;
      }
      if (v25)
      {
        if (*(_QWORD *)v4 == 0x676F72707473756DLL && *(_DWORD *)(v4 + 8) == 1936942450)
          return 239;
      }
LABEL_57:
      if (v32)
      {
        if (*(_DWORD *)v4 == 1853453153 && *(_BYTE *)(v4 + 4) == 99)
          return 241;
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1701869940)
        return 242;
      if (v31)
      {
        if (*(_DWORD *)v4 == 1902211183 && *(_WORD *)(v4 + 4) == 25973)
          return 243;
        if (*(_DWORD *)v4 == 1684893539 && *(_WORD *)(v4 + 4) == 29793)
          return 244;
      }
      v43 = 0;
LABEL_393:
      if (v27)
      {
        if (*(_QWORD *)v4 == 0x74616D7463617865 && *(_WORD *)(v4 + 8) == 26723)
          return 246;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1735549292 && *(_DWORD *)(v4 + 3) == 1953719655)
          return 247;
      }
      if (v23)
      {
        if (*(_QWORD *)v4 == 0x6C70756465646F6ELL && *(_QWORD *)(v4 + 5) == 0x65746163696C7075)
          return 248;
      }
      if (v30 && *(_QWORD *)v4 == 0x657A6973656D6173)
        return 249;
      if (v34)
      {
        if (*(_WORD *)v4 == 29029)
          return 250;
        if (*(_WORD *)v4 == 25966)
          return 251;
      }
      v441 = v34;
      if (v43)
      {
        if (*(_WORD *)v4 == 27763 && *(_BYTE *)(v4 + 2) == 116)
          return 252;
        if (*(_WORD *)v4 == 26483 && *(_BYTE *)(v4 + 2) == 116)
          return 253;
        if (*(_WORD *)v4 == 27763 && *(_BYTE *)(v4 + 2) == 101)
          return 254;
        if (*(_WORD *)v4 == 26483 && *(_BYTE *)(v4 + 2) == 101)
          return 255;
        if (*(_WORD *)v4 == 27765 && *(_BYTE *)(v4 + 2) == 116)
          return 256;
        if (*(_WORD *)v4 == 26485 && *(_BYTE *)(v4 + 2) == 116)
          return 257;
        if (*(_WORD *)v4 == 27765 && *(_BYTE *)(v4 + 2) == 101)
          return 258;
        if (*(_WORD *)v4 == 26485 && *(_BYTE *)(v4 + 2) == 101)
          return 259;
        if (*(_WORD *)v4 == 25967 && *(_BYTE *)(v4 + 2) == 113)
          return 260;
        if (*(_WORD *)v4 == 28271 && *(_BYTE *)(v4 + 2) == 101)
          return 261;
        if (*(_WORD *)v4 == 27759 && *(_BYTE *)(v4 + 2) == 116)
          return 262;
        if (*(_WORD *)v4 == 26479 && *(_BYTE *)(v4 + 2) == 116)
          return 263;
        if (*(_WORD *)v4 == 27759 && *(_BYTE *)(v4 + 2) == 101)
          return 264;
        if (*(_WORD *)v4 == 26479 && *(_BYTE *)(v4 + 2) == 101)
          return 265;
        if (*(_WORD *)v4 == 29295 && *(_BYTE *)(v4 + 2) == 100)
          return 266;
        if (*(_WORD *)v4 == 28277 && *(_BYTE *)(v4 + 2) == 111)
          return 267;
        if (*(_WORD *)v4 == 25973 && *(_BYTE *)(v4 + 2) == 113)
          return 268;
        if (*(_WORD *)v4 == 28277 && *(_BYTE *)(v4 + 2) == 101)
          return 269;
      }
      if (v20 == 4)
      {
        if (*(_DWORD *)v4 == 1734894456)
          return 270;
        if (*(_DWORD *)v4 == 1684955502)
          return 271;
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 24941 && *(_BYTE *)(v4 + 2) == 120)
          return 272;
        if (*(_WORD *)v4 == 26989 && *(_BYTE *)(v4 + 2) == 110)
          return 273;
      }
      if (v20 == 4)
      {
        if (*(_DWORD *)v4 == 2019650933)
          return 274;
        if (*(_DWORD *)v4 == 1852403061)
          return 275;
      }
      if (v31)
      {
        if (*(_DWORD *)v4 == 1633907574 && *(_WORD *)(v4 + 4) == 25964)
          return 17;
      }
      if (v26 && *(_BYTE *)v4 == 120)
        return 18;
      if (v25)
      {
        if (*(_QWORD *)v4 == 0x6464616B636F6C62 && *(_DWORD *)(v4 + 8) == 1936942450)
          return 344;
      }
      if (v31)
      {
        if (*(_DWORD *)v4 == 1667198830 && *(_WORD *)(v4 + 4) == 26982)
          return 346;
      }
      if (v30 && *(_QWORD *)v4 == 0x74636E6974736964)
        return 348;
      if (v25)
      {
        if (*(_QWORD *)v4 == 0x6F7473696C657375 && *(_DWORD *)(v4 + 8) == 1919247474)
          return 349;
      }
      if (v29)
      {
        if (*(_QWORD *)v4 == 0x6F7473696C657375 && *(_QWORD *)(v4 + 7) == 0x62625F726564726FLL)
          return 350;
      }
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x6C616E6F73726570 && *(_QWORD *)(v4 + 3) == 0x7974696C616E6F73)
          return 315;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1634036835 && *(_DWORD *)(v4 + 3) == 1886744161)
          return 316;
      }
      if (v32)
      {
        if (*(_DWORD *)v4 == 1668571491 && *(_BYTE *)(v4 + 4) == 104)
          return 317;
      }
      if (v31)
      {
        if (*(_DWORD *)v4 == 1953261926 && *(_WORD *)(v4 + 4) == 29285)
          return 318;
      }
      if (v20 == 4)
      {
        switch(*(_DWORD *)v4)
        {
          case 0x68746170:
            return 351;
          case 0x68736168:
            return 352;
          case 0x64697567:
            return 354;
          case 0x656D616E:
            return 355;
        }
      }
      else if (v34)
      {
        if (*(_WORD *)v4 == 30311)
          return 353;
        v441 = 1;
      }
      else
      {
        v441 = 0;
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x656972616D6D7573 && *(_BYTE *)(v4 + 8) == 115)
          return 356;
      }
      if (v32)
      {
        if (*(_DWORD *)v4 == 1734437990 && *(_BYTE *)(v4 + 4) == 115)
          return 357;
      }
      if (v27)
      {
        if (*(_QWORD *)v4 == 0x756F636B636F6C62 && *(_WORD *)(v4 + 8) == 29806)
          return 358;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1802398060 && *(_DWORD *)(v4 + 3) == 1701273963)
          return 359;
      }
      if (v27)
      {
        if (*(_QWORD *)v4 == 0x696C696269736976 && *(_WORD *)(v4 + 8) == 31092)
          return 360;
      }
      else if (v24)
      {
        if (*(_QWORD *)v4 == 0x6967696C45746F6ELL
          && *(_QWORD *)(v4 + 8) == 0x706D496F54656C62
          && *(_QWORD *)(v4 + 11) == 0x74726F706D496F54)
        {
          return 361;
        }
        v24 = 1;
      }
      else
      {
        if (v20 == 4 && *(_DWORD *)v4 == 1702259052)
          return 362;
        v24 = 0;
      }
      if (v30 && *(_QWORD *)v4 == 0x6C61636F4C6F7364)
        return 363;
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x486F7475416E6163 && *(_QWORD *)(v4 + 3) == 0x656469486F747541)
          return 364;
      }
      if (v30 && *(_QWORD *)v4 == 0x6E6F6974636E7566)
        return 365;
      if (v32)
      {
        if (*(_DWORD *)v4 == 1953721961 && *(_BYTE *)(v4 + 4) == 115)
          return 366;
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x67616C46636E7566 && *(_BYTE *)(v4 + 8) == 115)
          return 367;
      }
      if (v30)
      {
        if (*(_QWORD *)v4 == 0x656E6F4E64616572)
          return 368;
        if (*(_QWORD *)v4 == 0x796C6E4F64616572)
          return 369;
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x7372756365526F6ELL && *(_BYTE *)(v4 + 8) == 101)
          return 370;
      }
      if ((_DWORD)v28)
      {
        v399 = *(_QWORD *)v4 == 0x6F446E7275746572 && *(_QWORD *)(v4 + 8) == 0x696C41746F4E7365;
        v28 = 29537;
        if (v399 && *(_WORD *)(v4 + 16) == 29537)
          return 371;
      }
      if (v30)
      {
        v28 = *(_QWORD *)v4;
        if (*(_QWORD *)v4 == 0x656E696C6E496F6ELL)
          return 372;
      }
      if (v25)
      {
        v28 = 1701734764;
        if (*(_QWORD *)v4 == 0x6E49737961776C61 && *(_DWORD *)(v4 + 8) == 1701734764)
          return 373;
      }
      if (v30)
      {
        if (*(_QWORD *)v4 == 0x646E69776E556F6ELL)
          return 374;
        v28 = *(_QWORD *)v4;
        if (*(_QWORD *)v4 == 0x776F72685479616DLL)
          return 375;
      }
      if (v36)
      {
        v28 = 0x6C6C61436E776F6ELL;
        if (*(_QWORD *)v4 == 0x6F6E6B6E55736168 && *(_QWORD *)(v4 + 6) == 0x6C6C61436E776F6ELL)
          return 376;
      }
      if (v38)
      {
        v28 = *(_QWORD *)(v4 + 8);
        v403 = *(_QWORD *)v4 == 0x6E5565427473756DLL && v28 == 0x6C62616863616572;
        if (v403 && *(_BYTE *)(v4 + 16) == 101)
          return 377;
      }
      if (v32)
      {
        v28 = *(unsigned __int8 *)(v4 + 4);
        if (*(_DWORD *)v4 == 1819042147 && (_DWORD)v28 == 115)
          return 378;
      }
      if (v31)
      {
        if (*(_DWORD *)v4 == 1819042147 && *(_WORD *)(v4 + 4) == 25957)
          return 379;
        v28 = *(unsigned __int16 *)(v4 + 4);
        if (*(_DWORD *)v4 == 1634886000 && (_DWORD)v28 == 29549)
          return 380;
      }
      if (v32)
      {
        v28 = *(unsigned __int8 *)(v4 + 4);
        if (*(_DWORD *)v4 == 1634886000 && (_DWORD)v28 == 109)
          return 381;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1853124456 && *(_DWORD *)(v4 + 3) == 1936942446)
          return 382;
        v28 = *(unsigned int *)(v4 + 3);
        if (*(_DWORD *)v4 == 1852534389 && (_DWORD)v28 == 1853321070)
          return 383;
      }
      if (v43)
      {
        v28 = *(unsigned __int8 *)(v4 + 2);
        if (*(_WORD *)v4 == 28520 && (_DWORD)v28 == 116)
          return 384;
      }
      if (v30)
      {
        v28 = 0x6C61636974697263;
        if (*(_QWORD *)v4 == 0x6C61636974697263)
          return 385;
      }
      if (v32)
      {
        v28 = *(unsigned __int8 *)(v4 + 4);
        if (*(_DWORD *)v4 == 1651271026 && (_DWORD)v28 == 102)
          return 386;
      }
      if (v30)
      {
        v28 = 0x656C626169726176;
        if (*(_QWORD *)v4 == 0x656C626169726176)
          return 387;
      }
      if (v37)
      {
        v28 = *(_QWORD *)(v4 + 3);
        if (*(_QWORD *)v4 == 0x7546656C62615476 && v28 == 0x73636E7546656C62)
          return 388;
      }
      if (v30)
      {
        v28 = 0x636E754674726976;
        if (*(_QWORD *)v4 == 0x636E754674726976)
          return 389;
      }
      if (v21)
      {
        v28 = *(unsigned int *)(v4 + 3);
        if (*(_DWORD *)v4 == 1634298977 && (_DWORD)v28 == 1701147489)
          return 390;
      }
      if (v20 == 4)
      {
        v28 = 1936090482;
        if (*(_DWORD *)v4 == 1936090482)
          return 391;
      }
      else if (v27)
      {
        v28 = *(unsigned __int16 *)(v4 + 8);
        if (*(_QWORD *)v4 == 0x6E49644965707974 && (_DWORD)v28 == 28518)
          return 392;
        v27 = 1;
      }
      if (v33)
      {
        v28 = *(unsigned __int8 *)(v4 + 8);
        if (*(_QWORD *)v4 == 0x7473655465707974 && (_DWORD)v28 == 115)
          return 393;
      }
      if (v22)
      {
        v28 = *(_QWORD *)(v4 + 13);
        v416 = *(_QWORD *)v4 == 0x6365684365707974 && *(_QWORD *)(v4 + 8) == 0x5664616F4C64656BLL;
        if (v416 && v28 == 0x736C6C6143566461)
          return 395;
      }
      if (v20 == 25)
      {
        v28 = *(unsigned __int8 *)(v4 + 24);
        if (*(_QWORD *)v4 == 0x7473655465707974
          && *(_QWORD *)(v4 + 8) == 0x6F43656D75737341
          && *(_QWORD *)(v4 + 16) == 0x6C6C61435674736ELL
          && (_DWORD)v28 == 115)
        {
          return 396;
        }
      }
      else if (v39)
      {
        v28 = *(unsigned __int16 *)(v4 + 24);
        v434 = *(_QWORD *)v4 == 0x6365684365707974 && *(_QWORD *)(v4 + 8) == 0x4364616F4C64656BLL;
        v435 = v434 && *(_QWORD *)(v4 + 16) == 0x6C61435674736E6FLL;
        if (v435 && (_DWORD)v28 == 29548)
          return 397;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1853179510 && *(_DWORD *)(v4 + 3) == 1682531182)
          return 398;
      }
      if (v31)
      {
        if (*(_DWORD *)v4 == 1936090735 && *(_WORD *)(v4 + 4) == 29797)
          return 399;
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1936159329)
        return 400;
      if (v31)
      {
        if (*(_DWORD *)v4 == 1701869940 && *(_WORD *)(v4 + 4) == 25705)
          return 401;
        v201 = 1;
      }
      else
      {
        v201 = 0;
      }
      v203 = v25;
      v202 = v27;
      v200 = v32;
      v199 = v441;
LABEL_721:
      if (v21)
      {
        if (*(_DWORD *)v4 == 1835890035 && *(_DWORD *)(v4 + 3) == 2037539181)
          return 403;
      }
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x7473655465707974 && *(_QWORD *)(v4 + 3) == 0x7365527473655465)
          return 404;
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1684957547)
        return 405;
      if (v200)
      {
        if (*(_DWORD *)v4 == 1634954869 && *(_BYTE *)(v4 + 4) == 116)
          return 406;
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x6172724165747962 && *(_BYTE *)(v4 + 8) == 121)
          return 407;
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1768713833 && *(_WORD *)(v4 + 4) == 25966)
          return 408;
        if (*(_DWORD *)v4 == 1735289203 && *(_WORD *)(v4 + 4) == 25964)
          return 409;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1332505697 && *(_DWORD *)(v4 + 3) == 1936027215)
          return 410;
      }
      if (v36)
      {
        if (*(_QWORD *)v4 == 0x6942314D657A6973 && *(_QWORD *)(v4 + 6) == 0x6874646957746942)
          return 411;
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x676F4C6E67696C61 && *(_BYTE *)(v4 + 8) == 50)
          return 412;
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1702521203 && *(_WORD *)(v4 + 4) == 12621)
          return 413;
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1299474786 && *(_DWORD *)(v4 + 3) == 1802723661)
          return 414;
      }
      if (v202)
      {
        if (*(_QWORD *)v4 == 0x6942656E696C6E69 && *(_WORD *)(v4 + 8) == 29556)
          return 415;
      }
      if (v35)
      {
        if (*(_QWORD *)v4 == 0x69765F6C6C616376 && *(_QWORD *)(v4 + 8) == 0x7974696C69626973)
          return 416;
      }
      v217 = v36;
      if (v36)
      {
        if (*(_QWORD *)v4 == 0x6C6F736552647077 && *(_QWORD *)(v4 + 6) == 0x736E6F6974756C6FLL)
          return 417;
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1382314103 && *(_WORD *)(v4 + 4) == 29541)
          return 418;
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 1768189545 && *(_BYTE *)(v4 + 4) == 114)
          return 419;
      }
      if (v202)
      {
        if (*(_QWORD *)v4 == 0x6D49656C676E6973 && *(_WORD *)(v4 + 8) == 27760)
          return 420;
      }
      if (v203)
      {
        if (*(_QWORD *)v4 == 0x754668636E617262 && *(_DWORD *)(v4 + 8) == 1818586734)
          return 421;
      }
      if (v36)
      {
        if (*(_QWORD *)v4 == 0x6D49656C676E6973 && *(_QWORD *)(v4 + 6) == 0x656D614E6C706D49)
          return 422;
      }
      if (v30 && *(_QWORD *)v4 == 0x6772417942736572)
        return 423;
      if (v200)
      {
        if (*(_DWORD *)v4 == 1916893538 && *(_BYTE *)(v4 + 4) == 103)
          return 424;
      }
      if (v23)
      {
        if (*(_QWORD *)v4 == 0x526D726F66696E75 && *(_QWORD *)(v4 + 5) == 0x6C61567465526D72)
          return 425;
      }
      if (v203)
      {
        if (*(_QWORD *)v4 == 0x6552657571696E75 && *(_DWORD *)(v4 + 8) == 1818318452)
          return 426;
      }
      if (v35)
      {
        if (*(_QWORD *)v4 == 0x436C617574726976 && *(_QWORD *)(v4 + 8) == 0x706F725074736E6FLL)
          return 427;
      }
      if (v20 == 4)
      {
        if (*(_DWORD *)v4 == 1868983913)
          return 428;
        if (*(_DWORD *)v4 == 1702132066)
          return 429;
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 26978 && *(_BYTE *)(v4 + 2) == 116)
          return 430;
      }
      if (v30 && *(_QWORD *)v4 == 0x7367616C46726176)
        return 431;
      if (v20 == 4)
      {
        if (*(_DWORD *)v4 == 1684631414)
        {
          VoidTy = llvm::Type::getVoidTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
        if (*(_DWORD *)v4 == 1718378856)
        {
          VoidTy = llvm::Type::getHalfTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1869375074 && *(_WORD *)(v4 + 4) == 29793)
        {
          VoidTy = llvm::Type::getBFloatTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 1634692198 && *(_BYTE *)(v4 + 4) == 116)
        {
          VoidTy = llvm::Type::getFloatTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1651863396 && *(_WORD *)(v4 + 4) == 25964)
        {
          VoidTy = llvm::Type::getDoubleTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v30 && *(_QWORD *)v4 == 0x303870665F363878)
      {
        VoidTy = llvm::Type::getX86_FP80Ty(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
        goto LABEL_36;
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 842100838 && *(_BYTE *)(v4 + 4) == 56)
        {
          VoidTy = llvm::Type::getFP128Ty(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x323170665F637070 && *(_BYTE *)(v4 + 8) == 56)
        {
          VoidTy = llvm::Type::getPPC_FP128Ty(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 1700946284 && *(_BYTE *)(v4 + 4) == 108)
        {
          VoidTy = llvm::Type::getLabelTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v30 && *(_QWORD *)v4 == 0x617461646174656DLL)
      {
        VoidTy = llvm::Type::getMetadataTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
        goto LABEL_36;
      }
      if (v21)
      {
        v28 = 2020437343;
        if (*(_DWORD *)v4 == 1597388920 && *(_DWORD *)(v4 + 3) == 2020437343)
        {
          VoidTy = llvm::Type::getX86_MMXTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)0x786D6D5F);
          goto LABEL_36;
        }
        if (*(_DWORD *)v4 == 1597388920 && *(_DWORD *)(v4 + 3) == 2020434271)
        {
          VoidTy = llvm::Type::getX86_AMXTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)0x786D6D5F);
          goto LABEL_36;
        }
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 1701539700 && *(_BYTE *)(v4 + 4) == 110)
        {
          VoidTy = llvm::Type::getTokenTy(*((llvm::Type **)this + 5), (llvm::LLVMContext *)v28);
          goto LABEL_36;
        }
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 29808 && *(_BYTE *)(v4 + 2) == 114)
        {
          hasSetOpaquePointersValue = llvm::LLVMContext::hasSetOpaquePointersValue(*((llvm::LLVMContextImpl ***)this + 5));
          v432 = (llvm::LLVMContextImpl **)*((_QWORD *)this + 5);
          if ((hasSetOpaquePointersValue & 1) != 0)
          {
            if (llvm::LLVMContext::supportsTypedPointers(v432))
            {
              v447 = "ptr type is only supported in -opaque-pointers mode";
              v449 = 259;
              llvm::SourceMgr::PrintMessage(*((llvm **)this + 4), *((char **)this + 6), 1, (llvm::Twine *)&v447, 0, 0, 0, 0, 1u);
              return 1;
            }
          }
          else
          {
            llvm::LLVMContext::setOpaquePointers((llvm::LLVMContext *)v432, 1);
          }
          VoidTy = llvm::PointerType::get(*((llvm::PointerType **)this + 5), 0);
LABEL_36:
          *((_QWORD *)this + 12) = VoidTy;
          return 455;
        }
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1734700646)
      {
        *((_DWORD *)this + 22) = 12;
        return 276;
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 25697 && *(_BYTE *)(v4 + 2) == 100)
        {
          *((_DWORD *)this + 22) = 13;
          return 277;
        }
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1684300134)
      {
        *((_DWORD *)this + 22) = 14;
        return 278;
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 30067 && *(_BYTE *)(v4 + 2) == 98)
        {
          *((_DWORD *)this + 22) = 15;
          return 279;
        }
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1651864422)
      {
        *((_DWORD *)this + 22) = 16;
        return 280;
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 30061 && *(_BYTE *)(v4 + 2) == 108)
        {
          *((_DWORD *)this + 22) = 17;
          return 281;
        }
      }
      if (v20 == 4)
      {
        switch(*(_DWORD *)v4)
        {
          case 0x6C756D66:
            *((_DWORD *)this + 22) = 18;
            return 282;
          case 0x76696475:
            *((_DWORD *)this + 22) = 19;
            return 283;
          case 0x76696473:
            *((_DWORD *)this + 22) = 20;
            return 284;
          case 0x76696466:
            *((_DWORD *)this + 22) = 21;
            return 285;
          case 0x6D657275:
            *((_DWORD *)this + 22) = 22;
            return 286;
          case 0x6D657273:
            *((_DWORD *)this + 22) = 23;
            return 287;
          case 0x6D657266:
            *((_DWORD *)this + 22) = 24;
            return 288;
        }
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 26739 && *(_BYTE *)(v4 + 2) == 108)
        {
          *((_DWORD *)this + 22) = 25;
          return 289;
        }
      }
      if (v20 == 4)
      {
        if (*(_DWORD *)v4 == 1919447916)
        {
          *((_DWORD *)this + 22) = 26;
          return 290;
        }
        if (*(_DWORD *)v4 == 1919447905)
        {
          *((_DWORD *)this + 22) = 27;
          return 291;
        }
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 28257 && *(_BYTE *)(v4 + 2) == 100)
        {
          *((_DWORD *)this + 22) = 28;
          return 292;
        }
      }
      if (v199 && *(_WORD *)v4 == 29295)
      {
        *((_DWORD *)this + 22) = 29;
        return 293;
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 28536 && *(_BYTE *)(v4 + 2) == 114)
        {
          *((_DWORD *)this + 22) = 30;
          return 294;
        }
      }
      if (v20 == 4)
      {
        if (*(_DWORD *)v4 == 1886217065)
        {
          *((_DWORD *)this + 22) = 53;
          return 295;
        }
        if (*(_DWORD *)v4 == 1886217062)
        {
          *((_DWORD *)this + 22) = 54;
          return 296;
        }
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 26736 && *(_BYTE *)(v4 + 2) == 105)
        {
          *((_DWORD *)this + 22) = 55;
          return 297;
        }
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1819042147)
      {
        *((_DWORD *)this + 22) = 56;
        return 298;
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 1853190772 && *(_BYTE *)(v4 + 4) == 99)
        {
          *((_DWORD *)this + 22) = 38;
          return 299;
        }
      }
      if (v20 == 4)
      {
        if (*(_DWORD *)v4 == 1954047354)
        {
          *((_DWORD *)this + 22) = 39;
          return 300;
        }
        if (*(_DWORD *)v4 == 1954047347)
        {
          *((_DWORD *)this + 22) = 40;
          return 301;
        }
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1920233574 && *(_DWORD *)(v4 + 3) == 1668183410)
        {
          *((_DWORD *)this + 22) = 45;
          return 302;
        }
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 2019913830 && *(_BYTE *)(v4 + 4) == 116)
        {
          *((_DWORD *)this + 22) = 46;
          return 303;
        }
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1869900149 && *(_WORD *)(v4 + 4) == 28774)
        {
          *((_DWORD *)this + 22) = 43;
          return 304;
        }
        if (*(_DWORD *)v4 == 1869900147 && *(_WORD *)(v4 + 4) == 28774)
        {
          *((_DWORD *)this + 22) = 44;
          return 305;
        }
        if (*(_DWORD *)v4 == 1869901926 && *(_WORD *)(v4 + 4) == 26997)
        {
          *((_DWORD *)this + 22) = 41;
          return 306;
        }
        if (*(_DWORD *)v4 == 1869901926 && *(_WORD *)(v4 + 4) == 26995)
        {
          *((_DWORD *)this + 22) = 42;
          return 307;
        }
      }
      if (v30)
      {
        if (*(_QWORD *)v4 == 0x7274706F74746E69)
        {
          *((_DWORD *)this + 22) = 48;
          return 308;
        }
        if (*(_QWORD *)v4 == 0x746E696F74727470)
        {
          *((_DWORD *)this + 22) = 47;
          return 309;
        }
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 1668573538 && *(_DWORD *)(v4 + 3) == 1953718627)
        {
          *((_DWORD *)this + 22) = 49;
          return 310;
        }
      }
      if (v23)
      {
        if (*(_QWORD *)v4 == 0x6361707372646461 && *(_QWORD *)(v4 + 5) == 0x7473616365636170)
        {
          *((_DWORD *)this + 22) = 50;
          return 311;
        }
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1701602675 && *(_WORD *)(v4 + 4) == 29795)
        {
          *((_DWORD *)this + 22) = 57;
          return 312;
        }
        if (*(_DWORD *)v4 == 1633640822 && *(_WORD *)(v4 + 4) == 26482)
        {
          *((_DWORD *)this + 22) = 60;
          return 313;
        }
      }
      if (v43)
      {
        if (*(_WORD *)v4 == 25970 && *(_BYTE *)(v4 + 2) == 116)
        {
          *((_DWORD *)this + 22) = 1;
          return 319;
        }
      }
      if (v199 && *(_WORD *)v4 == 29282)
      {
        *((_DWORD *)this + 22) = 2;
        return 320;
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1953068915 && *(_WORD *)(v4 + 4) == 26723)
        {
          *((_DWORD *)this + 22) = 3;
          return 321;
        }
      }
      if (v202)
      {
        if (*(_QWORD *)v4 == 0x7463657269646E69 && *(_WORD *)(v4 + 8) == 29282)
        {
          *((_DWORD *)this + 22) = 4;
          return 322;
        }
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1870032489 && *(_WORD *)(v4 + 4) == 25963)
        {
          *((_DWORD *)this + 22) = 5;
          return 323;
        }
        if (*(_DWORD *)v4 == 1970496882 && *(_WORD *)(v4 + 4) == 25965)
        {
          *((_DWORD *)this + 22) = 6;
          return 324;
        }
      }
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x6168636165726E75 && *(_QWORD *)(v4 + 3) == 0x656C626168636165)
        {
          *((_DWORD *)this + 22) = 7;
          return 325;
        }
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1819042147 && *(_WORD *)(v4 + 4) == 29282)
        {
          *((_DWORD *)this + 22) = 11;
          return 331;
        }
        if (*(_DWORD *)v4 == 1869376609 && *(_WORD *)(v4 + 4) == 24931)
        {
          *((_DWORD *)this + 22) = 31;
          return 332;
        }
      }
      if (v20 == 4 && *(_DWORD *)v4 == 1684107116)
      {
        *((_DWORD *)this + 22) = 32;
        return 333;
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 1919906931 && *(_BYTE *)(v4 + 4) == 101)
        {
          *((_DWORD *)this + 22) = 33;
          return 334;
        }
      }
      if (v21)
      {
        if (*(_DWORD *)v4 == 2020633955 && *(_DWORD *)(v4 + 3) == 1734894456)
        {
          *((_DWORD *)this + 22) = 36;
          return 336;
        }
      }
      if (v33)
      {
        if (*(_QWORD *)v4 == 0x6D7263696D6F7461 && *(_BYTE *)(v4 + 8) == 119)
        {
          *((_DWORD *)this + 22) = 37;
          return 337;
        }
      }
      if (v200)
      {
        if (*(_DWORD *)v4 == 1668179302 && *(_BYTE *)(v4 + 4) == 101)
        {
          *((_DWORD *)this + 22) = 35;
          return 335;
        }
      }
      if (v23)
      {
        if (*(_QWORD *)v4 == 0x656D656C65746567 && *(_QWORD *)(v4 + 5) == 0x727470746E656D65)
        {
          *((_DWORD *)this + 22) = 34;
          return 338;
        }
      }
      if (v36)
      {
        if (*(_QWORD *)v4 == 0x6574636172747865 && *(_QWORD *)(v4 + 6) == 0x746E656D656C6574)
        {
          *((_DWORD *)this + 22) = 61;
          return 339;
        }
      }
      if (v23)
      {
        if (*(_QWORD *)v4 == 0x6C65747265736E69 && *(_QWORD *)(v4 + 5) == 0x746E656D656C6574)
        {
          *((_DWORD *)this + 22) = 62;
          return 340;
        }
        if (*(_QWORD *)v4 == 0x76656C6666756873 && *(_QWORD *)(v4 + 5) == 0x726F74636576656CLL)
        {
          *((_DWORD *)this + 22) = 63;
          return 341;
        }
      }
      if (v203)
      {
        if (*(_QWORD *)v4 == 0x7674636172747865 && *(_DWORD *)(v4 + 8) == 1702194273)
        {
          *((_DWORD *)this + 22) = 64;
          return 342;
        }
      }
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x6176747265736E69 && *(_QWORD *)(v4 + 3) == 0x65756C6176747265)
        {
          *((_DWORD *)this + 22) = 65;
          return 343;
        }
      }
      if (v202)
      {
        if (*(_QWORD *)v4 == 0x70676E69646E616CLL && *(_WORD *)(v4 + 8) == 25697)
        {
          *((_DWORD *)this + 22) = 66;
          return 314;
        }
        if (*(_QWORD *)v4 == 0x7270756E61656C63 && *(_WORD *)(v4 + 8) == 29797)
        {
          *((_DWORD *)this + 22) = 8;
          return 326;
        }
      }
      if (v30 && *(_QWORD *)v4 == 0x7465726863746163)
      {
        *((_DWORD *)this + 22) = 9;
        return 328;
      }
      if (v37)
      {
        if (*(_QWORD *)v4 == 0x6977736863746163 && *(_QWORD *)(v4 + 3) == 0x6863746977736863)
        {
          *((_DWORD *)this + 22) = 10;
          return 327;
        }
      }
      if (v30 && *(_QWORD *)v4 == 0x6461706863746163)
      {
        *((_DWORD *)this + 22) = 52;
        return 329;
      }
      if (v202)
      {
        if (*(_QWORD *)v4 == 0x7070756E61656C63 && *(_WORD *)(v4 + 8) == 25697)
        {
          *((_DWORD *)this + 22) = 51;
          return 330;
        }
      }
      if (v201)
      {
        if (*(_DWORD *)v4 == 1701147238 && *(_WORD *)(v4 + 4) == 25978)
        {
          *((_DWORD *)this + 22) = 67;
          return 347;
        }
      }
      if (v20 < 7)
      {
        if (v20 != 6)
        {
          if (v20 < 4)
            goto LABEL_1635;
          goto LABEL_1634;
        }
        goto LABEL_1176;
      }
LABEL_1166:
      if (*(_DWORD *)v4 == 1415534404 && *(_DWORD *)(v4 + 3) == 1598505300)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 443;
      }
      if (*(_DWORD *)v4 == 1096767300 && *(_DWORD *)(v4 + 3) == 1598379073)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 444;
      }
      if (v20 >= 0xE)
      {
        if (*(_QWORD *)v4 == 0x55545249565F5744 && *(_QWORD *)(v4 + 6) == 0x5F5954494C415554)
        {
          sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
          return 445;
        }
      }
      else if (v20 < 8)
      {
LABEL_1176:
        v288 = 1;
        goto LABEL_1615;
      }
      if (*(_QWORD *)v4 == 0x5F474E414C5F5744)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 446;
      }
      v288 = 0;
LABEL_1615:
      if (*(_DWORD *)v4 == 1130321732 && *(_WORD *)(v4 + 4) == 24387)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 447;
      }
      if (*(_DWORD *)v4 == 1331648324 && *(_WORD *)(v4 + 4) == 24400)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 450;
      }
      if (v20 >= 0xB && *(_QWORD *)v4 == 0x4E4943414D5F5744 && *(_QWORD *)(v4 + 3) == 0x5F4F464E4943414DLL)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 453;
      }
      if (*(_DWORD *)v4 == 1816545604 && *(_WORD *)(v4 + 4) == 26465)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 451;
      }
      if ((v288 & 1) == 0 && *(_QWORD *)v4 == 0x67616C4650534944)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 452;
      }
LABEL_1634:
      if (*(_DWORD *)v4 == 1598772035)
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 454;
      }
LABEL_1635:
      if (v21 && (*(_DWORD *)v4 == 1698983758 ? (v361 = *(_DWORD *)(v4 + 3) == 1735746149) : (v361 = 0), v361)
        || v33 && (*(_QWORD *)v4 == 0x756265446C6C7546 ? (v362 = *(_BYTE *)(v4 + 8) == 103) : (v362 = 0), v362)
        || v217
        && (*(_QWORD *)v4 == 0x6C626154656E694CLL ? (v363 = *(_QWORD *)(v4 + 6) == 0x796C6E4F73656C62) : (v363 = 0),
            v363)
        || v24
        && (*(_QWORD *)v4 == 0x7269446775626544 ? (v364 = *(_QWORD *)(v4 + 8) == 0x4F73657669746365) : (v364 = 0),
            v364 ? (v365 = *(_QWORD *)(v4 + 11) == 0x796C6E4F73657669) : (v365 = 0),
            v365))
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 448;
      }
      if (v43 && (*(_WORD *)v4 == 20039 ? (v366 = *(_BYTE *)(v4 + 2) == 85) : (v366 = 0), v366)
        || v20 == 4 && *(_DWORD *)v4 == 1701736270
        || v21 && (*(_DWORD *)v4 == 1634100548 ? (v367 = *(_DWORD *)(v4 + 3) == 1953264993) : (v367 = 0), v367))
      {
        sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)v4, v2, (std::string::size_type)&v2[-v4]);
        return 449;
      }
      v368 = (unsigned __int8 *)*((_QWORD *)this + 6);
      v369 = *v368;
      if (v369 == 99)
      {
        if (v368[1] == 99)
        {
          *(_QWORD *)this = v368 + 2;
          return 105;
        }
        goto LABEL_1914;
      }
      if (v369 != 117 && v369 != 115
        || v368[1] != 48
        || v368[2] != 120
        || (v370 = (char *)(v368 + 3), (*(_DWORD *)(v6 + 4 * v368[3] + 60) & 0x10000) == 0))
      {
LABEL_1914:
        *(_QWORD *)this = v368 + 1;
        return 1;
      }
      v371 = (_DWORD)v2 - (_DWORD)v368 - 3;
      if (v371)
      {
        v372 = v371;
        v373 = v370;
        while ((*v373 & 0x80000000) == 0 && (*(_DWORD *)(v6 + 4 * *v373 + 60) & 0x10000) != 0)
        {
          ++v373;
          if (!--v372)
            goto LABEL_1681;
        }
        *(_QWORD *)this = v370;
        return 1;
      }
LABEL_1681:
      v374 = 4 * v371;
      llvm::APInt::APInt((uint64_t)&v447, (4 * v371), v370, v371, 0x10u);
      v375 = v448;
      if (v448 > 0x40)
        v376 = llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v447);
      else
        v376 = v448 + __clz((unint64_t)v447) - 64;
      v424 = v375 - v376;
      if (v375 != v376 && v424 < v374)
      {
        llvm::APInt::trunc((llvm::APInt *)&v447, v424, (llvm::APInt *)&v445);
        if (v448 >= 0x41 && v447)
          MEMORY[0x1CAA32F9C](v447, 0x1000C8000313F17);
        v447 = v445;
        v375 = v446;
        v448 = v446;
      }
      v444 = v375;
      if (v375 > 0x40)
      {
        llvm::APInt::initSlowCase((llvm::APInt *)&v443, (const void **)&v447);
        v375 = v444;
        v425 = v443;
      }
      else
      {
        v425 = v447;
        v443 = v447;
      }
      v426 = **((_BYTE **)this + 6) == 117;
      v444 = 0;
      if (*((_DWORD *)this + 36) > 0x40u && (v427 = *((_QWORD *)this + 17)) != 0)
      {
        MEMORY[0x1CAA32F9C](v427, 0x1000C8000313F17);
        v428 = v444;
        *((_QWORD *)this + 17) = v425;
        *((_DWORD *)this + 36) = v375;
        *((_BYTE *)this + 148) = v426;
        if (v428 >= 0x41 && v443)
          MEMORY[0x1CAA32F9C](v443, 0x1000C8000313F17);
      }
      else
      {
        *((_QWORD *)this + 17) = v425;
        *((_DWORD *)this + 36) = v375;
        *((_BYTE *)this + 148) = v426;
      }
      if (v448 >= 0x41 && v447)
        MEMORY[0x1CAA32F9C](v447, 0x1000C8000313F17);
      return 457;
    case 0xFuLL:
      if (*(_QWORD *)v4 == 0x656572705F6F7364 && *(_QWORD *)(v4 + 7) == 0x656C626174706D65)
        return 26;
      if (*(_QWORD *)v4 == 0x74696E696F72657ALL && *(_QWORD *)(v4 + 7) == 0x72657A696C616974)
        return 50;
      if (*(_QWORD *)v4 == 0x665F656372756F73 && *(_QWORD *)(v4 + 7) == 0x656D616E656C6966)
        return 64;
      if (*(_QWORD *)v4 == 0x5F64726175676663 && *(_QWORD *)(v4 + 7) == 0x63636B636568635FLL)
        return 110;
      if (*(_QWORD *)v4 == 0x637061615F6D7261 && *(_QWORD *)(v4 + 7) == 0x63637066765F7363)
        return 118;
      if (*(_QWORD *)v4 == 0x6576726573657270 && *(_QWORD *)(v4 + 7) == 0x636374736F6D5F65)
        return 144;
      if (*(_QWORD *)v4 == 0x6572656665726564 && *(_QWORD *)(v4 + 7) == 0x656C626165636E65)
        return 175;
      if (*(_QWORD *)v4 == 0x63696C706D696F6ELL && *(_QWORD *)(v4 + 7) == 0x74616F6C66746963)
        return 194;
      if (*(_QWORD *)v4 != 0x6163776F64616873 || *(_QWORD *)(v4 + 7) != 0x6B636174736C6C61)
      {
        v38 = 0;
        v37 = 0;
        v36 = 0;
        v46 = 0;
        v34 = 0;
        v33 = 0;
        v32 = 0;
        v31 = 0;
        v30 = 0;
        v27 = 0;
        v26 = 0;
        v25 = 0;
        v24 = 0;
        v23 = 0;
        v22 = 0;
        v21 = 0;
        v63 = 1;
        goto LABEL_122;
      }
      return 223;
    case 0x10uLL:
      if (*(_QWORD *)v4 == 0x746365765F363878 && *(_QWORD *)(v4 + 8) == 0x63636C6C6163726FLL)
        return 114;
      if (*(_QWORD *)v4 != 0x65746E695F726961 || *(_QWORD *)(v4 + 8) != 0x6E6F697463657372)
      {
        v23 = 0;
        v44 = 0;
        v45 = 0;
        v47 = 0;
        v48 = 0;
        v49 = 0;
        v46 = 1;
        goto LABEL_598;
      }
      return 161;
    case 0x12uLL:
      if (*(_QWORD *)v4 == 0x6E755F6C61636F6CLL
        && *(_QWORD *)(v4 + 8) == 0x64615F64656D616ELL
        && *(_WORD *)(v4 + 16) == 29284)
      {
        return 42;
      }
      if (*(_QWORD *)v4 == 0x5F34366863726161
        && *(_QWORD *)(v4 + 8) == 0x705F726F74636576
        && *(_WORD *)(v4 + 16) == 29539)
      {
        return 119;
      }
      if (*(_QWORD *)v4 != 0x657A6974696E6173
        || *(_QWORD *)(v4 + 8) != 0x657264646177685FLL
        || *(_WORD *)(v4 + 16) != 29555)
      {
        v38 = 0;
        v37 = 0;
        v36 = 0;
        v35 = 0;
        v34 = 0;
        v33 = 0;
        v32 = 0;
        v31 = 0;
        v30 = 0;
        v63 = 0;
        v27 = 0;
        v26 = 0;
        v25 = 0;
        v24 = 0;
        v23 = 0;
        v22 = 0;
        v21 = 0;
        v28 = 1;
        goto LABEL_627;
      }
      return 168;
    case 0x14uLL:
      if (*(_QWORD *)v4 == 0x6C62616C69617661
        && *(_QWORD *)(v4 + 8) == 0x6E72657478655F65
        && *(_DWORD *)(v4 + 16) == 2037148769)
      {
        return 37;
      }
      if (*(_QWORD *)v4 == 0x61636F6C5F6F7364
        && *(_QWORD *)(v4 + 8) == 0x6176697571655F6CLL
        && *(_DWORD *)(v4 + 16) == 1953391980)
      {
        return 345;
      }
      if (*(_QWORD *)v4 != 0x7473655465707974
        || *(_QWORD *)(v4 + 8) != 0x4356656D75737341
        || *(_DWORD *)(v4 + 16) != 1936485473)
      {
        v217 = 0;
        v43 = 0;
        v33 = 0;
        v21 = 0;
        v24 = 0;
        goto LABEL_1166;
      }
      return 394;
    case 0x16uLL:
      if (*(_QWORD *)v4 == 0x6C616E7265747865
        && *(_QWORD *)(v4 + 8) == 0x6974696E695F796CLL
        && *(_QWORD *)(v4 + 14) == 0x64657A696C616974)
      {
        return 43;
      }
      if (*(_QWORD *)v4 == 0x5F34366863726161
        && *(_QWORD *)(v4 + 8) == 0x746365765F657673
        && *(_QWORD *)(v4 + 14) == 0x7363705F726F7463)
      {
        return 120;
      }
      if (*(_QWORD *)v4 != 0x6F43646965707974
        || *(_QWORD *)(v4 + 8) != 0x656C62697461706DLL
        || *(_QWORD *)(v4 + 14) != 0x656C62615456656CLL)
      {
        v37 = 0;
        v36 = 0;
        v35 = 0;
        v43 = 0;
        v199 = 0;
        v33 = 0;
        v200 = 0;
        v201 = 0;
        v30 = 0;
        v202 = 0;
        v203 = 0;
        v24 = 0;
        v23 = 0;
        v21 = 0;
        goto LABEL_721;
      }
      return 402;
    default:
      v47 = 0;
      v46 = 0;
      v50 = 0;
      v44 = 0;
      v51 = 0;
      LODWORD(v28) = 0;
      v52 = 0;
      v53 = 0;
      v45 = 0;
      goto LABEL_1212;
  }
}

uint64_t llvm::LLLexer::LexPositive(llvm::LLLexer *this)
{
  uint64_t v1;
  unsigned __int8 *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned __int8 *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned int v11;
  _BYTE v12[8];
  uint64_t v13[4];

  v13[3] = *MEMORY[0x1E0C80C00];
  v1 = MEMORY[0x1E0C80978];
  if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * **(unsigned __int8 **)this + 60) & 0x400) == 0)
    return 1;
  v4 = (unsigned __int8 *)(*(_QWORD *)this + 1);
  do
  {
    *(_QWORD *)this = v4;
    v6 = *v4++;
    v5 = v6;
  }
  while ((*(_DWORD *)(v1 + 4 * v6 + 60) & 0x400) != 0);
  if (v5 != 46)
  {
    *(_QWORD *)this = *((_QWORD *)this + 6) + 1;
    return 1;
  }
  v7 = v4 + 1;
  do
  {
    *(_QWORD *)this = v7 - 1;
    v8 = *(v7++ - 1);
  }
  while ((*(_DWORD *)(v1 + 4 * v8 + 60) & 0x400) != 0);
  v9 = v7 - 2;
  if ((v8 | 0x20) == 0x65)
  {
    v10 = *(v7 - 1);
    if ((*(_DWORD *)(v1 + 4 * v10 + 60) & 0x400) != 0
      || ((_DWORD)v10 == 43 || (_DWORD)v10 == 45) && (*(_DWORD *)(v1 + 4 * *v7 + 60) & 0x400) != 0)
    {
      do
      {
        *(_QWORD *)this = v7;
        v11 = *v7++;
      }
      while ((*(_DWORD *)(v1 + 4 * v11 + 60) & 0x400) != 0);
      v9 = v7 - 1;
    }
  }
  llvm::APFloat::APFloat((uint64_t)v12, &unk_1C866F198, *((unsigned __int8 **)this + 6), (unint64_t)&v9[-*((_QWORD *)this + 6)]);
  sub_1C48552C0((uint64_t)this + 112, (uint64_t)v13);
  sub_1C47A8258(v13);
  return 456;
}

uint64_t llvm::LLLexer::LexExclaim(llvm::LLLexer *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  char *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t v14;

  v2 = **(char **)this;
  v3 = **(unsigned __int8 **)this;
  v4 = MEMORY[0x1E0C80978];
  if (v2 < 0)
    v5 = __maskrune(v3, 0x100uLL);
  else
    v5 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x100;
  if (!v5)
  {
    v6 = **(unsigned __int8 **)this - 36;
    v7 = v6 > 0x3B;
    v8 = (1 << v6) & 0x900000000000601;
    if (v7 || v8 == 0)
      return 14;
  }
  while (1)
  {
    v10 = (char *)(*(_QWORD *)this + 1);
    *(_QWORD *)this = v10;
    v11 = *v10;
    if (*v10 < 0)
      v12 = __maskrune(v11, 0x500uLL);
    else
      v12 = *(_DWORD *)(v4 + 4 * v11 + 60) & 0x500;
    if (!v12)
    {
      v13 = **(unsigned __int8 **)this - 36;
      v7 = v13 > 0x3B;
      v14 = (1 << v13) & 0x900000000000601;
      if (v7 || v14 == 0)
        break;
    }
  }
  sub_1C4FAD170((std::string *)((char *)this + 64), (std::string::value_type *)(*((_QWORD *)this + 6) + 1), *(std::string::value_type **)this, *(_QWORD *)this - (*((_QWORD *)this + 6) + 1));
  sub_1C4FAC798((std::string *)((char *)this + 64));
  return 441;
}

uint64_t llvm::LLLexer::ReadVarName(llvm::LLLexer *this)
{
  std::string::value_type *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  char *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;

  v2 = *(std::string::value_type **)this;
  v3 = **(char **)this;
  v4 = **(unsigned __int8 **)this;
  v5 = MEMORY[0x1E0C80978];
  if (v3 < 0)
    v6 = __maskrune(v4, 0x100uLL);
  else
    v6 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x100;
  if (!v6)
  {
    v7 = **(unsigned __int8 **)this - 36;
    v8 = v7 > 0x3B;
    v9 = (1 << v7) & 0x800000000000601;
    if (v8 || v9 == 0)
      return 0;
  }
  while (1)
  {
    v11 = (char *)(*(_QWORD *)this + 1);
    *(_QWORD *)this = v11;
    v12 = *v11;
    if (*v11 < 0)
      v13 = __maskrune(v12, 0x500uLL);
    else
      v13 = *(_DWORD *)(v5 + 4 * v12 + 60) & 0x500;
    if (!v13)
    {
      v14 = **(unsigned __int8 **)this - 36;
      v8 = v14 > 0x3B;
      v15 = (1 << v14) & 0x800000000000601;
      if (v8 || v15 == 0)
        break;
    }
  }
  sub_1C4FAD170((std::string *)((char *)this + 64), v2, *(std::string::value_type **)this, *(_QWORD *)this - (_QWORD)v2);
  return 1;
}

uint64_t llvm::LLLexer::ReadString(uint64_t a1, uint64_t a2)
{
  std::string::size_type v3;
  std::string::value_type *v4;
  std::string *v5;
  const char *v7;
  __int16 v8;

  v3 = 0;
  v4 = *(std::string::value_type **)a1;
  while (1)
  {
    *(_QWORD *)a1 = &v4[v3 + 1];
    if (!v4[v3])
      break;
    if (v4[v3] == 34)
    {
      v5 = (std::string *)(a1 + 64);
      sub_1C4FAD170((std::string *)(a1 + 64), v4, &v4[v3], v3);
      sub_1C4FAC798(v5);
      return a2;
    }
LABEL_6:
    ++v3;
  }
  if (&v4[v3] != (std::string::value_type *)(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16)))
    goto LABEL_6;
  *(_QWORD *)a1 = &v4[v3];
  v7 = "end of file in string constant";
  v8 = 259;
  sub_1C4FAB818(a1, (llvm::Twine *)&v7);
  return 1;
}

uint64_t llvm::LLLexer::LexUIntID(unsigned __int8 **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 *v5;
  unsigned int v6;
  unint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  BOOL v11;
  _QWORD v13[4];
  __int16 v14;

  v2 = MEMORY[0x1E0C80978];
  if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * **a1 + 60) & 0x400) == 0)
    return 1;
  v3 = a2;
  v5 = *a1 + 1;
  do
  {
    *a1 = v5;
    v6 = *v5++;
  }
  while ((*(_DWORD *)(v2 + 4 * v6 + 60) & 0x400) != 0);
  v7 = 0;
  v8 = a1[6];
  v9 = v5 - 2;
  while (v9 != v8)
  {
    v10 = (char)*++v8;
    v11 = v10 + 10 * v7 - 48 >= v7;
    v7 = v10 + 10 * v7 - 48;
    if (!v11)
    {
      v13[0] = "constant bigger than 64 bits detected!";
      v14 = 259;
      sub_1C4FAB818((uint64_t)a1, (llvm::Twine *)v13);
      LODWORD(v7) = 0;
      goto LABEL_9;
    }
  }
  if (HIDWORD(v7))
  {
    v13[0] = "invalid value number (too large)!";
    v14 = 259;
    sub_1C4FAB818((uint64_t)a1, (llvm::Twine *)v13);
  }
LABEL_9:
  *((_DWORD *)a1 + 22) = v7;
  return v3;
}

void sub_1C61C5314(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 40, &v5);
  sub_1C4FAD00C((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

uint64_t llvm::LLParser::parseTargetDefinitions(llvm::LLParser *this)
{
  int v2;

  while (1)
  {
    while (1)
    {
      v2 = *((_DWORD *)this + 56);
      if (v2 != 62)
        break;
      if ((llvm::LLParser::parseTargetDefinition(this) & 1) != 0)
        return 1;
    }
    if (v2 != 64)
      break;
    if (llvm::LLParser::parseSourceFileName(this))
      return 1;
  }
  return 0;
}

uint64_t llvm::LLParser::parseTopLevelEntities(llvm::LLParser *this)
{
  int v2;
  int v3;
  const char *v5;
  __int16 v6;

  if (*((_QWORD *)this + 41))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            v2 = *((_DWORD *)this + 56);
            if (v2 <= 348)
              break;
            switch(v2)
            {
              case 433:
                if ((llvm::LLParser::parseUnnamedGlobal(this) & 1) != 0)
                  return 1;
                continue;
              case 434:
                if ((llvm::LLParser::parseUnnamedType(this) & 1) != 0)
                  return 1;
                continue;
              case 435:
              case 437:
                goto LABEL_51;
              case 436:
                if ((llvm::LLParser::parseSummaryEntry(this) & 1) != 0)
                  return 1;
                continue;
              case 438:
                if ((llvm::LLParser::parseNamedGlobal(this) & 1) != 0)
                  return 1;
                continue;
              case 439:
                if ((llvm::LLParser::parseComdat(this) & 1) != 0)
                  return 1;
                continue;
              case 440:
                if ((llvm::LLParser::parseNamedType(this) & 1) != 0)
                  return 1;
                continue;
              case 441:
                if ((llvm::LLParser::parseNamedMetadata(this) & 1) != 0)
                  return 1;
                continue;
              default:
                if (v2 == 350)
                {
                  if (llvm::LLParser::parseUseListOrderBB(this))
                    return 1;
                }
                else
                {
                  if (v2 != 349)
                    goto LABEL_51;
                  if ((llvm::LLParser::parseUseListOrder(this, 0) & 1) != 0)
                    return 1;
                }
                break;
            }
          }
          if (v2 <= 21)
            break;
          switch(v2)
          {
            case 96:
              if ((llvm::LLParser::parseModuleAsm(this) & 1) != 0)
                return 1;
              break;
            case 22:
              if ((llvm::LLParser::parseDefine(this) & 1) != 0)
                return 1;
              break;
            case 162:
              if ((llvm::LLParser::parseUnnamedAttrGrp(this) & 1) != 0)
                return 1;
              break;
            default:
              goto LABEL_51;
          }
        }
        if (v2 != 14)
          break;
        if ((llvm::LLParser::parseStandaloneMetadata(this) & 1) != 0)
          return 1;
      }
      if (v2 != 21)
        break;
      if ((llvm::LLParser::parseDeclare(this) & 1) != 0)
        return 1;
    }
    if (v2)
    {
LABEL_51:
      v5 = "expected top-level entity";
      v6 = 259;
      return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v5);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    do
    {
      while (1)
      {
        while (1)
        {
          v3 = *((_DWORD *)this + 56);
          if (v3 != 64)
            break;
          if ((llvm::LLParser::parseSourceFileName(this) & 1) != 0)
            return 1;
        }
        if (v3 == 436)
          break;
        if (!v3)
          return 0;
        *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      }
    }
    while ((llvm::LLParser::parseSummaryEntry(this) & 1) == 0);
    return 1;
  }
}

uint64_t llvm::LLParser::validateEndOfIndex(llvm::LLParser *this)
{
  uint64_t v3;
  char *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  const char *v11;
  __int16 v12;
  uint64_t v13[5];
  _BYTE v14[40];

  if (!*((_QWORD *)this + 42))
    return 0;
  if (*((_QWORD *)this + 147))
  {
    v3 = *((_QWORD *)this + 145);
LABEL_9:
    v4 = *(char **)(*(_QWORD *)(v3 + 40) + 8);
    v5 = "use of undefined summary '^";
LABEL_10:
    v11 = v5;
    v12 = 259;
    v6 = *(_DWORD *)(v3 + 32);
    v10 = 264;
    LODWORD(v9[0]) = v6;
    sub_1C4825FE4((uint64_t *)&v11, v9, (uint64_t)v13);
    v7 = "'";
    v8 = 259;
    sub_1C4825FE4(v13, (uint64_t *)&v7, (uint64_t)v14);
    return llvm::LLLexer::Error((uint64_t)this + 168, v4, (llvm::Twine *)v14);
  }
  if (*((_QWORD *)this + 150))
  {
    v3 = *((_QWORD *)this + 148);
    goto LABEL_9;
  }
  if (*((_QWORD *)this + 156))
  {
    v3 = *((_QWORD *)this + 154);
    v4 = *(char **)(*(_QWORD *)(v3 + 40) + 8);
    v5 = "use of undefined type id summary '^";
    goto LABEL_10;
  }
  return 0;
}

uint64_t llvm::LLParser::parseStandaloneConstantValue(uint64_t a1, llvm::Value ***a2, char **a3)
{
  char *v6;
  llvm::Type *v7;
  _QWORD v8[4];
  __int16 v9;

  llvm::LLParser::restoreParsingState(a1, a3);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  v7 = 0;
  v8[0] = "expected type";
  v9 = 259;
  if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v7, (const llvm::Twine *)v8, 0) & 1) != 0
    || (llvm::LLParser::parseConstantValue((llvm::LLParser *)a1, v7, a2) & 1) != 0)
  {
    return 1;
  }
  if (!*(_DWORD *)(a1 + 224))
    return 0;
  v6 = *(char **)(a1 + 216);
  v8[0] = "expected end of string";
  v9 = 259;
  return llvm::LLLexer::Error(a1 + 168, v6, (llvm::Twine *)v8);
}

uint64_t llvm::LLParser::parseConstantValue(llvm::LLParser *this, llvm::Type *a2, llvm::Value ***a3)
{
  uint64_t v6;
  char *v7;
  llvm::Type *v8;
  llvm::Constant *v10;
  __int16 v11;
  unsigned int v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char v20;
  _QWORD v21[6];
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  *a3 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0;
  v18 = 0;
  v6 = 1;
  v19 = 1;
  v20 = 0;
  sub_1C47BC1BC((uint64_t)v21, 0.0);
  v21[5] = 0;
  v22 = 0;
  v7 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseValID((uint64_t **)this, (uint64_t)&v12, 0, 0) & 1) != 0)
    goto LABEL_2;
  if (v12 > 0xF)
  {
LABEL_9:
    v10 = (llvm::Constant *)"expected a constant value";
    v11 = 259;
    v6 = llvm::LLLexer::Error((uint64_t)this + 168, v7, (llvm::Twine *)&v10);
    goto LABEL_2;
  }
  if (((1 << v12) & 0xD0B0) == 0)
  {
    if (v12 == 6)
    {
      v6 = 0;
      *a3 = llvm::Constant::getNullValue(a2, v8);
      goto LABEL_2;
    }
    goto LABEL_9;
  }
  v10 = 0;
  v6 = llvm::LLParser::convertValIDToValue((uint64_t)this, (uint64_t)a2, (uint64_t)&v12);
  if ((v6 & 1) == 0)
    *a3 = (llvm::Value **)v10;
LABEL_2:
  sub_1C4FCD54C((uint64_t)&v12);
  return v6;
}

uint64_t llvm::LLParser::parseSourceFileName(llvm::LLParser *this)
{
  uint64_t result;
  char v3;
  int v4;
  char *v5;
  size_t v6;
  size_t v7;

  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after source_filename") & 1) != 0
    || (llvm::LLParser::parseStringConstant((uint64_t)this, (std::string *)((char *)this + 1288)) & 1) != 0)
  {
    return 1;
  }
  result = *((_QWORD *)this + 41);
  if (result)
  {
    v3 = *((_BYTE *)this + 1311);
    v4 = v3;
    if (v3 >= 0)
      v5 = (char *)this + 1288;
    else
      v5 = (char *)*((_QWORD *)this + 161);
    v6 = v3 & 0x7F;
    if (v4 >= 0)
      v7 = v6;
    else
      v7 = *((_QWORD *)this + 162);
    LLVMSetSourceFileName_0(result, v5, v7);
    return 0;
  }
  return result;
}

uint64_t llvm::LLParser::parseSummaryEntry(llvm::LLParser *this)
{
  char *v2;
  unsigned int v3;
  uint64_t v4;
  int v6;
  uint64_t v7;
  char *v8;
  const char *v9;
  __int16 v10;

  v2 = (char *)this + 168;
  v3 = *((_DWORD *)this + 64);
  v4 = 1;
  *((_BYTE *)this + 320) = 1;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' here") & 1) != 0)
    return v4;
  if (*((_QWORD *)this + 42))
  {
    v6 = *((_DWORD *)this + 56);
    if (v6 > 357)
    {
      switch(v6)
      {
        case 401:
          v7 = llvm::LLParser::parseTypeIdEntry(this, v3);
          goto LABEL_13;
        case 402:
          v7 = llvm::LLParser::parseTypeIdCompatibleVtableEntry(this, v3);
          goto LABEL_13;
        case 358:
          v7 = llvm::LLParser::parseBlockCount(this);
          goto LABEL_13;
      }
    }
    else
    {
      switch(v6)
      {
        case 96:
          v7 = llvm::LLParser::parseModuleEntry(this, v3);
          goto LABEL_13;
        case 353:
          v7 = llvm::LLParser::parseGVEntry(this, v3);
LABEL_13:
          v4 = v7;
          *((_BYTE *)this + 320) = 0;
          return v4;
        case 357:
          v7 = llvm::LLParser::parseSummaryIndexFlags(this);
          goto LABEL_13;
      }
    }
    v8 = (char *)*((_QWORD *)this + 27);
    v9 = "unexpected summary kind";
    v10 = 259;
    v7 = llvm::LLLexer::Error((uint64_t)v2, v8, (llvm::Twine *)&v9);
    goto LABEL_13;
  }
  return llvm::LLParser::skipModuleSummaryEntry(this);
}

uint64_t llvm::LLParser::parseDeclare(llvm::LLParser *this)
{
  int v2;
  _OWORD *v3;
  uint64_t v4;
  llvm::MDNode **v5;
  llvm::Value *v6;
  llvm::Function *v8[2];
  llvm::MDNode *v9;
  unsigned int v10;
  void *__p;
  _OWORD *v12;
  unint64_t v13;

  v2 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  v3 = 0;
  *((_DWORD *)this + 56) = v2;
  __p = 0;
  v12 = 0;
  v13 = 0;
  if (v2 == 441)
  {
    v3 = 0;
    while (1)
    {
      v10 = 0;
      v9 = 0;
      if ((llvm::LLParser::parseMetadataAttachment(this, &v10, &v9) & 1) != 0)
        break;
      LODWORD(v8[0]) = v10;
      v8[1] = v9;
      if ((unint64_t)v3 >= v13)
        v3 = sub_1C4E3D7FC(&__p, v8);
      else
        *v3++ = *(_OWORD *)v8;
      v12 = v3;
      if (*((_DWORD *)this + 56) != 441)
        goto LABEL_8;
    }
    v4 = 1;
  }
  else
  {
LABEL_8:
    v8[0] = 0;
    v4 = llvm::LLParser::parseFunctionHeader(this, v8, 0);
    if ((v4 & 1) == 0)
    {
      v5 = (llvm::MDNode **)__p;
      if (__p != v3)
      {
        v6 = v8[0];
        do
        {
          llvm::Value::addMetadata(v6, *(_DWORD *)v5, v5[1]);
          v5 += 2;
        }
        while (v5 != (llvm::MDNode **)v3);
      }
    }
  }
  if (__p)
    operator delete(__p);
  return v4;
}

uint64_t llvm::LLParser::parseDefine(llvm::LLParser *this)
{
  llvm::Function *v3;
  llvm::Function *v4;

  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  v4 = 0;
  if ((llvm::LLParser::parseFunctionHeader(this, &v4, 1) & 1) != 0)
    return 1;
  v3 = v4;
  while (*((_DWORD *)this + 56) == 441)
  {
    if ((llvm::LLParser::parseGlobalObjectMetadataAttachment(this, v3) & 1) != 0)
      return 1;
  }
  return llvm::LLParser::parseFunctionBody(this, v3);
}

uint64_t llvm::LLParser::parseUnnamedType(llvm::LLParser *this)
{
  char *v2;
  char *v3;
  unsigned int v4;
  uint64_t result;
  uint64_t **v6;
  uint64_t **v7;
  llvm::Type *v8;
  uint64_t **v9;
  uint64_t **v10;
  const char *v11;
  __int16 v12;
  llvm::Type *v13;
  unsigned int v14;

  v2 = (char *)this + 168;
  v3 = (char *)*((_QWORD *)this + 27);
  v4 = *((_DWORD *)this + 64);
  v14 = v4;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after name") & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 242, "expected 'type' after '='") & 1) != 0)
    return 1;
  v13 = 0;
  v6 = (uint64_t **)((char *)this + 912);
  v7 = sub_1C4FCE1E0((uint64_t **)this + 114, v4, &v14);
  if ((llvm::LLParser::parseStructDefinition(this, v3, "", 0, (unint64_t *)v7 + 5, &v13) & 1) != 0)
    return 1;
  v8 = v13;
  if (*((_BYTE *)v13 + 8) == 16)
    return 0;
  v9 = sub_1C4FCE1E0(v6, v4, &v14);
  if (v9[5])
  {
    v11 = "non-struct types may not be recursive";
    v12 = 259;
    return llvm::LLLexer::Error((uint64_t)v2, v3, (llvm::Twine *)&v11);
  }
  else
  {
    v10 = v9;
    result = 0;
    v10[5] = (uint64_t *)v8;
    v10[6] = 0;
  }
  return result;
}

uint64_t llvm::LLParser::parseUnnamedAttrGrp(llvm::LLParser *this)
{
  llvm::LLLexer *v2;
  char *v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t *v9;
  unsigned int v10;
  BOOL v11;
  uint64_t *v12;
  char *v13;
  void *__p[3];
  const char *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = (llvm::LLParser *)((char *)this + 168);
  v3 = (char *)*((_QWORD *)this + 27);
  v4 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v4;
  if (v4 == 435)
  {
    v5 = *((_DWORD *)this + 64);
    memset(__p, 0, sizeof(__p));
    v13 = 0;
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
    if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' here") & 1) != 0
      || (llvm::LLParser::parseToken((uint64_t)this, 8, "expected '{' here") & 1) != 0)
    {
      v6 = 1;
    }
    else
    {
      v8 = *((_QWORD *)this + 143);
      if (!v8)
        goto LABEL_20;
      v9 = (uint64_t *)((char *)this + 1144);
      do
      {
        v10 = *(_DWORD *)(v8 + 32);
        v11 = v10 >= v5;
        if (v10 >= v5)
          v12 = (uint64_t *)v8;
        else
          v12 = (uint64_t *)(v8 + 8);
        if (v11)
          v9 = (uint64_t *)v8;
        v8 = *v12;
      }
      while (*v12);
      if (v9 == (uint64_t *)((char *)this + 1144) || v5 < *((_DWORD *)v9 + 8))
      {
LABEL_20:
        v15 = (const char *)**((_QWORD **)this + 41);
        v16 = &v18;
        v17 = 0x800000000;
        v9 = sub_1C4FCE65C((uint64_t)this + 1136, v5, v5, (uint64_t)&v15);
        if (v16 != &v18)
          free(v16);
      }
      v6 = 1;
      if ((llvm::LLParser::parseFnAttributeValuePairs((uint64_t)this, (uint64_t)(v9 + 5), (uint64_t)__p, 1, &v13) & 1) == 0
        && (llvm::LLParser::parseToken((uint64_t)this, 9, "expected end of attribute group") & 1) == 0)
      {
        if (*((_DWORD *)v9 + 14))
        {
          v6 = 0;
        }
        else
        {
          v15 = "attribute group has no attributes";
          v19 = 259;
          v6 = llvm::LLLexer::Error((uint64_t)v2, v3, (llvm::Twine *)&v15);
        }
      }
    }
    if (__p[0])
      operator delete(__p[0]);
  }
  else
  {
    v15 = "expected attribute group id";
    v19 = 259;
    return llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)&v15);
  }
  return v6;
}

uint64_t llvm::LLParser::parseUseListOrder(llvm::LLParser *this, llvm::LLParser::PerFunctionState *a2)
{
  char *v4;
  uint64_t v5;
  llvm::Value *v7;
  void *v8;
  uint64_t v9;
  _QWORD v10[9];

  v10[8] = *MEMORY[0x1E0C80C00];
  v4 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseToken((uint64_t)this, 349, "expected uselistorder directive") & 1) != 0)
    return 1;
  v7 = 0;
  v8 = v10;
  v9 = 0x1000000000;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v7, a2) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected comma in uselistorder directive") & 1) != 0
    || (llvm::LLParser::parseUseListOrderIndexes((uint64_t)this, (uint64_t)&v8) & 1) != 0)
  {
    v5 = 1;
  }
  else
  {
    v5 = llvm::LLParser::sortUseListOrder((uint64_t)this, (uint64_t)v7, (uint64_t)v8, v9, v4);
  }
  if (v8 != v10)
    free(v8);
  return v5;
}

uint64_t llvm::LLParser::parseToken(uint64_t a1, int a2, _BYTE *a3)
{
  llvm::LLLexer *v4;
  int v5;
  uint64_t result;
  char v7;
  _BYTE *v8;
  char v9;
  char v10;

  v4 = (llvm::LLLexer *)(a1 + 168);
  if (*(_DWORD *)(a1 + 224) == a2)
  {
    v5 = llvm::LLLexer::LexToken(v4);
    result = 0;
    *(_DWORD *)(a1 + 224) = v5;
  }
  else
  {
    v7 = 1;
    v10 = 1;
    if (*a3)
    {
      v8 = a3;
      v7 = 3;
    }
    v9 = v7;
    return llvm::LLLexer::Error((uint64_t)v4, *(char **)(a1 + 216), (llvm::Twine *)&v8);
  }
  return result;
}

uint64_t llvm::LLParser::parseStringConstant(uint64_t a1, std::string *this)
{
  llvm::LLLexer *v3;
  int v4;
  uint64_t result;
  const char *v6;
  __int16 v7;

  v3 = (llvm::LLLexer *)(a1 + 168);
  if (*(_DWORD *)(a1 + 224) == 442)
  {
    std::string::operator=(this, (const std::string *)(a1 + 232));
    v4 = llvm::LLLexer::LexToken(v3);
    result = 0;
    *(_DWORD *)(a1 + 224) = v4;
  }
  else
  {
    v6 = "expected string constant";
    v7 = 259;
    return llvm::LLLexer::Error(a1 + 168, *(char **)(a1 + 216), (llvm::Twine *)&v6);
  }
  return result;
}

uint64_t llvm::LLParser::parseFunctionBody(llvm::LLParser *this, llvm::Function *a2)
{
  llvm::LLLexer *v3;
  int v5;
  uint64_t v6;
  llvm::Type *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  const char *v12;
  __int16 v13;
  _QWORD v14[4];
  __int16 v15;

  v3 = (llvm::LLParser *)((char *)this + 168);
  if (*((_DWORD *)this + 56) == 8)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if ((*((_BYTE *)a2 + 23) & 0x10) != 0)
      v5 = -1;
    else
      v5 = ((*((_QWORD *)this + 130) - *((_QWORD *)this + 129)) >> 3) - 1;
    llvm::LLParser::PerFunctionState::PerFunctionState((llvm::LLParser::PerFunctionState *)v14, this, a2, v5);
    if ((llvm::LLParser::PerFunctionState::resolveForwardRefBlockAddresses((llvm::LLParser::PerFunctionState *)v14) & 1) != 0)
    {
      v6 = 1;
    }
    else
    {
      v8 = *((_QWORD *)this + 138);
      *((_QWORD *)this + 138) = v14;
      v9 = *((_DWORD *)this + 56);
      if (v9 == 9 || v9 == 349)
      {
        v12 = "function body requires at least one basic block";
        v13 = 259;
        v10 = llvm::LLLexer::Error((uint64_t)v3, *((char **)this + 27), (llvm::Twine *)&v12);
      }
      else
      {
        while (v9 != 349 && v9 != 9)
        {
          if ((llvm::LLParser::parseBasicBlock(this, (llvm::LLParser::PerFunctionState *)v14) & 1) != 0)
          {
LABEL_21:
            v6 = 1;
            goto LABEL_18;
          }
          v9 = *((_DWORD *)this + 56);
        }
        while (*((_DWORD *)this + 56) != 9)
        {
          if ((llvm::LLParser::parseUseListOrder(this, (llvm::LLParser::PerFunctionState *)v14) & 1) != 0)
            goto LABEL_21;
        }
        *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v3);
        v10 = llvm::LLParser::PerFunctionState::finishFunction((llvm::LLParser::PerFunctionState *)v14);
      }
      v6 = v10;
LABEL_18:
      *((_QWORD *)this + 138) = v8;
    }
    llvm::LLParser::PerFunctionState::~PerFunctionState((llvm::LLParser::PerFunctionState *)v14, v7);
  }
  else
  {
    v14[0] = "expected '{' in function body";
    v15 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)v14);
  }
  return v6;
}

uint64_t llvm::LLParser::parseGlobalType(llvm::LLParser *this, BOOL *a2)
{
  llvm::LLLexer *v3;
  int v4;
  BOOL v5;
  int v6;
  uint64_t result;
  const char *v8;
  __int16 v9;

  v3 = (llvm::LLParser *)((char *)this + 168);
  v4 = *((_DWORD *)this + 56);
  if (v4 == 23)
  {
    v5 = 0;
  }
  else
  {
    if (v4 != 24)
    {
      *a2 = 0;
      v8 = "expected 'global' or 'constant'";
      v9 = 259;
      return llvm::LLLexer::Error((uint64_t)v3, *((char **)this + 27), (llvm::Twine *)&v8);
    }
    v5 = 1;
  }
  *a2 = v5;
  v6 = llvm::LLLexer::LexToken(v3);
  result = 0;
  *((_DWORD *)this + 56) = v6;
  return result;
}

uint64_t llvm::LLParser::parseOptionalLinkage(llvm::LLParser *this, unsigned int *a2, BOOL *a3, unsigned int *a4, unsigned int *a5, BOOL *a6)
{
  llvm::LLLexer *v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t result;
  char *v16;
  const char *v17;
  __int16 v18;

  v11 = (llvm::LLParser *)((char *)this + 168);
  *a2 = sub_1C4FB8490(*((_DWORD *)this + 56), a3);
  if (*a3)
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v11);
  llvm::LLParser::parseOptionalDSOLocal(this, a6);
  v12 = *((_DWORD *)this + 56);
  if ((v12 - 38) >= 3)
  {
    *a4 = 0;
  }
  else
  {
    *a4 = v12 - 38;
    v12 = llvm::LLLexer::LexToken(v11);
    *((_DWORD *)this + 56) = v12;
  }
  if (v12 == 34)
  {
    v13 = 1;
  }
  else
  {
    if (v12 != 35)
    {
      result = 0;
      *a5 = 0;
      return result;
    }
    v13 = 2;
  }
  *a5 = v13;
  v14 = llvm::LLLexer::LexToken(v11);
  result = 0;
  *((_DWORD *)this + 56) = v14;
  if (*a6 && *a5 == 1)
  {
    v16 = (char *)*((_QWORD *)this + 27);
    v17 = "dso_location and DLL-StorageClass mismatch";
    v18 = 259;
    return llvm::LLLexer::Error((uint64_t)v11, v16, (llvm::Twine *)&v17);
  }
  return result;
}

uint64_t llvm::LLParser::parseOptionalThreadLocal(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int v5;

  result = 0;
  *a2 = 0;
  if (*(_DWORD *)(a1 + 224) == 46)
  {
    v5 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v5;
    *a2 = 1;
    if (v5 == 12)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      if ((llvm::LLParser::parseTLSModel(a1, a2) & 1) != 0)
        return 1;
      else
        return llvm::LLParser::parseToken(a1, 13, "expected ')' after thread local model");
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::LLParser::parseSpecializedMDNode(char **this, llvm::MDNode **a2, uint64_t a3)
{
  _QWORD *v6;
  const char *v8;
  __int16 v9;

  v6 = this + 29;
  if (sub_1C4FB2CFC(this + 29, "DILocation"))
    return llvm::LLParser::parseDILocation((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIExpression"))
    return llvm::LLParser::parseDIExpression((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIGlobalVariableExpression"))
    return llvm::LLParser::parseDIGlobalVariableExpression((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "GenericDINode"))
    return llvm::LLParser::parseGenericDINode((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DISubrange"))
    return llvm::LLParser::parseDISubrange((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIEnumerator"))
    return llvm::LLParser::parseDIEnumerator((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIBasicType"))
    return llvm::LLParser::parseDIBasicType((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIDerivedType"))
    return llvm::LLParser::parseDIDerivedType((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DICompositeType"))
    return llvm::LLParser::parseDICompositeType((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DISubroutineType"))
    return llvm::LLParser::parseDISubroutineType((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIFile"))
    return llvm::LLParser::parseDIFile((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DICompileUnit"))
    return llvm::LLParser::parseDICompileUnit((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DISubprogram"))
    return llvm::LLParser::parseDISubprogram((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DILexicalBlock"))
    return llvm::LLParser::parseDILexicalBlock((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DILexicalBlockFile"))
    return llvm::LLParser::parseDILexicalBlockFile((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DINamespace"))
    return llvm::LLParser::parseDINamespace((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIModule"))
    return llvm::LLParser::parseDIModule((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DITemplateTypeParameter"))
    return llvm::LLParser::parseDITemplateTypeParameter((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DITemplateValueParameter"))
    return llvm::LLParser::parseDITemplateValueParameter((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIGlobalVariable"))
    return llvm::LLParser::parseDIGlobalVariable((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DILocalVariable"))
    return llvm::LLParser::parseDILocalVariable((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DILabel"))
    return llvm::LLParser::parseDILabel((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIObjCProperty"))
    return llvm::LLParser::parseDIObjCProperty((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIImportedEntity"))
    return llvm::LLParser::parseDIImportedEntity((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIMacro"))
    return llvm::LLParser::parseDIMacro((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIMacroFile"))
    return llvm::LLParser::parseDIMacroFile((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DICommonBlock"))
    return llvm::LLParser::parseDICommonBlock((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIArgList"))
    return llvm::LLParser::parseDIArgList((llvm::LLParser *)this, a2, a3, 0);
  if (sub_1C4FB2CFC(v6, "DIStringType"))
    return llvm::LLParser::parseDIStringType((llvm::LLParser *)this, a2, a3);
  if (sub_1C4FB2CFC(v6, "DIGenericSubrange"))
    return llvm::LLParser::parseDIGenericSubrange((llvm::LLParser *)this, a2, a3);
  v8 = "expected metadata type";
  v9 = 259;
  return llvm::LLLexer::Error((uint64_t)(this + 21), this[27], (llvm::Twine *)&v8);
}

uint64_t llvm::LLParser::parseMDTuple(uint64_t **this, llvm::MDNode **a2, int a3)
{
  uint64_t v6;
  llvm::MDNode *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[17];

  v11[16] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x1000000000;
  v6 = llvm::LLParser::parseMDNodeVector(this, (uint64_t)&v9);
  if ((v6 & 1) == 0)
  {
    if (a3)
      v7 = (llvm::MDNode *)sub_1C61C8DC0(*this, v9, v10);
    else
      v7 = (llvm::MDNode *)sub_1C61C8DCC(*this, v9, v10);
    *a2 = v7;
  }
  if (v9 != v11)
    free(v9);
  return v6;
}

uint64_t llvm::LLParser::skipModuleSummaryEntry(llvm::LLParser *this)
{
  llvm::LLLexer *v2;
  int v3;
  uint64_t v4;
  const char *v6;
  int v7;
  int v8;
  const char *v9;
  __int16 v10;

  v2 = (llvm::LLParser *)((char *)this + 168);
  v3 = *((_DWORD *)this + 56);
  if (v3 <= 356)
  {
    if (v3 != 96 && v3 != 353)
      goto LABEL_13;
  }
  else
  {
    if (v3 == 357)
      return llvm::LLParser::parseSummaryIndexFlags(this);
    if (v3 == 358)
      return llvm::LLParser::parseBlockCount(this);
    if (v3 != 401)
    {
LABEL_13:
      v6 = "Expected 'gv', 'module', 'typeid', 'flags' or 'blockcount' at the start of summary entry";
      goto LABEL_14;
    }
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' at start of summary entry") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' at start of summary entry") & 1) != 0)
  {
    return 1;
  }
  v7 = *((_DWORD *)this + 56);
  v8 = 1;
  while (1)
  {
    if (v7 == 12)
    {
      ++v8;
      goto LABEL_23;
    }
    if (v7 == 13)
    {
      --v8;
      goto LABEL_23;
    }
    if (!v7)
      break;
LABEL_23:
    v7 = llvm::LLLexer::LexToken(v2);
    v4 = 0;
    *((_DWORD *)this + 56) = v7;
    if (!v8)
      return v4;
  }
  v6 = "found end of file while parsing summary entry";
LABEL_14:
  v9 = v6;
  v10 = 259;
  return llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)&v9);
}

uint64_t llvm::LLParser::parseSummaryIndexFlags(llvm::LLParser *this)
{
  uint64_t v2;
  _BYTE *v4;
  unint64_t v5;

  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0)
    return 1;
  v5 = 0;
  v2 = llvm::LLParser::parseUInt64((char **)this, &v5);
  if ((v2 & 1) == 0)
  {
    v4 = (_BYTE *)*((_QWORD *)this + 42);
    if (v4)
      llvm::ModuleSummaryIndex::setFlags(v4, v5);
  }
  return v2;
}

uint64_t llvm::LLParser::parseBlockCount(llvm::LLParser *this)
{
  uint64_t result;
  uint64_t v3;
  unint64_t v4;

  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0)
    return 1;
  v4 = 0;
  result = llvm::LLParser::parseUInt64((char **)this, &v4);
  if ((result & 1) == 0)
  {
    v3 = *((_QWORD *)this + 42);
    if (v3)
      *(_QWORD *)(v3 + 296) = v4;
  }
  return result;
}

uint64_t llvm::LLParser::parseGlobalTypeAndValue(llvm::LLParser *this, llvm::Constant **a2)
{
  llvm::Type *v5;
  const char *v6;
  __int16 v7;

  v5 = 0;
  v6 = "expected type";
  v7 = 259;
  if ((llvm::LLParser::parseType(this, &v5, (const llvm::Twine *)&v6, 0) & 1) != 0)
    return 1;
  else
    return llvm::LLParser::parseGlobalValue(this, v5, a2);
}

uint64_t llvm::LLParser::parseOptionalAddrSpace(llvm::LLParser *this, unsigned int *a2, unsigned int a3)
{
  *a2 = a3;
  if (*((_DWORD *)this + 56) != 91)
    return 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' in address space") & 1) != 0
    || (llvm::LLParser::parseUInt32(this, a2) & 1) != 0)
  {
    return 1;
  }
  else
  {
    return llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' in address space");
  }
}

uint64_t llvm::LLParser::parseOptionalAlignment(uint64_t a1, _WORD *a2, int a3)
{
  uint64_t result;
  int v7;
  char *v8;
  uint8x8_t v9;
  const char *v10;
  const char *v11;
  __int16 v12;
  unint64_t v13;

  result = 0;
  *a2 = 0;
  if (*(_DWORD *)(a1 + 224) == 90)
  {
    v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v7;
    v8 = *(char **)(a1 + 216);
    v13 = 0;
    if (a3 && v7 == 12)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      if ((llvm::LLParser::parseUInt64((char **)a1, &v13) & 1) == 0)
      {
        if (*(_DWORD *)(a1 + 224) != 13)
        {
          v10 = "expected ')'";
LABEL_14:
          v11 = v10;
          v12 = 259;
          return llvm::LLLexer::Error(a1 + 168, v8, (llvm::Twine *)&v11);
        }
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
LABEL_10:
        v9 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] == 1)
        {
          if (v13 < 0x100000001)
          {
            result = 0;
            *a2 = (63 - __clz(v13)) | 0x100;
            return result;
          }
          v10 = "huge alignments are not supported yet";
        }
        else
        {
          v10 = "alignment is not a power of two";
        }
        goto LABEL_14;
      }
    }
    else if ((llvm::LLParser::parseUInt64((char **)a1, &v13) & 1) == 0)
    {
      goto LABEL_10;
    }
    return 1;
  }
  return result;
}

uint64_t llvm::LLParser::parseGlobalObjectMetadataAttachment(llvm::LLParser *this, llvm::GlobalObject *a2)
{
  uint64_t v3;
  llvm::MDNode *v5;
  unsigned int v6;

  v6 = 0;
  v5 = 0;
  v3 = llvm::LLParser::parseMetadataAttachment(this, &v6, &v5);
  if ((v3 & 1) == 0)
    llvm::Value::addMetadata(a2, v6, v5);
  return v3;
}

uint64_t llvm::LLParser::parseRequiredTypeAttr(uint64_t a1, uint64_t **a2, int a3, int a4)
{
  llvm::LLLexer *v8;
  int v9;
  char *v10;
  const char *v11;
  llvm::Type *v12;
  _QWORD v13[4];
  __int16 v14;

  v12 = 0;
  if (*(_DWORD *)(a1 + 224) != a3)
    return 1;
  v8 = (llvm::LLLexer *)(a1 + 168);
  v9 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v9;
  if (v9 != 12)
  {
    v10 = *(char **)(a1 + 216);
    v11 = "expected '('";
LABEL_9:
    v13[0] = v11;
    v14 = 259;
    return llvm::LLLexer::Error((uint64_t)v8, v10, (llvm::Twine *)v13);
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v8);
  v13[0] = "expected type";
  v14 = 259;
  if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v12, (const llvm::Twine *)v13, 0) & 1) == 0)
  {
    if (*(_DWORD *)(a1 + 224) == 13)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v8);
      llvm::AttrBuilder::addTypeAttr(a2, a4, (uint64_t)v12);
      return 0;
    }
    v10 = *(char **)(a1 + 216);
    v11 = "expected ')'";
    goto LABEL_9;
  }
  return 1;
}

uint64_t llvm::LLParser::parseOptionalStackAlignment(llvm::LLParser *this, unsigned int *a2)
{
  uint64_t result;
  int v5;
  char *v6;
  uint8x8_t v7;
  char *v8;
  const char *v9;
  char *v10;
  const char *v11;
  __int16 v12;

  result = 0;
  *a2 = 0;
  if (*((_DWORD *)this + 56) == 99)
  {
    v5 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    *((_DWORD *)this + 56) = v5;
    if (v5 == 12)
    {
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      v6 = (char *)*((_QWORD *)this + 27);
      if ((llvm::LLParser::parseUInt32(this, a2) & 1) != 0)
        return 1;
      if (*((_DWORD *)this + 56) == 13)
      {
        *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
        v7 = (uint8x8_t)vcnt_s8((int8x8_t)*a2);
        v7.i16[0] = vaddlv_u8(v7);
        if (v7.i32[0] == 1)
          return 0;
        v11 = "stack alignment is not a power of two";
        v12 = 259;
        v10 = (char *)this + 168;
        v8 = v6;
        return llvm::LLLexer::Error((uint64_t)v10, v8, (llvm::Twine *)&v11);
      }
      v8 = (char *)*((_QWORD *)this + 27);
      v9 = "expected ')'";
    }
    else
    {
      v8 = (char *)*((_QWORD *)this + 27);
      v9 = "expected '('";
    }
    v11 = v9;
    v12 = 259;
    v10 = (char *)this + 168;
    return llvm::LLLexer::Error((uint64_t)v10, v8, (llvm::Twine *)&v11);
  }
  return result;
}

uint64_t llvm::LLParser::parseAllocSizeArguments(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  llvm::LLLexer *v6;
  int v7;
  uint64_t result;
  char *v9;
  unsigned int v10;
  int v11;
  char *v12;
  const char *v13;
  uint64_t v14;
  unsigned int v15;
  const char *v16;
  __int16 v17;

  v6 = (llvm::LLLexer *)(a1 + 168);
  v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v7;
  if (v7 != 12)
  {
    v12 = *(char **)(a1 + 216);
    v13 = "expected '('";
    goto LABEL_15;
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
  if ((llvm::LLParser::parseUInt32((llvm::LLParser *)a1, a2) & 1) == 0)
  {
    if (*(_DWORD *)(a1 + 224) == 4)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
      v9 = *(char **)(a1 + 216);
      v15 = 0;
      if ((llvm::LLParser::parseUInt32((llvm::LLParser *)a1, &v15) & 1) != 0)
        return 1;
      v10 = v15;
      if (v15 == *a2)
      {
        v16 = "'allocsize' indices can't refer to the same parameter";
        v17 = 259;
        v14 = (uint64_t)v6;
        v12 = v9;
        return llvm::LLLexer::Error(v14, v12, (llvm::Twine *)&v16);
      }
      if (!*(_BYTE *)(a3 + 4))
        *(_BYTE *)(a3 + 4) = 1;
      *(_DWORD *)a3 = v10;
    }
    else
    {
      *(_QWORD *)a3 = 0;
    }
    if (*(_DWORD *)(a1 + 224) == 13)
    {
      v11 = llvm::LLLexer::LexToken(v6);
      result = 0;
      *(_DWORD *)(a1 + 224) = v11;
      return result;
    }
    v12 = *(char **)(a1 + 216);
    v13 = "expected ')'";
LABEL_15:
    v16 = v13;
    v17 = 259;
    v14 = (uint64_t)v6;
    return llvm::LLLexer::Error(v14, v12, (llvm::Twine *)&v16);
  }
  return 1;
}

uint64_t llvm::LLParser::parseVScaleRangeArguments(llvm::LLParser *this, unsigned int *a2, unsigned int *a3)
{
  llvm::LLLexer *v6;
  int v7;
  uint64_t result;
  int v9;
  int v10;
  char *v11;
  const char *v12;
  const char *v13;
  __int16 v14;

  v6 = (llvm::LLParser *)((char *)this + 168);
  v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v7;
  if (v7 != 12)
  {
    v11 = (char *)*((_QWORD *)this + 27);
    v12 = "expected '('";
    goto LABEL_12;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
  if ((llvm::LLParser::parseUInt32(this, a2) & 1) == 0)
  {
    v9 = *((_DWORD *)this + 56);
    if (v9 == 4)
    {
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      if ((llvm::LLParser::parseUInt32(this, a3) & 1) != 0)
        return 1;
      v9 = *((_DWORD *)this + 56);
    }
    else
    {
      *a3 = *a2;
    }
    if (v9 == 13)
    {
      v10 = llvm::LLLexer::LexToken(v6);
      result = 0;
      *((_DWORD *)this + 56) = v10;
      return result;
    }
    v11 = (char *)*((_QWORD *)this + 27);
    v12 = "expected ')'";
LABEL_12:
    v13 = v12;
    v14 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v11, (llvm::Twine *)&v13);
  }
  return 1;
}

uint64_t llvm::LLParser::parseOptionalDerefAttrBytes(uint64_t a1, int a2, unint64_t *a3)
{
  llvm::LLLexer *v5;
  int v6;
  char *v7;
  char *v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;

  *a3 = 0;
  if (*(_DWORD *)(a1 + 224) != a2)
    return 0;
  v5 = (llvm::LLLexer *)(a1 + 168);
  v6 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v6;
  if (v6 != 12)
  {
    v9 = *(char **)(a1 + 216);
    v10 = "expected '('";
LABEL_10:
    v12 = v10;
    v13 = 259;
    v11 = (uint64_t)v5;
    return llvm::LLLexer::Error(v11, v9, (llvm::Twine *)&v12);
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v5);
  v7 = *(char **)(a1 + 216);
  if ((llvm::LLParser::parseUInt64((char **)a1, a3) & 1) != 0)
    return 1;
  if (*(_DWORD *)(a1 + 224) != 13)
  {
    v9 = *(char **)(a1 + 216);
    v10 = "expected ')'";
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v5);
  if (!*a3)
  {
    v12 = "dereferenceable bytes must be non-zero";
    v13 = 259;
    v11 = (uint64_t)v5;
    v9 = v7;
    return llvm::LLLexer::Error(v11, v9, (llvm::Twine *)&v12);
  }
  return 0;
}

uint64_t llvm::LLParser::parseOptionalUWTableKind(uint64_t a1, int *a2)
{
  llvm::LLLexer *v4;
  int v5;
  int v7;
  int v8;
  char *v9;
  const char *v10;
  __int16 v11;

  v4 = (llvm::LLLexer *)(a1 + 168);
  v5 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v5;
  *a2 = 2;
  if (v5 == 12)
  {
    v7 = llvm::LLLexer::LexToken(v4);
    *(_DWORD *)(a1 + 224) = v7;
    if (v7 == 240)
    {
      v8 = 1;
    }
    else
    {
      if (v7 != 241)
      {
        v9 = *(char **)(a1 + 216);
        v10 = "expected unwind table kind";
        v11 = 259;
        return llvm::LLLexer::Error((uint64_t)v4, v9, (llvm::Twine *)&v10);
      }
      v8 = 2;
    }
    *a2 = v8;
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
    return llvm::LLParser::parseToken(a1, 13, "expected ')'");
  }
  return 0;
}

uint64_t llvm::LLParser::getComdat(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  char v7;
  BOOL v8;
  unsigned __int8 *v9;
  size_t v10;
  size_t v11;
  int Key;
  size_t *inserted;
  uint64_t v15;

  v6 = *(_QWORD *)(a1 + 328);
  v7 = *(_BYTE *)(a2 + 23);
  v8 = v7 < 0;
  if (v7 >= 0)
    v9 = (unsigned __int8 *)a2;
  else
    v9 = *(unsigned __int8 **)a2;
  v10 = v7 & 0x7F;
  if (v8)
    v11 = *(_QWORD *)(a2 + 8);
  else
    v11 = v10;
  Key = llvm::StringMapImpl::FindKey((uint64_t *)(v6 + 120), v9, v11);
  if (Key != -1 && Key != (unint64_t)*(unsigned int *)(v6 + 128))
    return *(_QWORD *)(*(_QWORD *)(v6 + 120) + 8 * Key) + 8;
  inserted = llvm::Module::getOrInsertComdat(v6, v9, v11);
  v15 = a2;
  sub_1C61CE7A4(a1 + 1056, (const void **)a2, &v15)[7] = a3;
  return (uint64_t)inserted;
}

uint64_t llvm::LLParser::parseTLSModel(uint64_t a1, _DWORD *a2)
{
  llvm::LLLexer *v3;
  int v4;
  int v5;
  uint64_t result;
  const char *v7;
  __int16 v8;

  v3 = (llvm::LLLexer *)(a1 + 168);
  v4 = *(_DWORD *)(a1 + 224);
  if ((v4 - 47) >= 3)
  {
    v7 = "expected localdynamic, initialexec or localexec";
    v8 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, *(char **)(a1 + 216), (llvm::Twine *)&v7);
  }
  else
  {
    *a2 = v4 - 45;
    v5 = llvm::LLLexer::LexToken(v3);
    result = 0;
    *(_DWORD *)(a1 + 224) = v5;
  }
  return result;
}

llvm::LLLexer *llvm::LLParser::parseOptionalDSOLocal(llvm::LLParser *this, BOOL *a2)
{
  llvm::LLLexer *result;
  int v4;

  result = (llvm::LLParser *)((char *)this + 168);
  v4 = *((_DWORD *)this + 56);
  if (v4 == 25)
  {
    *a2 = 1;
    goto LABEL_5;
  }
  if (v4 == 26)
  {
    *a2 = 0;
LABEL_5:
    result = (llvm::LLLexer *)llvm::LLLexer::LexToken(result);
    *((_DWORD *)this + 56) = (_DWORD)result;
    return result;
  }
  *a2 = 0;
  return result;
}

uint64_t llvm::LLParser::parseOptionalCallingConv(llvm::LLParser *this, unsigned int *a2)
{
  int v3;
  unsigned int v5;
  llvm::LLLexer *v6;

  v3 = *((_DWORD *)this + 56) - 105;
  v5 = 0;
  v6 = (llvm::LLParser *)((char *)this + 168);
  switch(v3)
  {
    case 0:
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      return llvm::LLParser::parseUInt32(this, a2);
    case 1:
      goto LABEL_58;
    case 2:
      v5 = 8;
      goto LABEL_58;
    case 3:
      v5 = 9;
      goto LABEL_58;
    case 4:
      v5 = 77;
      goto LABEL_58;
    case 5:
      v5 = 19;
      goto LABEL_58;
    case 6:
      v5 = 64;
      goto LABEL_58;
    case 7:
      v5 = 65;
      goto LABEL_58;
    case 8:
      v5 = 70;
      goto LABEL_58;
    case 9:
      v5 = 80;
      goto LABEL_58;
    case 10:
      v5 = 92;
      goto LABEL_58;
    case 11:
      v5 = 66;
      goto LABEL_58;
    case 12:
      v5 = 67;
      goto LABEL_58;
    case 13:
      v5 = 68;
      goto LABEL_58;
    case 14:
      v5 = 97;
      goto LABEL_58;
    case 15:
      v5 = 98;
      goto LABEL_58;
    case 16:
      v5 = 69;
      goto LABEL_58;
    case 17:
      v5 = 84;
      goto LABEL_58;
    case 18:
      v5 = 85;
      goto LABEL_58;
    case 19:
      v5 = 71;
      goto LABEL_58;
    case 20:
      v5 = 72;
      goto LABEL_58;
    case 21:
      v5 = 76;
      goto LABEL_58;
    case 22:
      v5 = 75;
      goto LABEL_58;
    case 23:
      v5 = 100;
      goto LABEL_58;
    case 24:
      v5 = 101;
      goto LABEL_58;
    case 25:
      v5 = 102;
      goto LABEL_58;
    case 26:
      v5 = 103;
      goto LABEL_58;
    case 27:
      v5 = 104;
      goto LABEL_58;
    case 28:
      v5 = 105;
      goto LABEL_58;
    case 29:
      v5 = 106;
      goto LABEL_58;
    case 30:
      v5 = 107;
      goto LABEL_58;
    case 32:
      v5 = 108;
      goto LABEL_58;
    case 33:
      v5 = 78;
      goto LABEL_58;
    case 34:
      v5 = 79;
      goto LABEL_58;
    case 35:
      v5 = 12;
      goto LABEL_58;
    case 36:
      v5 = 13;
      goto LABEL_58;
    case 37:
      v5 = 16;
      goto LABEL_58;
    case 38:
      v5 = 20;
      goto LABEL_58;
    case 39:
      v5 = 14;
      goto LABEL_58;
    case 40:
      v5 = 15;
      goto LABEL_58;
    case 41:
      v5 = 10;
      goto LABEL_58;
    case 42:
      v5 = 83;
      goto LABEL_58;
    case 43:
      v5 = 81;
      goto LABEL_58;
    case 44:
      v5 = 82;
      goto LABEL_58;
    case 45:
      v5 = 17;
      goto LABEL_58;
    case 46:
      v5 = 87;
      goto LABEL_58;
    case 47:
      v5 = 95;
      goto LABEL_58;
    case 48:
      v5 = 93;
      goto LABEL_58;
    case 49:
      v5 = 96;
      goto LABEL_58;
    case 50:
      v5 = 88;
      goto LABEL_58;
    case 51:
      v5 = 89;
      goto LABEL_58;
    case 52:
      v5 = 90;
      goto LABEL_58;
    case 53:
      v5 = 91;
      goto LABEL_58;
    case 54:
      v5 = 109;
      goto LABEL_58;
    case 55:
      v5 = 18;
      goto LABEL_58;
    case 56:
      v5 = 255;
LABEL_58:
      *a2 = v5;
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      break;
    default:
      *a2 = 0;
      break;
  }
  return 0;
}

uint64_t llvm::LLParser::parseMDNode(char **this, llvm::MDNode **a2)
{
  if (*((_DWORD *)this + 56) == 441)
    return llvm::LLParser::parseSpecializedMDNode(this, a2, 0);
  if ((llvm::LLParser::parseToken((uint64_t)this, 14, "expected '!' here") & 1) != 0)
    return 1;
  return llvm::LLParser::parseMDNodeTail((llvm::LLParser *)this, a2);
}

uint64_t llvm::LLParser::parseOptionalCommaAlign(uint64_t a1, _WORD *a2, _BYTE *a3)
{
  llvm::LLLexer *v6;
  int v7;
  _BOOL8 v8;
  int v9;
  char *v11;
  const char *v12;
  __int16 v13;

  *a3 = 0;
  v6 = (llvm::LLLexer *)(a1 + 168);
  do
  {
    v7 = *(_DWORD *)(a1 + 224);
    v8 = v7 == 4;
    if (v7 != 4)
      break;
    v9 = llvm::LLLexer::LexToken(v6);
    *(_DWORD *)(a1 + 224) = v9;
    if (v9 != 90)
    {
      if (v9 == 441)
      {
        v8 = 0;
        *a3 = 1;
      }
      else
      {
        v11 = *(char **)(a1 + 216);
        v12 = "expected metadata or 'align'";
        v13 = 259;
        return llvm::LLLexer::Error((uint64_t)v6, v11, (llvm::Twine *)&v12);
      }
      return v8;
    }
  }
  while (!llvm::LLParser::parseOptionalAlignment(a1, a2, 0));
  return v8;
}

uint64_t llvm::LLParser::parseOptionalCommaAddrSpace(uint64_t a1, unsigned int *a2, _QWORD *a3, _BYTE *a4)
{
  llvm::LLLexer *v8;
  int v9;
  _BOOL8 v10;
  int v11;
  char *v13;
  const char *v14;
  __int16 v15;

  *a4 = 0;
  v8 = (llvm::LLLexer *)(a1 + 168);
  do
  {
    v9 = *(_DWORD *)(a1 + 224);
    v10 = v9 == 4;
    if (v9 != 4)
      break;
    v11 = llvm::LLLexer::LexToken(v8);
    *(_DWORD *)(a1 + 224) = v11;
    if (v11 == 441)
    {
      v10 = 0;
      *a4 = 1;
      return v10;
    }
    *a3 = *(_QWORD *)(a1 + 216);
    if (v11 != 91)
    {
      v13 = *(char **)(a1 + 216);
      v14 = "expected metadata or 'addrspace'";
      v15 = 259;
      return llvm::LLLexer::Error((uint64_t)v8, v13, (llvm::Twine *)&v14);
    }
  }
  while (!llvm::LLParser::parseOptionalAddrSpace((llvm::LLParser *)a1, a2, 0));
  return v10;
}

uint64_t llvm::LLParser::parseOrdering(uint64_t a1, _DWORD *a2)
{
  llvm::LLLexer *v3;
  int v4;
  int v5;
  uint64_t result;
  const char *v7;
  __int16 v8;

  v3 = (llvm::LLLexer *)(a1 + 168);
  v4 = *(_DWORD *)(a1 + 224) - 70;
  if (v4 >= 6)
  {
    v7 = "Expected ordering on atomic instruction";
    v8 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, *(char **)(a1 + 216), (llvm::Twine *)&v7);
  }
  else
  {
    *a2 = dword_1C85F7658[v4];
    v5 = llvm::LLLexer::LexToken(v3);
    result = 0;
    *(_DWORD *)(a1 + 224) = v5;
  }
  return result;
}

uint64_t llvm::LLParser::parseType(llvm::LLParser *this, llvm::Type **a2, const llvm::Twine *a3, char a4)
{
  llvm::LLLexer *v7;
  char *v8;
  int v9;
  int v10;
  uint64_t v11;
  llvm::LLVMContext *v12;
  uint64_t **v13;
  llvm::Type *v14;
  int v15;
  const char *v16;
  char *v17;
  uint64_t v18;
  int v20;
  char *v21;
  char v22;
  int v23;
  unsigned __int8 *v24;
  size_t v25;
  size_t v26;
  size_t **v27;
  size_t *v28;
  char v29;
  BOOL v30;
  unsigned __int8 *v31;
  size_t v32;
  size_t v33;
  llvm::Type *v34[4];
  __int16 v35;
  llvm::LLVMContext *v36;

  v7 = (llvm::LLParser *)((char *)this + 168);
  v8 = (char *)*((_QWORD *)this + 27);
  v9 = *((_DWORD *)this + 56);
  if (v9 <= 433)
  {
    if (v9 <= 61)
    {
      switch(v9)
      {
        case 6:
          *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
          if ((llvm::LLParser::parseArrayVectorType(this, a2, 0) & 1) == 0)
            goto LABEL_16;
          break;
        case 8:
          if ((llvm::LLParser::parseAnonStructType((uint64_t **)this, a2, 0) & 1) == 0)
            goto LABEL_16;
          break;
        case 10:
          v20 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
          *((_DWORD *)this + 56) = v20;
          v11 = 1;
          if (v20 != 8)
          {
            if ((llvm::LLParser::parseArrayVectorType(this, a2, 1) & 1) == 0)
              goto LABEL_16;
            return v11;
          }
          if ((llvm::LLParser::parseAnonStructType((uint64_t **)this, a2, 1) & 1) == 0
            && (llvm::LLParser::parseToken((uint64_t)this, 11, "expected '>' at end of packed struct") & 1) == 0)
          {
            while (1)
            {
              while (1)
              {
LABEL_16:
                while (1)
                {
                  v15 = *((_DWORD *)this + 56);
                  if (v15 != 5)
                    break;
                  switch(*((_BYTE *)*a2 + 8))
                  {
                    case 7:
                      v16 = "pointers to void are invalid - use i8* instead";
                      goto LABEL_25;
                    case 8:
                      goto LABEL_24;
                    case 9:
                    case 0xC:
                      goto LABEL_67;
                    default:
                      if (*((_BYTE *)*a2 + 8) == 11)
                        goto LABEL_67;
                      *a2 = (llvm::Type *)llvm::PointerType::get(*a2, 0);
                      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v7);
                      break;
                  }
                }
                if (v15 != 12)
                  break;
                if (llvm::LLParser::parseFunctionType((char **)this, a2))
                  return 1;
              }
              if (v15 != 91)
                break;
              switch(*((_BYTE *)*a2 + 8))
              {
                case 7:
                  v16 = "pointers to void are invalid; use i8* instead";
                  goto LABEL_25;
                case 8:
LABEL_24:
                  v16 = "basic block pointers are invalid";
                  goto LABEL_25;
                case 9:
                case 0xC:
                  goto LABEL_67;
                default:
                  if (*((_BYTE *)*a2 + 8) == 11)
                  {
LABEL_67:
                    v16 = "pointer to this type is invalid";
                    goto LABEL_25;
                  }
                  LODWORD(v34[0]) = 0;
                  if ((llvm::LLParser::parseOptionalAddrSpace(this, (unsigned int *)v34, 0) & 1) != 0
                    || (llvm::LLParser::parseToken((uint64_t)this, 5, "expected '*' in address space") & 1) != 0)
                  {
                    return 1;
                  }
                  *a2 = (llvm::Type *)llvm::PointerType::get(*a2, (llvm::Type *)LODWORD(v34[0]));
                  break;
              }
            }
            if ((a4 & 1) != 0 || *((_BYTE *)*a2 + 8) != 7)
              return 0;
            v34[0] = (llvm::Type *)"void type only allowed for function results";
            v35 = 259;
            v18 = (uint64_t)v7;
            v17 = v8;
            return llvm::LLLexer::Error(v18, v17, (llvm::Twine *)v34);
          }
          return v11;
        default:
          return llvm::LLLexer::Error((uint64_t)this + 168, v8, a3);
      }
    }
    else
    {
      if (v9 != 62)
        return llvm::LLLexer::Error((uint64_t)this + 168, v8, a3);
      if ((llvm::LLParser::parseTargetExtType(this, a2) & 1) == 0)
        goto LABEL_16;
    }
    return 1;
  }
  switch(v9)
  {
    case 434:
      LODWORD(v34[0]) = *((_DWORD *)this + 64);
      v13 = sub_1C4FCE1E0((uint64_t **)this + 114, v34[0], v34);
      v14 = (llvm::Type *)v13[5];
      if (!v14)
      {
        v14 = (llvm::Type *)llvm::StructType::create(*(llvm::StructType **)this, v12);
        v13[5] = (uint64_t *)v14;
        v13[6] = (uint64_t *)*((_QWORD *)this + 27);
      }
      goto LABEL_15;
    case 455:
      *a2 = (llvm::Type *)*((_QWORD *)this + 33);
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      if (!llvm::Type::isOpaquePointerTy(*a2))
        goto LABEL_16;
      LODWORD(v36) = 0;
      if ((llvm::LLParser::parseOptionalAddrSpace(this, (unsigned int *)&v36, 0) & 1) == 0)
      {
        *a2 = (llvm::Type *)llvm::PointerType::get(*(llvm::PointerType **)this, (llvm::LLVMContext *)v36);
        v10 = *((_DWORD *)this + 56);
        if (v10 != 5)
        {
          if (v10 == 12)
            goto LABEL_16;
          return 0;
        }
        v16 = "ptr* is invalid - use ptr instead";
LABEL_25:
        v34[0] = (llvm::Type *)v16;
        v35 = 259;
        v17 = (char *)*((_QWORD *)this + 27);
        v18 = (uint64_t)v7;
        return llvm::LLLexer::Error(v18, v17, (llvm::Twine *)v34);
      }
      return 1;
    case 440:
      v21 = (char *)this + 880;
      v22 = *((_BYTE *)this + 255);
      v23 = v22;
      if (v22 >= 0)
        v24 = (unsigned __int8 *)this + 232;
      else
        v24 = (unsigned __int8 *)*((_QWORD *)this + 29);
      v25 = v22 & 0x7F;
      if (v23 >= 0)
        v26 = v25;
      else
        v26 = *((_QWORD *)this + 30);
      v27 = sub_1C61CE4A4((uint64_t)v21, v24, v26);
      v28 = *v27;
      v14 = (llvm::Type *)(*v27)[1];
      if (!v14)
      {
        v29 = *((_BYTE *)this + 255);
        v30 = v29 < 0;
        if (v29 >= 0)
          v31 = (unsigned __int8 *)this + 232;
        else
          v31 = (unsigned __int8 *)*((_QWORD *)this + 29);
        v32 = v29 & 0x7F;
        if (v30)
          v33 = *((_QWORD *)this + 30);
        else
          v33 = v32;
        v14 = (llvm::Type *)llvm::StructType::create(*(_QWORD **)this, v31, v33);
        v28[1] = (size_t)v14;
        v28[2] = *((_QWORD *)this + 27);
      }
LABEL_15:
      *a2 = v14;
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v7);
      goto LABEL_16;
  }
  return llvm::LLLexer::Error((uint64_t)this + 168, v8, a3);
}

uint64_t llvm::LLParser::parseAnonStructType(uint64_t **this, llvm::Type **a2, int a3)
{
  uint64_t v6;
  void *v8;
  uint64_t v9;
  _QWORD v10[9];

  v10[8] = *MEMORY[0x1E0C80C00];
  v8 = v10;
  v9 = 0x800000000;
  v6 = llvm::LLParser::parseStructBody((uint64_t)this, (uint64_t)&v8);
  if ((v6 & 1) == 0)
    *a2 = (llvm::Type *)llvm::StructType::get(*this, (uint64_t)v8, v9, a3);
  if (v8 != v10)
    free(v8);
  return v6;
}

uint64_t llvm::LLParser::parseArrayVectorType(llvm::LLParser *this, llvm::Type **a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  llvm::Type *v11;
  char *v12;
  int v13;
  llvm::Type *v14;
  llvm::ArrayType *v15;
  llvm::Type *v16;
  llvm::ArrayType *v17;
  llvm::Type *v18;
  const char *v19;
  const char *v20;
  llvm::ArrayType *v21;
  _QWORD v22[4];
  __int16 v23;

  if (a3 && *((_DWORD *)this + 56) == 17)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if ((llvm::LLParser::parseToken((uint64_t)this, 18, "expected 'x' after vscale") & 1) != 0)
      return 1;
    v7 = 0x100000000;
  }
  else
  {
    v7 = 0;
  }
  if (*((_DWORD *)this + 56) == 457 && *((_BYTE *)this + 316) && *((_DWORD *)this + 78) < 0x41u)
  {
    v10 = (char *)*((_QWORD *)this + 27);
    v11 = (llvm::Type *)*((_QWORD *)this + 38);
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if ((llvm::LLParser::parseToken((uint64_t)this, 18, "expected 'x' after element count") & 1) != 0)
      return 1;
    v12 = (char *)*((_QWORD *)this + 27);
    v21 = 0;
    v22[0] = "expected type";
    v23 = 259;
    if ((llvm::LLParser::parseType(this, &v21, (const llvm::Twine *)v22, 0) & 1) != 0)
      return 1;
    v13 = a3 ? 11 : 7;
    if ((llvm::LLParser::parseToken((uint64_t)this, v13, "expected end of sequential type") & 1) != 0)
      return 1;
    if (a3)
    {
      if (v11)
      {
        if (!((unint64_t)v11 >> 32))
        {
          v15 = v21;
          if ((llvm::VectorType::isValidElementType(v21, v14) & 1) != 0)
          {
            llvm::VectorType::get(v15, (llvm::Type *)((unint64_t)v11 | v7));
LABEL_26:
            v18 = v16;
            result = 0;
            *a2 = v18;
            return result;
          }
          v20 = "invalid vector element type";
          goto LABEL_29;
        }
        v19 = "size too large for vector";
      }
      else
      {
        v19 = "zero element vector is illegal";
      }
      v22[0] = v19;
      v23 = 259;
      v9 = (char *)this + 168;
      v8 = v10;
      return llvm::LLLexer::Error((uint64_t)v9, v8, (llvm::Twine *)v22);
    }
    v17 = v21;
    if (llvm::ArrayType::isValidElementType(v21, v14))
    {
      llvm::ArrayType::get(v17, v11);
      goto LABEL_26;
    }
    v20 = "invalid array element type";
LABEL_29:
    v22[0] = v20;
    v23 = 259;
    v9 = (char *)this + 168;
    v8 = v12;
    return llvm::LLLexer::Error((uint64_t)v9, v8, (llvm::Twine *)v22);
  }
  v22[0] = "expected number in address space";
  v23 = 259;
  v8 = (char *)*((_QWORD *)this + 27);
  v9 = (char *)this + 168;
  return llvm::LLLexer::Error((uint64_t)v9, v8, (llvm::Twine *)v22);
}

uint64_t llvm::LLParser::parseFunctionType(char **this, llvm::Type **a2)
{
  int v3;
  uint64_t v7;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  unsigned __int8 v19;
  void *v20;
  uint64_t v21;
  _WORD v22[64];
  char *v23;
  uint64_t v24;
  _WORD v25[192];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = *((unsigned __int8 *)*a2 + 8);
  if (v3 == 8 || v3 == 14 || v3 == 9)
  {
    v23 = "invalid function return type";
    v25[8] = 259;
    return llvm::LLLexer::Error((uint64_t)(this + 21), this[27], (llvm::Twine *)&v23);
  }
  v23 = (char *)v25;
  v24 = 0x800000000;
  v19 = 0;
  if ((llvm::LLParser::parseArgumentList((uint64_t)this, (uint64_t)&v23, &v19) & 1) != 0)
  {
    v7 = 1;
    goto LABEL_10;
  }
  if (!(_DWORD)v24)
  {
    v13 = 0;
    v20 = v22;
    v21 = 0x1000000000;
    v16 = (uint64_t *)v22;
    goto LABEL_25;
  }
  v9 = v23;
  v10 = v24;
  do
  {
    if (v9[47] < 0)
      v11 = *((_QWORD *)v9 + 4);
    else
      v11 = v9[47];
    if (v11)
    {
      v17 = *(char **)v9;
      v18 = "argument name invalid in function type";
LABEL_32:
      v20 = v18;
      v22[8] = 259;
      v7 = llvm::LLLexer::Error((uint64_t)(this + 21), v17, (llvm::Twine *)&v20);
      goto LABEL_10;
    }
    if (*((_QWORD *)v9 + 2))
    {
      v17 = *(char **)v9;
      v18 = "argument attributes invalid in function type";
      goto LABEL_32;
    }
    v9 += 48;
    --v10;
  }
  while (v10);
  v12 = 0;
  LODWORD(v13) = 0;
  v20 = v22;
  v21 = 0x1000000000;
  v14 = 48 * v24;
  do
  {
    v15 = *(_QWORD *)&v23[v12 + 8];
    if (v13 >= HIDWORD(v21))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, (uint64_t)v22, v13 + 1, 8);
      LODWORD(v13) = v21;
    }
    *((_QWORD *)v20 + v13) = v15;
    v13 = (v21 + 1);
    LODWORD(v21) = v21 + 1;
    v12 += 48;
  }
  while (v14 != v12);
  v16 = (uint64_t *)v20;
LABEL_25:
  *a2 = (llvm::Type *)llvm::FunctionType::get((uint64_t **)*a2, v16, v13, v19);
  if (v20 != v22)
    free(v20);
  v7 = 0;
LABEL_10:
  sub_1C4FCE9E8(&v23);
  return v7;
}

uint64_t llvm::LLParser::parseStructBody(uint64_t a1, uint64_t a2)
{
  llvm::LLLexer *v4;
  int v5;
  int v6;
  uint64_t result;
  char *v8;
  llvm::Type *v9;
  llvm::StructType *v10;
  uint64_t v11;
  char *v12;
  llvm::Type *v13;
  llvm::StructType *v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  llvm::StructType *v18;
  _QWORD v19[4];
  __int16 v20;

  v4 = (llvm::LLLexer *)(a1 + 168);
  v5 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v5;
  if (v5 == 9)
  {
    v6 = llvm::LLLexer::LexToken(v4);
    result = 0;
    *(_DWORD *)(a1 + 224) = v6;
    return result;
  }
  v8 = *(char **)(a1 + 216);
  v18 = 0;
  v19[0] = "expected type";
  v20 = 259;
  if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v18, (const llvm::Twine *)v19, 0) & 1) != 0)
    return 1;
  v10 = v18;
  v11 = *(unsigned int *)(a2 + 8);
  if (v11 >= *(_DWORD *)(a2 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a2 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a2 + 8 * v11) = v10;
  ++*(_DWORD *)(a2 + 8);
  if (llvm::StructType::isValidElementType(v10, v9))
  {
    if (*(_DWORD *)(a1 + 224) == 4)
    {
      while (1)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        v12 = *(char **)(a1 + 216);
        v19[0] = "expected type";
        v20 = 259;
        if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v18, (const llvm::Twine *)v19, 0) & 1) != 0)
          break;
        v14 = v18;
        if (!llvm::StructType::isValidElementType(v18, v13))
        {
          v19[0] = "invalid element type for struct";
          v20 = 259;
          v16 = (uint64_t)v4;
          v17 = v12;
          return llvm::LLLexer::Error(v16, v17, (llvm::Twine *)v19);
        }
        v15 = *(unsigned int *)(a2 + 8);
        if (v15 >= *(unsigned int *)(a2 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v15 + 1, 8);
          v15 = *(unsigned int *)(a2 + 8);
        }
        *(_QWORD *)(*(_QWORD *)a2 + 8 * v15) = v14;
        ++*(_DWORD *)(a2 + 8);
        if (*(_DWORD *)(a1 + 224) != 4)
          return llvm::LLParser::parseToken(a1, 9, "expected '}' at end of struct");
      }
      return 1;
    }
    return llvm::LLParser::parseToken(a1, 9, "expected '}' at end of struct");
  }
  else
  {
    v19[0] = "invalid element type for struct";
    v20 = 259;
    v16 = (uint64_t)v4;
    v17 = v8;
    return llvm::LLLexer::Error(v16, v17, (llvm::Twine *)v19);
  }
}

llvm::LLParser::PerFunctionState *llvm::LLParser::PerFunctionState::PerFunctionState(llvm::LLParser::PerFunctionState *this, llvm::LLParser *a2, llvm::Function *a3, int a4)
{
  void **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v13;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
  *((_QWORD *)this + 8) = 0;
  v5 = (void **)((char *)this + 64);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = (char *)this + 48;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = a4;
  v6 = sub_1C485F330((uint64_t)a3);
  if (v6 != v7)
  {
    v8 = v6;
    v9 = v7;
    do
    {
      if ((*(_BYTE *)(v8 + 23) & 0x10) == 0)
      {
        v13 = v8;
        v10 = (uint64_t *)*((_QWORD *)this + 9);
        if ((unint64_t)v10 >= *((_QWORD *)this + 10))
        {
          v11 = sub_1C4DFEA3C(v5, &v13);
        }
        else
        {
          *v10 = v8;
          v11 = v10 + 1;
        }
        *((_QWORD *)this + 9) = v11;
      }
      v8 += 40;
    }
    while (v8 != v9);
  }
  return this;
}

llvm::Type **llvm::LLParser::PerFunctionState::getVal(uint64_t a1, unsigned int a2, unsigned __int8 *a3, char *a4)
{
  uint64_t v8;
  llvm::Type **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  uint64_t *v16;
  int v17;
  unsigned int v19;
  _QWORD **v20;
  _QWORD *v21;
  uint64_t **v22;
  uint64_t v24;
  uint64_t v25[4];
  __int16 v26;
  const char *v27;
  __int16 v28;
  _QWORD v29[4];
  __int16 v30;
  unsigned int v31;

  v31 = a2;
  v8 = *(_QWORD *)(a1 + 64);
  if (a2 < (unint64_t)((*(_QWORD *)(a1 + 72) - v8) >> 3))
  {
    v9 = *(llvm::Type ***)(v8 + 8 * a2);
    if (v9)
      goto LABEL_3;
  }
  v12 = *(_QWORD *)(a1 + 48);
  if (!v12)
    goto LABEL_15;
  v13 = a1 + 48;
  do
  {
    v14 = *(_DWORD *)(v12 + 32);
    v15 = v14 >= a2;
    if (v14 >= a2)
      v16 = (uint64_t *)v12;
    else
      v16 = (uint64_t *)(v12 + 8);
    if (v15)
      v13 = v12;
    v12 = *v16;
  }
  while (*v16);
  if (v13 != a1 + 48 && *(_DWORD *)(v13 + 32) <= a2 && (v9 = *(llvm::Type ***)(v13 + 40)) != 0)
  {
LABEL_3:
    v10 = *(_QWORD *)a1;
    v27 = "%";
    v28 = 259;
    v26 = 264;
    LODWORD(v25[0]) = a2;
    sub_1C4825FE4((uint64_t *)&v27, v25, (uint64_t)v29);
    return llvm::LLParser::checkValidVariableType(v10, a4, (uint64_t)v29, (llvm::Type *)a3, v9);
  }
  else
  {
LABEL_15:
    v17 = a3[8];
    if (v17 == 8)
    {
      v20 = *(_QWORD ***)(a1 + 8);
      v21 = (_QWORD *)**v20;
      v30 = 257;
      v11 = operator new();
      llvm::BasicBlock::BasicBlock(v11, v21, (uint64_t)v29, (uint64_t)v20, 0);
    }
    else
    {
      if (v17 == 14 || v17 == 7)
      {
        v24 = *(_QWORD *)a1;
        v29[0] = "invalid use of a non-first-class type";
        v30 = 259;
        llvm::LLLexer::Error(v24 + 168, a4, (llvm::Twine *)v29);
        return 0;
      }
      v11 = operator new();
      v30 = 257;
      *(_QWORD *)v11 = a3;
      *(_QWORD *)(v11 + 8) = 0;
      v19 = *(_DWORD *)(v11 + 20) & 0xC0000000;
      *(_DWORD *)(v11 + 16) = 21;
      *(_DWORD *)(v11 + 20) = v19;
      *(_QWORD *)(v11 + 24) = 0;
      *(_DWORD *)(v11 + 32) = 0;
      llvm::Value::setName((uint64_t ***)v11, (uint64_t)v29);
    }
    v22 = sub_1C4FCE1E0((uint64_t **)(a1 + 40), a2, &v31);
    v22[5] = (uint64_t *)v11;
    v22[6] = (uint64_t *)a4;
  }
  return (llvm::Type **)v11;
}

uint64_t llvm::LLParser::PerFunctionState::getBB(uint64_t a1, void *a2, char *a3)
{
  uint64_t result;

  result = llvm::LLParser::PerFunctionState::getVal((uint64_t *)a1, a2, (unsigned __int8 *)(****(_QWORD ****)(a1 + 8) + 1600), a3);
  if (result)
  {
    if (*(_BYTE *)(result + 16) != 22)
      return 0;
  }
  return result;
}

llvm::Type **llvm::LLParser::PerFunctionState::getBB(uint64_t a1, unsigned int a2, char *a3)
{
  llvm::Type **result;

  result = llvm::LLParser::PerFunctionState::getVal(a1, a2, (unsigned __int8 *)(****(_QWORD ****)(a1 + 8) + 1600), a3);
  if (result)
  {
    if (*((_BYTE *)result + 16) != 22)
      return 0;
  }
  return result;
}

uint64_t sub_1C61C8C08(uint64_t a1, uint64_t a2)
{
  const char *v4;
  __int16 v5;
  char v6;

  v6 = 0;
  if ((llvm::LLParser::parseIndexList(a1, a2, &v6) & 1) != 0)
    return 1;
  if (!v6)
    return 0;
  v4 = "expected index";
  v5 = 259;
  return llvm::LLLexer::Error(a1 + 168, *(char **)(a1 + 216), (llvm::Twine *)&v4);
}

uint64_t llvm::LLParser::parseCmpPredicate(llvm::LLParser *this, unsigned int *a2, int a3)
{
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  char *v10;
  const char *v11;
  const char *v12;
  __int16 v13;

  v4 = *((_DWORD *)this + 56);
  if (a3 == 54)
  {
    v5 = v4 - 256;
    v6 = 1;
    switch(v5)
    {
      case 0:
        v6 = 12;
        goto LABEL_6;
      case 1:
        v6 = 10;
        goto LABEL_6;
      case 2:
        v6 = 13;
        goto LABEL_6;
      case 3:
        v6 = 11;
        goto LABEL_6;
      case 4:
        goto LABEL_6;
      case 5:
        v6 = 6;
        goto LABEL_6;
      case 6:
        v6 = 4;
        goto LABEL_6;
      case 7:
        v6 = 2;
        goto LABEL_6;
      case 8:
        v6 = 5;
        goto LABEL_6;
      case 9:
        v6 = 3;
        goto LABEL_6;
      case 10:
        v6 = 7;
        goto LABEL_6;
      case 11:
        v6 = 8;
        goto LABEL_6;
      case 12:
        v6 = 9;
        goto LABEL_6;
      case 13:
        v6 = 14;
        goto LABEL_6;
      default:
        v10 = (char *)this + 168;
        v11 = "expected fcmp predicate (e.g. 'oeq')";
        goto LABEL_21;
    }
  }
  v7 = v4 - 250;
  if (v7 >= 0xA)
  {
    v10 = (char *)this + 168;
    v11 = "expected icmp predicate (e.g. 'eq')";
LABEL_21:
    v12 = v11;
    v13 = 259;
    return llvm::LLLexer::Error((uint64_t)v10, *((char **)this + 27), (llvm::Twine *)&v12);
  }
  else
  {
    v6 = dword_1C85F7670[v7];
LABEL_6:
    *a2 = v6;
    v8 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    result = 0;
    *((_DWORD *)this + 56) = v8;
  }
  return result;
}

uint64_t sub_1C61C8DC0(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  return llvm::MDTuple::getImpl(a1, a2, a3, 1, 1);
}

uint64_t sub_1C61C8DCC(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  return llvm::MDTuple::getImpl(a1, a2, a3, 0, 1);
}

uint64_t llvm::LLParser::parseMDNodeTail(llvm::LLParser *this, llvm::MDNode **a2)
{
  uint64_t v4;
  void *v6;
  uint64_t v7;
  _QWORD v8[17];

  v8[16] = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 56) != 8)
    return llvm::LLParser::parseMDNodeID(this, a2);
  v6 = v8;
  v7 = 0x1000000000;
  v4 = llvm::LLParser::parseMDNodeVector(this, (uint64_t)&v6);
  if ((v4 & 1) == 0)
    *a2 = (llvm::MDNode *)llvm::MDTuple::getImpl(*(uint64_t **)this, v6, v7, 0, 1);
  if (v6 != v8)
    free(v6);
  return v4;
}

uint64_t llvm::LLParser::parseDILocation(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  llvm::LLLexer *v6;
  uint64_t result;
  int v8;
  int v9;
  uint64_t *v10;
  llvm::LLParser *v11;
  const char *v12;
  uint64_t v13;
  char *v14;
  llvm::MDNode *Impl;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  const char *v31;
  __int16 v32;
  uint64_t v33[5];
  _QWORD v34[4];
  __int16 v35;

  v25 = 0;
  v26 = 0xFFFFFFFFLL;
  v21 = 0;
  v22 = 0;
  v23 = 0xFFFFLL;
  v24 = 0;
  v19 = 0;
  v20 = 0;
  v17 = 0;
  v18 = 256;
  v6 = (llvm::LLParser *)((char *)this + 168);
  v16 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0)
    return 1;
  v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1C4FB2CFC((_QWORD *)this + 29, "line"))
      {
        if ((sub_1C4FCED30((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v24) & 1) != 0)
          return 1;
      }
      else if (sub_1C4FB2CFC((_QWORD *)this + 29, "column"))
      {
        if ((sub_1C4FCEDE4((uint64_t)this, (uint64_t)&v21) & 1) != 0)
          return 1;
      }
      else
      {
        if (sub_1C4FB2CFC((_QWORD *)this + 29, "scope"))
        {
          v10 = &v19;
          v11 = this;
          v12 = "scope";
          v13 = 5;
        }
        else
        {
          if (!sub_1C4FB2CFC((_QWORD *)this + 29, "inlinedAt"))
          {
            if (sub_1C4FB2CFC((_QWORD *)this + 29, "isImplicitCode"))
            {
              if ((sub_1C4FCEF48((uint64_t)this, (uint64_t)"isImplicitCode", 14, (char *)&v16) & 1) != 0)
                return 1;
            }
            else
            {
              v31 = "invalid field '";
              v32 = 259;
              v30 = 260;
              v29[0] = (uint64_t)this + 232;
              sub_1C4825FE4((uint64_t *)&v31, v29, (uint64_t)v33);
              v27 = "'";
              v28 = 259;
              sub_1C4825FE4(v33, (uint64_t *)&v27, (uint64_t)v34);
              if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34) & 1) != 0)
                return 1;
            }
            goto LABEL_6;
          }
          v10 = &v17;
          v11 = this;
          v12 = "inlinedAt";
          v13 = 9;
        }
        if ((sub_1C4FCEE94((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10) & 1) != 0)
          return 1;
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4)
        goto LABEL_22;
      v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437)
        goto LABEL_25;
    }
  }
  if (v8 != 13)
  {
LABEL_25:
    v34[0] = "expected field label here";
    v35 = 259;
    if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34) & 1) != 0)
      return 1;
  }
LABEL_22:
  v14 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) != 0)
    return 1;
  if ((_BYTE)v20)
  {
    Impl = (llvm::MDNode *)llvm::DILocation::getImpl(*(uint64_t **)this, v24, v21, v19, v17, v16, a3, 1);
    result = 0;
    *a2 = Impl;
  }
  else
  {
    v34[0] = "missing required field 'scope'";
    v35 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v34);
  }
  return result;
}

uint64_t llvm::LLParser::parseDIBasicType(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  llvm::LLLexer *v6;
  uint64_t result;
  int v8;
  int v9;
  uint64_t *v10;
  llvm::LLParser *v11;
  const char *v12;
  uint64_t v13;
  char v14;
  llvm::MDNode *Impl;
  int v16;
  char v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  const char *v32;
  __int16 v33;
  uint64_t v34[4];
  __int16 v35;
  const char *v36;
  __int16 v37;
  uint64_t v38[5];
  _QWORD v39[4];
  __int16 v40;

  v29 = 36;
  v30 = 0;
  v31 = 0xFFFFLL;
  v28 = 256;
  v25 = 0;
  v26 = -1;
  v27 = 0;
  v22 = 0;
  v23 = 0xFFFFFFFFLL;
  v24 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 255;
  v21 = 0;
  v16 = 0;
  v6 = (llvm::LLParser *)((char *)this + 168);
  v17 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0)
    return 1;
  v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1C4FB2CFC((_QWORD *)this + 29, "tag"))
      {
        if ((sub_1C4FCF23C((uint64_t)this, (uint64_t)&v29) & 1) != 0)
          return 1;
      }
      else if (sub_1C4FB2CFC((_QWORD *)this + 29, "name"))
      {
        if ((sub_1C4FCF3D8((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v27) & 1) != 0)
          return 1;
      }
      else
      {
        if (sub_1C4FB2CFC((_QWORD *)this + 29, "size"))
        {
          v10 = &v24;
          v11 = this;
          v12 = "size";
          v13 = 4;
        }
        else
        {
          if (!sub_1C4FB2CFC((_QWORD *)this + 29, "align"))
          {
            if (sub_1C4FB2CFC((_QWORD *)this + 29, "encoding"))
            {
              if ((sub_1C4FCFBD4((uint64_t)this, (uint64_t)&v18) & 1) != 0)
                return 1;
            }
            else if (sub_1C4FB2CFC((_QWORD *)this + 29, "flags"))
            {
              if ((sub_1C4FCFD6C((uint64_t)this, (uint64_t)&v16) & 1) != 0)
                return 1;
            }
            else
            {
              v36 = "invalid field '";
              v37 = 259;
              v35 = 260;
              v34[0] = (uint64_t)this + 232;
              sub_1C4825FE4((uint64_t *)&v36, v34, (uint64_t)v38);
              v32 = "'";
              v33 = 259;
              sub_1C4825FE4(v38, (uint64_t *)&v32, (uint64_t)v39);
              if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v39) & 1) != 0)
                return 1;
            }
            goto LABEL_7;
          }
          v10 = &v21;
          v11 = this;
          v12 = "align";
          v13 = 5;
        }
        if ((sub_1C4FCED30((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10) & 1) != 0)
          return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4)
        goto LABEL_26;
      v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437)
        goto LABEL_28;
    }
  }
  if (v8 != 13)
  {
LABEL_28:
    v39[0] = "expected field label here";
    v40 = 259;
    if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v39) & 1) != 0)
      return 1;
  }
LABEL_26:
  v14 = llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here");
  result = 1;
  if ((v14 & 1) == 0)
  {
    Impl = llvm::DIBasicType::getImpl(*(_QWORD **)this, v29, v27, v24, v21, v18, v16, a3, 1);
    result = 0;
    *a2 = Impl;
  }
  return result;
}

uint64_t llvm::LLParser::parseDIFile(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  llvm::LLLexer *v6;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  uint64_t *v11;
  llvm::LLParser *v12;
  const char *v13;
  uint64_t v14;
  int v15;
  int v16;
  char v17;
  BOOL v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t ChecksumKind;
  int v23;
  uint64_t *v24;
  char *v25;
  uint64_t v26;
  char v27;
  _QWORD *v28;
  uint64_t v29;
  llvm::MDNode *Impl;
  const char *v31;
  uint64_t v32;
  char *v33;
  int v34;
  llvm::MDNode **v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  uint64_t v54[4];
  __int16 v55;
  __int128 v56;
  char v57;
  __int16 v58;

  v42 = 0;
  v43 = 256;
  v40 = 0;
  v41 = 256;
  v38 = 0;
  v39 = 256;
  v36 = 0;
  v6 = (llvm::LLParser *)((char *)this + 168);
  v37 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0)
    return 1;
  v8 = *((_DWORD *)this + 56);
  v35 = a2;
  v34 = a3;
  v9 = 0;
  if (v8 == 437)
  {
    v10 = 1;
    while (1)
    {
      if (sub_1C4FB2CFC((_QWORD *)this + 29, "filename"))
      {
        v11 = &v42;
        v12 = this;
        v13 = "filename";
        goto LABEL_7;
      }
      if (sub_1C4FB2CFC((_QWORD *)this + 29, "directory"))
        break;
      if (!sub_1C4FB2CFC((_QWORD *)this + 29, "checksumkind"))
      {
        if (sub_1C4FB2CFC((_QWORD *)this + 29, "checksum"))
        {
          v11 = &v38;
          v12 = this;
          v13 = "checksum";
LABEL_7:
          v14 = 8;
        }
        else
        {
          if (!sub_1C4FB2CFC((_QWORD *)this + 29, "source"))
          {
            v52[0] = (uint64_t)"invalid field '";
            v53 = 259;
            v51 = 260;
            v50[0] = (uint64_t)this + 232;
            sub_1C4825FE4(v52, v50, (uint64_t)v54);
            v48[0] = (uint64_t)"'";
            v49 = 259;
            v24 = v48;
LABEL_31:
            sub_1C4825FE4(v54, v24, (uint64_t)&v56);
            if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v56) & 1) != 0)
              return 1;
            goto LABEL_9;
          }
          v11 = &v36;
          v12 = this;
          v13 = "source";
          v14 = 6;
        }
LABEL_8:
        if ((sub_1C4FCF3D8((uint64_t)v12, (uint64_t)v13, v14, (uint64_t)v11) & 1) != 0)
          return 1;
        goto LABEL_9;
      }
      if (v9)
      {
        v55 = 1283;
        v54[0] = (uint64_t)"field '";
        v54[2] = (uint64_t)"checksumkind";
        v54[3] = 12;
        v52[0] = (uint64_t)"' cannot be specified more than once";
        v53 = 259;
        v24 = v52;
        goto LABEL_31;
      }
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      v17 = *((_BYTE *)this + 255);
      v18 = v17 < 0;
      if (v17 >= 0)
        v19 = (char *)this + 232;
      else
        v19 = (char *)*((_QWORD *)this + 29);
      v20 = v17 & 0x7F;
      if (v18)
        v21 = *((_QWORD *)this + 30);
      else
        v21 = v20;
      ChecksumKind = llvm::DIFile::getChecksumKind((uint64_t)v19, v21);
      if (*((_DWORD *)this + 56) == 454)
      {
        v23 = ChecksumKind;
        if ((ChecksumKind & 0xFF00000000) != 0)
        {
          v15 = llvm::LLLexer::LexToken(v6);
          *((_DWORD *)this + 56) = v15;
          v9 = 1;
          v10 = v23;
          goto LABEL_10;
        }
      }
      v50[0] = (uint64_t)"invalid checksum kind";
      v51 = 259;
      v48[0] = (uint64_t)" '";
      v49 = 259;
      sub_1C4825FE4(v50, v48, (uint64_t)v52);
      v47 = 260;
      v46[0] = (uint64_t)this + 232;
      sub_1C4825FE4(v52, v46, (uint64_t)v54);
      v44 = "'";
      v45 = 259;
      sub_1C4825FE4(v54, (uint64_t *)&v44, (uint64_t)&v56);
      if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v56) & 1) != 0)
        return 1;
LABEL_9:
      v15 = *((_DWORD *)this + 56);
LABEL_10:
      if (v15 != 4)
        goto LABEL_36;
      v16 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v16;
      if (v16 != 437)
        goto LABEL_46;
    }
    v11 = &v40;
    v12 = this;
    v13 = "directory";
    v14 = 9;
    goto LABEL_8;
  }
  v10 = 1;
  if (v8 != 13)
  {
LABEL_46:
    *(_QWORD *)&v56 = "expected field label here";
    v58 = 259;
    if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v56) & 1) != 0)
      return 1;
  }
LABEL_36:
  v25 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) != 0)
    return 1;
  if (!(_BYTE)v43)
  {
    v31 = "missing required field 'filename'";
LABEL_54:
    *(_QWORD *)&v56 = v31;
    v58 = 259;
    v32 = (uint64_t)v6;
    v33 = v25;
    return llvm::LLLexer::Error(v32, v33, (llvm::Twine *)&v56);
  }
  if (!(_BYTE)v41)
  {
    v31 = "missing required field 'directory'";
    goto LABEL_54;
  }
  v27 = v39;
  if (!v9 || !(_BYTE)v39)
  {
    if (!v9 && !(_BYTE)v39)
    {
      v10 = 0;
      goto LABEL_42;
    }
    *(_QWORD *)&v56 = "'checksumkind' and 'checksum' must be provided together";
    v58 = 259;
    v33 = (char *)*((_QWORD *)this + 27);
    v32 = (uint64_t)v6;
    return llvm::LLLexer::Error(v32, v33, (llvm::Twine *)&v56);
  }
  v27 = 1;
  v26 = v38;
LABEL_42:
  v28 = *(_QWORD **)this;
  if ((_BYTE)v37)
    v29 = v36;
  else
    v29 = 0;
  LODWORD(v56) = v10;
  *((_QWORD *)&v56 + 1) = v26;
  v57 = v27;
  Impl = llvm::DIFile::getImpl(v28, v42, v40, &v56, v29, v37, v34 != 0, 1);
  result = 0;
  *v35 = Impl;
  return result;
}

uint64_t llvm::LLParser::parseDIMacro(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  llvm::LLLexer *v6;
  uint64_t result;
  int v8;
  int v9;
  unint64_t *v10;
  llvm::LLParser *v11;
  const char *v12;
  uint64_t v13;
  char *v14;
  llvm::MDNode *Impl;
  const char *v16;
  unint64_t v17;
  __int16 v18;
  unint64_t v19;
  __int16 v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  const char *v31;
  __int16 v32;
  uint64_t v33[5];
  _QWORD v34[4];
  __int16 v35;

  v25 = 0;
  v26 = 255;
  v21 = 0;
  v22 = 0;
  v23 = 0xFFFFFFFFLL;
  v24 = 0;
  v19 = 0;
  v20 = 256;
  v18 = 256;
  v6 = (llvm::LLParser *)((char *)this + 168);
  v17 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0)
    return 1;
  v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1C4FB2CFC((_QWORD *)this + 29, "type"))
      {
        if ((sub_1C4FD00C8((uint64_t)this, (uint64_t)&v24) & 1) != 0)
          return 1;
      }
      else if (sub_1C4FB2CFC((_QWORD *)this + 29, "line"))
      {
        if ((sub_1C4FCED30((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v21) & 1) != 0)
          return 1;
      }
      else
      {
        if (sub_1C4FB2CFC((_QWORD *)this + 29, "name"))
        {
          v10 = &v19;
          v11 = this;
          v12 = "name";
          v13 = 4;
        }
        else
        {
          if (!sub_1C4FB2CFC((_QWORD *)this + 29, "value"))
          {
            v31 = "invalid field '";
            v32 = 259;
            v30 = 260;
            v29[0] = (uint64_t)this + 232;
            sub_1C4825FE4((uint64_t *)&v31, v29, (uint64_t)v33);
            v27 = "'";
            v28 = 259;
            sub_1C4825FE4(v33, (uint64_t *)&v27, (uint64_t)v34);
            if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34) & 1) != 0)
              return 1;
            goto LABEL_6;
          }
          v10 = &v17;
          v11 = this;
          v12 = "value";
          v13 = 5;
        }
        if ((sub_1C4FCF3D8((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10) & 1) != 0)
          return 1;
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4)
        goto LABEL_21;
      v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437)
        goto LABEL_25;
    }
  }
  if (v8 != 13)
  {
LABEL_25:
    v34[0] = "expected field label here";
    v35 = 259;
    if ((llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34) & 1) != 0)
      return 1;
  }
LABEL_21:
  v14 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) != 0)
    return 1;
  if (v25)
  {
    if ((_BYTE)v20)
    {
      Impl = llvm::DIMacro::getImpl(*(_QWORD **)this, v24, v21, v19, v17, a3, 1);
      result = 0;
      *a2 = Impl;
      return result;
    }
    v16 = "missing required field 'name'";
  }
  else
  {
    v16 = "missing required field 'type'";
  }
  v34[0] = v16;
  v35 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v34);
}

uint64_t llvm::LLParser::parseDIArgList(llvm::LLParser *this, llvm::MDNode **a2, int a3, llvm::LLParser::PerFunctionState *a4)
{
  llvm::LLLexer *v8;
  uint64_t v9;
  llvm::Metadata *v11;
  int v12;
  uint64_t v13;
  llvm::MDNode *Impl;
  int v15;
  llvm::Metadata *v16;
  const char *i;
  __int16 v18;
  llvm::Metadata *v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v22[4] = *MEMORY[0x1E0C80C00];
  v8 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0)
    return 1;
  v20 = v22;
  v21 = 0x400000000;
  if (*((_DWORD *)this + 56) != 13)
  {
    v19 = 0;
    for (i = "expected value-as-metadata operand"; ; i = "expected value-as-metadata operand")
    {
      v18 = 259;
      if ((llvm::LLParser::parseValueAsMetadata(this, &v19, (const llvm::Twine *)&i, a4) & 1) != 0)
        break;
      v11 = v19;
      v12 = *(unsigned __int8 *)v19;
      v13 = v21;
      if (v21 >= (unint64_t)HIDWORD(v21))
      {
        v16 = v19;
        v15 = *(unsigned __int8 *)v19;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, (uint64_t)v22, v21 + 1, 8);
        v12 = v15;
        v11 = v16;
        v13 = v21;
      }
      if ((v12 - 1) >= 2)
        v11 = 0;
      *((_QWORD *)v20 + v13) = v11;
      LODWORD(v21) = v21 + 1;
      if (*((_DWORD *)this + 56) != 4)
        goto LABEL_5;
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v8);
      v19 = 0;
    }
    goto LABEL_6;
  }
LABEL_5:
  if ((llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) != 0)
  {
LABEL_6:
    v9 = 1;
    goto LABEL_7;
  }
  Impl = llvm::DIArgList::getImpl(*(_QWORD **)this, v20, v21, a3, 1);
  v9 = 0;
  *a2 = Impl;
LABEL_7:
  if (v20 != v22)
    free(v20);
  return v9;
}

uint64_t llvm::LLParser::parseValueAsMetadata(llvm::LLParser *this, llvm::Metadata **a2, const llvm::Twine *a3, llvm::LLParser::PerFunctionState *a4)
{
  char *v7;
  uint64_t v8;
  llvm::Value *v10;
  llvm::ValueAsMetadata *v11[4];
  __int16 v12;
  llvm::Type *v13;

  v13 = 0;
  v7 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseType(this, &v13, a3, 0) & 1) != 0)
    return 1;
  if (*((_BYTE *)v13 + 8) == 9)
  {
    v11[0] = (llvm::ValueAsMetadata *)"invalid metadata-value-metadata roundtrip";
    v12 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v7, (llvm::Twine *)v11);
  }
  else
  {
    v11[0] = 0;
    v8 = llvm::LLParser::parseValue((uint64_t **)this, v13, v11, a4);
    if ((v8 & 1) == 0)
      *a2 = (llvm::Metadata *)llvm::ValueAsMetadata::get(v11[0], v10);
  }
  return v8;
}

uint64_t llvm::LLParser::parseMetadata(llvm::LLParser *this, llvm::Metadata **a2, llvm::LLParser::PerFunctionState *a3)
{
  int v5;
  int v6;
  uint64_t result;
  llvm::MDString *v9[4];
  __int16 v10;

  v5 = *((_DWORD *)this + 56);
  if (v5 != 14)
  {
    if (v5 != 441)
    {
      v9[0] = (llvm::MDString *)"expected metadata operand";
      v10 = 259;
      return llvm::LLParser::parseValueAsMetadata(this, a2, (const llvm::Twine *)v9, a3);
    }
    v9[0] = 0;
    if (sub_1C4FB2CFC((_QWORD *)this + 29, "DIArgList"))
    {
      if ((llvm::LLParser::parseDIArgList(this, v9, 0, a3) & 1) != 0)
        return 1;
    }
    else if ((llvm::LLParser::parseSpecializedMDNode(this, v9, 0) & 1) != 0)
    {
      return 1;
    }
    result = 0;
    goto LABEL_4;
  }
  v6 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v6;
  if (v6 == 442)
  {
    v9[0] = 0;
    result = llvm::LLParser::parseMDString((uint64_t **)this, v9);
    if ((result & 1) != 0)
      return result;
    goto LABEL_4;
  }
  v9[0] = 0;
  result = llvm::LLParser::parseMDNodeTail(this, v9);
  if ((result & 1) == 0)
LABEL_4:
    *a2 = v9[0];
  return result;
}

uint64_t llvm::LLParser::parseValue(uint64_t **this, llvm::Type *a2, llvm::Value **a3, llvm::LLParser::PerFunctionState *a4)
{
  uint64_t v7;
  int v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  char v17;
  _QWORD v18[6];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *a3 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0;
  v15 = 0;
  v7 = 1;
  v16 = 1;
  v17 = 0;
  sub_1C47BC1BC((uint64_t)v18, 0.0);
  v18[5] = 0;
  v19 = 0;
  if ((llvm::LLParser::parseValID(this, (uint64_t)&v9, a4, a2) & 1) == 0)
    v7 = llvm::LLParser::convertValIDToValue((uint64_t)this, (uint64_t)a2, (uint64_t)&v9);
  sub_1C4FCD54C((uint64_t)&v9);
  return v7;
}

uint64_t llvm::LLParser::parseTypeAndValue(uint64_t **this, llvm::Value **a2, llvm::LLParser::PerFunctionState *a3)
{
  llvm::Type *v7;
  const char *v8;
  __int16 v9;

  v7 = 0;
  v8 = "expected type";
  v9 = 259;
  if ((llvm::LLParser::parseType((llvm::LLParser *)this, &v7, (const llvm::Twine *)&v8, 0) & 1) != 0)
    return 1;
  else
    return llvm::LLParser::parseValue(this, v7, a2, a3);
}

uint64_t llvm::LLParser::parseTypeAndBasicBlock(uint64_t a1, llvm::Value **a2, char **a3, llvm::LLParser::PerFunctionState *a4)
{
  uint64_t result;
  char *v8;
  const char *v9;
  __int16 v10;
  llvm::Value *v11;

  v11 = 0;
  *a3 = *(char **)(a1 + 216);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)a1, &v11, a4) & 1) != 0)
    return 1;
  if (*((_BYTE *)v11 + 16) == 22)
  {
    result = 0;
    *a2 = v11;
  }
  else
  {
    v8 = *a3;
    v9 = "expected a basic block";
    v10 = 259;
    return llvm::LLLexer::Error(a1 + 168, v8, (llvm::Twine *)&v9);
  }
  return result;
}

uint64_t llvm::LLParser::parseResume(uint64_t **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v4;
  llvm::Value *v5;
  _DWORD *v6;
  llvm::Instruction *v7;
  llvm::Value *v9;

  v9 = 0;
  v4 = llvm::LLParser::parseTypeAndValue(this, &v9, a3);
  if ((v4 & 1) == 0)
  {
    v5 = v9;
    v6 = operator new(0x60uLL);
    v6[13] = v6[13] & 0x38000000 | 1;
    v7 = (llvm::Instruction *)(v6 + 8);
    *(_QWORD *)v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    *((_QWORD *)v6 + 2) = 0;
    *((_QWORD *)v6 + 3) = v6 + 8;
    llvm::ResumeInst::ResumeInst((llvm::ResumeInst *)(v6 + 8), v5, 0);
    *a2 = v7;
  }
  return v4;
}

uint64_t llvm::LLParser::parseCleanupRet(llvm::Type **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  llvm::LLVMContext *v6;
  uint64_t result;
  llvm::Type *TokenTy;
  llvm::BasicBlock *v9;
  llvm::Value *v10;
  unsigned int v11;
  llvm::CleanupReturnInst *v12;
  llvm::Value *v13;
  llvm::Value *v14;
  char *v15;

  v14 = 0;
  if ((llvm::LLParser::parseToken((uint64_t)this, 58, "expected 'from' after cleanupret") & 1) != 0)
    return 1;
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*this, v6);
  if ((llvm::LLParser::parseValue((uint64_t **)this, TokenTy, &v14, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 65, "expected 'unwind' in cleanupret") & 1) != 0)
  {
    return 1;
  }
  v13 = 0;
  if (*((_DWORD *)this + 56) != 55)
  {
    v15 = 0;
    if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v13, &v15, a3) & 1) == 0)
    {
      v9 = v13;
      goto LABEL_11;
    }
    return 1;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLLexer *)(this + 21));
  if ((llvm::LLParser::parseToken((uint64_t)this, 56, "expected 'caller' in cleanupret") & 1) != 0)
    return 1;
  v9 = 0;
LABEL_11:
  v10 = v14;
  if (v9)
    v11 = 2;
  else
    v11 = 1;
  v12 = (llvm::CleanupReturnInst *)llvm::User::operator new((llvm::User *)0x40, v11);
  llvm::CleanupReturnInst::CleanupReturnInst(v12, v10, v9, v11, 0);
  result = 0;
  *a2 = v12;
  return result;
}

uint64_t llvm::LLParser::parseCatchRet(llvm::Type **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  llvm::LLVMContext *v6;
  uint64_t result;
  llvm::Type *TokenTy;
  llvm::Value *v9;
  llvm::BasicBlock *v10;
  _DWORD *v11;
  llvm::Instruction *v12;
  llvm::Value *v13;
  llvm::Value *v14;
  char *v15;

  v14 = 0;
  if ((llvm::LLParser::parseToken((uint64_t)this, 58, "expected 'from' after catchret") & 1) != 0)
    return 1;
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*this, v6);
  if ((llvm::LLParser::parseValue((uint64_t **)this, TokenTy, &v14, a3) & 1) != 0)
    return 1;
  v13 = 0;
  if ((llvm::LLParser::parseToken((uint64_t)this, 55, "expected 'to' in catchret") & 1) != 0)
    return 1;
  v15 = 0;
  if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v13, &v15, a3) & 1) != 0)
    return 1;
  v10 = v13;
  v9 = v14;
  v11 = operator new(0x80uLL);
  v11[21] = v11[21] & 0x38000000 | 2;
  v12 = (llvm::Instruction *)(v11 + 16);
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = 0;
  *((_QWORD *)v11 + 2) = 0;
  *((_QWORD *)v11 + 3) = v11 + 16;
  *((_QWORD *)v11 + 4) = 0;
  *((_QWORD *)v11 + 5) = 0;
  *((_QWORD *)v11 + 6) = 0;
  *((_QWORD *)v11 + 7) = v11 + 16;
  llvm::CatchReturnInst::CatchReturnInst((llvm::CatchReturnInst *)(v11 + 16), v9, v10, 0);
  result = 0;
  *a2 = v12;
  return result;
}

uint64_t llvm::LLParser::parseCatchSwitch(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  llvm::LLVMContext *v6;
  uint64_t v7;
  int v9;
  llvm::Type *TokenTy;
  llvm::Value *v11;
  uint64_t v12;
  llvm::BasicBlock *v13;
  llvm::Value *v14;
  unsigned int v15;
  _DWORD *v16;
  llvm::CatchSwitchInst *v17;
  llvm::BasicBlock **v18;
  uint64_t v19;
  llvm::BasicBlock *v20;
  char *v21[4];
  __int16 v22;
  llvm::Value *v23;
  llvm::Value *v24;
  void *v25;
  uint64_t v26;
  _WORD v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((llvm::LLParser::parseToken((uint64_t)this, 57, "expected 'within' after catchswitch") & 1) != 0)
    return 1;
  v9 = *((_DWORD *)this + 56);
  if (v9 != 54 && v9 != 434 && v9 != 440)
  {
    v25 = "expected scope value for catchswitch";
    v27[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v25);
  }
  v24 = 0;
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*(llvm::Type **)this, v6);
  if ((llvm::LLParser::parseValue((uint64_t **)this, TokenTy, &v24, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' with catchswitch labels") & 1) != 0)
  {
    return 1;
  }
  v25 = v27;
  v26 = 0x2000000000;
  while (1)
  {
    v23 = 0;
    v21[0] = 0;
    if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v23, v21, a3) & 1) != 0)
      goto LABEL_17;
    v11 = v23;
    v12 = v26;
    if (v26 >= (unint64_t)HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, (uint64_t)v27, v26 + 1, 8);
      v12 = v26;
    }
    *((_QWORD *)v25 + v12) = v11;
    LODWORD(v26) = v26 + 1;
    if (*((_DWORD *)this + 56) != 4)
      break;
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  }
  if ((llvm::LLParser::parseToken((uint64_t)this, 7, "expected ']' after catchswitch labels") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 65, "expected 'unwind' after catchswitch scope") & 1) != 0)
  {
    goto LABEL_17;
  }
  v23 = 0;
  if (*((_DWORD *)this + 56) == 55)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if ((llvm::LLParser::parseToken((uint64_t)this, 56, "expected 'caller' in catchswitch") & 1) == 0)
    {
      v13 = 0;
      goto LABEL_26;
    }
LABEL_17:
    v7 = 1;
    goto LABEL_18;
  }
  v21[0] = 0;
  if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v23, v21, a3) & 1) != 0)
    goto LABEL_17;
  v13 = v23;
LABEL_26:
  v14 = v24;
  v15 = v26;
  v22 = 257;
  v16 = operator new(0x48uLL);
  v17 = (llvm::CatchSwitchInst *)(v16 + 2);
  v16[7] = v16[7] & 0x38000000 | 0x40000000;
  *(_QWORD *)v16 = 0;
  llvm::CatchSwitchInst::CatchSwitchInst((llvm::CatchSwitchInst *)(v16 + 2), v14, v13, v15, (const llvm::Twine *)v21, 0);
  if ((_DWORD)v26)
  {
    v18 = (llvm::BasicBlock **)v25;
    v19 = 8 * v26;
    do
    {
      v20 = *v18++;
      llvm::CatchSwitchInst::addHandler(v17, v20);
      v19 -= 8;
    }
    while (v19);
  }
  v7 = 0;
  *a2 = v17;
LABEL_18:
  if (v25 != v27)
    free(v25);
  return v7;
}

uint64_t llvm::LLParser::parseCatchPad(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  llvm::LLVMContext *v6;
  uint64_t v7;
  int v9;
  llvm::Type *TokenTy;
  llvm::Type **v11;
  uint64_t *v12;
  uint64_t v13;
  unsigned int v14;
  llvm::Instruction *v15;
  _BYTE v16[32];
  __int16 v17;
  llvm::Value *v18;
  void *v19;
  uint64_t v20;
  _WORD v21[32];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  if ((llvm::LLParser::parseToken((uint64_t)this, 57, "expected 'within' after catchpad") & 1) != 0)
    return 1;
  v9 = *((_DWORD *)this + 56);
  if (v9 != 434 && v9 != 440)
  {
    v19 = "expected scope value for catchpad";
    v21[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v19);
  }
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*(llvm::Type **)this, v6);
  if ((llvm::LLParser::parseValue((uint64_t **)this, TokenTy, &v18, a3) & 1) != 0)
    return 1;
  v19 = v21;
  v20 = 0x800000000;
  v7 = llvm::LLParser::parseExceptionArgs(this, (uint64_t)&v19, a3);
  if ((v7 & 1) == 0)
  {
    v11 = (llvm::Type **)v18;
    v12 = (uint64_t *)v19;
    v13 = v20;
    v14 = v20 + 1;
    v17 = 257;
    v15 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, (int)v20 + 1);
    *a2 = llvm::FuncletPadInst::FuncletPadInst(v15, 52, v11, v12, v13, v14, (uint64_t)v16, 0);
  }
  if (v19 != v21)
    free(v19);
  return v7;
}

uint64_t llvm::LLParser::parseCleanupPad(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  llvm::LLVMContext *v6;
  uint64_t v7;
  int v9;
  llvm::Type *TokenTy;
  llvm::Type **v11;
  uint64_t *v12;
  uint64_t v13;
  unsigned int v14;
  llvm::Instruction *v15;
  _BYTE v16[32];
  __int16 v17;
  llvm::Value *v18;
  void *v19;
  uint64_t v20;
  _WORD v21[32];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  if ((llvm::LLParser::parseToken((uint64_t)this, 57, "expected 'within' after cleanuppad") & 1) != 0)
    return 1;
  v9 = *((_DWORD *)this + 56);
  if (v9 != 54 && v9 != 434 && v9 != 440)
  {
    v19 = "expected scope value for cleanuppad";
    v21[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v19);
  }
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*(llvm::Type **)this, v6);
  if ((llvm::LLParser::parseValue((uint64_t **)this, TokenTy, &v18, a3) & 1) != 0)
    return 1;
  v19 = v21;
  v20 = 0x800000000;
  v7 = llvm::LLParser::parseExceptionArgs(this, (uint64_t)&v19, a3);
  if ((v7 & 1) == 0)
  {
    v11 = (llvm::Type **)v18;
    v12 = (uint64_t *)v19;
    v13 = v20;
    v14 = v20 + 1;
    v17 = 257;
    v15 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, (int)v20 + 1);
    *a2 = llvm::FuncletPadInst::FuncletPadInst(v15, 51, v11, v12, v13, v14, (uint64_t)v16, 0);
  }
  if (v19 != v21)
    free(v19);
  return v7;
}

uint64_t sub_1C61CAA2C(uint64_t a1)
{
  uint64_t result;
  int v3;
  uint64_t v4;

  result = 0;
  v3 = *(_DWORD *)(a1 + 224);
  while (1)
  {
    v4 = 0xFFFFFFFFLL;
    switch(v3)
    {
      case 'M':
        v4 = result | 2;
        break;
      case 'N':
        v4 = result | 4;
        break;
      case 'O':
        v4 = result | 8;
        break;
      case 'P':
        v4 = result | 0x10;
        break;
      case 'Q':
        v4 = result | 0x20;
        break;
      case 'R':
        v4 = result | 1;
        break;
      case 'S':
        v4 = result | 0x40;
        break;
      case 'T':
        break;
      default:
        return result;
    }
    v3 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v3;
    result = v4;
  }
}

uint64_t llvm::LLParser::parseUnaryOp(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, char a4, int a5)
{
  char *v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  llvm::Instruction *v13;
  _QWORD v14[4];
  __int16 v15;
  llvm::Value *v16;

  v16 = 0;
  v9 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v16, a3) & 1) != 0)
    return 1;
  v11 = *(_QWORD *)v16;
  v12 = *(_DWORD *)(*(_QWORD *)v16 + 8);
  if (a5)
  {
    if ((*(_DWORD *)(*(_QWORD *)v16 + 8) & 0xFE) == 0x12)
      v12 = *(unsigned __int8 *)(**(_QWORD **)(v11 + 16) + 8);
    if (v12 >= 7)
    {
LABEL_7:
      v14[0] = "invalid operand type for instruction";
      v15 = 259;
      return llvm::LLLexer::Error((uint64_t)this + 168, v9, (llvm::Twine *)v14);
    }
  }
  else
  {
    if ((*(_DWORD *)(*(_QWORD *)v16 + 8) & 0xFE) == 0x12)
      v12 = *(unsigned __int8 *)(**(_QWORD **)(v11 + 16) + 8);
    if (v12 != 13)
      goto LABEL_7;
  }
  v15 = 257;
  v13 = (llvm::Instruction *)llvm::UnaryOperator::Create(a4, (uint64_t *)v16, (uint64_t)v14, 0);
  result = 0;
  *a2 = v13;
  return result;
}

uint64_t llvm::LLParser::parseArithmetic(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, char a4, int a5)
{
  char *v10;
  uint64_t result;
  llvm::Value *v12;
  uint64_t v13;
  unsigned int v14;
  llvm::Instruction *v15;
  _QWORD v16[4];
  __int16 v17;
  llvm::Value *v18;
  llvm::Value *v19;

  v19 = 0;
  v10 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v19, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' in arithmetic operation") & 1) != 0)
    return 1;
  v18 = 0;
  v12 = v19;
  if ((llvm::LLParser::parseValue((uint64_t **)this, *(llvm::Type **)v19, &v18, a3) & 1) != 0)
    return 1;
  v13 = *(_QWORD *)v12;
  v14 = *(_DWORD *)(*(_QWORD *)v12 + 8);
  if (a5)
  {
    if ((*(_DWORD *)(*(_QWORD *)v12 + 8) & 0xFE) == 0x12)
      v14 = *(unsigned __int8 *)(**(_QWORD **)(v13 + 16) + 8);
    if (v14 >= 7)
    {
LABEL_9:
      v16[0] = "invalid operand type for instruction";
      v17 = 259;
      return llvm::LLLexer::Error((uint64_t)this + 168, v10, (llvm::Twine *)v16);
    }
  }
  else
  {
    if ((*(_DWORD *)(*(_QWORD *)v12 + 8) & 0xFE) == 0x12)
      v14 = *(unsigned __int8 *)(**(_QWORD **)(v13 + 16) + 8);
    if (v14 != 13)
      goto LABEL_9;
  }
  v17 = 257;
  v15 = llvm::BinaryOperator::Create(a4, v12, (uint64_t)v18, (uint64_t)v16, 0);
  result = 0;
  *a2 = v15;
  return result;
}

uint64_t llvm::LLParser::parseLogical(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, char a4)
{
  char *v8;
  uint64_t result;
  llvm::Value *v10;
  int v11;
  llvm::Instruction *v12;
  _QWORD v13[4];
  __int16 v14;
  llvm::Value *v15;
  llvm::Value *v16;

  v16 = 0;
  v8 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v16, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' in logical operation") & 1) != 0)
    return 1;
  v15 = 0;
  v10 = v16;
  if ((llvm::LLParser::parseValue((uint64_t **)this, *(llvm::Type **)v16, &v15, a3) & 1) != 0)
    return 1;
  if ((*(_DWORD *)(*(_QWORD *)v10 + 8) & 0xFE) == 0x12)
    v11 = *(unsigned __int8 *)(**(_QWORD **)(*(_QWORD *)v10 + 16) + 8);
  else
    v11 = *(_DWORD *)(*(_QWORD *)v10 + 8);
  if (v11 == 13)
  {
    v14 = 257;
    v12 = llvm::BinaryOperator::Create(a4, v10, (uint64_t)v15, (uint64_t)v13, 0);
    result = 0;
    *a2 = v12;
  }
  else
  {
    v13[0] = "instruction requires integer or integer vector operands";
    v14 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v8, (llvm::Twine *)v13);
  }
  return result;
}

uint64_t llvm::LLParser::parseCompare(char **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, int a4)
{
  uint64_t result;
  char *v9;
  llvm::Value *v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  _DWORD *v14;
  llvm::Instruction *v15;
  __int16 v16;
  llvm::Value *v17;
  uint64_t v18;
  _DWORD *v19;
  __int16 v20;
  llvm::Value *v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  _QWORD v25[4];
  __int16 v26;
  llvm::Value *v27;
  llvm::Value *v28;
  unsigned int v29;

  v29 = 0;
  if ((llvm::LLParser::parseCmpPredicate((llvm::LLParser *)this, &v29, a4) & 1) != 0)
    return 1;
  v28 = 0;
  v9 = this[27];
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v28, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after compare value") & 1) != 0)
    return 1;
  v24 = v9;
  v27 = 0;
  v10 = v28;
  if ((llvm::LLParser::parseValue((uint64_t **)this, *(llvm::Type **)v28, &v27, a3) & 1) != 0)
    return 1;
  v11 = *(_QWORD *)v10;
  v12 = *(_DWORD *)(*(_QWORD *)v10 + 8);
  v13 = *(_DWORD *)(*(_QWORD *)v10 + 8) & 0xFE;
  if (a4 == 54)
  {
    if (v13 == 18)
      v12 = *(unsigned __int8 *)(**(_QWORD **)(v11 + 16) + 8);
    if (v12 < 7)
    {
      v14 = operator new(0x80uLL);
      v14[21] = v14[21] & 0x38000000 | 2;
      v15 = (llvm::Instruction *)(v14 + 16);
      *(_QWORD *)v14 = 0;
      *((_QWORD *)v14 + 1) = 0;
      *((_QWORD *)v14 + 2) = 0;
      *((_QWORD *)v14 + 3) = v14 + 16;
      *((_QWORD *)v14 + 4) = 0;
      *((_QWORD *)v14 + 5) = 0;
      *((_QWORD *)v14 + 6) = 0;
      *((_QWORD *)v14 + 7) = v14 + 16;
      v16 = v29;
      v17 = v27;
      v26 = 257;
      sub_1C4774CC4(*(_DWORD **)v10);
      llvm::CmpInst::CmpInst((uint64_t)v15, v18, 54, v16, (uint64_t)v10, (uint64_t)v17, (uint64_t)v25, 0, 0);
LABEL_16:
      result = 0;
      *a2 = v15;
      return result;
    }
    v23 = "fcmp requires floating point operands";
  }
  else
  {
    if (v13 == 18)
      v12 = *(unsigned __int8 *)(**(_QWORD **)(v11 + 16) + 8);
    if (v12 == 13 || v12 == 15)
    {
      v19 = operator new(0x80uLL);
      v19[21] = v19[21] & 0x38000000 | 2;
      v15 = (llvm::Instruction *)(v19 + 16);
      *(_QWORD *)v19 = 0;
      *((_QWORD *)v19 + 1) = 0;
      *((_QWORD *)v19 + 2) = 0;
      *((_QWORD *)v19 + 3) = v19 + 16;
      *((_QWORD *)v19 + 4) = 0;
      *((_QWORD *)v19 + 5) = 0;
      *((_QWORD *)v19 + 6) = 0;
      *((_QWORD *)v19 + 7) = v19 + 16;
      v20 = v29;
      v21 = v27;
      v26 = 257;
      sub_1C4774CC4(*(_DWORD **)v10);
      llvm::CmpInst::CmpInst((uint64_t)v15, v22, 53, v20, (uint64_t)v10, (uint64_t)v21, (uint64_t)v25, 0, 0);
      goto LABEL_16;
    }
    v23 = "icmp requires integer operands";
  }
  v25[0] = v23;
  v26 = 259;
  return llvm::LLLexer::Error((uint64_t)(this + 21), v24, (llvm::Twine *)v25);
}

uint64_t llvm::LLParser::parseSelect(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  char *v6;
  uint64_t result;
  llvm::Value *v8;
  uint64_t *v9;
  llvm::Value *v10;
  const char *v11;
  llvm::Instruction *v12;
  char v13;
  _QWORD v14[4];
  __int16 v15;
  llvm::Value *v16;
  llvm::Value *v17;
  llvm::Value *v18;

  v18 = 0;
  v6 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v18, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after select condition") & 1) != 0)
    return 1;
  v17 = 0;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v17, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after select value") & 1) != 0)
    return 1;
  v16 = 0;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v16, a3) & 1) != 0)
    return 1;
  v9 = (uint64_t *)v17;
  v8 = v18;
  v10 = v16;
  v11 = llvm::SelectInst::areInvalidOperands((uint64_t *)v18, (uint64_t *)v17, v16);
  if (v11)
  {
    v13 = 1;
    HIBYTE(v15) = 1;
    if (*v11)
    {
      v14[0] = v11;
      v13 = 3;
    }
    LOBYTE(v15) = v13;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v14);
  }
  else
  {
    v15 = 257;
    v12 = sub_1C4FC8748((uint64_t)v8, v9, (uint64_t)v10, (uint64_t)v14, 0, 0);
    result = 0;
    *a2 = v12;
  }
  return result;
}

uint64_t llvm::LLParser::parseVAArg(uint64_t **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t result;
  char *v6;
  llvm::Type *v7;
  int v8;
  _DWORD *v10;
  llvm::Instruction *v11;
  uint64_t ***v12;
  llvm::Type *v13;
  llvm::Value *v14;
  _QWORD v15[4];
  __int16 v16;

  v13 = 0;
  v14 = 0;
  if ((llvm::LLParser::parseTypeAndValue(this, &v14, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after vaarg operand") & 1) != 0)
    return 1;
  v6 = (char *)this[27];
  v15[0] = "expected type";
  v16 = 259;
  if ((llvm::LLParser::parseType((llvm::LLParser *)this, &v13, (const llvm::Twine *)v15, 0) & 1) != 0)
    return 1;
  v7 = v13;
  v8 = *((unsigned __int8 *)v13 + 8);
  if (v8 == 14 || v8 == 7)
  {
    v15[0] = "va_arg requires operand with first class type";
    v16 = 259;
    return llvm::LLLexer::Error((uint64_t)(this + 21), v6, (llvm::Twine *)v15);
  }
  else
  {
    v10 = operator new(0x60uLL);
    v11 = (llvm::Instruction *)(v10 + 8);
    v10[13] = v10[13] & 0x38000000 | 1;
    *(_QWORD *)v10 = 0;
    *((_QWORD *)v10 + 1) = 0;
    *((_QWORD *)v10 + 2) = 0;
    *((_QWORD *)v10 + 3) = v10 + 8;
    v16 = 257;
    v12 = (uint64_t ***)sub_1C4FCD80C((uint64_t)(v10 + 8), (uint64_t)v7, 60, (uint64_t)v14, 0);
    llvm::Value::setName(v12, (uint64_t)v15);
    result = 0;
    *a2 = v11;
  }
  return result;
}

uint64_t llvm::LLParser::parseExtractElement(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  char *v6;
  uint64_t result;
  llvm::Value *v8;
  llvm::Value *v9;
  _DWORD *v10;
  llvm::Instruction *v11;
  _QWORD v12[4];
  __int16 v13;
  llvm::Value *v14;
  llvm::Value *v15;

  v15 = 0;
  v6 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v15, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after extract value") & 1) != 0)
    return 1;
  v14 = 0;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v14, a3) & 1) != 0)
    return 1;
  v8 = v15;
  if ((*(_DWORD *)(*(_QWORD *)v15 + 8) & 0xFE) == 0x12 && (v9 = v14, *(_BYTE *)(*(_QWORD *)v14 + 8) == 13))
  {
    v13 = 257;
    v10 = operator new(0x80uLL);
    v10[21] = v10[21] & 0x38000000 | 2;
    v11 = (llvm::Instruction *)(v10 + 16);
    *(_QWORD *)v10 = 0;
    *((_QWORD *)v10 + 1) = 0;
    *((_QWORD *)v10 + 2) = 0;
    *((_QWORD *)v10 + 3) = v10 + 16;
    *((_QWORD *)v10 + 4) = 0;
    *((_QWORD *)v10 + 5) = 0;
    *((_QWORD *)v10 + 6) = 0;
    *((_QWORD *)v10 + 7) = v10 + 16;
    llvm::ExtractElementInst::ExtractElementInst((llvm::ExtractElementInst *)(v10 + 16), v8, v9, (const llvm::Twine *)v12, 0);
    result = 0;
    *a2 = v11;
  }
  else
  {
    v12[0] = "invalid extractelement operands";
    v13 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v12);
  }
  return result;
}

uint64_t llvm::LLParser::parseInsertElement(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  char *v6;
  uint64_t v7;
  llvm::Value *v9;
  llvm::Value *v10;
  llvm::Value *v11;
  _DWORD *v12;
  uint64_t v13;
  llvm::InsertElementInst *v14;
  _QWORD *v15;
  llvm::Instruction *inserted;
  _QWORD v17[4];
  __int16 v18;
  llvm::Value *v19;
  llvm::Value *v20;
  llvm::Value *v21;

  v21 = 0;
  v6 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v21, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after insertelement value") & 1) != 0)
    return 1;
  v20 = 0;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v20, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after insertelement value") & 1) != 0)
    return 1;
  v19 = 0;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v19, a3) & 1) != 0)
    return 1;
  v9 = v21;
  if ((*(_DWORD *)(*(_QWORD *)v21 + 8) & 0xFE) == 0x12
    && (v10 = v20, *(_QWORD *)v20 == *(_QWORD *)(*(_QWORD *)v21 + 24))
    && (v11 = v19, *(_BYTE *)(*(_QWORD *)v19 + 8) == 13))
  {
    v18 = 257;
    v12 = operator new(0xA0uLL);
    v13 = 0;
    v14 = (llvm::InsertElementInst *)(v12 + 24);
    v12[29] = v12[29] & 0x38000000 | 3;
    do
    {
      v15 = &v12[v13];
      *v15 = 0;
      v15[1] = 0;
      v15[2] = 0;
      v15[3] = v14;
      v13 += 8;
    }
    while (v13 != 24);
    inserted = (llvm::Instruction *)llvm::InsertElementInst::InsertElementInst(v14, v9, v10, v11, (const llvm::Twine *)v17, 0);
    v7 = 0;
    *a2 = inserted;
  }
  else
  {
    v17[0] = "invalid insertelement operands";
    v18 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v17);
  }
  return v7;
}

uint64_t llvm::LLParser::parseShuffleVector(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  char *v6;
  uint64_t result;
  const llvm::Value *v8;
  llvm::Value *v9;
  llvm::Value *v10;
  llvm::Value *v11;
  _DWORD *v12;
  llvm::Instruction *v13;
  _QWORD v14[4];
  __int16 v15;
  llvm::Value *v16;
  llvm::Value *v17;
  llvm::Value *v18;

  v18 = 0;
  v6 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v18, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after shuffle mask") & 1) != 0)
    return 1;
  v17 = 0;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v17, a3) & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after shuffle value") & 1) != 0)
    return 1;
  v16 = 0;
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v16, a3) & 1) != 0)
    return 1;
  v10 = v17;
  v9 = v18;
  v11 = v16;
  if ((llvm::ShuffleVectorInst::isValidOperands(v18, v17, v16, v8) & 1) != 0)
  {
    v12 = operator new(0xA8uLL);
    v12[21] = v12[21] & 0x38000000 | 2;
    v13 = (llvm::Instruction *)(v12 + 16);
    *(_QWORD *)v12 = 0;
    *((_QWORD *)v12 + 1) = 0;
    *((_QWORD *)v12 + 2) = 0;
    *((_QWORD *)v12 + 3) = v12 + 16;
    *((_QWORD *)v12 + 4) = 0;
    *((_QWORD *)v12 + 5) = 0;
    *((_QWORD *)v12 + 6) = 0;
    *((_QWORD *)v12 + 7) = v12 + 16;
    v15 = 257;
    llvm::ShuffleVectorInst::ShuffleVectorInst((llvm::ShuffleVectorInst *)(v12 + 16), v9, v10, v11, (const llvm::Twine *)v14, 0);
    result = 0;
    *a2 = v13;
  }
  else
  {
    v14[0] = "invalid shufflevector operands";
    v15 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v14);
  }
  return result;
}

uint64_t llvm::LLParser::parseFreeze(uint64_t **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v4;
  _DWORD *v5;
  llvm::Instruction *v6;
  _WORD v8[20];
  llvm::Value *v9;

  v9 = 0;
  v4 = llvm::LLParser::parseTypeAndValue(this, &v9, a3);
  if ((v4 & 1) == 0)
  {
    v5 = operator new(0x60uLL);
    v6 = (llvm::Instruction *)(v5 + 8);
    v5[13] = v5[13] & 0x38000000 | 1;
    *(_QWORD *)v5 = 0;
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 2) = 0;
    *((_QWORD *)v5 + 3) = v5 + 8;
    v8[16] = 257;
    llvm::FreezeInst::FreezeInst((uint64_t)(v5 + 8), v9, (uint64_t)v8, 0);
    *a2 = v6;
  }
  return v4;
}

uint64_t llvm::LLParser::parseAlloc(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  int v6;
  int v7;
  char *v8;
  uint64_t v9;
  unsigned __int8 *v11;
  unsigned int v12;
  BOOL v13;
  BOOL v14;
  int v15;
  char *v16;
  char *v17;
  char *v18;
  llvm::Value *v19;
  unsigned __int8 v20;
  __int16 v21;
  _DWORD *v22;
  llvm::Instruction *v23;
  unsigned int v24;
  unsigned __int8 v25;
  int v26;
  _QWORD v27[4];
  __int16 v28;
  const char *v29;
  char *v30;
  uint64_t v31;
  int v32;
  _WORD v33[19];
  unsigned __int8 v34;
  llvm::Type *v35;
  unsigned int v36;
  __int16 v37;
  uint64_t v38;
  llvm::Value *v39;

  v39 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v6 = *((_DWORD *)this + 56);
  v7 = v6;
  if (v6 == 172)
  {
    v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    *((_DWORD *)this + 56) = v7;
  }
  if (v7 == 229)
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  v8 = (char *)*((_QWORD *)this + 27);
  v29 = "expected type";
  v33[0] = 259;
  if ((llvm::LLParser::parseType(this, &v35, (const llvm::Twine *)&v29, 0) & 1) != 0)
    return 1;
  v11 = (unsigned __int8 *)v35;
  v12 = *((unsigned __int8 *)v35 + 8);
  if (v12 == 14
    || (v12 <= 0xC ? (v13 = ((1 << v12) & 0x1380) == 0) : (v13 = 1), v13 ? (v14 = v12 == 11) : (v14 = 1), v14))
  {
    v29 = "invalid type for alloca";
    v33[0] = 259;
    v17 = (char *)this + 168;
    v18 = v8;
    return llvm::LLLexer::Error((uint64_t)v17, v18, (llvm::Twine *)&v29);
  }
  v34 = 0;
  if (*((_DWORD *)this + 56) != 4)
    goto LABEL_28;
  v15 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v15;
  switch(v15)
  {
    case 441:
      v16 = 0;
LABEL_19:
      v34 = 1;
      goto LABEL_29;
    case 91:
      if ((llvm::LLParser::parseOptionalAddrSpace(this, &v36, 0) & 1) == 0)
      {
LABEL_28:
        v16 = 0;
        goto LABEL_29;
      }
      return 1;
    case 90:
      if ((llvm::LLParser::parseOptionalAlignment((uint64_t)this, &v37, 0) & 1) == 0
        && (llvm::LLParser::parseOptionalCommaAddrSpace((uint64_t)this, &v36, &v38, &v34) & 1) == 0)
      {
        goto LABEL_28;
      }
      return 1;
  }
  v16 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v39, a3) & 1) != 0)
    return 1;
  if (*((_DWORD *)this + 56) != 4)
    goto LABEL_29;
  v26 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v26;
  if (v26 == 441)
    goto LABEL_19;
  if (v26 == 91)
  {
    if ((llvm::LLParser::parseOptionalAddrSpace(this, &v36, 0) & 1) == 0)
      goto LABEL_29;
    return 1;
  }
  if (v26 == 90
    && ((llvm::LLParser::parseOptionalAlignment((uint64_t)this, &v37, 0) & 1) != 0
     || (llvm::LLParser::parseOptionalCommaAddrSpace((uint64_t)this, &v36, &v38, &v34) & 1) != 0))
  {
    return 1;
  }
LABEL_29:
  v19 = v39;
  if (v39 && *(_BYTE *)(*(_QWORD *)v39 + 8) != 13)
  {
    v29 = "element count must have integer type";
    v33[0] = 259;
    v17 = (char *)this + 168;
    v18 = v16;
    return llvm::LLLexer::Error((uint64_t)v17, v18, (llvm::Twine *)&v29);
  }
  v29 = (const char *)v33;
  v30 = (char *)v33;
  v31 = 4;
  v32 = 0;
  if (HIBYTE(v37))
  {
    v20 = v37;
LABEL_33:
    v21 = v7 == 229;
    v22 = operator new(0x68uLL);
    v22[13] = v22[13] & 0x38000000 | 1;
    *(_QWORD *)v22 = 0;
    *((_QWORD *)v22 + 1) = 0;
    *((_QWORD *)v22 + 2) = 0;
    *((_QWORD *)v22 + 3) = v22 + 8;
    v28 = 257;
    v23 = (llvm::Instruction *)llvm::AllocaInst::AllocaInst((uint64_t)(v22 + 8), (llvm::PointerType *)v11, (llvm::Type *)v36, v19, v20, (uint64_t)v27, 0);
    *((_WORD *)v22 + 25) = ((v6 == 172) << 6) | (v21 << 7) | *((_WORD *)v22 + 25) & 0xFF3F;
    *a2 = v23;
    v9 = 2 * v34;
    goto LABEL_34;
  }
  v24 = v11[8];
  if (v24 <= 0x11)
  {
    if (((1 << v24) & 0xAC7F) != 0)
    {
LABEL_38:
      llvm::DataLayout::getPrefTypeAlign(*((_QWORD *)this + 41) + 272, (uint64_t)v11);
      v20 = v25;
      goto LABEL_33;
    }
    if (((1 << v24) & 0x30000) != 0)
      goto LABEL_40;
  }
  if ((v24 & 0xFE) == 0x12 || v24 == 21)
  {
LABEL_40:
    if ((llvm::Type::isSizedDerivedType((uint64_t)v11, (llvm::SmallPtrSetImplBase *)&v29) & 1) != 0)
      goto LABEL_38;
  }
  v27[0] = "Cannot allocate unsized type";
  v28 = 259;
  v9 = llvm::LLLexer::Error((uint64_t)this + 168, v8, (llvm::Twine *)v27);
LABEL_34:
  if (v30 != v29)
    free(v30);
  return v9;
}

uint64_t llvm::LLParser::parseAtomicRMW(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  int v6;
  int v7;
  char *v8;
  int v9;
  int v10;
  int v11;
  const char *v12;
  char *v13;
  char *v14;
  char *v16;
  char *v17;
  llvm::Value *v18;
  uint64_t *v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned int v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  unsigned int PrimitiveSizeInBits;
  uint8x8_t v28;
  const char *v29;
  uint64_t v30;
  unint64_t v31;
  char v32;
  _DWORD *v33;
  unsigned __int8 v34;
  llvm::Instruction *v35;
  const char *v36;
  uint64_t v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  char *OperationName;
  uint64_t v43;
  __int16 v44;
  _QWORD v45[4];
  __int16 v46;
  __int16 v47;
  unsigned __int8 v48;
  int v49;
  unsigned __int8 v50;
  llvm::Value *v51;
  llvm::Value *v52;

  v50 = 0;
  v49 = 0;
  v48 = 1;
  v47 = 0;
  v6 = *((_DWORD *)this + 56);
  v7 = v6;
  if (v6 == 68)
  {
    v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    *((_DWORD *)this + 56) = v7;
  }
  v8 = (char *)this + 168;
  v9 = 0;
  v10 = 0;
  v11 = 1;
  switch(v7)
  {
    case 270:
      goto LABEL_19;
    case 271:
      v11 = 0;
      v10 = 0;
      v9 = 4;
      goto LABEL_19;
    case 272:
      v11 = 0;
      v10 = 0;
      v9 = 7;
      goto LABEL_19;
    case 273:
      v11 = 0;
      v10 = 0;
      v9 = 8;
      goto LABEL_19;
    case 274:
      v11 = 0;
      v10 = 0;
      v9 = 9;
      goto LABEL_19;
    case 275:
      v11 = 0;
      v10 = 0;
      v9 = 10;
      goto LABEL_19;
    case 277:
      v11 = 0;
      v10 = 0;
      v9 = 1;
      goto LABEL_19;
    case 278:
      v11 = 0;
      v10 = 1;
      v9 = 11;
      goto LABEL_19;
    case 279:
      v11 = 0;
      v10 = 0;
      v9 = 2;
      goto LABEL_19;
    case 280:
      v11 = 0;
      v10 = 1;
      v9 = 12;
      goto LABEL_19;
    case 292:
      v11 = 0;
      v10 = 0;
      v9 = 3;
      goto LABEL_19;
    case 293:
      v11 = 0;
      v10 = 0;
      v9 = 5;
      goto LABEL_19;
    case 294:
      v11 = 0;
      v10 = 0;
      v9 = 6;
LABEL_19:
      v52 = 0;
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      v16 = (char *)*((_QWORD *)this + 27);
      if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v52, a3) & 1) != 0)
        return 1;
      if ((llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after atomicrmw address") & 1) != 0)
        return 1;
      v51 = 0;
      v17 = (char *)*((_QWORD *)this + 27);
      if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v51, a3) & 1) != 0
        || (llvm::LLParser::parseScope((uint64_t **)this, &v48) & 1) != 0
        || (llvm::LLParser::parseOrdering((uint64_t)this, &v49) & 1) != 0
        || (llvm::LLParser::parseOptionalCommaAlign((uint64_t)this, &v47, &v50) & 1) != 0)
      {
        return 1;
      }
      v38 = v49;
      if (v49 == 1)
      {
        v12 = "atomicrmw cannot be unordered";
LABEL_12:
        v45[0] = v12;
        v46 = 259;
        v13 = (char *)*((_QWORD *)this + 27);
        v14 = (char *)this + 168;
        return llvm::LLLexer::Error((uint64_t)v14, v13, (llvm::Twine *)v45);
      }
      v18 = v52;
      if (*(_BYTE *)(*(_QWORD *)v52 + 8) != 15)
      {
        v45[0] = "atomicrmw operand must be a pointer";
        v46 = 259;
        v14 = v8;
        v13 = v16;
        return llvm::LLLexer::Error((uint64_t)v14, v13, (llvm::Twine *)v45);
      }
      v19 = (uint64_t *)v51;
      v20 = *(unsigned __int8 **)v51;
      v21 = *(unsigned __int8 **)(*(_QWORD *)v52 + 24);
      if (v21 && v21 != v20)
      {
        v36 = "atomicrmw value and pointer type do not match";
LABEL_50:
        v45[0] = v36;
        v46 = 259;
LABEL_51:
        v14 = v8;
        v13 = v17;
        return llvm::LLLexer::Error((uint64_t)v14, v13, (llvm::Twine *)v45);
      }
      v22 = v20[8];
      if (v11)
      {
        if (v22 >= 7 && v22 != 13)
        {
          v44 = 1283;
          v41 = "atomicrmw ";
          OperationName = llvm::AtomicRMWInst::getOperationName(0);
          v43 = v23;
          v24 = " operand must be an integer or floating point type";
LABEL_54:
          v39 = v24;
          v40 = 259;
          sub_1C4825FE4((uint64_t *)&v41, (uint64_t *)&v39, (uint64_t)v45);
          goto LABEL_51;
        }
      }
      else if (v10)
      {
        if (v22 >= 7)
        {
          v44 = 1283;
          v41 = "atomicrmw ";
          OperationName = llvm::AtomicRMWInst::getOperationName(v9);
          v43 = v25;
          v24 = " operand must be a floating point type";
          goto LABEL_54;
        }
      }
      else if (v22 != 13)
      {
        v44 = 1283;
        v41 = "atomicrmw ";
        OperationName = llvm::AtomicRMWInst::getOperationName(v9);
        v43 = v37;
        v24 = " operand must be an integer";
        goto LABEL_54;
      }
      PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v20);
      if ((_DWORD)v26 == 1)
      if (PrimitiveSizeInBits < 8
        || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)PrimitiveSizeInBits), v28.i16[0] = vaddlv_u8(v28), v28.i32[0] >= 2u))
      {
        v36 = "atomicrmw operand must be power-of-two byte-sized integer";
        goto LABEL_50;
      }
      sub_1C4768AD0(*(_QWORD *)(*((_QWORD *)a3 + 1) + 40) + 272, *v19);
      v31 = (unint64_t)(v30 + 7) >> 3;
      if ((_DWORD)v29 == 1)
      v32 = __clz(v31);
      v33 = operator new(0x80uLL);
      v33[21] = v33[21] & 0x38000000 | 2;
      *(_QWORD *)v33 = 0;
      *((_QWORD *)v33 + 1) = 0;
      *((_QWORD *)v33 + 2) = 0;
      *((_QWORD *)v33 + 3) = v33 + 16;
      *((_QWORD *)v33 + 4) = 0;
      *((_QWORD *)v33 + 5) = 0;
      *((_QWORD *)v33 + 6) = 0;
      *((_QWORD *)v33 + 7) = v33 + 16;
      v34 = 63 - v32;
      if (HIBYTE(v47))
        v34 = v47;
      v35 = (llvm::Instruction *)llvm::AtomicRMWInst::AtomicRMWInst((uint64_t)(v33 + 16), v9, (uint64_t)v18, v19, v34, v38, v48, 0);
      *((_WORD *)v33 + 41) = *((_WORD *)v33 + 41) & 0xFFFE | (v6 == 68);
      *a2 = v35;
      return 2 * v50;
    default:
      v12 = "expected binary operation in atomicrmw";
      goto LABEL_12;
  }
}

uint64_t llvm::LLParser::parseFence(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v5;
  __int16 v7;
  llvm::Instruction *v8;
  llvm::Instruction *v9;
  const char *v10;
  const char *v11;
  __int16 v12;
  unsigned __int8 v13;
  int v14;

  v14 = 0;
  v5 = 1;
  v13 = 1;
  if ((llvm::LLParser::parseScope((uint64_t **)this, &v13) & 1) == 0
    && (llvm::LLParser::parseOrdering((uint64_t)this, &v14) & 1) == 0)
  {
    v7 = v14;
    if (v14 == 2)
    {
      v10 = "fence cannot be monotonic";
    }
    else
    {
      if (v14 != 1)
      {
        v8 = (llvm::Instruction *)operator new(0x40uLL);
        *((_DWORD *)v8 + 5) &= 0x38000000u;
        v9 = llvm::FenceInst::FenceInst(v8, *(_QWORD *)this, v7, v13, 0);
        v5 = 0;
        *a2 = v9;
        return v5;
      }
      v10 = "fence cannot be unordered";
    }
    v11 = v10;
    v12 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v11);
  }
  return v5;
}

uint64_t llvm::LLParser::parseExtractValue(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  char *v5;
  uint64_t v6;
  uint64_t *v8;
  unsigned int *v9;
  uint64_t v10;
  const char *v11;
  _QWORD v12[4];
  __int16 v13;
  unsigned __int8 v14;
  llvm::Value *v15;
  void *v16;
  uint64_t v17;
  _QWORD v18[3];

  v18[2] = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16 = v18;
  v17 = 0x400000000;
  v5 = (char *)*((_QWORD *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((uint64_t **)this, &v15, a3) & 1) != 0
    || (v14 = 0, (llvm::LLParser::parseIndexList((uint64_t)this, (uint64_t)&v16, &v14) & 1) != 0))
  {
    v6 = 1;
    goto LABEL_4;
  }
  v8 = (uint64_t *)v15;
  if ((*(_DWORD *)(*(_QWORD *)v15 + 8) & 0xFE) == 0x10)
  {
    v9 = (unsigned int *)v16;
    v10 = v17;
    if (llvm::ExtractValueInst::getIndexedType(*(_QWORD *)v15, (unsigned int *)v16, v17))
    {
      v13 = 257;
      *a2 = sub_1C4FC8964(v8, v9, v10, (uint64_t)v12, 0);
      v6 = 2 * v14;
      goto LABEL_4;
    }
    v11 = "invalid indices for extractvalue";
  }
  else
  {
    v11 = "extractvalue operand must be aggregate type";
  }
  v12[0] = v11;
  v13 = 259;
  v6 = llvm::LLLexer::Error((uint64_t)this + 168, v5, (llvm::Twine *)v12);
LABEL_4:
  if (v16 != v18)
    free(v16);
  return v6;
}

char *sub_1C61CC1B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, llvm::Instruction *a10)
{
  int v16;
  uint64_t v17;
  _QWORD *v18;
  signed int v19;
  char *v20;
  llvm::Instruction *v21;
  uint64_t v22;

  v16 = 0;
  if (a8)
  {
    v17 = 48 * a8;
    v18 = (_QWORD *)(a7 + 32);
    do
    {
      v16 += (*v18 - *(v18 - 1)) >> 3;
      v18 += 6;
      v17 -= 48;
    }
    while (v17);
  }
  v19 = a6 + v16 + 3;
  v20 = llvm::User::operator new((llvm::User *)0x50, v19, 16 * (int)a8);
  v21 = llvm::Instruction::Instruction((llvm::Instruction *)v20, **(llvm::Type ***)(a1 + 16), 5, (llvm::Use *)&v20[-32 * v19], v19, a10);
  *((_QWORD *)v21 + 8) = 0;
  llvm::InvokeInst::init((uint64_t)v21, a1, a2, a3, a4, a5, a6, v22, a7, a8, a9);
  return v20;
}

uint64_t llvm::LLParser::parseExceptionArgs(_DWORD *a1, uint64_t a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t result;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  llvm::Value *v12;
  llvm::Type *v13;
  llvm::Metadata *v14[4];
  __int16 v15;

  if ((llvm::LLParser::parseToken((uint64_t)a1, 6, "expected '[' in catchpad/cleanuppad") & 1) != 0)
    return 1;
  if (a1[56] != 7)
  {
    v8 = *(_DWORD *)(a2 + 8);
    while (!v8 || (llvm::LLParser::parseToken((uint64_t)a1, 4, "expected ',' in argument list") & 1) == 0)
    {
      v13 = 0;
      v14[0] = (llvm::Metadata *)"expected type";
      v15 = 259;
      if (llvm::LLParser::parseType((llvm::LLParser *)a1, &v13, (const llvm::Twine *)v14, 0))
        break;
      v12 = 0;
      if (*((_BYTE *)v13 + 8) == 9)
      {
        v14[0] = 0;
        if ((llvm::LLParser::parseMetadata((llvm::LLParser *)a1, v14, a3) & 1) != 0)
          return 1;
        v9 = llvm::MetadataAsValue::get(*(uint64_t **)a1, (unsigned __int8 *)v14[0]);
      }
      else
      {
        if ((llvm::LLParser::parseValue((uint64_t **)a1, v13, &v12, a3) & 1) != 0)
          return 1;
        v9 = (uint64_t)v12;
      }
      v10 = *(unsigned int *)(a2 + 8);
      if (v10 >= *(unsigned int *)(a2 + 12))
      {
        v11 = v9;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v10 + 1, 8);
        v9 = v11;
        v10 = *(unsigned int *)(a2 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a2 + 8 * v10) = v9;
      v8 = *(_DWORD *)(a2 + 8) + 1;
      *(_DWORD *)(a2 + 8) = v8;
      if (a1[56] == 7)
        goto LABEL_4;
    }
    return 1;
  }
LABEL_4:
  v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 42));
  result = 0;
  a1[56] = v7;
  return result;
}

char *sub_1C61CC41C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, llvm::Instruction *a12)
{
  int v16;
  uint64_t v17;
  _QWORD *v18;
  signed int v19;
  char *v20;
  llvm::Instruction *v21;

  v16 = 0;
  if (a10)
  {
    v17 = 48 * a10;
    v18 = (_QWORD *)(a9 + 32);
    do
    {
      v16 += (*v18 - *(v18 - 1)) >> 3;
      v18 += 6;
      v17 -= 48;
    }
    while (v17);
  }
  v19 = a5 + a7 + v16 + 2;
  v20 = llvm::User::operator new((llvm::User *)0x58, v19, 16 * (int)a10);
  v21 = llvm::Instruction::Instruction((llvm::Instruction *)v20, **(llvm::Type ***)(a1 + 16), 11, (llvm::Use *)&v20[-32 * v19], v19, a12);
  *((_QWORD *)v21 + 8) = 0;
  llvm::CallBrInst::init((uint64_t)v21, a1, a2, a3, a4, a5, a6, a7, a9, a10, a11);
  return v20;
}

uint64_t llvm::LLParser::parseTypeIdSummary(uint64_t a1, uint64_t a2)
{
  if ((llvm::LLParser::parseToken(a1, 403, "expected 'summary' here") & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseTypeTestResolution(a1, a2) & 1) != 0)
    return 1;
  if (*(_DWORD *)(a1 + 224) == 4
    && (*(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168)),
        (llvm::LLParser::parseOptionalWpdResolutions(a1, (uint64_t **)(a2 + 40)) & 1) != 0))
  {
    return 1;
  }
  else
  {
    return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
  }
}

uint64_t llvm::LLParser::parseGVReference(llvm::LLParser *this, llvm::ValueInfo *a2, unsigned int *a3)
{
  int v6;
  _BOOL4 v7;
  uint64_t result;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = *((_DWORD *)this + 56);
  v7 = v6 != 214;
  if (v6 == 235 || v6 == 214)
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  else
    v7 = 0;
  result = llvm::LLParser::parseToken((uint64_t)this, 436, "expected GV ID");
  if ((result & 1) == 0)
  {
    v9 = *((unsigned int *)this + 64);
    *a3 = v9;
    v10 = *((_QWORD *)this + 151);
    if (v9 >= (*((_QWORD *)this + 152) - v10) >> 3)
      v11 = -8;
    else
      v11 = *(_QWORD *)(v10 + 8 * v9);
    if (v6 == 214)
      v11 |= 2uLL;
    *(_QWORD *)a2 = v11;
    if (v7)
      *(_QWORD *)a2 = v11 | 4;
  }
  return result;
}

uint64_t llvm::LLParser::parseWpdRes(uint64_t a1, uint64_t a2)
{
  unsigned int v5;
  int v6;
  int v7;
  char *v8;
  const char *v9;
  const char *v10;
  __int16 v11;

  if ((llvm::LLParser::parseToken(a1, 418, "expected 'wpdRes' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 405, "expected 'kind' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
  {
    return 1;
  }
  v5 = *(_DWORD *)(a1 + 224) - 419;
  if (v5 >= 3)
  {
    v8 = *(char **)(a1 + 216);
    v9 = "unexpected WholeProgramDevirtResolution kind";
    goto LABEL_18;
  }
  *(_DWORD *)a2 = v5;
  v6 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v6;
  if (v6 != 4)
    return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
  while (1)
  {
    v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v7;
    if (v7 == 423)
    {
      if ((llvm::LLParser::parseOptionalResByArg(a1, a2 + 32) & 1) != 0)
        return 1;
      goto LABEL_15;
    }
    if (v7 != 422)
      break;
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
      || (llvm::LLParser::parseStringConstant(a1, (std::string *)(a2 + 8)) & 1) != 0)
    {
      return 1;
    }
LABEL_15:
    if (*(_DWORD *)(a1 + 224) != 4)
      return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
  }
  v8 = *(char **)(a1 + 216);
  v9 = "expected optional WholeProgramDevirtResolution field";
LABEL_18:
  v10 = v9;
  v11 = 259;
  return llvm::LLLexer::Error(a1 + 168, v8, (llvm::Twine *)&v10);
}

uint64_t llvm::LLParser::parseOptionalResByArg(uint64_t a1, uint64_t a2)
{
  char v2;
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned int *v10;
  uint64_t *v11;
  char *v12;
  const char *v13;
  uint64_t v14[4];
  __int16 v15;
  __int128 v16;
  uint64_t v17;
  void *__p;
  void *v19;
  uint64_t v20;

  if ((llvm::LLParser::parseToken(a1, 423, "expected 'resByArg' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
  {
    v2 = 1;
    return v2 & 1;
  }
  while (2)
  {
    __p = 0;
    v19 = 0;
    v20 = 0;
    if ((llvm::LLParser::parseArgs(a1, (uint64_t)&__p) & 1) != 0
      || (llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 424, "expected 'byArg here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 405, "expected 'kind' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
    {
LABEL_7:
      v6 = 1;
      v2 = 1;
      goto LABEL_8;
    }
    *((_QWORD *)&v16 + 1) = 0;
    v17 = 0;
    switch(*(_DWORD *)(a1 + 224))
    {
      case 0x1A3:
        LODWORD(v16) = 0;
        goto LABEL_26;
      case 0x1A9:
        v7 = 1;
        goto LABEL_25;
      case 0x1AA:
        v7 = 2;
        goto LABEL_25;
      case 0x1AB:
        v7 = 3;
LABEL_25:
        LODWORD(v16) = v7;
LABEL_26:
        v8 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        *(_DWORD *)(a1 + 224) = v8;
        if (v8 != 4)
          goto LABEL_39;
        break;
      default:
        v12 = *(char **)(a1 + 216);
        v13 = "unexpected WholeProgramDevirtResolution::ByArg kind";
        goto LABEL_42;
    }
    do
    {
      v9 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      *(_DWORD *)(a1 + 224) = v9;
      if (v9 == 430)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
          goto LABEL_7;
        v10 = (unsigned int *)&v17 + 1;
        goto LABEL_37;
      }
      if (v9 == 429)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
          goto LABEL_7;
        v10 = (unsigned int *)&v17;
LABEL_37:
        if ((llvm::LLParser::parseUInt32((llvm::LLParser *)a1, v10) & 1) != 0)
          goto LABEL_7;
        continue;
      }
      if (v9 != 428)
      {
        v12 = *(char **)(a1 + 216);
        v13 = "expected optional whole program devirt field";
LABEL_42:
        v14[0] = (uint64_t)v13;
        v15 = 259;
        v2 = llvm::LLLexer::Error(a1 + 168, v12, (llvm::Twine *)v14);
        v6 = 1;
        goto LABEL_8;
      }
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
        || (llvm::LLParser::parseUInt64((char **)a1, (unint64_t *)&v16 + 1) & 1) != 0)
      {
        goto LABEL_7;
      }
    }
    while (*(_DWORD *)(a1 + 224) == 4);
LABEL_39:
    if ((llvm::LLParser::parseToken(a1, 13, "expected ')' here") & 1) != 0)
      goto LABEL_7;
    v14[0] = (uint64_t)&__p;
    v11 = sub_1C61CEBFC(a2, (unint64_t **)&__p, (uint64_t)&std::piecewise_construct, v14);
    v6 = 0;
    *(_OWORD *)(v11 + 7) = v16;
    v11[9] = v17;
LABEL_8:
    if (__p)
    {
      v19 = __p;
      operator delete(__p);
    }
    if (!v6)
    {
      if (*(_DWORD *)(a1 + 224) == 4)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        continue;
      }
      v2 = llvm::LLParser::parseToken(a1, 13, "expected ')' here");
    }
    return v2 & 1;
  }
}

__n128 llvm::LLParser::parseModuleReference(llvm::LLParser *this, __n128 *a2)
{
  __n128 result;
  char *v5;
  unsigned int v6;
  char *v7;
  unsigned int v8;
  BOOL v9;
  char **v10;

  if ((llvm::LLParser::parseToken((uint64_t)this, 96, "expected 'module' here") & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 436, "expected module ID") & 1) == 0)
  {
    v5 = (char *)*((_QWORD *)this + 158);
    if (!v5)
      goto LABEL_16;
    v6 = *((_DWORD *)this + 64);
    v7 = (char *)this + 1264;
    do
    {
      v8 = *((_DWORD *)v5 + 8);
      v9 = v8 >= v6;
      if (v8 >= v6)
        v10 = (char **)v5;
      else
        v10 = (char **)(v5 + 8);
      if (v9)
        v7 = v5;
      v5 = *v10;
    }
    while (*v10);
    if (v7 == (char *)this + 1264 || v6 < *((_DWORD *)v7 + 8))
LABEL_16:
      v7 = (char *)this + 1264;
    result = *(__n128 *)(v7 + 40);
    *a2 = result;
  }
  return result;
}

uint64_t llvm::LLParser::parseGVFlags(uint64_t a1, _WORD *a2)
{
  llvm::LLLexer *v4;
  uint64_t v5;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  char *v12;
  const char *v13;
  __int16 v14;
  char v15;
  unsigned int v16;

  v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
    return 1;
  v5 = 1;
  if ((llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
    return v5;
  v7 = *(_DWORD *)(a1 + 224);
  while (2)
  {
    v16 = 0;
    switch(v7)
    {
      case 359:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0)
          return 1;
        *a2 = *a2 & 0xFFF0 | sub_1C4FB8490(*(_DWORD *)(a1 + 224), &v15);
        v8 = llvm::LLLexer::LexToken(v4);
        *(_DWORD *)(a1 + 224) = v8;
        goto LABEL_26;
      case 360:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0)
          return 1;
        v9 = *(_DWORD *)(a1 + 224);
        switch(v9)
        {
          case '&':
            v11 = 0;
            v16 = 0;
LABEL_36:
            *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
            goto LABEL_24;
          case '\'':
            v16 = 1;
            v11 = 16;
            goto LABEL_36;
          case '(':
            v16 = 2;
            v11 = 32;
            goto LABEL_36;
        }
        v11 = 0;
        v16 = 0;
LABEL_24:
        v10 = *a2 & 0xFFCF | (16 * ((v11 >> 4) & 3));
LABEL_25:
        *a2 = v10;
        v8 = *(_DWORD *)(a1 + 224);
LABEL_26:
        if (v8 == 4)
        {
          v7 = llvm::LLLexer::LexToken(v4);
          *(_DWORD *)(a1 + 224) = v7;
          continue;
        }
        return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
      case 361:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFFBF | ((v16 & 1) << 6);
        goto LABEL_25;
      case 362:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFF7F | ((v16 & 1) << 7);
        goto LABEL_25;
      case 363:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFEFF | ((v16 & 1) << 8);
        goto LABEL_25;
      case 364:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFDFF | ((v16 & 1) << 9);
        goto LABEL_25;
      default:
        v12 = *(char **)(a1 + 216);
        v13 = "expected gv flag type";
        v14 = 259;
        return llvm::LLLexer::Error((uint64_t)v4, v12, (llvm::Twine *)&v13);
    }
  }
}

uint64_t llvm::LLParser::parseOptionalFFlags(uint64_t a1, _WORD *a2)
{
  llvm::LLLexer *v4;
  int v6;
  __int16 v7;
  char *v8;
  const char *v9;
  __int16 v10;
  unsigned int v11;

  v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' in funcFlags") & 1) == 0
    && (llvm::LLParser::parseToken(a1, 12, "expected '(' in funcFlags") & 1) == 0)
  {
    v6 = *(_DWORD *)(a1 + 224);
    while (1)
    {
      v11 = 0;
      switch(v6)
      {
        case 368:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFFFE | v11 & 1;
          goto LABEL_9;
        case 369:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFFFD | (2 * (v11 & 1));
          goto LABEL_9;
        case 370:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFFFB | (4 * (v11 & 1));
          goto LABEL_9;
        case 371:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFFF7 | (8 * (v11 & 1));
          goto LABEL_9;
        case 372:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFFEF | (16 * (v11 & 1));
          goto LABEL_9;
        case 373:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFFDF | (32 * (v11 & 1));
          goto LABEL_9;
        case 374:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFFBF | ((v11 & 1) << 6);
          goto LABEL_9;
        case 375:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFF7F | ((v11 & 1) << 7);
          goto LABEL_9;
        case 376:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFEFF | ((v11 & 1) << 8);
          goto LABEL_9;
        case 377:
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
          if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
            || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
          {
            return 1;
          }
          v7 = *a2 & 0xFDFF | ((v11 & 1) << 9);
LABEL_9:
          *a2 = v7;
          if (*(_DWORD *)(a1 + 224) != 4)
            return llvm::LLParser::parseToken(a1, 13, "expected ')' in funcFlags");
          v6 = llvm::LLLexer::LexToken(v4);
          *(_DWORD *)(a1 + 224) = v6;
          break;
        default:
          v8 = *(char **)(a1 + 216);
          v9 = "expected function flag type";
          v10 = 259;
          return llvm::LLLexer::Error((uint64_t)v4, v8, (llvm::Twine *)&v9);
      }
    }
  }
  return 1;
}

uint64_t llvm::LLParser::parseOptionalTypeIdInfo(uint64_t a1, unint64_t **a2)
{
  llvm::LLLexer *v4;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  char *v12;
  const char *v13;
  __int16 v14;

  v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) == 0
    && (llvm::LLParser::parseToken(a1, 12, "expected '(' in typeIdInfo") & 1) == 0)
  {
    v7 = *(_DWORD *)(a1 + 224);
    while (1)
    {
      switch(v7)
      {
        case 393:
          if ((llvm::LLParser::parseTypeTests(a1, a2) & 1) != 0)
            return 1;
          goto LABEL_16;
        case 394:
          v8 = a1;
          v9 = a2 + 3;
          goto LABEL_11;
        case 395:
          v8 = a1;
          v9 = a2 + 6;
LABEL_11:
          if ((llvm::LLParser::parseVFuncIdList(v8, v6, v9) & 1) != 0)
            return 1;
          goto LABEL_16;
        case 396:
          v10 = a1;
          v11 = (uint64_t *)(a2 + 9);
          goto LABEL_15;
        case 397:
          v10 = a1;
          v11 = (uint64_t *)(a2 + 12);
LABEL_15:
          if ((llvm::LLParser::parseConstVCallList(v10, v6, v11) & 1) != 0)
            return 1;
LABEL_16:
          if (*(_DWORD *)(a1 + 224) != 4)
            return llvm::LLParser::parseToken(a1, 13, "expected ')' in typeIdInfo");
          v7 = llvm::LLLexer::LexToken(v4);
          *(_DWORD *)(a1 + 224) = v7;
          break;
        default:
          v12 = *(char **)(a1 + 216);
          v13 = "invalid typeIdInfo list type";
          v14 = 259;
          return llvm::LLLexer::Error((uint64_t)v4, v12, (llvm::Twine *)&v13);
      }
    }
  }
  return 1;
}

uint64_t llvm::LLParser::parseGVarFlags(uint64_t a1, _BYTE *a2)
{
  llvm::LLLexer *v4;
  int i;
  char v7;
  char *v8;
  const char *v9;
  __int16 v10;
  unsigned int v11;

  v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) == 0
    && (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) == 0)
  {
    for (i = *(_DWORD *)(a1 + 224); ; *(_DWORD *)(a1 + 224) = i)
    {
      v11 = 0;
      if (i > 234)
      {
        if (i == 235)
        {
          if ((sub_1C4FCD4F0((_DWORD *)a1, &v11) & 1) != 0)
            return 1;
          v7 = *a2 & 0xFD | (2 * (v11 & 1));
        }
        else
        {
          if (i != 416)
          {
LABEL_22:
            v8 = *(char **)(a1 + 216);
            v9 = "expected gvar flag type";
            v10 = 259;
            return llvm::LLLexer::Error((uint64_t)v4, v8, (llvm::Twine *)&v9);
          }
          if ((sub_1C4FCD4F0((_DWORD *)a1, &v11) & 1) != 0)
            return 1;
          v7 = *a2 & 0xE7 | (8 * (v11 & 3));
        }
      }
      else if (i == 24)
      {
        if ((sub_1C4FCD4F0((_DWORD *)a1, &v11) & 1) != 0)
          return 1;
        v7 = *a2 & 0xFB | (4 * (v11 & 1));
      }
      else
      {
        if (i != 214)
          goto LABEL_22;
        if ((sub_1C4FCD4F0((_DWORD *)a1, &v11) & 1) != 0)
          return 1;
        v7 = *a2 & 0xFE | v11 & 1;
      }
      *a2 = v7;
      if (*(_DWORD *)(a1 + 224) != 4)
        return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
      i = llvm::LLLexer::LexToken(v4);
    }
  }
  return 1;
}

uint64_t sub_1C61CD658(int a1, uint64_t a2, void *__s2, size_t __n)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;

  v4 = *(uint64_t **)((a2 & 0xFFFFFFFFFFFFFFF8) + 24);
  v5 = *(_QWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 32) - (_QWORD)v4;
  if (!v5)
    return 0;
  v8 = 8 * (v5 >> 3);
  while (1)
  {
    v9 = *v4;
    if (*(_QWORD *)(*v4 + 32) == __n && (!__n || !memcmp(*(const void **)(v9 + 24), __s2, __n)))
      break;
    ++v4;
    v8 -= 8;
    if (!v8)
      return 0;
  }
  return v9;
}

uint64_t llvm::LLParser::parseFlag(llvm::LLParser *this, unsigned int *a2)
{
  llvm::LLLexer *v3;
  llvm::APInt *v5;
  unsigned int v6;
  BOOL v7;
  int v8;
  int v9;
  uint64_t result;
  const char *v11;
  __int16 v12;

  v3 = (llvm::LLParser *)((char *)this + 168);
  if (*((_DWORD *)this + 56) == 457 && *((_BYTE *)this + 316))
  {
    v5 = (llvm::LLParser *)((char *)this + 304);
    v6 = *((_DWORD *)this + 78);
    if (v6 > 0x40)
      v7 = llvm::APInt::countLeadingZerosSlowCase(v5) == v6;
    else
      v7 = *(_QWORD *)v5 == 0;
    v8 = v7;
    *a2 = v8 ^ 1;
    v9 = llvm::LLLexer::LexToken(v3);
    result = 0;
    *((_DWORD *)this + 56) = v9;
  }
  else
  {
    v11 = "expected integer";
    v12 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v11);
  }
  return result;
}

uint64_t llvm::LLParser::parseHotness(uint64_t a1, char *a2)
{
  llvm::LLLexer *v3;
  int v4;
  char v5;
  int v6;
  uint64_t result;
  char *v8;
  const char *v9;
  __int16 v10;

  v3 = (llvm::LLLexer *)(a1 + 168);
  v4 = *(_DWORD *)(a1 + 224);
  if (v4 <= 382)
  {
    if (v4 == 54)
    {
      v5 = 2;
      goto LABEL_12;
    }
    if (v4 == 173)
    {
      v5 = 1;
      goto LABEL_12;
    }
LABEL_14:
    v8 = *(char **)(a1 + 216);
    v9 = "invalid call edge hotness";
    v10 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, v8, (llvm::Twine *)&v9);
  }
  if (v4 == 383)
  {
    v5 = 0;
    goto LABEL_12;
  }
  if (v4 == 384)
  {
    v5 = 3;
    goto LABEL_12;
  }
  if (v4 != 385)
    goto LABEL_14;
  v5 = 4;
LABEL_12:
  *a2 = v5;
  v6 = llvm::LLLexer::LexToken(v3);
  result = 0;
  *(_DWORD *)(a1 + 224) = v6;
  return result;
}

uint64_t llvm::LLParser::parseParamNo(char **this, unint64_t *a2)
{
  if ((llvm::LLParser::parseToken((uint64_t)this, 381, "expected 'param' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0)
  {
    return 1;
  }
  else
  {
    return llvm::LLParser::parseUInt64(this, a2);
  }
}

uint64_t llvm::LLParser::parseParamAccessOffset(llvm::LLParser *this, llvm::ConstantRange *a2)
{
  uint64_t v4;
  uint64_t v6;
  size_t v7;
  void *v8;
  unsigned int v9;
  void *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  void *__s2;
  unsigned int v17;
  char v18;
  void *v19;
  unsigned int v20;
  char v21;

  v4 = 1;
  v20 = 1;
  v19 = 0;
  v21 = 0;
  v17 = 1;
  __s2 = 0;
  v18 = 0;
  if ((llvm::LLParser::parseToken((uint64_t)this, 399, "expected 'offset' here") & 1) != 0)
    goto LABEL_2;
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' here") & 1) == 0
    && (sub_1C4FCC224((uint64_t)this, &v19) & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) == 0
    && (sub_1C4FCC224((uint64_t)this, &__s2) & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 7, "expected ']' here") & 1) == 0)
  {
    llvm::APInt::operator++((uint64_t)&__s2);
    v6 = v20;
    if (v20 > 0x40)
    {
      if (memcmp(v19, __s2, (((unint64_t)v20 + 63) >> 3) & 0x3FFFFFF8)
        || llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v19) == (_DWORD)v6)
      {
        v11 = v6;
        v10 = (void *)operator new[]();
        memcpy(v10, v19, ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8);
        goto LABEL_22;
      }
    }
    else if (!v20 || v19 != __s2 || v19 == (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v20))
    {
      v11 = v20;
      v10 = v19;
LABEL_22:
      v9 = v17;
      if (v17 > 0x40)
      {
        v7 = (((unint64_t)v17 + 63) >> 3) & 0x3FFFFFF8;
        v8 = (void *)operator new[]();
        memcpy(v8, __s2, v7);
      }
      else
      {
        v8 = __s2;
      }
      llvm::ConstantRange::ConstantRange((uint64_t)&v12, (uint64_t)&v10, (uint64_t)&v8);
      sub_1C4FCC3C8((uint64_t)a2, (uint64_t)&v12);
      sub_1C4E8C6FC((uint64_t)&v12);
      if (v9 >= 0x41 && v8)
        MEMORY[0x1CAA32F9C](v8, 0x1000C8000313F17);
      if (v11 >= 0x41 && v10)
        MEMORY[0x1CAA32F9C](v10, 0x1000C8000313F17);
      goto LABEL_33;
    }
    v13 = 64;
    v12 = 0;
    v15 = 64;
    v14 = 0;
    sub_1C4FCC3C8((uint64_t)a2, (uint64_t)&v12);
    sub_1C4E8C6FC((uint64_t)&v12);
LABEL_33:
    v4 = 0;
  }
  if (v17 >= 0x41 && __s2)
    MEMORY[0x1CAA32F9C](__s2, 0x1000C8000313F17);
LABEL_2:
  if (v20 >= 0x41 && v19)
    MEMORY[0x1CAA32F9C](v19, 0x1000C8000313F17);
  return v4;
}

uint64_t llvm::LLParser::parseParamAccessCall(llvm::LLParser *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  unsigned int v11;

  if ((llvm::LLParser::parseToken((uint64_t)a1, 12, "expected '(' here") & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)a1, 379, "expected 'callee' here") & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseToken((uint64_t)a1, 16, "expected ':' here") & 1) != 0)
    return 1;
  v11 = 0;
  v10 = 0;
  v7 = *((_QWORD *)a1 + 27);
  if ((llvm::LLParser::parseGVReference(a1, (llvm::ValueInfo *)&v10, &v11) & 1) != 0)
    return 1;
  a2[1] = v10;
  v8 = *(_QWORD *)(a3 + 8);
  if (v8 >= *(_QWORD *)(a3 + 16))
  {
    v9 = sub_1C4FD0A28((char **)a3, v11, v7);
  }
  else
  {
    *(_DWORD *)v8 = v11;
    *(_QWORD *)(v8 + 8) = v7;
    v9 = (char *)(v8 + 16);
  }
  *(_QWORD *)(a3 + 8) = v9;
  if ((llvm::LLParser::parseToken((uint64_t)a1, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseParamNo((char **)a1, a2) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)a1, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseParamAccessOffset(a1, (llvm::ConstantRange *)(a2 + 2)) & 1) != 0)
  {
    return 1;
  }
  else
  {
    return llvm::LLParser::parseToken((uint64_t)a1, 13, "expected ')' here");
  }
}

uint64_t llvm::LLParser::parseVFuncId(uint64_t a1, unint64_t *a2, uint64_t **a3, unsigned int a4)
{
  llvm::LLLexer *v8;
  uint64_t v10;
  uint64_t **v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t *v14;
  __int128 v15;
  unsigned int v16;

  v8 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
  {
    return 1;
  }
  if (*(_DWORD *)(a1 + 224) == 436)
  {
    *a2 = 0;
    v16 = *(_DWORD *)(a1 + 256);
    v10 = *(_QWORD *)(a1 + 216);
    v11 = sub_1C4FD085C(a3, v16, &v16);
    v12 = v11;
    *(_QWORD *)&v15 = a4;
    *((_QWORD *)&v15 + 1) = v10;
    v13 = v11[6];
    if (v13 >= v11[7])
    {
      v14 = (uint64_t *)sub_1C4E3D7FC((void **)v11 + 5, &v15);
    }
    else
    {
      *(_OWORD *)v13 = v15;
      v14 = v13 + 2;
    }
    v12[6] = v14;
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v8);
  }
  else if ((llvm::LLParser::parseToken(a1, 354, "expected 'guid' here") & 1) != 0
         || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
         || (llvm::LLParser::parseUInt64((char **)a1, a2) & 1) != 0)
  {
    return 1;
  }
  if ((llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 399, "expected 'offset' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseUInt64((char **)a1, a2 + 1) & 1) != 0)
  {
    return 1;
  }
  return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
}

uint64_t llvm::LLParser::parseConstVCall(uint64_t a1, unint64_t *a2, uint64_t **a3, unsigned int a4)
{
  if ((llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
    return 1;
  if ((llvm::LLParser::parseVFuncId(a1, a2, a3, a4) & 1) != 0)
    return 1;
  if (*(_DWORD *)(a1 + 224) == 4
    && (*(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168)),
        (llvm::LLParser::parseArgs(a1, (uint64_t)(a2 + 2)) & 1) != 0))
  {
    return 1;
  }
  else
  {
    return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
  }
}

uint64_t *sub_1C61CDF18(uint64_t a1, unsigned __int8 *a2, size_t a3, _OWORD *a4)
{
  uint64_t v8;
  uint64_t *i;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  __int128 v15;

  v8 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  i = (uint64_t *)(*(_QWORD *)a1 + 8 * v8);
  v10 = *i;
  if (*i == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v10)
  {
    while (!v10 || v10 == -8)
    {
      v11 = i[1];
      ++i;
      v10 = v11;
    }
    return i;
  }
  v12 = (char *)operator new(a3 + 41, (std::align_val_t)8uLL);
  v13 = v12;
  v14 = v12 + 40;
  if (a3)
    memcpy(v12 + 40, a2, a3);
  v14[a3] = 0;
  *(_QWORD *)v13 = a3;
  v15 = a4[1];
  *(_OWORD *)(v13 + 8) = *a4;
  *(_OWORD *)(v13 + 24) = v15;
  *i = (uint64_t)v13;
  ++*(_DWORD *)(a1 + 12);
  for (i = (uint64_t *)(*(_QWORD *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v8));
        !*i || *i == -8;
  return i;
}

_QWORD *sub_1C61CE020(_QWORD **a1, _QWORD *a2, unint64_t *a3, _QWORD *a4)
{
  void **v6;
  _QWORD *v7;
  void **v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  v6 = (void **)sub_1C4FCDC00(a1, a2, &v14, &v13, a3);
  v7 = *v6;
  if (!*v6)
  {
    v9 = v6;
    v7 = operator new(0x60uLL);
    v7[4] = *a4;
    sub_1C4FCDD9C((_DWORD *)v7 + 10, (uint64_t)(a4 + 1));
    v10 = v14;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v10;
    *v9 = v7;
    v11 = (_QWORD *)**a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = (uint64_t *)*v9;
    }
    sub_1C4768E74(a1[1], v12);
    a1[2] = (_QWORD *)((char *)a1[2] + 1);
  }
  return v7;
}

char *sub_1C61CE0D8(_QWORD **a1, _QWORD *a2, unint64_t **a3, uint64_t a4)
{
  void **v6;
  char *v7;
  void **v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  v6 = (void **)sub_1C4FCDE90(a1, a2, &v14, &v13, a3);
  v7 = (char *)*v6;
  if (!*v6)
  {
    v9 = v6;
    v7 = (char *)operator new(0x50uLL);
    *((_QWORD *)v7 + 5) = 0;
    *((_QWORD *)v7 + 6) = 0;
    *((_QWORD *)v7 + 4) = 0;
    sub_1C4DFE394((_QWORD *)v7 + 4, *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 3);
    *(_OWORD *)(v7 + 56) = *(_OWORD *)(a4 + 24);
    *((_QWORD *)v7 + 9) = *(_QWORD *)(a4 + 40);
    v10 = v14;
    *(_QWORD *)v7 = 0;
    *((_QWORD *)v7 + 1) = 0;
    *((_QWORD *)v7 + 2) = v10;
    *v9 = v7;
    v11 = (_QWORD *)**a1;
    v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      v12 = (uint64_t *)*v9;
    }
    sub_1C4768E74(a1[1], v12);
    a1[2] = (_QWORD *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1C61CE1A4(uint64_t a1, _QWORD *a2)
{
  unsigned __int8 *v4;

  if (a2)
  {
    sub_1C61CE1A4(a1, *a2);
    sub_1C61CE1A4(a1, a2[1]);
    v4 = (unsigned __int8 *)a2[5];
    if (v4)
      llvm::MetadataTracking::untrack((uint64_t)(a2 + 5), v4);
    operator delete(a2);
  }
}

uint64_t sub_1C61CE1F4(uint64_t a1, uint64_t a2, int a3, unsigned __int8 *a4)
{
  uint64_t v7;
  _DWORD *v8;
  uint64_t result;

  v7 = a2 + 8;
  v8 = operator new(0x30uLL);
  *(_QWORD *)a1 = v8;
  *(_QWORD *)(a1 + 8) = v7;
  v8[8] = a3;
  *((_QWORD *)v8 + 5) = a4;
  result = (uint64_t)(v8 + 10);
  if (a4)
    result = llvm::MetadataTracking::track(result, a4, 2);
  *(_BYTE *)(a1 + 16) = 1;
  return result;
}

uint64_t sub_1C61CE250(uint64_t a1, unsigned __int8 *a2, size_t a3, _OWORD *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  _QWORD *i;

  result = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  v9 = *(_QWORD *)a1;
  v10 = result;
  v11 = *(_QWORD *)(*(_QWORD *)a1 + 8 * result);
  if (v11 == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v11)
  {
    return result;
  }
  v12 = (char *)operator new(a3 + 25, (std::align_val_t)8uLL);
  v13 = v12;
  v14 = v12 + 24;
  if (a3)
    memcpy(v12 + 24, a2, a3);
  v14[a3] = 0;
  *(_QWORD *)v13 = a3;
  *(_OWORD *)(v13 + 8) = *a4;
  *(_QWORD *)(v9 + 8 * v10) = v13;
  ++*(_DWORD *)(a1 + 12);
  result = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v10);
  for (i = (_QWORD *)(*(_QWORD *)a1 + 8 * result); !*i || *i == -8; ++i)
    ;
  return result;
}

void sub_1C61CE348(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = (_QWORD *)(a1 + 8);
  sub_1C61CE1A4(a1, *(_QWORD **)(a1 + 8));
  *(_QWORD *)a1 = *a2;
  v5 = a2 + 1;
  v6 = a2[1];
  *v4 = v6;
  v7 = a2[2];
  *(_QWORD *)(a1 + 16) = v7;
  if (v7)
  {
    *(_QWORD *)(v6 + 16) = v4;
    *a2 = v5;
    *v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(_QWORD *)a1 = v4;
  }
}

uint64_t sub_1C61CE3B0(uint64_t a1, unsigned __int8 *a2, size_t a3, size_t *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  size_t *v13;
  char *v14;
  size_t v15;
  _QWORD *i;

  result = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  v9 = *(_QWORD *)a1;
  v10 = result;
  v11 = *(_QWORD *)(*(_QWORD *)a1 + 8 * result);
  if (v11 == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v11)
  {
    return result;
  }
  v12 = operator new(a3 + 17, (std::align_val_t)8uLL);
  v13 = v12;
  v14 = (char *)(v12 + 2);
  if (a3)
    memcpy(v12 + 2, a2, a3);
  v14[a3] = 0;
  v15 = *a4;
  *v13 = a3;
  v13[1] = v15;
  *(_QWORD *)(v9 + 8 * v10) = v13;
  ++*(_DWORD *)(a1 + 12);
  result = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v10);
  for (i = (_QWORD *)(*(_QWORD *)a1 + 8 * result); !*i || *i == -8; ++i)
    ;
  return result;
}

size_t **sub_1C61CE4A4(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6;
  size_t **i;
  size_t *v8;
  size_t *v9;
  _QWORD *v11;
  size_t *v12;
  char *v13;

  v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  i = (size_t **)(*(_QWORD *)a1 + 8 * v6);
  v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      v9 = i[1];
      ++i;
      v8 = v9;
    }
    return i;
  }
  v11 = operator new(a3 + 25, (std::align_val_t)8uLL);
  v12 = v11;
  v13 = (char *)(v11 + 3);
  if (a3)
    memcpy(v11 + 3, a2, a3);
  v13[a3] = 0;
  v12[1] = 0;
  v12[2] = 0;
  *v12 = a3;
  *i = v12;
  ++*(_DWORD *)(a1 + 12);
  for (i = (size_t **)(*(_QWORD *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

uint64_t sub_1C61CE594(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  char v6;
  BOOL v7;
  const void *v8;
  uint64_t v9;
  int v10;
  uint64_t *v11;
  const void *v12;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const void *v18;
  uint64_t v19;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 8;
  do
  {
    v6 = *((_BYTE *)a2 + 23);
    v7 = v6 < 0;
    v8 = (const void *)*a2;
    if (v6 >= 0)
      v8 = a2;
    v9 = v6 & 0x7F;
    if (v7)
      v9 = a2[1];
    v18 = v8;
    v19 = v9;
    v10 = sub_1C4FCE12C((const void **)(v3 + 32), (uint64_t)&v18);
    v11 = (uint64_t *)(v3 + 8);
    if (v10 >= 0)
    {
      v11 = (uint64_t *)v3;
      v5 = v3;
    }
    v3 = *v11;
  }
  while (*v11);
  if (v5 == v2)
    return v2;
  v12 = *(const void **)(v5 + 32);
  v13 = *(_BYTE *)(v5 + 55);
  v14 = v13;
  if (v13 >= 0)
    v12 = (const void *)(v5 + 32);
  v15 = *(_QWORD *)(v5 + 40);
  v16 = v13 & 0x7F;
  if (v14 >= 0)
    v15 = v16;
  v18 = v12;
  v19 = v15;
  if ((sub_1C4FCE12C((const void **)a2, (uint64_t)&v18) & 0x80000000) != 0)
    return v2;
  return v5;
}

void sub_1C61CE65C(uint64_t **a1, uint64_t *a2)
{
  llvm::MDNode *v3;
  llvm::MDNode *v4;

  sub_1C49C7D1C(a1, a2);
  v4 = (llvm::MDNode *)a2[5];
  a2[5] = 0;
  if (v4)
    llvm::MDNode::deleteTemporary(v4, v3);
  operator delete(a2);
}

uint64_t sub_1C61CE690(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  _DWORD *v8;
  uint64_t result;

  v7 = a2 + 8;
  v8 = operator new(0x80uLL);
  *(_QWORD *)a1 = v8;
  *(_QWORD *)(a1 + 8) = v7;
  v8[8] = a3;
  *((_QWORD *)v8 + 5) = *(_QWORD *)a4;
  *((_QWORD *)v8 + 7) = 0x800000000;
  *((_QWORD *)v8 + 6) = v8 + 16;
  result = (uint64_t)(v8 + 12);
  if (*(_DWORD *)(a4 + 16))
    result = sub_1C4FCE718(result, a4 + 8);
  *(_BYTE *)(a1 + 16) = 1;
  return result;
}

uint64_t *sub_1C61CE704(uint64_t a1, const void **a2, uint64_t *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;

  v5 = (uint64_t **)sub_1C4768D58(a1, &v13, a2);
  v6 = *v5;
  if (!*v5)
  {
    v8 = v5;
    sub_1C4FCE84C((uint64_t)&v12, a1, *a3);
    v9 = v13;
    v6 = v12;
    *v12 = 0;
    v6[1] = 0;
    v6[2] = v9;
    *v8 = v6;
    v10 = **(_QWORD **)a1;
    v11 = v6;
    if (v10)
    {
      *(_QWORD *)a1 = v10;
      v11 = *v8;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v11);
    ++*(_QWORD *)(a1 + 16);
  }
  return v6;
}

uint64_t *sub_1C61CE7A4(uint64_t a1, const void **a2, uint64_t *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;

  v5 = (uint64_t **)sub_1C4768D58(a1, &v13, a2);
  v6 = *v5;
  if (!*v5)
  {
    v8 = v5;
    sub_1C4FCE8BC((uint64_t)&v12, a1, *a3);
    v9 = v13;
    v6 = v12;
    *v12 = 0;
    v6[1] = 0;
    v6[2] = v9;
    *v8 = v6;
    v10 = **(_QWORD **)a1;
    v11 = v6;
    if (v10)
    {
      *(_QWORD *)a1 = v10;
      v11 = *v8;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v11);
    ++*(_QWORD *)(a1 + 16);
  }
  return v6;
}

void sub_1C61CE844(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t *v6;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = a1 + 8;
    do
    {
      v4 = *(_DWORD *)(v2 + 32);
      v5 = v4 >= a2;
      if (v4 >= a2)
        v6 = (uint64_t *)v2;
      else
        v6 = (uint64_t *)(v2 + 8);
      if (v5)
        v3 = v2;
      v2 = *v6;
    }
    while (*v6);
    if (v3 != a1 + 8 && *(_DWORD *)(v3 + 32) <= a2)
    {
      sub_1C49C7D1C((uint64_t **)a1, (uint64_t *)v3);
      operator delete((void *)v3);
    }
  }
}

void sub_1C61CE8B4(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1C61CE8B4(a1, *a2);
    sub_1C61CE8B4(a1, a2[1]);
    sub_1C4FCD54C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t *sub_1C61CE8FC(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;

  v5 = (uint64_t **)sub_1C4FCEC0C(a1, &v13, a2);
  v6 = *v5;
  if (!*v5)
  {
    v8 = v5;
    sub_1C61CE99C((uint64_t)&v12, a1, a3);
    v9 = v13;
    v6 = v12;
    *v12 = 0;
    v6[1] = 0;
    v6[2] = v9;
    *v8 = v6;
    v10 = **(_QWORD **)a1;
    v11 = v6;
    if (v10)
    {
      *(_QWORD *)a1 = v10;
      v11 = *v8;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v11);
    ++*(_QWORD *)(a1 + 16);
  }
  return v6;
}

uint64_t sub_1C61CE99C(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t result;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v5 = a2 + 8;
  v6 = operator new(0xD0uLL);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 8) = v5;
  result = sub_1C4FCD600((uint64_t)(v6 + 4), (uint64_t)a3);
  v8 = a3 + 20;
  v9 = a3[20];
  v6[23] = a3[19];
  v6[24] = v9;
  v10 = v6 + 24;
  v11 = a3[21];
  v6[25] = v11;
  if (v11)
  {
    *(_QWORD *)(v9 + 16) = v10;
    a3[19] = v8;
    *v8 = 0;
    a3[21] = 0;
  }
  else
  {
    v6[23] = v10;
  }
  *(_BYTE *)(a1 + 16) = 1;
  return result;
}

uint64_t *sub_1C61CEA24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;

  v5 = (uint64_t **)sub_1C4FCEC0C(a1, &v12, a2);
  v6 = *v5;
  if (!*v5)
  {
    v8 = v5;
    v6 = (uint64_t *)operator new(0xC0uLL);
    sub_1C4FCD600((uint64_t)(v6 + 4), a3);
    v6[23] = 0;
    v9 = v12;
    *v6 = 0;
    v6[1] = 0;
    v6[2] = v9;
    *v8 = v6;
    v10 = **(_QWORD **)a1;
    v11 = v6;
    if (v10)
    {
      *(_QWORD *)a1 = v10;
      v11 = *v8;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v11);
    ++*(_QWORD *)(a1 + 16);
  }
  return v6;
}

_QWORD *sub_1C61CEACC(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _BOOL4 v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = sub_1C4FCEC9C((uint64_t)(v3 + 4), a2);
    v7 = v3 + 1;
    if (!v6)
    {
      v7 = v3;
      v5 = v3;
    }
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2 || sub_1C4FCEC9C(a2, (uint64_t)(v5 + 4)))
    return v2;
  return v5;
}

void sub_1C61CEB44(uint64_t **a1, uint64_t a2)
{
  sub_1C49C7D1C(a1, (uint64_t *)a2);
  sub_1C61CE8B4(a2 + 184, *(_QWORD **)(a2 + 192));
  sub_1C4FCD54C(a2 + 32);
  operator delete((void *)a2);
}

void sub_1C61CEB80(uint64_t **a1, uint64_t *a2)
{
  void *v3;

  sub_1C49C7D1C(a1, a2);
  v3 = (void *)a2[5];
  if (v3)
  {
    a2[6] = (uint64_t)v3;
    operator delete(v3);
  }
  operator delete(a2);
}

void sub_1C61CEBB4(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    sub_1C61CEBB4(*a1);
    sub_1C61CEBB4(a1[1]);
    v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t *sub_1C61CEBFC(uint64_t a1, unint64_t **a2, uint64_t a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;

  v6 = (uint64_t **)sub_1C4FCE06C(a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v9 = v6;
    v7 = (uint64_t *)operator new(0x50uLL);
    v10 = *a4;
    v7[5] = 0;
    v7[6] = 0;
    v7[4] = 0;
    sub_1C4DFE394(v7 + 4, *(const void **)v10, *(_QWORD *)(v10 + 8), (uint64_t)(*(_QWORD *)(v10 + 8) - *(_QWORD *)v10) >> 3);
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    v11 = v14;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v11;
    *v9 = v7;
    v12 = **(_QWORD **)a1;
    v13 = v7;
    if (v12)
    {
      *(_QWORD *)a1 = v12;
      v13 = *v9;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v13);
    ++*(_QWORD *)(a1 + 16);
  }
  return v7;
}

uint64_t llvm::parseAssembly@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void (*a5)(void **__return_ptr, uint64_t, uint64_t, uint64_t)@<X4>, uint64_t a6@<X5>, llvm::LLVMContextImpl ****a7@<X8>)
{
  const void *v14;
  size_t v15;
  llvm::LLVMContextImpl ***v16;
  __int128 v17;
  uint64_t result;
  _OWORD v19[2];

  v14 = *(const void **)(a1 + 16);
  v15 = *(_QWORD *)(a1 + 24);
  v16 = (llvm::LLVMContextImpl ***)operator new();
  llvm::Module::Module((uint64_t)v16, v14, v15, a3);
  v17 = *(_OWORD *)(a1 + 16);
  v19[0] = *(_OWORD *)a1;
  v19[1] = v17;
  result = sub_1C4FD1908((uint64_t)v19, v16, 0, a2, a4, (char *)1, a5, a6);
  if ((_DWORD)result)
  {
    llvm::Module::~Module((llvm::Module *)v16);
    result = MEMORY[0x1CAA32FC0]();
    v16 = 0;
  }
  *a7 = v16;
  return result;
}

const void ***llvm::parseConstantValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, char **a5)
{
  char *v10;
  uint64_t v11;
  int v12;
  const void ***v13;
  char *v15;
  _OWORD v16[4];
  uint64_t v17;
  const void ***v18;
  _QWORD v19[4];
  __int16 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v20 = 261;
  v19[0] = "";
  v19[1] = 0;
  v18 = (const void ***)v19;
  v10 = sub_1C5E1F380(24, &v18);
  *(_QWORD *)v10 = &off_1E81A17B0;
  *((_QWORD *)v10 + 1) = a1;
  *((_QWORD *)v10 + 2) = a1 + a2;
  v15 = v10;
  sub_1C6175188((uint64_t)v16, (uint64_t *)&v15, 0);
  v11 = (uint64_t)v15;
  v15 = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  v18 = 0;
  sub_1C4FD2DBC((uint64_t)v19, a1, a2, (uint64_t)v16, a3, (uint64_t)a4, 0, *a4, 0);
  v12 = llvm::LLParser::parseStandaloneConstantValue((uint64_t)v19, (llvm::Value ***)&v18, a5);
  sub_1C4FD2F30((uint64_t)v19);
  if (v12)
    v13 = 0;
  else
    v13 = v18;
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)v16);
  return v13;
}

void sub_1C61CEEE8(_QWORD *a1)
{
  _QWORD *v2;

  if (a1)
  {
    sub_1C61CEEE8(*a1);
    sub_1C61CEEE8(a1[1]);
    v2 = (_QWORD *)a1[6];
    if (v2 != a1 + 8)
      free(v2);
    operator delete(a1);
  }
}

void sub_1C61CEF34(_QWORD *a1)
{
  if (a1)
  {
    sub_1C61CEF34(*a1);
    sub_1C61CEF34(a1[1]);
    sub_1C61CE8B4((uint64_t)(a1 + 23), (_QWORD *)a1[24]);
    sub_1C4FCD54C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1C61CEF84(_QWORD *a1)
{
  llvm::MDNode *v2;
  llvm::MDNode *v3;

  if (a1)
  {
    sub_1C61CEF84(*a1);
    sub_1C61CEF84(a1[1]);
    v3 = (llvm::MDNode *)a1[5];
    a1[5] = 0;
    if (v3)
      llvm::MDNode::deleteTemporary(v3, v2);
    operator delete(a1);
  }
}

uint64_t llvm::COFF::encodeSectionName(llvm::COFF *this, unint64_t a2)
{
  _QWORD *v3;
  char *v5;
  int v6;
  unint64_t v7;
  unint64_t *v8;
  __int16 v9;
  uint64_t v10[4];
  __int16 v11;
  _BYTE v12[40];
  unint64_t v13;
  _QWORD *v14;
  __int128 v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v13 = a2;
  if (a2 <= 0x98967F)
  {
    v14 = v16;
    v15 = xmmword_1C6464ED0;
    v11 = 263;
    LOBYTE(v10[0]) = 47;
    v9 = 268;
    v8 = &v13;
    sub_1C4825FE4(v10, (uint64_t *)&v8, (uint64_t)v12);
    llvm::Twine::toVector((uint64_t)v12, (uint64_t)&v14);
    v3 = v14;
    memcpy(this, v14, v15);
    if (v3 != v16)
      free(v3);
    return 1;
  }
  if (!(a2 >> 36))
  {
    *(_WORD *)this = 12079;
    v5 = (char *)this + 7;
    v6 = 6;
    do
    {
      v7 = a2 & 0x3F;
      a2 >>= 6;
      *v5-- = aAbcdefghijklmn[v7];
      --v6;
    }
    while (v6);
    return 1;
  }
  return 0;
}

uint64_t llvm::dwarf::AttributeVersion(int a1)
{
  if ((a1 - 1) > 0x8B)
    return 0;
  else
    return dword_1C85F807C[(__int16)(a1 - 1)];
}

const char *llvm::dwarf::AttributeEncodingString(llvm::dwarf *this)
{
  const char *result;

  switch((int)this)
  {
    case 1:
      result = "DW_ATE_address";
      break;
    case 2:
      result = "DW_ATE_BOOLean";
      break;
    case 3:
      result = "DW_ATE_complex_float";
      break;
    case 4:
      result = "DW_ATE_float";
      break;
    case 5:
      result = "DW_ATE_signed";
      break;
    case 6:
      result = "DW_ATE_signed_char";
      break;
    case 7:
      result = "DW_ATE_unsigned";
      break;
    case 8:
      result = "DW_ATE_unsigned_char";
      break;
    case 9:
      result = "DW_ATE_imaginary_float";
      break;
    case 10:
      result = "DW_ATE_packed_decimal";
      break;
    case 11:
      result = "DW_ATE_numeric_string";
      break;
    case 12:
      result = "DW_ATE_edited";
      break;
    case 13:
      result = "DW_ATE_signed_fixed";
      break;
    case 14:
      result = "DW_ATE_unsigned_fixed";
      break;
    case 15:
      result = "DW_ATE_decimal_float";
      break;
    case 16:
      result = "DW_ATE_UTF";
      break;
    case 17:
      result = "DW_ATE_UCS";
      break;
    case 18:
      result = "DW_ATE_ASCII";
      break;
    default:
      switch((int)this)
      {
        case 129:
          result = "DW_ATE_HP_complex_float";
          break;
        case 130:
          result = "DW_ATE_HP_float128";
          break;
        case 131:
          result = "DW_ATE_HP_complex_float128";
          break;
        case 132:
          result = "DW_ATE_HP_floathpintel";
          break;
        case 133:
          result = "DW_ATE_HP_imaginary_float90";
          break;
        case 134:
          result = "DW_ATE_HP_imaginary_float128";
          break;
        default:
          result = 0;
          break;
      }
      break;
  }
  return result;
}

char *llvm::dwarf::AccessibilityString(llvm::dwarf *this)
{
  if (((_DWORD)this - 1) > 2)
    return 0;
  else
    return off_1E813E020[(int)this - 1];
}

uint64_t llvm::dwarf::LanguageLowerBound(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  switch(a1)
  {
    case 1:
    case 2:
    case 4:
    case 11:
    case 12:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 32:
    case 33:
    case 36:
    case 37:
      v1 = 0;
      v2 = 0x100000000;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
    case 23:
    case 31:
    case 34:
    case 35:
      v2 = 0x100000000;
      v1 = 1;
      break;
    default:
      v2 = 0x100000000;
      v4 = 0x100000000;
      if (a1 != 45056)
        v4 = 0;
      if (a1 != 36439)
        v2 = v4;
      v1 = 0;
      break;
  }
  return v1 | v2;
}

const char *llvm::dwarf::ConventionString(llvm::dwarf *this)
{
  int v1;
  const char *result;
  const char *v3;

  if ((int)this <= 175)
  {
    switch((int)this)
    {
      case 1:
        result = "DW_CC_normal";
        break;
      case 2:
        result = "DW_CC_program";
        break;
      case 3:
        result = "DW_CC_nocall";
        break;
      case 4:
        result = "DW_CC_pass_by_reference";
        break;
      case 5:
        result = "DW_CC_pass_by_value";
        break;
      default:
        v3 = "DW_CC_GNU_borland_fastcall_i386";
        if ((_DWORD)this != 65)
          v3 = 0;
        if ((_DWORD)this == 64)
          result = "DW_CC_GNU_renesas_sh";
        else
          result = v3;
        break;
    }
  }
  else
  {
    v1 = (_DWORD)this - 176;
    result = 0;
    switch(v1)
    {
      case 0:
        result = "DW_CC_BORLAND_safecall";
        break;
      case 1:
        result = "DW_CC_BORLAND_stdcall";
        break;
      case 2:
        result = "DW_CC_BORLAND_pascal";
        break;
      case 3:
        result = "DW_CC_BORLAND_msfastcall";
        break;
      case 4:
        result = "DW_CC_BORLAND_msreturn";
        break;
      case 5:
        result = "DW_CC_BORLAND_thiscall";
        break;
      case 6:
        result = "DW_CC_BORLAND_fastcall";
        break;
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 29:
      case 30:
      case 31:
        return result;
      case 16:
        result = "DW_CC_LLVM_vectorcall";
        break;
      case 17:
        result = "DW_CC_LLVM_Win64";
        break;
      case 18:
        result = "DW_CC_LLVM_X86_64SysV";
        break;
      case 19:
        result = "DW_CC_LLVM_AAPCS";
        break;
      case 20:
        result = "DW_CC_LLVM_AAPCS_VFP";
        break;
      case 21:
        result = "DW_CC_LLVM_IntelOclBicc";
        break;
      case 22:
        result = "DW_CC_LLVM_SpirFunction";
        break;
      case 23:
        result = "DW_CC_LLVM_OpenCLKernel";
        break;
      case 24:
        result = "DW_CC_LLVM_Swift";
        break;
      case 25:
        result = "DW_CC_LLVM_PreserveMost";
        break;
      case 26:
        result = "DW_CC_LLVM_PreserveAll";
        break;
      case 27:
        result = "DW_CC_LLVM_X86RegCall";
        break;
      case 28:
        result = "DW_CC_LLVM_SwiftTail";
        break;
      case 32:
        result = "DW_CC_LLVM_AGX_thread_invariant";
        break;
      default:
        result = 0;
        break;
    }
  }
  return result;
}

char *llvm::dwarf::LNStandardString(llvm::dwarf *this)
{
  if (this > 0xC)
    return 0;
  else
    return off_1E813DDF0[(int)this];
}

char *llvm::dwarf::LNExtendedString(llvm::dwarf *this)
{
  if (((_DWORD)this - 1) > 3)
    return 0;
  else
    return off_1E813DE58[(int)this - 1];
}

const char *llvm::dwarf::MacinfoString(llvm::dwarf *this)
{
  int v1;
  const char *result;

  v1 = (_DWORD)this + 1;
  result = 0;
  switch(v1)
  {
    case 0:
      result = "DW_MACINFO_invalid";
      break;
    case 1:
      return result;
    case 2:
      result = "DW_MACINFO_define";
      break;
    case 3:
      result = "DW_MACINFO_undef";
      break;
    case 4:
      result = "DW_MACINFO_start_file";
      break;
    case 5:
      result = "DW_MACINFO_end_file";
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

char *llvm::dwarf::MacroString(llvm::dwarf *this)
{
  if (((_DWORD)this - 1) > 0xB)
    return 0;
  else
    return off_1E813DE78[(int)this - 1];
}

char *llvm::dwarf::GnuMacroString(llvm::dwarf *this)
{
  if (((_DWORD)this - 1) > 9)
    return 0;
  else
    return off_1E813DED8[(int)this - 1];
}

char *llvm::dwarf::RangeListEncodingString(llvm::dwarf *this)
{
  if (this > 7)
    return 0;
  else
    return off_1E813E110[(int)this];
}

char *llvm::dwarf::LocListEncodingString(llvm::dwarf *this)
{
  if (this > 8)
    return 0;
  else
    return off_1E813DF28[(int)this];
}

const char *llvm::dwarf::ApplePropertyString(llvm::dwarf *this)
{
  int v1;
  const char *result;
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;

  v1 = (int)this;
  result = 0;
  if (v1 > 255)
  {
    if (v1 <= 2047)
    {
      v11 = "DW_APPLE_PROPERTY_weak";
      v12 = "DW_APPLE_PROPERTY_strong";
      if (v1 != 1024)
        v12 = 0;
      if (v1 != 512)
        v11 = v12;
      if (v1 == 256)
        return "DW_APPLE_PROPERTY_atomic";
      else
        return v11;
    }
    else
    {
      v3 = "DW_APPLE_PROPERTY_null_resettable";
      v4 = "DW_APPLE_PROPERTY_class";
      if (v1 != 0x4000)
        v4 = 0;
      if (v1 != 0x2000)
        v3 = v4;
      v5 = "DW_APPLE_PROPERTY_unsafe_unretained";
      v6 = "DW_APPLE_PROPERTY_nullability";
      if (v1 != 4096)
        v6 = 0;
      if (v1 != 2048)
        v5 = v6;
      if (v1 < 0x2000)
        return v5;
      else
        return v3;
    }
  }
  else if (v1 > 15)
  {
    v7 = "DW_APPLE_PROPERTY_nonatomic";
    v8 = "DW_APPLE_PROPERTY_setter";
    if (v1 != 128)
      v8 = 0;
    if (v1 != 64)
      v7 = v8;
    v9 = "DW_APPLE_PROPERTY_retain";
    v10 = "DW_APPLE_PROPERTY_copy";
    if (v1 != 32)
      v10 = 0;
    if (v1 != 16)
      v9 = v10;
    if (v1 <= 63)
      return v9;
    else
      return v7;
  }
  else
  {
    switch(v1)
    {
      case 1:
        result = "DW_APPLE_PROPERTY_readonly";
        break;
      case 2:
        result = "DW_APPLE_PROPERTY_getter";
        break;
      case 4:
        result = "DW_APPLE_PROPERTY_assign";
        break;
      case 8:
        result = "DW_APPLE_PROPERTY_readwrite";
        break;
      default:
        return result;
    }
  }
  return result;
}

char *llvm::dwarf::UnitTypeString(llvm::dwarf *this)
{
  if (((_DWORD)this - 1) > 5)
    return 0;
  else
    return off_1E813DF70[(int)this - 1];
}

char *llvm::dwarf::GDBIndexEntryKindString(int a1)
{
  return off_1E813DFE0[a1];
}

const char *llvm::dwarf::GDBIndexEntryLinkageString(int a1)
{
  if (a1)
    return "STATIC";
  else
    return "EXTERNAL";
}

const char *llvm::dwarf::AttributeValueString(llvm::dwarf *this, llvm::dwarf *a2)
{
  int v2;
  const char *result;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;

  v2 = (int)this;
  result = 0;
  if (v2 <= 65)
  {
    if (v2 > 31)
    {
      if (v2 <= 49)
      {
        if (v2 != 32)
          return result;
        if (a2 < 4)
          return off_1E813E0B0[(int)a2];
        return 0;
      }
      switch(v2)
      {
        case '2':
          if (((_DWORD)a2 - 1) < 3)
            return off_1E813E020[(int)a2 - 1];
          return 0;
        case '6':
          return llvm::dwarf::ConventionString(a2);
        case '>':
          return llvm::dwarf::AttributeEncodingString(a2);
      }
    }
    else
    {
      if (v2 != 9)
      {
        if (v2 != 19)
        {
          if (v2 != 23)
            return result;
          if (((_DWORD)a2 - 1) < 3)
            return off_1E813E078[(int)a2 - 1];
          return 0;
        }
        return llvm::dwarf::LanguageString(a2);
      }
      v4 = "DW_ORD_row_major";
      if ((_DWORD)a2)
        v4 = 0;
      if ((_DWORD)a2 == 1)
        return "DW_ORD_col_major";
      else
        return v4;
    }
  }
  else
  {
    if (v2 <= 100)
    {
      switch(v2)
      {
        case 'B':
          if (a2 < 4)
            return off_1E813E090[(int)a2];
          break;
        case 'L':
          if (a2 < 3)
            return off_1E813E038[(int)a2];
          break;
        case '^':
          if (((_DWORD)a2 - 1) < 5)
            return off_1E813E050[(int)a2 - 1];
          break;
        default:
          return result;
      }
      return 0;
    }
    if (v2 != 101)
    {
      if (v2 != 139)
      {
        if (v2 != 16358)
          return result;
        return llvm::dwarf::LanguageString(a2);
      }
      if (a2 < 3)
        return off_1E813E0D0[(int)a2];
      return 0;
    }
    v5 = "DW_END_little";
    v6 = "DW_END_lo_user";
    v7 = "DW_END_hi_user";
    if ((_DWORD)a2 != 255)
      v7 = 0;
    if ((_DWORD)a2 != 64)
      v6 = v7;
    if ((_DWORD)a2 != 2)
      v5 = v6;
    v8 = "DW_END_default";
    v9 = "DW_END_big";
    if ((_DWORD)a2 != 1)
      v9 = 0;
    if ((_DWORD)a2)
      v8 = v9;
    if ((int)a2 <= 1)
      return v8;
    else
      return v5;
  }
  return result;
}

const char *llvm::dwarf::AtomValueString(llvm::dwarf *this, llvm::dwarf *a2)
{
  if ((_DWORD)this == 3)
    return llvm::dwarf::TagString(a2);
  if ((_DWORD)this)
    return 0;
  return "NULL";
}

char *llvm::dwarf::IndexString(llvm::dwarf *this)
{
  if (((_DWORD)this - 1) > 4)
    return 0;
  else
    return off_1E813E0E8[(int)this - 1];
}

const char *llvm::dwarf::FormatString(int a1)
{
  const char *v1;

  v1 = "DWARF32";
  if (a1)
    v1 = 0;
  if (a1 == 1)
    return "DWARF64";
  else
    return v1;
}

char *llvm::dwarf::RLEString(llvm::dwarf *this)
{
  if (this > 7)
    return 0;
  else
    return off_1E813E110[(int)this];
}

uint64_t sub_1C61CFCDC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

BOOL sub_1C61CFD10(_BYTE *a1, uint64_t a2)
{
  if (a2 == 1)
  {
    return *a1 == 126;
  }
  else
  {
    if (a2 != 4)
      return 0;
    if (*(_DWORD *)a1 == 1819047278 || *(_DWORD *)a1 == 1819047246)
      return 1;
    return *(_DWORD *)a1 == 1280070990;
  }
}

BOOL sub_1C61CFD78(uint64_t a1, uint64_t a2)
{
  if (a2 != 5)
    return a2 == 4 && (*(_DWORD *)a1 == 1702195828 || *(_DWORD *)a1 == 1702195796 || *(_DWORD *)a1 == 1163219540);
  if (*(_DWORD *)a1 == 1936482662 && *(_BYTE *)(a1 + 4) == 101)
    return 1;
  if (*(_DWORD *)a1 == 1936482630 && *(_BYTE *)(a1 + 4) == 101)
    return 1;
  return *(_DWORD *)a1 == 1397506374 && *(_BYTE *)(a1 + 4) == 69;
}

void llvm::wasm::toString(int a1)
{
  __asm { BR              X10 }
}

char *sub_1C61CFE58()
{
  uint64_t v0;
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)v0 = result;
  *(_OWORD *)(v0 + 8) = xmmword_1C640C680;
  strcpy(result, "WASM_SYMBOL_TYPE_FUNCTION");
  return result;
}

void llvm::wasm::relocTypetoString(llvm::wasm *this)
{
  __asm { BR              X10 }
}

char *sub_1C61CFFAC()
{
  uint64_t v0;
  char *result;

  result = (char *)operator new(0x20uLL);
  *(_QWORD *)v0 = result;
  *(_OWORD *)(v0 + 8) = xmmword_1C640C680;
  strcpy(result, "R_WASM_FUNCTION_INDEX_LEB");
  return result;
}

void sub_1C61D0264()
{
  void **v0;

  *v0 = operator new(0x20uLL);
  JUMPOUT(0x1C61D0280);
}

void sub_1C61D029C()
{
  void **v0;

  *v0 = operator new(0x20uLL);
  JUMPOUT(0x1C61D02B8);
}

void sub_1C61D02D4()
{
  uint64_t v0;
  char *v1;

  v1 = (char *)operator new(0x20uLL);
  *(_QWORD *)v0 = v1;
  *(_OWORD *)(v0 + 8) = xmmword_1C640C6B0;
  strcpy(v1, "R_WASM_MEMORY_ADDR_LOCREL_I32");
  JUMPOUT(0x1C61D0258);
}

void sub_1C61D02F4()
{
  uint64_t v0;
  char *v1;

  v1 = (char *)operator new(0x20uLL);
  *(_QWORD *)v0 = v1;
  *(_OWORD *)(v0 + 8) = xmmword_1C640C6B0;
  strcpy(v1, "R_WASM_TABLE_INDEX_REL_SLEB64");
  JUMPOUT(0x1C61D0258);
}

void sub_1C61D0314()
{
  void **v0;

  *v0 = operator new(0x20uLL);
  JUMPOUT(0x1C61D0330);
}

uint64_t llvm::wasm::relocTypeHasAddend(llvm::wasm *this)
{
  return (this < 0x1A) & (0x2E3CB38u >> (char)this);
}

const char *llvm::XCOFF::getMappingClassString(unsigned int a1)
{
  if (a1 > 0x16)
    return "Unknown";
  else
    return off_1E813E980[(char)a1];
}

const char *llvm::XCOFF::getRelocationTypeString(unsigned int a1)
{
  if (a1 > 0x31)
    return "Unknown";
  else
    return off_1E813EA38[(char)a1];
}

uint64_t sub_1C61D03D8(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61D040C(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

double sub_1C61D0440(char **a1, char **a2)
{
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  double result;

  v4 = *a1;
  v5 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v5)
  {
    v6 = v4 - 24;
    v7 = 32 * v5;
    do
    {
      if (*(_QWORD *)&v6[v7])
      {
        sub_1C4FF80DC((uint64_t *)&v6[v7]);
        operator delete(*(void **)&v6[v7]);
      }
      v7 -= 32;
    }
    while (v7);
    v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2))
    free(v4);
  *a1 = *a2;
  result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

void sub_1C61D04D4(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 32, &v5);
  sub_1C61D0540((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61D0540(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v2)
  {
    v3 = *a1;
    v4 = *a1 + 32 * v2;
    do
    {
      *(_DWORD *)a2 = *(_DWORD *)v3;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_OWORD *)(a2 + 8) = *(_OWORD *)(v3 + 8);
      *(_QWORD *)(a2 + 24) = *(_QWORD *)(v3 + 24);
      *(_QWORD *)(v3 + 8) = 0;
      *(_QWORD *)(v3 + 16) = 0;
      *(_QWORD *)(v3 + 24) = 0;
      v3 += 32;
      a2 += 32;
    }
    while (v3 != v4);
    v5 = *a1 - 24;
    v6 = 32 * v2;
    do
    {
      if (*(_QWORD *)(v5 + v6))
      {
        sub_1C4FF80DC((uint64_t *)(v5 + v6));
        operator delete(*(void **)(v5 + v6));
      }
      v6 -= 32;
    }
    while (v6);
  }
}

uint64_t sub_1C61D05D8(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61D060C(uint64_t a1, uint64_t a2)
{
  void **v5;

  if (*(_BYTE *)(a2 + 24))
  {
    if (*(_BYTE *)(a1 + 24))
    {
      sub_1C4FF8834((void **)a1);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
    }
    else
    {
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      *(_BYTE *)(a1 + 24) = 1;
    }
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    v5 = (void **)a1;
    sub_1C4FF8984(&v5);
    *(_BYTE *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1C61D06AC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

unint64_t llvm::BitcodeErrorCategory(llvm *this)
{
  if (!atomic_load(qword_1EF8F6CB0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F6CB0, (void *(*)(void))sub_1C5017DE0, (void (*)(void *))sub_1C5017E14);
  return qword_1EF8F6CB0[0];
}

void llvm::BitcodeModule::getLazyModule(llvm::BitcodeModule *this@<X0>, llvm::LLVMContext *a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  char v5;

  llvm::BitcodeModule::getModuleImpl((__int128 *)this, (uint64_t)a2, 0, a3, a4, (uint64_t)sub_1C5017E80, (uint64_t)&v5, a5);
}

void llvm::getLazyBitcodeModule(_OWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  __int128 v9;
  uint64_t v10;
  _OWORD v11[2];
  char v12;
  __int128 v13[4];
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v9 = a1[1];
  v11[0] = *a1;
  v11[1] = v9;
  sub_1C4FFF85C(v11, (uint64_t)v13);
  if ((v14 & 1) != 0)
  {
    v10 = *(_QWORD *)&v13[0];
    *(_BYTE *)(a5 + 8) |= 1u;
    *(_QWORD *)a5 = v10;
  }
  else
  {
    llvm::BitcodeModule::getModuleImpl(v13, a2, 0, a3, a4, (uint64_t)sub_1C5017E80, (uint64_t)&v12, a5);
  }
}

void llvm::getOwningLazyBitcodeModule(const llvm::MemoryBuffer **a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v10;
  const llvm::MemoryBuffer *v11;
  uint64_t v12;
  const llvm::MemoryBuffer *v13;
  _OWORD v14[2];

  llvm::MemoryBufferRef::MemoryBufferRef((llvm::MemoryBufferRef *)v14, *a1);
  llvm::getLazyBitcodeModule(v14, a2, a3, a4, a5);
  if ((*(_BYTE *)(a5 + 8) & 1) == 0)
  {
    v10 = *(_QWORD *)a5;
    v11 = *a1;
    *a1 = 0;
    v13 = v11;
    llvm::Module::setOwnedMemoryBuffer(v10, (uint64_t *)&v13);
    v12 = (uint64_t)v13;
    v13 = 0;
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  }
}

void llvm::BitcodeModule::parseModule(__int128 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  llvm::BitcodeModule::getModuleImpl(a1, a2, 1, 0, 0, a3, a4, a5);
}

void llvm::getModuleSummaryIndex(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v3;
  uint64_t v4;
  _OWORD v5[2];
  _QWORD v6[8];
  char v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = a1[1];
  v5[0] = *a1;
  v5[1] = v3;
  sub_1C4FFF85C(v5, (uint64_t)v6);
  if ((v7 & 1) != 0)
  {
    v4 = v6[0];
    *(_BYTE *)(a2 + 8) |= 1u;
    *(_QWORD *)a2 = v4;
  }
  else
  {
    llvm::BitcodeModule::getSummary((llvm::BitcodeModule *)v6, a2);
  }
}

void llvm::getModuleSummaryIndexForFile(const char **a1@<X0>, const char **a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  std::error_code v6;
  llvm *v7;
  _OWORD v8[2];
  uint64_t v9;
  const char **v10[4];
  __int16 v11;
  llvm *v12[2];
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v11 = 261;
  v10[0] = a1;
  v10[1] = a2;
  llvm::MemoryBuffer::getFileOrSTDIN(v10, 0, 1, (uint64_t)v12);
  if ((v13 & 1) != 0)
  {
    *(llvm **)&v6.__val_ = v12[1];
    llvm::errorCodeToError(v12[0], v6, &v9);
    *(_BYTE *)(a4 + 8) |= 1u;
    *(_QWORD *)a4 = v9;
    v9 = 0;
  }
  else if (a3 && *((_QWORD *)v12[0] + 2) == *((_QWORD *)v12[0] + 1))
  {
    *(_BYTE *)(a4 + 8) &= ~1u;
    *(_QWORD *)a4 = 0;
  }
  else
  {
    llvm::MemoryBufferRef::MemoryBufferRef((llvm::MemoryBufferRef *)v8, v12[0]);
    llvm::getModuleSummaryIndex(v8, a4);
  }
  if ((v13 & 1) == 0)
  {
    v7 = v12[0];
    v12[0] = 0;
    if (v7)
      (*(void (**)(llvm *))(*(_QWORD *)v7 + 8))(v7);
  }
}

uint64_t sub_1C61D0A64(uint64_t *a1, __int128 *a2, __n128 *a3)
{
  unint64_t v4;
  uint64_t result;

  v4 = a1[1];
  if (v4 >= a1[2])
  {
    result = sub_1C5010850(a1, a2, a3);
  }
  else
  {
    sub_1C501099C(a1[1], a2, a3);
    result = v4 + 48;
  }
  a1[1] = result;
  return result;
}

_QWORD *sub_1C61D0AA8(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;

  v8 = 0;
  v4 = sub_1C614ECAC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  v5 = v8;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61D0B14(a1, a2, v8);
    v7 = *a2;
    v5[2] = 0;
    v5[3] = 0;
    *v5 = v7;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61D0B14(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C500FB34(a1, v6);
  v8 = 0;
  sub_1C614ECAC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61D0BC4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 32 * v6;
    do
    {
      *v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C614ECAC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_QWORD *)a2;
      v10[1] = 0;
      v10[2] = 0;
      v10[3] = 0;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      v10[3] = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

_DWORD *sub_1C61D0C8C(uint64_t a1, int *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C61D0CF8(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61D0D94(a1, a2, v7);
    *v5 = *a2;
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 2) = 0;
  }
  return v5;
}

uint64_t sub_1C61D0CF8(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = (37 * a3) & (a2 - 1);
    v6 = (_DWORD *)(a1 + 24 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -1)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -2;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_DWORD *)(a1 + 24 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1C61D0D94(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C5017310(a1, v6);
  v8 = 0;
  sub_1C61D0CF8(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61D0E44(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  _DWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_DWORD **)result;
    v8 = 24 * v6;
    do
    {
      *v7 = -1;
      v7 += 6;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      v11 = 0;
      result = sub_1C61D0CF8(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_DWORD *)a2;
      *(_OWORD *)(v10 + 2) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

_QWORD *sub_1C61D0EF8(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61D0F5C(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61D1000((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
    v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1C61D0F5C(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = (37 * *a2) & (v3 - 1);
    v7 = (_QWORD *)(*a1 + 24 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -1)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v8 == -2;
        if (v12)
          v10 = v7;
        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (_QWORD *)(v4 + 24 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
          goto LABEL_4;
      }
      result = 0;
      if (v10)
        v7 = v10;
    }
  }
  else
  {
    v7 = 0;
    result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61D1000(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C501787C(a1, v7);
  v9 = 0;
  sub_1C61D0F5C((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C61D10AC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 24 * v6;
    do
    {
      *v7 = -1;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (*(_QWORD *)a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v10 = 0;
      result = sub_1C61D0F5C((uint64_t *)v5, (_QWORD *)a2, &v10);
      v9 = v10;
      *v10 = *(_QWORD *)a2;
      *(_OWORD *)(v9 + 1) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

_QWORD *sub_1C61D1160(uint64_t a1, unint64_t **a2, uint64_t *a3)
{
  uint64_t **v5;
  _QWORD *v6;
  uint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;

  v5 = (uint64_t **)sub_1C4FCE06C(a1, &v13, a2);
  v6 = *v5;
  if (!*v5)
  {
    v8 = v5;
    v6 = operator new(0x50uLL);
    v9 = *a3;
    v6[5] = 0;
    v6[6] = 0;
    v6[4] = 0;
    *((_OWORD *)v6 + 2) = *(_OWORD *)v9;
    v6[6] = *(_QWORD *)(v9 + 16);
    *(_QWORD *)v9 = 0;
    *(_QWORD *)(v9 + 8) = 0;
    *(_QWORD *)(v9 + 16) = 0;
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    v10 = v13;
    *v6 = 0;
    v6[1] = 0;
    v6[2] = v10;
    *v8 = v6;
    v11 = **(_QWORD **)a1;
    v12 = v6;
    if (v11)
    {
      *(_QWORD *)a1 = v11;
      v12 = *v8;
    }
    sub_1C4768E74(*(uint64_t **)(a1 + 8), v12);
    ++*(_QWORD *)(a1 + 16);
  }
  return v6;
}

void sub_1C61D1224(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *(_QWORD *)a1) >> 4);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1C50179F8((void **)a1, v6);
  }
  else if (!v5)
  {
    v7 = *(_QWORD *)a1 + 48 * a2;
    if (v3 != v7)
    {
      do
      {
        v8 = v3 - 48;
        sub_1C4E8C6FC(v3 - 32);
        v3 = v8;
      }
      while (v8 != v7);
    }
    *(_QWORD *)(a1 + 8) = v7;
  }
}

_DWORD *sub_1C61D12B0(uint64_t a1, _DWORD *a2)
{
  int v3;
  int v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  _DWORD *v9;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    v9 = 0;
LABEL_5:
    v6 = sub_1C61D1368(a1, a2, v9);
    *(_QWORD *)v6 = *a2;
    return v6;
  }
  v4 = v3 - 1;
  v5 = (37 * *a2) & (v3 - 1);
  v6 = (_DWORD *)(*(_QWORD *)a1 + 8 * v5);
  v7 = *v6;
  if (*a2 != *v6)
  {
    v10 = 0;
    v11 = 1;
    while (v7 != -1)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v7 == -2;
      if (v12)
        v10 = v6;
      v13 = v5 + v11++;
      v5 = v13 & v4;
      v6 = (_DWORD *)(*(_QWORD *)a1 + 8 * (v13 & v4));
      v7 = *v6;
      if (*a2 == *v6)
        return v6;
    }
    if (v10)
      v9 = v10;
    else
      v9 = v6;
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1C61D1368(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  _DWORD *v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  BOOL v21;
  unsigned int v22;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
      goto LABEL_3;
    sub_1C5017C34(a1, v6);
    v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      v17 = v16 - 1;
      v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v18);
      v19 = *a3;
      if (*a2 == *a3)
        goto LABEL_3;
      v12 = 0;
      v20 = 1;
      while (v19 != -1)
      {
        if (v12)
          v21 = 0;
        else
          v21 = v19 == -2;
        if (v21)
          v12 = a3;
        v22 = v18 + v20++;
        v18 = v22 & v17;
        a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v18);
        v19 = *a3;
        if (*a2 == *a3)
          goto LABEL_3;
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1C5017C34(a1, 2 * v6);
  v8 = *(_DWORD *)(a1 + 16);
  if (!v8)
    goto LABEL_24;
  v9 = v8 - 1;
  v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v10);
  v11 = *a3;
  if (*a2 == *a3)
    goto LABEL_3;
  v12 = 0;
  v13 = 1;
  while (v11 != -1)
  {
    if (v12)
      v14 = 0;
    else
      v14 = v11 == -2;
    if (v14)
      v12 = a3;
    v15 = v10 + v13++;
    v10 = v15 & v9;
    a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v10);
    v11 = *a3;
    if (*a2 == *a3)
      goto LABEL_3;
  }
LABEL_21:
  if (v12)
    a3 = v12;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61D14EC(uint64_t result, int *a2, int *a3)
{
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  int v7;
  int v8;
  unsigned int v9;
  _DWORD *v10;
  int v11;
  int v12;
  _DWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  *(_QWORD *)(result + 8) = 0;
  v3 = *(_DWORD **)result;
  v4 = *(unsigned int *)(result + 16);
  if ((_DWORD)v4)
  {
    v5 = 8 * v4;
    v6 = *(_DWORD **)result;
    do
    {
      *v6 = -1;
      v6 += 2;
      v5 -= 8;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    v7 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      v8 = *(_DWORD *)(result + 16) - 1;
      v9 = v8 & (37 * v7);
      v10 = &v3[2 * v9];
      v11 = *v10;
      if (v7 != *v10)
      {
        v13 = 0;
        v14 = 1;
        while (v11 != -1)
        {
          if (v13)
            v15 = 0;
          else
            v15 = v11 == -2;
          if (v15)
            v13 = v10;
          v16 = v9 + v14++;
          v9 = v16 & v8;
          v10 = &v3[2 * (v16 & v8)];
          v11 = *v10;
          if (v7 == *v10)
            goto LABEL_7;
        }
        if (v13)
          v10 = v13;
      }
LABEL_7:
      v12 = a2[1];
      *v10 = v7;
      v10[1] = v12;
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

uint64_t sub_1C61D15BC(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;

  v4 = *a2;
  v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 9);
  if ((__int128 *)a1 != a2)
    sub_1C4FF8630((uint64_t *)(a1 + 40), *((uint64_t **)a2 + 5), *((uint64_t **)a2 + 6), (uint64_t)(*((_QWORD *)a2 + 6) - *((_QWORD *)a2 + 5)) >> 4);
  sub_1C4FF8474(a1 + 64, (uint64_t)(a2 + 4));
  *(_QWORD *)(a1 + 336) = *((_QWORD *)a2 + 42);
  return a1;
}

char ***llvm::MetadataLoader::operator=(char ***a1, char ***a2)
{
  char **v3;
  char **v4;
  char **v5;

  v3 = *a2;
  *a2 = 0;
  v4 = *a1;
  *a1 = v3;
  if (v4)
  {
    v5 = sub_1C5021F0C(v4);
    MEMORY[0x1CAA32FC0](v5, 0x10F0C4004B5578BLL);
  }
  return a1;
}

uint64_t llvm::MetadataLoader::setStripTBAA(uint64_t this, char a2)
{
  *(_BYTE *)(*(_QWORD *)this + 968) = a2;
  return this;
}

void sub_1C61D1680(uint64_t a1, unint64_t a2)
{
  unsigned __int8 **v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = (unsigned __int8 **)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 8, &v5);
  sub_1C50205A4(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

_DWORD *sub_1C61D16EC(uint64_t a1, uint64_t a2, int *a3)
{
  _DWORD *result;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;

  v14 = 0;
  result = (_DWORD *)sub_1C61D17A8(a2, *a3, &v14);
  v7 = v14;
  if ((_DWORD)result)
  {
    v8 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v9 = 1;
    }
    else
    {
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(unsigned int *)(a2 + 16);
    }
    v10 = 0;
    v11 = v8 + 4 * v9;
  }
  else
  {
    result = sub_1C61D1854((_DWORD *)a2, a3, v14);
    v7 = result;
    *result = *a3;
    v12 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v13 = 1;
    }
    else
    {
      v12 = *(_QWORD *)(a2 + 8);
      v13 = *(unsigned int *)(a2 + 16);
    }
    v11 = v12 + 4 * v13;
    v10 = 1;
  }
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1C61D17A8(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  int v8;
  uint64_t result;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 1;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & (37 * a2);
  v7 = (_DWORD *)(v3 + 4 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -1)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -2;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_DWORD *)(v3 + 4 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_DWORD *sub_1C61D1854(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 1;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C5020AA8((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61D17A8((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -1)
    --a1[1];
  return a3;
}

uint64_t sub_1C61D1910(uint64_t result, int *a2, int *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  void *v8;
  size_t v9;
  int v10;
  int *v11;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (void *)(result + 8);
    v9 = 4;
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_6;
    v8 = *(void **)(result + 8);
    v9 = 4 * v7;
  }
  result = (uint64_t)memset(v8, 255, v9);
LABEL_6:
  while (a2 != a3)
  {
    v10 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      v11 = 0;
      result = sub_1C61D17A8((uint64_t)v5, v10, &v11);
      *v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

_DWORD *sub_1C61D19C0(_DWORD *a1)
{
  int v2;
  _DWORD *v3;
  uint64_t v4;
  _DWORD *result;
  uint64_t v6;
  _DWORD *v7;

  v2 = *a1;
  if (*a1 > 1u)
  {
    if ((v2 & 1) != 0)
    {
      result = a1 + 2;
      v7 = a1 + 3;
LABEL_10:
      while (*result >= 0xFFFFFFFE)
      {
        if (++result == v7)
          return v7;
      }
    }
    else
    {
      result = (_DWORD *)*((_QWORD *)a1 + 1);
      v6 = a1[4];
      if ((_DWORD)v6)
      {
        v7 = &result[v6];
        goto LABEL_10;
      }
    }
  }
  else
  {
    if (v2)
    {
      v3 = a1 + 2;
      v4 = 1;
    }
    else
    {
      v3 = (_DWORD *)*((_QWORD *)a1 + 1);
      v4 = a1[4];
    }
    return &v3[v4];
  }
  return result;
}

_QWORD *sub_1C61D1A34(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  _QWORD *result;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v16 = 0;
  result = (_QWORD *)sub_1C61D1AFC(a2, *a3, &v16);
  v9 = v16;
  if ((_DWORD)result)
  {
    v10 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v11 = 1;
    }
    else
    {
      v10 = *(_QWORD *)(a2 + 8);
      v11 = *(unsigned int *)(a2 + 16);
    }
    v12 = 0;
    v13 = v10 + 16 * v11;
  }
  else
  {
    result = sub_1C61D1BA8((_DWORD *)a2, a3, v16);
    v9 = result;
    *result = *a3;
    result[1] = *a4;
    v14 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v15 = 1;
    }
    else
    {
      v14 = *(_QWORD *)(a2 + 8);
      v15 = *(unsigned int *)(a2 + 16);
    }
    v13 = v14 + 16 * v15;
    v12 = 1;
  }
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v13;
  *(_BYTE *)(a1 + 16) = v12;
  return result;
}

uint64_t sub_1C61D1AFC(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 1;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 16 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 16 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61D1BA8(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 1;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C5020D0C((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61D1AFC((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

uint64_t sub_1C61D1C64(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 24);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[2 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      result = sub_1C61D1AFC((uint64_t)v5, v10, &v12);
      v11 = v12;
      *v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

_QWORD *sub_1C61D1D2C(_DWORD *a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61D1AFC((uint64_t)a1, *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61D1D8C(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61D1D8C(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 1;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C5020F04((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61D1AFC((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

void sub_1C61D1E48(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  llvm::MDNode *v11;
  uint64_t *v12;
  uint64_t v13;
  llvm::MDNode *v14;
  uint64_t *v15;

  v6 = *(_DWORD *)a1;
  *(_QWORD *)a1 = *(_DWORD *)a1 & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(a1 + 8);
    v9 = (_QWORD *)(a1 + 24);
  }
  else
  {
    v7 = *(unsigned int *)(a1 + 16);
    if (!(_DWORD)v7)
      goto LABEL_11;
    v8 = *(_QWORD **)(a1 + 8);
    v9 = &v8[2 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_11:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v15 = 0;
      sub_1C61D1AFC(a1, v10, &v15);
      v12 = v15;
      *v15 = *a2;
      v13 = a2[1];
      a2[1] = 0;
      v12[1] = v13;
      *(_DWORD *)a1 += 2;
      v14 = (llvm::MDNode *)a2[1];
      a2[1] = 0;
      if (v14)
        llvm::MDNode::deleteTemporary(v14, v11);
    }
    a2 += 2;
  }
}

uint64_t sub_1C61D1F24(uint64_t a1, llvm::MDNode *a2)
{
  llvm::MDNode *v3;

  v3 = *(llvm::MDNode **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;
  if (v3)
    llvm::MDNode::deleteTemporary(v3, a2);
  if (*(_QWORD *)a1)
    llvm::MetadataTracking::untrack(a1, *(unsigned __int8 **)a1);
  return a1;
}

void sub_1C61D1F64(uint64_t a1, llvm::MDNode *a2)
{
  unsigned int v3;
  unsigned int v4;
  int v5;
  int v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;

  v3 = *(_DWORD *)a1;
  sub_1C5021064(a1, a2);
  v4 = (v3 >> 1) - 1;
  v5 = 1 << (33 - __clz(v4));
  if (v4 >= 0x10)
    v6 = v5;
  else
    v6 = 64;
  if (v3 >= 2)
    v7 = v6;
  else
    v7 = 0;
  if ((*(_DWORD *)a1 & 1) != 0 && v7 < 2)
  {
    v8 = (_QWORD *)(a1 + 8);
    *(_QWORD *)a1 = 1;
    v9 = (_QWORD *)(a1 + 24);
    goto LABEL_10;
  }
  if ((*(_DWORD *)a1 & 1) != 0)
  {
LABEL_13:
    sub_1C50210E0((_QWORD *)a1, v7);
    return;
  }
  if (v7 != *(_DWORD *)(a1 + 16))
  {
    MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 8), 8);
    goto LABEL_13;
  }
  *(_QWORD *)a1 = 0;
  if (!v7)
    return;
  v8 = *(_QWORD **)(a1 + 8);
  v9 = &v8[2 * v7];
  do
  {
LABEL_10:
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
}

_DWORD *sub_1C61D2030(_DWORD *result)
{
  _DWORD *v1;
  int v2;
  unsigned int v3;
  uint64_t v4;
  void *v5;
  size_t v6;

  v1 = result;
  v2 = *result;
  if (*result > 1u || result[1])
  {
    if ((v2 & 1) != 0)
    {
      v5 = result + 2;
      v6 = 4;
    }
    else
    {
      v3 = (2 * v2) & 0xFFFFFFFC;
      v4 = result[4];
      if (v3 < v4 && v4 >= 0x41)
        return sub_1C61D20BC(result);
      if (!(_DWORD)v4)
        goto LABEL_10;
      v5 = (void *)*((_QWORD *)result + 1);
      v6 = 4 * v4;
    }
    result = memset(v5, 255, v6);
    LODWORD(v4) = *v1 & 1;
LABEL_10:
    *v1 = v4;
    v1[1] = 0;
  }
  return result;
}

_DWORD *sub_1C61D20BC(_DWORD *result)
{
  _DWORD *v1;
  unsigned int v2;
  unsigned int v3;
  int v4;
  int v5;
  unsigned int v6;
  void *v7;
  size_t v8;

  v1 = result;
  v2 = *result;
  v3 = (*result >> 1) - 1;
  v4 = 1 << (33 - __clz(v3));
  if (v3 >= 0x10)
    v5 = v4;
  else
    v5 = 64;
  if (v2 >= 2)
    v6 = v5;
  else
    v6 = 0;
  if ((v2 & 1) != 0 && v6 < 2)
  {
    *(_QWORD *)result = 1;
    v7 = result + 2;
    v8 = 4;
    return memset(v7, 255, v8);
  }
  if ((v2 & 1) != 0)
    return sub_1C5021160(v1, v6);
  if (v6 != result[4])
  {
    MEMORY[0x1CAA32FB4](*((_QWORD *)result + 1), 4);
    return sub_1C5021160(v1, v6);
  }
  *(_QWORD *)result = 0;
  if (v6)
  {
    v7 = (void *)*((_QWORD *)result + 1);
    v8 = 4 * v6;
    return memset(v7, 255, v8);
  }
  return result;
}

uint64_t sub_1C61D2184(uint64_t result, unsigned __int8 ***a2, unsigned __int8 ***a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 **v5;
  unsigned __int8 **v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;

  v3 = result;
  v4 = *(unsigned int *)(result + 8);
  if (v4 >= *(_DWORD *)(result + 12))
    return sub_1C61D2208(result, a2, a3);
  v5 = (unsigned __int8 **)(*(_QWORD *)result + 16 * v4);
  v6 = *a3;
  v7 = **a2;
  *v5 = v7;
  if (v7)
  {
    result = llvm::MetadataTracking::track((uint64_t)v5, v7, 2);
    LODWORD(v4) = *(_DWORD *)(v3 + 8);
  }
  v8 = *v6;
  *v6 = 0;
  v5[1] = v8;
  *(_DWORD *)(v3 + 8) = v4 + 1;
  return result;
}

uint64_t sub_1C61D2208(uint64_t a1, unsigned __int8 ***a2, unsigned __int8 ***a3)
{
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 **v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int v11;
  unsigned int v12;
  unint64_t v14;

  v14 = 0;
  v6 = (unsigned __int8 **)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, 0, 16, &v14);
  v7 = &v6[2 * *(unsigned int *)(a1 + 8)];
  v8 = *a3;
  v9 = **a2;
  *v7 = v9;
  if (v9)
    llvm::MetadataTracking::track((uint64_t)v7, v9, 2);
  v10 = *v8;
  *v8 = 0;
  v7[1] = v10;
  sub_1C61D22CC(a1, v6);
  v11 = v14;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v6;
  v12 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v12;
  *(_DWORD *)(a1 + 12) = v11;
  return (uint64_t)&v6[2 * v12 - 2];
}

uint64_t sub_1C61D22CC(uint64_t result, unsigned __int8 **a2)
{
  uint64_t v2;
  uint64_t v4;
  unsigned __int8 **v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *(unsigned int *)(result + 8);
  if ((_DWORD)v2)
  {
    v4 = result;
    v5 = *(unsigned __int8 ***)result;
    v6 = 16 * v2;
    do
    {
      *a2 = *v5;
      v7 = *v5;
      if (*v5)
      {
        result = llvm::MetadataTracking::retrack((uint64_t)v5, v7, (uint64_t)a2);
        *v5 = 0;
      }
      v8 = v5[1];
      v5[1] = 0;
      a2[1] = v8;
      v5 += 2;
      a2 += 2;
      v6 -= 16;
    }
    while (v6);
    v9 = *(unsigned int *)(v4 + 8);
    if ((_DWORD)v9)
    {
      v10 = *(_QWORD *)v4;
      v11 = 16 * v9;
      v12 = v10 - 16;
      do
      {
        result = sub_1C61D1F24(v12 + v11, (llvm::MDNode *)v7);
        v11 -= 16;
      }
      while (v11);
    }
  }
  return result;
}

_QWORD *sub_1C61D2364(_DWORD *a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C6184BF0((uint64_t)a1, *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61D23C4(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61D23C4(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 16;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C5021708((uint64_t)a1, v6);
  v8 = 0;
  sub_1C6184BF0((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

uint64_t sub_1C61D2480(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 264);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[2 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      result = sub_1C6184BF0((uint64_t)v5, v10, &v12);
      v11 = v12;
      *v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

char **sub_1C61D2548@<X0>(char **a1@<X0>, std::string *a2@<X8>)
{
  char *v3;
  char **v5;
  char *v6;
  char *v7;
  std::string *v8;
  uint64_t v9;
  _QWORD v10[7];

  v10[6] = *MEMORY[0x1E0C80C00];
  v8 = (std::string *)v10;
  v9 = 0x200000000;
  v3 = *a1;
  *a1 = 0;
  v5 = (char **)&v8;
  v6 = v3;
  sub_1C61D260C(&v6, (uint64_t *)&v5, &v7);
  if (v6)
    (*(void (**)(char *))(*(_QWORD *)v6 + 8))(v6);
  sub_1C5021A04(v8, &v8[v9], "\n", 1uLL, a2);
  return sub_1C4E01820((char **)&v8);
}

char **sub_1C61D260C@<X0>(char **result@<X0>, uint64_t *a2@<X1>, char **a3@<X8>)
{
  char *v4;
  char **v6;
  char **v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = *result;
  if (*result)
  {
    *result = 0;
    if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v4 + 48))(v4, &llvm::ErrorList::ID))
    {
      *a3 = 0;
      v6 = (char **)*((_QWORD *)v4 + 1);
      v7 = (char **)*((_QWORD *)v4 + 2);
      if (v6 != v7)
      {
        v8 = 0;
        do
        {
          v11 = v8;
          v9 = *v6;
          *v6 = 0;
          if ((*(unsigned int (**)(char *, void *))(*(_QWORD *)v9 + 48))(v9, &llvm::ErrorInfoBase::ID))
          {
            sub_1C5021978(a2, (uint64_t)v9);
            (*(void (**)(char *))(*(_QWORD *)v9 + 8))(v9);
            v9 = 0;
          }
          v10 = v9;
          sub_1C6174794(&v11, &v10, &v12);
          v8 = v12;
          *a3 = v12;
          v12 = 0;
          if (v10)
            (*(void (**)(char *))(*(_QWORD *)v10 + 8))(v10);
          if (v11)
            (*(void (**)(char *))(*(_QWORD *)v11 + 8))(v11);
          ++v6;
        }
        while (v6 != v7);
      }
      return (char **)(*(uint64_t (**)(char *))(*(_QWORD *)v4 + 8))(v4);
    }
    else
    {
      result = (char **)(*(uint64_t (**)(char *, void *))(*(_QWORD *)v4 + 48))(v4, &llvm::ErrorInfoBase::ID);
      if ((_DWORD)result)
      {
        sub_1C5021978(a2, (uint64_t)v4);
        *a3 = 0;
        return (char **)(*(uint64_t (**)(char *))(*(_QWORD *)v4 + 8))(v4);
      }
      else
      {
        *a3 = v4;
      }
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t sub_1C61D279C(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a2 + 16);
  v4 = (uint64_t *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0)
    v4 = (uint64_t *)*v4;
  v5 = llvm::MetadataAsValue::get(v4, (unsigned __int8 *)a2);
  return LLVMSetArgOperand_0(a1, 2u, v5);
}

uint64_t llvm::BitcodeWriter::BitcodeWriter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  llvm::raw_ostream *v8;
  unsigned int v9;
  char v11;

  *(_QWORD *)a1 = a2;
  v6 = operator new();
  v7 = dword_1ED82EE10;
  *(_QWORD *)v6 = a2;
  *(_QWORD *)(v6 + 8) = a3;
  *(_QWORD *)(v6 + 16) = (v7 << 20);
  *(_QWORD *)(v6 + 24) = 0;
  *(_DWORD *)(v6 + 32) = 2;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_QWORD *)(v6 + 104) = 0;
  *(_QWORD *)(a1 + 8) = v6;
  llvm::StringTableBuilder::StringTableBuilder(a1 + 16, 6u, 1);
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a1 + 96;
  *(_QWORD *)(a1 + 88) = 0x400000000;
  *(_QWORD *)(a1 + 128) = a1 + 144;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 152) = 1;
  *(_WORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  v8 = *(llvm::raw_ostream **)(a1 + 8);
  sub_1C5030204(v8, 0x42u, 8);
  sub_1C5030204(v8, 0x43u, 8);
  v9 = *((_DWORD *)v8 + 6) + 4;
  if (v9 >= 0x20)
  {
    sub_1C503027C((uint64_t *)v8, *((_DWORD *)v8 + 7));
    v11 = *((_DWORD *)v8 + 6);
    *((_DWORD *)v8 + 7) = 0;
    v9 = (v11 + 4) & 0x1F;
  }
  *((_DWORD *)v8 + 6) = v9;
  sub_1C5030204(v8, 0xCu, 4);
  sub_1C5030204(v8, 0xEu, 4);
  sub_1C5030204(v8, 0xDu, 4);
  return a1;
}

void llvm::BitcodeWriter::~BitcodeWriter(llvm::BitcodeWriter *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (void *)*((_QWORD *)this + 21);
  if (v2)
  {
    *((_QWORD *)this + 22) = v2;
    operator delete(v2);
  }
  sub_1C4926AE8((uint64_t)this + 64);
  llvm::StringTableBuilder::~StringTableBuilder((llvm::BitcodeWriter *)((char *)this + 16));
  v3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v3)
  {
    v4 = sub_1C5037EC0(v3);
    MEMORY[0x1CAA32FC0](v4, 0x1020C40DD110337);
  }
}

uint64_t llvm::BitcodeWriter::writeModule(uint64_t a1, const llvm::Module *a2, int a3, _QWORD *a4, char a5, uint64_t a6)
{
  const llvm::Module **v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  double v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22[3];
  uint64_t v23;
  _QWORD *v24[6];
  char v25;
  uint64_t v26;
  _QWORD v27[14];

  v27[13] = *MEMORY[0x1E0C80C00];
  v22[0] = (uint64_t)a2;
  v12 = *(const llvm::Module ***)(a1 + 176);
  if ((unint64_t)v12 < *(_QWORD *)(a1 + 184))
  {
    *v12 = a2;
    v13 = v12 + 1;
  }
  else
  {
    v13 = sub_1C4DFEA3C((void **)(a1 + 168), v22);
  }
  *(_QWORD *)(a1 + 176) = v13;
  v14 = a1 + 16;
  v16 = *(_QWORD **)a1;
  v15 = *(_QWORD *)(a1 + 8);
  sub_1C5030FB4((uint64_t)v22, a2, v14, v15, a3, a4);
  v24[5] = v16;
  v25 = a5;
  v26 = a6;
  v17 = llvm::SHA1::init((llvm::SHA1 *)v27);
  v18 = *(_QWORD **)(v15 + 8);
  v19 = *(_QWORD *)(*(_QWORD *)v15 + 8);
  if (v18)
    v20 = (*(uint64_t (**)(_QWORD, double))(*v18 + 80))(*(_QWORD *)(v15 + 8), v17) + v18[4] - v18[2];
  else
    v20 = 0;
  v27[12] = *(unsigned int *)(v15 + 24) + 8 * (v20 + v19);
  sub_1C5024B88(v22);
  sub_1C61247C0((uint64_t)v24, v24[1]);
  return sub_1C504113C((uint64_t)&v23);
}

llvm::raw_ostream *sub_1C61D2AE4(llvm::raw_ostream *result, char *a2, uint64_t a3, int a4)
{
  llvm::raw_ostream *v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  char v11;
  char *v12;
  _QWORD *v13;
  uint64_t v14;

  v6 = result;
  if (a4)
  {
    if (a3 >= 0x20)
    {
      v8 = a3;
      do
      {
        sub_1C5030204(v6, v8 & 0x1F | 0x20, 6);
        v7 = v8 >> 5;
        v9 = v8 > 0x3FF;
        v8 >>= 5;
      }
      while (v9);
    }
    else
    {
      v7 = a3;
    }
    result = sub_1C5030204(v6, v7, 6);
  }
  if (*((_DWORD *)v6 + 6))
  {
    result = sub_1C503027C((uint64_t *)v6, *((_DWORD *)v6 + 7));
    *((_QWORD *)v6 + 3) = 0;
  }
  if (a3)
  {
    v10 = 4 * a3;
    do
    {
      v11 = *a2;
      a2 += 4;
      result = sub_1C5033B48((uint64_t *)v6, v11);
      v10 -= 4;
    }
    while (v10);
  }
  while (1)
  {
    v13 = (_QWORD *)*((_QWORD *)v6 + 1);
    v14 = *(_QWORD *)(*(_QWORD *)v6 + 8);
    if (v13)
    {
      result = (llvm::raw_ostream *)(*(uint64_t (**)(_QWORD))(*v13 + 80))(*((_QWORD *)v6 + 1));
      v12 = (char *)result + v13[4] - v13[2];
    }
    else
    {
      LOBYTE(v12) = 0;
    }
    if ((((_BYTE)v12 + (_BYTE)v14) & 3) == 0)
      break;
    result = sub_1C5033B48((uint64_t *)v6, 0);
  }
  return result;
}

llvm::raw_ostream *sub_1C61D2BE0(llvm::raw_ostream *result, char *a2, uint64_t a3, int a4)
{
  llvm::raw_ostream *v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  char v11;
  char *v12;
  _QWORD *v13;
  uint64_t v14;

  v6 = result;
  if (a4)
  {
    if (a3 >= 0x20)
    {
      v8 = a3;
      do
      {
        sub_1C5030204(v6, v8 & 0x1F | 0x20, 6);
        v7 = v8 >> 5;
        v9 = v8 > 0x3FF;
        v8 >>= 5;
      }
      while (v9);
    }
    else
    {
      v7 = a3;
    }
    result = sub_1C5030204(v6, v7, 6);
  }
  if (*((_DWORD *)v6 + 6))
  {
    result = sub_1C503027C((uint64_t *)v6, *((_DWORD *)v6 + 7));
    *((_QWORD *)v6 + 3) = 0;
  }
  if (a3)
  {
    v10 = 8 * a3;
    do
    {
      v11 = *a2;
      a2 += 8;
      result = sub_1C5033B48((uint64_t *)v6, v11);
      v10 -= 8;
    }
    while (v10);
  }
  while (1)
  {
    v13 = (_QWORD *)*((_QWORD *)v6 + 1);
    v14 = *(_QWORD *)(*(_QWORD *)v6 + 8);
    if (v13)
    {
      result = (llvm::raw_ostream *)(*(uint64_t (**)(_QWORD))(*v13 + 80))(*((_QWORD *)v6 + 1));
      v12 = (char *)result + v13[4] - v13[2];
    }
    else
    {
      LOBYTE(v12) = 0;
    }
    if ((((_BYTE)v12 + (_BYTE)v14) & 3) == 0)
      break;
    result = sub_1C5033B48((uint64_t *)v6, 0);
  }
  return result;
}

unsigned int *sub_1C61D2CDC(unsigned int *result, char *a2, char *a3)
{
  char *v4;
  unsigned int *v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  v4 = a2;
  v5 = result;
  v6 = (_DWORD)a3 - (_DWORD)a2;
  v7 = result[2];
  v8 = a3 - a2 + v7;
  if (v8 > result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v8, 8);
    v7 = v5[2];
  }
  if (v4 != a3)
  {
    v9 = (_QWORD *)(*(_QWORD *)v5 + 8 * v7);
    do
    {
      v10 = *v4++;
      *v9++ = v10;
    }
    while (v4 != a3);
  }
  v5[2] = v7 + v6;
  return result;
}

llvm::raw_ostream *sub_1C61D2D58(int *a1, char a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  llvm::raw_ostream *result;
  uint64_t v11;
  uint64_t v12;

  v6 = *(unsigned int *)(a3 + 8);
  sub_1C5030204((llvm::raw_ostream *)a1, 3u, a1[8]);
  sub_1C5030204((llvm::raw_ostream *)a1, a2 & 0x1F | 0x20, 6);
  sub_1C5030204((llvm::raw_ostream *)a1, 1u, 6);
  v7 = v6;
  if (v6 >= 0x20)
  {
    v8 = v6;
    do
    {
      sub_1C5030204((llvm::raw_ostream *)a1, v8 & 0x1F | 0x20, 6);
      v7 = v8 >> 5;
      v9 = v8 > 0x3FF;
      v8 >>= 5;
    }
    while (v9);
  }
  result = sub_1C5030204((llvm::raw_ostream *)a1, v7, 6);
  if ((_DWORD)v6)
  {
    v11 = 0;
    v12 = 8 * v6;
    do
    {
      result = sub_1C5030AF8((llvm::raw_ostream *)a1, *(_QWORD *)(*(_QWORD *)a3 + v11), 6);
      v11 += 8;
    }
    while (v12 != v11);
  }
  return result;
}

unsigned int *sub_1C61D2E24(unsigned int *result, char *a2, char *a3)
{
  char *v4;
  unsigned int *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  unsigned int v10;

  v4 = a2;
  v5 = result;
  v6 = a3 - a2;
  v7 = result[2];
  v8 = v7 + ((a3 - a2) >> 2);
  if (v8 > result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v8, 8);
    v7 = v5[2];
  }
  if (v4 != a3)
  {
    v9 = (_QWORD *)(*(_QWORD *)v5 + 8 * v7);
    do
    {
      v10 = *(_DWORD *)v4;
      v4 += 4;
      *v9++ = v10;
    }
    while (v4 != a3);
  }
  v5[2] = v7 + (v6 >> 2);
  return result;
}

uint64_t sub_1C61D2EA4(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a2 < *a1;
}

llvm::raw_ostream *sub_1C61D2EC0(int *a1, uint64_t a2)
{
  uint64_t i;
  llvm::raw_ostream *result;

  sub_1C5030204((llvm::raw_ostream *)a1, 3u, a1[8]);
  sub_1C5030204((llvm::raw_ostream *)a1, 0x11u, 6);
  sub_1C5030204((llvm::raw_ostream *)a1, 5u, 6);
  for (i = 0; i != 20; i += 4)
    result = sub_1C5030AF8((llvm::raw_ostream *)a1, *(unsigned int *)(a2 + i), 6);
  return result;
}

unsigned int *sub_1C61D2F34(unsigned int *result, char *a2, char *a3)
{
  char *v4;
  unsigned int *v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  _DWORD *v9;
  int v10;

  v4 = a2;
  v5 = result;
  v6 = (_DWORD)a3 - (_DWORD)a2;
  v7 = result[2];
  v8 = a3 - a2 + v7;
  if (v8 > result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v8, 4);
    v7 = v5[2];
  }
  if (v4 != a3)
  {
    v9 = (_DWORD *)(*(_QWORD *)v5 + 4 * v7);
    do
    {
      v10 = *v4++;
      *v9++ = v10;
    }
    while (v4 != a3);
    LODWORD(v7) = v5[2];
  }
  v5[2] = v7 + v6;
  return result;
}

void sub_1C61D2FB4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E813F300;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1C61D2FC8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E813F300;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *llvm::BitcodeWriterPass::run@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const llvm::Module *v4;
  _QWORD *v6;
  uint64_t ResultImpl;
  uint64_t v9;

  v4 = (const llvm::Module *)a2;
  if (*(_BYTE *)(a1 + 9))
  {
    v9 = a1;
    ResultImpl = llvm::AnalysisManager<llvm::Module>::getResultImpl(a3, &llvm::ModuleSummaryIndexAnalysis::Key, a2);
    a1 = v9;
    v4 = (const llvm::Module *)a2;
    v6 = (_QWORD *)(ResultImpl + 8);
  }
  else
  {
    v6 = 0;
  }
  llvm::WriteBitcodeToFile(v4, *(llvm::raw_ostream **)a1, *(unsigned __int8 *)(a1 + 8), v6, *(_BYTE *)(a1 + 10), 0);
  return llvm::InstCountPass::run(a4);
}

uint64_t llvm::createBitcodeWriterPass(llvm *this, llvm::raw_ostream *a2, char a3, char a4)
{
  char v6;
  uint64_t v8;
  unint64_t v10;
  unint64_t v12;
  _QWORD *v13;
  _QWORD v14[2];

  v6 = (char)a2;
  v8 = operator new();
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 16) = &unk_1ED7F4D10;
  *(_DWORD *)(v8 + 24) = 4;
  *(_QWORD *)v8 = &off_1E813F338;
  *(_QWORD *)(v8 + 32) = this;
  *(_BYTE *)(v8 + 40) = v6;
  *(_BYTE *)(v8 + 41) = a3;
  *(_BYTE *)(v8 + 42) = a4;
  if (!atomic_load(qword_1ED830BC0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED830BC0, (void *(*)(void))sub_1C624602C, (void (*)(void *))sub_1C62460B0);
  v12 = qword_1ED830BC0[0];
  v10 = atomic_load(&qword_1ED7F4D18);
  if (v10 != -1)
  {
    v14[0] = sub_1C5042D28;
    v14[1] = &v12;
    v13 = v14;
    std::__call_once(&qword_1ED7F4D18, &v13, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return v8;
}

BOOL llvm::isBitcodeWriterPass(llvm *this, llvm::Pass *a2)
{
  return *((_QWORD *)this + 2) == (_QWORD)&unk_1ED7F4D10;
}

uint64_t llvm::ValueEnumerator::getComdatID(llvm::ValueEnumerator *this, const llvm::Comdat *a2)
{
  char *v2;
  _QWORD *v3;
  _QWORD *v4;
  char *v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;

  v4 = (_QWORD *)*((_QWORD *)this + 16);
  v2 = (char *)this + 128;
  v3 = v4;
  if (!v4)
    return 0;
  v5 = v2;
  do
  {
    v6 = v3[4];
    v7 = v6 >= (unint64_t)a2;
    if (v6 >= (unint64_t)a2)
      v8 = v3;
    else
      v8 = v3 + 1;
    if (v7)
      v5 = (char *)v3;
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v5 != v2 && *((_QWORD *)v5 + 4) <= (unint64_t)a2)
    return *((unsigned int *)v5 + 10);
  else
    return 0;
}

llvm *llvm::ValueEnumerator::dump(llvm::ValueEnumerator *this)
{
  llvm *v2;
  llvm *v3;
  llvm *v4;
  _BYTE *v5;
  llvm *v6;
  llvm *v7;
  llvm *result;
  _BYTE *v9;

  v2 = llvm::dbgs(this);
  v3 = llvm::ValueEnumerator::print((int)v2, v2, (uint64_t)this + 72, "Default");
  v4 = llvm::dbgs(v3);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    v4 = llvm::raw_ostream::write(v4, 10);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 10;
  }
  v6 = llvm::dbgs(v4);
  llvm::ValueEnumerator::print((int)v6, v6, (uint64_t)this + 216, "MetaData");
  result = llvm::dbgs(v7);
  v9 = (_BYTE *)*((_QWORD *)result + 4);
  if ((unint64_t)v9 >= *((_QWORD *)result + 3))
    return llvm::raw_ostream::write(result, 10);
  *((_QWORD *)result + 4) = v9 + 1;
  *v9 = 10;
  return result;
}

void llvm::ValueEnumerator::EnumerateFunctionLocalMetadata(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;

  v11 = a3;
  v6 = sub_1C504A298((uint64_t *)(a1 + 216), &v11);
  if (!*((_DWORD *)v6 + 3))
  {
    v7 = v6;
    v8 = *(uint64_t **)(a1 + 176);
    if ((unint64_t)v8 >= *(_QWORD *)(a1 + 184))
    {
      v9 = sub_1C4ABDC28((void **)(a1 + 168), a3);
    }
    else
    {
      *v8 = a3;
      v9 = v8 + 1;
    }
    *(_QWORD *)(a1 + 176) = v9;
    v10 = ((unint64_t)v9 - *(_QWORD *)(a1 + 168)) >> 3;
    *((_DWORD *)v7 + 2) = a2;
    *((_DWORD *)v7 + 3) = v10;
    llvm::ValueEnumerator::EnumerateValue((llvm::ValueEnumerator *)a1, *(const llvm::Value **)(a3 + 128));
  }
}

_QWORD *llvm::ValueEnumerator::EnumerateFunctionLocalListMetadata(llvm::ValueEnumerator *this, unsigned int a2, const llvm::Value ****a3)
{
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  const llvm::Value ***v9;
  uint64_t v10;
  const llvm::Value *****v11;
  unint64_t v12;
  const llvm::DIArgList *v13;

  v13 = (const llvm::DIArgList *)a3;
  result = sub_1C504A298((uint64_t *)this + 27, &v13);
  if (!*((_DWORD *)result + 3))
  {
    v7 = (uint64_t)result;
    v8 = *((unsigned int *)a3 + 8);
    if ((_DWORD)v8)
    {
      v9 = a3[3];
      v10 = 8 * v8;
      do
      {
        if (*(_BYTE *)*v9 != 2)
          llvm::ValueEnumerator::EnumerateMetadata((uint64_t *)this, a2, *v9);
        ++v9;
        v10 -= 8;
      }
      while (v10);
    }
    v11 = (const llvm::Value *****)*((_QWORD *)this + 22);
    if ((unint64_t)v11 >= *((_QWORD *)this + 23))
    {
      result = sub_1C4ABDC28((void **)this + 21, (uint64_t)a3);
    }
    else
    {
      *v11 = a3;
      result = v11 + 1;
    }
    *((_QWORD *)this + 22) = result;
    v12 = ((unint64_t)result - *((_QWORD *)this + 21)) >> 3;
    *(_DWORD *)(v7 + 8) = a2;
    *(_DWORD *)(v7 + 12) = v12;
  }
  return result;
}

_DWORD *sub_1C61D33F0(uint64_t a1, unint64_t *a2)
{
  _DWORD *result;
  _DWORD *v5;
  uint64_t *v6;
  unint64_t v7;
  uint64_t v8;

  result = sub_1C5031104((uint64_t **)a1, *a2, (uint64_t **)a2);
  if (!result[10])
  {
    v5 = result;
    v6 = *(uint64_t **)(a1 + 32);
    v7 = *(_QWORD *)(a1 + 40);
    v5[10] = (((unint64_t)v6 - *(_QWORD *)(a1 + 24)) >> 3) + 1;
    v8 = *a2;
    if ((unint64_t)v6 >= v7)
    {
      result = sub_1C4ABDC28((void **)(a1 + 24), v8);
    }
    else
    {
      *v6 = v8;
      result = v6 + 1;
    }
    *(_QWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t llvm::ValueEnumerator::getGlobalBasicBlockID(llvm::ValueEnumerator *this, const llvm::BasicBlock *a2)
{
  char *v3;
  int v4;
  llvm::BasicBlock *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  llvm::BasicBlock *v12;
  uint64_t v13;

  v12 = a2;
  v3 = (char *)this + 368;
  v4 = *((_DWORD *)sub_1C504D08C((uint64_t)this + 368, (uint64_t *)&v12) + 2);
  if (v4)
    return (v4 - 1);
  v6 = v12;
  v7 = *((_QWORD *)v12 + 7);
  v8 = v7 + 72;
  v9 = *(_QWORD *)(v7 + 80);
  if (v9 != v7 + 72)
  {
    v10 = 1;
    do
    {
      v11 = v9 - 24;
      if (!v9)
        v11 = 0;
      v13 = v11;
      *((_DWORD *)sub_1C61D35F0((uint64_t)v3, &v13) + 2) = v10;
      v9 = *(_QWORD *)(v9 + 8);
      ++v10;
    }
    while (v9 != v8);
    v6 = v12;
  }
  return llvm::ValueEnumerator::getGlobalBasicBlockID(this, v6);
}

uint64_t llvm::ValueEnumerator::computeBitsRequiredForTypeIndicies(llvm::ValueEnumerator *this)
{
  return 32 - __clz((*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 3);
}

_QWORD *sub_1C61D3534(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C6144BDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C6180ABC(a1, a2, v7);
    *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
    *((_BYTE *)v5 + 12) = 0;
  }
  return v5;
}

uint64_t sub_1C61D35A4(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t *v5;
  uint64_t result;

  v5 = (uint64_t *)a1[1];
  if ((unint64_t)v5 >= a1[2])
  {
    result = sub_1C50487D4(a1, a2, a3, a4);
  }
  else
  {
    *v5 = a2;
    v5[1] = a3;
    sub_1C50488E4(v5 + 2, a4);
    result = (uint64_t)(v5 + 5);
  }
  a1[1] = result;
  return result;
}

_QWORD *sub_1C61D35F0(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4926528(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C4DC1798(a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void sub_1C61D3650(void **a1)
{
  char *v1;
  char *v3;
  void *v4;
  void *v5;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = (void *)*((_QWORD *)v3 - 3);
        if (v5)
        {
          *((_QWORD *)v3 - 2) = v5;
          operator delete(v5);
        }
        v3 -= 40;
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1C61D36BC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(unsigned int *)(a1 + 24));
}

uint64_t llvm::cas::createInMemoryActionCache@<X0>(llvm::cas::builtin::BuiltinCASContext **a1@<X8>)
{
  llvm::cas::builtin::BuiltinCASContext *v3;
  _UNKNOWN **DefaultContext;
  uint64_t result;

  v3 = (llvm::cas::builtin::BuiltinCASContext *)operator new();
  DefaultContext = llvm::cas::builtin::BuiltinCASContext::getDefaultContext(v3);
  *(_QWORD *)v3 = &off_1E813F430;
  *((_QWORD *)v3 + 1) = DefaultContext;
  result = llvm::cas::ThreadSafeHashMappedTrieBase::ThreadSafeHashMappedTrieBase((uint64_t)v3 + 16, 68, 1, 4, 0, 0, 0, 0);
  *a1 = v3;
  return result;
}

void llvm::cas::builtin::BuiltinCASContext::printIDImpl(llvm::cas::builtin::BuiltinCASContext *this, llvm::raw_ostream *a2, const llvm::cas::CASID *a3)
{
  uint64_t v4;
  void *v5;
  __int128 v6;
  _QWORD v7[9];

  v7[8] = *MEMORY[0x1E0C80C00];
  v5 = v7;
  v6 = xmmword_1C64638C0;
  sub_1C5050690(*((unsigned __int8 **)a3 + 1), *((_QWORD *)a3 + 2), 1, &v5);
  v4 = *((_QWORD *)a2 + 4);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v4) > 9)
  {
    *(_WORD *)(v4 + 8) = 12079;
    *(_QWORD *)v4 = *(_QWORD *)"llvmcas://";
    *((_QWORD *)a2 + 4) += 10;
  }
  else
  {
    a2 = llvm::raw_ostream::write(a2, "llvmcas://", 0xAuLL);
  }
  llvm::raw_ostream::write(a2, (const char *)v5, v6);
  if (v5 != v7)
    free(v5);
}

_UNKNOWN **llvm::cas::builtin::BuiltinCASContext::getDefaultContext(llvm::cas::builtin::BuiltinCASContext *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_1ED7F4D20);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_1ED7F4D20))
    __cxa_guard_release(&qword_1ED7F4D20);
  return &off_1EF8EB1E8;
}

void llvm::cas::builtin::BuiltinCAS::storeFromOpenFileImpl(llvm::sys::fs::file_status *a1@<X0>, llvm::sys::fs *this@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unsigned __int8 v9;
  unint64_t v10;
  int v11;
  BOOL v12;
  llvm *v13;
  std::error_code v14;
  std::error_code v15;
  int *v16;
  unint64_t v17;
  llvm::sys::fs::mapped_file_region *v18;
  _QWORD v19[2];
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  llvm *v25;
  const std::error_category *v26;
  uint64_t v27;
  _QWORD v28[3];
  _OWORD v29[2];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v9 = atomic_load((unsigned __int8 *)&qword_1ED7F4D30);
  if ((v9 & 1) == 0)
  {
    v18 = (llvm::sys::fs::mapped_file_region *)__cxa_guard_acquire(&qword_1ED7F4D30);
    if ((_DWORD)v18)
    {
      dword_1ED7F4D28 = llvm::sys::fs::mapped_file_region::alignment(v18);
      __cxa_guard_release(&qword_1ED7F4D30);
    }
  }
  v10 = dword_1ED7F4D28;
  if (*(_BYTE *)(a3 + 64))
    goto LABEL_3;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_QWORD *)(a3 + 48) = 0;
  *(_QWORD *)(a3 + 56) = 0;
  *(_OWORD *)a3 = 0u;
  *(_DWORD *)(a3 + 44) = 0xFFFF;
  *(_BYTE *)(a3 + 64) = 1;
  v13 = (llvm *)llvm::sys::fs::status(this, a3, (llvm::sys::fs::file_status *)a3);
  if (!(_DWORD)v13)
  {
LABEL_3:
    v11 = *(_DWORD *)(a3 + 40);
    v12 = v11 == 2 || v11 == 5;
    if (v12 && *(_QWORD *)(a3 + 32) >> 14)
    {
      LODWORD(v25) = 0;
      v26 = std::system_category();
      llvm::sys::fs::mapped_file_region::mapped_file_region((uint64_t)&v22, (int)this, 0, *(_QWORD *)(a3 + 32), 0, (uint64_t *)&v25);
      if ((_DWORD)v25)
      {
        *(_QWORD *)&v15.__val_ = v26;
        llvm::errorCodeToError(v25, v15, &v21);
        *(_BYTE *)(a5 + 8) |= 1u;
        *(_QWORD *)a5 = v21;
        v21 = 0;
      }
      else
      {
        v16 = (int *)llvm::sys::fs::mapped_file_region::data((llvm::sys::fs::mapped_file_region *)&v22);
        v17 = llvm::sys::fs::mapped_file_region::size((llvm::sys::fs::mapped_file_region *)&v22);
        memset(v29, 0, sizeof(v29));
        sub_1C61D3B34((char *)v29, (uint64_t)a1, 0, 0, v16, v17);
        if ((v17 & ~(-1 << (63 - __clz(v10)))) != 0 && !*((_BYTE *)v16 + v17))
        {
          v19[0] = v22;
          v19[1] = v23;
          v20 = v24;
          memset(v28, 0, sizeof(v28));
          v22 = 0;
          v23 = 0;
          v24 = 0;
          llvm::sys::fs::mapped_file_region::unmapImpl((llvm::sys::fs::mapped_file_region *)v28);
          (*(void (**)(llvm::sys::fs::file_status *, _OWORD *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 152))(a1, v29, 32, v19);
          llvm::sys::fs::mapped_file_region::unmapImpl((llvm::sys::fs::mapped_file_region *)v19);
        }
        else
        {
          (*(void (**)(llvm::sys::fs::file_status *, _OWORD *, uint64_t, _QWORD, _QWORD, int *, unint64_t))(*(_QWORD *)a1 + 144))(a1, v29, 32, 0, 0, v16, v17);
        }
      }
      llvm::sys::fs::mapped_file_region::unmapImpl((llvm::sys::fs::mapped_file_region *)&v22);
    }
    else
    {
      sub_1C5050724(a5, (uint64_t)this, (uint64_t)a1, a4);
    }
  }
  else
  {
    llvm::errorCodeToError(v13, v14, &v27);
    *(_BYTE *)(a5 + 8) |= 1u;
    *(_QWORD *)a5 = v27;
  }
}

unsigned __int8 *sub_1C61D3B34(char *a1, uint64_t a2, uint64_t *a3, unint64_t a4, int *a5, unint64_t a6)
{
  __n128 v12;
  __n128 v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v16;
  unint64_t __src;
  unsigned __int8 v19[1912];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v12.n128_f64[0] = llvm_blake3_hasher_init((uint64_t)v19);
  __src = a4;
  v13.n128_f64[0] = llvm_blake3_hasher_update((uint64_t)v19, (int *)&__src, 8uLL, v12);
  if (a4)
  {
    v14 = 8 * a4;
    do
    {
      v15 = *a3++;
      sub_1C61D3E78((uint64_t)v19, a2, v15);
      v14 -= 8;
    }
    while (v14);
  }
  __src = a6;
  v16.n128_f64[0] = llvm_blake3_hasher_update((uint64_t)v19, (int *)&__src, 8uLL, v13);
  llvm_blake3_hasher_update((uint64_t)v19, a5, a6, v16);
  return llvm_blake3_hasher_finalize(v19, a1, 0x20uLL);
}

uint64_t llvm::cas::builtin::BuiltinCAS::store(uint64_t a1, uint64_t *a2, unint64_t a3, int *a4, unint64_t a5)
{
  char v11[32];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  sub_1C61D3B34(v11, a1, a2, a3, a4, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t *, unint64_t, int *, unint64_t))(*(_QWORD *)a1 + 144))(a1, v11, 32, a2, a3, a4, a5);
}

uint64_t sub_1C61D3CDC(uint64_t a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
  return v1;
}

uint64_t sub_1C61D3CFC(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
}

uint64_t sub_1C61D3D08(uint64_t a1, uint64_t a2, uint64_t a3, llvm::sys::fs::mapped_file_region *this)
{
  uint64_t v8;
  uint64_t v9;

  v8 = llvm::sys::fs::mapped_file_region::data(this);
  v9 = llvm::sys::fs::mapped_file_region::size(this);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 144))(a1, a2, a3, 0, 0, v8, v9);
}

void sub_1C61D3D80()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t *sub_1C61D3D94()
{
  unsigned __int8 v0;
  const char *v2;
  __int16 v3;
  uint64_t v4[4];
  __int16 v5;
  _BYTE v6[40];

  v0 = atomic_load((unsigned __int8 *)&qword_1ED7F4D38);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1ED7F4D38))
  {
    v5 = 1283;
    v4[0] = (uint64_t)"llvm.cas.builtin.v2[";
    v4[2] = (uint64_t)"BLAKE3";
    v4[3] = 6;
    v2 = "]";
    v3 = 259;
    sub_1C4825FE4(v4, (uint64_t *)&v2, (uint64_t)v6);
    llvm::Twine::str((llvm::Twine *)v6, &qword_1ED7F4D40);
    __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE44D0], &qword_1ED7F4D40, &dword_1C475E000);
    __cxa_guard_release(&qword_1ED7F4D38);
  }
  if (byte_1ED7F4D57 >= 0)
    return &qword_1ED7F4D40;
  else
    return (uint64_t *)qword_1ED7F4D40;
}

void sub_1C61D3E78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 v4;
  uint64_t v5;
  void *v6;
  unint64_t v7;
  _QWORD v8[5];

  v8[4] = *MEMORY[0x1E0C80C00];
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(&v5, a2, a3);
  llvm_blake3_hasher_update(a1, (int *)v6, v7, v4);
  if (v6 != v8)
    free(v6);
}

void sub_1C61D3F04(uint64_t a1)
{
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 72), 8);
  std::mutex::~mutex((std::mutex *)a1);
}

uint64_t sub_1C61D3F30@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61D3FB4((uint64_t *)a1, (uint64_t)a2, &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61D4078(a1, (uint64_t)a2, (uint64_t)a2, v10);
    v7 = (_QWORD *)result;
    *(_QWORD *)result = *a2;
    v8 = 1;
  }
  v9 = *(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v9;
  *(_BYTE *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1C61D3FB4(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  uint64_t v6;
  int HashValue;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t result;
  _QWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    v6 = *a1;
    HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*(_QWORD **)(*(_QWORD *)a2 + 16), *(_QWORD *)(*(_QWORD *)a2 + 24));
    v8 = v4 - 1;
    v9 = HashValue & (v4 - 1);
    v10 = (_QWORD *)(v6 + 8 * v9);
    v11 = *v10;
    if (*(_QWORD *)a2 == *v10)
    {
      result = 1;
    }
    else
    {
      v13 = 0;
      v14 = 1;
      result = 1;
      while (v11 != -4096)
      {
        if (v13)
          v15 = 0;
        else
          v15 = v11 == -8192;
        if (v15)
          v13 = v10;
        v16 = v9 + v14++;
        v9 = v16 & v8;
        v10 = (_QWORD *)(v6 + 8 * (v16 & v8));
        v11 = *v10;
        if (*(_QWORD *)a2 == *v10)
          goto LABEL_4;
      }
      result = 0;
      if (v13)
        v10 = v13;
    }
  }
  else
  {
    v10 = 0;
    result = 0;
  }
LABEL_4:
  *a3 = v10;
  return result;
}

_QWORD *sub_1C61D4078(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C5051904(a1, v7);
  v9 = 0;
  sub_1C61D3FB4((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C61D4124(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v9 = 0;
      result = sub_1C61D3FB4((uint64_t *)v5, (uint64_t)a2, &v9);
      *v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1C61D41D0()
{
  return 0;
}

llvm::raw_ostream *sub_1C61D41D8(int a1, llvm::raw_ostream *a2, uint64_t a3, int a4)
{
  int v5;

  if (a4)
  {
    v5 = a4;
    do
    {
      sub_1C4816AD8(a2, "  ");
      --v5;
    }
    while (v5);
  }
  return sub_1C4816AD8(a2, "FileSystem\n");
}

void sub_1C61D422C(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1C61D4238(uint64_t *a1, const void **a2, uint64_t **a3)
{
  int v4;
  uint64_t v6;
  unsigned int HashValue;
  uint64_t *v8;
  int v9;
  int i;
  unsigned int v11;
  uint64_t *v12;
  uint64_t v13;
  size_t v14;
  BOOL v15;
  uint64_t result;

  v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    v12 = 0;
    result = 0;
    goto LABEL_16;
  }
  v6 = *a1;
  HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*a2, (uint64_t)a2[1]);
  v8 = 0;
  v9 = v4 - 1;
  for (i = 1; ; ++i)
  {
    v11 = HashValue & v9;
    v12 = (uint64_t *)(v6 + 8 * (HashValue & v9));
    v13 = *v12;
    if (*v12 == -8192)
      goto LABEL_8;
    if (v13 == -4096)
      break;
    v14 = (size_t)a2[1];
    if (v14 == *(_QWORD *)(v13 + 24) && (!v14 || !memcmp(*a2, *(const void **)(v13 + 16), v14)))
    {
      result = 1;
      goto LABEL_16;
    }
LABEL_8:
    if (v8)
      v15 = 0;
    else
      v15 = v13 == -8192;
    if (v15)
      v8 = (uint64_t *)(v6 + 8 * v11);
    HashValue = v11 + i;
  }
  result = 0;
  if (v8)
    v12 = v8;
LABEL_16:
  *a3 = v12;
  return result;
}

double llvm::cas::CASOutputBackend::CASOutputBackend(llvm::cas::CASOutputBackend *this, llvm::cas::ObjectStore *a2)
{
  double result;

  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E813F6C0;
  *((_QWORD *)this + 2) = (char *)this + 32;
  *(_QWORD *)&result = 0x100000000;
  *((_QWORD *)this + 3) = 0x100000000;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 8) = a2;
  return result;
}

void llvm::cas::CASOutputBackend::~CASOutputBackend(llvm::cas::CASOutputBackend *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  *(_QWORD *)this = &off_1E813F6C0;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 10);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  sub_1C5053158((char **)this + 2);
}

{
  llvm::cas::CASOutputBackend::~CASOutputBackend(this);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61D43F0@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  if (result)
    ++*(_DWORD *)(result + 8);
  *a2 = result;
  return result;
}

void sub_1C61D4408(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 32, &v5);
  sub_1C505338C((__int128 **)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void *sub_1C61D4474()
{
  return &llvm::vfs::OutputFileImpl::ID;
}

BOOL sub_1C61D4480(uint64_t a1, void *a2)
{
  return a2 == &llvm::vfs::OutputFileImpl::ID || a2 == &llvm::RTTIRoot::ID;
}

__n128 llvm::cas::createCASProvidingFileSystem@<Q0>(__n128 *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  __n128 result;
  uint64_t v8;

  v6 = operator new();
  result = *a1;
  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  v8 = *a2;
  *a2 = 0;
  *(_DWORD *)(v6 + 8) = 0;
  *(_QWORD *)(v6 + 16) = v8;
  *(_QWORD *)v6 = &off_1E813F748;
  *(__n128 *)(v6 + 24) = result;
  *a3 = v6;
  return result;
}

uint64_t sub_1C61D4510(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D4520(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D4530(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D4540(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D4550(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 56))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D4560@<X0>(llvm::Twine *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t result;
  std::error_code v5;

  *(_QWORD *)&v5.__val_ = std::generic_category();
  result = sub_1C61D45C4((llvm *)0x2D, v5, a1, (uint64_t *)a2);
  *(_BYTE *)(a2 + 8) |= 1u;
  return result;
}

uint64_t sub_1C61D45A4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 72))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D45B4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 80))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D45C4@<X0>(llvm *this@<X1>, std::error_code a2@<0:X2, 8:X3>, llvm::Twine *a3@<X0>, uint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  std::error_code v11;

  *(_QWORD *)&v11.__val_ = v11.__cat_;
  llvm::errorCodeToError(this, v11, &v9);
  v7 = v9;
  v9 = 0;
  v10 = v7;
  sub_1C61D4644(a3, 0, 0, &v10, a4);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  result = v9;
  if (v9)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  return result;
}

uint64_t sub_1C61D4644@<X0>(llvm::Twine *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;

  v9 = *a4;
  *a4 = 0;
  v15 = &v16;
  v16 = 0;
  v17 = v9;
  sub_1C5053C0C((uint64_t)&v17, &v15, &v18);
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  v10 = operator new();
  v11 = v16;
  v16 = 0;
  v14 = v11;
  *a5 = sub_1C5053D84(v10, a1, a2, a3, &v14);
  v12 = v14;
  v14 = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  result = v16;
  v16 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t sub_1C61D4730(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
}

void sub_1C61D473C(llvm::vfs::FileSystem *this)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  *(_QWORD *)this = off_1E813F820;
  v2 = (std::__shared_weak_count *)*((_QWORD *)this + 4);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  llvm::vfs::FileSystem::~FileSystem(this);
}

char **sub_1C61D47A0(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 24 * v3;
    v5 = v2 - 24;
    do
    {
      MEMORY[0x1CAA32FB4](*(_QWORD *)&v5[v4], 8);
      v4 -= 24;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

uint64_t sub_1C61D4808(uint64_t a1, const char **a2, unint64_t *a3, char a4)
{
  char *v7;
  uint64_t v8;
  char *v9;
  size_t v10;
  unint64_t v11;
  void *v13;
  __int128 v14;
  _QWORD v15[17];

  v15[16] = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 16) = a4;
  v7 = (char *)operator new(0x70uLL);
  *((_QWORD *)v7 + 2) = 0;
  *(_QWORD *)v7 = &unk_1E813FB00;
  *((_QWORD *)v7 + 1) = 0;
  *((_QWORD *)v7 + 7) = 0;
  *(_OWORD *)(v7 + 40) = 0u;
  *((_DWORD *)v7 + 14) = 9;
  v7[60] = 1;
  *((_OWORD *)v7 + 4) = 0u;
  *((_OWORD *)v7 + 5) = 0u;
  *(_OWORD *)(v7 + 92) = 0u;
  *((_DWORD *)v7 + 27) = 0xFFFF;
  *(_OWORD *)(v7 + 24) = 0u;
  v8 = (uint64_t)(v7 + 24);
  *(_QWORD *)a1 = v7 + 24;
  *(_QWORD *)(a1 + 8) = v7;
  v13 = v15;
  v14 = xmmword_1C85F20B0;
  v9 = (char *)sub_1C50561CC(a2, (uint64_t)&v13);
  *a3 = llvm::sys::fs::detail::directory_iterator_construct(v8, v9, v10, *(_BYTE *)(a1 + 16));
  a3[1] = v11;
  if (v13 != v15)
    free(v13);
  return a1;
}

void sub_1C61D4924(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E813FB00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1C61D4938(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E813FB00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61D496C(_QWORD *a1, std::mutex *this)
{
  unsigned __int8 v3;
  unsigned int *v5;
  unsigned int v6;
  unsigned __int8 v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = 0;
  v3 = atomic_load((unsigned __int8 *)&this[1]);
  if ((v3 & 1) == 0)
  {
    v5 = (unsigned int *)&this[1].__m_.__sig + 1;
    *a1 = (char *)this + 68;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
    v7 = atomic_load((unsigned __int8 *)&this[1].__m_.__sig + 1);
    if ((v7 & 1) != 0)
    {
      do
        v8 = __ldaxr(v5);
      while (__stlxr(v8 - 1, v5));
      std::mutex::lock(this);
      do
        v9 = __ldaxr(v5);
      while (__stlxr(v9 + 1, v5));
      std::mutex::unlock(this);
    }
  }
  return a1;
}

char *sub_1C61D49FC(uint64_t *a1, uint64_t a2, char *__src, char *a4)
{
  char *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  _BYTE *v15;
  char v16;

  v5 = __src;
  v7 = *a1;
  v8 = a1[1];
  v9 = a2 - *a1;
  if (*a1 + v8 == a2)
  {
    sub_1C50575FC(a1, __src, a4);
    return (char *)(*a1 + v9);
  }
  else
  {
    v10 = a4 - __src;
    v11 = v8 + a4 - __src;
    if (a1[2] < v11)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v11, 1);
      v7 = *a1;
      v8 = a1[1];
    }
    v12 = (char *)(v7 + v9);
    v13 = (char *)(v7 + v8);
    v14 = v8 - v9;
    if (v8 - v9 >= v10)
    {
      sub_1C5042AFC(a1, &v13[-v10], (char *)(v7 + v8));
      if (&v13[-v10] != v12)
        memmove(&v12[v10], v12, &v13[-v10] - v12);
      if (v5 != a4)
        memmove(v12, v5, a4 - v5);
    }
    else
    {
      a1[1] = v8 + v10;
      if (v9 != v8)
        memcpy((void *)(v7 + v10 + v9), v12, v8 - v9);
      if (v14)
      {
        v15 = v12;
        do
        {
          v16 = *v5++;
          *v15++ = v16;
          --v14;
        }
        while (v14);
      }
      if (v5 != a4)
        memcpy(v13, v5, a4 - v5);
    }
  }
  return v12;
}

uint64_t sub_1C61D4B40(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  void *v6;

  v3 = *(unsigned __int8 *)(a1 + 64);
  if (*(_BYTE *)(a2 + 64))
  {
    *(_QWORD *)a1 = *(_QWORD *)a2;
    v4 = a1 + 8;
    if (v3)
    {
      sub_1C4FE6ED8(v4, a2 + 8);
    }
    else
    {
      *(_QWORD *)(a1 + 8) = a1 + 32;
      *(_OWORD *)(a1 + 16) = xmmword_1C677F680;
      if (*(_QWORD *)(a2 + 16))
        sub_1C4FE6ED8(v4, a2 + 8);
      *(_BYTE *)(a1 + 64) = 1;
    }
  }
  else if (*(_BYTE *)(a1 + 64))
  {
    v6 = *(void **)(a1 + 8);
    if (v6 != (void *)(a1 + 32))
      free(v6);
    *(_BYTE *)(a1 + 64) = 0;
  }
  return a1;
}

uint64_t sub_1C61D4BD4(uint64_t a1, _QWORD *a2)
{
  int v3;
  uint64_t v4;

  v3 = *(unsigned __int8 *)(a1 + 64);
  *(_QWORD *)a1 = *a2;
  v4 = a1 + 8;
  if (v3)
  {
    sub_1C4FE6ED8(v4, (uint64_t)(a2 + 1));
  }
  else
  {
    *(_QWORD *)(a1 + 8) = a1 + 32;
    *(_OWORD *)(a1 + 16) = xmmword_1C677F680;
    if (a2[2])
      sub_1C4FE6ED8(v4, (uint64_t)(a2 + 1));
    *(_BYTE *)(a1 + 64) = 1;
  }
  return a1;
}

uint64_t sub_1C61D4C3C(uint64_t a1)
{
  unsigned int v1;
  _QWORD *v2;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 >= *(_DWORD *)(a1 + 12))
    return sub_1C61D4C70(a1);
  v2 = (_QWORD *)(*(_QWORD *)a1 + 24 * v1);
  *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

uint64_t sub_1C61D4C70(uint64_t a1)
{
  char *v2;
  char *v3;
  int v4;
  unsigned int v5;
  unint64_t v7;

  v7 = 0;
  v2 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, 0, 24, &v7);
  v3 = &v2[24 * *(unsigned int *)(a1 + 8)];
  *(_QWORD *)v3 = 0;
  *((_QWORD *)v3 + 1) = 0;
  *((_QWORD *)v3 + 2) = 0;
  sub_1C6146B5C(a1, (uint64_t)v2);
  v4 = v7;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v2;
  v5 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 12) = v4;
  return (uint64_t)&v2[24 * v5 - 24];
}

uint64_t llvm::cas::FileSystemCache::Directory::Writer::Writer(uint64_t a1, std::mutex *this)
{
  int v4;

  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 8) = 0;
  atomic_store(1u, (unsigned __int8 *)&this[1].__m_.__sig + 1);
  if (*(_BYTE *)(a1 + 8))
  {
    std::mutex::unlock(*(std::mutex **)a1);
    *(_BYTE *)(a1 + 8) = 0;
  }
  *(_QWORD *)a1 = this;
  std::mutex::lock(this);
  *(_BYTE *)(a1 + 8) = 1;
  do
    v4 = atomic_load((unsigned int *)&this[1].__m_.__sig + 1);
  while (v4 > 0);
  return a1;
}

unint64_t llvm::cas::FileSystemCache::makeLazySymlinkAlreadyLocked(uint64_t a1, uint64_t a2, _BYTE *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = atomic_load((unint64_t *)(a2 + 72));
  return sub_1C5058880(a1 + 424, a1 + 320, a2, v9, a3, a4, 2, a8, a5, 1);
}

unint64_t llvm::cas::FileSystemCache::makeLazyFileAlreadyLocked(uint64_t a1, uint64_t a2, _BYTE *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;

  v10 = atomic_load((unint64_t *)(a2 + 72));
  return sub_1C5058880(a1 + 424, a1 + 320, a2, v10, a3, a4, a6, a8, a5, 1);
}

unint64_t llvm::cas::FileSystemCache::makeDirectoryAlreadyLocked(uint64_t a1, uint64_t a2, _BYTE *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t *v17;
  unsigned __int8 v20;

  v10 = atomic_load((unint64_t *)(a2 + 72));
  v11 = sub_1C5058880(a1 + 424, a1 + 320, a2, v10, a3, a4, 3, a8, a5, a6);
  v12 = (unsigned __int8 *)(a1 + 312);
  do
    v13 = __ldaxr(v12);
  while (__stxr(1u, v12));
  if ((v13 & 1) != 0)
  {
    do
      v20 = __ldaxr(v12);
    while (__stxr(1u, v12) | v20 & 1);
  }
  v14 = sub_1C484358C(a1 + 216, 112, 3);
  atomic_store(0, (unsigned __int8 *)(a1 + 312));
  *(_QWORD *)v14 = 850045863;
  *(_OWORD *)(v14 + 8) = 0u;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 50) = 0u;
  *(_QWORD *)(v14 + 68) = 0;
  *(_QWORD *)(v14 + 84) = 0;
  *(_QWORD *)(v14 + 76) = 0;
  do
  {
    v15 = __ldaxr((unsigned int *)&unk_1EF8F7330);
    v16 = v15 + 1;
  }
  while (__stlxr(v16, (unsigned int *)&unk_1EF8F7330));
  *(_QWORD *)(v14 + 96) = -1;
  *(_QWORD *)(v14 + 104) = v16;
  v17 = (unint64_t *)(v11 + 72);
  while (!__ldaxr(v17))
  {
    if (!__stlxr(v14, v17))
      return v11;
  }
  __clrex();
  return v11;
}

void llvm::cas::FileSystemCache::finishLazySymlink(uint64_t a1, uint64_t a2, const std::string::value_type *a3, std::string::size_type a4)
{
  unint64_t v8;
  int v9;
  unint64_t *v10;
  unsigned __int8 *v12;
  unsigned __int8 v13;
  std::string *v14;
  unsigned int v15;
  std::string::size_type v16;
  unsigned __int8 v18;

  v8 = atomic_load((unint64_t *)(*(_QWORD *)(a2 + 32) + 72));
  atomic_store(1u, (unsigned __int8 *)(v8 + 65));
  std::mutex::lock((std::mutex *)v8);
  do
    v9 = atomic_load((unsigned int *)(v8 + 68));
  while (v9 > 0);
  v10 = (unint64_t *)(a2 + 72);
  if (!atomic_load(v10))
  {
    v12 = (unsigned __int8 *)(a1 + 208);
    do
      v13 = __ldaxr(v12);
    while (__stxr(1u, v12));
    if ((v13 & 1) != 0)
    {
      do
        v18 = __ldaxr(v12);
      while (__stxr(1u, v12) | v18 & 1);
    }
    v14 = (std::string *)sub_1C484358C(a1 + 112, 40, 3);
    atomic_store(0, v12);
    std::string::__init(v14, a3, a4);
    do
    {
      v15 = __ldaxr((unsigned int *)&unk_1EF8F7330);
      v16 = v15 + 1;
    }
    while (__stlxr(v16, (unsigned int *)&unk_1EF8F7330));
    v14[1].__r_.__value_.__r.__words[0] = -1;
    v14[1].__r_.__value_.__l.__size_ = v16;
    while (!__ldaxr(v10))
    {
      if (!__stlxr((unint64_t)v14, v10))
        goto LABEL_4;
    }
    __clrex();
  }
LABEL_4:
  std::mutex::unlock((std::mutex *)v8);
}

void llvm::cas::FileSystemCache::finishLazyFile(llvm::cas::FileSystemCache *this, llvm::cas::FileSystemCache::DirectoryEntry *a2, uint64_t a3)
{
  unint64_t v6;
  int v7;
  unint64_t *v8;
  char *v10;
  unsigned __int8 *v11;
  unsigned __int8 v12;
  _QWORD *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 v17;

  v6 = atomic_load((unint64_t *)(*((_QWORD *)a2 + 4) + 72));
  atomic_store(1u, (unsigned __int8 *)(v6 + 65));
  std::mutex::lock((std::mutex *)v6);
  do
    v7 = atomic_load((unsigned int *)(v6 + 68));
  while (v7 > 0);
  v8 = (unint64_t *)((char *)a2 + 72);
  if (!atomic_load(v8))
  {
    v10 = (char *)this + 8;
    v11 = (unsigned __int8 *)this + 104;
    do
      v12 = __ldaxr(v11);
    while (__stxr(1u, v11));
    if ((v12 & 1) != 0)
    {
      do
        v17 = __ldaxr(v11);
      while (__stxr(1u, v11) | v17 & 1);
    }
    v13 = (_QWORD *)sub_1C484358C((uint64_t)v10, 24, 3);
    atomic_store(0, v11);
    *v13 = a3;
    do
    {
      v14 = __ldaxr((unsigned int *)&unk_1EF8F7330);
      v15 = v14 + 1;
    }
    while (__stlxr(v15, (unsigned int *)&unk_1EF8F7330));
    v13[1] = -1;
    v13[2] = v15;
    while (!__ldaxr(v8))
    {
      if (!__stlxr((unint64_t)v13, v8))
        goto LABEL_4;
    }
    __clrex();
  }
LABEL_4:
  std::mutex::unlock((std::mutex *)v6);
}

uint64_t llvm::cas::FileSystemCache::VFSDirIterImpl::increment(llvm::cas::FileSystemCache::VFSDirIterImpl *this)
{
  *((_QWORD *)this + 13) += 8;
  llvm::cas::FileSystemCache::VFSDirIterImpl::setEntry(this);
  std::system_category();
  return 0;
}

void sub_1C61D5158(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E813FB38;
  sub_1C5052E10((_QWORD *)(a1 + 40));
  llvm::vfs::detail::DirIterImpl::~DirIterImpl((void **)a1);
}

void sub_1C61D5188(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_1E813FB38;
  sub_1C5052E10((_QWORD *)(a1 + 40));
  llvm::vfs::detail::DirIterImpl::~DirIterImpl((void **)a1);
  free(v2);
}

_QWORD *sub_1C61D51BC(_QWORD *result, uint64_t a2)
{
  char v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;

  *(_OWORD *)result = *(_OWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v2 = *(_BYTE *)(*result + 31);
  v3 = v2;
  v4 = *(_QWORD *)(*result + 16);
  v5 = v2 & 0x7F;
  if (v3 >= 0)
    v4 = v5;
  if (!v4)
  {
    v6 = (std::__shared_weak_count *)result[1];
    *result = 0;
    result[1] = 0;
    if (v6)
    {
      v9 = result;
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
        return v9;
      }
    }
  }
  return result;
}

void sub_1C61D5258(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61D527C(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

unint64_t llvm::cas::ThreadSafeHashMappedTrieBase::getOrCreateImpl(llvm::cas::ThreadSafeHashMappedTrieBase *this)
{
  unint64_t *v1;
  unint64_t v2;
  _QWORD *v4;
  unint64_t v5;
  int v6;
  void *v7;

  v1 = (unint64_t *)((char *)this + 16);
  v2 = atomic_load((unint64_t *)this + 2);
  if (!v2)
  {
    v4 = sub_1C61D5304(*((unsigned __int16 *)this + 3));
    while (1)
    {
      v5 = __ldaxr(v1);
      if (v5)
        break;
      if (!__stlxr((unint64_t)v4, v1))
      {
        v6 = 1;
        goto LABEL_8;
      }
    }
    v6 = 0;
    __clrex();
LABEL_8:
    if (v6)
      v2 = (unint64_t)v4;
    else
      v2 = v5;
    if ((v6 & 1) == 0 && v4)
    {
      v7 = (void *)sub_1C4926AE8((uint64_t)v4);
      free(v7);
    }
  }
  return v2;
}

_QWORD *sub_1C61D5304(unint64_t a1)
{
  size_t v2;
  _QWORD *v3;

  v2 = 8 << a1;
  v3 = malloc_type_malloc((8 << a1) + 144, 0xD863AA27uLL);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = v3 + 4;
  v3[3] = 0x400000000;
  v3[10] = 0;
  v3[8] = v3 + 10;
  v3[9] = 0;
  v3[11] = 1;
  *((_BYTE *)v3 + 96) = 0;
  *((_BYTE *)v3 + 104) = 1;
  *((_DWORD *)v3 + 27) = 0;
  *((_DWORD *)v3 + 28) = a1;
  v3[15] = 0;
  v3[16] = v3 + 18;
  v3[17] = 1 << a1;
  if (a1 <= 0x3C)
    bzero(v3 + 18, v2);
  return v3;
}

uint64_t sub_1C61D53A0(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v2;

  if (*(_BYTE *)(a1 + 40))
  {
    v1 = (unint64_t *)(a1 + 8);
    v2 = *(_QWORD *)(a1 + 8 * (*(_QWORD *)(a1 + 32) != 0)) + *(_QWORD *)(a1 + 32);
  }
  else
  {
    v2 = 0;
    *(_BYTE *)(a1 + 40) = 1;
    v1 = (unint64_t *)a1;
  }
  *(_QWORD *)(a1 + 32) = v2;
  return sub_1C505B9F4(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v2, *v1);
}

void llvm::cas::ThreadSafeHashMappedTrieBase::dump(llvm::cas::ThreadSafeHashMappedTrieBase *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  llvm::cas::ThreadSafeHashMappedTrieBase::print(this, v2);
}

void llvm::cas::ThreadSafeHashMappedTrieBase::destroyImpl(uint64_t a1, void (*a2)(uint64_t, _BYTE *), uint64_t a3)
{
  unint64_t *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  _BYTE *v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  void *v15;

  v5 = (unint64_t *)(a1 + 16);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(0, v5));
  if (v6)
  {
    if (a2)
    {
      v7 = (unint64_t *)(v6 + 104);
      do
      {
        v8 = v7[4];
        if (v8)
        {
          v9 = (unint64_t *)v7[3];
          v10 = 8 * v8;
          do
          {
            v11 = (_BYTE *)atomic_load(v9);
            if ((unint64_t)(v11 + 1) >= 2 && !*v11)
              a2(a3, &v11[v11[1]]);
            ++v9;
            v10 -= 8;
          }
          while (v10);
        }
        v7 = (unint64_t *)atomic_load(v7 + 2);
      }
      while (v7);
    }
    v12 = (unint64_t *)atomic_load((unint64_t *)(v6 + 120));
    if (v12)
    {
      do
      {
        v13 = v12 + 2;
        do
          v14 = __ldaxr(v13);
        while (__stlxr(0, v13));
        free(v12);
        v12 = (unint64_t *)v14;
      }
      while (v14);
    }
    v15 = (void *)sub_1C4926AE8(v6);
    free(v15);
  }
}

void llvm::cas::HierarchicalTreeBuilder::pushImpl(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v7;
  _QWORD v8[2];
  int v9;
  __int128 v10;
  void *v11;
  __int128 v12;
  _QWORD v13[33];

  v13[32] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v10 = a2;
  *((_QWORD *)&v10 + 1) = a3;
  v9 = a4;
  v11 = v13;
  v12 = xmmword_1C64638F0;
  llvm::Twine::toVector(a5, (uint64_t)&v11);
  v8[0] = sub_1C505C640((uint64_t *)&v11, a4);
  v8[1] = v7;
  sub_1C505C440(a1, &v10, &v9, (uint64_t)v8);
  if (v11 != v13)
    free(v11);
}

uint64_t sub_1C61D55E4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;

  v5 = *(unsigned int *)(a1 + 8);
  if (v5 >= *(_DWORD *)(a1 + 12))
    return sub_1C505EBBC(a1, a2, a3, a4, a5);
  v6 = *(_QWORD *)a1 + 32 * v5;
  *(_DWORD *)v6 = a3;
  *(_QWORD *)(v6 + 8) = a2;
  *(_QWORD *)(v6 + 16) = a4;
  *(_QWORD *)(v6 + 24) = a5;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

uint64_t *sub_1C61D5618(uint64_t *result, uint64_t a2, char *a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;

  v4 = result;
  v5 = *result;
  v6 = result[1];
  if (*result + v6 == a2)
  {
    v11 = *a3;
    if (v6 + 1 > (unint64_t)result[2])
    {
      result = (uint64_t *)llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)result, result + 3, v6 + 1, 1);
      v5 = *v4;
      v6 = v4[1];
    }
    *(_BYTE *)(v5 + v6) = v11;
    ++v4[1];
  }
  else
  {
    v7 = a2 - v5;
    if (v6 + 1 > (unint64_t)result[2])
    {
      result = (uint64_t *)llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)result, result + 3, v6 + 1, 1);
      v5 = *v4;
      v6 = v4[1];
    }
    v8 = (char *)(v5 + v7);
    *(_BYTE *)(v5 + v6) = *(_BYTE *)(v5 + v6 - 1);
    v9 = v4[1];
    v10 = *v4 + v9 - 1;
    if ((char *)v10 != v8)
    {
      result = (uint64_t *)memmove(v8 + 1, v8, v10 - (_QWORD)v8);
      v9 = v4[1];
    }
    v4[1] = v9 + 1;
    *v8 = *a3;
  }
  return result;
}

double llvm::cas::createInMemoryCAS@<D0>(uint64_t *a1@<X8>)
{
  uint64_t v3;
  _UNKNOWN **DefaultContext;
  double result;

  v3 = operator new();
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 128) = 0u;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_OWORD *)(v3 + 176) = 0u;
  *(_OWORD *)(v3 + 192) = 0u;
  *(_OWORD *)(v3 + 208) = 0u;
  *(_OWORD *)(v3 + 224) = 0u;
  *(_OWORD *)(v3 + 240) = 0u;
  *(_OWORD *)(v3 + 256) = 0u;
  *(_OWORD *)(v3 + 272) = 0u;
  *(_OWORD *)(v3 + 288) = 0u;
  *(_OWORD *)(v3 + 304) = 0u;
  *(_OWORD *)(v3 + 320) = 0u;
  *(_OWORD *)(v3 + 336) = 0u;
  *(_OWORD *)(v3 + 352) = 0u;
  *(_QWORD *)(v3 + 368) = 0;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  DefaultContext = llvm::cas::builtin::BuiltinCASContext::getDefaultContext((llvm::cas::builtin::BuiltinCASContext *)v3);
  *(_QWORD *)v3 = &off_1E813FBD8;
  *(_QWORD *)(v3 + 8) = DefaultContext;
  llvm::cas::ThreadSafeHashMappedTrieBase::ThreadSafeHashMappedTrieBase(v3 + 16, 48, 8, 8, 0, 0, 0, 0);
  llvm::cas::ThreadSafeHashMappedTrieBase::ThreadSafeHashMappedTrieBase(v3 + 40, 48, 8, 8, 0, 0, 0, 0);
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  *(_QWORD *)(v3 + 80) = v3 + 96;
  *(_QWORD *)&result = 0x400000000;
  *(_QWORD *)(v3 + 88) = 0x400000000;
  *(_QWORD *)(v3 + 144) = 0;
  *(_QWORD *)(v3 + 128) = v3 + 144;
  *(_QWORD *)(v3 + 136) = 0;
  *(_QWORD *)(v3 + 152) = 1;
  *(_BYTE *)(v3 + 160) = 0;
  *(_QWORD *)(v3 + 168) = 0;
  *(_QWORD *)(v3 + 176) = 0;
  *(_QWORD *)(v3 + 184) = v3 + 200;
  *(_QWORD *)(v3 + 192) = 0x400000000;
  *(_QWORD *)(v3 + 248) = 0;
  *(_QWORD *)(v3 + 232) = v3 + 248;
  *(_QWORD *)(v3 + 240) = 0;
  *(_QWORD *)(v3 + 256) = 1;
  *(_BYTE *)(v3 + 264) = 0;
  *(_QWORD *)(v3 + 272) = 0;
  *(_QWORD *)(v3 + 280) = 0;
  *(_QWORD *)(v3 + 288) = v3 + 304;
  *(_QWORD *)(v3 + 296) = 0x400000000;
  *(_QWORD *)(v3 + 336) = v3 + 352;
  *(_QWORD *)(v3 + 344) = 0;
  *(_QWORD *)(v3 + 352) = 0;
  *(_QWORD *)(v3 + 360) = 0;
  *(_BYTE *)(v3 + 368) = 0;
  *a1 = v3;
  return result;
}

uint64_t llvm::cas::CASID::dump(llvm::cas::CASID *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return (*(uint64_t (**)(_QWORD, llvm *, llvm::cas::CASID *))(**(_QWORD **)this + 32))(*(_QWORD *)this, v2, this);
}

uint64_t llvm::cas::ObjectStore::dump(llvm::cas::ObjectStore *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return (*(uint64_t (**)(llvm::cas::ObjectStore *, llvm *))(*(_QWORD *)this + 112))(this, v2);
}

void llvm::cas::ObjectRef::dump(llvm::cas::ObjectRef *this)
{
  void **v2;

  v2 = (void **)llvm::dbgs(this);
  llvm::cas::ReferenceBase::print((unint64_t *)this, v2);
}

void llvm::cas::ObjectHandle::dump(llvm::cas::ObjectHandle *this)
{
  void **v2;

  v2 = (void **)llvm::dbgs(this);
  llvm::cas::ReferenceBase::print((unint64_t *)this, v2);
}

void llvm::cas::ReferenceBase::print(unint64_t *a1, void **this)
{
  unint64_t v2;
  _BYTE v3[8];
  void *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3[0] = 0;
  v6 = 0;
  sub_1C505F7D0(this, "object-handle", 0xDuLL, v2, v3);
  if (v6)
  {
    if (v4 != &v5)
      free(v4);
  }
}

{
  unint64_t v2;
  _BYTE v3[8];
  void *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3[0] = 0;
  v6 = 0;
  sub_1C505F7D0(this, "object-ref", 0xAuLL, v2, v3);
  if (v6)
  {
    if (v4 != &v5)
      free(v4);
  }
}

uint64_t llvm::cas::ObjectStore::readRefs(uint64_t a1)
{
  char *v1;
  uint64_t result;
  char *v3;
  char *v4;
  char *v5;

  (*(void (**)(char **__return_ptr))(*(_QWORD *)a1 + 64))(&v3);
  v1 = v3;
  v3 = 0;
  v4 = v1;
  sub_1C4D62BD4(&v4, &v5);
  if (v4)
    (*(void (**)(char *))(*(_QWORD *)v4 + 8))(v4);
  result = (uint64_t)v3;
  if (v3)
    return (*(uint64_t (**)(char *))(*(_QWORD *)v3 + 8))(v3);
  return result;
}

void llvm::cas::ObjectStore::getProxy(llvm::cas::ObjectStore *this@<X0>, const llvm::cas::CASID *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  char v7;
  uint64_t v8;

  v6 = (*(uint64_t (**)(llvm::cas::ObjectStore *))(*(_QWORD *)this + 32))(this);
  if (v7)
  {
    llvm::cas::ObjectStore::getProxy((uint64_t)this, v6, a3);
  }
  else
  {
    llvm::cas::ObjectStore::createUnknownObjectError(a2, &v8);
    *(_BYTE *)(a3 + 24) |= 1u;
    *(_QWORD *)a3 = v8;
  }
}

_QWORD *llvm::cas::ObjectStore::getProxy@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  _QWORD *result;
  uint64_t v7;
  char v8;
  char v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  v4 = a1;
  v12 = *MEMORY[0x1E0C80C00];
  result = (*(_QWORD *(**)(uint64_t *__return_ptr))(*(_QWORD *)a1 + 48))(&v10);
  v7 = v10;
  v8 = *(_BYTE *)(a3 + 24);
  if ((v11 & 1) != 0 && v10)
  {
    v9 = v8 | 1;
    v4 = v10;
  }
  else
  {
    if ((v11 & 1) != 0)
      v7 = 0;
    v9 = v8 & 0xFE;
    *(_QWORD *)(a3 + 8) = a2;
    *(_QWORD *)(a3 + 16) = v7;
  }
  *(_BYTE *)(a3 + 24) = v9;
  *(_QWORD *)a3 = v4;
  return result;
}

_QWORD *llvm::cas::ObjectStore::createProxy@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;
  char v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  result = (*(_QWORD *(**)(_QWORD **__return_ptr))(*(_QWORD *)a1 + 8))(&v6);
  if ((v7 & 1) != 0)
  {
    v5 = (uint64_t)v6;
    *(_BYTE *)(a2 + 24) |= 1u;
    *(_QWORD *)a2 = v5;
  }
  else
  {
    result = llvm::cas::ObjectStore::getProxy(a1, (uint64_t)v6, a2);
    if ((v7 & 1) != 0)
    {
      result = v6;
      v6 = 0;
      if (result)
        return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
    }
  }
  return result;
}

char *llvm::cas::ObjectProxy::getMemoryBuffer@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char **a5@<X8>)
{
  uint64_t v8;
  uint64_t v9;

  v8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)*a1 + 88))(*a1, a1[2], a4);
  return llvm::MemoryBuffer::getMemBuffer(v8, v9, a2, a3, a5);
}

void llvm::cas::getDefaultOnDiskCASStableID(_QWORD *a1)
{
  uint64_t v2;
  void **v3;
  __int16 v4;
  _QWORD *v5;
  __int16 v6;
  _QWORD *v7[4];
  __int16 v8;
  _QWORD *v9[4];
  __int16 v10;

  v2 = 0;
  a1[1] = 0;
  if (a1[2] <= 0x1CuLL)
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, 0x1DuLL, 1);
    v2 = a1[1];
  }
  qmemcpy((void *)(*a1 + v2), "/^llvm::cas::builtin::default", 29);
  a1[1] += 29;
  v10 = 261;
  v9[0] = "llvm.cas.builtin.default";
  v9[1] = (_QWORD *)24;
  v8 = 261;
  v7[0] = "cas";
  v7[1] = (_QWORD *)3;
  v6 = 257;
  v4 = 257;
  llvm::sys::path::append(a1, v9, v7, &v5, &v3);
}

void llvm::cas::getDefaultOnDiskCASPath(_QWORD *a1)
{
  void **v2;
  __int16 v3;
  _QWORD *v4;
  __int16 v5;
  _QWORD *v6[4];
  __int16 v7;
  _QWORD *v8[4];
  __int16 v9;

  if ((llvm::sys::path::cache_directory(a1) & 1) == 0)
    llvm::report_fatal_error((llvm *)"cannot get default cache directory", (const char *)1);
  v9 = 261;
  v8[0] = "llvm.cas.builtin.default";
  v8[1] = (_QWORD *)24;
  v7 = 261;
  v6[0] = "cas";
  v6[1] = (_QWORD *)3;
  v5 = 257;
  v3 = 257;
  llvm::sys::path::append(a1, v8, v6, &v4, &v2);
}

uint64_t llvm::cas::TreeSchema::isNode(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 80))(*a2, a2[2]);
  if (result)
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*a2 + 72))(*a2, a2[2], 0) == *(_QWORD *)(a1 + 16);
  return result;
}

llvm::cas::TreeSchema *llvm::cas::TreeSchema::TreeSchema(llvm::cas::TreeSchema *this, llvm::cas::ObjectStore *a2)
{
  uint64_t v3;
  _QWORD v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E813FD60;
  *((_QWORD *)this + 1) = a2;
  *((_BYTE *)this + 16) = 0;
  *((_BYTE *)this + 24) = 0;
  (*(void (**)(_QWORD *__return_ptr, llvm::cas::ObjectStore *, _QWORD, _QWORD, const char *, uint64_t))(*(_QWORD *)a2 + 8))(v5, a2, 0, 0, "llvm::cas::schema::tree::v1", 27);
  v3 = v5[0];
  if (!*((_BYTE *)this + 24))
    *((_BYTE *)this + 24) = 1;
  *((_QWORD *)this + 2) = v3;
  return this;
}

uint64_t llvm::cas::TreeSchema::getNumTreeEntries(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 80))(*a2, a2[2]) - 1;
}

uint64_t sub_1C61D5F80(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
    return sub_1C61D6260(a1, a2, a3);
  v4 = *(_QWORD *)a1 + 32 * v3;
  *(_DWORD *)v4 = a3;
  *(_QWORD *)(v4 + 8) = a2;
  *(_QWORD *)(v4 + 16) = "/";
  *(_QWORD *)(v4 + 24) = 1;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

void llvm::cas::TreeSchema::load(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  llvm::cas::ObjectStore::getProxy(*(_QWORD *)(a1 + 8), a2, (uint64_t)&v9);
  if ((v11 & 1) != 0)
  {
    v5 = v9;
    *(_BYTE *)(a3 + 32) |= 1u;
    *(_QWORD *)a3 = v5;
  }
  else
  {
    v7 = v9;
    v8 = v10;
    llvm::cas::TreeSchema::load(a1, &v7, a3);
    if ((v11 & 1) != 0)
    {
      v6 = v9;
      *(_QWORD *)&v9 = 0;
      if (v6)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    }
  }
}

void llvm::cas::TreeSchema::load(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  llvm *v6;
  uint64_t v7;
  llvm *v8;
  uint64_t v9;
  std::error_code v10;

  v6 = (llvm *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 80))(*a2, a2[2]);
  if (v6
    && (v6 = (llvm *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*a2 + 72))(*a2, a2[2], 0),
        v6 == *(llvm **)(a1 + 16)))
  {
    v7 = *a2;
    *(_OWORD *)(a3 + 8) = *(_OWORD *)(a2 + 1);
    *(_BYTE *)(a3 + 32) &= ~1u;
    *(_QWORD *)a3 = v7;
    *(_QWORD *)(a3 + 24) = a1;
  }
  else
  {
    v8 = (llvm *)llvm::inconvertibleErrorCode(v6);
    v10.__cat_ = (const std::error_category *)"not a tree object";
    llvm::createStringError(v8, v10, &v9);
    *(_BYTE *)(a3 + 32) |= 1u;
    *(_QWORD *)a3 = v9;
  }
}

void llvm::cas::TreeProxy::Builder::startNode(llvm::cas::TreeProxy::Builder *this@<X0>, uint64_t a2@<X8>)
{
  llvm::cas::TreeProxy::Builder *v3;
  void *v4;
  __int128 v5;
  _BYTE v6[256];
  void *v7;
  uint64_t v8;
  _QWORD v9[17];

  v9[16] = *MEMORY[0x1E0C80C00];
  v3 = this;
  v4 = v6;
  v5 = xmmword_1C64638F0;
  v7 = v9;
  v9[0] = *((_QWORD *)this + 2);
  v8 = 0x1000000001;
  *(_BYTE *)(a2 + 432) &= ~1u;
  sub_1C61D62D4(a2, (uint64_t)&v3);
  if (v7 != v9)
    free(v7);
  if (v4 != v6)
    free(v4);
}

void sub_1C61D6204()
{
  JUMPOUT(0x1CAA32FC0);
}

void *sub_1C61D6218()
{
  return &llvm::cas::TreeSchema::ID;
}

uint64_t sub_1C61D6224(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &llvm::cas::NodeSchema::ID || a2 == &llvm::RTTIRoot::ID;
  return a2 == &llvm::cas::TreeSchema::ID || v3;
}

uint64_t sub_1C61D6258()
{
  return 0;
}

uint64_t sub_1C61D6260(uint64_t a1, uint64_t a2, int a3)
{
  _OWORD *v4;
  _OWORD *v5;
  __int128 v6;
  uint64_t v7;
  int v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;

  v9 = a3;
  v10 = a2;
  v11 = "/";
  v12 = 1;
  v4 = (_OWORD *)sub_1C47C0F60(a1, (unint64_t)&v9, 1);
  v5 = (_OWORD *)(*(_QWORD *)a1 + 32 * *(unsigned int *)(a1 + 8));
  v6 = v4[1];
  *v5 = *v4;
  v5[1] = v6;
  v7 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v7;
  return *(_QWORD *)a1 + 32 * v7 - 32;
}

uint64_t sub_1C61D62D4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = a1 + 32;
  v4 = a1 + 8;
  *(_OWORD *)(a1 + 16) = xmmword_1C64638F0;
  if (*(_QWORD *)(a2 + 16))
    sub_1C4FE6ED8(v4, a2 + 8);
  *(_QWORD *)(a1 + 288) = a1 + 304;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  if (*(_DWORD *)(a2 + 296))
    sub_1C614D378(a1 + 288, a2 + 288);
  return a1;
}

unsigned int *sub_1C61D6350(unsigned int *result, _BYTE *__src, _BYTE *a3)
{
  _DWORD *v5;
  size_t v6;
  uint64_t v7;
  unint64_t v8;

  v5 = result;
  v6 = a3 - __src;
  v7 = result[2];
  v8 = v7 + ((a3 - __src) >> 5);
  if (v8 > result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v8, 32);
    LODWORD(v7) = v5[2];
  }
  if (__src != a3)
  {
    result = (unsigned int *)memcpy((void *)(*(_QWORD *)v5 + 32 * v7), __src, v6);
    LODWORD(v7) = v5[2];
  }
  v5[2] = v7 + (v6 >> 5);
  return result;
}

BOOL sub_1C61D63D4(uint64_t a1, uint64_t a2)
{
  size_t v3;

  if (*(_DWORD *)a1 != *(_DWORD *)a2 || *(_QWORD *)(a1 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  v3 = *(_QWORD *)(a1 + 24);
  if (v3 != *(_QWORD *)(a2 + 24))
    return 0;
  if (v3)
    return memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v3) == 0;
  return 1;
}

void sub_1C61D6438(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 48, &v5);
  sub_1C4FCE92C((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

unsigned int *sub_1C61D64A4(unsigned int *a1, unsigned int a2, uint64_t a3)
{
  uint64_t *v5;
  unint64_t v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v15;

  *a1 = a2;
  v5 = (uint64_t *)(a1 + 8);
  v6 = a2;
  v15 = 0;
  sub_1C5065358((_QWORD *)a1 + 1, a2, &v15);
  v15 = 0;
  sub_1C5065358(v5, v6, &v15);
  *((_QWORD *)a1 + 8) = 0;
  *((_QWORD *)a1 + 9) = 0;
  *((_QWORD *)a1 + 7) = a1 + 16;
  v15 = 0;
  sub_1C5065358((_QWORD *)a1 + 10, v6, &v15);
  v15 = 0;
  v7 = sub_1C5065358((_QWORD *)a1 + 13, v6, &v15);
  v8 = -1;
  v9 = a3 + 48;
  do
  {
    v9 = *(_QWORD *)(v9 + 8);
    ++v8;
  }
  while (v9 != a3 + 48);
  if (*a1)
  {
    v10 = 0;
    v11 = *v5;
    v12 = *((_QWORD *)a1 + 10);
    v13 = *v7;
    do
    {
      *(_DWORD *)(v11 + 4 * v10) = v10;
      *(_DWORD *)(v12 + 4 * v10) = -1;
      *(_DWORD *)(v13 + 4 * v10++) = v8;
    }
    while (v10 < *a1);
  }
  return a1;
}

_QWORD *sub_1C61D65A0(_QWORD *result, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  v3 = result[4];
  v4 = result[1];
  v5 = *(unsigned int *)(v3 + 4 * a2);
  do
  {
    v6 = v5;
    v5 = *(unsigned int *)(v4 + 4 * v5);
  }
  while (v5 != v6);
  v7 = *(unsigned int *)(v3 + 4 * a3);
  do
  {
    v8 = v7;
    v7 = *(unsigned int *)(v4 + 4 * v7);
  }
  while (v7 != v8);
  if (v6)
    v9 = v8;
  else
    v9 = 0;
  if (v9 == v6)
    v6 = v8;
  if (v6 >= (result[2] - v4) >> 2)
    abort();
  *(_DWORD *)(v4 + 4 * v6) = v9;
  return result;
}

char *sub_1C61D6608(_QWORD *a1, unsigned int a2)
{
  _DWORD *v5;
  char **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *result;
  int v11;

  v7 = a1[1];
  v5 = (_DWORD *)a1[2];
  v6 = (char **)(a1 + 1);
  v8 = (unint64_t)v6[2];
  v9 = ((unint64_t)v5 - v7) >> 2;
  v11 = v9;
  if ((unint64_t)v5 >= v8)
  {
    result = sub_1C4E36640(v6, &v11);
    LODWORD(v9) = v11;
  }
  else
  {
    *v5 = v9;
    result = (char *)(v5 + 1);
  }
  a1[2] = result;
  *(_DWORD *)(a1[4] + 4 * a2) = v9;
  return result;
}

uint64_t sub_1C61D6674(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = &off_1E813FE58;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 16) + 104))(*(_QWORD *)(a2 + 16));
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 16) + 176))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16));
  *(_QWORD *)(a1 + 48) = a1 + 64;
  *(_QWORD *)(a1 + 32) = v7;
  *(_QWORD *)(a1 + 40) = a3;
  *(_QWORD *)(a1 + 56) = 0x600000000;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  v8 = *(unsigned int *)(a4 + 8);
  if ((_DWORD)v8)
  {
    for (i = 0; i != v8; ++i)
    {
      llvm::TargetRegisterInfo::getAllocatableSet(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 8), *(_QWORD **)(*(_QWORD *)a4 + 8 * i), (char *)&v18);
      v10 = *(unsigned int *)(a1 + 56);
      if ((_DWORD)v10)
      {
        v11 = *(_QWORD **)(a1 + 48);
        v12 = 8 * v10;
        while (!*v11)
        {
          ++v11;
          v12 -= 8;
          if (!v12)
            goto LABEL_7;
        }
        if (*(_DWORD *)(a1 + 112) < v21)
          sub_1C4833580((_DWORD *)(a1 + 48), v21, 0);
        v13 = (char *)v18;
        if (v19)
        {
          v14 = 0;
          v15 = *(_QWORD *)(a1 + 48);
          v16 = 8 * v19;
          do
          {
            *(_QWORD *)(v15 + v14) |= *(_QWORD *)&v13[v14];
            v14 += 8;
          }
          while (v16 != v14);
        }
      }
      else
      {
LABEL_7:
        sub_1C49DA960(a1 + 48, (uint64_t)&v18);
        *(_DWORD *)(a1 + 112) = v21;
        v13 = (char *)v18;
      }
      if (v13 != (char *)&v20)
        free(v13);
    }
  }
  return a1;
}

void sub_1C61D6818(llvm::AntiDepBreaker *this)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E813FE58;
  v2 = *((_QWORD *)this + 15);
  if (v2)
  {
    v4 = sub_1C61D71B4(v2);
    MEMORY[0x1CAA32FC0](v4, 0x1030C403AA5FAB9);
  }
  v3 = (char *)*((_QWORD *)this + 6);
  if (v3 != (char *)this + 64)
    free(v3);
  llvm::AntiDepBreaker::~AntiDepBreaker(this);
}

void sub_1C61D6880(llvm::AntiDepBreaker *a1)
{
  sub_1C61D6818(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61D68A4(uint64_t a1, uint64_t a2)
{
  unsigned int *v4;
  char v5;
  uint64_t v6;
  llvm::MachineBasicBlock **v7;
  llvm::MachineBasicBlock **v8;
  uint64_t v9;
  llvm::MachineBasicBlock *v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _WORD *CalleeSavedRegs;
  unsigned int v22;
  _WORD *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  unsigned int v31;
  uint64_t v32;
  _DWORD v33[4];
  char v34;
  uint64_t v35;
  unsigned __int16 v36;
  void *v37[2];
  char v38;
  uint64_t v39;
  unsigned __int16 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v4 = (unsigned int *)operator new();
  *(_QWORD *)(a1 + 120) = sub_1C61D64A4(v4, *(_DWORD *)(*(_QWORD *)(a1 + 32) + 16), a2);
  v5 = sub_1C498FBAC(a2);
  v6 = *(_QWORD *)(a1 + 120);
  v7 = *(llvm::MachineBasicBlock ***)(a2 + 88);
  v8 = *(llvm::MachineBasicBlock ***)(a2 + 96);
  v32 = a2;
  if (v7 != v8)
  {
    v9 = a2 + 48;
    do
    {
      v10 = *v7;
      v11 = llvm::MachineBasicBlock::livein_begin(*v7);
      v12 = (unsigned __int16 *)*((_QWORD *)v10 + 20);
      if (v12 != (unsigned __int16 *)v11)
      {
        v13 = (unsigned __int16 *)v11;
        do
        {
          v14 = *(_QWORD *)(a1 + 32);
          if (v14)
            v15 = (_QWORD *)(v14 + 8);
          else
            v15 = 0;
          sub_1C48385F4((uint64_t)v37, *v13, v15, 1);
          v16 = v39;
          while (v16)
          {
LABEL_10:
            v17 = v40;
            sub_1C61D65A0(*(_QWORD **)(a1 + 120), v40, 0);
            v18 = -1;
            v19 = v9;
            do
            {
              v19 = *(_QWORD *)(v19 + 8);
              ++v18;
            }
            while (v19 != v9);
            *(_DWORD *)(*(_QWORD *)(v6 + 80) + 4 * v17) = v18;
            *(_DWORD *)(*(_QWORD *)(v6 + 104) + 4 * v17) = -1;
            while (1)
            {
              sub_1C48386F0((uint64_t)v37);
              v16 = v39;
              if (v38 || v39 == 0)
                break;
              if (LODWORD(v37[0]) != v40)
                goto LABEL_10;
            }
          }
          v13 += 8;
        }
        while (v13 != v12);
      }
      ++v7;
    }
    while (v7 != v8);
  }
  llvm::MachineFrameInfo::getPristineRegs(*(llvm::MachineFrameInfo **)(*(_QWORD *)(a1 + 8) + 56), *(const llvm::MachineFunction **)(a1 + 8), (char *)v37);
  CalleeSavedRegs = (_WORD *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*(llvm::MachineRegisterInfo **)(*(_QWORD *)(a1 + 8) + 40));
  v22 = (unsigned __int16)*CalleeSavedRegs;
  if (*CalleeSavedRegs)
  {
    v23 = CalleeSavedRegs;
    do
    {
      if ((v5 & 1) != 0 || ((*((_QWORD *)v37[0] + (v22 >> 6)) >> v22) & 1) != 0)
      {
        v24 = *(_QWORD *)(a1 + 32);
        if (v24)
          v25 = (_QWORD *)(v24 + 8);
        else
          v25 = 0;
        sub_1C48385F4((uint64_t)v33, v22, v25, 1);
        v26 = v35;
        while (v26)
        {
LABEL_30:
          v27 = v36;
          sub_1C61D65A0(*(_QWORD **)(a1 + 120), v36, 0);
          v28 = -1;
          v29 = v32 + 48;
          do
          {
            v29 = *(_QWORD *)(v29 + 8);
            ++v28;
          }
          while (v29 != v32 + 48);
          *(_DWORD *)(*(_QWORD *)(v6 + 80) + 4 * v27) = v28;
          *(_DWORD *)(*(_QWORD *)(v6 + 104) + 4 * v27) = -1;
          while (1)
          {
            sub_1C48386F0((uint64_t)v33);
            v26 = v35;
            if (v34 || v35 == 0)
              break;
            if (v33[0] != v36)
              goto LABEL_30;
          }
        }
      }
      v31 = (unsigned __int16)v23[1];
      ++v23;
      v22 = v31;
    }
    while (v31);
  }
  if (v37[0] != &v38)
    free(v37[0]);
}

uint64_t sub_1C61D6B38(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = *(_QWORD *)(a1 + 120);
  if (result)
  {
    v3 = sub_1C61D71B4(result);
    result = MEMORY[0x1CAA32FC0](v3, 0x1030C403AA5FAB9);
  }
  *(_QWORD *)(a1 + 120) = 0;
  return result;
}

uint64_t sub_1C61D6B7C(uint64_t result, uint64_t a2, uint64_t **a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int16 *v16;
  int v17;
  unsigned int v18;

  v3 = *(unsigned int *)(a2 + 40);
  if ((_DWORD)v3)
  {
    v6 = result;
    for (i = 0; i != v3; ++i)
    {
      v8 = *(_QWORD *)(a2 + 32);
      v9 = v8 + 32 * i;
      v10 = *(_DWORD *)v9;
      if (!*(_DWORD *)v9)
      {
        if ((v10 & 0x1000000) != 0
          && ((v10 & 0x10000FF) == 0x1000000 ? (v11 = (v10 & 0xF00000) == 0) : (v11 = 1), !v11)
          || (result = sub_1C61D6EB0(a2, v10, *(_DWORD *)(v9 + 4)), (_DWORD)result))
        {
          v12 = *(_QWORD *)(v6 + 32);
          v13 = (_QWORD *)(v12 + 8);
          if (!v12)
            v13 = 0;
          v14 = v13[6];
          if (v14)
          {
            v15 = *(_DWORD *)(v8 + 32 * i + 4);
            v16 = (unsigned __int16 *)(v14 + 2 * *(unsigned int *)(*v13 + 24 * v15 + 4));
            do
            {
              v18 = (unsigned __int16)v15;
              result = (uint64_t)sub_1C4778ED8(a3, &v18, &v18);
              v17 = *v16++;
              v15 += v17;
            }
            while (v17);
          }
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1C61D6C8C(uint64_t *result, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  _DWORD *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v24;
  _DWORD *v25;
  uint64_t v26;

  v4 = (uint64_t)result;
  v5 = result[15];
  v6 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8);
  if ((*(_WORD *)(a2 + 44) & 0xC) != 0 && (*(_WORD *)(a2 + 44) & 4) == 0)
  {
    if ((v6 & 0x80) != 0)
      goto LABEL_7;
    v21 = a2;
    v8 = 1;
    while ((*(_WORD *)(v21 + 44) & 8) != 0)
    {
      v21 = *(_QWORD *)(v21 + 8);
      if ((*(_BYTE *)(*(_QWORD *)(v21 + 16) + 8) & 0x80) != 0)
        goto LABEL_8;
    }
    if ((v6 & 0x80000000) != 0)
      goto LABEL_7;
    v22 = a2;
    v8 = 1;
    while ((*(_WORD *)(v22 + 44) & 8) != 0)
    {
      v22 = *(_QWORD *)(v22 + 8);
      if ((*(_BYTE *)(*(_QWORD *)(v22 + 16) + 11) & 0x80) != 0)
        goto LABEL_8;
    }
  }
  else if ((v6 & 0x80000080) != 0)
  {
LABEL_7:
    v8 = 1;
    goto LABEL_8;
  }
  result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result[3] + 768))(result[3], a2);
  if ((result & 1) != 0)
    goto LABEL_7;
  v8 = **(unsigned __int16 **)(a2 + 16) - 1 < 2;
LABEL_8:
  v9 = *(unsigned int *)(a2 + 40);
  if ((_DWORD)v9)
  {
    v10 = 0;
    v11 = 0;
    v12 = (uint64_t **)(v5 + 56);
    do
    {
      v13 = (_DWORD *)(*(_QWORD *)(a2 + 32) + v10);
      if ((*v13 & 0x10000FF) == 0)
      {
        v14 = v13[1];
        if (v14)
        {
          sub_1C61D6F40(v4, v13[1], a3);
          if (v8)
            sub_1C61D65A0(*(_QWORD **)(v4 + 120), v14, 0);
          if (v11 >= *(unsigned __int16 *)(*(_QWORD *)(a2 + 16) + 2))
            v15 = 0;
          else
            v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 24) + 16))(*(_QWORD *)(v4 + 24));
          v24 = v14;
          v25 = v13;
          v26 = v15;
          result = sub_1C5065534(v12, (int *)&v24);
        }
      }
      ++v11;
      v10 += 32;
    }
    while (v9 != v11);
  }
  if (**(_WORD **)(a2 + 16) == 7)
  {
    v16 = *(unsigned int *)(a2 + 40);
    if ((_DWORD)v16)
    {
      v17 = 0;
      v18 = *(_QWORD *)(a2 + 32);
      v19 = 32 * v16;
      v20 = (unsigned int *)(v18 + 4);
      do
      {
        if (!*((_BYTE *)v20 - 4) && *v20)
        {
          if (v17)
            result = sub_1C61D65A0(*(_QWORD **)(v4 + 120), v17, *v20);
          else
            v17 = *v20;
        }
        v20 += 8;
        v19 -= 32;
      }
      while (v19);
    }
  }
  return result;
}

uint64_t sub_1C61D6EB0(uint64_t a1, int a2, unsigned int a3)
{
  unsigned int RegisterUseOperandIdx;
  uint64_t v7;

  if ((a2 & 0x20000FF) != 0x2000000 || a3 == 0)
    return 0;
  if ((a2 & 0x1000000) != 0)
    RegisterUseOperandIdx = llvm::MachineInstr::findRegisterUseOperandIdx(a1, a3, 1, 0);
  else
    RegisterUseOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx(a1, a3, 0, 0, 0);
  if (RegisterUseOperandIdx == -1)
    return 0;
  v7 = *(_QWORD *)(a1 + 32) + 32 * RegisterUseOperandIdx;
  if (!v7)
    return 0;
  else
    return (*(unsigned __int8 *)(v7 + 3) >> 1) & 1;
}

uint64_t sub_1C61D6F40(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t result;
  _WORD *v11;
  BOOL v12;
  unsigned int v13;
  unsigned __int16 *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int16 v24;
  unsigned __int16 *v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  _DWORD v29[4];
  char v30;
  uint64_t v31;
  unsigned __int16 v32;

  v6 = *(_QWORD *)(a1 + 120);
  v7 = *(_QWORD *)(a1 + 32);
  if (v7)
    v8 = (_QWORD *)(v7 + 8);
  else
    v8 = 0;
  v9 = a2;
  result = sub_1C48385F4((uint64_t)v29, a2, v8, 1);
  if (v31)
  {
    while (1)
    {
LABEL_5:
      v11 = (_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56)
                    + 2 * *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24 * v9 + 8));
      v12 = *v11 == 0;
      if (*v11)
      {
        v13 = (unsigned __int16)*v11 + a2;
        if (v32 != (unsigned __int16)v13)
        {
          v14 = v11 + 1;
          do
          {
            v16 = *v14++;
            v15 = v16;
            v12 = v16 == 0;
            if (!v16)
              v14 = 0;
            if (!v15)
              break;
            v13 += v15;
          }
          while (v32 != (unsigned __int16)v13);
        }
      }
      if (!v12)
      {
        v17 = *(_QWORD *)(a1 + 120);
        if (*(_DWORD *)(*(_QWORD *)(v17 + 80) + 4 * v32) != -1
          && *(_DWORD *)(*(_QWORD *)(v17 + 104) + 4 * v32) == -1)
        {
          break;
        }
      }
      while (1)
      {
        result = sub_1C48386F0((uint64_t)v29);
        if (v30 || v31 == 0)
          break;
        if (v29[0] != v32)
          goto LABEL_5;
      }
      if (!v31)
        goto LABEL_22;
    }
  }
  else
  {
LABEL_22:
    v19 = *(_QWORD *)(a1 + 120);
    if (*(_DWORD *)(*(_QWORD *)(v19 + 80) + 4 * v9) == -1 || *(_DWORD *)(*(_QWORD *)(v19 + 104) + 4 * v9) != -1)
    {
      *(_DWORD *)(*(_QWORD *)(v6 + 80) + 4 * v9) = a3;
      *(_DWORD *)(*(_QWORD *)(v6 + 104) + 4 * v9) = -1;
      sub_1C61D727C((uint64_t **)(v6 + 56), a2);
      result = (uint64_t)sub_1C61D6608(*(_QWORD **)(a1 + 120), a2);
      v20 = *(_QWORD *)(a1 + 32);
      v21 = v20 ? (_QWORD *)(v20 + 8) : 0;
      v22 = v21[6];
      v23 = *(unsigned int *)(*v21 + 24 * v9 + 4);
      if (*(_WORD *)(v22 + 2 * v23))
      {
        v24 = *(_WORD *)(v22 + 2 * v23) + a2;
        v25 = (unsigned __int16 *)(v22 + 2 * v23 + 2);
        do
        {
          v26 = v24;
          v27 = *(_QWORD *)(a1 + 120);
          if (*(_DWORD *)(*(_QWORD *)(v27 + 80) + 4 * v24) == -1
            || *(_DWORD *)(*(_QWORD *)(v27 + 104) + 4 * v24) != -1)
          {
            *(_DWORD *)(*(_QWORD *)(v6 + 80) + 4 * v24) = a3;
            *(_DWORD *)(*(_QWORD *)(v6 + 104) + 4 * v24) = -1;
            sub_1C61D727C((uint64_t **)(v6 + 56), v24);
            result = (uint64_t)sub_1C61D6608(*(_QWORD **)(a1 + 120), v26);
          }
          v28 = *v25++;
          v24 = v28 + v26;
        }
        while (v28);
      }
    }
  }
  return result;
}

uint64_t llvm::createAggressiveAntiDepBreaker(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  v6 = operator new();
  return sub_1C61D6674(v6, a1, a2, a3);
}

uint64_t sub_1C61D71B4(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = *(void **)(a1 + 104);
  if (v2)
  {
    *(_QWORD *)(a1 + 112) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 80);
  if (v3)
  {
    *(_QWORD *)(a1 + 88) = v3;
    operator delete(v3);
  }
  sub_1C6143384(*(_QWORD **)(a1 + 64));
  v4 = *(void **)(a1 + 32);
  if (v4)
  {
    *(_QWORD *)(a1 + 40) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 8);
  if (v5)
  {
    *(_QWORD *)(a1 + 16) = v5;
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_1C61D721C(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  int v8;

  v4 = **(unsigned __int16 **)(a2 + 16);
  if ((v4 - 13) > 1)
  {
    result = *(_QWORD *)(a2 + 32);
    if (*(_BYTE *)result)
      return result;
    v8 = *(_DWORD *)(result + 4);
  }
  else
  {
    v5 = v4 == 14;
    v6 = *(_QWORD *)(a2 + 32);
    result = v6 + (v5 << 6);
    if (*(_BYTE *)result)
      return result;
    v8 = *(_DWORD *)(v6 + ((unint64_t)v5 << 6) + 4);
  }
  if (v8 == a3)
    return llvm::MachineOperand::setReg(result, a4);
  return result;
}

void sub_1C61D727C(uint64_t **a1, unsigned int a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;

  v3 = sub_1C50654A4((uint64_t)a1, a2);
  if (v3 != v4)
  {
    v5 = v3;
    v6 = v4;
    do
    {
      v7 = sub_1C485B670(a1, v5);
      operator delete(v5);
      v5 = v7;
    }
    while (v7 != v6);
  }
}

void sub_1C61D72D8(_QWORD *a1)
{
  _QWORD *v2;

  if (a1)
  {
    sub_1C61D72D8(*a1);
    sub_1C61D72D8(a1[1]);
    v2 = (_QWORD *)a1[5];
    if (v2 != a1 + 7)
      free(v2);
    operator delete(a1);
  }
}

uint64_t llvm::getFCmpCodeWithoutNaN(uint64_t result)
{
  int v1;

  v1 = result - 1;
  if ((result - 1) <= 0xD && ((0x3F3Fu >> v1) & 1) != 0)
    return dword_1C85FA574[v1];
  return result;
}

unsigned int *sub_1C61D7360(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unsigned int *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _DWORD *v11;
  int v12;

  v6 = a3;
  v7 = result;
  v8 = a3 - a5;
  v9 = result[2];
  v10 = v9 + ((a3 - a5) >> 2);
  if (v10 > result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v10, 4);
    v9 = v7[2];
  }
  if (v6 != a5)
  {
    v11 = (_DWORD *)(*(_QWORD *)v7 + 4 * v9);
    do
    {
      v12 = *(_DWORD *)(v6 - 4);
      v6 -= 4;
      *v11++ = v12;
    }
    while (v6 != a5);
    LODWORD(v9) = v7[2];
  }
  v7[2] = v9 + (v8 >> 2);
  return result;
}

uint64_t sub_1C61D73E4(uint64_t a1, uint64_t a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;

  v12 = 0;
  result = sub_1C61252B8((uint64_t *)a2, a3, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C6128C6C(a2, (uint64_t)a3, a3, v12);
    v9 = (_QWORD *)result;
    *(_QWORD *)result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

void llvm::initializeAtomicExpandPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F4EF0);
  if (v2 != -1)
  {
    v5[0] = sub_1C5067A80;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F4EF0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::expandAtomicRMWToCmpXchg(uint64_t a1, void (*a2)(uint64_t, uint64_t *, uint64_t, llvm::PHINode *, uint64_t, uint64_t, uint64_t, _QWORD, llvm::Value **, uint64_t *), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  llvm::Value *v10;
  llvm::Instruction **v12;
  llvm::Instruction *v13;
  void *v14[2];
  _QWORD v15[16];

  v15[15] = *MEMORY[0x1E0C80C00];
  v13 = (llvm::Instruction *)a1;
  sub_1C4773D54((uint64_t)v14, a1, 0, 0, 0);
  v6 = *(_QWORD *)a1;
  v7 = *(_QWORD *)(a1 - 64);
  v8 = *(unsigned __int16 *)(a1 + 18);
  v9 = *(unsigned __int8 *)(a1 + 60);
  v12 = &v13;
  v10 = (llvm::Value *)sub_1C5067C04((uint64_t *)v14, v6, v7, BYTE1(v8) & 0x3F, (v8 >> 1) & 7, v9, (uint64_t (*)(uint64_t, uint64_t *, llvm::PHINode *))sub_1C506F728, (uint64_t)&v12, a2, a3);
  llvm::Value::doRAUW(v13, v10, (llvm::Value *)1);
  llvm::Instruction::eraseFromParent(v13);
  if (v14[0] != v15)
    free(v14[0]);
  return 1;
}

unsigned __int8 **sub_1C61D75CC(uint64_t *a1, uint64_t a2, uint64_t ***a3, uint64_t *a4, __int16 a5, __int16 a6, __int16 a7, char a8)
{
  unint64_t v11;
  const char *v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  unsigned __int8 **v21;
  char *v22;
  char v24[32];
  __int16 v25;

  LOBYTE(v11) = a5;
  if ((a5 & 0xFF00) == 0)
  {
    sub_1C4768AD0(*(_QWORD *)(*(_QWORD *)(a1[6] + 56) + 40) + 272, *a4);
    v18 = (unint64_t)(v17 + 7) >> 3;
    if ((_DWORD)v16 == 1)
    v11 = 63 - __clz(v18);
  }
  v19 = (char *)operator new(0xA0uLL);
  v20 = 0;
  v21 = (unsigned __int8 **)(v19 + 96);
  *((_DWORD *)v19 + 29) = *((_DWORD *)v19 + 29) & 0x38000000 | 3;
  do
  {
    v22 = &v19[v20];
    *(_QWORD *)v22 = 0;
    *((_QWORD *)v22 + 1) = 0;
    *((_QWORD *)v22 + 2) = 0;
    *((_QWORD *)v22 + 3) = v21;
    v20 += 32;
  }
  while (v20 != 96);
  llvm::AtomicCmpXchgInst::AtomicCmpXchgInst((uint64_t)(v19 + 96), a2, a3, (uint64_t)a4, v11, a6, a7, a8, 0);
  v25 = 257;
  return sub_1C61D76F0(a1, v21, (uint64_t)v24);
}

unsigned __int8 **sub_1C61D76F0(uint64_t *a1, unsigned __int8 **a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  (*(void (**)(uint64_t, unsigned __int8 **, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1[10] + 16))(a1[10], a2, a3, a1[6], a1[7]);
  v5 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v5)
  {
    v6 = *a1;
    v7 = v6 + 16 * v5;
    do
    {
      llvm::Instruction::setMetadata(a2, *(_DWORD *)v6, *(llvm::MDNode **)(v6 + 8));
      v6 += 16;
    }
    while (v6 != v7);
  }
  return a2;
}

unsigned __int8 **sub_1C61D775C(uint64_t *a1, __int16 a2, uint64_t a3, uint64_t *a4, __int16 a5, __int16 a6, char a7)
{
  unint64_t v9;
  const char *v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  unsigned __int8 **v18;
  _BYTE v20[32];
  __int16 v21;

  LOBYTE(v9) = a5;
  if ((a5 & 0xFF00) == 0)
  {
    sub_1C4768AD0(*(_QWORD *)(*(_QWORD *)(a1[6] + 56) + 40) + 272, *a4);
    v16 = (unint64_t)(v15 + 7) >> 3;
    if ((_DWORD)v14 == 1)
    v9 = 63 - __clz(v16);
  }
  v17 = (char *)operator new(0x80uLL);
  *((_DWORD *)v17 + 21) = *((_DWORD *)v17 + 21) & 0x38000000 | 2;
  v18 = (unsigned __int8 **)(v17 + 64);
  *(_QWORD *)v17 = 0;
  *((_QWORD *)v17 + 1) = 0;
  *((_QWORD *)v17 + 2) = 0;
  *((_QWORD *)v17 + 3) = v17 + 64;
  *((_QWORD *)v17 + 4) = 0;
  *((_QWORD *)v17 + 5) = 0;
  *((_QWORD *)v17 + 6) = 0;
  *((_QWORD *)v17 + 7) = v17 + 64;
  llvm::AtomicRMWInst::AtomicRMWInst((uint64_t)(v17 + 64), a2, a3, a4, v9, a6, a7, 0);
  v21 = 257;
  return sub_1C61D76F0(a1, v18, (uint64_t)v20);
}

uint64_t sub_1C61D7864(uint64_t (*a1)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  return a1(a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

unsigned __int8 **LLVMBuildUnreachable_0(uint64_t a1)
{
  llvm::UnreachableInst *v2;
  _BYTE v4[32];
  __int16 v5;

  v2 = (llvm::UnreachableInst *)operator new(0x40uLL);
  *((_DWORD *)v2 + 5) &= 0x38000000u;
  llvm::UnreachableInst::UnreachableInst(v2, *(llvm::LLVMContext **)(a1 + 64), 0);
  v5 = 257;
  return sub_1C61D76F0((uint64_t *)a1, (unsigned __int8 **)v2, (uint64_t)v4);
}

llvm::BasicTTIImpl *llvm::BasicTTIImpl::BasicTTIImpl(llvm::BasicTTIImpl *this, const llvm::TargetMachine *a2, const llvm::Function *a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((_QWORD *)a3 + 5) + 272;
  *(_QWORD *)this = &unk_1E813FF40;
  *((_QWORD *)this + 1) = v4;
  v5 = (*(uint64_t (**)(const llvm::TargetMachine *, const llvm::Function *))(*(_QWORD *)a2 + 16))(a2, a3);
  *((_QWORD *)this + 2) = v5;
  *((_QWORD *)this + 3) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 120))(v5);
  return this;
}

void sub_1C61D795C()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61D7970(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D7980(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 56))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D7990(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D79A0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 88))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D79B0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 72))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1C61D79C0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 80))(*(_QWORD *)(a1 + 16));
}

void sub_1C61D79D0(int **a1, __int128 *a2, _WORD *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&llvm::PartialUnrollingThreshold, 0, 0);
  dword_1ED82EED0 = 0;
  qword_1ED82EED8 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED82EEE0 = 0;
  llvm::PartialUnrollingThreshold = (uint64_t)&unk_1E819E3B0;
  qword_1ED82EEE8 = (uint64_t)&unk_1E819E2C0;
  qword_1ED82EEF0 = (uint64_t)&off_1E7F95260;
  qword_1ED82EF08 = (uint64_t)&qword_1ED82EEF0;
  llvm::cl::Option::setArgStr(v6, "partial-unrolling-threshold", 0x1BuLL);
  dword_1ED82EED0 = **a1;
  byte_1ED82EEE4 = 1;
  dword_1ED82EEE0 = dword_1ED82EED0;
  xmmword_1ED82EE70 = *a2;
  word_1ED82EE5A = (32 * (*a3 & 3)) | word_1ED82EE5A & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::PartialUnrollingThreshold);
}

void llvm::initializeBranchFolderPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F4EF8);
  if (v2 != -1)
  {
    v5[0] = sub_1C506F890;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F4EF8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61D7B10(uint64_t result, char a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = result + 56;
  *(_QWORD *)(result + 32) = result + 56;
  *(_QWORD *)(result + 40) = 2;
  *(_DWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 72) = 0;
  *(_QWORD *)(result + 80) = 0;
  *(_DWORD *)(result + 88) = 0;
  *(_QWORD *)(result + 104) = 0;
  *(_QWORD *)(result + 112) = 0;
  *(_QWORD *)(result + 96) = 0;
  *(_BYTE *)(result + 122) = a3;
  *(_DWORD *)(result + 124) = a7;
  *(_QWORD *)(result + 160) = 0;
  *(_QWORD *)(result + 168) = result + 192;
  *(_OWORD *)(result + 176) = xmmword_1C6464ED0;
  *(_QWORD *)(result + 208) = 0;
  *(_DWORD *)(result + 216) = 0;
  *(_QWORD *)(result + 224) = a4;
  *(_QWORD *)(result + 232) = a5;
  *(_QWORD *)(result + 240) = a6;
  if (!a7)
    *(_DWORD *)(result + 124) = dword_1ED7F5100;
  if (dword_1ED7F4F80)
  {
    if (dword_1ED7F4F80 == 2)
    {
      a2 = 0;
    }
    else
    {
      if (dword_1ED7F4F80 != 1)
        return result;
      a2 = 1;
    }
  }
  *(_BYTE *)(result + 121) = a2;
  return result;
}

int32x2_t sub_1C61D7BAC(uint64_t a1, llvm::MachineBasicBlock *a2)
{
  int32x2_t *v4;
  uint64_t i;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t j;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  int32x2_t result;
  int32x2_t *v15;
  llvm::MachineBasicBlock *v16;
  _QWORD *v17;

  v16 = a2;
  v4 = (int32x2_t *)*((_QWORD *)a2 + 4);
  v6 = *((_QWORD *)a2 + 11);
  for (i = *((_QWORD *)a2 + 12); v6 != i; i = *((_QWORD *)a2 + 12))
  {
    llvm::MachineBasicBlock::removeSuccessor((uint64_t)a2, (char *)(i - 8), 0);
    v6 = *((_QWORD *)a2 + 11);
  }
  v7 = sub_1C477672C(a1 + 24, (uint64_t)a2);
  v8 = *(_QWORD *)(a1 + 32);
  v9 = 40;
  if (v8 == *(_QWORD *)(a1 + 24))
    v9 = 44;
  if (v7 != (_QWORD *)(v8 + 8 * *(unsigned int *)(a1 + v9)))
  {
    *v7 = -2;
    ++*(_DWORD *)(a1 + 48);
  }
  for (j = *((_QWORD *)a2 + 7);
        (llvm::MachineBasicBlock *)j != (llvm::MachineBasicBlock *)((char *)a2 + 48);
        j = *(_QWORD *)(j + 8))
  {
    if (llvm::MachineInstr::shouldUpdateCallSiteInfo((llvm::MachineInstr *)j))
      llvm::MachineFunction::eraseCallSiteInfo(v4, (const llvm::MachineInstr *)j);
    if (!j || (*(_BYTE *)j & 4) == 0)
    {
      while ((*(_WORD *)(j + 44) & 8) != 0)
        j = *(_QWORD *)(j + 8);
    }
  }
  v11 = (uint64_t)&v4[40];
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::removeNodeFromList(v11, (uint64_t)a2);
  v12 = *(_QWORD *)a2;
  v13 = (_QWORD *)*((_QWORD *)a2 + 1);
  *v13 = *(_QWORD *)a2;
  *(_QWORD *)(v12 + 8) = v13;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  llvm::ilist_alloc_traits<llvm::MachineBasicBlock>::deleteNode(v11, a2);
  v17 = 0;
  if (sub_1C61252B8((uint64_t *)(a1 + 72), &v16, &v17))
  {
    *v17 = -8192;
    result = vadd_s32(*(int32x2_t *)(a1 + 80), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 80) = result;
  }
  v15 = *(int32x2_t **)(a1 + 152);
  if (v15)
    return llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeBlock(v15 + 31, (uint64_t)v16);
  return result;
}

uint64_t sub_1C61D7D18(uint64_t a1, llvm::MachineFunction *this)
{
  const llvm::MachineFunction *v4;
  uint64_t *v5;
  uint64_t *v6;
  char v7;
  uint64_t *v8;
  char v9;
  uint64_t v11;
  uint64_t v12;
  int v13;

  llvm::MachineFunction::RenumberBlocks(this, 0);
  llvm::getEHScopeMembership(this, v4, (uint64_t)&v11);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 72), 8);
  *(_QWORD *)(a1 + 72) = v11;
  *(_QWORD *)(a1 + 80) = v12;
  v11 = 0;
  v12 = 0;
  *(_DWORD *)(a1 + 88) = v13;
  v13 = 0;
  MEMORY[0x1CAA32FB4](0, 8);
  v5 = (uint64_t *)((char *)this + 320);
  v6 = *(uint64_t **)(*((_QWORD *)this + 41) + 8);
  if (v6 == v5)
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    do
    {
      v8 = (uint64_t *)v6[1];
      v9 = sub_1C50721C0(a1, v6);
      if (v6[8] == v6[9])
      {
        sub_1C61D7BAC(a1, (llvm::MachineBasicBlock *)v6);
        v7 = 1;
      }
      else
      {
        v7 |= v9;
      }
      v6 = v8;
    }
    while (v8 != v5);
  }
  return v7 & 1;
}

uint64_t sub_1C61D7E04(uint64_t a1, unint64_t *a2, llvm::MachineBasicBlock *a3)
{
  const llvm::MachineFunction **v6;
  const llvm::MachineInstr *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unsigned int v11;
  unsigned __int8 *v13;

  if (*(_BYTE *)(a1 + 123))
  {
    v6 = (const llvm::MachineFunction **)a2[3];
    *(_QWORD *)(a1 + 176) = 0;
    llvm::LivePhysRegs::addLiveOuts((llvm::LivePhysRegs *)(a1 + 160), v6);
    v7 = (const llvm::MachineInstr *)(v6 + 6);
    do
    {
      v7 = (const llvm::MachineInstr *)(*(_QWORD *)v7 & 0xFFFFFFFFFFFFFFF8);
      if (!v7 || (*(_BYTE *)v7 & 4) == 0)
      {
        while ((*((_WORD *)v7 + 22) & 4) != 0)
          v7 = (const llvm::MachineInstr *)(*(_QWORD *)v7 & 0xFFFFFFFFFFFFFFF8);
      }
      llvm::LivePhysRegs::stepBackward((llvm::LivePhysRegs *)(a1 + 160), v7);
    }
    while (v7 != (const llvm::MachineInstr *)a2);
    v8 = llvm::MachineBasicBlock::livein_begin(a3);
    v9 = (unsigned __int16 *)*((_QWORD *)a3 + 20);
    if (v9 != (unsigned __int16 *)v8)
    {
      v10 = (unsigned __int16 *)v8;
      do
      {
        v11 = *v10;
        if (llvm::LivePhysRegs::available((llvm::LivePhysRegs *)(a1 + 160), *(const llvm::MachineRegisterInfo **)(a1 + 136), v11))
        {
          v13 = 0;
          sub_1C4787570((uint64_t)v6, a2, &v13, *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 480, v11);
          if (v13)
            llvm::MetadataTracking::untrack((uint64_t)&v13, v13);
        }
        v10 += 8;
      }
      while (v10 != v9);
    }
  }
  return (*(uint64_t (**)(_QWORD, unint64_t *, llvm::MachineBasicBlock *))(**(_QWORD **)(a1 + 128)
                                                                                          + 304))(*(_QWORD *)(a1 + 128), a2, a3);
}

unint64_t sub_1C61D7F30(uint64_t a1, unint64_t a2, unint64_t *a3, const llvm::BasicBlock *a4)
{
  unint64_t MachineBasicBlock;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t BlockFreq;
  const llvm::MachineBasicBlock *v19;
  const llvm::LivePhysRegs *v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;

  if (!(*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 128) + 312))(*(_QWORD *)(a1 + 128)))
    return 0;
  MachineBasicBlock = llvm::MachineFunction::CreateMachineBasicBlock(*(llvm::MachineFunction **)(a2 + 32), a4);
  v22 = MachineBasicBlock;
  v10 = *(unint64_t **)(a2 + 8);
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList(*(_QWORD *)(a2 + 32) + 320, MachineBasicBlock);
  v11 = *v10;
  *(_QWORD *)MachineBasicBlock = *v10;
  *(_QWORD *)(MachineBasicBlock + 8) = v10;
  *(_QWORD *)(v11 + 8) = MachineBasicBlock;
  *v10 = MachineBasicBlock;
  llvm::MachineBasicBlock::transferSuccessors((char *)MachineBasicBlock, (llvm::MachineBasicBlock *)a2);
  llvm::MachineBasicBlock::addSuccessor((_QWORD *)a2, (_QWORD *)MachineBasicBlock, -1);
  v12 = (unint64_t *)(a2 + 48);
  if ((unint64_t *)(a2 + 48) != a3 && MachineBasicBlock != a2)
  {
    v13 = *(_QWORD *)(MachineBasicBlock + 40);
    v14 = a3;
    do
    {
      v14[3] = v13;
      v14 = (unint64_t *)v14[1];
    }
    while (v14 != v12);
    sub_1C4785D30((unint64_t *)(MachineBasicBlock + 48), a3, v12);
  }
  v15 = *(_QWORD *)(a1 + 152);
  if (v15)
  {
    v23 = 0;
    v24 = a2;
    if ((sub_1C48BF0C0((uint64_t *)(v15 + 248), &v24, &v23) & 1) != 0)
    {
      v16 = *(_QWORD **)(v23 + 8);
      if (v16)
        llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBasicBlockToLoop(v16, MachineBasicBlock, *(_QWORD *)(a1 + 152) + 248);
    }
  }
  v17 = *(uint64_t **)(a1 + 224);
  BlockFreq = llvm::MBFIWrapper::getBlockFreq((llvm::MBFIWrapper *)v17, (const llvm::MachineBasicBlock *)a2);
  v24 = MachineBasicBlock;
  sub_1C6204DEC(v17 + 1, &v24)[1] = BlockFreq;
  if (*(_BYTE *)(a1 + 123))
  {
    llvm::computeLiveIns((llvm *)(a1 + 160), (llvm::LivePhysRegs *)MachineBasicBlock, v19);
    llvm::addLiveIns((llvm *)MachineBasicBlock, (llvm::MachineBasicBlock *)(a1 + 160), v20);
  }
  v23 = a2;
  v24 = 0;
  if (sub_1C61252B8((uint64_t *)(a1 + 72), &v23, &v24)
    && v24 != *(_QWORD *)(a1 + 72) + 16 * *(unsigned int *)(a1 + 88))
  {
    v21 = *(_DWORD *)(v24 + 8);
    *((_DWORD *)sub_1C6128C08((uint64_t *)(a1 + 72), &v22) + 2) = v21;
    return v22;
  }
  return MachineBasicBlock;
}

void sub_1C61D80F0(_QWORD *a1, int a2, uint64_t a3, llvm::MachineBasicBlock *a4)
{
  _DWORD *v8;
  _DWORD *v9;
  _DWORD *v10;
  int v11;
  llvm::MachineBasicBlock *v12;
  _DWORD *v13;

  v8 = (_DWORD *)*a1;
  v9 = (_DWORD *)(a1[1] - 16);
  while (1)
  {
    v10 = v9;
    v11 = *v9;
    if (v11 != a2)
      break;
    if (a3)
    {
      v12 = (llvm::MachineBasicBlock *)*((_QWORD *)v10 + 1);
      if (v12 != a4)
        sub_1C5071AC8(v12, a3, a1[16]);
    }
    v9 = v10 - 4;
    if (v10 == v8)
    {
      v11 = *v8;
      goto LABEL_9;
    }
  }
  v8 = v10;
LABEL_9:
  if (v11 == a2)
    v13 = v8;
  else
    v13 = v10 + 4;
  if (v13 != (_DWORD *)a1[1])
    a1[1] = v13;
}

void sub_1C61D81B0(uint64_t a1, unsigned int a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v5;
  uint64_t v6;
  llvm *v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  llvm::MachineFunction *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  int v33;
  unsigned __int8 *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t i;
  int v39;
  llvm::DILocation *v41;
  const llvm::DILocation *v42;
  const llvm::DILocation *v43;
  llvm::DILocation *MergedLocation;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  const llvm::LivePhysRegs *v50;
  const llvm::MachineFunction ***v51;
  const llvm::MachineFunction ***v52;
  const llvm::MachineFunction **v53;
  unint64_t FirstTerminator;
  unint64_t *v55;
  unsigned __int16 *v56;
  uint64_t v57;
  unsigned int v58;
  llvm *v59;
  uint64_t v60;
  char *v61;
  unsigned __int8 *v62;
  unsigned __int8 *v63;
  unsigned __int8 *v64;
  void *v65;
  __int128 v66;
  _BYTE v67[16];
  void *v68;
  int v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v7 = *(llvm **)(*(_QWORD *)(v6 + 16 * a2) + 8);
  v8 = v5 - v6;
  v59 = v7;
  if (v5 == v6)
  {
    v61 = 0;
    v10 = 0;
  }
  else
  {
    if ((v8 & 0x8000000000000000) != 0)
      abort();
    v9 = v8 >> 1;
    v10 = (char *)operator new(v8 >> 1);
    v60 = v9 & 0x7FFFFFFFFFFFFFF8;
    bzero(v10, v9 & 0x7FFFFFFFFFFFFFF8);
    v11 = 0;
    v12 = 0;
    v13 = (_QWORD *)((char *)v7 + 48);
    do
    {
      if (v12 != a2)
      {
        v14 = v6 + 16 * v11;
        *(_QWORD *)&v10[8 * v11] = *(_QWORD *)(v14 + 8);
        v15 = *(_QWORD *)(v14 + 8);
        v16 = *(_QWORD *)(v15 + 24);
        v17 = (_QWORD *)(v16 + 48);
        if (v15 == v16 + 48)
        {
          v18 = 0;
        }
        else
        {
          v18 = 0;
          do
          {
            if (!v15 || (*(_BYTE *)v15 & 4) == 0)
            {
              while ((*(_WORD *)(v15 + 44) & 8) != 0)
                v15 = *(_QWORD *)(v15 + 8);
            }
            ++v18;
            v15 = *(_QWORD *)(v15 + 8);
          }
          while ((_QWORD *)v15 != v17);
        }
        v19 = *v17 & 0xFFFFFFFFFFFFFFF8;
        if (!v19 || (*(_BYTE *)v19 & 4) == 0)
        {
          while ((*(_WORD *)(v19 + 44) & 4) != 0)
            v19 = *(_QWORD *)v19 & 0xFFFFFFFFFFFFFFF8;
        }
        v20 = *v13 & 0xFFFFFFFFFFFFFFF8;
        if (!v20 || (*(_BYTE *)v20 & 4) == 0)
        {
          while ((*(_WORD *)(v20 + 44) & 4) != 0)
            v20 = *(_QWORD *)v20 & 0xFFFFFFFFFFFFFFF8;
        }
        while (v18)
        {
          --v18;
          v21 = **(unsigned __int16 **)(v19 + 16);
          if ((v21 - 13) < 5 || v21 == 3)
          {
            v19 = *(_QWORD *)v19 & 0xFFFFFFFFFFFFFFF8;
            if (!v19 || (*(_BYTE *)v19 & 4) == 0)
            {
              while ((*(_WORD *)(v19 + 44) & 4) != 0)
                v19 = *(_QWORD *)v19 & 0xFFFFFFFFFFFFFFF8;
            }
          }
          else
          {
            v46 = (uint64_t)v13;
            if ((_QWORD *)v20 != v13)
            {
              do
              {
                v26 = **(unsigned __int16 **)(v20 + 16);
                if ((v26 - 13) >= 5 && v26 != 3)
                {
                  v46 = v20;
                  goto LABEL_62;
                }
                v20 = *(_QWORD *)v20 & 0xFFFFFFFFFFFFFFF8;
                if (!v20 || (*(_BYTE *)v20 & 4) == 0)
                {
                  while ((*(_WORD *)(v20 + 44) & 4) != 0)
                    v20 = *(_QWORD *)v20 & 0xFFFFFFFFFFFFFFF8;
                }
              }
              while ((_QWORD *)v20 != v13);
              v46 = (uint64_t)v13;
            }
LABEL_62:
            if ((sub_1C5073EC0(v46, 1) & 1) != 0 || sub_1C5073F60(v46, 1))
            {
              v28 = *(llvm::MachineFunction **)(v16 + 32);
              v64 = (unsigned __int8 *)v46;
              v65 = (void *)v19;
              llvm::MachineInstr::cloneMergedMemRefs((llvm::MachineInstr *)v46, v28, (const llvm::MachineInstr **)&v64, 2);
            }
            v29 = *(unsigned int *)(v46 + 40);
            if ((_DWORD)v29)
            {
              v25 = 0;
              v30 = 32 * v29;
              do
              {
                v23 = *(_QWORD *)(v46 + 32);
                v24 = *(_DWORD *)(v23 + v25);
                if ((v24 & 0x100000FF) == 0x10000000 && (*(_BYTE *)(*(_QWORD *)(v19 + 32) + v25 + 3) & 0x10) == 0)
                  *(_DWORD *)(v23 + v25) = v24 & 0xEFFFFFFF;
                v25 += 32;
              }
              while (v30 != v25);
            }
            v19 = *(_QWORD *)v19 & 0xFFFFFFFFFFFFFFF8;
            if (!v19 || (*(_BYTE *)v19 & 4) == 0)
            {
              while ((*(_WORD *)(v19 + 44) & 4) != 0)
                v19 = *(_QWORD *)v19 & 0xFFFFFFFFFFFFFFF8;
            }
            v20 = *(_QWORD *)v46 & 0xFFFFFFFFFFFFFFF8;
            if (!v20 || (*(_BYTE *)v20 & 4) == 0)
            {
              while ((*(_WORD *)(v20 + 44) & 4) != 0)
                v20 = *(_QWORD *)v20 & 0xFFFFFFFFFFFFFFF8;
            }
          }
        }
      }
      v6 = *(_QWORD *)(a1 + 96);
      v11 = ++v12;
    }
    while (v12 != (*(_QWORD *)(a1 + 104) - v6) >> 4);
    v7 = v59;
    v61 = &v10[v60];
  }
  v31 = (char *)v7 + 48;
  v32 = *((_QWORD *)v7 + 7);
  if ((llvm *)v32 != (llvm *)((char *)v7 + 48))
  {
    do
    {
      v33 = **(unsigned __int16 **)(v32 + 16);
      if ((v33 - 13) >= 5 && v33 != 3)
      {
        v35 = *(unsigned __int8 **)(v32 + 56);
        v64 = v35;
        if (v35)
          llvm::MetadataTracking::track((uint64_t)&v64, v35, 2);
        if (v61 != v10)
        {
          v36 = 0;
          v37 = 0;
          do
          {
            if (v37 != a2)
            {
              for (i = *(_QWORD *)&v10[8 * v36]; ; *(_QWORD *)&v10[8 * v36] = i)
              {
                v39 = **(unsigned __int16 **)(i + 16);
                if ((v39 - 13) >= 5 && v39 != 3)
                  break;
                if ((*(_BYTE *)i & 4) == 0)
                {
                  while ((*(_WORD *)(i + 44) & 8) != 0)
                    i = *(_QWORD *)(i + 8);
                }
                i = *(_QWORD *)(i + 8);
              }
              v41 = (llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)&v64);
              v42 = (const llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)(*(_QWORD *)&v10[8 * v36] + 56));
              MergedLocation = llvm::DILocation::getMergedLocation(v41, v42, v43);
              llvm::DebugLoc::DebugLoc((llvm::DebugLoc *)&v63, MergedLocation);
              sub_1C49264C4(&v64, &v63);
              if (v63)
                llvm::MetadataTracking::untrack((uint64_t)&v63, v63);
              v45 = *(_QWORD *)&v10[8 * v36];
              if (!v45 || (*(_BYTE *)v45 & 4) == 0)
              {
                while ((*(_WORD *)(v45 + 44) & 8) != 0)
                  v45 = *(_QWORD *)(v45 + 8);
              }
              *(_QWORD *)&v10[8 * v36] = *(_QWORD *)(v45 + 8);
            }
            v36 = ++v37;
          }
          while ((v61 - v10) >> 3 > (unint64_t)v37);
        }
        v62 = v64;
        if (v64)
          llvm::MetadataTracking::track((uint64_t)&v62, v64, 2);
        sub_1C49264C4((unsigned __int8 **)(v32 + 56), &v62);
        if (v62)
          llvm::MetadataTracking::untrack((uint64_t)&v62, v62);
        if (v64)
          llvm::MetadataTracking::untrack((uint64_t)&v64, v64);
        if (!v32)
          goto LABEL_113;
      }
      if ((*(_BYTE *)v32 & 4) == 0)
      {
LABEL_113:
        while ((*(_WORD *)(v32 + 44) & 8) != 0)
          v32 = *(_QWORD *)(v32 + 8);
      }
      v32 = *(_QWORD *)(v32 + 8);
    }
    while ((char *)v32 != v31);
  }
  if (*(_BYTE *)(a1 + 123))
  {
    v47 = *(_QWORD *)(a1 + 144);
    v64 = (unsigned __int8 *)v47;
    v65 = v67;
    v66 = xmmword_1C6464ED0;
    v68 = 0;
    v69 = 0;
    v48 = *(_DWORD *)(v47 + 16);
    if (v48)
    {
      v68 = sub_1C5074000(*(unsigned int *)(v47 + 16), 1uLL);
      v69 = v48;
    }
    llvm::computeLiveIns((llvm *)&v64, v59, a3);
    v49 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(a1 + 160) = v49;
    *(_QWORD *)(a1 + 176) = 0;
    sub_1C61D8D14((void *)(a1 + 168), *(_DWORD *)(v49 + 16));
    v51 = (const llvm::MachineFunction ***)*((_QWORD *)v59 + 8);
    v52 = (const llvm::MachineFunction ***)*((_QWORD *)v59 + 9);
    while (v51 != v52)
    {
      v53 = *v51;
      *(_QWORD *)(a1 + 176) = 0;
      llvm::LivePhysRegs::addLiveOuts((llvm::LivePhysRegs *)(a1 + 160), v53);
      FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator((llvm::MachineBasicBlock *)v53);
      if ((_QWORD)v66)
      {
        v55 = (unint64_t *)FirstTerminator;
        v56 = (unsigned __int16 *)v65;
        v57 = 2 * v66;
        do
        {
          v58 = *v56;
          if (llvm::LivePhysRegs::available((llvm::LivePhysRegs *)(a1 + 160), *(const llvm::MachineRegisterInfo **)(a1 + 136), v58))
          {
            v63 = 0;
            sub_1C4787570((uint64_t)v53, v55, &v63, *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 480, v58);
            if (v63)
              llvm::MetadataTracking::untrack((uint64_t)&v63, v63);
          }
          ++v56;
          v57 -= 2;
        }
        while (v57);
      }
      ++v51;
    }
    *((_QWORD *)v59 + 20) = *((_QWORD *)v59 + 19);
    llvm::addLiveIns(v59, (llvm::MachineBasicBlock *)&v64, v50);
    free(v68);
    if (v65 != v67)
      free(v65);
  }
  if (v10)
    operator delete(v10);
}

uint64_t sub_1C61D87E4(_QWORD *a1, uint64_t a2, llvm::MachineBasicBlock *a3, unsigned int a4)
{
  void *v7;
  uint64_t v8;
  unint64_t v9;
  char v10;
  int v11;
  llvm::MachineBasicBlock *v12;
  char *v13;
  char *v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  llvm::MachineBasicBlock *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  const llvm::MachineBasicBlock *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v35;
  llvm::MachineBasicBlock *v36;

  v36 = a3;
  v7 = (void *)*a1;
  v8 = a1[1];
  v9 = v8 - (_QWORD)v7;
  if (v8 - (uint64_t)v7 >= 32)
  {
    qsort(v7, v9 >> 4, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1C5074060);
    v8 = a1[1];
    v9 = v8 - *a1;
  }
  if (v9 >= 0x11)
  {
    v10 = 0;
    while (1)
    {
      v11 = *(_DWORD *)(v8 - 16);
      v12 = v36;
      sub_1C5071178(a1, v11, a4, a2, v36);
      v13 = (char *)a1[12];
      v14 = (char *)a1[13];
      if (v13 == v14)
      {
        v15 = a1;
        v16 = v11;
        v17 = a2;
        v18 = v12;
      }
      else
      {
        v19 = v14 - v13;
        v20 = (unint64_t)v19 >> 4;
        if (v19 != 32)
        {
          if ((v19 & 0xFFFFFFFF0) != 0)
          {
LABEL_18:
            v23 = 0;
            v24 = v13 + 8;
            do
            {
              v25 = *(_QWORD *)(*(v24 - 1) + 8);
              if (v25 != *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 8) + 32) + 328) && !*(_BYTE *)(v25 + 184)
                || *v24 != *(_QWORD *)(v25 + 56))
              {
                if ((llvm::MachineBasicBlock *)v25 == v12)
                {
                  v35 = v23;
                  LODWORD(v20) = v23;
                  goto LABEL_27;
                }
                if (*v24 == *(_QWORD *)(v25 + 56))
                  LODWORD(v20) = v23;
              }
              ++v23;
              v24 += 2;
            }
            while (((unint64_t)v19 >> 4) != v23);
          }
LABEL_26:
          v35 = v20;
          goto LABEL_27;
        }
        v21 = *(_QWORD *)(*(_QWORD *)v13 + 8);
        v22 = *(_QWORD *)(*((_QWORD *)v13 + 2) + 8);
        if (*(_QWORD *)(v21 + 8) == v22 && *((_QWORD *)v13 + 3) == *(_QWORD *)(v22 + 56) && !*(_BYTE *)(v22 + 184))
        {
          LODWORD(v20) = 1;
          goto LABEL_26;
        }
        if (*(_QWORD *)(v22 + 8) != v21 || *((_QWORD *)v13 + 1) != *(_QWORD *)(v21 + 56) || *(_BYTE *)(v21 + 184))
          goto LABEL_18;
        LODWORD(v20) = 0;
        v35 = 0;
LABEL_27:
        v26 = v20;
        if (v20 != v19 >> 4)
        {
          if (*(llvm::MachineBasicBlock **)(*(_QWORD *)&v13[16 * v20] + 8) != v12)
          {
            v12 = *(llvm::MachineBasicBlock **)(*(_QWORD *)&v13[16 * v20] + 8);
            goto LABEL_30;
          }
          if (*(_QWORD *)&v13[16 * v20 + 8] == *((_QWORD *)v12 + 7))
            goto LABEL_30;
        }
        if (sub_1C5071C7C((uint64_t)a1, (unint64_t *)&v36, a2, &v35))
        {
          v26 = v35;
          v12 = *(llvm::MachineBasicBlock **)(*(_QWORD *)(a1[12] + 16 * v35) + 8);
          LODWORD(v20) = v35;
LABEL_30:
          sub_1C5071EC4((uint64_t)a1, v12);
          sub_1C61D81B0((uint64_t)a1, v20, v27);
          v28 = a1[13] - a1[12];
          if ((v28 & 0xFFFFFFFF0) != 0)
          {
            v29 = 0;
            v30 = (v28 >> 4);
            do
            {
              if (v26)
              {
                sub_1C61D7E04((uint64_t)a1, *(unint64_t **)(a1[12] + v29 + 8), v12);
                v31 = *(_QWORD *)(a1[12] + v29);
                v32 = a1[1];
                v33 = v32 - (v31 + 16);
                if (v32 != v31 + 16)
                  memmove(*(void **)(a1[12] + v29), (const void *)(v31 + 16), v32 - (v31 + 16));
                a1[1] = v31 + v33;
              }
              v29 += 16;
              --v26;
              --v30;
            }
            while (v30);
          }
          v10 = 1;
          goto LABEL_8;
        }
        v18 = v36;
        v15 = a1;
        v16 = v11;
        v17 = a2;
      }
      sub_1C61D80F0(v15, v16, v17, v18);
LABEL_8:
      v8 = a1[1];
      if ((unint64_t)(v8 - *a1) <= 0x10)
        return v10 & 1;
    }
  }
  v10 = 0;
  return v10 & 1;
}

uint64_t sub_1C61D8AEC(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  int v11;

  v11 = 0;
  v8 = llvm::cl::parser<llvm::cl::BOOLOrDefault>::parse(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v11);
  if ((v8 & 1) != 0)
    return v8;
  *(_DWORD *)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 184);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v11);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C61D8B64();
}

uint64_t sub_1C61D8B64()
{
  return 1;
}

void sub_1C61D8B6C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &unk_1E8140060;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_4;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_4:
  sub_1C47A80D0(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61D8BE0(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1C61D8BEC(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

void sub_1C61D8BFC(uint64_t a1, int a2, int a3)
{
  int v3;
  void *v4;
  int v5;
  char v6;

  if (a3)
  {
    v3 = *(_DWORD *)(a1 + 128);
LABEL_3:
    v5 = *(_DWORD *)(a1 + 144);
    v6 = *(_BYTE *)(a1 + 148);
    v4 = &unk_1E819E900;
    llvm::cl::parser<llvm::cl::BOOLOrDefault>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, v3, (uint64_t)&v4, a2);
    return;
  }
  if (*(_BYTE *)(a1 + 148))
  {
    v3 = *(_DWORD *)(a1 + 128);
    if (*(_DWORD *)(a1 + 144) != v3)
      goto LABEL_3;
  }
}

BOOL sub_1C61D8C70(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 12) && *(_BYTE *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

uint64_t sub_1C61D8C9C(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  free(*(void **)(a1 + 208));
  v2 = *(void **)(a1 + 168);
  if (v2 != (void *)(a1 + 192))
    free(v2);
  v3 = *(void **)(a1 + 96);
  if (v3)
  {
    *(_QWORD *)(a1 + 104) = v3;
    operator delete(v3);
  }
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 72), 8);
  v4 = *(void **)(a1 + 32);
  if (v4 != *(void **)(a1 + 24))
    free(v4);
  v5 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v5;
    operator delete(v5);
  }
  return a1;
}

void *sub_1C61D8D14(void *result, unsigned int a2)
{
  unsigned int v2;
  _QWORD *v5;

  v2 = *((_DWORD *)result + 12);
  if (v2 < a2 || v2 >> 2 > a2)
  {
    v5 = result;
    free(*((void **)result + 5));
    result = sub_1C5074000(a2, 1uLL);
    v5[5] = result;
    *((_DWORD *)v5 + 12) = a2;
  }
  return result;
}

void sub_1C61D8D64(int **a1, _WORD *a2)
{
  uint64_t v4;
  int *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F4F00, 0, 0);
  dword_1ED7F4F80 = 0;
  qword_1ED7F4F88 = (uint64_t)&unk_1E819E900;
  *(_QWORD *)&dword_1ED7F4F90 = 0;
  qword_1ED7F4F00 = (uint64_t)&unk_1E8140060;
  qword_1ED7F4F98 = (uint64_t)&unk_1E819E920;
  qword_1ED7F4FA0 = (uint64_t)&unk_1E81400C8;
  qword_1ED7F4FB8 = (uint64_t)&qword_1ED7F4FA0;
  llvm::cl::Option::setArgStr(v4, "enable-tail-merge", 0x11uLL);
  v5 = *a1;
  dword_1ED7F4F80 = **a1;
  byte_1ED7F4F94 = 1;
  dword_1ED7F4F90 = *v5;
  word_1ED7F4F0A = (32 * (*a2 & 3)) | word_1ED7F4F0A & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F4F00);
}

void sub_1C61D8E3C()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61D8E50()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_1E81400C8;
  return result;
}

void sub_1C61D8E78(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_1E81400C8;
}

uint64_t sub_1C61D8E94(uint64_t a1, char *a2, _OWORD *a3, int **a4, _WORD *a5)
{
  uint64_t v10;
  size_t v11;
  int v12;

  v10 = sub_1C47AD050(a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(_QWORD *)(v10 + 136) = &off_1E7F952A8;
  *(_QWORD *)(v10 + 144) = 0;
  *(_QWORD *)v10 = &unk_1E819E3B0;
  *(_QWORD *)(v10 + 152) = &unk_1E819E2C0;
  *(_QWORD *)(v10 + 160) = &off_1E7F95260;
  *(_QWORD *)(v10 + 184) = v10 + 160;
  v11 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v11);
  *(_OWORD *)(a1 + 32) = *a3;
  v12 = **a4;
  *(_DWORD *)(a1 + 128) = v12;
  *(_BYTE *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  *(_WORD *)(a1 + 10) = (32 * (*a5 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1C61D8F84(__int128 *a1, int **a2, _WORD *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F5080, 0, 0);
  dword_1ED7F5100 = 0;
  qword_1ED7F5108 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F5110 = 0;
  qword_1ED7F5080 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F5118 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F5120 = (uint64_t)&off_1E7F95260;
  qword_1ED7F5138 = (uint64_t)&qword_1ED7F5120;
  llvm::cl::Option::setArgStr(v6, "tail-merge-size", 0xFuLL);
  xmmword_1ED7F50A0 = *a1;
  dword_1ED7F5100 = **a2;
  byte_1ED7F5114 = 1;
  dword_1ED7F5110 = dword_1ED7F5100;
  word_1ED7F508A = (32 * (*a3 & 3)) | word_1ED7F508A & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F5080);
}

uint64_t sub_1C61D9060(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  uint64_t *v7;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = a1 + 8;
  do
  {
    v5 = *(_DWORD *)(v2 + 28);
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (v6)
      v4 = v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28))
    return 0;
  sub_1C485B670((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

void llvm::initializeBranchRelaxationPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F5140);
  if (v2 != -1)
  {
    v5[0] = sub_1C50741B0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F5140, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61D913C(uint64_t a1, int a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a2)
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
    if ((~*(_DWORD *)(*(_QWORD *)(a1 + 16) + 8) & 0x500) == 0)
      goto LABEL_10;
    return 0;
  }
  if ((*(_WORD *)(a1 + 44) & 0xC) == 0 || (*(_WORD *)(a1 + 44) & 4) != 0)
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 16) + 9) & 4) != 0 && (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 9) & 1) != 0)
    {
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
LABEL_10:
      v4 = (v3 >> 11) & 1;
      return v4 ^ 1;
    }
    return 0;
  }
  LODWORD(v4) = a2 == 2;
  for (i = a1; ; i = *(_QWORD *)(i + 8))
  {
    v7 = *(_QWORD *)(i + 16);
    if ((*(_BYTE *)(v7 + 9) & 4) != 0)
    {
      if (a2 == 1)
        break;
      if ((*(_WORD *)(i + 44) & 8) == 0)
      {
        v8 = a1;
        if (a2 == 2)
          goto LABEL_24;
        return 0;
      }
      continue;
    }
    if (a2 != 2)
    {
      if ((*(_WORD *)(i + 44) & 8) == 0)
        return 0;
      continue;
    }
    if (*(_WORD *)v7 != 20)
      return 0;
    if ((*(_WORD *)(i + 44) & 8) == 0)
      break;
  }
  v8 = a1;
LABEL_24:
  while (1)
  {
    v9 = *(_QWORD *)(v8 + 16);
    if ((*(_BYTE *)(v9 + 9) & 1) != 0)
      break;
    if (a2 == 2)
    {
      if (*(_WORD *)v9 != 20)
        return 0;
      if ((*(_WORD *)(v8 + 44) & 8) == 0)
        goto LABEL_33;
    }
    else if ((*(_WORD *)(v8 + 44) & 8) == 0)
    {
      return 0;
    }
LABEL_27:
    v8 = *(_QWORD *)(v8 + 8);
  }
  if (a2 != 1 && (*(_WORD *)(v8 + 44) & 8) != 0)
    goto LABEL_27;
LABEL_33:
  while (1)
  {
    v10 = *(_QWORD *)(a1 + 16);
    if ((*(_BYTE *)(v10 + 9) & 8) == 0)
      break;
    if (a2 == 1)
    {
      LODWORD(v4) = 1;
      return v4 ^ 1;
    }
LABEL_35:
    if ((*(_WORD *)(a1 + 44) & 8) == 0)
      return v4 ^ 1;
    a1 = *(_QWORD *)(a1 + 8);
  }
  if (a2 != 2 || *(_WORD *)v10 == 20)
    goto LABEL_35;
  LODWORD(v4) = 0;
  return v4 ^ 1;
}

uint64_t sub_1C61D92AC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

uint64_t *sub_1C61D92E0(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;

  v2 = a1[27];
  a1[27] = 0;
  if (v2)
    MEMORY[0x1CAA32F9C](v2, 0x1000C8052888210);
  v3 = (uint64_t *)a1[18];
  if (v3 != a1 + 20)
    free(v3);
  v4 = (uint64_t *)a1[9];
  if (v4 != a1 + 11)
    free(v4);
  v5 = (uint64_t *)a1[5];
  if (v5 != a1 + 8)
    free(v5);
  v6 = *a1;
  *a1 = 0;
  if (v6)
    sub_1C507665C((uint64_t)a1, v6);
  return a1;
}

void llvm::initializeBasicBlockSectionsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F0B8);
  if (v2 != -1)
  {
    v5[0] = sub_1C50766D8;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F0B8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createBasicBlockSectionsPass(llvm *this, const llvm::MemoryBuffer *a2)
{
  uint64_t v3;
  _QWORD *v4;
  unint64_t v6;
  unint64_t v8;
  _QWORD *v9;
  _QWORD v10[2];

  v3 = operator new();
  v4 = (_QWORD *)sub_1C4776848(v3, (uint64_t)&unk_1EF8F6CD0);
  *v4 = &off_1E81402B8;
  v4[31] = this;
  v4[32] = 0;
  v4[33] = 0;
  v4[34] = 0x4800000000;
  v4[36] = 0;
  v4[37] = 0;
  v4[38] = 0x1800000000;
  if (!atomic_load(qword_1ED830BC0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED830BC0, (void *(*)(void))sub_1C624602C, (void (*)(void *))sub_1C62460B0);
  v8 = qword_1ED830BC0[0];
  v6 = atomic_load(&qword_1ED82F0B8);
  if (v6 != -1)
  {
    v10[0] = sub_1C50766D8;
    v10[1] = &v8;
    v9 = v10;
    std::__call_once(&qword_1ED82F0B8, &v9, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return v3;
}

llvm::StringMapImpl *sub_1C61D94C8(llvm::StringMapImpl *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  size_t v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v16;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0x1800000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    v4 = *(_QWORD *)this;
    v5 = *((unsigned int *)this + 2);
    v6 = *a2;
    *(_QWORD *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if ((_DWORD)v5)
    {
      v7 = 0;
      v16 = v4 + 8 * v5 + 8;
      v8 = v6 + 8 * v5 + 8;
      do
      {
        v9 = *(_QWORD *)(*a2 + 8 * v7);
        if (v9)
          v10 = v9 == -8;
        else
          v10 = 1;
        if (v10)
        {
          *(_QWORD *)(*(_QWORD *)this + 8 * v7) = v9;
        }
        else
        {
          v11 = *(_QWORD *)v9;
          v12 = (char *)operator new(*(_QWORD *)v9 + 25, (std::align_val_t)8uLL);
          v13 = v12;
          v14 = v12 + 24;
          if (v11)
            memcpy(v12 + 24, (const void *)(v9 + 24), v11);
          v14[v11] = 0;
          *(_QWORD *)v13 = v11;
          *(_OWORD *)(v13 + 8) = *(_OWORD *)(v9 + 8);
          *(_QWORD *)(*(_QWORD *)this + 8 * v7) = v13;
          *(_DWORD *)(v16 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

void sub_1C61D95E8(__int128 *a1, const char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::BBSectionsColdTextPrefix, "bbsections-cold-text-prefix", 0x1BuLL);
  xmmword_1ED82EF30 = *a1;
  sub_1C5077F60(*a2);
  word_1ED82EF1A = (32 * (*a3 & 3)) | word_1ED82EF1A & 0xFF9F;
}

uint64_t llvm::CCState::AnalyzeFormalArguments(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, unint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11[4];
  __int16 v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[40];

  v4 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v4)
  {
    v7 = result;
    v8 = 0;
    for (i = 0; i != v4; ++i)
    {
      v10 = *(_QWORD *)a2 + v8;
      v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v10 + 8);
      result = a3(i, *(unsigned __int8 *)(v10 + 12), *(unsigned __int8 *)(v10 + 12), 0, *(_QWORD *)v10, v3, v7);
      if ((_DWORD)result)
      {
        v13 = "unable to allocate function argument #";
        v14 = 259;
        v12 = 264;
        LODWORD(v11[0]) = i;
        sub_1C6131AAC((uint64_t *)&v13, v11, (uint64_t)v15);
        llvm::report_fatal_error((uint64_t)v15, 1);
      }
      v8 += 48;
    }
  }
  return result;
}

uint64_t llvm::CCState::CheckReturn(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, unint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  v4 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v4)
    return 1;
  v8 = 0;
  v9 = 0;
  v10 = v4 - 1;
  do
  {
    v11 = *(_QWORD *)a2 + v8;
    v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v11 + 8);
    v12 = a3(v9, *(unsigned __int8 *)(v11 + 12), *(unsigned __int8 *)(v11 + 12), 0, *(_QWORD *)v11, v3, a1);
    if ((v12 & 1) != 0)
      break;
    v8 += 48;
  }
  while (v10 != v9++);
  return v12 ^ 1u;
}

uint64_t llvm::CCState::AnalyzeReturn(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, unint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11[4];
  __int16 v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[40];

  v4 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v4)
  {
    v7 = result;
    v8 = 0;
    for (i = 0; i != v4; ++i)
    {
      v10 = *(_QWORD *)a2 + v8;
      v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v10 + 8);
      result = a3(i, *(unsigned __int8 *)(v10 + 12), *(unsigned __int8 *)(v10 + 12), 0, *(_QWORD *)v10, v3, v7);
      if ((_DWORD)result)
      {
        v13 = "unable to allocate function return #";
        v14 = 259;
        v12 = 264;
        LODWORD(v11[0]) = i;
        sub_1C6131AAC((uint64_t *)&v13, v11, (uint64_t)v15);
        llvm::report_fatal_error((uint64_t)v15, 1);
      }
      v8 += 48;
    }
  }
  return result;
}

uint64_t llvm::CCState::AnalyzeCallResult(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, unint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;

  v4 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v4)
  {
    v7 = result;
    v8 = 0;
    for (i = 0; i != v4; ++i)
    {
      v10 = *(_QWORD *)a2 + v8;
      v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v10 + 8);
      result = a3(i, *(unsigned __int8 *)(v10 + 12), *(unsigned __int8 *)(v10 + 12), 0, *(_QWORD *)v10, v3, v7);
      v8 += 48;
    }
  }
  return result;
}

void llvm::initializeCFGuardLongjmpPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F5150);
  if (v2 != -1)
  {
    v5[0] = sub_1C507AB64;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F5150, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeCFIFixupPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F5158);
  if (v2 != -1)
  {
    v5[0] = sub_1C507B2B0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F5158, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createCFIFixup(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C61D9A8C(v1);
}

void sub_1C61D9A34(llvm::Pass *a1)
{
  sub_1C4926674(a1);
  JUMPOUT(0x1CAA32FC0);
}

void *sub_1C61D9A58(llvm::MachineFunctionPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::callDefaultCtor<llvm::CFIFixup>()
{
  uint64_t v0;

  v0 = operator new();
  return sub_1C61D9A8C(v0);
}

uint64_t sub_1C61D9A8C(uint64_t a1)
{
  llvm::PassRegistry *v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = (llvm::PassRegistry *)sub_1C4776848(a1, (uint64_t)&llvm::CFIFixup::ID);
  *(_QWORD *)v2 = &off_1E8140438;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  v3 = atomic_load(&qword_1ED7F5158);
  if (v3 != -1)
  {
    v7[0] = sub_1C507B2B0;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED7F5158, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return a1;
}

void sub_1C61D9B18(char **a1, uint64_t *a2)
{
  char *v3;
  char *v4;
  uint64_t v5;
  _OWORD v6[4];
  void *v7[2];
  _OWORD v8[8];
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  _QWORD v13[17];

  v13[16] = *MEMORY[0x1E0C80C00];
  sub_1C486F76C((uint64_t)&v10, *a2);
  v7[0] = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  memset(v6, 0, sizeof(v6));
  v3 = (char *)v6 + 8;
  v4 = (char *)v6 + 8;
  v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  sub_1C486DC64((uint64_t)&v10, (uint64_t)&v3, a1);
  if (v7[1] != (char *)v8 + 8)
    free(v7[1]);
  if (v4 != v3)
    free(v4);
  if (v12 != v13)
    free(v12);
  if (v11 != v10)
    free(v11);
}

void llvm::initializeCFIInstrInserterPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F5228);
  if (v2 != -1)
  {
    v5[0] = sub_1C507BB8C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F5228, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C61D9C90(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  char *v3;
  char *v4;
  uint64_t v5;
  _OWORD v6[4];
  uint64_t v7;
  void *__p;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  sub_1C61D9E2C((uint64_t)&v11, *(_QWORD *)(*(_QWORD *)a1 + 328));
  v7 = 0;
  __p = 0;
  memset(v6, 0, sizeof(v6));
  v3 = (char *)v6 + 8;
  v4 = (char *)v6 + 8;
  v5 = 8;
  v9 = 0;
  v10 = 0;
  sub_1C61D9D48((uint64_t)&v11, (uint64_t)&v3, a2);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  if (v4 != v3)
    free(v4);
  if (v13)
  {
    v14 = v13;
    operator delete(v13);
  }
  if (v12 != v11)
    free(v12);
}

void sub_1C61D9D48(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  void *v6;
  void *v7;
  uint64_t v8;
  void *__p[2];
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14[2];
  uint64_t v15;

  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v11, &v13, 8, (uint64_t *)a1);
  *(_OWORD *)v14 = *(_OWORD *)(a1 + 96);
  v15 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v6, &v8, 8, (uint64_t *)a2);
  *(_OWORD *)__p = *(_OWORD *)(a2 + 96);
  v10 = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  sub_1C6187DA4(a3, (uint64_t)&v11, (uint64_t)&v6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v7 != v6)
    free(v7);
  if (v14[0])
  {
    v14[1] = v14[0];
    operator delete(v14[0]);
  }
  if (v12 != v11)
    free(v12);
}

uint64_t sub_1C61D9E2C(uint64_t a1, uint64_t a2)
{
  void **v4;
  unint64_t v5;
  __int128 v6;
  char *v7;
  __int128 v9;
  uint64_t v10;

  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 32;
  *(_QWORD *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v4 = (void **)(a1 + 96);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  sub_1C4774094((llvm::SmallPtrSetImplBase *)a1, a2);
  *(_QWORD *)&v9 = a2;
  BYTE8(v9) = 0;
  LOBYTE(v10) = 0;
  v5 = *(_QWORD *)(a1 + 104);
  if (v5 >= *(_QWORD *)(a1 + 112))
  {
    v7 = sub_1C4D8DBBC(v4, (uint64_t)&v9);
  }
  else
  {
    v6 = v9;
    *(_QWORD *)(v5 + 16) = v10;
    *(_OWORD *)v5 = v6;
    v7 = (char *)(v5 + 24);
  }
  *(_QWORD *)(a1 + 104) = v7;
  return a1;
}

char *sub_1C61D9EC8(char *this)
{
  llvm::SmallPtrSetImplBase *v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v1 = (llvm::SmallPtrSetImplBase *)this;
  v2 = (void **)(this + 96);
  v3 = *((_QWORD *)this + 13);
  while (2)
  {
    v4 = *(_QWORD *)(v3 - 24);
    if (!*(_BYTE *)(v3 - 8))
    {
      *(_QWORD *)(v3 - 16) = *(_QWORD *)(v4 + 88);
      *(_BYTE *)(v3 - 8) = 1;
    }
    while (1)
    {
      v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 96))
        break;
      *(_QWORD *)(v3 - 16) = v5 + 1;
      v6 = *v5;
      this = (char *)sub_1C4774094(v1, *v5);
      if (v7)
      {
        *(_QWORD *)&v11 = v6;
        BYTE8(v11) = 0;
        LOBYTE(v12) = 0;
        v9 = *((_QWORD *)v1 + 13);
        if (v9 >= *((_QWORD *)v1 + 14))
        {
          this = sub_1C4D8DBBC(v2, (uint64_t)&v11);
        }
        else
        {
          v10 = v11;
          *(_QWORD *)(v9 + 16) = v12;
          *(_OWORD *)v9 = v10;
          this = (char *)(v9 + 24);
        }
        *((_QWORD *)v1 + 13) = this;
        return this;
      }
    }
    v8 = *((_QWORD *)v1 + 12);
    v3 = *((_QWORD *)v1 + 13) - 24;
    *((_QWORD *)v1 + 13) = v3;
    if (v8 != v3)
      continue;
    break;
  }
  return this;
}

void llvm::initializeCodeGen(llvm *this, llvm::PassRegistry *a2)
{
  llvm::PassRegistry *v3;
  llvm::PassRegistry *v4;
  llvm::PassRegistry *v5;
  llvm::PassRegistry *v6;
  llvm::PassRegistry *v7;
  llvm::PassRegistry *v8;
  llvm::PassRegistry *v9;
  llvm::PassRegistry *v10;
  llvm::PassRegistry *v11;
  llvm::PassRegistry *v12;
  llvm::PassRegistry *v13;
  llvm::PassRegistry *v14;
  llvm::PassRegistry *v15;
  llvm::PassRegistry *v16;
  llvm::PassRegistry *v17;
  llvm::PassRegistry *v18;
  llvm::PassRegistry *v19;
  llvm::PassRegistry *v20;
  llvm::PassRegistry *v21;
  llvm::PassRegistry *v22;
  llvm::PassRegistry *v23;
  llvm::PassRegistry *v24;
  llvm::PassRegistry *v25;
  llvm::PassRegistry *v26;
  llvm::PassRegistry *v27;
  llvm::PassRegistry *v28;
  llvm::PassRegistry *v29;
  llvm::PassRegistry *v30;
  llvm::PassRegistry *v31;
  llvm::PassRegistry *v32;
  llvm::PassRegistry *v33;
  llvm::PassRegistry *v34;
  llvm::PassRegistry *v35;
  llvm::PassRegistry *v36;
  llvm::PassRegistry *v37;
  llvm::PassRegistry *v38;
  llvm::PassRegistry *v39;
  llvm::PassRegistry *v40;
  llvm::PassRegistry *v41;
  llvm::PassRegistry *v42;
  llvm::PassRegistry *v43;
  llvm::PassRegistry *v44;
  llvm::PassRegistry *v45;
  llvm::PassRegistry *v46;
  llvm::PassRegistry *v47;
  llvm::PassRegistry *v48;
  llvm::PassRegistry *v49;
  llvm::PassRegistry *v50;
  llvm::PassRegistry *v51;
  llvm::PassRegistry *v52;
  llvm::PassRegistry *v53;
  llvm::PassRegistry *v54;
  llvm::PassRegistry *v55;
  llvm::PassRegistry *v56;
  llvm::PassRegistry *v57;
  llvm::PassRegistry *v58;
  llvm::PassRegistry *v59;
  llvm::PassRegistry *v60;
  llvm::PassRegistry *v61;
  llvm::PassRegistry *v62;
  llvm::PassRegistry *v63;
  llvm::PassRegistry *v64;
  llvm::PassRegistry *v65;
  llvm::PassRegistry *v66;
  llvm::PassRegistry *v67;
  llvm::PassRegistry *v68;
  llvm::PassRegistry *v69;
  llvm::PassRegistry *v70;
  llvm::PassRegistry *v71;
  llvm::PassRegistry *v72;
  llvm::PassRegistry *v73;
  llvm::PassRegistry *v74;
  llvm::PassRegistry *v75;
  llvm::PassRegistry *v76;
  llvm::PassRegistry *v77;
  llvm::PassRegistry *v78;
  llvm::PassRegistry *v79;
  llvm::PassRegistry *v80;
  llvm::PassRegistry *v81;
  llvm::PassRegistry *v82;
  llvm::PassRegistry *v83;
  llvm::PassRegistry *v84;
  llvm::PassRegistry *v85;
  llvm::PassRegistry *v86;
  llvm::PassRegistry *v87;
  llvm::PassRegistry *v88;
  llvm::PassRegistry *v89;
  llvm::PassRegistry *v90;
  llvm::PassRegistry *v91;
  llvm::PassRegistry *v92;
  llvm::PassRegistry *v93;
  llvm::PassRegistry *v94;
  llvm::PassRegistry *v95;
  llvm::PassRegistry *v96;
  llvm::PassRegistry *v97;
  llvm::PassRegistry *v98;
  llvm::PassRegistry *v99;
  llvm::PassRegistry *v100;
  llvm::PassRegistry *v101;
  llvm::PassRegistry *v102;
  llvm::PassRegistry *v103;
  llvm::PassRegistry *v104;
  llvm::PassRegistry *v105;
  llvm::PassRegistry *v106;

  llvm::initializeAtomicExpandPass(this, a2);
  llvm::initializeBasicBlockSectionsPass(this, v3);
  llvm::initializeBranchFolderPassPass(this, v4);
  llvm::initializeBranchRelaxationPass(this, v5);
  llvm::initializeCFGuardLongjmpPass(this, v6);
  llvm::initializeCFIFixupPass(this, v7);
  llvm::initializeCFIInstrInserterPass(this, v8);
  llvm::initializeCheckDebugMachineModulePass(this, v9);
  llvm::initializeCodeGenPreparePass(this, v10);
  llvm::initializeDeadMachineInstructionElimPass(this, v11);
  llvm::initializeDebugifyMachineModulePass(this, v12);
  llvm::initializeDetectDeadLanesPass(this, v13);
  llvm::initializeDwarfEHPrepareLegacyPassPass(this, v14);
  llvm::initializeEarlyIfConverterPass(this, v15);
  llvm::initializeEarlyIfPredicatorPass(this, v16);
  llvm::initializeEarlyMachineLICMPass(this, v17);
  llvm::initializeEarlyTailDuplicatePass(this, v18);
  llvm::initializeExpandMemCmpPassPass(this, v19);
  llvm::initializeExpandPostRAPass(this, v20);
  llvm::initializeFEntryInserterPass(this, v21);
  llvm::initializeFinalizeISelPass(this, v22);
  llvm::initializeFinalizeMachineBundlesPass(this, v23);
  llvm::initializeFixupStatepointCallerSavedPass(this, v24);
  llvm::initializeFuncletLayoutPass(this, v25);
  llvm::initializeGCMachineCodeAnalysisPass(this, v26);
  llvm::initializeGCModuleInfoPass(this, v27);
  llvm::initializeHardwareLoopsPass(this, v28);
  llvm::initializeIfConverterPass(this, v29);
  llvm::initializeImplicitNullChecksPass(this, v30);
  llvm::initializeIndirectBrExpandPassPass(this, v31);
  llvm::initializeInterleavedLoadCombinePass(this, v32);
  llvm::initializeInterleavedAccessPass(this, v33);
  llvm::initializeJMCInstrumenterPass(this, v34);
  llvm::initializeLiveDebugValuesPass(this, v35);
  llvm::initializeLiveDebugVariablesPass(this, v36);
  llvm::initializeLiveIntervalsPass((uint64_t)this);
  llvm::initializeLiveRangeShrinkPass(this, v37);
  llvm::initializeLiveStacksPass(this, v38);
  llvm::initializeLiveVariablesPass(this, v39);
  llvm::initializeLocalStackSlotPassPass(this, v40);
  llvm::initializeLowerGlobalDtorsLegacyPassPass(this, v41);
  llvm::initializeLowerIntrinsicsPass(this, v42);
  llvm::initializeMIRAddFSDiscriminatorsPass(this, v43);
  llvm::initializeMIRCanonicalizerPass(this, v44);
  llvm::initializeMIRNamerPass(this, v45);
  llvm::initializeMIRProfileLoaderPassPass(this, v46);
  llvm::initializeMachineBlockFrequencyInfoPass(this, v47);
  llvm::initializeMachineBlockPlacementPass(this, v48);
  llvm::initializeMachineBlockPlacementStatsPass(this, v49);
  llvm::initializeMachineCSEPass(this, v50);
  llvm::initializeMachineCombinerPass(this, v51);
  llvm::initializeMachineCopyPropagationPass(this, v52);
  llvm::initializeMachineCycleInfoPrinterPassPass(this, v53);
  llvm::initializeMachineCycleInfoWrapperPassPass(this, v54);
  llvm::initializeMachineDominatorTreePass((uint64_t)this);
  llvm::initializeMachineFunctionPrinterPassPass(this, v55);
  llvm::initializeMachineLICMPass(this, v56);
  llvm::initializeMachineLoopInfoPass((uint64_t)this);
  llvm::initializeMachineModuleInfoWrapperPassPass(this, v57);
  llvm::initializeMachineOptimizationRemarkEmitterPassPass(this, v58);
  llvm::initializeMachineOutlinerPass(this, v59);
  llvm::initializeMachinePipelinerPass(this, v60);
  llvm::initializeModuloScheduleTestPass(this, v61);
  llvm::initializeMachinePostDominatorTreePass(this, v62);
  llvm::initializeMachineRegionInfoPassPass(this, v63);
  llvm::initializeMachineSchedulerPass(this, v64);
  llvm::initializeMachineSinkingPass(this, v65);
  llvm::initializeMachineVerifierPassPass(this, v66);
  llvm::initializeObfuscateModulePass(this, v67);
  llvm::initializeOptimizePHIsPass(this, v68);
  llvm::initializePEIPass(this, v69);
  llvm::initializePHIEliminationPass(this, v70);
  llvm::initializePatchableFunctionPass(this, v71);
  llvm::initializePeepholeOptimizerPass(this, v72);
  llvm::initializePostMachineSchedulerPass(this, v73);
  llvm::initializePostRAHazardRecognizerPass(this, v74);
  llvm::initializePostRAMachineSinkingPass(this, v75);
  llvm::initializePostRASchedulerPass(this, v76);
  llvm::initializePreISelIntrinsicLoweringLegacyPassPass(this, v77);
  llvm::initializeProcessImplicitDefsPass(this, v78);
  llvm::initializeRABasicPass(this, v79);
  llvm::initializeRAGreedyPass(this, v80);
  llvm::initializeRegAllocFastPass(this, v81);
  llvm::initializeRegUsageInfoCollectorPass(this, v82);
  llvm::initializeRegUsageInfoPropagationPass(this, v83);
  llvm::initializeRegisterCoalescerPass(this, v84);
  llvm::initializeRemoveRedundantDebugValuesPass(this, v85);
  llvm::initializeRenameIndependentSubregsPass(this, v86);
  llvm::initializeSafeStackLegacyPassPass(this, v87);
  llvm::initializeShadowStackGCLoweringPass(this, v88);
  llvm::initializeShrinkWrapPass(this, v89);
  llvm::initializeSjLjEHPreparePass(this, v90);
  llvm::initializeSlotIndexesPass((uint64_t)this);
  llvm::initializeStackColoringPass(this, v91);
  llvm::initializeStackMapLivenessPass(this, v92);
  llvm::initializeStackProtectorPass(this, v93);
  llvm::initializeStackSlotColoringPass(this, v94);
  llvm::initializeStripDebugMachineModulePass(this, v95);
  llvm::initializeTailDuplicatePass(this, v96);
  llvm::initializeTargetPassConfigPass((uint64_t)this);
  llvm::initializeTwoAddressInstructionPassPass(this, v97);
  llvm::initializeTypePromotionPass(this, v98);
  llvm::initializeUnpackMachineBundlesPass(this, v99);
  llvm::initializeUnreachableBlockElimLegacyPassPass(this, v100);
  llvm::initializeUnreachableMachineBlockElimPass(this, v101);
  llvm::initializeVirtRegMapPass(this, v102);
  llvm::initializeVirtRegRewriterPass(this, v103);
  llvm::initializeWasmEHPreparePass(this, v104);
  llvm::initializeWinEHPreparePass(this, v105);
  llvm::initializeXRayInstrumentationPass(this, v106);
}

llvm::MachineBasicBlock *llvm::StackProtectorDescriptor::addSuccessorMBB(llvm::StackProtectorDescriptor *this, const llvm::BasicBlock *a2, llvm::MachineBasicBlock *a3, int a4, llvm::MachineBasicBlock *a5)
{
  llvm::MachineBasicBlock *MachineBasicBlock;
  llvm::MachineFunction *v8;
  llvm::MachineBasicBlock **v9;
  llvm::MachineBasicBlock *v10;
  int v11;

  MachineBasicBlock = a5;
  if (!a5)
  {
    v8 = (llvm::MachineFunction *)*((_QWORD *)a3 + 4);
    MachineBasicBlock = (llvm::MachineBasicBlock *)llvm::MachineFunction::CreateMachineBasicBlock(v8, a2);
    v9 = (llvm::MachineBasicBlock **)*((_QWORD *)a3 + 1);
    llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList((uint64_t)v8 + 320, (uint64_t)MachineBasicBlock);
    v10 = *v9;
    *(_QWORD *)MachineBasicBlock = *v9;
    *((_QWORD *)MachineBasicBlock + 1) = v9;
    *((_QWORD *)v10 + 1) = MachineBasicBlock;
    *v9 = MachineBasicBlock;
  }
  v11 = sub_1C61DA3B4(a4);
  llvm::MachineBasicBlock::addSuccessor(a3, MachineBasicBlock, v11);
  return MachineBasicBlock;
}

uint64_t sub_1C61DA3B4(int a1)
{
  unsigned __int8 v1;
  int v3;
  int v4;

  v1 = atomic_load((unsigned __int8 *)&qword_1EF8EB210);
  if ((v1 & 1) == 0)
  {
    v4 = a1;
    v3 = __cxa_guard_acquire(&qword_1EF8EB210);
    a1 = v4;
    if (v3)
    {
      llvm::BranchProbability::BranchProbability(&dword_1EF8EB208, 0xFFFFFuLL, 0x100000u);
      __cxa_guard_release(&qword_1EF8EB210);
      a1 = v4;
    }
  }
  if (a1)
    return dword_1EF8EB208;
  else
    return 0x80000000 - dword_1EF8EB208;
}

void llvm::initializeCodeGenPreparePass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F5238);
  if (v2 != -1)
  {
    v5[0] = sub_1C507F6EC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F5238, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createCodeGenPreparePass(llvm *this)
{
  char v1;
  uint64_t v2;

  v1 = (char)this;
  v2 = operator new();
  return sub_1C507F7A0(v2, v1);
}

void sub_1C61DA4D8(uint64_t a1, uint64_t a2)
{
  int32x2_t *v4;
  unint64_t *v5;
  int32x2_t *v6;
  unint64_t v7;
  uint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  char v14[24];
  unint64_t *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t (**v22)(llvm::CallbackVH *__hidden);
  _QWORD v23[2];
  uint64_t v24;
  int32x2_t *v25;

  sub_1C4E42548(v23, (_QWORD *)(a1 + 8));
  v4 = *(int32x2_t **)(a1 + 32);
  v22 = &off_1E8140658;
  v25 = v4;
  v15 = 0;
  if (sub_1C5086900((uint64_t)*v4, v4[2].i32[0], v24, &v15))
    v5 = v15;
  else
    v5 = (unint64_t *)(*(_QWORD *)v4 + ((unint64_t)v4[2].u32[0] << 6));
  v6 = v25;
  if ((unint64_t *)(*(_QWORD *)v6 + ((unint64_t)v6[2].u32[0] << 6)) != v5)
  {
    v19 = 6;
    v20 = 0;
    v7 = v5[7];
    v21 = v7;
    if (v7 != -8192 && v7 != -4096 && v7 != 0)
    {
      v12 = v5[5] & 0xFFFFFFFFFFFFFFF8;
      v20 = *(unint64_t **)v12;
      v13 = v20;
      *(_QWORD *)v12 = &v19;
      v19 = v12 | 6;
      if (v13)
        *v13 = *v13 & 7 | (unint64_t)&v20;
      v6 = v25;
    }
    sub_1C61DA6B8(v6, v5);
    v9 = (uint64_t)v25;
    v15 = (unint64_t *)a2;
    v16 = 6;
    v17 = 0;
    v18 = v21;
    if (v21 != -8192 && v21 != -4096)
    {
      if (v21)
      {
        v10 = v19 & 0xFFFFFFFFFFFFFFF8;
        v17 = *(unint64_t **)(v19 & 0xFFFFFFFFFFFFFFF8);
        v11 = v17;
        *(_QWORD *)v10 = &v16;
        v16 = v10 | 6;
        if (v11)
          *v11 = *v11 & 7 | (unint64_t)&v17;
      }
    }
    sub_1C61DA770((uint64_t)v14, v9, (uint64_t *)&v15);
    if (v18 != -8192 && v18 != -4096 && v18)
      llvm::ValueHandleBase::RemoveFromUseList(&v16);
    if (v21 != -8192 && v21 != -4096 && v21)
      llvm::ValueHandleBase::RemoveFromUseList(&v19);
  }
  if (v24 != -8192 && v24 != -4096)
  {
    if (v24)
      llvm::ValueHandleBase::RemoveFromUseList(v23);
  }
}

int32x2_t sub_1C61DA6B8(int32x2_t *a1, unint64_t *a2)
{
  unint64_t v4;
  uint64_t v6;
  int32x2_t result;
  uint64_t v9[2];
  uint64_t v10;
  unint64_t v11;

  v4 = a2[7];
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(a2 + 5);
  v9[1] = 0;
  v10 = -8192;
  v9[0] = 2;
  v11 = 0;
  sub_1C4D98DE0(a2 + 1, v9);
  v6 = v10;
  a2[4] = v11;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(v9);
  result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

double sub_1C61DA770(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  double result;
  uint64_t (**v9)(llvm::CallbackVH *__hidden);
  _QWORD v10[2];
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[5];
  _QWORD v14[3];
  __int128 v15;
  char v16;

  v6 = *a3;
  v10[0] = 2;
  v10[1] = 0;
  v11 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v10);
  v9 = &off_1E8140658;
  v12 = a2;
  sub_1C5086F04(v13, &v9, a3 + 1);
  sub_1C61DA848((uint64_t)&v15, a2, (uint64_t)v13, v14);
  sub_1C61DA988(v13);
  if (v11 != -8192 && v11 != -4096 && v11)
    llvm::ValueHandleBase::RemoveFromUseList(v10);
  result = *(double *)&v15;
  *(_OWORD *)a1 = v15;
  *(_BYTE *)(a1 + 16) = v16;
  return result;
}

uint64_t sub_1C61DA848(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t v9;
  char v10;
  unint64_t v11;
  uint64_t v12;

  v12 = 0;
  result = sub_1C5086900(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *(_QWORD *)(a3 + 24), &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61DA8D4((_DWORD *)a2, v12, a3, a4);
    v9 = result;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + ((unint64_t)*(unsigned int *)(a2 + 16) << 6);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

unint64_t *sub_1C61DA8D4(_DWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unint64_t *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v11;

  v6 = (unint64_t *)sub_1C5086994(a1, a3, a2);
  sub_1C4D98DE0(v6 + 1, (uint64_t *)(a3 + 8));
  v6[4] = *(_QWORD *)(a3 + 32);
  v6[5] = 6;
  v7 = v6 + 5;
  v6[6] = 0;
  v8 = (unint64_t)(v6 + 6);
  v9 = a4[2];
  v6[7] = v9;
  if (v9 != -8192 && v9 != -4096 && v9 != 0)
  {
    v11 = *a4 & 0xFFFFFFFFFFFFFFF8;
    *(_QWORD *)v8 = *(_QWORD *)v11;
    *(_QWORD *)v11 = v7;
    *v7 = v11 | 6;
    if (*(_QWORD *)v8)
      **(_QWORD **)v8 = **(_QWORD **)v8 & 7 | v8;
  }
  return v6;
}

_QWORD *sub_1C61DA988(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v4;

  v2 = a1[7];
  if (v2 != -8192 && v2 != -4096 && v2 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 5);
  v4 = a1[3];
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 1);
  return a1;
}

void sub_1C61DA9E8(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    v2 = 152 * v1;
    v3 = *(_QWORD *)a1 + 24;
    do
    {
      if ((*(_QWORD *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4)
          free(v4);
      }
      v3 += 152;
      v2 -= 152;
    }
    while (v2);
  }
}

uint64_t sub_1C61DAA4C(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 24);
  sub_1C5086FE8(&v3);
  MEMORY[0x1CAA32FB4](*(_QWORD *)a1, 8);
  return a1;
}

_QWORD *sub_1C61DAA90(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61DAB08(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61DABA4(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x1000000000;
  }
  return v5;
}

uint64_t sub_1C61DAB08(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 152 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 152 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61DABA4(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C5097F58(a1, v6);
  v8 = 0;
  sub_1C61DAB08(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61DAC54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 152 * v6;
    do
    {
      *v7 = -4096;
      v7 += 19;
      v8 -= 152;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61DAB08(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x1000000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C4964480(v11, (const void **)(v4 + 8));
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 152;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1C61DAD48(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v8;
  char v9;
  uint64_t v10;
  int v11;
  void *v12;
  uint64_t v13;
  _BYTE v14[512];
  uint64_t v15;
  void *v16;
  uint64_t v17;
  _QWORD v18[65];

  v18[64] = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = 0;
  sub_1C61DAE70((uint64_t)&v8, a1, &v10, &v11);
  v4 = v8;
  if (v9)
  {
    v12 = v14;
    v13 = 0x2000000000;
    v15 = *a2;
    v16 = v18;
    v17 = 0x2000000000;
    sub_1C509B2CC((uint64_t *)(a1 + 24), (uint64_t)&v15);
    if (v16 != v18)
      free(v16);
    if (v12 != v14)
      free(v12);
    v5 = *(_QWORD *)(a1 + 24);
    v6 = 128207979 * ((unint64_t)(*(_QWORD *)(a1 + 32) - v5) >> 3) - 1;
    *(_DWORD *)(v4 + 8) = v6;
  }
  else
  {
    v6 = *(_DWORD *)(v8 + 8);
    v5 = *(_QWORD *)(a1 + 24);
  }
  return v5 + 536 * v6 + 8;
}

uint64_t sub_1C61DAE70(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;

  v12 = 0;
  result = sub_1C47AD1C0(a2, a3, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C509B474(a2, (uint64_t)a3, a3, v12);
    v9 = (_QWORD *)result;
    *(_QWORD *)result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t *sub_1C61DAF08(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 != *result)
  {
    v7 = 0;
    do
    {
      *(_QWORD *)(v6 + v7 - 536) = *(_QWORD *)(v4 + v7 - 536);
      result = (uint64_t *)(v6 + v7 - 528);
      *result = v6 + v7 - 512;
      *(_QWORD *)(v6 + v7 - 520) = 0x2000000000;
      if (*(_DWORD *)(v4 + v7 - 520))
        result = (uint64_t *)sub_1C4E85538((uint64_t)result, v4 + v7 - 528);
      v7 -= 536;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  v8 = *v3;
  *v3 = v6;
  a2[1] = v8;
  v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

_QWORD *sub_1C61DAFE8(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4E2F6FC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61DB054(a1, a2, v7);
    *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

_QWORD *sub_1C61DB054(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C509B5A4(a1, v6);
  v8 = 0;
  sub_1C4E2F6FC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61DB104(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C4E2F6FC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *(_QWORD *)a2;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

_QWORD *sub_1C61DB1B0(_QWORD *a1, unsigned int a2)
{
  uint64_t v3;
  _QWORD *result;
  int v5;
  _QWORD *v6;

  if (a2 <= 0x20)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    v3 = a2;
    result = operator new(16 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      v6 = &result[2 * v3];
      goto LABEL_6;
    }
  }
  result = a1 + 1;
  v6 = a1 + 65;
  do
  {
LABEL_6:
    *result = -4096;
    result += 2;
  }
  while (result != v6);
  return result;
}

uint64_t sub_1C61DB230(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 520);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[2 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v13 = 0;
      result = sub_1C509BB64((uint64_t)v5, v10, &v13);
      v11 = v13;
      v12 = a2[1];
      *v13 = *a2;
      v11[1] = v12;
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1C61DB2E8(uint64_t a1, unint64_t a2, unint64_t a3, _OWORD *a4)
{
  uint64_t **v6;
  uint64_t **v8;
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;

  v6 = (uint64_t **)sub_1C509C468(a1, &v13, a2, a3);
  if (*v6)
    return 0;
  v8 = v6;
  v9 = operator new(0x30uLL);
  v9[2] = *a4;
  v10 = v13;
  *(_QWORD *)v9 = 0;
  *((_QWORD *)v9 + 1) = 0;
  *((_QWORD *)v9 + 2) = v10;
  *v8 = (uint64_t *)v9;
  v11 = **(_QWORD **)a1;
  if (v11)
  {
    *(_QWORD *)a1 = v11;
    v12 = *v8;
  }
  else
  {
    v12 = (uint64_t *)v9;
  }
  sub_1C4768E74(*(uint64_t **)(a1 + 8), v12);
  ++*(_QWORD *)(a1 + 16);
  return 1;
}

uint64_t sub_1C61DB390@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61DB414((uint64_t *)a1, a2, &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61DB4B0(a1, (uint64_t)a2, a2, v10);
    v7 = (_QWORD *)result;
    *(_QWORD *)result = *a2;
    v8 = 1;
  }
  v9 = *(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v9;
  *(_BYTE *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1C61DB414(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t result;
  BOOL v12;
  unsigned int v13;

  v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    v7 = (_QWORD *)(*a1 + 8 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }
    else
    {
      v9 = 0;
      v10 = 1;
      result = 1;
      while (v8 != -4096)
      {
        if (v9)
          v12 = 0;
        else
          v12 = v8 == -8192;
        if (v12)
          v9 = v7;
        v13 = v6 + v10++;
        v6 = v13 & v5;
        v7 = (_QWORD *)(v4 + 8 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
          goto LABEL_7;
      }
      result = 0;
      if (v9)
        v7 = v9;
    }
  }
  else
  {
    v7 = 0;
    result = 0;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61DB4B0(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C509D018(a1, v7);
  v9 = 0;
  sub_1C61DB414((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C61DB560(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v9 = 0;
      result = sub_1C61DB414((uint64_t *)v5, a2, &v9);
      *v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

unsigned __int8 **sub_1C61DB60C(uint64_t *a1, llvm::Value *a2, llvm::BasicBlock *a3, llvm::BasicBlock *a4, uint64_t a5)
{
  char *v10;
  uint64_t v11;
  unsigned __int8 **v12;
  char *v13;
  int v15[8];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v10 = (char *)operator new(0xA0uLL);
  v11 = 0;
  v12 = (unsigned __int8 **)(v10 + 96);
  *((_DWORD *)v10 + 29) = *((_DWORD *)v10 + 29) & 0x38000000 | 3;
  do
  {
    v13 = &v10[v11];
    *(_QWORD *)v13 = 0;
    *((_QWORD *)v13 + 1) = 0;
    *((_QWORD *)v13 + 2) = 0;
    *((_QWORD *)v13 + 3) = v12;
    v11 += 32;
  }
  while (v11 != 96);
  llvm::BranchInst::BranchInst((llvm::BranchInst *)(v10 + 96), a3, a4, a2, 0);
  if (a5)
  {
    *(_OWORD *)v15 = xmmword_1C85FA9F8;
    llvm::Instruction::copyMetadata((uint64_t)v12, a5, v15, 4);
  }
  v16 = 257;
  return sub_1C4867F8C(a1, v12, (uint64_t)v15);
}

_QWORD *sub_1C61DB70C(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4E5818C(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C619F79C((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

unint64_t *sub_1C61DB76C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t *result;
  unint64_t v11;

  v7 = a2 + 8;
  v8 = operator new(0x38uLL);
  *(_QWORD *)a1 = v8;
  *(_QWORD *)(a1 + 8) = v7;
  v9 = v8;
  v8[6] = a4;
  v8[4] = 6;
  result = v8 + 4;
  v9[5] = 0;
  v11 = (unint64_t)(v9 + 5);
  if (a4 != -8192 && a4 != -4096)
  {
    if (a4)
    {
      *(_QWORD *)v11 = *(_QWORD *)(a3 & 0xFFFFFFFFFFFFFFF8);
      *(_QWORD *)(a3 & 0xFFFFFFFFFFFFFFF8) = result;
      *result = a3 & 0xFFFFFFFFFFFFFFF8 | 6;
      if (*(_QWORD *)v11)
        **(_QWORD **)v11 = **(_QWORD **)v11 & 7 | v11;
    }
  }
  *(_BYTE *)(a1 + 16) = 1;
  return result;
}

uint64_t sub_1C61DB808(uint64_t a1, uint64_t a2, int *a3, _QWORD *a4)
{
  uint64_t result;
  _DWORD *v9;
  char v10;
  uint64_t v11;
  _DWORD *v12;

  v12 = 0;
  result = sub_1C61DB8AC(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61DB990(a2, a3, v12);
    v9 = (_DWORD *)result;
    *(_DWORD *)result = *a3;
    *(_DWORD *)(result + 4) = a3[1];
    *(_QWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1C61DB8AC(uint64_t a1, int a2, int a3, int a4, _QWORD *a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  _DWORD *v10;
  int v11;
  int v12;
  uint64_t v14;
  _DWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v20;

  if (a2)
  {
    v5 = ((37 * a4) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)(37 * a4) << 32);
    v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    v8 = a2 - 1;
    v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~((_DWORD)v7 << 27)));
    v10 = (_DWORD *)(a1 + 16 * v9);
    v11 = *v10;
    v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      v14 = 1;
    }
    else
    {
      v16 = 0;
      v17 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v16)
          v18 = 0;
        else
          v18 = v12 == -2;
        if (v18 && v11 == -2)
          v16 = v10;
        v20 = v9 + v17++;
        v9 = v20 & v8;
        v10 = (_DWORD *)(a1 + 16 * (v20 & v8));
        v11 = *v10;
        v12 = v10[1];
        v14 = 1;
        if (*v10 == a3 && v12 == a4)
          goto LABEL_8;
      }
      v14 = 0;
      if (v16)
        v10 = v16;
    }
  }
  else
  {
    v10 = 0;
    v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

_DWORD *sub_1C61DB990(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v9;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C50A0184(a1, v6);
  v9 = 0;
  sub_1C61DB8AC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61DBA44(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  _DWORD *v13;
  _DWORD *v14;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -1;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_DWORD *)a2;
    v10 = *(_DWORD *)(a2 + 4);
    if ((*(_DWORD *)a2 != -1 || v10 != -1) && (v9 != -2 || v10 != -2))
    {
      v14 = 0;
      result = sub_1C61DB8AC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
      v13 = v14;
      *v14 = *(_DWORD *)a2;
      v13[1] = *(_DWORD *)(a2 + 4);
      *((_QWORD *)v13 + 1) = *(_QWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

_QWORD *sub_1C61DBB0C(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61DBB84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61DBC20(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x200000000;
  }
  return v5;
}

uint64_t sub_1C61DBB84(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 40 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 40 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61DBC20(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C50A023C(a1, v6);
  v8 = 0;
  sub_1C61DBB84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61DBCD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 40 * v6;
    do
    {
      *v7 = -4096;
      v7 += 5;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61DBB84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x200000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C614D378(v11, v4 + 8);
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

void sub_1C61DBDC8(llvm::DbgVariableIntrinsic *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  llvm::UndefValue **v6;
  llvm::Type *v7;
  llvm::UndefValue *v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  _BYTE *v12;
  uint64_t v13;
  int v14;
  _BYTE v15[32];

  v11 = v15;
  v12 = v15;
  v13 = 4;
  v14 = 0;
  llvm::DbgVariableIntrinsic::location_ops((uint64_t)a1, &v9);
  v3 = v9;
  v2 = v10;
  if (v9 != v10)
  {
    do
    {
      v4 = (unint64_t *)(v3 & 0xFFFFFFFFFFFFFFF8);
      v5 = v3 & 0xFFFFFFFFFFFFFFF8;
      if ((v3 & 4) != 0)
        v5 = *v4;
      v6 = *(llvm::UndefValue ***)(v5 + 128);
      sub_1C4774094((llvm::SmallPtrSetImplBase *)&v11, (uint64_t)v6);
      if ((_BYTE)v7)
      {
        v8 = llvm::UndefValue::get(*v6, v7);
        llvm::DbgVariableIntrinsic::replaceVariableLocationOp(a1, (llvm::Value *)v6, v8);
      }
      if ((v3 & 4) != 0)
        v3 = (unint64_t)(v4 + 1) | 4;
      else
        v3 = (uint64_t)(v4 + 17);
    }
    while (v3 != v2);
    if (v12 != v11)
      free(v12);
  }
}

void sub_1C61DBE98(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F59C0, 0, 0);
  byte_1ED7F5A40 = 0;
  qword_1ED7F5A48 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F5A50 = 0;
  qword_1ED7F59C0 = (uint64_t)&unk_1E819E898;
  qword_1ED7F5A58 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F5A60 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F5A78 = (uint64_t)&qword_1ED7F5A60;
  sub_1C61DBF4C(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F59C0);
}

__n128 sub_1C61DBF4C(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  char *v8;
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F59C0, "profile-guided-section-prefix", 0x1DuLL);
  word_1ED7F59CA = word_1ED7F59CA & 0xFF9F | (32 * (*a1 & 3));
  v8 = *a2;
  byte_1ED7F5A40 = **a2;
  byte_1ED7F5A51 = 1;
  byte_1ED7F5A50 = *v8;
  word_1ED7F59CA = word_1ED7F59CA & 0xFFF8 | *a3 & 7;
  result = *a4;
  xmmword_1ED7F59E0 = (__int128)*a4;
  return result;
}

void sub_1C61DBFE0(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F5A80, 0, 0);
  byte_1ED7F5B00 = 0;
  qword_1ED7F5B08 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F5B10 = 0;
  qword_1ED7F5A80 = (uint64_t)&unk_1E819E898;
  qword_1ED7F5B18 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F5B20 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F5B38 = (uint64_t)&qword_1ED7F5B20;
  sub_1C61DC094(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F5A80);
}

__n128 sub_1C61DC094(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  char *v8;
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F5A80, "profile-unknown-in-special-section", 0x22uLL);
  word_1ED7F5A8A = word_1ED7F5A8A & 0xFF9F | (32 * (*a1 & 3));
  v8 = *a2;
  byte_1ED7F5B00 = **a2;
  byte_1ED7F5B11 = 1;
  byte_1ED7F5B10 = *v8;
  word_1ED7F5A8A = word_1ED7F5A8A & 0xFFF8 | *a3 & 7;
  result = *a4;
  xmmword_1ED7F5AA0 = (__int128)*a4;
  return result;
}

void sub_1C61DC128(_WORD *a1, int **a2, __int128 *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F5B40, 0, 0);
  dword_1ED7F5BC0 = 0;
  qword_1ED7F5BC8 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F5BD0 = 0;
  qword_1ED7F5B40 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F5BD8 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F5BE0 = (uint64_t)&off_1E7F95260;
  qword_1ED7F5BF8 = (uint64_t)&qword_1ED7F5BE0;
  llvm::cl::Option::setArgStr(v6, "cgp-freq-ratio-to-skip-merge", 0x1CuLL);
  word_1ED7F5B4A = (32 * (*a1 & 3)) | word_1ED7F5B4A & 0xFF9F;
  dword_1ED7F5BC0 = **a2;
  byte_1ED7F5BD4 = 1;
  dword_1ED7F5BD0 = dword_1ED7F5BC0;
  xmmword_1ED7F5B60 = *a3;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F5B40);
}

uint64_t sub_1C61DC204()
{
  return 2;
}

void sub_1C61DC20C(uint64_t a1)
{
  sub_1C50A7650(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61DC230(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 176, a1);
}

llvm::raw_ostream *sub_1C61DC23C(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 176), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C61DC254(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  llvm::raw_ostream *v3;
  unint64_t v4;
  size_t v5;
  char *v6;
  void *v7;
  _BYTE *v8;
  unint64_t v9;
  size_t v10;
  char *v11;
  void *v12;

  v3 = result;
  v4 = *(char *)result;
  if (v4 <= 2)
  {
    v5 = qword_1C85FAA40[v4];
    v6 = off_1E81419B0[v4];
    v7 = (void *)*((_QWORD *)this + 4);
    if (v5 <= *((_QWORD *)this + 3) - (_QWORD)v7)
    {
      result = (llvm::raw_ostream *)memcpy(v7, v6, v5);
      *((_QWORD *)this + 4) += v5;
    }
    else
    {
      result = llvm::raw_ostream::write(this, v6, v5);
      this = result;
    }
  }
  v8 = (_BYTE *)*((_QWORD *)this + 4);
  if ((unint64_t)v8 >= *((_QWORD *)this + 3))
  {
    result = llvm::raw_ostream::write(this, 44);
    this = result;
  }
  else
  {
    *((_QWORD *)this + 4) = v8 + 1;
    *v8 = 44;
  }
  v9 = *((char *)v3 + 1);
  if (v9 <= 2)
  {
    v10 = qword_1C85FAA40[v9];
    v11 = off_1E81419B0[v9];
    v12 = (void *)*((_QWORD *)this + 4);
    if (v10 <= *((_QWORD *)this + 3) - (_QWORD)v12)
    {
      result = (llvm::raw_ostream *)memcpy(v12, v11, v10);
      *((_QWORD *)this + 4) += v10;
    }
    else
    {
      return llvm::raw_ostream::write(this, v11, qword_1C85FAA40[v9]);
    }
  }
  return result;
}

void sub_1C61DC368()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61DC37C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &unk_1E81415E0;
  return result;
}

void sub_1C61DC3A4(uint64_t a1, _QWORD *a2)
{
  *a2 = &unk_1E81415E0;
}

void sub_1C61DC3C0(__int128 *a1, char **a2)
{
  uint64_t v4;
  char *v5;

  v4 = sub_1C47AD050((uint64_t)qword_1ED7F6A78, 0, 0);
  byte_1ED7F6AF8 = 0;
  qword_1ED7F6B00 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F6B08 = 0;
  qword_1ED7F6A78[0] = (uint64_t)&unk_1E819E898;
  qword_1ED7F6B10 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F6B18 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F6B30 = (uint64_t)&qword_1ED7F6B18;
  llvm::cl::Option::setArgStr(v4, "vec-extabi", 0xAuLL);
  xmmword_1ED7F6A98 = *a1;
  v5 = *a2;
  byte_1ED7F6AF8 = **a2;
  byte_1ED7F6B09 = 1;
  byte_1ED7F6B08 = *v5;
  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1ED7F6A78);
}

void sub_1C61DC484(__int128 *a1, char **a2)
{
  uint64_t v4;
  char *v5;

  v4 = sub_1C47AD050((uint64_t)qword_1ED7F6E38, 0, 0);
  byte_1ED7F6EB8 = 0;
  qword_1ED7F6EC0 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F6EC8 = 0;
  qword_1ED7F6E38[0] = (uint64_t)&unk_1E819E898;
  qword_1ED7F6ED0 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F6ED8 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F6EF0 = (uint64_t)&qword_1ED7F6ED8;
  llvm::cl::Option::setArgStr(v4, "use-ctors", 9uLL);
  xmmword_1ED7F6E58 = *a1;
  v5 = *a2;
  byte_1ED7F6EB8 = **a2;
  byte_1ED7F6EC9 = 1;
  byte_1ED7F6EC8 = *v5;
  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1ED7F6E38);
}

void sub_1C61DC548(__int128 *a1, char **a2)
{
  uint64_t v4;
  char *v5;

  v4 = sub_1C47AD050((uint64_t)qword_1EF8F0788, 0, 0);
  byte_1EF8F0808 = 0;
  qword_1EF8F0810 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1EF8F0818 = 0;
  qword_1EF8F0788[0] = (uint64_t)&unk_1E819E898;
  qword_1EF8F0820 = (uint64_t)&off_1E819E9A0;
  qword_1EF8F0828 = (uint64_t)&off_1E7F9E8F8;
  qword_1EF8F0840 = (uint64_t)&qword_1EF8F0828;
  llvm::cl::Option::setArgStr(v4, "addrsig", 7uLL);
  xmmword_1EF8F07A8 = *a1;
  v5 = *a2;
  byte_1EF8F0808 = **a2;
  byte_1EF8F0819 = 1;
  byte_1EF8F0818 = *v5;
  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EF8F0788);
}

void sub_1C61DC610(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61DC634(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1C61DC650(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)a1 = &off_1E81419D8;
  v2 = *(void **)(a1 + 216);
  if (v2 != (void *)(a1 + 232))
    free(v2);
  v3 = *(void **)(a1 + 192);
  if (v3)
  {
    *(_QWORD *)(a1 + 200) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 168);
  if (v4)
  {
    *(_QWORD *)(a1 + 176) = v4;
    operator delete(v4);
  }
  sub_1C6143384(*(_QWORD **)(a1 + 152));
  v5 = *(void **)(a1 + 120);
  if (v5)
  {
    *(_QWORD *)(a1 + 128) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(a1 + 48);
  if (v6 != (void *)(a1 + 64))
    free(v6);
  llvm::AntiDepBreaker::~AntiDepBreaker((llvm::AntiDepBreaker *)a1);
}

void sub_1C61DC6E0(uint64_t a1)
{
  sub_1C61DC650(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61DC704(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  char v9;
  llvm::MachineBasicBlock **v10;
  llvm::MachineBasicBlock **j;
  llvm::MachineBasicBlock *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _WORD *CalleeSavedRegs;
  unsigned int v22;
  _WORD *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v29;
  _DWORD v30[4];
  char v31;
  uint64_t v32;
  unsigned __int16 v33;
  void *v34[2];
  char v35;
  uint64_t v36;
  unsigned __int16 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = -1;
  v5 = a2 + 48;
  do
  {
    v5 = *(_QWORD *)(v5 + 8);
    ++v4;
  }
  while (v5 != a2 + 48);
  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 32) + 16);
  if ((_DWORD)v6)
  {
    for (i = 0; i != v6; ++i)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8 * i) = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 168) + 4 * i) = -1;
      *(_DWORD *)(*(_QWORD *)(a1 + 192) + 4 * i) = v4;
    }
  }
  v8 = *(unsigned int *)(a1 + 224);
  if ((_DWORD)v8)
    bzero(*(void **)(a1 + 216), 8 * v8);
  v9 = sub_1C498FBAC(a2);
  v10 = *(llvm::MachineBasicBlock ***)(a2 + 88);
  for (j = *(llvm::MachineBasicBlock ***)(a2 + 96); v10 != j; ++v10)
  {
    v12 = *v10;
    v13 = llvm::MachineBasicBlock::livein_begin(*v10);
    v14 = (unsigned __int16 *)*((_QWORD *)v12 + 20);
    if (v14 != (unsigned __int16 *)v13)
    {
      v15 = (unsigned __int16 *)v13;
      do
      {
        v16 = *(_QWORD *)(a1 + 32);
        if (v16)
          v17 = (_QWORD *)(v16 + 8);
        else
          v17 = 0;
        sub_1C48385F4((uint64_t)v34, *v15, v17, 1);
        v18 = v36;
        while (v18)
        {
LABEL_16:
          v19 = v37;
          *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8 * v37) = -1;
          *(_DWORD *)(*(_QWORD *)(a1 + 168) + 4 * v19) = v4;
          *(_DWORD *)(*(_QWORD *)(a1 + 192) + 4 * v19) = -1;
          while (1)
          {
            sub_1C48386F0((uint64_t)v34);
            v18 = v36;
            if (v35 || v36 == 0)
              break;
            if (LODWORD(v34[0]) != v37)
              goto LABEL_16;
          }
        }
        v15 += 8;
      }
      while (v15 != v14);
    }
  }
  llvm::MachineFrameInfo::getPristineRegs(*(llvm::MachineFrameInfo **)(*(_QWORD *)(a1 + 8) + 56), *(const llvm::MachineFunction **)(a1 + 8), (char *)v34);
  CalleeSavedRegs = (_WORD *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*(llvm::MachineRegisterInfo **)(*(_QWORD *)(a1 + 8) + 40));
  v22 = (unsigned __int16)*CalleeSavedRegs;
  if (*CalleeSavedRegs)
  {
    v23 = CalleeSavedRegs;
    do
    {
      if ((v9 & 1) != 0 || ((*((_QWORD *)v34[0] + (v22 >> 6)) >> v22) & 1) != 0)
      {
        v24 = *(_QWORD *)(a1 + 32);
        if (v24)
          v25 = (_QWORD *)(v24 + 8);
        else
          v25 = 0;
        sub_1C48385F4((uint64_t)v30, v22, v25, 1);
        v26 = v32;
        while (v26)
        {
LABEL_34:
          v27 = v33;
          *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8 * v33) = -1;
          *(_DWORD *)(*(_QWORD *)(a1 + 168) + 4 * v27) = v4;
          *(_DWORD *)(*(_QWORD *)(a1 + 192) + 4 * v27) = -1;
          while (1)
          {
            sub_1C48386F0((uint64_t)v30);
            v26 = v32;
            if (v31 || v32 == 0)
              break;
            if (v30[0] != v33)
              goto LABEL_34;
          }
        }
      }
      v29 = (unsigned __int16)v23[1];
      ++v23;
      v22 = v29;
    }
    while (v29);
  }
  if (v34[0] != &v35)
    free(v34[0]);
}

void sub_1C61DC984(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 152;
  sub_1C6143384(*(_QWORD **)(a1 + 152));
  *(_QWORD *)(v2 - 8) = v2;
  *(_QWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  v3 = *(unsigned int *)(v2 + 72);
  if ((_DWORD)v3)
    bzero(*(void **)(a1 + 216), 8 * v3);
}

uint64_t llvm::createCriticalAntiDepBreaker(llvm *this, llvm::MachineFunction *a2, const llvm::RegisterClassInfo *a3)
{
  uint64_t v5;

  v5 = operator new();
  return sub_1C50AB13C(v5, (uint64_t)this, (uint64_t)a2);
}

void llvm::initializeDeadMachineInstructionElimPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F71F8);
  if (v2 != -1)
  {
    v5[0] = sub_1C50AC590;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F71F8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeDetectDeadLanesPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7200);
  if (v2 != -1)
  {
    v5[0] = sub_1C50ACD0C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7200, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

BOOL llvm::DFAPacketizer::canReserveResources(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  unint64_t v4;

  if (*(_WORD *)(a2 + 6))
    v2 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * *(unsigned __int16 *)(a2 + 6)) == 0;
  else
    v2 = 1;
  if (v2)
    return 0;
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * *(unsigned __int16 *)(a2 + 6));
  return sub_1C61DCB20((_QWORD *)(a1 + 8), &v4);
}

BOOL sub_1C61DCB20(_QWORD *a1, unint64_t *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = (_QWORD *)(*a1 + 8);
  v3 = (_QWORD *)*v2;
  if (!*v2)
    goto LABEL_14;
  v4 = a1[4];
  v5 = *a2;
  v6 = *a1 + 8;
  do
  {
    v7 = v3[4];
    if (v7 >= v4)
    {
      if (v4 >= v7)
      {
        if (v3[5] < v5)
          ++v3;
        else
          v6 = (uint64_t)v3;
      }
      else
      {
        v6 = (uint64_t)v3;
      }
    }
    else
    {
      ++v3;
    }
    v3 = (_QWORD *)*v3;
  }
  while (v3);
  if ((_QWORD *)v6 == v2 || (v8 = *(_QWORD *)(v6 + 32), v4 < v8) || v8 >= v4 && v5 < *(_QWORD *)(v6 + 40))
LABEL_14:
    v6 = *a1 + 8;
  return v6 != (_QWORD)v2;
}

uint64_t llvm::DFAPacketizer::reserveResources(uint64_t result, uint64_t a2)
{
  BOOL v2;
  unint64_t v3;

  if (*(_WORD *)(a2 + 6))
    v2 = *(_DWORD *)(*(_QWORD *)(result + 56) + 4 * *(unsigned __int16 *)(a2 + 6)) == 0;
  else
    v2 = 1;
  if (!v2)
  {
    v3 = *(unsigned int *)(*(_QWORD *)(result + 56) + 4 * *(unsigned __int16 *)(a2 + 6));
    return sub_1C50AE550(result + 8, &v3);
  }
  return result;
}

uint64_t sub_1C61DCC00()
{
  return 0;
}

uint64_t sub_1C61DCC08(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5)
  {
    v6 = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return a1;
}

void sub_1C61DCC98(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;

  v2 = *(unsigned int *)(a1 + 168);
  if ((_DWORD)v2)
  {
    v3 = *(_QWORD *)(a1 + 160);
    v4 = 48 * v2;
    do
    {
      v5 = *(void **)(v3 + v4 - 48);
      if ((void *)(v3 + v4 - 32) != v5)
        free(v5);
      v4 -= 48;
    }
    while (v4);
  }
  *(_DWORD *)(a1 + 168) = 0;
  v6 = (_QWORD *)(a1 + 112);
  sub_1C50AF5E4((_QWORD *)(a1 + 112));
  v7 = a1 + 16;
  sub_1C4926A50(v7);
  v8 = (_QWORD *)sub_1C484358C(v7, 16, 3);
  *v8 = 0;
  v8[1] = 0;
  v9 = v8;
  sub_1C48410F0(v6, &v9);
}

void sub_1C61DCD38(_WORD *a1, int **a2, __int128 *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F7210, 0, 0);
  dword_1ED7F7290 = 0;
  qword_1ED7F7298 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F72A0 = 0;
  qword_1ED7F7210 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F72A8 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F72B0 = (uint64_t)&off_1E7F95260;
  qword_1ED7F72C8 = (uint64_t)&qword_1ED7F72B0;
  llvm::cl::Option::setArgStr(v6, "dfa-instr-limit", 0xFuLL);
  word_1ED7F721A = (32 * (*a1 & 3)) | word_1ED7F721A & 0xFF9F;
  dword_1ED7F7290 = **a2;
  byte_1ED7F72A4 = 1;
  dword_1ED7F72A0 = dword_1ED7F7290;
  xmmword_1ED7F7230 = *a3;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F7210);
}

void sub_1C61DCE14(uint64_t a1, _QWORD *a2, unint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  unint64_t v29;
  _QWORD *v32;

  v3 = (_QWORD *)(a1 + 112);
  v4 = *(unsigned int *)(a1 + 152);
  if (*(_DWORD *)(a1 + 152))
  {
    v6 = 0;
    v7 = a1 + 16;
    do
    {
      if (a3)
      {
        v8 = a2;
        v9 = *(unint64_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 120)
                                              + (((unint64_t)(*(_QWORD *)(a1 + 144) + v6) >> 6) & 0x3FFFFFFFFFFFFF8))
                                  + 8 * ((*(_QWORD *)(a1 + 144) + v6) & 0x1FF));
        v10 = *v9;
        v11 = a3;
        do
        {
          v12 = v11 >> 1;
          v13 = &v8[2 * (v11 >> 1)];
          v15 = *v13;
          v14 = v13 + 2;
          v11 += ~(v11 >> 1);
          if (v15 < v10)
            v8 = v14;
          else
            v11 = v12;
        }
        while (v11);
        v16 = a3;
        v17 = a2;
        do
        {
          v18 = v16 >> 1;
          v19 = &v17[2 * (v16 >> 1)];
          if (v10 >= *v19 && (*v19 < v10 || (v19[1] & 0x8000000000000000) == 0))
          {
            v17 = v19 + 2;
            v18 = v16 + ~v18;
          }
          v16 = v18;
        }
        while (v18);
        while (v8 != v17)
        {
          if (*v8 == *v9)
          {
            v20 = v8[1];
            v21 = (_QWORD *)sub_1C484358C(v7, 16, 3);
            *v21 = v20;
            v21[1] = v9;
            v32 = v21;
            sub_1C48410F0(v3, &v32);
          }
          v8 += 2;
        }
      }
      ++v6;
    }
    while (v6 != v4);
  }
  v22 = *(_QWORD *)(a1 + 144);
  v23 = *(_QWORD *)(a1 + 120);
  v24 = (char *)(v23 + 8 * (v22 >> 9));
  if (*(_QWORD *)(a1 + 128) == v23)
    v25 = 0;
  else
    v25 = (char *)(*(_QWORD *)v24 + 8 * (*(_QWORD *)(a1 + 144) & 0x1FFLL));
  if (v4)
  {
    v26 = v4 + ((uint64_t)&v25[-*(_QWORD *)v24] >> 3);
    if (v26 < 1)
    {
      v29 = 511 - v26;
      v27 = &v24[-8 * (v29 >> 9)];
      v28 = (char *)(*(_QWORD *)v27 + 8 * (~(_WORD)v29 & 0x1FF));
    }
    else
    {
      v27 = &v24[8 * ((unint64_t)v26 >> 9)];
      v28 = (char *)(*(_QWORD *)v27 + 8 * (v26 & 0x1FF));
    }
  }
  else
  {
    v28 = v25;
    v27 = (char *)(v23 + 8 * (v22 >> 9));
  }
  sub_1C50AF830(v3, v24, v25, v27, v28);
}

void llvm::initializeDwarfEHPrepareLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F72D0);
  if (v2 != -1)
  {
    v5[0] = sub_1C50AFD38;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F72D0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createDwarfEHPass(int a1)
{
  uint64_t result;

  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = &unk_1EF8F2EE0;
  *(_QWORD *)result = &off_1E8141C98;
  *(_DWORD *)(result + 24) = 2;
  *(_DWORD *)(result + 28) = a1;
  return result;
}

llvm::Instruction *sub_1C61DD0B0(llvm::Instruction *this, uint64_t **a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, llvm::BasicBlock *a9)
{
  llvm::Type *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t ***v23;

  v17 = (llvm::Type *)*a2[2];
  if (a7)
  {
    LODWORD(v18) = 0;
    v19 = 48 * a7;
    v20 = (_QWORD *)(a6 + 32);
    do
    {
      v18 = v18 + ((*v20 - *(v20 - 1)) >> 3);
      v20 += 6;
      v19 -= 48;
    }
    while (v19);
    v21 = 48 * a7;
    v22 = (_QWORD *)(a6 + 32);
    do
    {
      LODWORD(v19) = v19 + ((*v22 - *(v22 - 1)) >> 3);
      v22 += 6;
      v21 -= 48;
    }
    while (v21);
  }
  else
  {
    v18 = 0;
    LODWORD(v19) = 0;
  }
  v23 = (uint64_t ***)llvm::Instruction::Instruction(this, v17, 56, (llvm::Instruction *)((char *)this + 32 * ~(a5 + v18)), (int)a5 + (int)v19 + 1, a9);
  *((_QWORD *)this + 8) = 0;
  llvm::CallInst::init(v23, a2, a3, a4, a5, a6, a7, a8);
  return this;
}

void llvm::initializeEarlyIfConverterPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F72D8);
  if (v2 != -1)
  {
    v5[0] = sub_1C50B1160;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F72D8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeEarlyIfPredicatorPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F72E0);
  if (v2 != -1)
  {
    v5[0] = sub_1C50B1204;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F72E0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C61DD280(uint64_t a1, void ***this)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _OWORD v7[4];
  void *v8[2];
  _OWORD v9[8];
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  _QWORD v14[17];

  v14[16] = *MEMORY[0x1E0C80C00];
  llvm::MachineDominatorTree::applySplitCriticalEdges(this);
  sub_1C4EB6E94((uint64_t)&v11, (uint64_t)this[165][6]);
  v8[0] = 0;
  memset(v9, 0, sizeof(v9));
  v10 = 0;
  memset(v7, 0, sizeof(v7));
  v4 = (char *)v7 + 8;
  v5 = (char *)v7 + 8;
  v6 = 8;
  v8[1] = (char *)v9 + 8;
  DWORD1(v9[0]) = 8;
  sub_1C61AF830(a1, (uint64_t)&v11, (uint64_t)&v4);
  if (v8[1] != (char *)v9 + 8)
    free(v8[1]);
  if (v5 != v4)
    free(v5);
  if (v13 != v14)
    free(v13);
  if (v12 != v11)
    free(v12);
}

void sub_1C61DD3A8(uint64_t a1)
{
  sub_1C50B4134(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61DD3CC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  size_t v3;

  v1 = *(_QWORD *)(****(_QWORD ****)(a1 + 16) + 72);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
    v3 = strlen(*(const char **)(a1 + 40));
  else
    v3 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, size_t))(*(_QWORD *)v1 + 32))(v1, v2, v3);
}

void sub_1C61DD428(uint64_t a1)
{
  sub_1C50B4134(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61DD44C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  size_t v3;

  v1 = *(_QWORD *)(****(_QWORD ****)(a1 + 16) + 72);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
    v3 = strlen(*(const char **)(a1 + 40));
  else
    v3 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, size_t))(*(_QWORD *)v1 + 40))(v1, v2, v3);
}

void llvm::initializeEdgeBundlesPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F0C0);
  if (v2 != -1)
  {
    v5[0] = sub_1C50B4F00;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F0C0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void *llvm::EdgeBundles::getAnalysisUsage(llvm::MachineFunctionPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

llvm::raw_ostream *llvm::WriteGraph<llvm::EdgeBundles>(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  int v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  unsigned int v10;
  llvm::raw_ostream *v11;
  llvm::raw_ostream *v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  llvm::raw_ostream *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  void (**v18)(void);
  void (**v19)(void);
  void (**v20)(void);
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  llvm::raw_ostream *v24;
  llvm::raw_ostream *v25;
  void (**v26)(void);
  void (**v27)(void);
  uint64_t v29;
  uint64_t v30;
  _QWORD v31[3];
  _QWORD *v32;
  _QWORD v33[3];
  _QWORD *v34;
  _QWORD v35[3];
  _QWORD *v36;
  uint64_t v37;

  v2 = a2;
  v37 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a2 + 248);
  sub_1C4816AD8(a1, "digraph {\n");
  v5 = *(_QWORD *)(v4 + 328);
  v30 = v4 + 320;
  if (v5 != v4 + 320)
  {
    v29 = v2;
    do
    {
      v6 = *(_DWORD *)(v5 + 24);
      v7 = sub_1C4816AD8(a1, "\t\"");
      llvm::printMBBReference(v5, v35);
      if (!v36)
        goto LABEL_45;
      (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v36 + 48))(v36, v7);
      v8 = sub_1C4816AD8(v7, "\" [ shape=box ]\n");
      v9 = (_BYTE *)*((_QWORD *)v8 + 4);
      if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
      {
        v8 = llvm::raw_ostream::write(v8, 9);
      }
      else
      {
        *((_QWORD *)v8 + 4) = v9 + 1;
        *v9 = 9;
      }
      v10 = 2 * v6;
      v11 = llvm::raw_ostream::operator<<(v8, *(unsigned int *)(*(_QWORD *)(v2 + 256) + 4 * v10));
      v12 = sub_1C4816AD8(v11, " -> \"");
      llvm::printMBBReference(v5, v33);
      if (!v34
        || ((*(void (**)(_QWORD *, llvm::raw_ostream *))(*v34 + 48))(v34, v12),
            v13 = sub_1C4816AD8(v12, "\"\n"),
            v14 = sub_1C4816AD8(v13, "\t\""),
            llvm::printMBBReference(v5, v31),
            !v32))
      {
LABEL_45:
        sub_1C485C2F0();
      }
      (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v32 + 48))(v32, v14);
      v15 = sub_1C4816AD8(v14, "\" -> ");
      v16 = llvm::raw_ostream::operator<<(v15, *(unsigned int *)(*(_QWORD *)(v2 + 256) + 4 * (v10 | 1)));
      v17 = (_BYTE *)*((_QWORD *)v16 + 4);
      if ((unint64_t)v17 >= *((_QWORD *)v16 + 3))
      {
        llvm::raw_ostream::write(v16, 10);
      }
      else
      {
        *((_QWORD *)v16 + 4) = v17 + 1;
        *v17 = 10;
      }
      if (v32 == v31)
      {
        v18 = (void (**)(void))(v31[0] + 32);
      }
      else
      {
        if (!v32)
          goto LABEL_16;
        v18 = (void (**)(void))(*v32 + 40);
      }
      (*v18)();
LABEL_16:
      if (v34 == v33)
      {
        v19 = (void (**)(void))(v33[0] + 32);
      }
      else
      {
        if (!v34)
          goto LABEL_20;
        v19 = (void (**)(void))(*v34 + 40);
      }
      (*v19)();
LABEL_20:
      if (v36 == v35)
      {
        v20 = (void (**)(void))(v35[0] + 32);
        goto LABEL_23;
      }
      if (v36)
      {
        v20 = (void (**)(void))(*v36 + 40);
LABEL_23:
        (*v20)();
      }
      v21 = *(uint64_t **)(v5 + 88);
      v22 = *(uint64_t **)(v5 + 96);
      while (v21 != v22)
      {
        v23 = *v21;
        v24 = sub_1C4816AD8(a1, "\t\"");
        llvm::printMBBReference(v5, v35);
        if (!v36)
          goto LABEL_45;
        (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v36 + 48))(v36, v24);
        v25 = sub_1C4816AD8(v24, "\" -> \"");
        llvm::printMBBReference(v23, v33);
        if (!v34)
          goto LABEL_45;
        (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v34 + 48))(v34, v25);
        sub_1C4816AD8(v25, "\" [ color=lightgray ]\n");
        if (v34 == v33)
        {
          v26 = (void (**)(void))(v33[0] + 32);
        }
        else
        {
          if (!v34)
            goto LABEL_32;
          v26 = (void (**)(void))(*v34 + 40);
        }
        (*v26)();
LABEL_32:
        if (v36 == v35)
        {
          v27 = (void (**)(void))(v35[0] + 32);
        }
        else
        {
          if (!v36)
            goto LABEL_36;
          v27 = (void (**)(void))(*v36 + 40);
        }
        (*v27)();
LABEL_36:
        ++v21;
      }
      v5 = *(_QWORD *)(v5 + 8);
      v2 = v29;
    }
    while (v5 != v30);
  }
  sub_1C4816AD8(a1, "}\n");
  return a1;
}

void sub_1C61DD8B4(uint64_t a1)
{
  sub_1C61DD960(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t llvm::callDefaultCtor<llvm::EdgeBundles>()
{
  uint64_t v0;
  uint64_t v1;

  v0 = operator new();
  v1 = sub_1C4776848(v0, (uint64_t)&llvm::EdgeBundles::ID);
  *(_QWORD *)v1 = &off_1E8141F40;
  *(_QWORD *)(v0 + 256) = v0 + 272;
  *(_QWORD *)(v0 + 264) = 0x800000000;
  *(_DWORD *)(v0 + 304) = 0;
  llvm::IntEqClasses::grow((_DWORD *)(v1 + 256), 0);
  *(_QWORD *)(v0 + 312) = v0 + 328;
  *(_QWORD *)(v0 + 320) = 0x400000000;
  return v0;
}

void sub_1C61DD960(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1E8141F40;
  sub_1C61DD9A8((char **)(a1 + 312));
  v2 = *(void **)(a1 + 256);
  if (v2 != (void *)(a1 + 272))
    free(v2);
  sub_1C4926674((llvm::Pass *)a1);
}

char **sub_1C61DD9A8(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v7;
  char *v8;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 48 * v3;
    do
    {
      v5 = *(char **)&v2[v4 - 48];
      if (&v2[v4 - 32] != v5)
      {
        v7 = v4;
        v8 = v2;
        free(v5);
        v4 = v7;
        v2 = v8;
      }
      v4 -= 48;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

void sub_1C61DDA28(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 48, &v5);
  sub_1C61DDA94(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61DDA94(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v3 = *(_QWORD *)a1;
    v4 = 48 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x800000000;
      if (*(_DWORD *)(v3 + 8))
        sub_1C4EA2F88((uint64_t)a2, v3);
      v3 += 48;
      a2 += 6;
      v4 -= 48;
    }
    while (v4);
    v5 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v5)
    {
      v6 = *(_QWORD *)a1;
      v7 = 48 * v5;
      do
      {
        v8 = *(void **)(v6 + v7 - 48);
        if ((void *)(v6 + v7 - 32) != v8)
          free(v8);
        v7 -= 48;
      }
      while (v7);
    }
  }
}

void llvm::initializeExpandMemCmpPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7540);
  if (v2 != -1)
  {
    v5[0] = sub_1C50B76A0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7540, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createExpandMemCmpPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C50B7754(v1);
}

double sub_1C61DDBE0(uint64_t a1, uint64_t *a2, char *a3)
{
  uint64_t v5;
  char v6;
  double result;

  if (*(_BYTE *)(a1 + 440))
    a1 = sub_1C50B98E4(a1);
  v5 = *a2;
  v6 = *a3;
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0x1000000000;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = v5;
  *(_QWORD *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 304) = v6;
  *(_QWORD *)(a1 + 312) = a1 + 344;
  *(_QWORD *)(a1 + 320) = a1 + 344;
  *(_QWORD *)&result = 8;
  *(_QWORD *)(a1 + 328) = 8;
  *(_DWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_QWORD *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 432) = 0;
  *(_BYTE *)(a1 + 440) = 1;
  return result;
}

uint64_t sub_1C61DDC60(uint64_t a1, llvm::LLVMContext *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  llvm::ConstantInt **Int64Ty;
  uint64_t result;
  _DWORD *v12;
  uint64_t v13;
  _WORD v14[20];
  llvm::ValueHandleBase *v15;

  Int64Ty = (llvm::ConstantInt **)llvm::Type::getInt64Ty(*(llvm::Type **)(a1 + 64), a2);
  v15 = llvm::ConstantInt::get(Int64Ty, a4, 0);
  result = (*(uint64_t (**)(_QWORD, llvm::LLVMContext *, uint64_t *, llvm::ValueHandleBase **, uint64_t, _QWORD))(**(_QWORD **)(a1 + 72) + 48))(*(_QWORD *)(a1 + 72), a2, a3, &v15, 1, 0);
  if (!result)
  {
    v14[16] = 257;
    v12 = operator new(0x90uLL);
    v12[21] = v12[21] & 0x38000000 | 2;
    v13 = (uint64_t)(v12 + 16);
    *(_QWORD *)v12 = 0;
    *((_QWORD *)v12 + 1) = 0;
    *((_QWORD *)v12 + 2) = 0;
    *((_QWORD *)v12 + 3) = v12 + 16;
    *((_QWORD *)v12 + 4) = 0;
    *((_QWORD *)v12 + 5) = 0;
    *((_QWORD *)v12 + 6) = 0;
    *((_QWORD *)v12 + 7) = v12 + 16;
    sub_1C477449C((uint64_t)(v12 + 16), a2, a3, (llvm::Value *)&v15, 1, 2, (uint64_t)v14, 0);
    return sub_1C477438C((uint64_t *)a1, v13, a5);
  }
  return result;
}

uint64_t sub_1C61DDD4C(uint64_t a1, char *a2, _WORD *a3, _OWORD *a4)
{
  uint64_t v8;
  size_t v9;

  v8 = sub_1C47AD050(a1, 0, 0);
  *(_DWORD *)(v8 + 128) = 0;
  *(_QWORD *)(v8 + 136) = &off_1E7F952A8;
  *(_QWORD *)(v8 + 144) = 0;
  *(_QWORD *)v8 = &unk_1E819E3B0;
  *(_QWORD *)(v8 + 152) = &unk_1E819E2C0;
  *(_QWORD *)(v8 + 160) = &off_1E7F95260;
  *(_QWORD *)(v8 + 184) = v8 + 160;
  v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  *(_WORD *)(a1 + 10) = (32 * (*a3 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1C61DDE18(_WORD *a1, __int128 *a2)
{
  uint64_t v4;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F76C8, 0, 0);
  dword_1ED7F7748 = 0;
  qword_1ED7F7750 = (uint64_t)&off_1E7F952A8;
  unk_1ED7F7758 = 0;
  qword_1ED7F76C8 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F7760 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F7768 = (uint64_t)&off_1E7F95260;
  qword_1ED7F7780 = (uint64_t)&qword_1ED7F7768;
  llvm::cl::Option::setArgStr(v4, "max-loads-per-memcmp-opt-size", 0x1DuLL);
  word_1ED7F76D2 = (32 * (*a1 & 3)) | word_1ED7F76D2 & 0xFF9F;
  xmmword_1ED7F76E8 = *a2;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F76C8);
}

void llvm::initializeExpandPostRAPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7788);
  if (v2 != -1)
  {
    v5[0] = sub_1C50BAAC8;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7788, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createExpandReductionsPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C50BB314(v1);
}

uint64_t llvm::createExpandVectorPredicationPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C50BBC20(v1);
}

__n128 sub_1C61DDF8C(const char **a1, _WORD *a2, __n128 *a3)
{
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F77B0, "expandvp-override-evl-transform", 0x1FuLL);
  sub_1C49C7D74(a1, (uint64_t)&qword_1ED7F77B0);
  word_1ED7F77BA = (32 * (*a2 & 3)) | word_1ED7F77BA & 0xFF9F;
  result = *a3;
  xmmword_1ED7F77D0 = (__int128)*a3;
  return result;
}

__n128 sub_1C61DE000(const char **a1, _WORD *a2, __n128 *a3)
{
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F7898, "expandvp-override-mask-transform", 0x20uLL);
  sub_1C49C7D74(a1, (uint64_t)&qword_1ED7F7898);
  word_1ED7F78A2 = (32 * (*a2 & 3)) | word_1ED7F78A2 & 0xFF9F;
  result = *a3;
  xmmword_1ED7F78B8 = (__int128)*a3;
  return result;
}

void llvm::initializeFEntryInserterPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7980);
  if (v2 != -1)
  {
    v5[0] = sub_1C50BDAE4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7980, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeFinalizeISelPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7988);
  if (v2 != -1)
  {
    v5[0] = sub_1C50BE18C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7988, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeFixupStatepointCallerSavedPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7990);
  if (v2 != -1)
  {
    v5[0] = sub_1C50BE494;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7990, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61DE1A0(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 88 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 88 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61DE23C(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61DE1A0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61DE2B4(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x800000000;
  }
  return v5;
}

_QWORD *sub_1C61DE2B4(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C50C09FC(a1, v6);
  v8 = 0;
  sub_1C61DE1A0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61DE364(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 88 * v6;
    do
    {
      *v7 = -4096;
      v7 += 11;
      v8 -= 88;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61DE1A0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x800000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C50C0AC0(v11, v4 + 8);
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
}

_DWORD *sub_1C61DE458(uint64_t a1, int *a2)
{
  int v3;
  int v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  _DWORD *v9;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    v9 = 0;
LABEL_5:
    v6 = sub_1C61DE510(a1, a2, v9);
    *(_QWORD *)v6 = *a2;
    return v6;
  }
  v4 = v3 - 1;
  v5 = (37 * *a2) & (v3 - 1);
  v6 = (_DWORD *)(*(_QWORD *)a1 + 8 * v5);
  v7 = *v6;
  if (*a2 != *v6)
  {
    v10 = 0;
    v11 = 1;
    while (v7 != -1)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v7 == -2;
      if (v12)
        v10 = v6;
      v13 = v5 + v11++;
      v5 = v13 & v4;
      v6 = (_DWORD *)(*(_QWORD *)a1 + 8 * (v13 & v4));
      v7 = *v6;
      if (*a2 == *v6)
        return v6;
    }
    if (v10)
      v9 = v10;
    else
      v9 = v6;
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1C61DE510(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  int v7;
  int v9;
  unsigned int v10;
  int v11;
  _DWORD *v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  BOOL v20;
  unsigned int v21;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1C50C4EB4(a1, 2 * v6);
    v7 = *a2;
    v9 = *(_DWORD *)(a1 + 16) - 1;
    v10 = (37 * *a2) & v9;
    a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v10);
    v11 = *a3;
    if (*a2 != *a3)
    {
      v12 = 0;
      v13 = 1;
      while (v11 != -1)
      {
        if (v12)
          v14 = 0;
        else
          v14 = v11 == -2;
        if (v14)
          v12 = a3;
        v15 = v10 + v13++;
        v10 = v15 & v9;
        a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v10);
        v11 = *a3;
        if (v7 == *a3)
          goto LABEL_4;
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      v7 = *a3;
      goto LABEL_4;
    }
    sub_1C50C4EB4(a1, v6);
    v7 = *a2;
    v16 = *(_DWORD *)(a1 + 16) - 1;
    v17 = (37 * *a2) & v16;
    a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v17);
    v18 = *a3;
    if (*a2 != *a3)
    {
      v12 = 0;
      v19 = 1;
      while (v18 != -1)
      {
        if (v12)
          v20 = 0;
        else
          v20 = v18 == -2;
        if (v20)
          v12 = a3;
        v21 = v17 + v19++;
        v17 = v21 & v16;
        a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v17);
        v18 = *a3;
        if (v7 == *a3)
          goto LABEL_4;
      }
LABEL_20:
      if (v12)
        a3 = v12;
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61DE684(uint64_t result, int *a2, int *a3)
{
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  int v7;
  int v8;
  unsigned int v9;
  _DWORD *v10;
  int v11;
  _DWORD *v12;
  int v13;
  BOOL v14;
  unsigned int v15;

  *(_QWORD *)(result + 8) = 0;
  v3 = *(_DWORD **)result;
  v4 = *(unsigned int *)(result + 16);
  if ((_DWORD)v4)
  {
    v5 = 8 * v4;
    v6 = *(_DWORD **)result;
    do
    {
      *v6 = -1;
      v6 += 2;
      v5 -= 8;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    v7 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      v8 = *(_DWORD *)(result + 16) - 1;
      v9 = v8 & (37 * v7);
      v10 = &v3[2 * v9];
      v11 = *v10;
      if (v7 != *v10)
      {
        v12 = 0;
        v13 = 1;
        while (v11 != -1)
        {
          if (v12)
            v14 = 0;
          else
            v14 = v11 == -2;
          if (v14)
            v12 = v10;
          v15 = v9 + v13++;
          v9 = v15 & v8;
          v10 = &v3[2 * (v15 & v8)];
          v11 = *v10;
          if (v7 == *v10)
            goto LABEL_7;
        }
        if (v12)
          v10 = v12;
      }
LABEL_7:
      *v10 = v7;
      v10[1] = a2[1];
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

uint64_t sub_1C61DE758(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 112 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != -4096)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 112 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_QWORD *sub_1C61DE7F4(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;

  v8 = 0;
  v4 = sub_1C61DE758(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  v5 = v8;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61DE890(a1, a2, v8);
    v7 = *a2;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 7) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    *v5 = v7;
    v5[1] = v5 + 3;
    v5[2] = 0x800000000;
    v5[13] = 0;
    v5[12] = 0;
    v5[11] = v5 + 12;
  }
  return v5;
}

_QWORD *sub_1C61DE890(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C50C51DC(a1, v6);
  v8 = 0;
  sub_1C61DE758(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61DE940(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 112 * v6;
    do
    {
      *v7 = -4096;
      v7 += 14;
      v8 -= 112;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *(_QWORD *)a2;
    if ((*(_QWORD *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v12 = 0;
      sub_1C61DE758(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      v10 = v12;
      *v12 = *(_QWORD *)a2;
      sub_1C61DEA14(v10 + 1, a2 + 8);
      ++*(_DWORD *)(a1 + 8);
      sub_1C6143384(*(_QWORD **)(a2 + 96));
      v11 = *(void **)(a2 + 8);
      if ((void *)(a2 + 24) != v11)
        free(v11);
    }
    a2 += 112;
  }
}

_QWORD *sub_1C61DEA14(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  *result = result + 2;
  result[1] = 0x800000000;
  if (*(_DWORD *)(a2 + 8))
    result = (_QWORD *)sub_1C50C0AC0((uint64_t)result, a2);
  result[10] = *(_QWORD *)(a2 + 80);
  v3 = (_QWORD *)(a2 + 88);
  v4 = *(_QWORD *)(a2 + 88);
  result[11] = v4;
  v5 = result + 11;
  v6 = *(_QWORD *)(a2 + 96);
  result[12] = v6;
  if (v6)
  {
    *(_QWORD *)(v4 + 16) = v5;
    *(_QWORD *)(a2 + 80) = v3;
    *v3 = 0;
    *(_QWORD *)(a2 + 96) = 0;
  }
  else
  {
    result[10] = v5;
  }
  return result;
}

uint64_t *sub_1C61DEA8C(uint64_t a1, unsigned int a2, int a3, uint64_t *a4)
{
  uint64_t *result;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;

  result = sub_1C50C52A0(a1, &v12, a2, a3);
  if (!*result)
  {
    v7 = result;
    v8 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v8 + 28) = *a4;
    v9 = v12;
    *v8 = 0;
    v8[1] = 0;
    v8[2] = v9;
    *v7 = (uint64_t)v8;
    v10 = **(_QWORD **)a1;
    if (v10)
    {
      *(_QWORD *)a1 = v10;
      v11 = (uint64_t *)*v7;
    }
    else
    {
      v11 = v8;
    }
    result = sub_1C4768E74(*(uint64_t **)(a1 + 8), v11);
    ++*(_QWORD *)(a1 + 16);
  }
  return result;
}

void sub_1C61DEB2C(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  void *v4;

  if (a2)
  {
    v3 = 112 * a2;
    do
    {
      if ((*(_QWORD *)a1 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        sub_1C6143384(*(_QWORD **)(a1 + 96));
        v4 = *(void **)(a1 + 8);
        if ((void *)(a1 + 24) != v4)
          free(v4);
      }
      a1 += 112;
      v3 -= 112;
    }
    while (v3);
  }
}

void sub_1C61DEB94(_WORD *a1, char **a2, __n128 *a3, _WORD *a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F7998, 0, 0);
  byte_1ED7F7A18 = 0;
  qword_1ED7F7A20 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F7A28 = 0;
  qword_1ED7F7998 = (uint64_t)&unk_1E819E898;
  qword_1ED7F7A30 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F7A38 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F7A50 = (uint64_t)&qword_1ED7F7A38;
  sub_1C61DEC48(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F7998);
}

__n128 sub_1C61DEC48(_WORD *a1, char **a2, __n128 *a3, _WORD *a4)
{
  __int16 v8;
  char *v9;
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7F7998, "fixup-scs-extend-slot-size", 0x1AuLL);
  v8 = word_1ED7F79A2;
  word_1ED7F79A2 = word_1ED7F79A2 & 0xFF9F | (32 * (*a1 & 3));
  v9 = *a2;
  byte_1ED7F7A18 = **a2;
  byte_1ED7F7A29 = 1;
  byte_1ED7F7A28 = *v9;
  result = *a3;
  xmmword_1ED7F79B8 = (__int128)*a3;
  word_1ED7F79A2 = v8 & 0xFF9F | (32 * (*a4 & 3));
  return result;
}

void sub_1C61DECE0(_WORD *a1, __int128 *a2)
{
  uint64_t v4;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F7BD8, 0, 0);
  dword_1ED7F7C58 = 0;
  qword_1ED7F7C60 = (uint64_t)&off_1E7F952A8;
  unk_1ED7F7C68 = 0;
  qword_1ED7F7BD8 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F7C70 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F7C78 = (uint64_t)&off_1E7F95260;
  qword_1ED7F7C90 = (uint64_t)&qword_1ED7F7C78;
  llvm::cl::Option::setArgStr(v4, "fixup-max-csr-statepoints", 0x19uLL);
  word_1ED7F7BE2 = (32 * (*a1 & 3)) | word_1ED7F7BE2 & 0xFF9F;
  xmmword_1ED7F7BF8 = *a2;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F7BD8);
}

void llvm::initializeFuncletLayoutPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7C98);
  if (v2 != -1)
  {
    v5[0] = sub_1C50C5458;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7C98, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeGCModuleInfoPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F0C8);
  if (v2 != -1)
  {
    v5[0] = sub_1C50C5AF0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F0C8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::GCFunctionInfo::~GCFunctionInfo(llvm::GCFunctionInfo *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 48);
  sub_1C50C661C(&v3);
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
}

llvm::GCModuleInfo *llvm::GCModuleInfo::GCModuleInfo(llvm::GCModuleInfo *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::GCModuleInfo::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E8142760;
  *((_QWORD *)this + 4) = (char *)this + 48;
  *((_QWORD *)this + 5) = 0x100000000;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0x1000000000;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82F0C8);
  if (v2 != -1)
  {
    v6[0] = sub_1C50C5AF0;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82F0C8, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::GCModuleInfo::getFunctionInfo(llvm::GCModuleInfo *this, const llvm::Function *a2)
{
  uint64_t *v4;
  uint64_t v5;
  _QWORD *GC;
  char v8;
  BOOL v9;
  unsigned __int8 *v10;
  size_t v11;
  size_t v12;
  uint64_t GCStrategy;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  llvm::GCFunctionInfo *v17;
  const llvm::Function *v18;
  llvm::GCFunctionInfo *v19;

  v4 = (uint64_t *)((char *)this + 112);
  v18 = a2;
  v19 = 0;
  if (sub_1C61252B8((uint64_t *)this + 14, &v18, &v19)
    && v19 != (llvm::GCFunctionInfo *)(*((_QWORD *)this + 14) + 16 * *((unsigned int *)this + 32)))
  {
    return *((_QWORD *)v19 + 1);
  }
  GC = llvm::Function::getGC(a2);
  v8 = *((_BYTE *)GC + 23);
  v9 = v8 < 0;
  if (v8 >= 0)
    v10 = (unsigned __int8 *)GC;
  else
    v10 = (unsigned __int8 *)*GC;
  v11 = v8 & 0x7F;
  if (v9)
    v12 = GC[1];
  else
    v12 = v11;
  GCStrategy = llvm::GCModuleInfo::getGCStrategy((uint64_t)this, v10, v12);
  v14 = operator new();
  *(_QWORD *)v14 = a2;
  *(_QWORD *)(v14 + 8) = GCStrategy;
  *(_QWORD *)(v14 + 16) = -1;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  v19 = (llvm::GCFunctionInfo *)v14;
  v15 = (uint64_t *)*((_QWORD *)this + 12);
  if ((unint64_t)v15 >= *((_QWORD *)this + 13))
  {
    v16 = sub_1C50C669C((char **)this + 11, (uint64_t *)&v19);
    v17 = v19;
    *((_QWORD *)this + 12) = v16;
    v19 = 0;
    if (v17)
    {
      llvm::GCFunctionInfo::~GCFunctionInfo(v17);
      MEMORY[0x1CAA32FC0]();
      v16 = (char *)*((_QWORD *)this + 12);
    }
  }
  else
  {
    *v15 = v14;
    v16 = (char *)(v15 + 1);
    *((_QWORD *)this + 12) = v16;
  }
  v5 = *((_QWORD *)v16 - 1);
  v19 = a2;
  sub_1C61DF1DC(v4, &v19)[1] = v5;
  return v5;
}

unsigned int *llvm::GCModuleInfo::clear(llvm::GCModuleInfo *this)
{
  unsigned int *v2;
  unsigned int *result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = (unsigned int *)((char *)this + 88);
  sub_1C50C67B0((llvm::GCModuleInfo *)((char *)this + 88), *((_QWORD **)this + 11));
  result = sub_1C61446F0(v2 + 6);
  v4 = *(v2 - 12);
  if ((_DWORD)v4)
  {
    v5 = *((_QWORD *)v2 - 7);
    v6 = 8 * v4;
    v7 = v5 - 8;
    do
    {
      result = *(unsigned int **)(v7 + v6);
      *(_QWORD *)(v7 + v6) = 0;
      if (result)
        result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)result + 8))(result);
      v6 -= 8;
    }
    while (v6);
  }
  *((_DWORD *)this + 10) = 0;
  return result;
}

uint64_t llvm::createGCInfoPrinter(llvm *this, llvm::raw_ostream *a2)
{
  uint64_t result;

  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = &unk_1EF8F6EE1;
  *(_DWORD *)(result + 24) = 2;
  *(_QWORD *)result = &off_1E8142808;
  *(_QWORD *)(result + 32) = this;
  return result;
}

void sub_1C61DF190(uint64_t a1)
{
  sub_1C61DF238(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::GCModuleInfo *llvm::callDefaultCtor<llvm::GCModuleInfo>()
{
  llvm::GCModuleInfo *v0;

  v0 = (llvm::GCModuleInfo *)operator new();
  return llvm::GCModuleInfo::GCModuleInfo(v0);
}

_QWORD *sub_1C61DF1DC(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61252B8(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61899D4((uint64_t)a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void sub_1C61DF238(uint64_t a1)
{
  _QWORD *v2;

  *(_QWORD *)a1 = &off_1E8142760;
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 112), 8);
  v2 = *(_QWORD **)(a1 + 88);
  if (v2)
  {
    sub_1C50C67B0((llvm::GCFunctionInfo *)(a1 + 88), v2);
    operator delete(*(void **)(a1 + 88));
  }
  sub_1C61DF2A0(a1 + 56);
  sub_1C61DF314((void **)(a1 + 32));
  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
}

uint64_t sub_1C61DF2A0(uint64_t a1)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 8 * v3;
      do
      {
        v6 = *(_QWORD *)(*(_QWORD *)a1 + v4);
        if (v6 != -8 && v6 != 0)
          MEMORY[0x1CAA32FB4]();
        v4 += 8;
      }
      while (v5 != v4);
    }
  }
  free(*(void **)a1);
  return a1;
}

void **sub_1C61DF314(void **result)
{
  void **v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  void **v6;
  void **v7;

  v1 = (void **)*result;
  v2 = *((unsigned int *)result + 2);
  if ((_DWORD)v2)
  {
    v7 = result;
    v3 = 8 * v2;
    v4 = (char *)(v1 - 1);
    do
    {
      v5 = *(_QWORD *)&v4[v3];
      *(_QWORD *)&v4[v3] = 0;
      if (v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v3 -= 8;
    }
    while (v3);
    result = v7;
    v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void *llvm::Registry<llvm::GCMetadataPrinter>::begin()
{
  return llvm::Registry<llvm::GCMetadataPrinter>::Head;
}

void llvm::initializeLowerIntrinsicsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F0D0);
  if (v2 != -1)
  {
    v5[0] = sub_1C50C6890;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F0D0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeGCMachineCodeAnalysisPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F7CA0);
  if (v2 != -1)
  {
    v5[0] = sub_1C50C6A10;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F7CA0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61DF470(uint64_t *a1, uint64_t a2, unsigned __int8 *a3)
{
  unint64_t v4;
  uint64_t result;

  v4 = a1[1];
  if (v4 >= a1[2])
  {
    result = sub_1C50C7704(a1, a2, a3);
  }
  else
  {
    sub_1C50C77EC((_QWORD *)a1[1], a2, a3);
    result = v4 + 16;
  }
  a1[1] = result;
  return result;
}

uint64_t *sub_1C61DF4B4(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  unsigned __int8 **v5;
  uint64_t v6;
  unsigned __int8 **v7;
  uint64_t v8;
  unsigned __int8 **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = result;
  v5 = (unsigned __int8 **)*result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 != *result)
  {
    v7 = (unsigned __int8 **)(v4 - 8);
    v8 = v6 - 8;
    do
    {
      *(_OWORD *)(v8 - 8) = *(_OWORD *)(v7 - 1);
      if (*v7)
      {
        result = (uint64_t *)llvm::MetadataTracking::retrack((uint64_t)v7, *v7, v8);
        *v7 = 0;
      }
      v9 = v7 - 1;
      v7 -= 2;
      v8 -= 16;
    }
    while (v9 != v5);
    v6 = v8 + 8;
  }
  a2[1] = v6;
  v10 = *v3;
  *v3 = v6;
  a2[1] = v10;
  v11 = v3[1];
  v3[1] = a2[2];
  a2[2] = v11;
  v12 = v3[2];
  v3[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1C61DF56C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    v4 = v2 - 16;
    *(_QWORD *)(a1 + 16) = v2 - 16;
    v7 = *(unsigned __int8 **)(v2 - 8);
    v5 = v2 - 8;
    v6 = v7;
    if (v7)
    {
      llvm::MetadataTracking::untrack(v5, v6);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 = v4;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void llvm::initializeHardwareLoopsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F8140);
  if (v2 != -1)
  {
    v5[0] = sub_1C50CE6A8;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F8140, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createHardwareLoopsPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C50CE754(v1);
}

void sub_1C61DF658()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61DF66C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E8142B90;
  result[1] = v3;
  return result;
}

void llvm::initializeIfConverterPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F85D0);
  if (v2 != -1)
  {
    v5[0] = sub_1C50D0AD0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F85D0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61DF708(uint64_t *a1, unsigned __int16 *a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *a2;
  v4 = a1[5];
  v5 = *(unsigned __int8 *)(v4 + v3);
  v6 = a1[1];
  if (v5 < v6)
  {
    v7 = *a1;
    while (1)
    {
      v8 = v5;
      if (*(unsigned __int16 *)(v7 + 2 * v5) == (_DWORD)v3)
        break;
      v5 += 256;
      if (v8 + 256 >= v6)
        goto LABEL_5;
    }
    if (v6 != v5)
      return v7 + 2 * v5;
  }
LABEL_5:
  *(_BYTE *)(v4 + v3) = v6;
  v9 = *a2;
  v10 = a1[1];
  if (v10 + 1 > (unint64_t)a1[2])
  {
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)a1, a1 + 3, v10 + 1, 2);
    v10 = a1[1];
  }
  *(_WORD *)(*a1 + 2 * v10) = v9;
  v11 = *a1;
  v12 = a1[1] + 1;
  a1[1] = v12;
  return v11 + 2 * v12 - 2;
}

void sub_1C61DF7C0(int **a1, _WORD *a2)
{
  uint64_t v4;
  int *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F85D8, 0, 0);
  dword_1ED7F8658 = 0;
  qword_1ED7F8660 = (uint64_t)&off_1E7FA9DC8;
  *(_QWORD *)&dword_1ED7F8668 = 0;
  qword_1ED7F85D8 = (uint64_t)&unk_1E819E418;
  qword_1ED7F8670 = (uint64_t)&unk_1E819E230;
  qword_1ED7F8678 = (uint64_t)&off_1E7FA9D80;
  qword_1ED7F8690 = (uint64_t)&qword_1ED7F8678;
  llvm::cl::Option::setArgStr(v4, "ifcvt-fn-start", 0xEuLL);
  v5 = *a1;
  dword_1ED7F8658 = **a1;
  byte_1ED7F866C = 1;
  dword_1ED7F8668 = *v5;
  word_1ED7F85E2 = (32 * (*a2 & 3)) | word_1ED7F85E2 & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F85D8);
}

uint64_t sub_1C61DF88C(uint64_t a1, char *a2, _DWORD **a3, _WORD *a4)
{
  uint64_t v8;
  size_t v9;
  _DWORD *v10;

  v8 = sub_1C47AD050(a1, 0, 0);
  *(_DWORD *)(v8 + 128) = 0;
  *(_QWORD *)(v8 + 136) = &off_1E7FA9DC8;
  *(_QWORD *)(v8 + 144) = 0;
  *(_QWORD *)v8 = &unk_1E819E418;
  *(_QWORD *)(v8 + 152) = &unk_1E819E230;
  *(_QWORD *)(v8 + 160) = &off_1E7FA9D80;
  *(_QWORD *)(v8 + 184) = v8 + 160;
  v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  v10 = *a3;
  *(_DWORD *)(a1 + 128) = **a3;
  *(_BYTE *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v10;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1C61DF964(int **a1, _WORD *a2)
{
  uint64_t v4;
  int *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7F8758, 0, 0);
  dword_1ED7F87D8 = 0;
  qword_1ED7F87E0 = (uint64_t)&off_1E7FA9DC8;
  *(_QWORD *)&dword_1ED7F87E8 = 0;
  qword_1ED7F8758 = (uint64_t)&unk_1E819E418;
  qword_1ED7F87F0 = (uint64_t)&unk_1E819E230;
  qword_1ED7F87F8 = (uint64_t)&off_1E7FA9D80;
  qword_1ED7F8810 = (uint64_t)&qword_1ED7F87F8;
  llvm::cl::Option::setArgStr(v4, "ifcvt-limit", 0xBuLL);
  v5 = *a1;
  dword_1ED7F87D8 = **a1;
  byte_1ED7F87EC = 1;
  dword_1ED7F87E8 = *v5;
  word_1ED7F8762 = (32 * (*a2 & 3)) | word_1ED7F8762 & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F8758);
}

void llvm::initializeImplicitNullChecksPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F8ED8);
  if (v2 != -1)
  {
    v5[0] = sub_1C50D7D34;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F8ED8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C61DFA94(__n128 *a1, int **a2, _WORD *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F8EE0, 0, 0);
  dword_1ED7F8F60 = 0;
  qword_1ED7F8F68 = (uint64_t)&off_1E7FA9DC8;
  *(_QWORD *)&dword_1ED7F8F70 = 0;
  qword_1ED7F8EE0 = (uint64_t)&unk_1E819E418;
  qword_1ED7F8F78 = (uint64_t)&unk_1E819E230;
  qword_1ED7F8F80 = (uint64_t)&off_1E7FA9D80;
  qword_1ED7F8F98 = (uint64_t)&qword_1ED7F8F80;
  sub_1C50D9FD4(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F8EE0);
}

uint64_t sub_1C61DFB30(uint64_t a1, char *a2, _OWORD *a3, _WORD *a4, int **a5)
{
  uint64_t v10;
  size_t v11;
  int v12;

  v10 = sub_1C47AD050(a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(_QWORD *)(v10 + 136) = &off_1E7F952A8;
  *(_QWORD *)(v10 + 144) = 0;
  *(_QWORD *)v10 = &unk_1E819E3B0;
  *(_QWORD *)(v10 + 152) = &unk_1E819E2C0;
  *(_QWORD *)(v10 + 160) = &off_1E7F95260;
  *(_QWORD *)(v10 + 184) = v10 + 160;
  v11 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v11);
  *(_OWORD *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  v12 = **a5;
  *(_DWORD *)(a1 + 128) = v12;
  *(_BYTE *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void llvm::initializeIndirectBrExpandPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F9068);
  if (v2 != -1)
  {
    v5[0] = sub_1C50DA134;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F9068, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

double sub_1C61DFC84(uint64_t a1, uint64_t a2, char *a3)
{
  char v5;
  double result;

  if (*(_BYTE *)(a1 + 440))
    a1 = sub_1C50B98E4(a1);
  v5 = *a3;
  *(_QWORD *)a1 = a1 + 16;
  *(_QWORD *)(a1 + 8) = 0x1000000000;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = a2;
  *(_QWORD *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 304) = v5;
  *(_QWORD *)(a1 + 312) = a1 + 344;
  *(_QWORD *)(a1 + 320) = a1 + 344;
  *(_QWORD *)&result = 8;
  *(_QWORD *)(a1 + 328) = 8;
  *(_DWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_QWORD *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 432) = 0;
  *(_BYTE *)(a1 + 440) = 1;
  return result;
}

_DWORD *sub_1C61DFD04(uint64_t *a1, _DWORD *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C61DFD70(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61DFE14((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 2) = 0;
    *((_QWORD *)v5 + 3) = -1;
    *((_QWORD *)v5 + 4) = -1;
  }
  return v5;
}

uint64_t sub_1C61DFD70(uint64_t *a1, _DWORD *a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  int v8;
  uint64_t result;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = v3 - 1;
    v6 = (37 * *a2) & (v3 - 1);
    v7 = (_DWORD *)(*a1 + 40 * v6);
    v8 = *v7;
    if (*a2 == *v7)
    {
      result = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      result = 1;
      while (v8 != -1)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v8 == -2;
        if (v12)
          v10 = v7;
        v13 = v6 + v11++;
        v6 = v13 & v5;
        v7 = (_DWORD *)(v4 + 40 * (v13 & v5));
        v8 = *v7;
        if (*a2 == *v7)
          goto LABEL_4;
      }
      result = 0;
      if (v10)
        v7 = v10;
    }
  }
  else
  {
    v7 = 0;
    result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

_DWORD *sub_1C61DFE14(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v6;
  unsigned int v7;
  _DWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C50E1294(a1, v7);
  v9 = 0;
  sub_1C61DFD70((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

uint64_t sub_1C61DFEC0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  _DWORD *v9;
  __int128 v10;
  _DWORD *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_DWORD **)result;
    v8 = 40 * v6;
    do
    {
      *v7 = -1;
      v7 += 10;
      v8 -= 40;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      v11 = 0;
      result = sub_1C61DFD70((uint64_t *)v5, (_DWORD *)a2, &v11);
      v9 = v11;
      *v11 = *(_DWORD *)a2;
      v10 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(v9 + 6) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(v9 + 2) = v10;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 40;
  }
  return result;
}

uint64_t sub_1C61DFF7C(uint64_t result, unsigned int a2, unsigned int *a3)
{
  uint64_t v3;
  unsigned int *v4;

  v3 = *(unsigned int *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12))
    return sub_1C61DFFB0(result, a2, *a3);
  v4 = (unsigned int *)(*(_QWORD *)result + 8 * v3);
  *v4 = a2;
  v4[1] = *a3;
  *(_DWORD *)(result + 8) = v3 + 1;
  return result;
}

uint64_t sub_1C61DFFB0(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int v7;

  v6 = *(unsigned int *)(a1 + 8);
  if (v6 >= *(_DWORD *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v6 + 1, 8);
    LODWORD(v6) = *(_DWORD *)(a1 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v6) = a2 | (unint64_t)(a3 << 32);
  v7 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v7;
  return *(_QWORD *)a1 + 8 * v7 - 8;
}

void sub_1C61E002C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  void *v11;
  uint64_t *v12;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 176 * v6;
    do
    {
      *v7 = -4096;
      v7 += 22;
      v8 -= 176;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if (*a2 != -8192 && v9 != -4096)
    {
      v12 = 0;
      sub_1C50E45EC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      v10 = v12;
      *v12 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v10 + 5, 16, a2 + 1);
      v10[21] = a2[21];
      ++*(_DWORD *)(a1 + 8);
      v11 = (void *)a2[2];
      if (v11 != (void *)a2[1])
        free(v11);
    }
    a2 += 22;
  }
}

void llvm::initializeInterleavedAccessPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F92B8);
  if (v2 != -1)
  {
    v5[0] = sub_1C50E619C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F92B8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

_QWORD *sub_1C61E016C(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C617A1AC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C617A248(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
    *((_DWORD *)v5 + 4) = 0;
  }
  return v5;
}

void llvm::initializeInterleavedLoadCombinePass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F9388);
  if (v2 != -1)
  {
    v5[0] = sub_1C50E7954;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F9388, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeJMCInstrumenterPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F9398);
  if (v2 != -1)
  {
    v5[0] = sub_1C50EEC20;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F9398, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createJMCInstrumenterPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C50EECB0(v1);
}

char **sub_1C61E02C8(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  unsigned __int8 *v6;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    v5 = v2 - 8;
    do
    {
      v6 = *(unsigned __int8 **)&v5[v4];
      if (v6)
        llvm::MetadataTracking::untrack((uint64_t)&v5[v4], v6);
      v4 -= 8;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

BOOL llvm::latency_sort::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;

  if ((*(_WORD *)(a2 + 228) & 0x800) != 0)
  {
    if ((*(_WORD *)(a3 + 228) & 0x800) == 0)
      return 0;
  }
  else if ((*(_WORD *)(a3 + 228) & 0x800) != 0)
  {
    return 1;
  }
  v5 = *(unsigned int *)(a2 + 192);
  v6 = *(unsigned int *)(a3 + 192);
  v7 = **(_QWORD **)(*(_QWORD *)a1 + 16);
  v8 = v7;
  if ((*(_BYTE *)(v7 + 272 * v5 + 236) & 2) == 0)
  {
    llvm::SUnit::ComputeHeight((llvm::SUnit *)(v7 + 272 * v5));
    v8 = **(_QWORD **)(*(_QWORD *)a1 + 16);
  }
  v9 = *(_DWORD *)(v7 + 272 * v5 + 244);
  if ((*(_BYTE *)(v8 + 272 * v6 + 236) & 2) == 0)
    llvm::SUnit::ComputeHeight((llvm::SUnit *)(v8 + 272 * v6));
  v10 = *(_DWORD *)(v8 + 272 * v6 + 244);
  if (v9 < v10)
    return 1;
  if (v9 > v10)
    return 0;
  v11 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  v12 = *(_DWORD *)(v11 + 4 * v5);
  v13 = *(_DWORD *)(v11 + 4 * v6);
  if (v12 < v13)
    return 1;
  return v12 <= v13 && v6 < v5;
}

uint64_t llvm::LatencyPriorityQueue::scheduledNode(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(unsigned int *)(a2 + 120);
  if ((_DWORD)v2)
  {
    v3 = result;
    v4 = *(uint64_t **)(a2 + 112);
    v5 = 16 * v2;
    do
    {
      v6 = *v4;
      v4 += 2;
      result = llvm::LatencyPriorityQueue::AdjustPriorityOfUnscheduledPreds(v3, v6 & 0xFFFFFFFFFFFFFFF8);
      v5 -= 16;
    }
    while (v5);
  }
  return result;
}

uint64_t llvm::LatencyPriorityQueue::pop(uint64_t **this)
{
  uint64_t result;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;

  if ((((uint64_t (*)(uint64_t **))(*this)[8])(this) & 1) != 0)
    return 0;
  v3 = this[6];
  v4 = this[7];
  v5 = v3 + 1;
  if (v3 + 1 != v4)
  {
    v6 = v3 + 1;
    do
    {
      v7 = *v6++;
      if (llvm::latency_sort::operator()((uint64_t)(this + 9), *v3, v7))
        v3 = v5;
      v5 = v6;
    }
    while (v6 != v4);
    v4 = this[7];
  }
  result = *v3;
  v8 = v4 - 1;
  if (v3 != v4 - 1)
  {
    *v3 = *v8;
    *v8 = result;
    v4 = this[7];
  }
  this[7] = v4 - 1;
  return result;
}

uint64_t llvm::LatencyPriorityQueue::remove(uint64_t result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;

  v2 = *(uint64_t **)(result + 48);
  v3 = *(uint64_t **)(result + 56);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        v2 = *(uint64_t **)(result + 56);
        break;
      }
    }
  }
  v4 = v3 - 1;
  if (v2 != v3 - 1)
  {
    v5 = *v2;
    *v2 = *v4;
    *v4 = v5;
    v3 = *(uint64_t **)(result + 56);
  }
  *(_QWORD *)(result + 56) = v3 - 1;
  return result;
}

llvm *llvm::LatencyPriorityQueue::dump(uint64_t **this, llvm::ScheduleDAG *a2)
{
  llvm *v4;
  llvm *v5;
  llvm *v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm *result;
  uint64_t *v10;
  uint64_t *i;
  uint64_t v12;
  llvm *v13;

  v4 = llvm::dbgs((llvm *)this);
  v5 = sub_1C4816AD8(v4, "Latency Priority Queue\n");
  v6 = llvm::dbgs(v5);
  v7 = sub_1C4816AD8(v6, "  Number of Queue Entries: ");
  v8 = llvm::raw_ostream::operator<<(v7, this[7] - this[6]);
  result = sub_1C4816AD8(v8, "\n");
  v10 = this[6];
  for (i = this[7];
        v10 != i;
        result = (llvm *)(*(uint64_t (**)(llvm::ScheduleDAG *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v12))
  {
    v12 = *v10++;
    v13 = llvm::dbgs(result);
    sub_1C4816AD8(v13, "    ");
  }
  return result;
}

void sub_1C61E061C(_QWORD *a1)
{
  sub_1C61E0760(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61E0640()
{
  return 0;
}

void sub_1C61E0648(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  a1[2] = a2;
  v2 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(a2[1] - *a2) >> 4);
  v5 = 0;
  v3 = a1[3];
  v4 = (a1[4] - v3) >> 2;
  if (v2 <= v4)
  {
    if (v2 < v4)
      a1[4] = v3 + 4 * v2;
  }
  else
  {
    sub_1C50F0728((uint64_t)(a1 + 3), v2 - v4, &v5);
  }
}

void sub_1C61E06BC(_QWORD *a1)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;
  int v4;

  v1 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(_QWORD *)(a1[2] + 8) - *(_QWORD *)a1[2]) >> 4);
  v4 = 0;
  v2 = a1[3];
  v3 = (a1[4] - v2) >> 2;
  if (v1 <= v3)
  {
    if (v1 < v3)
      a1[4] = v2 + 4 * v1;
  }
  else
  {
    sub_1C50F0728((uint64_t)(a1 + 3), v1 - v3, &v4);
  }
}

uint64_t sub_1C61E0734(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

BOOL sub_1C61E073C(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 56);
}

uint64_t sub_1C61E074C()
{
  return 0;
}

uint64_t sub_1C61E0754()
{
  return 1;
}

_QWORD *sub_1C61E0760(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E81430C0;
  v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
  return a1;
}

void llvm::initializeLazyMachineBlockFrequencyInfoPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F0D8);
  if (v2 != -1)
  {
    v5[0] = sub_1C50F0858;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F0D8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::LazyMachineBlockFrequencyInfoPass *llvm::LazyMachineBlockFrequencyInfoPass::LazyMachineBlockFrequencyInfoPass(llvm::LazyMachineBlockFrequencyInfoPass *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848((uint64_t)this, (uint64_t)&llvm::LazyMachineBlockFrequencyInfoPass::ID);
  *(_QWORD *)v2 = &off_1E8143158;
  *(_OWORD *)(v2 + 248) = 0u;
  *(_OWORD *)(v2 + 264) = 0u;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED82F0D8);
  if (v3 != -1)
  {
    v7[0] = sub_1C50F0858;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F0D8, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::LazyMachineBlockFrequencyInfoPass::print(llvm::LazyMachineBlockFrequencyInfoPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v5;

  v5 = llvm::LazyMachineBlockFrequencyInfoPass::calculateIfNotAvailable(this);
  return (*(uint64_t (**)(uint64_t, llvm::raw_ostream *, const llvm::Module *))(*(_QWORD *)v5 + 40))(v5, a2, a3);
}

void *llvm::LazyMachineBlockFrequencyInfoPass::getAnalysisUsage(llvm::LazyMachineBlockFrequencyInfoPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBranchProbabilityInfo::ID);
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::LazyMachineBlockFrequencyInfoPass::calculateIfNotAvailable(llvm::LazyMachineBlockFrequencyInfoPass *this)
{
  uint64_t AnalysisIfAvailable;
  uint64_t result;
  void **v4;
  void *v5;
  const llvm::MachineBranchProbabilityInfo *v6;
  uint64_t v7;
  const llvm::MachineLoopInfo *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  llvm::MachineDominatorTree *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  llvm::MachineLoopInfo *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  llvm::MachineBlockFrequencyInfo *v21;
  llvm::MachineBlockFrequencyInfo *v22;
  uint64_t v23;

  AnalysisIfAvailable = llvm::AnalysisResolver::getAnalysisIfAvailable(*((llvm::PMDataManager ***)this + 1), &llvm::MachineBlockFrequencyInfo::ID);
  if (AnalysisIfAvailable)
  {
    result = (*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)AnalysisIfAvailable + 96))(AnalysisIfAvailable, &llvm::MachineBlockFrequencyInfo::ID);
    if (result)
      return result;
  }
  v4 = (void **)**((_QWORD **)this + 1);
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != &llvm::MachineBranchProbabilityInfo::ID);
  v6 = (const llvm::MachineBranchProbabilityInfo *)(*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v4 - 1)
                                                                                             + 96))(*(v4 - 1), &llvm::MachineBranchProbabilityInfo::ID);
  v7 = llvm::AnalysisResolver::getAnalysisIfAvailable(*((llvm::PMDataManager ***)this + 1), &llvm::MachineLoopInfo::ID);
  if (v7)
    v8 = (const llvm::MachineLoopInfo *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v7 + 96))(v7, &llvm::MachineLoopInfo::ID);
  else
    v8 = 0;
  v9 = llvm::AnalysisResolver::getAnalysisIfAvailable(*((llvm::PMDataManager ***)this + 1), &llvm::MachineDominatorTree::ID);
  if (v9)
  {
    v10 = (*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v9 + 96))(v9, &llvm::MachineDominatorTree::ID);
    if (!v8)
    {
      v11 = v10;
      if (v10)
      {
LABEL_16:
        v16 = (llvm::MachineLoopInfo *)operator new();
        v17 = llvm::MachineLoopInfo::MachineLoopInfo(v16);
        v18 = *((_QWORD *)this + 32);
        *((_QWORD *)this + 32) = v17;
        if (v18)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
          v17 = *((_QWORD *)this + 32);
        }
        v19 = v17 + 248;
        v20 = sub_1C50F0988(v11);
        llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::analyze(v19, v20);
        v8 = (const llvm::MachineLoopInfo *)*((_QWORD *)this + 32);
        goto LABEL_19;
      }
LABEL_13:
      v12 = (llvm::MachineDominatorTree *)operator new();
      v13 = llvm::MachineDominatorTree::MachineDominatorTree(v12);
      v14 = *((_QWORD *)this + 33);
      *((_QWORD *)this + 33) = v13;
      if (v14)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
        v13 = *((_QWORD *)this + 33);
      }
      v15 = sub_1C50F0988(v13);
      *(_QWORD *)(v15 + 56) = *((_QWORD *)this + 34);
      sub_1C50F0A2C(v15, 0);
      v11 = *((_QWORD *)this + 33);
      goto LABEL_16;
    }
  }
  else if (!v8)
  {
    goto LABEL_13;
  }
LABEL_19:
  v21 = (llvm::MachineBlockFrequencyInfo *)operator new();
  v22 = (llvm::MachineBlockFrequencyInfo *)llvm::MachineBlockFrequencyInfo::MachineBlockFrequencyInfo(v21);
  v23 = *((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = v22;
  if (v23)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
    v22 = (llvm::MachineBlockFrequencyInfo *)*((_QWORD *)this + 31);
  }
  llvm::MachineBlockFrequencyInfo::calculate(v22, *((const llvm::MachineFunction **)this + 34), v6, v8);
  return *((_QWORD *)this + 31);
}

void sub_1C61E0B18(llvm::Pass *a1)
{
  sub_1C61E0B64(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::LazyMachineBlockFrequencyInfoPass *llvm::callDefaultCtor<llvm::LazyMachineBlockFrequencyInfoPass>()
{
  llvm::LazyMachineBlockFrequencyInfoPass *v0;

  v0 = (llvm::LazyMachineBlockFrequencyInfoPass *)operator new();
  return llvm::LazyMachineBlockFrequencyInfoPass::LazyMachineBlockFrequencyInfoPass(v0);
}

void sub_1C61E0B64(llvm::Pass *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  llvm::Pass *v4;
  llvm::Pass *v5;
  llvm::Pass *v6;

  *(_QWORD *)a1 = &off_1E8143158;
  v1 = *((_QWORD *)a1 + 33);
  *((_QWORD *)a1 + 33) = 0;
  if (v1)
  {
    v4 = a1;
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
    a1 = v4;
  }
  v2 = *((_QWORD *)a1 + 32);
  *((_QWORD *)a1 + 32) = 0;
  if (v2)
  {
    v5 = a1;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    a1 = v5;
  }
  v3 = *((_QWORD *)a1 + 31);
  *((_QWORD *)a1 + 31) = 0;
  if (v3)
  {
    v6 = a1;
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    sub_1C4926674(v6);
  }
  else
  {
    sub_1C4926674(a1);
  }
}

uint64_t sub_1C61E0C00(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1C61E0C58(a1, (_DWORD *)a2);
    sub_1C61E0C58(a1 + 296, (_DWORD *)(a2 + 296));
  }
  *(_BYTE *)(a1 + 592) = *(_BYTE *)(a2 + 592);
  sub_1C614EBE4(a1 + 600, a2 + 600);
  return a1;
}

uint64_t sub_1C61E0C58(uint64_t a1, _DWORD *a2)
{
  int v4;
  uint64_t v5;

  sub_1C61E0CF0(a1);
  v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 8), 8);
    v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 | 1;
  if ((*(_BYTE *)a2 & 1) == 0 && a2[4] >= 5u)
  {
    *(_DWORD *)a1 = v4 & 0xFFFFFFFE;
    if ((*a2 & 1) != 0)
      v5 = 4;
    else
      v5 = a2[4];
    *(_QWORD *)(a1 + 8) = operator new(8 * (v5 + 8 * v5), (std::align_val_t)8uLL);
    *(_QWORD *)(a1 + 16) = v5;
  }
  return sub_1C61E0D84(a1, a2);
}

void sub_1C61E0CF0(uint64_t a1)
{
  unsigned int v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t i;
  _QWORD *v5;

  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v2 = (_QWORD *)(a1 + 8);
    v1 = 4;
  }
  else
  {
    v1 = *(_DWORD *)(a1 + 16);
    if (!v1)
      return;
    v2 = *(_QWORD **)(a1 + 8);
  }
  v3 = &v2[9 * v1];
  do
  {
    if ((*v2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      for (i = 0; i != -8; i -= 4)
      {
        v5 = (_QWORD *)v2[i + 5];
        if (&v2[i + 7] != v5)
          free(v5);
      }
    }
    v2 += 9;
  }
  while (v2 != v3);
}

uint64_t sub_1C61E0D84(uint64_t result, _DWORD *a2)
{
  unsigned int *v3;
  unint64_t v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;

  v3 = (unsigned int *)result;
  v4 = 0;
  v5 = *a2 & 0xFFFFFFFE | *(_DWORD *)result & 1;
  *(_DWORD *)result = v5;
  *(_DWORD *)(result + 4) = a2[1];
  v6 = (_QWORD *)(result + 8);
  v7 = a2 + 2;
  while ((v5 & 1) == 0)
  {
    if (v4 >= v3[4])
      return result;
    v8 = (_QWORD *)*v6;
LABEL_6:
    v9 = v7;
    if ((*(_BYTE *)a2 & 1) == 0)
      v9 = (_QWORD *)*v7;
    v8[9 * v4] = v9[9 * v4];
    v5 = *v3;
    if ((*v3 & 1) != 0)
    {
      v11 = v6[9 * v4] | 0x1000;
      v10 = v6;
    }
    else
    {
      v10 = (_QWORD *)*v6;
      v11 = *(_QWORD *)(*v6 + 72 * v4) | 0x1000;
    }
    if (v11 != -4096)
    {
      v12 = v7;
      if ((*(_BYTE *)a2 & 1) == 0)
        v12 = (_QWORD *)*v7;
      v13 = 0;
      v14 = 0;
      v15 = (uint64_t)&v10[9 * v4 + 1];
      v16 = (uint64_t)&v12[9 * v4 + 1];
      do
      {
        v17 = v13;
        result = v15 + 32 * v14;
        v18 = v16 + 32 * v14;
        *(_QWORD *)result = result + 16;
        *(_QWORD *)(result + 8) = 0x200000000;
        if (*(_DWORD *)(v18 + 8))
          result = sub_1C50F1754(result, v18);
        v13 = 1;
        v14 = 1;
      }
      while ((v17 & 1) == 0);
      v5 = *v3;
    }
    ++v4;
  }
  v8 = v6;
  if (v4 < 4)
    goto LABEL_6;
  return result;
}

uint64_t sub_1C61E0EDC(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = a2;
  if (sub_1C61E0F68(a1, &v7, &v6))
    return v6;
  v4 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v5 = 4;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 16);
  }
  return v4 + 72 * v5;
}

uint64_t sub_1C61E0F68(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  v7 = (_QWORD *)(v3 + 72 * v6);
  v8 = *v7;
  if (*a2 == *v7)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 72 * (v13 & v5));
      v8 = *v7;
      if (*a2 == *v7)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

BOOL sub_1C61E1020(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v5 = *a1;
  v11 = 0;
  v12 = a2;
  if (sub_1C4926528(v5, &v12, &v11))
    v6 = v11;
  else
    v6 = *(_QWORD *)v5 + 16 * *(unsigned int *)(v5 + 16);
  v7 = *(_DWORD *)(v6 + 8);
  v8 = *a1;
  v11 = 0;
  v12 = a3;
  if (sub_1C4926528(v8, &v12, &v11))
    v9 = v11;
  else
    v9 = *(_QWORD *)v8 + 16 * *(unsigned int *)(v8 + 16);
  return v7 < *(_DWORD *)(v9 + 8);
}

_QWORD *sub_1C61E10C0(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C50F6534(a1, v7);
  v9 = 0;
  sub_1C4850EC8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

void ***sub_1C61E1170(void ***result, void ***a2, void ***a3)
{
  void ***v4;
  uint64_t v5;
  void **v6;
  uint64_t v7;
  void ***v8;
  _QWORD *v9;
  void **v10;
  void ***v11;
  _QWORD *v12;

  v4 = result;
  result[1] = 0;
  v5 = *((unsigned int *)result + 4);
  if ((_DWORD)v5)
  {
    v6 = *result;
    v7 = 16 * v5;
    do
    {
      *v6 = (void *)-4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    v8 = a2 + 1;
    do
    {
      if (((unint64_t)*(v8 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v12 = 0;
        sub_1C4850EC8((uint64_t *)v4, v8 - 1, &v12);
        v9 = v12;
        *v12 = *(v8 - 1);
        v10 = *v8;
        *v8 = 0;
        v9[1] = v10;
        ++*((_DWORD *)v4 + 2);
        result = sub_1C50F65EC(v8, 0);
      }
      v11 = v8 + 1;
      v8 += 2;
    }
    while (v11 != a3);
  }
  return result;
}

void llvm::initializeLiveDebugVariablesPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F0E0);
  if (v2 != -1)
  {
    v5[0] = sub_1C50F6640;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F0E0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void *sub_1C61E1298(llvm::MachineFunctionPass *a1, llvm::AnalysisUsage *this)
{
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(this, llvm::LiveIntervals::ID);
  *((_BYTE *)this + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(a1, this);
}

uint64_t sub_1C61E12E8(uint64_t a1)
{
  llvm::PassRegistry *v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = (llvm::PassRegistry *)sub_1C4776848(a1, (uint64_t)&unk_1EF8F6EF8);
  *(_QWORD *)v2 = &off_1E8143218;
  *((_QWORD *)v2 + 31) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  v3 = atomic_load(&qword_1ED82F0E0);
  if (v3 != -1)
  {
    v7[0] = sub_1C50F6640;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F0E0, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return a1;
}

void sub_1C61E1380(llvm::Pass *a1)
{
  sub_1C50F9A98(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61E13A4()
{
  uint64_t v0;

  v0 = operator new();
  return sub_1C61E12E8(v0);
}

uint64_t sub_1C61E13CC(uint64_t result, uint64_t a2, uint64_t a3)
{
  _DWORD *v5;
  int v6;
  int v7;
  _DWORD *v8;
  _DWORD *v9;
  int v10;
  _DWORD *v11;
  _DWORD *v12;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_DWORD *)(result + 8);
    v9 = (_DWORD *)(result + 104);
  }
  else
  {
    v7 = *(_DWORD *)(result + 16);
    if (!v7)
      goto LABEL_10;
    v8 = *(_DWORD **)(result + 8);
    v9 = &v8[6 * v7];
  }
  do
  {
    *v8 = -1;
    v8 += 6;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      v12 = 0;
      result = sub_1C51014A4((uint64_t)v5, v10, &v12);
      v11 = v12;
      *v12 = *(_DWORD *)a2;
      *(_OWORD *)(v11 + 2) = *(_OWORD *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 24;
  }
  return result;
}

_DWORD *sub_1C61E148C(_DWORD *a1, int *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C61E1500((uint64_t)a1, *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61E15B4(a1, a2, v7);
    *v5 = *a2;
    *((_QWORD *)v5 + 1) = v5 + 6;
    *((_QWORD *)v5 + 2) = 0x400000000;
  }
  return v5;
}

uint64_t sub_1C61E1500(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  int v8;
  uint64_t result;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & (37 * a2);
  v7 = (_DWORD *)(v3 + 88 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -1)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -2;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_DWORD *)(v3 + 88 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_DWORD *sub_1C61E15B4(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 4;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C51018DC((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61E1500((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -1)
    --a1[1];
  return a3;
}

void sub_1C61E1670(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int v6;
  int v7;
  _DWORD *v8;
  _DWORD *v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  void *v13;
  _DWORD *v14;

  v4 = a2;
  v6 = *(_DWORD *)a1;
  *(_QWORD *)a1 = *(_DWORD *)a1 & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_DWORD *)(a1 + 8);
    v9 = (_DWORD *)(a1 + 360);
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 16);
    if (!v7)
      goto LABEL_6;
    v8 = *(_DWORD **)(a1 + 8);
    v9 = &v8[22 * v7];
  }
  do
  {
    *v8 = -1;
    v8 += 22;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      v10 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        v14 = 0;
        sub_1C61E1500(a1, v10, &v14);
        v11 = v14;
        *v14 = *(_DWORD *)v4;
        *((_QWORD *)v11 + 2) = 0x400000000;
        *((_QWORD *)v11 + 1) = v11 + 6;
        v12 = (uint64_t)(v11 + 2);
        if (*(_DWORD *)(v4 + 16))
          sub_1C486F510(v12, v4 + 8);
        *(_DWORD *)a1 += 2;
        v13 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v13)
          free(v13);
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
}

void sub_1C61E1774(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  void *v4;

  v1 = a1[4];
  if ((_DWORD)v1)
  {
    v2 = 32 * v1;
    v3 = (_QWORD *)(*(_QWORD *)a1 + 16);
    do
    {
      if (*((_DWORD *)v3 - 4) <= 0xFFFFFFFD)
      {
        v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

uint64_t sub_1C61E17CC(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    v6 = (_QWORD *)(a1 + 16 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v10 = 1;
    }
    else
    {
      v8 = 0;
      v9 = 1;
      while (v7 != -4096)
      {
        if (v8)
          v12 = 0;
        else
          v12 = v7 == -8192;
        if (v12)
          v8 = v6;
        v13 = v5 + v9++;
        v5 = v13 & v4;
        v6 = (_QWORD *)(a1 + 16 * (v13 & v4));
        v7 = *v6;
        v10 = 1;
        if (*v6 == a3)
          goto LABEL_9;
      }
      v10 = 0;
      if (v8)
        v6 = v8;
    }
  }
  else
  {
    v6 = 0;
    v10 = 0;
  }
LABEL_9:
  *a4 = v6;
  return v10;
}

_QWORD *sub_1C61E1860(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4F763D4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61E18C4(a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C61E18C4(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C5102D50(a1, v6);
  v8 = 0;
  sub_1C4F763D4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61E1978(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C4F763D4(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      v10 = v11;
      *v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

void sub_1C61E1A2C(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F93A0, 0, 0);
  byte_1ED7F9420 = 0;
  qword_1ED7F9428 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7F9430 = 0;
  qword_1ED7F93A0 = (uint64_t)&unk_1E819E898;
  qword_1ED7F9438 = (uint64_t)&off_1E819E9A0;
  qword_1ED7F9440 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7F9458 = (uint64_t)&qword_1ED7F9440;
  sub_1C510320C(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F93A0);
}

void *llvm::LiveIntervals::getAnalysisUsage(llvm::LiveIntervals *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::setPreservesCFG(a2);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AAResultsWrapperPass::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::LiveVariables::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::MachineLoopInfo::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::MachineDominatorTree::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MachineDominatorTree::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::SlotIndexes::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::SlotIndexes::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

llvm::LiveIntervals *llvm::LiveIntervals::LiveIntervals(llvm::LiveIntervals *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848((uint64_t)this, (uint64_t)llvm::LiveIntervals::ID);
  *(_QWORD *)v2 = &off_1E81432E0;
  *(_OWORD *)(v2 + 296) = 0u;
  *(_OWORD *)(v2 + 312) = 0u;
  *(_QWORD *)(v2 + 328) = v2 + 344;
  *(_QWORD *)(v2 + 336) = 0x400000000;
  *(_QWORD *)(v2 + 376) = v2 + 392;
  *(_QWORD *)(v2 + 384) = 0;
  *(_QWORD *)(v2 + 392) = 0;
  *(_QWORD *)(v2 + 400) = 1;
  *(_QWORD *)(v2 + 416) = 0;
  *(_QWORD *)(v2 + 424) = 0;
  *(_QWORD *)(v2 + 408) = v2 + 424;
  *(_QWORD *)(v2 + 440) = v2 + 456;
  *(_QWORD *)(v2 + 448) = 0x800000000;
  *(_QWORD *)(v2 + 520) = v2 + 536;
  *(_QWORD *)(v2 + 528) = 0x800000000;
  *(_QWORD *)(v2 + 600) = v2 + 616;
  *(_QWORD *)(v2 + 608) = 0x800000000;
  *(_QWORD *)(v2 + 680) = v2 + 696;
  *(_QWORD *)(v2 + 688) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED82F0E8);
  if (v3 != -1)
  {
    v7[0] = sub_1C510335C;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F0E8, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::LiveIntervals::~LiveIntervals(llvm::LiveIntervals *this)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;

  *(_QWORD *)this = &off_1E81432E0;
  v2 = *((_QWORD *)this + 38);
  if (v2)
  {
    v3 = sub_1C5109060(v2);
    MEMORY[0x1CAA32FC0](v3, 0x10E0C40F11850D9);
  }
  v4 = (char *)*((_QWORD *)this + 85);
  if (v4 != (char *)this + 696)
    free(v4);
  v5 = (char *)*((_QWORD *)this + 75);
  if (v5 != (char *)this + 616)
    free(v5);
  v6 = (char *)*((_QWORD *)this + 65);
  if (v6 != (char *)this + 536)
    free(v6);
  v7 = (char *)*((_QWORD *)this + 55);
  if (v7 != (char *)this + 456)
    free(v7);
  v8 = (char *)*((_QWORD *)this + 51);
  if (v8 != (char *)this + 424)
    free(v8);
  sub_1C4926AE8((uint64_t)this + 312);
  sub_1C4926674(this);
}

{
  llvm::LiveIntervals::~LiveIntervals(this);
  JUMPOUT(0x1CAA32FC0);
}

void llvm::LiveIntervals::print(llvm::LiveIntervals *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v5;
  uint64_t i;
  uint64_t **v7;
  _BYTE *v8;
  llvm::raw_ostream *v9;
  _BYTE *v10;
  void (**v11)(void);
  int v12;
  int j;
  llvm::LiveInterval *v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  llvm::raw_ostream *v21;
  _BYTE *v22;
  _QWORD v23[3];
  _QWORD *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  sub_1C4816AD8(a2, "********** INTERVALS **********\n");
  v5 = *((unsigned int *)this + 172);
  if ((_DWORD)v5)
  {
    for (i = 0; v5 != i; ++i)
    {
      v7 = *(uint64_t ***)(*((_QWORD *)this + 85) + 8 * i);
      if (v7)
      {
        llvm::printRegUnit(i, *((_QWORD *)this + 33), v23);
        if (!v24)
          sub_1C485C2F0();
        (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v24 + 48))(v24, a2);
        v8 = (_BYTE *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v8 >= *((_QWORD *)a2 + 3))
        {
          v9 = llvm::raw_ostream::write(a2, 32);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v8 + 1;
          *v8 = 32;
          v9 = a2;
        }
        llvm::LiveRange::print(v7, v9);
        v10 = (_BYTE *)*((_QWORD *)v9 + 4);
        if ((unint64_t)v10 >= *((_QWORD *)v9 + 3))
        {
          llvm::raw_ostream::write(v9, 10);
        }
        else
        {
          *((_QWORD *)v9 + 4) = v10 + 1;
          *v10 = 10;
        }
        if (v24 == v23)
        {
          v11 = (void (**)(void))(v23[0] + 32);
          goto LABEL_14;
        }
        if (v24)
        {
          v11 = (void (**)(void))(*v24 + 40);
LABEL_14:
          (*v11)();
        }
      }
    }
  }
  v12 = *(_DWORD *)(*((_QWORD *)this + 32) + 32);
  if (v12)
  {
    for (j = 0; j != v12; ++j)
    {
      if ((j & 0x7FFFFFFFu) < (unint64_t)*((unsigned int *)this + 104)
        && *(_QWORD *)(*((_QWORD *)this + 51) + 8 * (j & 0x7FFFFFFF)))
      {
        v14 = sub_1C5104FB8((uint64_t)this, j | 0x80000000);
        llvm::LiveInterval::print(v14, a2);
        v15 = (_BYTE *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v15 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, 10);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v15 + 1;
          *v15 = 10;
        }
      }
    }
  }
  sub_1C4816AD8(a2, "RegMasks:");
  v16 = *((unsigned int *)this + 112);
  if ((_DWORD)v16)
  {
    v17 = (uint64_t *)*((_QWORD *)this + 55);
    v18 = 8 * v16;
    do
    {
      v19 = *v17;
      v20 = (_BYTE *)*((_QWORD *)a2 + 4);
      if ((unint64_t)v20 >= *((_QWORD *)a2 + 3))
      {
        v21 = llvm::raw_ostream::write(a2, 32);
      }
      else
      {
        *((_QWORD *)a2 + 4) = v20 + 1;
        *v20 = 32;
        v21 = a2;
      }
      v23[0] = v19;
      llvm::SlotIndex::print((llvm::SlotIndex *)v23, v21);
      ++v17;
      v18 -= 8;
    }
    while (v18);
  }
  v22 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v22 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v22 + 1;
    *v22 = 10;
  }
  sub_1C4816AD8(a2, "********** MACHINEINSTRS **********\n");
  llvm::MachineFunction::print(*((llvm::Value ***)this + 31), a2, *((const llvm::SlotIndexes **)this + 36));
}

void llvm::LiveIntervals::dumpInstrs(llvm::LiveIntervals *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  sub_1C4816AD8(v2, "********** MACHINEINSTRS **********\n");
  llvm::MachineFunction::print(*((llvm::Value ***)this + 31), v2, *((const llvm::SlotIndexes **)this + 36));
}

float llvm::LiveIntervals::getSpillWeight(llvm::LiveIntervals *this, unsigned int a2, llvm::MachineBlockFrequencyInfo *a3, const llvm::MachineBlockFrequencyInfo *a4, const llvm::MachineBasicBlock *a5, float a6)
{
  unsigned int v9;
  unint64_t BlockFreq;
  uint64_t v11;
  float v12;

  v9 = this;
  BlockFreq = llvm::MachineBlockFrequencyInfo::getBlockFreq(a3, a4);
  v11 = *((_QWORD *)a3 + 31);
  if (v11)
    v12 = (float)*(unint64_t *)(*(_QWORD *)(v11 + 8) + 16);
  else
    v12 = 0.0;
  return (float)((float)a2 + (float)((float)v9 * a6)) * (float)((float)(1.0 / v12) * (float)BlockFreq);
}

uint64_t llvm::LiveIntervals::addSegmentToEndOfBlock@<X0>(uint64_t a1@<X0>, int a2@<W1>, unint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __int128 v13;
  unint64_t v14;

  v7 = sub_1C4851220(a1, a2);
  v8 = sub_1C4A07EAC(*(_QWORD *)(a1 + 288), a3, 0);
  v9 = sub_1C5107228(v7, v8 & 0xFFFFFFFFFFFFFFF8 | 4, a1 + 312);
  v10 = sub_1C4A07EAC(*(_QWORD *)(a1 + 288), a3, 0);
  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 288) + 392)
                  + 16 * *(unsigned int *)(*(_QWORD *)(a3 + 24) + 24)
                  + 8);
  *a4 = v10 & 0xFFFFFFFFFFFFFFF8 | 4;
  a4[1] = v11;
  a4[2] = v9;
  v14 = v9;
  v13 = *(_OWORD *)a4;
  return llvm::LiveRange::addSegment(v7, (uint64_t)&v13);
}

uint64_t llvm::LiveIntervals::repairOldRegInRange(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t result;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[3];
  _QWORD v42[3];

  result = llvm::LiveRange::find((uint64_t *)a5, a4);
  v15 = result;
  v38 = (_QWORD *)a5;
  if (result == *(_QWORD *)a5 + 24 * *(unsigned int *)(a5 + 8)
    || ((*(_QWORD *)result >> 1) & 3 | *(_DWORD *)((*(_QWORD *)result & 0xFFFFFFFFFFFFFFF8) + 24)) >= (*(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3))
  {
    v16 = 0;
    if (result == *(_QWORD *)a5)
      v17 = 0;
    else
      v17 = -1;
    v15 = result + 24 * v17;
  }
  else
  {
    v16 = *(_QWORD *)(result + 8);
  }
  if (a3 != a2)
  {
    v35 = a7;
    v36 = a1 + 312;
    while (1)
    {
      a3 = *(_QWORD *)a3 & 0xFFFFFFFFFFFFFFF8;
      if (!a3 || (*(_BYTE *)a3 & 4) == 0)
      {
        while ((*(_WORD *)(a3 + 44) & 4) != 0)
          a3 = *(_QWORD *)a3 & 0xFFFFFFFFFFFFFFF8;
      }
      v18 = **(unsigned __int16 **)(a3 + 16);
      if ((v18 - 13) >= 5 && v18 != 23)
      {
        result = sub_1C4A07EAC(*(_QWORD *)(a1 + 288), a3, 0);
        v20 = *(_QWORD *)v15 < 8uLL ? 0 : *(_QWORD *)((*(_QWORD *)v15 & 0xFFFFFFFFFFFFFFF8) + 16);
        v21 = *(_QWORD *)(v15 + 8);
        v22 = v21 < 8 ? 0 : *(_QWORD *)((v21 & 0xFFFFFFFFFFFFFFF8) + 16);
        v23 = *(unsigned int *)(a3 + 40);
        if ((_DWORD)v23)
          break;
      }
LABEL_20:
      if (a3 == a2)
        goto LABEL_59;
    }
    v24 = *(unsigned int **)(a3 + 32);
    v37 = result & 0xFFFFFFFFFFFFFFF8;
    v25 = result & 0xFFFFFFFFFFFFFFF8 | 4;
    v26 = 32 * v23;
    v39 = v22;
    v40 = v20;
    while (1)
    {
      v27 = *v24;
      if (!*v24
        && v24[1] == a6
        && (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 264) + 232) + 8 * ((v27 >> 8) & 0xFFF)) & a7) != 0)
      {
        if ((v27 & 0x1000000) != 0)
        {
          if (v20)
            goto LABEL_41;
          if ((~*(_DWORD *)(v15 + 8) & 6) != 0)
          {
            *(_QWORD *)v15 = v25;
            *(_QWORD *)(*(_QWORD *)(v15 + 16) + 8) = v25;
          }
          else
          {
            result = (uint64_t)llvm::LiveRange::removeSegment((uint64_t)v38, (char *)v15, 1);
            v22 = v39;
            v20 = v40;
            a7 = v35;
            if (v15 == *v38)
              v33 = 0;
            else
              v33 = -1;
            v15 += 24 * v33;
LABEL_41:
            if (v16 <= 7)
            {
              v29 = (uint64_t)v38;
              v31 = sub_1C5107228((uint64_t)v38, v25, v36);
              v42[0] = v25;
              v42[1] = v37 | 6;
              v42[2] = v31;
              v30 = v42;
LABEL_45:
              result = llvm::LiveRange::addSegment(v29, (uint64_t)v30);
              v15 = result;
              v22 = v39;
              v20 = v40;
            }
            else if (*(_QWORD *)v15 != v25)
            {
              v28 = sub_1C5107228((uint64_t)v38, v25, v36);
              v41[0] = v25;
              v41[1] = v16;
              v29 = (uint64_t)v38;
              a7 = v35;
              v41[2] = v28;
              v30 = v41;
              goto LABEL_45;
            }
          }
          v32 = (*v24 >> 28) & 1;
          if ((*v24 & 0xFFF00) == 0)
            v32 = 1;
          if (v32)
            v16 = 0;
          else
            v16 = v25;
          goto LABEL_31;
        }
        if (!v22 && (*(_BYTE *)(v15 + 8) & 6) != 0)
          *(_QWORD *)(v15 + 8) = v25;
        if (v16 <= 7)
          v16 = v25;
      }
LABEL_31:
      v24 += 8;
      v26 -= 32;
      if (!v26)
        goto LABEL_20;
    }
  }
LABEL_59:
  v34 = *(_QWORD *)v15;
  if ((*(_QWORD *)v15 < 8uLL || !*(_QWORD *)((v34 & 0xFFFFFFFFFFFFFFF8) + 16)) && (~*(_DWORD *)(v15 + 8) & 6) == 0)
    return (uint64_t)llvm::LiveRange::removeSegment((uint64_t)v38, v34, *(_QWORD *)(v15 + 8), 1);
  return result;
}

_QWORD *llvm::LiveIntervals::removePhysRegDefAt(_QWORD *result, unsigned int a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  _WORD *v8;
  unsigned __int16 *v9;
  __int16 v10;
  unsigned __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v4 = result;
  v5 = result[33];
  if (v5)
    v6 = (_QWORD *)(v5 + 8);
  else
    v6 = 0;
  v7 = *(unsigned int *)(*v6 + 24 * a2 + 16);
  v8 = (_WORD *)(v6[6] + ((v7 >> 3) & 0x1FFFFFFE));
  v10 = *v8;
  v9 = v8 + 1;
  v11 = v10 + (v7 & 0xF) * a2;
  do
  {
    v12 = v4[85];
    v13 = *(_QWORD *)(v12 + 8 * v11);
    if (v13)
    {
      result = sub_1C5109144(*(_QWORD *)(v12 + 8 * v11), a3);
      if (result != (_QWORD *)(*(_QWORD *)v13 + 24 * *(unsigned int *)(v13 + 8)))
      {
        v14 = result[2];
        if (v14)
          result = llvm::LiveRange::removeValNo((uint64_t *)v13, v14);
      }
    }
    v15 = *v9++;
    v11 += v15;
  }
  while (v15);
  return result;
}

llvm::LiveIntervals *llvm::callDefaultCtor<llvm::LiveIntervals>()
{
  llvm::LiveIntervals *v0;

  v0 = (llvm::LiveIntervals *)operator new();
  return llvm::LiveIntervals::LiveIntervals(v0);
}

_QWORD *sub_1C61E25A8(_QWORD *result)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;

  v1 = *(unint64_t **)(*result + 440);
  v2 = *(unsigned int *)(*result + 448);
  if ((_DWORD)v2)
  {
    do
    {
      v3 = v2 >> 1;
      v4 = &v1[v2 >> 1];
      v6 = *v4;
      v5 = v4 + 1;
      v2 += ~(v2 >> 1);
      if (((v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24)) < ((result[3] >> 1) & 3 | *(_DWORD *)((result[3] & 0xFFFFFFFFFFFFFFF8) + 24)))
        v1 = v5;
      else
        v2 = v3;
    }
    while (v2);
  }
  *v1 = result[4] & 0xFFFFFFFFFFFFFFF8 | 4;
  return result;
}

llvm::raw_ostream *llvm::LiveRange::Segment::dump(llvm::LiveRange::Segment *this)
{
  llvm *v2;
  llvm::raw_ostream *result;
  _BYTE *v4;

  v2 = llvm::dbgs(this);
  result = llvm::operator<<(v2, (uint64_t *)this);
  v4 = (_BYTE *)*((_QWORD *)result + 4);
  if ((unint64_t)v4 >= *((_QWORD *)result + 3))
    return llvm::raw_ostream::write(result, 10);
  *((_QWORD *)result + 4) = v4 + 1;
  *v4 = 10;
  return result;
}

llvm::raw_ostream *llvm::LiveRange::print(uint64_t **this, llvm::raw_ostream *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  llvm::raw_ostream *result;
  _BYTE *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  _BYTE *v15;
  _BYTE *v16;
  uint64_t v17;

  v4 = *((unsigned int *)this + 2);
  if ((_DWORD)v4)
  {
    v5 = *this;
    v6 = 24 * v4;
    do
    {
      result = llvm::operator<<(a2, v5);
      v5 += 3;
      v6 -= 24;
    }
    while (v6);
  }
  else
  {
    result = sub_1C4816AD8(a2, "EMPTY");
  }
  if (*((_DWORD *)this + 18))
  {
    v8 = (_BYTE *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v8 >= *((_QWORD *)a2 + 3))
    {
      result = llvm::raw_ostream::write(a2, 32);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v8 + 1;
      *v8 = 32;
    }
    v9 = *((unsigned int *)this + 18);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = this[8];
      v12 = 8 * v9;
      do
      {
        v13 = v11[v10];
        if (v10)
        {
          v14 = (_BYTE *)*((_QWORD *)a2 + 4);
          if ((unint64_t)v14 >= *((_QWORD *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 32);
          }
          else
          {
            *((_QWORD *)a2 + 4) = v14 + 1;
            *v14 = 32;
          }
        }
        result = llvm::raw_ostream::operator<<(a2, v10);
        v15 = (_BYTE *)*((_QWORD *)result + 4);
        if ((unint64_t)v15 >= *((_QWORD *)result + 3))
        {
          result = llvm::raw_ostream::write(result, 64);
        }
        else
        {
          *((_QWORD *)result + 4) = v15 + 1;
          *v15 = 64;
        }
        if (*(_QWORD *)(v13 + 8) > 7uLL)
        {
          v17 = *(_QWORD *)(v13 + 8);
          result = llvm::SlotIndex::print((llvm::SlotIndex *)&v17, a2);
          if ((*(_BYTE *)(v13 + 8) & 6) == 0)
            result = sub_1C4816AD8(a2, "-phi");
        }
        else
        {
          v16 = (_BYTE *)*((_QWORD *)a2 + 4);
          if ((unint64_t)v16 >= *((_QWORD *)a2 + 3))
          {
            result = llvm::raw_ostream::write(a2, 120);
          }
          else
          {
            *((_QWORD *)a2 + 4) = v16 + 1;
            *v16 = 120;
          }
        }
        ++v10;
        v12 -= 8;
      }
      while (v12);
    }
  }
  return result;
}

_QWORD *llvm::LiveInterval::SubRange::print(llvm::LiveInterval::SubRange *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v3;
  uint64_t v4;
  _BYTE *v5;
  _QWORD *result;
  uint64_t (**v7)(void);
  _QWORD v8[3];
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = sub_1C4816AD8(a2, "  L");
  v4 = *((_QWORD *)this + 14);
  v10 = v9;
  v9[0] = &off_1E81433A0;
  v9[1] = v4;
  v8[0] = &unk_1E8133270;
  v8[1] = "%016llX";
  v8[2] = v4;
  llvm::raw_ostream::operator<<(v3, (uint64_t)v8);
  v5 = (_BYTE *)*((_QWORD *)v3 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v3 + 3))
  {
    v3 = llvm::raw_ostream::write(v3, 32);
  }
  else
  {
    *((_QWORD *)v3 + 4) = v5 + 1;
    *v5 = 32;
  }
  llvm::LiveRange::print((uint64_t **)this, v3);
  result = v10;
  if (v10 == v9)
  {
    v7 = (uint64_t (**)(void))(v9[0] + 32);
  }
  else
  {
    if (!v10)
      return result;
    v7 = (uint64_t (**)(void))(*v10 + 40);
  }
  return (_QWORD *)(*v7)();
}

llvm::raw_ostream *llvm::LiveInterval::print(llvm::LiveInterval *this, llvm::raw_ostream *a2)
{
  _BYTE *v4;
  _QWORD *v5;
  void (**v6)(_QWORD *);
  llvm::LiveInterval::SubRange *i;
  llvm::raw_ostream *v8;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  llvm::printReg(*((_DWORD *)this + 28), 0, 0, 0, (uint64_t)v10);
  if (!v11)
    sub_1C485C2F0();
  (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v11 + 48))(v11, a2);
  v4 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v4 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 32);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v4 + 1;
    *v4 = 32;
  }
  v5 = v11;
  if (v11 == v10)
  {
    v6 = (void (**)(_QWORD *))(v10[0] + 32);
    v5 = v10;
LABEL_7:
    (*v6)(v5);
    goto LABEL_8;
  }
  if (v11)
  {
    v6 = (void (**)(_QWORD *))(*v11 + 40);
    goto LABEL_7;
  }
LABEL_8:
  llvm::LiveRange::print((uint64_t **)this, a2);
  for (i = (llvm::LiveInterval::SubRange *)*((_QWORD *)this + 13);
        i;
        i = (llvm::LiveInterval::SubRange *)*((_QWORD *)i + 13))
  {
    llvm::LiveInterval::SubRange::print(i, a2);
  }
  v8 = sub_1C4816AD8(a2, "  weight:");
  return llvm::raw_ostream::operator<<(v8, *((float *)this + 29));
}

llvm::raw_ostream *llvm::LiveRange::dump(llvm::LiveRange *this)
{
  llvm *v2;
  llvm::raw_ostream *result;
  _BYTE *v4;

  v2 = llvm::dbgs(this);
  result = llvm::LiveRange::print((uint64_t **)this, v2);
  v4 = (_BYTE *)*((_QWORD *)v2 + 4);
  if ((unint64_t)v4 >= *((_QWORD *)v2 + 3))
    return llvm::raw_ostream::write(v2, 10);
  *((_QWORD *)v2 + 4) = v4 + 1;
  *v4 = 10;
  return result;
}

llvm::raw_ostream *llvm::LiveInterval::SubRange::dump(llvm::LiveInterval::SubRange *this)
{
  llvm *v2;
  llvm::raw_ostream *result;
  _BYTE *v4;

  v2 = llvm::dbgs(this);
  result = (llvm::raw_ostream *)llvm::LiveInterval::SubRange::print(this, v2);
  v4 = (_BYTE *)*((_QWORD *)v2 + 4);
  if ((unint64_t)v4 >= *((_QWORD *)v2 + 3))
    return llvm::raw_ostream::write(v2, 10);
  *((_QWORD *)v2 + 4) = v4 + 1;
  *v4 = 10;
  return result;
}

llvm::raw_ostream *llvm::LiveInterval::dump(llvm::LiveInterval *this)
{
  llvm *v2;
  llvm::raw_ostream *result;
  _BYTE *v4;

  v2 = llvm::dbgs(this);
  result = llvm::LiveInterval::print(this, v2);
  v4 = (_BYTE *)*((_QWORD *)v2 + 4);
  if ((unint64_t)v4 >= *((_QWORD *)v2 + 3))
    return llvm::raw_ostream::write(v2, 10);
  *((_QWORD *)v2 + 4) = v4 + 1;
  *v4 = 10;
  return result;
}

llvm::raw_ostream *llvm::LiveRangeUpdater::print(uint64_t ***this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v2;
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  llvm::raw_ostream *v6;
  uint64_t *v7;
  uint64_t *i;
  _BYTE *v9;
  llvm::raw_ostream *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  llvm::raw_ostream *v15;
  llvm::raw_ostream *result;
  uint64_t *v17;
  uint64_t j;
  _BYTE *v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  uint64_t **v22;

  v2 = a2;
  if ((unint64_t)this[1] <= 7)
  {
    if (!*this)
      return sub_1C4816AD8(a2, "Null updater.\n");
    v2 = sub_1C4816AD8(a2, "Clean updater: ");
    result = llvm::LiveRange::print(*this, v2);
    v21 = (_BYTE *)*((_QWORD *)v2 + 4);
    if ((unint64_t)v21 >= *((_QWORD *)v2 + 3))
      return llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    v4 = sub_1C4816AD8(a2, " updater with gap = ");
    v5 = llvm::raw_ostream::operator<<(v4, 0xAAAAAAAAAAAAAAABLL * (this[3] - this[2]));
    v6 = sub_1C4816AD8(v5, ", last start = ");
    v22 = this[1];
    llvm::SlotIndex::print((llvm::SlotIndex *)&v22, v6);
    sub_1C4816AD8(v6, ":\n  Area 1:");
    v7 = **this;
    for (i = (uint64_t *)this[2]; v7 != i; v7 += 3)
    {
      v9 = (_BYTE *)*((_QWORD *)v2 + 4);
      if ((unint64_t)v9 >= *((_QWORD *)v2 + 3))
      {
        v10 = llvm::raw_ostream::write(v2, 32);
      }
      else
      {
        *((_QWORD *)v2 + 4) = v9 + 1;
        *v9 = 32;
        v10 = v2;
      }
      llvm::operator<<(v10, v7);
    }
    sub_1C4816AD8(v2, "\n  Spills:");
    v11 = *((unsigned int *)this + 10);
    if ((_DWORD)v11)
    {
      v12 = 0;
      v13 = 24 * v11;
      do
      {
        v14 = (_BYTE *)*((_QWORD *)v2 + 4);
        if ((unint64_t)v14 >= *((_QWORD *)v2 + 3))
        {
          v15 = llvm::raw_ostream::write(v2, 32);
        }
        else
        {
          *((_QWORD *)v2 + 4) = v14 + 1;
          *v14 = 32;
          v15 = v2;
        }
        llvm::operator<<(v15, (uint64_t *)&this[4][v12 / 8]);
        v12 += 24;
      }
      while (v13 != v12);
    }
    result = sub_1C4816AD8(v2, "\n  Area 2:");
    v17 = (uint64_t *)this[3];
    for (j = (uint64_t)&(**this)[3 * *((unsigned int *)*this + 2)]; v17 != (uint64_t *)j; v17 += 3)
    {
      v19 = (_BYTE *)*((_QWORD *)v2 + 4);
      if ((unint64_t)v19 >= *((_QWORD *)v2 + 3))
      {
        v20 = llvm::raw_ostream::write(v2, 32);
      }
      else
      {
        *((_QWORD *)v2 + 4) = v19 + 1;
        *v19 = 32;
        v20 = v2;
      }
      result = llvm::operator<<(v20, v17);
    }
    v21 = (_BYTE *)*((_QWORD *)v2 + 4);
    if ((unint64_t)v21 >= *((_QWORD *)v2 + 3))
      return llvm::raw_ostream::write(v2, 10);
  }
  *((_QWORD *)v2 + 4) = v21 + 1;
  *v21 = 10;
  return result;
}

llvm::raw_ostream *llvm::LiveRangeUpdater::dump(llvm::LiveRangeUpdater *this)
{
  llvm::raw_ostream *v2;

  v2 = (llvm::raw_ostream *)llvm::errs(this);
  return llvm::LiveRangeUpdater::print((uint64_t ***)this, v2);
}

void sub_1C61E2F48()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61E2F5C(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E81433A0;
  result[1] = v3;
  return result;
}

uint64_t sub_1C61E2F90(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E81433A0;
  a2[1] = v2;
  return result;
}

llvm::raw_ostream *sub_1C61E2FAC(uint64_t a1, llvm::raw_ostream *a2)
{
  uint64_t v2;
  _QWORD v4[3];

  v2 = *(_QWORD *)(a1 + 8);
  v4[0] = &unk_1E8133270;
  v4[1] = "%016llX";
  v4[2] = v2;
  return llvm::raw_ostream::operator<<(a2, (uint64_t)v4);
}

uint64_t sub_1C61E2FF4(uint64_t *a1, unsigned int a2)
{
  _QWORD *v3;
  uint64_t result;
  uint64_t *v5;
  unsigned __int16 v7;
  _DWORD v8[4];
  char v9;
  uint64_t v10;
  unsigned __int16 v11;

  if (*a1)
    v3 = (_QWORD *)(*a1 + 8);
  else
    v3 = 0;
  result = sub_1C48385F4((uint64_t)v8, a2, v3, 1);
  if (v10)
  {
    v5 = a1 + 1;
    do
    {
LABEL_6:
      v7 = v11;
      sub_1C511402C(v5, &v7);
      while (1)
      {
        result = sub_1C48386F0((uint64_t)v8);
        if (v9 || v10 == 0)
          break;
        if (v8[0] != v11)
          goto LABEL_6;
      }
    }
    while (v10);
  }
  return result;
}

uint64_t *sub_1C61E308C(uint64_t *result, unsigned int a2)
{
  _QWORD *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned __int16 *v5;
  uint64_t *v6;
  int v7;
  unsigned __int16 v8;

  v2 = (_QWORD *)(*result + 8);
  if (!*result)
    v2 = 0;
  v3 = v2[6];
  if (v3)
  {
    v4 = a2;
    v5 = (unsigned __int16 *)(v3 + 2 * *(unsigned int *)(*v2 + 24 * a2 + 4));
    v6 = result + 1;
    do
    {
      v8 = v4;
      result = (uint64_t *)sub_1C61DF708(v6, &v8);
      v7 = *v5++;
      v4 += v7;
    }
    while (v7);
  }
  return result;
}

_QWORD *llvm::LivePhysRegs::stepBackward(llvm::LivePhysRegs *this, const llvm::MachineInstr *a2)
{
  llvm::LivePhysRegs::removeDefs(this, a2);
  return llvm::LivePhysRegs::addUses(this, a2);
}

llvm::raw_ostream *llvm::LivePhysRegs::print(llvm::LivePhysRegs *this, llvm::raw_ostream *a2)
{
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  int v7;
  llvm::raw_ostream *v8;
  void (**v9)(void);
  char *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  sub_1C4816AD8(a2, "Live Registers:");
  if (*(_QWORD *)this)
  {
    v4 = *((_QWORD *)this + 2);
    if (v4)
    {
      v5 = (unsigned __int16 *)*((_QWORD *)this + 1);
      v6 = 2 * v4;
      while (1)
      {
        v7 = *v5;
        v8 = sub_1C4816AD8(a2, " ");
        llvm::printReg(v7, *(_QWORD *)this, 0, 0, (uint64_t)v12);
        if (!v13)
          sub_1C485C2F0();
        (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v13 + 48))(v13, v8);
        if (v13 == v12)
          break;
        if (v13)
        {
          v9 = (void (**)(void))(*v13 + 40);
LABEL_8:
          (*v9)();
        }
        ++v5;
        v6 -= 2;
        if (!v6)
          return sub_1C4816AD8(a2, "\n");
      }
      v9 = (void (**)(void))(v12[0] + 32);
      goto LABEL_8;
    }
    v11 = " (empty)\n";
  }
  else
  {
    v11 = " (uninitialized)\n";
  }
  return sub_1C4816AD8(a2, v11);
}

llvm::raw_ostream *llvm::LivePhysRegs::dump(llvm::LivePhysRegs *this)
{
  llvm *v2;
  llvm::raw_ostream *v3;

  v2 = llvm::dbgs(this);
  v3 = sub_1C4816AD8(v2, "  ");
  return llvm::LivePhysRegs::print(this, v3);
}

uint64_t llvm::LivePhysRegs::available(llvm::LivePhysRegs *this, const llvm::MachineRegisterInfo *a2, unsigned int a3)
{
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  _DWORD v15[4];
  char v16;
  uint64_t v17;
  unsigned __int16 v18;

  v6 = *(unsigned __int8 *)(*((_QWORD *)this + 6) + a3);
  v7 = *((_QWORD *)this + 2);
  if (v6 < v7)
  {
    while (1)
    {
      v8 = v6;
      if (*(unsigned __int16 *)(*((_QWORD *)this + 1) + 2 * v6) == a3)
        break;
      v6 += 256;
      if (v8 + 256 >= v7)
        goto LABEL_4;
    }
    if (v7 != v6)
      return 0;
  }
LABEL_4:
  if (((*(_QWORD *)(*((_QWORD *)a2 + 44) + (((unint64_t)a3 >> 3) & 0x1FF8)) >> a3) & 1) != 0)
    return 0;
  if (*(_QWORD *)this)
    v10 = (_QWORD *)(*(_QWORD *)this + 8);
  else
    v10 = 0;
  sub_1C48385F4((uint64_t)v15, a3, v10, 0);
  while (v17)
  {
LABEL_11:
    v11 = *(unsigned __int8 *)(*((_QWORD *)this + 6) + v18);
    v12 = *((_QWORD *)this + 2);
    if (v11 >= v12)
      goto LABEL_16;
    do
    {
      v13 = v11;
      if (*(unsigned __int16 *)(*((_QWORD *)this + 1) + 2 * v11) == v18)
      {
        if (v12 == v11)
          break;
        return 0;
      }
      v11 += 256;
    }
    while (v13 + 256 < v12);
LABEL_16:
    while (1)
    {
      sub_1C48386F0((uint64_t)v15);
      if (v16 || v17 == 0)
        break;
      if (v15[0] != v18)
        goto LABEL_11;
    }
  }
  return 1;
}

uint64_t *llvm::LivePhysRegs::addBlockLiveIns(llvm::LivePhysRegs *this, unsigned __int16 **a2)
{
  uint64_t *result;
  unsigned __int16 *v5;
  uint64_t *v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  int v15;

  result = (uint64_t *)llvm::MachineBasicBlock::livein_begin((llvm::MachineBasicBlock *)a2);
  v5 = a2[20];
  if (v5 != (unsigned __int16 *)result)
  {
    v6 = result;
    do
    {
      v7 = *(unsigned __int16 *)v6;
      v8 = v6[1];
      v9 = (_QWORD *)(*(_QWORD *)this + 8);
      if (!*(_QWORD *)this)
        v9 = 0;
      if (v8 == -1
        || (v10 = v9[6], v11 = *(unsigned int *)(*v9 + 24 * *(unsigned __int16 *)v6 + 4), !*(_WORD *)(v10 + 2 * v11)))
      {
        result = sub_1C61E308C((uint64_t *)this, v7);
      }
      else
      {
        v12 = *(_WORD *)(v10 + 2 * v11) + v7;
        v13 = (unsigned __int16 *)(v9[10] + 2 * *(unsigned int *)(*v9 + 24 * *(unsigned __int16 *)v6 + 12));
        v14 = (unsigned __int16 *)(v10 + 2 * v11 + 2);
        do
        {
          if ((*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 232) + 8 * *v13) & v8) != 0)
            result = sub_1C61E308C((uint64_t *)this, v12);
          v15 = *v14++;
          v12 += v15;
          ++v13;
        }
        while (v15);
      }
      v6 += 2;
    }
    while (v6 != (uint64_t *)v5);
  }
  return result;
}

void llvm::LivePhysRegs::addPristines(llvm::LivePhysRegs *this, const llvm::MachineFunction *a2)
{
  uint64_t v2;
  uint64_t v5;
  int v6;
  unsigned __int16 *CalleeSavedRegs;
  unsigned __int16 v8;
  unsigned __int16 *v9;
  int v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned __int16 *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned __int16 *v17;
  unsigned __int16 v18;
  unsigned __int16 *v19;
  int v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  unsigned int v23;
  uint64_t v24;
  void *v25;
  __int128 v26;
  _BYTE v27[16];
  void *v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)a2 + 7);
  if (*(_BYTE *)(v2 + 104))
  {
    if (*((_QWORD *)this + 2))
    {
      v5 = *(_QWORD *)this;
      v24 = v5;
      v25 = v27;
      v26 = xmmword_1C6464ED0;
      v28 = 0;
      v29 = 0;
      v6 = *(_DWORD *)(v5 + 16);
      if (v6)
      {
        v28 = sub_1C5074000(*(unsigned int *)(v5 + 16), 1uLL);
        v29 = v6;
      }
      CalleeSavedRegs = (unsigned __int16 *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*((llvm::MachineRegisterInfo **)a2
                                                                                          + 5));
      if (CalleeSavedRegs)
      {
        v8 = *CalleeSavedRegs;
        if (*CalleeSavedRegs)
        {
          v9 = CalleeSavedRegs + 1;
          do
          {
            sub_1C61E308C(&v24, v8);
            v10 = *v9++;
            v8 = v10;
          }
          while (v10);
        }
      }
      v11 = *(unsigned __int16 **)(v2 + 80);
      v12 = *(unsigned __int16 **)(v2 + 88);
      while (v11 != v12)
      {
        v13 = *v11;
        v11 += 6;
        sub_1C61E2FF4(&v24, v13);
      }
      if ((_QWORD)v26)
      {
        v14 = (unsigned __int16 *)v25;
        v15 = 2 * v26;
        do
        {
          v16 = *v14++;
          sub_1C61E308C((uint64_t *)this, v16);
          v15 -= 2;
        }
        while (v15);
      }
      free(v28);
      if (v25 != v27)
        free(v25);
    }
    else
    {
      v17 = (unsigned __int16 *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*((llvm::MachineRegisterInfo **)a2 + 5));
      if (v17)
      {
        v18 = *v17;
        if (*v17)
        {
          v19 = v17 + 1;
          do
          {
            sub_1C61E308C((uint64_t *)this, v18);
            v20 = *v19++;
            v18 = v20;
          }
          while (v20);
        }
      }
      v21 = *(unsigned __int16 **)(v2 + 80);
      v22 = *(unsigned __int16 **)(v2 + 88);
      while (v21 != v22)
      {
        v23 = *v21;
        v21 += 6;
        sub_1C61E2FF4((uint64_t *)this, v23);
      }
    }
  }
}

uint64_t llvm::LivePhysRegs::addLiveOutsNoPristines(llvm::LivePhysRegs *this, const llvm::MachineBasicBlock *a2)
{
  unsigned __int16 ***v4;
  unsigned __int16 ***v5;
  unsigned __int16 **v6;
  uint64_t result;
  uint64_t v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;

  v4 = (unsigned __int16 ***)*((_QWORD *)a2 + 11);
  v5 = (unsigned __int16 ***)*((_QWORD *)a2 + 12);
  while (v4 != v5)
  {
    v6 = *v4++;
    llvm::LivePhysRegs::addBlockLiveIns(this, v6);
  }
  result = sub_1C498FBAC((uint64_t)a2);
  if ((result & 1) != 0)
  {
    v8 = *(_QWORD *)(*((_QWORD *)a2 + 4) + 56);
    if (*(_BYTE *)(v8 + 104))
    {
      v9 = *(unsigned __int16 **)(v8 + 80);
      v10 = *(unsigned __int16 **)(v8 + 88);
      while (v9 != v10)
      {
        if (*((_BYTE *)v9 + 8))
          result = (uint64_t)sub_1C61E308C((uint64_t *)this, *v9);
        v9 += 6;
      }
    }
  }
  return result;
}

uint64_t llvm::LivePhysRegs::addLiveOuts(llvm::LivePhysRegs *this, const llvm::MachineFunction **a2)
{
  llvm::LivePhysRegs::addPristines(this, a2[4]);
  return llvm::LivePhysRegs::addLiveOutsNoPristines(this, (const llvm::MachineBasicBlock *)a2);
}

_QWORD *llvm::computeLiveIns(llvm *this, llvm::LivePhysRegs *a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *result;
  const llvm::MachineInstr *v8;
  uint64_t v9;
  const llvm::MachineInstr *v10;

  v5 = *(_QWORD *)(**(_QWORD **)(*((_QWORD *)a2 + 4) + 40) + 16);
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 176))(v5);
  *(_QWORD *)this = v6;
  *((_QWORD *)this + 2) = 0;
  sub_1C61D8D14((char *)this + 8, *(_DWORD *)(v6 + 16));
  result = (_QWORD *)llvm::LivePhysRegs::addLiveOutsNoPristines(this, a2);
  v9 = *((_QWORD *)a2 + 6);
  v8 = (llvm::LivePhysRegs *)((char *)a2 + 48);
  v10 = (const llvm::MachineInstr *)(v9 & 0xFFFFFFFFFFFFFFF8);
  if ((v9 & 0xFFFFFFFFFFFFFFF8) == 0 || (*(_BYTE *)v10 & 4) == 0)
  {
    while ((*((_WORD *)v10 + 22) & 4) != 0)
      v10 = (const llvm::MachineInstr *)(*(_QWORD *)v10 & 0xFFFFFFFFFFFFFFF8);
  }
  while (v10 != v8)
  {
    llvm::LivePhysRegs::removeDefs(this, v10);
    result = llvm::LivePhysRegs::addUses(this, v10);
    v10 = (const llvm::MachineInstr *)(*(_QWORD *)v10 & 0xFFFFFFFFFFFFFFF8);
    if (!v10 || (*(_BYTE *)v10 & 4) == 0)
    {
      while ((*((_WORD *)v10 + 22) & 4) != 0)
        v10 = (const llvm::MachineInstr *)(*(_QWORD *)v10 & 0xFFFFFFFFFFFFFFF8);
    }
  }
  return result;
}

_OWORD *llvm::addLiveIns(llvm *this, llvm::MachineBasicBlock *a2, const llvm::LivePhysRegs *a3)
{
  _QWORD *v5;
  _OWORD *result;
  uint64_t v7;
  _WORD *v8;
  _WORD *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  _WORD *v13;
  unsigned __int16 v14;
  uint64_t v15;
  unsigned int i;
  int v17;
  _OWORD *v18;
  __int128 v19;

  v5 = *(_QWORD **)(*((_QWORD *)this + 4) + 40);
  result = (_OWORD *)(*(uint64_t (**)(_QWORD, llvm::MachineBasicBlock *, const llvm::LivePhysRegs *))(**(_QWORD **)(*v5 + 16) + 176))(*(_QWORD *)(*v5 + 16), a2, a3);
  v7 = *((_QWORD *)a2 + 2);
  if (v7)
  {
    v8 = (_WORD *)*((_QWORD *)a2 + 1);
    v9 = &v8[v7];
    if (result)
      v10 = (_QWORD *)result + 1;
    else
      v10 = 0;
    do
    {
      v11 = (unsigned __int16)*v8;
      v12 = v5[44];
      if (((*(_QWORD *)(v12 + ((v11 >> 3) & 0x1FF8)) >> v11) & 1) == 0)
      {
        v13 = (_WORD *)(v10[6] + 2 * *(unsigned int *)(*v10 + 24 * (unsigned __int16)*v8 + 8));
        if (*v13)
        {
          v14 = *v13 + v11;
          v15 = *((_QWORD *)a2 + 2);
          while (2)
          {
            for (i = *(unsigned __int8 *)(*((_QWORD *)a2 + 6) + v14); i < v15; i += 256)
            {
              if (*(unsigned __int16 *)(*((_QWORD *)a2 + 1) + 2 * i) == v14)
              {
                if (v15 != i && ((*(_QWORD *)(v12 + (((unint64_t)v14 >> 3) & 0x1FF8)) >> v14) & 1) == 0)
                  goto LABEL_6;
                break;
              }
            }
            v17 = (unsigned __int16)v13[1];
            ++v13;
            v14 += v17;
            if (v17)
              continue;
            break;
          }
        }
        LOWORD(v19) = *v8;
        *((_QWORD *)&v19 + 1) = -1;
        v18 = (_OWORD *)*((_QWORD *)this + 20);
        if ((unint64_t)v18 >= *((_QWORD *)this + 21))
        {
          result = sub_1C51140B0((void **)this + 19, &v19);
        }
        else
        {
          *v18 = v19;
          result = v18 + 1;
        }
        *((_QWORD *)this + 20) = result;
      }
LABEL_6:
      ++v8;
    }
    while (v8 != v9);
  }
  return result;
}

_OWORD *llvm::computeAndAddLiveIns(llvm *this, llvm::LivePhysRegs *a2, llvm::MachineBasicBlock *a3)
{
  const llvm::LivePhysRegs *v5;

  llvm::computeLiveIns(this, a2, a3);
  return llvm::addLiveIns(a2, this, v5);
}

void sub_1C61E39DC()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61E39F0()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E81433E8;
  return result;
}

void sub_1C61E3A18(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 152 * v6;
    do
    {
      *v7 = -4096;
      v7 += 19;
      v8 -= 152;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v13 = 0;
      sub_1C5115B5C(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      v10 = v13;
      *v13 = *a2;
      sub_1C511586C((uint64_t)(v10 + 1), (uint64_t)(a2 + 1));
      ++*(_DWORD *)(a1 + 8);
      v11 = (uint64_t *)a2[10];
      if (a2 + 12 != v11)
        free(v11);
      v12 = (uint64_t *)a2[1];
      if (a2 + 3 != v12)
        free(v12);
    }
    a2 += 19;
  }
}

void sub_1C61E3B00(_QWORD *a1)
{
  sub_1C61E3B28(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61E3B28(_QWORD *a1)
{
  void *v2;
  void *v3;

  *a1 = &off_1E8143478;
  *(_QWORD *)(a1[3] + 8) = 0;
  v2 = (void *)a1[19];
  if (v2 != (void *)a1[18])
    free(v2);
  v3 = (void *)a1[11];
  if (v3 != (void *)a1[10])
    free(v3);
  return a1;
}

void llvm::initializeLiveRangeShrinkPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F9468);
  if (v2 != -1)
  {
    v5[0] = sub_1C51190EC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F9468, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

unsigned int *sub_1C61E3BE4(unsigned int *result)
{
  uint64_t v1;
  _DWORD *v2;
  uint64_t v3;

  if (*((_QWORD *)result + 1))
  {
    v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if ((_DWORD)v1)
      {
        v2 = *(_DWORD **)result;
        v3 = 24 * v1;
        do
        {
          *v2 = -1;
          v2 += 6;
          v3 -= 24;
        }
        while (v3);
      }
      *((_QWORD *)result + 1) = 0;
    }
    else
    {
      return sub_1C5119CE0(result);
    }
  }
  return result;
}

_QWORD *sub_1C61E3C38(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4926528(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C48BE074(a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

_DWORD *sub_1C61E3C98(uint64_t a1, int *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C61D0CF8(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61D0D94(a1, a2, v7);
    *v5 = *a2;
    v5[2] = 0;
    *((_QWORD *)v5 + 2) = 0;
  }
  return v5;
}

void llvm::initializeLiveRegMatrixPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F1B0);
  if (v2 != -1)
  {
    v5[0] = sub_1C5119EA4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F1B0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

double llvm::LiveRegMatrix::LiveRegMatrix(llvm::LiveRegMatrix *this)
{
  uint64_t v1;
  double result;

  v1 = sub_1C4776848((uint64_t)this, (uint64_t)&llvm::LiveRegMatrix::ID);
  *(_QWORD *)v1 = &off_1E81435B8;
  *(_DWORD *)(v1 + 272) = 0;
  *(_QWORD *)(v1 + 280) = 0;
  *(_QWORD *)(v1 + 288) = 0;
  *(_QWORD *)(v1 + 296) = 0;
  *(_QWORD *)(v1 + 304) = v1 + 320;
  *(_QWORD *)(v1 + 312) = 0x400000000;
  *(_QWORD *)(v1 + 352) = v1 + 368;
  *(_QWORD *)(v1 + 360) = 0;
  *(_QWORD *)(v1 + 368) = 0;
  *(_QWORD *)(v1 + 376) = 1;
  *(_DWORD *)(v1 + 384) = 0;
  *(_QWORD *)(v1 + 392) = 0;
  *(_QWORD *)(v1 + 400) = 0;
  *(_QWORD *)(v1 + 408) = 0;
  *(_QWORD *)(v1 + 416) = v1 + 432;
  *(_QWORD *)&result = 0x600000000;
  *(_QWORD *)(v1 + 424) = 0x600000000;
  *(_DWORD *)(v1 + 480) = 0;
  return result;
}

void *llvm::LiveRegMatrix::getAnalysisUsage(llvm::LiveRegMatrix *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::LiveIntervals::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::VirtRegMap::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void sub_1C61E3E30(_QWORD *a1)
{
  sub_1C61E3E7C(a1);
  JUMPOUT(0x1CAA32FC0);
}

double llvm::callDefaultCtor<llvm::LiveRegMatrix>()
{
  llvm::LiveRegMatrix *v0;

  v0 = (llvm::LiveRegMatrix *)operator new();
  return llvm::LiveRegMatrix::LiveRegMatrix(v0);
}

void sub_1C61E3E7C(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E81435B8;
  v2 = (_QWORD *)a1[52];
  if (v2 != a1 + 54)
    free(v2);
  v3 = a1[50];
  a1[50] = 0;
  if (v3)
    sub_1C4A065F0((uint64_t)(a1 + 50), v3);
  llvm::LiveIntervalUnion::Array::clear((llvm::LiveIntervalUnion::Array *)(a1 + 48));
  a1[35] = 0;
  sub_1C4926AE8((uint64_t)(a1 + 36));
  sub_1C4926674((llvm::Pass *)a1);
}

void llvm::initializeLiveStacksPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F1B8);
  if (v2 != -1)
  {
    v5[0] = sub_1C511C0B0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F1B8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void *llvm::LiveStacks::getAnalysisUsage(llvm::LiveStacks *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::SlotIndexes::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::SlotIndexes::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

llvm::raw_ostream *llvm::LiveStacks::print(llvm::LiveStacks *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  llvm::raw_ostream *result;
  uint64_t *v6;
  char **v7;
  char *v8;
  int v9;
  char **v10;
  int v11;
  BOOL v12;
  char **v13;
  char *v14;
  llvm::raw_ostream *v15;
  llvm::raw_ostream *v16;
  char *v17;

  result = sub_1C4816AD8(a2, "********** INTERVALS **********\n");
  v6 = (uint64_t *)*((_QWORD *)this + 46);
  if (v6)
  {
    v7 = (char **)((char *)this + 400);
    do
    {
      llvm::LiveInterval::print((llvm::LiveInterval *)(v6 + 3), a2);
      v8 = *v7;
      if (!*v7)
        goto LABEL_13;
      v9 = *((_DWORD *)v6 + 4);
      v10 = (char **)((char *)this + 400);
      do
      {
        v11 = *((_DWORD *)v8 + 8);
        v12 = v11 < v9;
        if (v11 >= v9)
          v13 = (char **)v8;
        else
          v13 = (char **)(v8 + 8);
        if (!v12)
          v10 = (char **)v8;
        v8 = *v13;
      }
      while (*v13);
      if (v10 == v7 || *((_DWORD *)v10 + 8) > v9)
LABEL_13:
        v10 = (char **)((char *)this + 400);
      v14 = v10[5];
      if (v14)
      {
        v15 = sub_1C4816AD8(a2, " [");
        v16 = sub_1C4816AD8(v15, (char *)(*(_QWORD *)(*((_QWORD *)this + 31) + 80) + *(unsigned int *)(*(_QWORD *)v14 + 16)));
        v17 = "]\n";
      }
      else
      {
        v16 = a2;
        v17 = " [Unknown]\n";
      }
      result = sub_1C4816AD8(v16, v17);
      v6 = (uint64_t *)*v6;
    }
    while (v6);
  }
  return result;
}

void sub_1C61E40B0(uint64_t a1)
{
  sub_1C61E41D0(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t llvm::callDefaultCtor<llvm::LiveStacks>()
{
  uint64_t v0;

  v0 = operator new();
  return sub_1C61E40FC(v0);
}

uint64_t sub_1C61E40FC(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848(a1, (uint64_t)&llvm::LiveStacks::ID);
  *(_QWORD *)v2 = &off_1E8143680;
  *(_QWORD *)(v2 + 256) = 0;
  *(_QWORD *)(v2 + 264) = 0;
  *(_QWORD *)(v2 + 272) = v2 + 288;
  *(_QWORD *)(v2 + 280) = 0x400000000;
  *(_QWORD *)(v2 + 320) = v2 + 336;
  *(_QWORD *)(v2 + 328) = 0;
  *(_QWORD *)(v2 + 336) = 0;
  *(_QWORD *)(v2 + 344) = 1;
  *(_OWORD *)(v2 + 352) = 0u;
  *(_OWORD *)(v2 + 368) = 0u;
  *(_DWORD *)(v2 + 384) = 1065353216;
  *(_QWORD *)(v2 + 400) = 0;
  *(_QWORD *)(v2 + 408) = 0;
  *(_QWORD *)(v2 + 392) = v2 + 400;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED82F1B8);
  if (v3 != -1)
  {
    v7[0] = sub_1C511C0B0;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F1B8, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return a1;
}

void sub_1C61E41D0(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1E8143680;
  sub_1C6143384(*(_QWORD **)(a1 + 400));
  sub_1C511C9D0(*(_QWORD **)(a1 + 368));
  v2 = *(void **)(a1 + 352);
  *(_QWORD *)(a1 + 352) = 0;
  if (v2)
    operator delete(v2);
  sub_1C4926AE8(a1 + 256);
  sub_1C4926674((llvm::Pass *)a1);
}

_DWORD *sub_1C61E4224(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *result;
  int v10;
  char v11;
  _DWORD *v12;
  _DWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  v6 = *(_DWORD *)(a2 + 16);
  if (!v6)
  {
    v12 = 0;
LABEL_6:
    result = sub_1C6150C74(a2, (uint64_t)a3, a3, v12);
    *result = *a3;
    v7 = *(_QWORD *)a2;
    v6 = *(_DWORD *)(a2 + 16);
    v11 = 1;
    goto LABEL_4;
  }
  v7 = *(_QWORD *)a2;
  v8 = (37 * *a3) & (v6 - 1);
  result = (_DWORD *)(*(_QWORD *)a2 + 4 * v8);
  v10 = *result;
  if (*a3 != *result)
  {
    v13 = 0;
    v14 = 1;
    while (v10 != 0x7FFFFFFF)
    {
      if (v13)
        v15 = 0;
      else
        v15 = v10 == 0x80000000;
      if (v15)
        v13 = result;
      v16 = v8 + v14++;
      v8 = v16 & (v6 - 1);
      result = (_DWORD *)(v7 + 4 * v8);
      v10 = *result;
      if (*a3 == *result)
        goto LABEL_3;
    }
    if (v13)
      v12 = v13;
    else
      v12 = result;
    goto LABEL_6;
  }
LABEL_3:
  v11 = 0;
LABEL_4:
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = v7 + 4 * v6;
  *(_BYTE *)(a1 + 16) = v11;
  return result;
}

void llvm::initializeLiveVariablesPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F1C0);
  if (v2 != -1)
  {
    v5[0] = sub_1C511D230;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F1C0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void *llvm::LiveVariables::getAnalysisUsage(llvm::LiveVariables *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, byte_1EF8F7020);
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::LiveVariables::VarInfo::findKill(llvm::LiveVariables::VarInfo *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *((_QWORD *)this + 4);
  v3 = *((_QWORD *)this + 5);
  while (v2 != v3)
  {
    result = *(_QWORD *)v2;
    if (*(const llvm::MachineBasicBlock **)(*(_QWORD *)v2 + 24) == a2)
      return result;
    v2 += 8;
  }
  return 0;
}

llvm::raw_ostream *llvm::LiveVariables::VarInfo::dump(llvm::LiveVariables::VarInfo *this)
{
  llvm *v2;
  uint64_t v3;
  uint64_t v4;
  llvm *v5;
  int v6;
  int v7;
  llvm *v8;
  llvm *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  llvm *v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  llvm::raw_ostream *v19;
  unint64_t v20;
  llvm *v21;
  llvm::raw_ostream *v22;
  llvm *v23;
  unsigned __int8 v25[8];
  llvm::LiveVariables::VarInfo *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  _BYTE v30[8];
  llvm::LiveVariables::VarInfo *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;

  v2 = llvm::dbgs(this);
  sub_1C4816AD8(v2, "  Alive in blocks: ");
  v3 = *((_QWORD *)this + 1);
  v31 = this;
  v32 = v3;
  v34 = 0;
  v33 = 0xFFFFFFFF00000000;
  v30[0] = 0;
  sub_1C511F4E8((uint64_t)v30);
  v4 = *((_QWORD *)this + 1);
  v26 = this;
  v27 = v4;
  v29 = 0;
  v28 = 0xFFFFFFFF00000000;
  v25[0] = 1;
  v5 = (llvm *)sub_1C511F4E8((uint64_t)v25);
  v6 = v30[0];
  v7 = v25[0];
  if (!v30[0] || !v25[0])
  {
    while (1)
    {
      v20 = v33;
      if (v6 == v7 && (_DWORD)v28 == (_DWORD)v33)
        break;
      v21 = llvm::dbgs(v5);
      v22 = llvm::raw_ostream::operator<<(v21, v20);
      sub_1C4816AD8(v22, ", ");
      LODWORD(v33) = v33 + 1;
      v34 >>= 1;
      v5 = (llvm *)sub_1C511F56C((uint64_t)v30);
      v6 = v30[0];
      v7 = v25[0];
      if (v30[0])
      {
        if (v25[0])
          break;
      }
    }
  }
  v8 = llvm::dbgs(v5);
  v9 = sub_1C4816AD8(v8, "\n  Killed by:");
  v10 = *((_QWORD *)this + 4);
  v11 = *((_QWORD *)this + 5);
  if (v10 == v11)
  {
    v15 = " No instructions.\n";
  }
  else
  {
    v12 = v11 - v10;
    if ((v12 & 0x7FFFFFFF8) != 0)
    {
      v13 = 0;
      v14 = (v12 >> 3);
      v15 = "\n";
      do
      {
        v16 = llvm::dbgs(v9);
        v17 = sub_1C4816AD8(v16, "\n    #");
        v18 = llvm::raw_ostream::operator<<(v17, v13);
        v19 = sub_1C4816AD8(v18, ": ");
        llvm::MachineInstr::print(*(llvm::MachineInstr **)(*((_QWORD *)this + 4) + 8 * v13++), v19, 1, 0, 0, 1, 0);
      }
      while (v14 != v13);
    }
    else
    {
      v15 = "\n";
    }
  }
  v23 = llvm::dbgs(v9);
  return sub_1C4816AD8(v23, v15);
}

uint64_t llvm::LiveVariables::getVarInfo(uint64_t a1, int a2)
{
  _QWORD *v2;
  unint64_t v3;

  v2 = (_QWORD *)(a1 + 248);
  v3 = a2 & 0x7FFFFFFF;
  if (v3 >= *(unsigned int *)(a1 + 256))
    sub_1C61E5C60((uint64_t *)(a1 + 248), v3 + 1, a1 + 264);
  return *v2 + 56 * v3;
}

void llvm::LiveVariables::MarkVirtRegAliveInBlock(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;

  v9 = *(_DWORD *)(a4 + 24);
  v11 = a2[4];
  v10 = a2[5];
  v12 = v10 - v11;
  if (((v10 - v11) & 0x7FFFFFFF8) != 0)
  {
    v13 = (v12 >> 3);
    v14 = v12 - 8;
    while (*(_QWORD *)(*(_QWORD *)v11 + 24) != a4)
    {
      v11 += 8;
      v14 -= 8;
      if (!--v13)
        goto LABEL_9;
    }
    if (v11 + 8 != v10)
      memmove((void *)v11, (const void *)(v11 + 8), v14);
    a2[5] = v11 + (v14 & 0xFFFFFFFFFFFFFFF8);
  }
LABEL_9:
  if (a4 != a3 && (sub_1C617C970(a2, v9) & 1) == 0)
  {
    sub_1C4DB3420(a2, v9);
    sub_1C511D2C4(a5, *(_QWORD *)a5 + 8 * a5[2], *(_QWORD *)(a4 + 72), *(_QWORD *)(a4 + 72), *(_QWORD *)(a4 + 64), *(_QWORD *)(a4 + 64));
  }
}

void llvm::LiveVariables::MarkVirtRegAliveInBlock(llvm::LiveVariables *this, llvm::LiveVariables::VarInfo *a2, llvm::MachineBasicBlock *a3, llvm::MachineBasicBlock *a4)
{
  llvm::MachineBasicBlock *v4;
  llvm::LiveVariables::VarInfo *v5;
  void *v6;
  uint64_t v7;
  _QWORD v8[17];

  v4 = a3;
  v5 = a2;
  v8[16] = *MEMORY[0x1E0C80C00];
  v6 = v8;
  v7 = 0x1000000000;
  while (1)
  {
    llvm::LiveVariables::MarkVirtRegAliveInBlock((uint64_t)this, (uint64_t *)a2, (uint64_t)a3, (uint64_t)a4, (unsigned int *)&v6);
    if (!(_DWORD)v7)
      break;
    a4 = (llvm::MachineBasicBlock *)*((_QWORD *)v6 + v7 - 1);
    LODWORD(v7) = v7 - 1;
    a2 = v5;
    a3 = v4;
  }
  if (v6 != v8)
    free(v6);
}

void llvm::LiveVariables::HandleVirtRegUse(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD **v14;
  _QWORD *v15;
  _QWORD *v16;
  llvm::MachineBasicBlock **v17;
  llvm::MachineBasicBlock **v18;
  llvm::MachineBasicBlock *v19;
  llvm::MachineBasicBlock **VRegDef;
  uint64_t v21;

  v8 = *(_DWORD *)(a3 + 24);
  v9 = (uint64_t *)(a1 + 248);
  v10 = a2 & 0x7FFFFFFF;
  if (v10 >= *(unsigned int *)(a1 + 256))
    sub_1C61E5C60((uint64_t *)(a1 + 248), v10 + 1, a1 + 264);
  v11 = *v9;
  v12 = *v9 + 56 * v10;
  v14 = (_QWORD **)(v12 + 40);
  v13 = *(_QWORD *)(v12 + 40);
  if (*(_QWORD *)(v12 + 32) != v13 && *(_QWORD *)(*(_QWORD *)(v13 - 8) + 24) == a3)
  {
    *(_QWORD *)(v13 - 8) = a4;
  }
  else if (*(_QWORD *)(llvm::MachineRegisterInfo::getVRegDef(*(_QWORD *)(a1 + 368), a2) + 24) != a3)
  {
    if ((sub_1C617C970((uint64_t *)v12, v8) & 1) == 0)
    {
      v21 = a4;
      v15 = *v14;
      if ((unint64_t)*v14 >= *(_QWORD *)(v11 + 56 * v10 + 48))
      {
        v16 = sub_1C4DFEA3C((void **)(v12 + 32), &v21);
      }
      else
      {
        *v15 = a4;
        v16 = v15 + 1;
      }
      *v14 = v16;
    }
    v17 = *(llvm::MachineBasicBlock ***)(a3 + 64);
    v18 = *(llvm::MachineBasicBlock ***)(a3 + 72);
    while (v17 != v18)
    {
      v19 = *v17++;
      VRegDef = (llvm::MachineBasicBlock **)llvm::MachineRegisterInfo::getVRegDef(*(_QWORD *)(a1 + 368), a2);
      llvm::LiveVariables::MarkVirtRegAliveInBlock((llvm::LiveVariables *)VRegDef, (llvm::LiveVariables::VarInfo *)v12, VRegDef[3], v19);
    }
  }
}

uint64_t *llvm::LiveVariables::HandleVirtRegDef(uint64_t *result, int a2, uint64_t a3)
{
  uint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t **v10;
  uint64_t v11;

  v4 = result + 31;
  v5 = a2 & 0x7FFFFFFF;
  if (v5 >= *((unsigned int *)result + 64))
    result = sub_1C61E5C60(result + 31, v5 + 1, (unint64_t)(result + 33));
  v6 = *v4;
  if (!*(_QWORD *)(*v4 + 56 * v5 + 16))
  {
    v11 = a3;
    v7 = v6 + 56 * v5;
    v8 = *(_QWORD **)(v7 + 40);
    v9 = *(_QWORD *)(v7 + 48);
    v10 = (uint64_t **)(v7 + 40);
    if ((unint64_t)v8 >= v9)
    {
      result = sub_1C4DFEA3C((void **)(v6 + 56 * v5 + 32), &v11);
    }
    else
    {
      *v8 = a3;
      result = v8 + 1;
    }
    *v10 = result;
  }
  return result;
}

uint64_t llvm::LiveVariables::HandleRegMask(uint64_t this, const llvm::MachineOperand *a2)
{
  int v2;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 v12;
  unsigned __int16 *v13;
  unsigned int v14;
  int v15;

  v2 = *(_DWORD *)(*(_QWORD *)(this + 376) + 16);
  if (v2 != 1)
  {
    v4 = (_QWORD *)this;
    v5 = 1;
    do
    {
      v6 = v4[48];
      if (*(_QWORD *)(v6 + 8 * v5) || *(_QWORD *)(v4[51] + 8 * v5))
      {
        v7 = *((_QWORD *)a2 + 2);
        if (((*(_DWORD *)(v7 + ((v5 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v5) & 1) == 0)
        {
          v8 = v4[47];
          v9 = (_QWORD *)(v8 + 8);
          if (!v8)
            v9 = 0;
          v10 = v9[6];
          v11 = *(unsigned int *)(*v9 + 24 * v5 + 8);
          if (*(_WORD *)(v10 + 2 * v11))
          {
            v12 = *(_WORD *)(v10 + 2 * v11) + v5;
            v13 = (unsigned __int16 *)(v10 + 2 * v11 + 2);
            v14 = v5;
            do
            {
              if ((*(_QWORD *)(v6 + 8 * v12) || *(_QWORD *)(v4[51] + 8 * v12))
                && ((*(_DWORD *)(v7 + (((unint64_t)v12 >> 3) & 0x1FFC)) >> v12) & 1) == 0)
              {
                v14 = v12;
              }
              v15 = *v13++;
              v12 += v15;
            }
            while (v15);
          }
          else
          {
            v14 = v5;
          }
          this = llvm::LiveVariables::HandlePhysRegKill(v4, v14, 0);
        }
      }
      ++v5;
    }
    while (v2 != (_DWORD)v5);
  }
  return this;
}

_QWORD *llvm::LiveVariables::UpdatePhysRegDefs(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  int v9;

  v3 = *(unsigned int *)(a3 + 8);
  while ((_DWORD)v3)
  {
    v4 = *(_DWORD *)(*(_QWORD *)a3 + 4 * v3-- - 4);
    *(_DWORD *)(a3 + 8) = v3;
    v5 = result[47];
    v6 = (_QWORD *)(v5 + 8);
    if (!v5)
      v6 = 0;
    v7 = v6[6];
    if (v7)
    {
      v8 = (unsigned __int16 *)(v7 + 2 * *(unsigned int *)(*v6 + 24 * v4 + 4));
      do
      {
        *(_QWORD *)(result[48] + 8 * (unsigned __int16)v4) = a2;
        *(_QWORD *)(result[51] + 8 * (unsigned __int16)v4) = 0;
        v9 = *v8++;
        v4 += v9;
      }
      while (v9);
    }
  }
  return result;
}

void llvm::LiveVariables::runOnInstr(llvm::LiveVariables *this, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int *v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  _BYTE v41[16];
  void *v42;
  uint64_t v43;
  _QWORD v44[3];

  v44[2] = *MEMORY[0x1E0C80C00];
  v6 = **(unsigned __int16 **)(a2 + 16);
  if (v6 == 69 || v6 == 0)
    v8 = 1;
  else
    v8 = *(unsigned int *)(a2 + 40);
  v42 = v44;
  v43 = 0x400000000;
  v39 = v41;
  v40 = 0x400000000;
  v36 = &v38;
  v37 = 0x100000000;
  if (!(_DWORD)v8)
    goto LABEL_8;
  v9 = 0;
  v10 = 0;
  v11 = &v43;
  do
  {
    v12 = *(_QWORD *)(a2 + 32);
    v13 = *(_DWORD *)(v12 + v9);
    if ((_BYTE)v13)
    {
      if (*(_DWORD *)(v12 + v9) != 12)
        goto LABEL_23;
      v14 = v37;
      if (v37 >= (unint64_t)HIDWORD(v37))
      {
        v33 = v11;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, (uint64_t)&v38, v37 + 1, 4);
        v11 = v33;
        v14 = v37;
      }
      *((_DWORD *)v36 + v14) = v10;
      v15 = &v37;
      goto LABEL_22;
    }
    v16 = *(unsigned int *)(v12 + v9 + 4);
    if ((_DWORD)v16)
    {
      v17 = v16 >> 30;
      if ((v13 & 0x1000000) != 0)
      {
        if (!v17
          && ((*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 46) + 352) + ((v16 >> 3) & 0x1FFFFFF8)) >> v16) & 1) == 0)
        {
          *(_DWORD *)(v12 + v9) = v13 & 0xFBFFFFFF;
        }
        v22 = v40;
        if (v40 >= (unint64_t)HIDWORD(v40))
        {
          v34 = v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, (uint64_t)v41, v40 + 1, 4);
          v11 = v34;
          v22 = v40;
        }
        *((_DWORD *)v39 + v22) = v16;
        v15 = &v40;
        goto LABEL_22;
      }
      if (v17
        || ((*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 46) + 352) + ((v16 >> 3) & 0x1FFFFFF8)) >> v16) & 1) == 0)
      {
        v13 &= ~0x4000000u;
        *(_DWORD *)(v12 + v9) = v13;
      }
      v18 = v13 & 0x30000000;
      v19 = v13 & 0x10FFF00;
      if (v18)
        v20 = 1;
      else
        v20 = v19 == 0x1000000;
      if (!v20)
      {
        v21 = v43;
        if (v43 >= (unint64_t)HIDWORD(v43))
        {
          v35 = v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, (uint64_t)v44, v43 + 1, 4);
          v11 = v35;
          v21 = v43;
        }
        *((_DWORD *)v42 + v21) = v16;
        v15 = v11;
LABEL_22:
        ++*(_DWORD *)v15;
      }
    }
LABEL_23:
    ++v10;
    v9 += 32;
  }
  while (v8 != v10);
  if ((_DWORD)v43)
  {
    v29 = (unsigned int *)v42;
    v30 = *(_QWORD *)(a2 + 24);
    v31 = 4 * v43;
    do
    {
      v32 = *v29;
      if ((v32 & 0x80000000) != 0)
      {
        llvm::LiveVariables::HandleVirtRegUse((uint64_t)this, v32, v30, a2);
      }
      else if (((*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 46) + 352) + ((v32 >> 3) & 0x1FFFFFF8)) >> v32) & 1) == 0)
      {
        llvm::LiveVariables::HandlePhysRegUse(this, v32, a2);
      }
      ++v29;
      v31 -= 4;
    }
    while (v31);
  }
  if ((_DWORD)v37)
  {
    v26 = (unsigned int *)v36;
    v27 = 4 * v37;
    do
    {
      v28 = *v26++;
      llvm::LiveVariables::HandleRegMask((uint64_t)this, (const llvm::MachineOperand *)(*(_QWORD *)(a2 + 32) + 32 * v28));
      v27 -= 4;
    }
    while (v27);
  }
LABEL_8:
  if ((_DWORD)v40)
  {
    v23 = (unsigned int *)v39;
    v24 = 4 * v40;
    do
    {
      v25 = *v23;
      if ((v25 & 0x80000000) != 0)
      {
        llvm::LiveVariables::HandleVirtRegDef((uint64_t *)this, v25, a2);
      }
      else if (((*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 46) + 352) + ((v25 >> 3) & 0x1FFFFFF8)) >> v25) & 1) == 0)
      {
        llvm::LiveVariables::HandlePhysRegDef(this, v25, (llvm::MachineInstr *)a2, a3);
      }
      ++v23;
      v24 -= 4;
    }
    while (v24);
  }
  llvm::LiveVariables::UpdatePhysRegDefs(this, a2, a3);
  if (v36 != &v38)
    free(v36);
  if (v39 != v41)
    free(v39);
  if (v42 != v44)
    free(v42);
}

void sub_1C61E4EDC(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        v6 = (char *)(v3 - 16);
        do
        {
          v7 = (char *)*((_QWORD *)v6 - 2);
          if (v6 != v7)
            free(v7);
          v8 = v6 - 16;
          v6 -= 32;
        }
        while (v8 != (char *)v5);
      }
      a1[1] = v5;
    }
  }
  else
  {
    sub_1C511F814(a1, a2 - v4);
  }
}

void *llvm::LiveVariables::analyzePHINodes(void *this, const llvm::MachineFunction *a2)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t i;
  int v6;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  char *v19;

  v2 = (char *)a2 + 320;
  v3 = (char *)*((_QWORD *)a2 + 41);
  if (v3 != (char *)a2 + 320)
  {
    v4 = (uint64_t)this;
    v19 = (char *)a2 + 320;
    do
    {
      for (i = *((_QWORD *)v3 + 7); (char *)i != v3 + 48; i = *(_QWORD *)(i + 8))
      {
        v6 = **(unsigned __int16 **)(i + 16);
        if (v6 != 69 && v6 != 0)
          break;
        v8 = *(_DWORD *)(i + 40);
        if (v8 != 1)
        {
          v9 = 1;
          do
          {
            v10 = *(_QWORD *)(i + 32);
            v11 = v9;
            v12 = *(_DWORD *)(v10 + 32 * v9);
            v13 = v12 & 0x30000000;
            v14 = v12 & 0x10FFF00;
            if (v13)
              v15 = 1;
            else
              v15 = v14 == 0x1000000;
            if (!v15)
            {
              v16 = *(_QWORD *)(v4 + 432)
                  + 32 * *(int *)(*(_QWORD *)(v10 + 32 * (v11 + 1) + 16) + 24);
              v17 = *(_DWORD *)(v10 + 32 * v11 + 4);
              v18 = *(unsigned int *)(v16 + 8);
              if (v18 >= *(unsigned int *)(v16 + 12))
              {
                this = llvm::SmallVectorBase<unsigned int>::grow_pod(v16, v16 + 16, v18 + 1, 4);
                v2 = v19;
                v18 = *(unsigned int *)(v16 + 8);
              }
              *(_DWORD *)(*(_QWORD *)v16 + 4 * v18) = v17;
              ++*(_DWORD *)(v16 + 8);
            }
            v9 = v11 + 2;
          }
          while (v8 != (_DWORD)v11 + 2);
        }
        if ((*(_BYTE *)i & 4) == 0)
        {
          while ((*(_WORD *)(i + 44) & 8) != 0)
            i = *(_QWORD *)(i + 8);
        }
      }
      v3 = (char *)*((_QWORD *)v3 + 1);
    }
    while (v3 != v2);
  }
  return this;
}

uint64_t *llvm::LiveVariables::replaceKillInstruction(uint64_t *result, int a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;

  v6 = result + 31;
  v7 = a2 & 0x7FFFFFFF;
  if (v7 >= *((unsigned int *)result + 64))
    result = sub_1C61E5C60(result + 31, v7 + 1, (unint64_t)(result + 33));
  v8 = *v6 + 56 * v7;
  v9 = *(_QWORD **)(v8 + 32);
  v10 = *(_QWORD **)(v8 + 40);
  while (v9 != v10)
  {
    if (*v9 == a3)
      *v9 = a4;
    ++v9;
  }
  return result;
}

BOOL llvm::LiveVariables::removeVirtualRegistersKilled(_BOOL8 this, llvm::MachineInstr *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;

  v2 = *((unsigned int *)a2 + 10);
  if ((_DWORD)v2)
  {
    v4 = this;
    v5 = 0;
    v6 = (uint64_t *)(this + 248);
    v7 = 32 * v2;
    do
    {
      v8 = *((_QWORD *)a2 + 4);
      v9 = *(_DWORD *)(v8 + v5);
      if (!(_BYTE)v9 && ((v9 >> 26) & ~HIBYTE(v9) & 1) != 0)
      {
        v10 = (unsigned int *)(v8 + v5);
        *v10 = v9 & 0xFBFFFFFF;
        v11 = v10[1];
        if ((v11 & 0x80000000) != 0)
        {
          v12 = v11 & 0x7FFFFFFF;
          if ((v11 & 0x7FFFFFFF) >= *(_DWORD *)(v4 + 256))
            sub_1C61E5C60(v6, v12 + 1, v4 + 264);
          this = sub_1C511F3EC(*v6 + 56 * v12, (uint64_t)a2);
        }
      }
      v5 += 32;
    }
    while (v7 != v5);
  }
  return this;
}

uint64_t llvm::LiveVariables::VarInfo::isLiveIn(uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t VRegDef;
  uint64_t i;
  uint64_t v11;

  if ((sub_1C617C970(a1, *(_DWORD *)(a2 + 24)) & 1) != 0)
    return 1;
  VRegDef = llvm::MachineRegisterInfo::getVRegDef(a4, a3);
  if (VRegDef && *(_QWORD *)(VRegDef + 24) == a2)
    return 0;
  for (i = a1[4]; i != a1[5]; i += 8)
  {
    v11 = *(_QWORD *)i;
    if (*(_QWORD *)(*(_QWORD *)i + 24) == a2)
      return v11 != 0;
  }
  v11 = 0;
  return v11 != 0;
}

BOOL llvm::LiveVariables::isLiveOut(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v4;
  unint64_t v5;
  uint64_t *v6;
  _BYTE *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  _QWORD *v18;
  _BOOL8 v19;
  BOOL v20;
  _BYTE *v22;
  _BYTE *v23;
  uint64_t v24;
  int v25;
  _BYTE v26[64];

  v4 = (_QWORD *)(a1 + 248);
  v5 = a2 & 0x7FFFFFFF;
  if (v5 >= *(unsigned int *)(a1 + 256))
    sub_1C61E5C60((uint64_t *)(a1 + 248), v5 + 1, a1 + 264);
  v6 = (uint64_t *)(*v4 + 56 * v5);
  v7 = v26;
  v22 = v26;
  v23 = v26;
  v24 = 8;
  v25 = 0;
  v8 = (uint64_t *)v6[4];
  v9 = (uint64_t *)v6[5];
  if (v8 == v9)
  {
    v11 = v26;
  }
  else
  {
    do
    {
      v10 = *v8++;
      sub_1C4774094((llvm::SmallPtrSetImplBase *)&v22, *(_QWORD *)(v10 + 24));
    }
    while (v8 != v9);
    v7 = v22;
    v11 = v23;
  }
  v12 = *(_QWORD *)(a3 + 88);
  v13 = *(_QWORD *)(a3 + 96);
  if (v12 == v13)
  {
    v19 = 0;
  }
  else
  {
    v14 = v12 + 8;
    while (1)
    {
      v15 = *(_QWORD *)(v14 - 8);
      if (sub_1C617C970(v6, *(_DWORD *)(v15 + 24)))
        break;
      v16 = sub_1C477672C((uint64_t)&v22, v15);
      v7 = v22;
      v11 = v23;
      v17 = (uint64_t *)((char *)&v24 + 4);
      if (v23 != v22)
        v17 = &v24;
      v18 = &v23[8 * *(unsigned int *)v17];
      v19 = v16 != v18;
      v20 = v16 != v18 || v14 == v13;
      v14 += 8;
      if (v20)
        goto LABEL_16;
    }
    v19 = 1;
    v7 = v22;
    v11 = v23;
  }
LABEL_16:
  if (v11 != v7)
    free(v11);
  return v19;
}

uint64_t llvm::LiveVariables::addNewBlock(llvm::LiveVariables *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3, llvm::MachineBasicBlock *a4)
{
  unsigned int v5;
  char *v6;
  uint64_t v7;
  _QWORD *v9;
  int v10;
  int v12;
  unsigned int i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  unsigned int v19;
  _QWORD *v20;
  int v21;
  int v22;
  _QWORD *v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  uint64_t *v28;
  unsigned int v29;
  int v30;
  int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  char *v36;
  int v38;
  _QWORD v39[2];
  int v40;
  _QWORD v41[2];
  int v42;
  _BYTE v43[31];

  v5 = *((_DWORD *)a2 + 6);
  v41[0] = 0;
  v41[1] = 0;
  v42 = 0;
  v6 = (char *)a4 + 48;
  v39[0] = 0;
  v39[1] = 0;
  v40 = 0;
  v7 = *((_QWORD *)a4 + 7);
  if ((llvm::MachineBasicBlock *)v7 == (llvm::MachineBasicBlock *)((char *)a4 + 48))
    goto LABEL_38;
  v9 = (_QWORD *)((char *)this + 248);
  v36 = (char *)this + 264;
  do
  {
    v10 = **(unsigned __int16 **)(v7 + 16);
    if (v10 != 69 && v10 != 0)
    {
      while (1)
      {
LABEL_38:
        if ((char *)v7 == v6)
          goto LABEL_39;
        v16 = *(unsigned int *)(v7 + 40);
        if (!(_DWORD)v16)
          goto LABEL_33;
        v17 = 32 * v16;
        v18 = (int *)(*(_QWORD *)(v7 + 32) + 4);
        do
        {
          v19 = *(v18 - 1);
          if (!(_BYTE)v19 && *v18 < 0)
          {
            if ((v19 & 0x1000000) != 0)
            {
              v38 = *v18;
              v20 = v41;
            }
            else
            {
              if (((v19 >> 26) & ~HIBYTE(v19) & 1) == 0)
                goto LABEL_24;
              v38 = *v18;
              v20 = v39;
            }
            sub_1C61E6104((uint64_t)v20, &v38, (uint64_t)v43);
          }
LABEL_24:
          v18 += 8;
          v17 -= 32;
        }
        while (v17);
        if (v7)
        {
LABEL_33:
          if ((*(_BYTE *)v7 & 4) != 0)
            goto LABEL_37;
        }
        while ((*(_WORD *)(v7 + 44) & 8) != 0)
          v7 = *(_QWORD *)(v7 + 8);
LABEL_37:
        v7 = *(_QWORD *)(v7 + 8);
      }
    }
    v38 = *(_DWORD *)(*(_QWORD *)(v7 + 32) + 4);
    sub_1C61E6104((uint64_t)v41, &v38, (uint64_t)v43);
    v12 = *(_DWORD *)(v7 + 40);
    if (v12 != 1)
    {
      for (i = 1; i != v12; i += 2)
      {
        v14 = *(_QWORD *)(v7 + 32);
        if (*(llvm::MachineBasicBlock **)(v14 + 32 * (i + 1) + 16) == a2)
        {
          v15 = *(_DWORD *)(v14 + 32 * i + 4) & 0x7FFFFFFF;
          if (v15 >= *((_DWORD *)this + 64))
            sub_1C61E5C60((uint64_t *)this + 31, v15 + 1, (unint64_t)v36);
          sub_1C4DB3420((uint64_t *)(*v9 + 56 * v15), v5);
        }
      }
    }
    if ((*(_BYTE *)v7 & 4) == 0)
    {
      while ((*(_WORD *)(v7 + 44) & 8) != 0)
        v7 = *(_QWORD *)(v7 + 8);
    }
    v7 = *(_QWORD *)(v7 + 8);
  }
  while ((char *)v7 != v6);
LABEL_39:
  v21 = *(_DWORD *)(*((_QWORD *)this + 46) + 32);
  if (v21)
  {
    v22 = 0;
    v23 = (_QWORD *)((char *)this + 248);
    while (1)
    {
      v24 = v22 | 0x80000000;
      if (!v42)
        goto LABEL_45;
      v25 = (v42 - 1) & (37 * v24);
      v26 = *(_DWORD *)(v41[0] + 4 * v25);
      if (v24 != v26)
        break;
LABEL_43:
      if (++v22 == v21)
        goto LABEL_52;
    }
    v32 = 1;
    while (v26 != -1)
    {
      v33 = v25 + v32++;
      v25 = v33 & (v42 - 1);
      v26 = *(_DWORD *)(v41[0] + 4 * v25);
      if (v24 == v26)
        goto LABEL_43;
    }
LABEL_45:
    v27 = v22 & 0x7FFFFFFF;
    if (v27 >= *((_DWORD *)this + 64))
      sub_1C61E5C60((uint64_t *)this + 31, v27 + 1, (unint64_t)this + 264);
    v28 = (uint64_t *)(*v23 + 56 * v27);
    if (v40)
    {
      v29 = (v40 - 1) & (37 * v24);
      v30 = *(_DWORD *)(v39[0] + 4 * v29);
      if (v24 == v30)
      {
LABEL_49:
        sub_1C4DB3420(v28, v5);
        goto LABEL_43;
      }
      v34 = 1;
      while (v30 != -1)
      {
        v35 = v29 + v34++;
        v29 = v35 & (v40 - 1);
        v30 = *(_DWORD *)(v39[0] + 4 * v29);
        if (v24 == v30)
          goto LABEL_49;
      }
    }
    if (!sub_1C617C970((uint64_t *)(*v23 + 56 * v27), *((_DWORD *)a4 + 6)))
      goto LABEL_43;
    goto LABEL_49;
  }
LABEL_52:
  MEMORY[0x1CAA32FB4](v39[0], 4);
  return MEMORY[0x1CAA32FB4](v41[0], 4);
}

uint64_t llvm::LiveVariables::addNewBlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t result;
  int v11;
  int v12;
  uint64_t i;
  int v14;
  unsigned int j;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v21;
  unint64_t v22;
  unsigned __int8 v23[8];
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  _BYTE v28[8];
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;

  v8 = *(_DWORD *)(a2 + 24);
  v9 = *a5 + 32 * *(int *)(a4 + 24);
  v29 = v9;
  v30 = *(_QWORD *)(v9 + 8);
  v32 = 0;
  v31 = 0xFFFFFFFF00000000;
  v28[0] = 0;
  sub_1C511F4E8((uint64_t)v28);
  v24 = v9;
  v25 = *(_QWORD *)(v9 + 8);
  v27 = 0;
  v26 = 0xFFFFFFFF00000000;
  v23[0] = 1;
  result = sub_1C511F4E8((uint64_t)v23);
  v11 = v28[0];
  v12 = v23[0];
  if (!v28[0] || !v23[0])
  {
    while (v11 != v12 || (_DWORD)v26 != (_DWORD)v31)
    {
      v22 = v31 & 0x7FFFFFFF;
      if ((v31 & 0x7FFFFFFF) >= *(_DWORD *)(a1 + 256))
        sub_1C61E5C60((uint64_t *)(a1 + 248), v22 + 1, a1 + 264);
      sub_1C4DB3420((uint64_t *)(*(_QWORD *)(a1 + 248) + 56 * v22), v8);
      LODWORD(v31) = v31 + 1;
      v32 >>= 1;
      result = sub_1C511F56C((uint64_t)v28);
      v11 = v28[0];
      v12 = v23[0];
      if (v28[0])
      {
        if (v23[0])
          break;
      }
    }
  }
  for (i = *(_QWORD *)(a4 + 56); i != a4 + 48; i = *(_QWORD *)(i + 8))
  {
    if (**(_WORD **)(i + 16) && **(_WORD **)(i + 16) != 69)
      break;
    v14 = *(_DWORD *)(i + 40);
    if (v14 != 1)
    {
      for (j = 1; j != v14; j += 2)
      {
        v16 = *(_QWORD *)(i + 32);
        if (*(_QWORD *)(v16 + 32 * (j + 1) + 16) == a2)
        {
          v17 = *(_DWORD *)(v16 + 32 * j);
          v18 = v17 & 0x30000000;
          v19 = v17 & 0x10FFF00;
          if (!v18 && v19 != 0x1000000)
          {
            v21 = *(_DWORD *)(v16 + 32 * j + 4) & 0x7FFFFFFF;
            if (v21 >= *(_DWORD *)(a1 + 256))
              sub_1C61E5C60((uint64_t *)(a1 + 248), v21 + 1, a1 + 264);
            result = (uint64_t)sub_1C4DB3420((uint64_t *)(*(_QWORD *)(a1 + 248) + 56 * v21), v8);
          }
        }
      }
    }
    if ((*(_BYTE *)i & 4) == 0)
    {
      while ((*(_WORD *)(i + 44) & 8) != 0)
        i = *(_QWORD *)(i + 8);
    }
  }
  return result;
}

void sub_1C61E5958(uint64_t a1)
{
  sub_1C61E5ABC(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t *sub_1C61E597C(uint64_t *result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *((unsigned int *)result + 64);
  if ((_DWORD)v2)
  {
    v3 = 56 * v2;
    v4 = result[31] - 56;
    do
    {
      result = sub_1C61E5B8C((uint64_t *)(v4 + v3));
      v3 -= 56;
    }
    while (v3);
  }
  *((_DWORD *)v1 + 64) = 0;
  return result;
}

uint64_t llvm::callDefaultCtor<llvm::LiveVariables>()
{
  uint64_t v0;

  v0 = operator new();
  return sub_1C61E59F4(v0);
}

uint64_t sub_1C61E59F4(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848(a1, (uint64_t)&llvm::LiveVariables::ID);
  *(_QWORD *)v2 = &off_1E8143740;
  *(_QWORD *)(v2 + 248) = v2 + 264;
  *(_QWORD *)(v2 + 256) = 0;
  *(_QWORD *)(v2 + 264) = v2 + 264;
  *(_QWORD *)(v2 + 272) = v2 + 264;
  *(_QWORD *)(v2 + 280) = 0;
  *(_QWORD *)(v2 + 288) = v2 + 264;
  *(_QWORD *)(v2 + 304) = 0;
  *(_QWORD *)(v2 + 312) = 0;
  *(_QWORD *)(v2 + 296) = 0;
  *(_QWORD *)(v2 + 328) = v2 + 328;
  *(_QWORD *)(v2 + 336) = v2 + 328;
  *(_QWORD *)(v2 + 344) = 0;
  *(_QWORD *)(v2 + 352) = v2 + 328;
  *(_OWORD *)(v2 + 384) = 0u;
  *(_OWORD *)(v2 + 400) = 0u;
  *(_OWORD *)(v2 + 416) = 0u;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 460) = 0u;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED82F1C0);
  if (v3 != -1)
  {
    v7[0] = sub_1C511D230;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F1C0, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return a1;
}

void sub_1C61E5ABC(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  void **v8;

  *(_QWORD *)a1 = &off_1E8143740;
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 456), 8);
  v8 = (void **)(a1 + 432);
  sub_1C511F468(&v8);
  v2 = *(void **)(a1 + 408);
  if (v2)
  {
    *(_QWORD *)(a1 + 416) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 384);
  if (v3)
  {
    *(_QWORD *)(a1 + 392) = v3;
    operator delete(v3);
  }
  if (*(_QWORD *)(a1 + 344))
  {
    v5 = *(_QWORD *)(a1 + 328);
    v4 = *(uint64_t **)(a1 + 336);
    v6 = *v4;
    *(_QWORD *)(v6 + 8) = *(_QWORD *)(v5 + 8);
    **(_QWORD **)(v5 + 8) = v6;
    *(_QWORD *)(a1 + 344) = 0;
    if (v4 != (uint64_t *)(a1 + 328))
    {
      do
      {
        v7 = (uint64_t *)v4[1];
        operator delete(v4);
        v4 = v7;
      }
      while (v7 != (uint64_t *)(a1 + 328));
    }
  }
  sub_1C61E5B8C((uint64_t *)(a1 + 264));
  sub_1C61E5BFC((char **)(a1 + 248));
  sub_1C4926674((llvm::Pass *)a1);
}

uint64_t *sub_1C61E5B8C(uint64_t *a1)
{
  void *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;

  v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = (uint64_t)v2;
    operator delete(v2);
  }
  if (a1[2])
  {
    v4 = *a1;
    v3 = (uint64_t *)a1[1];
    v5 = *v3;
    *(_QWORD *)(v5 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v4 + 8) = v5;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v6 = (uint64_t *)v3[1];
        operator delete(v3);
        v3 = v6;
      }
      while (v6 != a1);
    }
  }
  return a1;
}

char **sub_1C61E5BFC(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    v5 = v2 - 56;
    do
    {
      sub_1C61E5B8C((uint64_t *)&v5[v4]);
      v4 -= 56;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

uint64_t *sub_1C61E5C60(uint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v3 = *((unsigned int *)result + 2);
  v4 = a2 - v3;
  if (a2 != v3)
  {
    v5 = result;
    if (a2 >= v3)
    {
      v9 = sub_1C511F6CC((uint64_t)result, a3, v4);
      result = sub_1C511F7AC((_QWORD *)(*v5 + 56 * *((unsigned int *)v5 + 2)), v4, v9);
      v6 = *((_DWORD *)v5 + 2) + v4;
    }
    else
    {
      v6 = a2;
      v7 = 56 * v3;
      v8 = 56 * a2 - v7;
      result = (uint64_t *)(v7 + *result - 56);
      do
      {
        result = sub_1C61E5B8C(result) - 7;
        v8 += 56;
      }
      while (v8);
    }
    *((_DWORD *)v5 + 2) = v6;
  }
  return result;
}

void sub_1C61E5D04(uint64_t a1, unint64_t a2)
{
  uint64_t *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = (uint64_t *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 56, &v5);
  sub_1C61E5D70(a1, v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61E5D70(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  __n128 *v4;
  uint64_t v5;
  __int8 *v6;

  sub_1C511F734(*(__n128 **)a1, (__n128 *)(*(_QWORD *)a1 + 56 * *(unsigned int *)(a1 + 8)), a2);
  v3 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v3)
  {
    v4 = *(__n128 **)a1;
    v5 = 56 * v3;
    v6 = &v4[-4].n128_i8[8];
    do
    {
      sub_1C61E5B8C((uint64_t *)&v6[v5]);
      v5 -= 56;
    }
    while (v5);
  }
}

_QWORD *sub_1C61E5DCC(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3 != a2)
  {
    v5 = 1;
    v6 = a1;
    do
    {
      v7 = operator new(0x28uLL);
      *v7 = 0;
      v7[1] = 0;
      v8 = *(_QWORD *)(v3 + 32);
      *((_OWORD *)v7 + 1) = *(_OWORD *)(v3 + 16);
      v7[4] = v8;
      *v7 = v6;
      v7[1] = a1;
      v6[1] = v7;
      *a1 = v7;
      a1[2] = v5;
      v3 = *(_QWORD *)(v3 + 8);
      ++v5;
      v6 = v7;
    }
    while (v3 != a2);
  }
  return a1;
}

uint64_t *sub_1C61E5E5C(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 != *result)
  {
    v7 = 0;
    do
    {
      *(_QWORD *)(v6 + v7 - 32) = v6 + v7 - 16;
      result = (uint64_t *)(v6 + v7 - 32);
      *(_QWORD *)(v6 + v7 - 24) = 0x400000000;
      if (*(_DWORD *)(v4 + v7 - 24))
        result = (uint64_t *)sub_1C4EA2F88((uint64_t)result, v4 + v7 - 32);
      v7 -= 32;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  v8 = *v3;
  *v3 = v6;
  a2[1] = v8;
  v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void sub_1C61E5F20(_QWORD *a1, uint64_t a2, llvm::SmallPtrSetImplBase *a3)
{
  _BYTE *v4;
  uint64_t v5;
  void *__p;
  _BYTE *v7;

  sub_1C61E5F8C(&v5, a2, a3);
  v4 = __p;
  *a1 = v5;
  a1[2] = 0;
  a1[3] = 0;
  a1[1] = 0;
  sub_1C4D6CDA0(a1 + 1, v4, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v4) >> 3));
  if (__p)
  {
    v7 = __p;
    operator delete(__p);
  }
}

_QWORD *sub_1C61E5F8C(_QWORD *a1, uint64_t a2, llvm::SmallPtrSetImplBase *this)
{
  void **v5;
  char v6;
  unint64_t v7;
  __int128 v8;
  char *v9;
  __int128 v11;
  uint64_t v12;

  *a1 = this;
  a1[1] = 0;
  v5 = (void **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  sub_1C4774094(this, a2);
  if (v6)
  {
    *(_QWORD *)&v11 = a2;
    BYTE8(v11) = 0;
    LOBYTE(v12) = 0;
    v7 = a1[2];
    if (v7 >= a1[3])
    {
      v9 = sub_1C4D8DBBC(v5, (uint64_t)&v11);
    }
    else
    {
      v8 = v11;
      *(_QWORD *)(v7 + 16) = v12;
      *(_OWORD *)v7 = v8;
      v9 = (char *)(v7 + 24);
    }
    a1[2] = v9;
  }
  return a1;
}

char *sub_1C61E6020(char *result)
{
  char *v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v1 = result;
  v2 = (void **)(result + 8);
  v3 = *((_QWORD *)result + 2);
  while (2)
  {
    v4 = *(_QWORD *)(v3 - 24);
    if (!*(_BYTE *)(v3 - 8))
    {
      *(_QWORD *)(v3 - 16) = *(_QWORD *)(v4 + 88);
      *(_BYTE *)(v3 - 8) = 1;
    }
    while (1)
    {
      v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 96))
        break;
      *(_QWORD *)(v3 - 16) = v5 + 1;
      v6 = *v5;
      result = (char *)sub_1C4774094(*(llvm::SmallPtrSetImplBase **)v1, *v5);
      if (v7)
      {
        *(_QWORD *)&v11 = v6;
        BYTE8(v11) = 0;
        LOBYTE(v12) = 0;
        v9 = *((_QWORD *)v1 + 2);
        if (v9 >= *((_QWORD *)v1 + 3))
        {
          result = sub_1C4D8DBBC(v2, (uint64_t)&v11);
        }
        else
        {
          v10 = v11;
          *(_QWORD *)(v9 + 16) = v12;
          *(_OWORD *)v9 = v10;
          result = (char *)(v9 + 24);
        }
        *((_QWORD *)v1 + 2) = result;
        return result;
      }
    }
    v8 = *((_QWORD *)v1 + 1);
    v3 = *((_QWORD *)v1 + 2) - 24;
    *((_QWORD *)v1 + 2) = v3;
    if (v8 != v3)
      continue;
    break;
  }
  return result;
}

_DWORD *sub_1C61E6104@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *result;
  int v10;
  char v11;
  _DWORD *v12;
  _DWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  v6 = *(_DWORD *)(a1 + 16);
  if (!v6)
  {
    v12 = 0;
LABEL_6:
    result = sub_1C4A0C948(a1, (uint64_t)a2, a2, v12);
    *result = *a2;
    v7 = *(_QWORD *)a1;
    v6 = *(_DWORD *)(a1 + 16);
    v11 = 1;
    goto LABEL_4;
  }
  v7 = *(_QWORD *)a1;
  v8 = (37 * *a2) & (v6 - 1);
  result = (_DWORD *)(*(_QWORD *)a1 + 4 * v8);
  v10 = *result;
  if (*a2 != *result)
  {
    v13 = 0;
    v14 = 1;
    while (v10 != -1)
    {
      if (v13)
        v15 = 0;
      else
        v15 = v10 == -2;
      if (v15)
        v13 = result;
      v16 = v8 + v14++;
      v8 = v16 & (v6 - 1);
      result = (_DWORD *)(v7 + 4 * v8);
      v10 = *result;
      if (*a2 == *result)
        goto LABEL_3;
    }
    if (v13)
      v12 = v13;
    else
      v12 = result;
    goto LABEL_6;
  }
LABEL_3:
  v11 = 0;
LABEL_4:
  *(_QWORD *)a3 = result;
  *(_QWORD *)(a3 + 8) = v7 + 4 * v6;
  *(_BYTE *)(a3 + 16) = v11;
  return result;
}

uint64_t llvm::LLVMTargetMachine::initAsmInfo(llvm::LLVMTargetMachine *this)
{
  uint64_t v2;
  char v3;
  BOOL v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(void **);
  uint64_t v9;
  uint64_t (*v10)(void);
  uint64_t v11;
  char v12;
  BOOL v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char *v18;
  uint64_t v19;
  char v20;
  int v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  BOOL v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  int v34;
  uint64_t result;
  uint64_t v36;

  v2 = *((_QWORD *)this + 1);
  v3 = *((_BYTE *)this + 471);
  v4 = v3 < 0;
  if (v3 >= 0)
    v5 = (char *)this + 448;
  else
    v5 = (char *)*((_QWORD *)this + 56);
  v6 = v3 & 0x7F;
  if (v4)
    v7 = *((_QWORD *)this + 57);
  else
    v7 = v6;
  v8 = sub_1C511F97C(v2, (uint64_t)v5, v7);
  v9 = *((_QWORD *)this + 71);
  *((_QWORD *)this + 71) = v8;
  if (v9)
  {
    v36 = sub_1C61E6B14(v9);
    MEMORY[0x1CAA32FC0](v36, 0x10F0C4031312594);
  }
  v10 = *(uint64_t (**)(void))(*((_QWORD *)this + 1) + 64);
  if (v10)
    v10 = (uint64_t (*)(void))v10();
  v11 = *((_QWORD *)this + 72);
  *((_QWORD *)this + 72) = v10;
  if (v11)
    MEMORY[0x1CAA32FC0](v11, 0x10F0C40CB53E019);
  v12 = *((_BYTE *)this + 471);
  v13 = v12 < 0;
  if (v12 >= 0)
    v14 = (char *)this + 448;
  else
    v14 = (char *)*((_QWORD *)this + 56);
  v15 = v12 & 0x7F;
  if (v13)
    v16 = *((_QWORD *)this + 57);
  else
    v16 = v15;
  v17 = *((_BYTE *)this + 519);
  if (v17 >= 0)
    v18 = (char *)this + 496;
  else
    v18 = (char *)*((_QWORD *)this + 62);
  if (v17 >= 0)
    v19 = v17 & 0x7F;
  else
    v19 = *((_QWORD *)this + 63);
  v20 = *((_BYTE *)this + 543);
  v21 = v20;
  if (v20 >= 0)
    v22 = (char *)this + 520;
  else
    v22 = (char *)*((_QWORD *)this + 65);
  v23 = v20 & 0x7F;
  if (v21 >= 0)
    v24 = v23;
  else
    v24 = *((_QWORD *)this + 66);
  v25 = sub_1C4D72F0C(*((_QWORD *)this + 1), (uint64_t)v14, v16, (uint64_t)v18, v19, (uint64_t)v22, v24);
  v26 = *((_QWORD *)this + 73);
  *((_QWORD *)this + 73) = v25;
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
  v27 = *((_BYTE *)this + 471);
  v28 = v27 < 0;
  if (v27 >= 0)
    v29 = (char *)this + 448;
  else
    v29 = (char *)*((_QWORD *)this + 56);
  v30 = v27 & 0x7F;
  if (v28)
    v31 = *((_QWORD *)this + 57);
  else
    v31 = v30;
  v32 = (_QWORD *)sub_1C511F9DC(*((_QWORD *)this + 1), *((_QWORD *)this + 71), (uint64_t)v29, v31, (uint64_t)this + 1128);
  v33 = v32;
  if (*((int *)this + 253) >= 1)
    v32[57] = *(_QWORD *)((char *)this + 1012);
  if ((*((_BYTE *)this + 1032) & 4) != 0)
  {
    (*(void (**)(_QWORD *, _QWORD))(*v32 + 80))(v32, 0);
    (*(void (**)(_QWORD *, _QWORD))(*v33 + 88))(v33, 0);
  }
  (*(void (**)(_QWORD *, _QWORD))(*v33 + 96))(v33, (*((unsigned __int16 *)this + 564) >> 12) & 1);
  *((_DWORD *)v33 + 117) = *((_DWORD *)this + 259);
  *((_BYTE *)v33 + 473) = *((_BYTE *)this + 1040) & 1;
  v34 = *((_DWORD *)this + 281);
  if (v34)
    *((_DWORD *)v33 + 103) = v34;
  result = *((_QWORD *)this + 70);
  *((_QWORD *)this + 70) = v33;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

double llvm::LLVMTargetMachine::getTargetTransformInfo@<D0>(llvm::LLVMTargetMachine *this@<X0>, const llvm::Function *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  double result;
  _QWORD v7[2];
  __int128 v8;

  llvm::BasicTTIImpl::BasicTTIImpl((llvm::BasicTTIImpl *)v7, this, a2);
  v4 = operator new();
  v5 = v7[1];
  result = *(double *)&v8;
  *(_OWORD *)(v4 + 24) = v8;
  *(_QWORD *)(v4 + 16) = v5;
  *(_QWORD *)v4 = &off_1E81438E8;
  *(_QWORD *)(v4 + 8) = &unk_1E813FF40;
  *a3 = v4;
  return result;
}

uint64_t llvm::LLVMTargetMachine::addAsmPrinter(uint64_t a1, uint64_t a2, llvm::raw_pwrite_stream *a3, llvm::raw_pwrite_stream *a4, int a5, llvm::MCContext *a6)
{
  uint64_t (*v8)(uint64_t, _QWORD **);
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  llvm::LLVMTargetMachine::createMCStreamer(a1, a3, a4, a5, a6, (uint64_t)&v15);
  if ((v16 & 1) != 0 && (v13 = v15, v15 = 0, v13))
  {
    (*(void (**)(_QWORD *))(*v13 + 8))(v13);
  }
  else
  {
    v8 = *(uint64_t (**)(uint64_t, _QWORD **))(*(_QWORD *)(a1 + 8) + 120);
    if (v8)
    {
      v9 = v8(a1, &v15);
      if (v9)
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v9);
        v10 = 0;
        goto LABEL_5;
      }
    }
  }
  v10 = 1;
LABEL_5:
  v11 = v15;
  v15 = 0;
  if (v11)
  {
    v14 = 8;
    if ((v16 & 1) == 0)
      v14 = 48;
    (*(void (**)(void))(*v11 + v14))();
  }
  return v10;
}

uint64_t sub_1C61E65D0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, int a5, uint64_t a6, uint64_t *a7, llvm::MCAsmBackend **a8, unsigned __int8 a9)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v17;

  v12 = *a3;
  *a3 = 0;
  v17 = v12;
  v13 = llvm::createAsmStreamer(a2, &v17, a4, a5, a6, a7, a8, a9);
  v14 = v17;
  v17 = 0;
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
  v15 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 208);
  if (v15)
    v15(v13, v12, a6, a4);
  return v13;
}

uint64_t llvm::LLVMTargetMachine::addPassesToEmitFile(const llvm::LLVMTargetMachine *a1, uint64_t a2, llvm *a3, llvm::raw_pwrite_stream *a4, int a5, char a6, _QWORD *a7)
{
  _QWORD *v7;
  llvm::TargetMachine **v14;
  uint64_t v15;
  llvm::raw_ostream *v16;
  llvm::MCContext *v17;
  uint64_t FreeMachineFunctionPass;
  _QWORD *PrintMIRPass;

  v7 = a7;
  if (!a7)
  {
    v7 = (_QWORD *)operator new();
    llvm::MachineModuleInfoWrapperPass::MachineModuleInfoWrapperPass((llvm::MachineModuleInfoWrapperPass *)v7, a1);
  }
  v14 = sub_1C511FF24((uint64_t)a1, a2, a6, (uint64_t)v7);
  if (v14)
  {
    v15 = llvm::TargetPassConfig::willCompleteCodeGenPipeline((llvm::TargetPassConfig *)v14);
    if (!(_DWORD)v15)
    {
      if (a5 != 2)
      {
        PrintMIRPass = llvm::createPrintMIRPass(a3, v16);
        v15 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 16))(a2, PrintMIRPass);
      }
      goto LABEL_9;
    }
    if (v7[261])
      v17 = (llvm::MCContext *)v7[261];
    else
      v17 = (llvm::MCContext *)(v7 + 5);
    v15 = llvm::LLVMTargetMachine::addAsmPrinter((uint64_t)a1, a2, a3, a4, a5, v17);
    if ((v15 & 1) == 0)
    {
LABEL_9:
      FreeMachineFunctionPass = llvm::createFreeMachineFunctionPass((llvm *)v15);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, FreeMachineFunctionPass);
      return 0;
    }
  }
  return 1;
}

uint64_t llvm::LLVMTargetMachine::addPassesToEmitMC(llvm::LLVMTargetMachine *this, llvm::legacy::PassManagerBase *a2, llvm::MCContext **a3, llvm::raw_pwrite_stream *a4, char a5)
{
  _QWORD *v10;
  llvm::MCContext *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(_QWORD);
  uint64_t v15;
  uint64_t (*v16)(void);
  llvm::MCAsmBackend *v17;
  uint64_t v18;
  uint64_t v19;
  llvm::MCContext *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(llvm::LLVMTargetMachine *, uint64_t *);
  uint64_t v25;
  llvm *v26;
  uint64_t FreeMachineFunctionPass;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  llvm::MCAsmBackend *v32;
  uint64_t v33;

  v10 = (_QWORD *)operator new();
  llvm::MachineModuleInfoWrapperPass::MachineModuleInfoWrapperPass((llvm::MachineModuleInfoWrapperPass *)v10, this);
  if (!sub_1C511FF24((uint64_t)this, (uint64_t)a2, a5, (uint64_t)v10))
    return 1;
  if (v10[261])
    v11 = (llvm::MCContext *)v10[261];
  else
    v11 = (llvm::MCContext *)(v10 + 5);
  *a3 = v11;
  *((_DWORD *)this + 283) = 0;
  if ((*((_BYTE *)this + 1128) & 0x40) != 0)
    *((_BYTE *)v11 + 1627) = 0;
  v12 = *((_QWORD *)this + 73);
  v13 = *((_QWORD *)this + 1);
  v14 = *(uint64_t (**)(_QWORD))(v13 + 144);
  if (v14)
  {
    v15 = v14(*((_QWORD *)this + 72));
    v13 = *((_QWORD *)this + 1);
  }
  else
  {
    v15 = 0;
  }
  v16 = *(uint64_t (**)(void))(v13 + 104);
  if (!v16)
    return 1;
  v17 = (llvm::MCAsmBackend *)v16();
  v18 = 1;
  if (v15 && v17)
  {
    v19 = *((_QWORD *)this + 1);
    v20 = *a3;
    v32 = v17;
    llvm::MCAsmBackend::createObjectWriter(v17, a4, &v31);
    v30 = v15;
    v33 = sub_1C6175EA0(v19, (uint64_t)this + 448, v20, (uint64_t *)&v32, &v31, &v30, v12, *((_WORD *)this + 564) & 1, HIBYTE(*((_WORD *)this + 564)) & 1, 1u);
    v21 = v30;
    v30 = 0;
    if (v21)
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
    v22 = v31;
    v31 = 0;
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
    v23 = (uint64_t)v32;
    v32 = 0;
    if (v23)
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
    v24 = *(uint64_t (**)(llvm::LLVMTargetMachine *, uint64_t *))(*((_QWORD *)this + 1) + 120);
    if (v24 && (v25 = v24(this, &v33)) != 0)
    {
      v26 = (llvm *)(*(uint64_t (**)(llvm::legacy::PassManagerBase *, uint64_t))(*(_QWORD *)a2 + 16))(a2, v25);
      FreeMachineFunctionPass = llvm::createFreeMachineFunctionPass(v26);
      (*(void (**)(llvm::legacy::PassManagerBase *, uint64_t))(*(_QWORD *)a2 + 16))(a2, FreeMachineFunctionPass);
      v18 = 0;
    }
    else
    {
      v18 = 1;
    }
    v29 = v33;
    v33 = 0;
    if (v29)
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 48))(v29);
  }
  return v18;
}

void sub_1C61E69A8(llvm::TargetMachine *a1)
{
  llvm::TargetMachine::~TargetMachine(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61E69CC(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED82F1C8, 0, 0);
  byte_1ED82F248 = 0;
  qword_1ED82F250 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED82F258 = 0;
  qword_1ED82F1C8 = (uint64_t)&unk_1E819E898;
  qword_1ED82F260 = (uint64_t)&off_1E819E9A0;
  qword_1ED82F268 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED82F280 = (uint64_t)&qword_1ED82F268;
  sub_1C61E6A80(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED82F1C8);
}

__n128 sub_1C61E6A80(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  char *v8;
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED82F1C8, "trap-unreachable", 0x10uLL);
  word_1ED82F1D2 = word_1ED82F1D2 & 0xFF9F | (32 * (*a1 & 3));
  word_1ED82F1D2 = word_1ED82F1D2 & 0xFFF8 | *a2 & 7;
  v8 = *a3;
  byte_1ED82F248 = **a3;
  byte_1ED82F259 = 1;
  byte_1ED82F258 = *v8;
  result = *a4;
  xmmword_1ED82F1E8 = (__int128)*a4;
  return result;
}

uint64_t sub_1C61E6B14(uint64_t a1)
{
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 184), 4);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 160), 4);
  return a1;
}

void sub_1C61E6B50(llvm::TargetTransformInfo::Concept *a1)
{
  llvm::TargetTransformInfo::Concept::~Concept(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61E6B74(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t sub_1C61E6B7C(uint64_t a1, uint64_t a2, llvm::Value *a3, llvm **a4, uint64_t a5)
{
  return sub_1C51200BC((uint64_t *)(a1 + 16), a2, a3, a4, a5);
}

uint64_t sub_1C61E6B84()
{
  return 1;
}

uint64_t sub_1C61E6B8C()
{
  return 0;
}

uint64_t sub_1C61E6B94()
{
  return 150;
}

uint64_t sub_1C61E6B9C()
{
  return 4;
}

uint64_t sub_1C61E6BA8(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  return sub_1C4843E38(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_1C61E6BC8(uint64_t a1, int **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1C51205AC((uint64_t *)(a1 + 16), a2, a3, a4, a5);
}

uint64_t sub_1C61E6BD0()
{
  unsigned int v1;

  llvm::BranchProbability::BranchProbability(&v1, 0x63uLL, 0x64u);
  return v1;
}

uint64_t sub_1C61E6BFC()
{
  return 0;
}

uint64_t sub_1C61E6C04()
{
  return 0;
}

uint64_t sub_1C61E6C0C()
{
  return 0;
}

uint64_t sub_1C61E6C14()
{
  return 0;
}

uint64_t sub_1C61E6C1C()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_1C61E6C24()
{
  return 0;
}

uint64_t sub_1C61E6C2C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 8) + 64))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
}

BOOL sub_1C61E6C40(uint64_t a1, int a2)
{
  return a2 == 0;
}

uint64_t sub_1C61E6C4C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 8) + 72))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
}

uint64_t sub_1C61E6C60(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 8) + 80))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
}

uint64_t sub_1C61E6C74()
{
  return 0;
}

uint64_t sub_1C61E6C7C(uint64_t a1, uint64_t ***a2)
{
  return sub_1C4845148(a1 + 16, a2);
}

void sub_1C61E6C84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm::OptimizationRemarkEmitter *a5)
{
  sub_1C512468C(a1 + 8, a2, a4, a5);
}

void sub_1C61E6C94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)a4 = 0;
  *(_WORD *)(a4 + 4) = 1;
  *(_BYTE *)(a4 + 6) = 1;
}

uint64_t sub_1C61E6CA8()
{
  return 0;
}

uint64_t sub_1C61E6CB0()
{
  return 0;
}

uint64_t sub_1C61E6CB8()
{
  return 0;
}

uint64_t sub_1C61E6CC0()
{
  return 0;
}

uint64_t sub_1C61E6CCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  size_t v6;
  void *v7;
  const void *v9;
  int v10;

  v5 = *(unsigned int *)(a4 + 8);
  v10 = v5;
  if (v5 > 0x40)
  {
    v6 = ((unint64_t)(v5 + 63) >> 3) & 0x3FFFFFF8;
    v7 = (void *)operator new[]();
    v9 = v7;
    memcpy(v7, *(const void **)a4, v6);
    sub_1C6138A10((uint64_t)&v9);
    MEMORY[0x1CAA32F9C](v7, 0x1000C8000313F17);
  }
  else
  {
    v9 = *(const void **)a4;
    sub_1C6138A10((uint64_t)&v9);
  }
  return 0;
}

uint64_t sub_1C61E6D7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  uint64_t v10;
  void *v11;
  _QWORD *v12;
  void (**v13)(void);
  void *v15;
  int v16;
  _QWORD v17[3];
  _QWORD *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v10 = *(unsigned int *)(a4 + 8);
  v16 = v10;
  if (v10 > 0x40)
  {
    v11 = (void *)operator new[]();
    memcpy(v11, *(const void **)a4, ((unint64_t)(v10 + 63) >> 3) & 0x3FFFFFF8);
  }
  else
  {
    v11 = *(void **)a4;
  }
  v15 = v11;
  v12 = (_QWORD *)a8[3];
  if (v12)
  {
    if (v12 == a8)
    {
      v18 = v17;
      (*(void (**)(_QWORD *, _QWORD *))(*a8 + 24))(a8, v17);
    }
    else
    {
      v18 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v12 + 16))(v12);
    }
  }
  else
  {
    v18 = 0;
  }
  sub_1C6138A98((uint64_t)&v15, v17);
  if (v18 == v17)
  {
    v13 = (void (**)(void))(v17[0] + 32);
    goto LABEL_9;
  }
  if (v18)
  {
    v13 = (void (**)(void))(*v18 + 40);
LABEL_9:
    (*v13)();
  }
  if (v10 >= 0x41 && v11)
    MEMORY[0x1CAA32F9C](v11, 0x1000C8000313F17);
  return 0;
}

uint64_t sub_1C61E6EE4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 1088))(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1C61E6EF4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 1080))(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1C61E6F04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD v9[2];
  char v10;
  uint64_t v11;

  v9[0] = a3;
  v9[1] = a4;
  v10 = a5;
  v11 = a6;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 32) + 1064))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 16), v9, a2, a7, a8);
}

BOOL sub_1C61E6F54(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  __int128 v3;
  __int128 v4;
  _OWORD v6[2];
  _OWORD v7[2];

  v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  v4 = a3[1];
  v6[0] = *a3;
  v6[1] = v4;
  return sub_1C6138BE0(a1 + 16, v7, v6);
}

uint64_t sub_1C61E6F8C()
{
  return 1;
}

uint64_t sub_1C61E6F94()
{
  return 0;
}

uint64_t sub_1C61E6F9C()
{
  return 0;
}

uint64_t sub_1C61E6FA4()
{
  return 0;
}

uint64_t sub_1C61E6FAC()
{
  return 2;
}

uint64_t sub_1C61E6FB4()
{
  return 0;
}

uint64_t sub_1C61E6FBC()
{
  return 0;
}

BOOL sub_1C61E6FC4(uint64_t a1, uint64_t a2, char a3)
{
  return sub_1C4849330((uint64_t *)(a1 + 16), a2, a3);
}

BOOL sub_1C61E6FD0(uint64_t a1, uint64_t a2, char a3)
{
  return sub_1C4849330((uint64_t *)(a1 + 16), a2, a3);
}

uint64_t sub_1C61E6FDC()
{
  return 0;
}

uint64_t sub_1C61E6FE4()
{
  return 0;
}

uint64_t sub_1C61E6FEC()
{
  return 0;
}

uint64_t sub_1C61E6FF4()
{
  return 0;
}

uint64_t sub_1C61E6FFC()
{
  return 0;
}

uint64_t sub_1C61E7004()
{
  return 0;
}

uint64_t sub_1C61E700C()
{
  return 0;
}

uint64_t sub_1C61E7014()
{
  return 0;
}

uint64_t sub_1C61E701C()
{
  return 0;
}

uint64_t sub_1C61E7024()
{
  return 0;
}

uint64_t sub_1C61E702C()
{
  return 1;
}

uint64_t sub_1C61E7034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7)
{
  _QWORD v8[2];
  char v9;
  uint64_t v10;

  v8[0] = a3;
  v8[1] = a4;
  v9 = a5;
  v10 = a6;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t))(**(_QWORD **)(a1 + 32) + 1072))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 16), v8, a2, a7);
}

uint64_t sub_1C61E7080()
{
  return 0;
}

uint64_t sub_1C61E7088(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 1144))(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1C61E7098(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 1176))(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1C61E70A8(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 368))(*(_QWORD *)(a1 + 24));
}

BOOL sub_1C61E70B8(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v3;

  v3 = sub_1C47A7FD0(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 16), a2, 0);
  return v3 && *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v3 + 96) != 0;
}

uint64_t sub_1C61E710C(uint64_t a1, llvm::EVT **a2)
{
  uint64_t v3;

  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 32), *(const llvm::DataLayout **)(a1 + 16), a2, (uint64_t)&v3);
  return v3;
}

BOOL sub_1C61E7140(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 4510) | 4) == 4
      || (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 4509) & 0xFB) == 0;
}

uint64_t sub_1C61E7178()
{
  return 1;
}

unint64_t sub_1C61E7180(uint64_t a1)
{
  return sub_1C48493AC(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
}

uint64_t sub_1C61E718C()
{
  return 0;
}

unint64_t sub_1C61E7194(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  return sub_1C61E820C(a1 + 8, a2, a3, a4, a5);
}

unint64_t sub_1C61E719C(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t *a4)
{
  return sub_1C5124544(a1 + 8, a2, a3, a4);
}

uint64_t sub_1C61E71A4()
{
  return 0;
}

uint64_t sub_1C61E71AC()
{
  return 0;
}

double sub_1C61E71B4@<D0>(uint64_t a1@<X8>)
{
  double result;

  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = a1 + 24;
  *(_QWORD *)&result = 0x800000000;
  *(_QWORD *)(a1 + 16) = 0x800000000;
  *(_DWORD *)(a1 + 56) = 1;
  *(_BYTE *)(a1 + 60) = 0;
  return result;
}

uint64_t sub_1C61E71DC()
{
  return 0;
}

uint64_t sub_1C61E71E4()
{
  return 0;
}

uint64_t sub_1C61E71EC()
{
  return 0;
}

uint64_t sub_1C61E71F4()
{
  return 0;
}

uint64_t sub_1C61E71FC(uint64_t a1, llvm::EVT *a2, llvm::LLVMContext *a3, uint64_t a4, unsigned __int8 a5, uint64_t a6)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v9 = a5;
  v10 = sub_1C4815B1C(a2, a3);
  return (*(uint64_t (**)(_QWORD, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(**(_QWORD **)(a1 + 32) + 648))(*(_QWORD *)(a1 + 32), v10, v11, a4, v9, 0, a6);
}

uint64_t sub_1C61E7264()
{
  return 0;
}

BOOL sub_1C61E726C(uint64_t a1, uint64_t a2)
{
  return sub_1C4849494(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32), a2);
}

uint64_t sub_1C61E7280()
{
  return 1;
}

uint64_t sub_1C61E7288(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_1C47A7FD0(v2, *(_QWORD *)(a1 + 16), a2, 0);
  if (v3 && (v3 == 1 || *(_QWORD *)(v2 + 8 * v3 + 96)) && (v4 = *(char *)(v2 + 390 * v3 + 3958), v4 <= 4))
    return qword_1C85FAF90[v4];
  else
    return 4;
}

uint64_t sub_1C61E7304()
{
  return 0;
}

uint64_t sub_1C61E7310()
{
  return 1;
}

uint64_t sub_1C61E731C()
{
  return 0;
}

uint64_t sub_1C61E7328()
{
  return 0;
}

uint64_t sub_1C61E7334()
{
  return 8;
}

uint64_t sub_1C61E733C(uint64_t a1, uint64_t a2)
{
  return a2;
}

const char *sub_1C61E7344(uint64_t a1, int a2)
{
  const char *v2;

  v2 = "Generic::Unknown Register Class";
  if (a2 == 1)
    v2 = "Generic::VectorRC";
  if (a2)
    return v2;
  else
    return "Generic::ScalarRC";
}

uint64_t sub_1C61E7370()
{
  return 32;
}

uint64_t sub_1C61E737C()
{
  return 128;
}

uint64_t sub_1C61E7384()
{
  return 0;
}

uint64_t sub_1C61E738C()
{
  return 0;
}

uint64_t sub_1C61E7394()
{
  return 0;
}

uint64_t sub_1C61E739C(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
    return 0x100000000;
  else
    return 0;
}

uint64_t sub_1C61E73AC()
{
  return 0;
}

uint64_t sub_1C61E73B4(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  *a3 = 0;
  return 0;
}

uint64_t sub_1C61E73C0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 56))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61E73D0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 32))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61E73E0(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 40))(*(_QWORD *)(a1 + 24));
  if ((result & 0xFF00000000) == 0)
    return 0;
  return result;
}

uint64_t sub_1C61E7408(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61E7418(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 88))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61E7428(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 72))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61E7438(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 80))(*(_QWORD *)(a1 + 24));
}

uint64_t sub_1C61E7448()
{
  return 1;
}

void sub_1C61E7450(uint64_t a1, int a2)
{
  sub_1C5121850(a1 + 8, a2);
}

void sub_1C61E745C(uint64_t a1, int a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  sub_1C51229E4(a1 + 8, a2, a3, a4, a5);
}

uint64_t sub_1C61E7468(uint64_t a1, uint64_t a2, llvm::Type ***a3, llvm::Type ***a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  return sub_1C5121DC4(a1 + 8, a2, a3, a4, a5, a6, a7);
}

unint64_t sub_1C61E7470(uint64_t a1, uint64_t a2, llvm::Type ***a3, uint64_t a4)
{
  return sub_1C61E88D8(a1 + 8, a2, a3, a4);
}

uint64_t sub_1C61E7478(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  return sub_1C51226E4(a1 + 8, a2, a3, a4, a6);
}

uint64_t sub_1C61E7484(uint64_t a1, uint64_t a2, uint64_t a3)
{
  llvm::TargetLoweringBase *v4;
  uint64_t v6;

  v4 = *(llvm::TargetLoweringBase **)(a1 + 32);
  if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12)
    a3 = **(_QWORD **)(a3 + 16);
  llvm::TargetLoweringBase::getTypeLegalizationCost(v4, *(const llvm::DataLayout **)(a1 + 16), (llvm::EVT **)a3, (uint64_t)&v6);
  return v6;
}

unint64_t sub_1C61E74CC(uint64_t a1, llvm::FixedVectorType *a2, int a3, llvm::Type *a4, llvm::APIntOps *a5)
{
  return sub_1C61E76F4(a1 + 8, a2, a3, a4, a5);
}

unint64_t sub_1C61E74D4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  return sub_1C5122554(a1 + 8, a2, a3, a6);
}

uint64_t sub_1C61E74E0()
{
  return 1;
}

unint64_t sub_1C61E74EC(uint64_t a1, int a2, uint64_t a3, unsigned __int8 a4, uint64_t a5, int a6)
{
  return sub_1C61E7C10(a1 + 8, a2, a3, a4, 1, 0, a6);
}

unint64_t sub_1C61E7504(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, unsigned __int8 a6, int a7)
{
  return sub_1C61E7C10(a1 + 8, a2, a3, a6, a5, 1, a7);
}

unint64_t sub_1C61E7514(uint64_t a1, int a2, uint64_t a3, unsigned int a4, unsigned int *a5, unint64_t a6, unsigned __int8 a7, uint64_t a8, int a9, unsigned __int8 a10, char a11)
{
  return sub_1C51249DC(a1 + 8, a2, a3, a4, a5, a6, a7, a9, a10, a11);
}

unint64_t sub_1C61E7534(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1C61E7888(a1 + 8, a2, a3, a4, a5);
}

unint64_t sub_1C61E753C(uint64_t a1, llvm::FixedVectorType **a2, uint64_t a3, uint64_t a4, int a5)
{
  return sub_1C61E78A4(a1 + 8, a2, a3, a5);
}

unint64_t sub_1C61E7548(uint64_t a1, int a2, int a3, llvm::FixedVectorType *a4, uint64_t a5, uint64_t a6)
{
  return sub_1C61E8988(a1 + 8, a2, a3, a4, a5, a6);
}

uint64_t sub_1C61E7550(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1C5120FD0(a1 + 8, a2, a3);
}

uint64_t sub_1C61E7558()
{
  return 10;
}

uint64_t sub_1C61E7564(uint64_t a1, llvm::EVT **a2)
{
  _DWORD v3[6];

  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 32), *(const llvm::DataLayout **)(a1 + 16), a2, (uint64_t)v3);
  if (v3[2])
    return 0;
  else
    return v3[0];
}

uint64_t sub_1C61E75A4()
{
  return 0;
}

uint64_t sub_1C61E75B0()
{
  return 0;
}

uint64_t sub_1C61E75BC()
{
  return 0;
}

uint64_t sub_1C61E75C4()
{
  return 0;
}

uint64_t sub_1C61E75CC()
{
  return 0;
}

_QWORD *sub_1C61E75D4(int a1, llvm::Type *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a8 & 0xFF00000000) != 0)
    return llvm::Type::getIntNTy(this, (llvm::LLVMContext *)(8 * a8));
  else
    return (_QWORD *)(*(_QWORD *)this + 1912);
}

void *sub_1C61E75F8(int a1, uint64_t a2, llvm::Type *a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  return sub_1C6138E7C(a1 + 16, a2, a3, a4, a5, a6, a7, a8, a9);
}

BOOL sub_1C61E7608(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1C4849AD0(a1 + 16, a2, a3);
}

BOOL sub_1C61E7610(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1C4849AD0(a1 + 16, a2, a3);
}

uint64_t sub_1C61E7618()
{
  return 128;
}

uint64_t sub_1C61E7620()
{
  return 1;
}

uint64_t sub_1C61E7628()
{
  return 1;
}

uint64_t sub_1C61E7630()
{
  return 1;
}

uint64_t sub_1C61E7638()
{
  return 1;
}

uint64_t sub_1C61E7640()
{
  return 1;
}

uint64_t sub_1C61E7648()
{
  return 1;
}

uint64_t sub_1C61E7650(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1C61E7658(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1C61E7660()
{
  return 0;
}

uint64_t sub_1C61E7668()
{
  return 0;
}

uint64_t sub_1C61E7670()
{
  return 1;
}

uint64_t sub_1C61E7678()
{
  return 1;
}

uint64_t sub_1C61E7680()
{
  return 0;
}

uint64_t sub_1C61E7688()
{
  return 0;
}

uint64_t sub_1C61E7690()
{
  return 0;
}

uint64_t sub_1C61E7698(uint64_t a1, llvm::ShuffleVectorInst *a2)
{
  if (*((_BYTE *)a2 + 16) == 60)
    return 4;
  else
    return sub_1C5124F8C((uint64_t *)(a1 + 16), a2);
}

uint64_t sub_1C61E76C8()
{
  return 0x200000001;
}

uint64_t sub_1C61E76D4()
{
  return 0;
}

uint64_t sub_1C61E76DC()
{
  return 1;
}

uint64_t sub_1C61E76E4()
{
  return 1;
}

uint64_t sub_1C61E76EC()
{
  return 1;
}

unint64_t sub_1C61E76F4(uint64_t a1, llvm::FixedVectorType *this, int a3, llvm::Type *a4, llvm::APIntOps *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v17;
  unsigned int v18;

  llvm::FixedVectorType::get(this, a4);
  v11 = v10;
  llvm::FixedVectorType::get(this, (llvm::Type *)((_DWORD)a4 * a3));
  v13 = v12;
  llvm::APIntOps::ScaleBitMask(a5, a4, (llvm::APInt *)&v17);
  v14 = sub_1C61E820C(a1, v11, (uint64_t)&v17, 0, 1);
  v15 = sub_1C61E820C(a1, v13, (uint64_t)a5, 1, 0);
  if (v18 >= 0x41 && v17)
    MEMORY[0x1CAA32F9C](v17, 0x1000C8000313F17);
  if (__OFADD__(v14, v15))
    return ((uint64_t)(v14 + v15) >> 63) ^ 0x8000000000000000;
  else
    return v14 + v15;
}

unint64_t sub_1C61E77EC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  unint64_t v8;
  uint64_t v10;
  unsigned int v11;

  sub_1C4832EA4((llvm::APInt *)&v10, *(_DWORD *)(a2 + 32), -1, 1);
  v8 = sub_1C61E820C(a1, a2, (uint64_t)&v10, a3, a4);
  if (v11 >= 0x41 && v10)
    MEMORY[0x1CAA32F9C](v10, 0x1000C8000313F17);
  return v8;
}

unint64_t sub_1C61E7888(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((a4 & 0xFF00000000) == 0 || (a4 & 1) != 0)
    return sub_1C61E7EC8(a1, a2, (llvm::FixedVectorType **)a3, a5);
  else
    return sub_1C61E7DF8(a1, a2, a3);
}

unint64_t sub_1C61E78A4(uint64_t a1, llvm::FixedVectorType **a2, uint64_t a3, int a4)
{
  uint64_t v4;
  llvm::Type *v5;
  unsigned int v7;
  llvm::FixedVectorType *v8;
  llvm::FixedVectorType *v9;
  llvm::Type *v10;
  int v11;
  const char *v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int64_t v23;
  BOOL v24;
  int64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  unint64_t v35;
  llvm::TargetLoweringBase *v36;
  const llvm::DataLayout *v37;
  unint64_t v38;
  int64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v43;
  llvm::FixedVectorType *v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  char v52[16];
  unsigned __int8 v53[8];
  uint64_t v54;
  int v55;

  v4 = a3;
  v5 = (llvm::Type *)a2;
  if (((_DWORD)a2[1] & 0xFE) == 0x12)
    v7 = *(unsigned __int8 *)(*(_QWORD *)a2[2] + 8);
  else
    v7 = *((_DWORD *)a2 + 2);
  v8 = a2[3];
  v9 = *(llvm::FixedVectorType **)(a3 + 24);
  LODWORD(v10) = *((_DWORD *)a2 + 8);
  if (v7 >= 7)
    v11 = 53;
  else
    v11 = 54;
  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), a2, (uint64_t)v52);
  if (v53[0] - 15 > 0x9B)
  {
    v13 = 1;
  }
  else
  {
    if (v53[0] - 120 <= 0x32)
      llvm::reportInvalidSizeRequest((llvm *)"Possible incorrect use of MVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use MVT::getVectorElementCount() instead", v12);
    v13 = sub_1C47F381C(v53);
  }
  v14 = __clz(v10);
  if (v10 <= v13)
  {
    v48 = 0;
    v49 = 0;
    v15 = 0;
  }
  else
  {
    v43 = v14;
    v44 = v8;
    v15 = 0;
    v48 = 0;
    v49 = 0;
    v45 = v13;
    do
    {
      v10 = (llvm::Type *)(v10 >> 1);
      llvm::FixedVectorType::get(v44, v10);
      v17 = v16;
      llvm::FixedVectorType::get(v9, v10);
      v4 = v18;
      v19 = sub_1C61E85E4(a1, (uint64_t)v5, v17);
      v20 = v49 + v19;
      if (__OFADD__(v49, v19))
        v20 = ((uint64_t)(v49 + v19) >> 63) ^ 0x8000000000000000;
      v49 = v20;
      v21 = sub_1C51226E4(a1, v11, v17, v4, a4);
      v5 = (llvm::Type *)v17;
      v22 = sub_1C51226E4(a1, 57, v17, v4, a4);
      v23 = v21 + v22;
      if (__OFADD__(v21, v22))
        v23 = (v23 >> 63) ^ 0x8000000000000000;
      v24 = __OFADD__(v48, v23);
      v25 = v48 + v23;
      if (v24)
        v25 = (v25 >> 63) ^ 0x8000000000000000;
      v48 = v25;
      --v15;
    }
    while (v10 > v45);
    v14 = v43;
  }
  v26 = 0;
  v27 = v15 - v14 + 31;
  v28 = 1;
  if (v5 && *((_BYTE *)v5 + 8) == 18)
    v26 = sub_1C61E84E8(a1, (uint64_t)v5);
  v50 = v26;
  v51 = v28;
  v54 = v27;
  v55 = 0;
  sub_1C4848B64((uint64_t)&v54, (uint64_t)&v50);
  v46 = v54;
  v29 = sub_1C51226E4(a1, v11, (uint64_t)v5, v4, a4);
  v31 = v30;
  v32 = sub_1C51226E4(a1, 57, (uint64_t)v5, v4, a4);
  v33 = v31 & 0xFFFFFFFF00000000 | 1;
  if (v34 != 1)
    v33 = v31;
  v35 = v29 + v32;
  if (__OFADD__(v29, v32))
    v35 = ((v29 + v32) >> 63) ^ 0x8000000000000000;
  v50 = v35;
  v51 = v33;
  v54 = v27;
  v55 = 0;
  sub_1C4848B64((uint64_t)&v54, (uint64_t)&v50);
  v36 = *(llvm::TargetLoweringBase **)(a1 + 24);
  v37 = *(const llvm::DataLayout **)(a1 + 8);
  if ((*((_DWORD *)v5 + 2) & 0xFE) == 0x12)
    v5 = (llvm::Type *)**((_QWORD **)v5 + 2);
  v38 = v49 + v46;
  if (__OFADD__(v49, v46))
    v38 = ((v49 + v46) >> 63) ^ 0x8000000000000000;
  v39 = v48 + v54;
  if (__OFADD__(v48, v54))
    v39 = (v39 >> 63) ^ 0x8000000000000000;
  v24 = __OFADD__(v38, v39);
  v40 = v38 + v39;
  if (v24)
    v41 = (v40 >> 63) ^ 0x8000000000000000;
  else
    v41 = v40;
  llvm::TargetLoweringBase::getTypeLegalizationCost(v36, v37, (llvm::EVT **)v5, (uint64_t)&v54);
  if (__OFADD__(v41, v54))
    return ((uint64_t)(v41 + v54) >> 63) ^ 0x8000000000000000;
  else
    return v41 + v54;
}

unint64_t sub_1C61E7C10(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  llvm::FixedVectorType *v12;
  uint64_t v13;
  llvm::EVT **v14;
  llvm::Type *v15;
  unint64_t v16;
  llvm::Type *v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  llvm::Type *v22;
  unint64_t v23;
  llvm::Type *v24;
  uint64_t v25;
  llvm::EVT **v26;
  uint64_t v27;
  _BOOL8 v28;
  BOOL v29;
  uint64_t v30;
  llvm::Type *v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v35;
  unint64_t v36;
  llvm::Type *v37;
  unint64_t v38;

  if (a6)
  {
    v12 = (llvm::FixedVectorType *)llvm::PointerType::get(*(llvm::PointerType **)(a3 + 24), 0);
    llvm::FixedVectorType::get(v12, (llvm::Type *)*(unsigned int *)(a3 + 32));
    v14 = (llvm::EVT **)v13;
    if ((*(_DWORD *)(v13 + 8) & 0xFE) == 0x12)
      v14 = **(llvm::EVT ****)(v13 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v14, (uint64_t)&v37);
    v15 = v37;
    v16 = v38;
  }
  else
  {
    v15 = 0;
    v16 = 0;
  }
  v17 = (llvm::Type *)*(unsigned int *)(a3 + 32);
  v18 = sub_1C5122554(a1, a2, *(_QWORD *)(a3 + 24), a7);
  v19 = v16 & 0xFFFFFFFF00000000 | 1;
  if (v20 != 1)
    v19 = v16;
  v21 = (unint64_t)v15 + v18;
  if (__OFADD__(v15, v18))
    v21 = ((uint64_t)((uint64_t)v15 + v18) >> 63) ^ 0x8000000000000000;
  v35 = v21;
  v36 = v19;
  v37 = v17;
  LODWORD(v38) = 0;
  sub_1C4848B64((uint64_t)&v37, (uint64_t)&v35);
  v22 = v37;
  v23 = sub_1C61E77EC(a1, a3, a2 != 33, a2 == 33);
  if (a5)
  {
    v24 = (llvm::Type *)*(unsigned int *)(a3 + 32);
    llvm::FixedVectorType::get((llvm::FixedVectorType *)(**(_QWORD **)a3 + 1888), v24);
    v26 = (llvm::EVT **)v25;
    if ((*(_DWORD *)(v25 + 8) & 0xFE) == 0x12)
      v26 = **(llvm::EVT ****)(v25 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v26, (uint64_t)&v37);
    v27 = (uint64_t)v37 + 1;
    if (__OFADD__(v37, 1))
      v27 = 0x7FFFFFFFFFFFFFFFLL;
    v28 = a7 == 0;
    v29 = __OFADD__(v27, v28);
    v30 = v27 + v28;
    if (v29)
      v30 = 0x7FFFFFFFFFFFFFFFLL;
    v35 = v30;
    v36 = v38;
    v37 = v24;
    LODWORD(v38) = 0;
    sub_1C4848B64((uint64_t)&v37, (uint64_t)&v35);
    v31 = v37;
  }
  else
  {
    v31 = 0;
  }
  v32 = (unint64_t)v22 + v23;
  if (__OFADD__(v22, v23))
    v32 = ((uint64_t)((uint64_t)v22 + v23) >> 63) ^ 0x8000000000000000;
  v29 = __OFADD__(v32, v31);
  v33 = (uint64_t)v31 + v32;
  if (v29)
    return (v33 >> 63) ^ 0x8000000000000000;
  else
    return v33;
}

unint64_t sub_1C61E7DF8(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  int v12;

  if (*(_BYTE *)(a3 + 8) == 19)
    return 0;
  v7 = sub_1C61E77EC(a1, a3, 0, 1);
  sub_1C5121850(a1, a2);
  v10[0] = v8;
  v10[1] = v9;
  v11 = *(unsigned int *)(a3 + 32);
  v12 = 0;
  sub_1C4848B64((uint64_t)v10, (uint64_t)&v11);
  if (__OFADD__(v7, v10[0]))
    return ((uint64_t)(v7 + v10[0]) >> 63) ^ 0x8000000000000000;
  else
    return v7 + v10[0];
}

unint64_t sub_1C61E7EC8(uint64_t a1, int a2, llvm::FixedVectorType **a3, uint64_t a4)
{
  llvm::Type *v5;
  llvm::FixedVectorType *v7;
  llvm::Type *v8;
  BOOL v9;
  const char *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  llvm::Type *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  BOOL v31;
  uint64_t v32;
  llvm::Type ***v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  llvm::FixedVectorType *v39;
  unsigned int v40;
  unint64_t v42;
  uint64_t v43;
  char v44[16];
  unsigned __int8 v45[8];
  uint64_t v46;
  int v47;

  v5 = (llvm::Type *)a3;
  v7 = a3[3];
  LODWORD(v8) = *((_DWORD *)a3 + 8);
  if ((a2 & 0xFFFFFFFE) == 0x1C
    && (v7 == (llvm::FixedVectorType *)(*(_QWORD *)*a3 + 1888) ? (v9 = v8 >= 2) : (v9 = 0), v9))
  {
    v34 = (llvm::Type ***)llvm::IntegerType::get(*a3, (llvm::LLVMContext *)*((unsigned int *)a3 + 8));
    v35 = sub_1C5121DC4(a1, 49, v34, (llvm::Type ***)v5, 0, a4, 0);
    sub_1C4774CC4(v34);
    v37 = sub_1C51226E4(a1, 53, (uint64_t)v34, v36, a4);
    v31 = __OFADD__(v35, v37);
    v32 = v35 + v37;
  }
  else
  {
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), a3, (uint64_t)v44);
    if (v45[0] - 15 > 0x9B)
    {
      v11 = 1;
    }
    else
    {
      if (v45[0] - 120 <= 0x32)
        llvm::reportInvalidSizeRequest((llvm *)"Possible incorrect use of MVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use MVT::getVectorElementCount() instead", v10);
      v11 = sub_1C47F381C(v45);
    }
    v12 = __clz(v8);
    if (v8 <= v11)
    {
      v15 = 0;
      v14 = 0;
      v13 = 0;
    }
    else
    {
      v38 = v12;
      v39 = v7;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v40 = v11;
      do
      {
        v16 = a4;
        v17 = v5;
        v8 = (llvm::Type *)(v8 >> 1);
        llvm::FixedVectorType::get(v39, v8);
        v5 = (llvm::Type *)v18;
        v19 = (uint64_t)v17;
        a4 = v16;
        v20 = sub_1C61E85E4(a1, v19, v18);
        if (__OFADD__(v15, v20))
          v15 = ((uint64_t)(v15 + v20) >> 63) ^ 0x8000000000000000;
        else
          v15 += v20;
        sub_1C5121850(a1, a2);
        if (__OFADD__(v14, v21))
          v14 = ((uint64_t)(v14 + v21) >> 63) ^ 0x8000000000000000;
        else
          v14 += v21;
        --v13;
      }
      while (v8 > v40);
      v12 = v38;
    }
    v22 = 0;
    v23 = v13 - v12 + 31;
    v24 = 1;
    if (v5 && *((_BYTE *)v5 + 8) == 18)
      v22 = sub_1C61E84E8(a1, (uint64_t)v5);
    v42 = v22;
    v43 = v24;
    v46 = v23;
    v47 = 0;
    sub_1C4848B64((uint64_t)&v46, (uint64_t)&v42);
    if (__OFADD__(v15, v46))
      v25 = ((uint64_t)(v15 + v46) >> 63) ^ 0x8000000000000000;
    else
      v25 = v15 + v46;
    sub_1C5121850(a1, a2);
    v42 = v26;
    v43 = v27;
    v46 = v23;
    v47 = 0;
    sub_1C4848B64((uint64_t)&v46, (uint64_t)&v42);
    v28 = v14 + v46;
    if (__OFADD__(v14, v46))
      v28 = ((uint64_t)(v14 + v46) >> 63) ^ 0x8000000000000000;
    v31 = __OFADD__(v25, v28);
    v29 = v25 + v28;
    if (v31)
      v30 = (v29 >> 63) ^ 0x8000000000000000;
    else
      v30 = v29;
    if ((*((_DWORD *)v5 + 2) & 0xFE) == 0x12)
      v5 = (llvm::Type *)**((_QWORD **)v5 + 2);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), (llvm::EVT **)v5, (uint64_t)&v46);
    v31 = __OFADD__(v30, v46);
    v32 = v30 + v46;
  }
  if (v31)
    return (v32 >> 63) ^ 0x8000000000000000;
  else
    return v32;
}

unint64_t sub_1C61E820C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  int v5;
  unsigned int v11;
  unint64_t v12;
  _QWORD *v13;
  llvm::EVT **v14;
  llvm::EVT **v15;
  uint64_t v17;

  v5 = *(_DWORD *)(a2 + 32);
  if (v5 < 1)
    return 0;
  v11 = 0;
  v12 = 0;
  do
  {
    if (*(_DWORD *)(a3 + 8) >= 0x41u)
      v13 = (_QWORD *)(*(_QWORD *)a3 + 8 * (v11 >> 6));
    else
      v13 = (_QWORD *)a3;
    if (((*v13 >> v11) & 1) != 0)
    {
      if (a4)
      {
        v14 = (llvm::EVT **)a2;
        if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
          v14 = **(llvm::EVT ****)(a2 + 16);
        llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v14, (uint64_t)&v17);
        if (__OFADD__(v12, v17))
          v12 = ((uint64_t)(v12 + v17) >> 63) ^ 0x8000000000000000;
        else
          v12 += v17;
      }
      if (a5)
      {
        v15 = (llvm::EVT **)a2;
        if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
          v15 = **(llvm::EVT ****)(a2 + 16);
        llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v15, (uint64_t)&v17);
        if (__OFADD__(v12, v17))
          v12 = ((uint64_t)(v12 + v17) >> 63) ^ 0x8000000000000000;
        else
          v12 += v17;
      }
    }
    ++v11;
  }
  while (v5 != v11);
  return v12;
}

unint64_t sub_1C61E835C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  unint64_t v10;
  unint64_t v11;

  v10 = sub_1C61E77EC(a1, a2, 1, 0);
  if (a4)
    v11 = sub_1C5124544(a1, a3, a4, a5);
  else
    v11 = sub_1C61E77EC(a1, a2, 0, 1);
  if (__OFADD__(v10, v11))
    return ((uint64_t)(v10 + v11) >> 63) ^ 0x8000000000000000;
  else
    return v10 + v11;
}

unint64_t sub_1C61E840C(uint64_t a1, uint64_t a2)
{
  llvm::TargetLoweringBase *v4;
  llvm::EVT **v5;
  unint64_t v6;
  int v7;
  llvm::EVT **v8;
  unint64_t v10;

  v4 = *(llvm::TargetLoweringBase **)(a1 + 24);
  v5 = (llvm::EVT **)a2;
  if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
    v5 = **(llvm::EVT ****)(a2 + 16);
  llvm::TargetLoweringBase::getTypeLegalizationCost(v4, *(const llvm::DataLayout **)(a1 + 8), v5, (uint64_t)&v10);
  v6 = v10;
  v7 = *(_DWORD *)(a2 + 32);
  if (v7 >= 1)
  {
    do
    {
      v8 = (llvm::EVT **)a2;
      if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
        v8 = **(llvm::EVT ****)(a2 + 16);
      llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v10);
      if (__OFADD__(v6, v10))
        v6 = ((uint64_t)(v6 + v10) >> 63) ^ 0x8000000000000000;
      else
        v6 += v10;
      --v7;
    }
    while (v7);
  }
  return v6;
}

unint64_t sub_1C61E84E8(uint64_t a1, uint64_t a2)
{
  int v2;
  unint64_t v5;
  llvm::EVT **v6;
  unint64_t v7;
  llvm::EVT **v8;
  uint64_t v10;

  v2 = *(_DWORD *)(a2 + 32);
  if (v2 < 1)
    return 0;
  v5 = 0;
  do
  {
    v6 = (llvm::EVT **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
      v6 = **(llvm::EVT ****)(a2 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v6, (uint64_t)&v10);
    if (__OFADD__(v5, v10))
      v7 = ((uint64_t)(v5 + v10) >> 63) ^ 0x8000000000000000;
    else
      v7 = v5 + v10;
    v8 = (llvm::EVT **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
      v8 = **(llvm::EVT ****)(a2 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v10);
    if (__OFADD__(v7, v10))
      v5 = ((uint64_t)(v7 + v10) >> 63) ^ 0x8000000000000000;
    else
      v5 = v7 + v10;
    --v2;
  }
  while (v2);
  return v5;
}

unint64_t sub_1C61E85E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  unint64_t v7;
  llvm::EVT **v8;
  unint64_t v9;
  llvm::EVT **v10;
  uint64_t v12;

  v3 = *(_DWORD *)(a3 + 32);
  if (!v3)
    return 0;
  v7 = 0;
  do
  {
    v8 = (llvm::EVT **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
      v8 = **(llvm::EVT ****)(a2 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v12);
    if (__OFADD__(v7, v12))
      v9 = ((uint64_t)(v7 + v12) >> 63) ^ 0x8000000000000000;
    else
      v9 = v7 + v12;
    v10 = (llvm::EVT **)a3;
    if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12)
      v10 = **(llvm::EVT ****)(a3 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v10, (uint64_t)&v12);
    if (__OFADD__(v9, v12))
      v7 = ((uint64_t)(v9 + v12) >> 63) ^ 0x8000000000000000;
    else
      v7 = v9 + v12;
    --v3;
  }
  while (v3);
  return v7;
}

unint64_t sub_1C61E86E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  unint64_t v7;
  llvm::EVT **v8;
  unint64_t v9;
  llvm::EVT **v10;
  uint64_t v12;

  v3 = *(_DWORD *)(a3 + 32);
  if (!v3)
    return 0;
  v7 = 0;
  do
  {
    v8 = (llvm::EVT **)a3;
    if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12)
      v8 = **(llvm::EVT ****)(a3 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v12);
    if (__OFADD__(v7, v12))
      v9 = ((uint64_t)(v7 + v12) >> 63) ^ 0x8000000000000000;
    else
      v9 = v7 + v12;
    v10 = (llvm::EVT **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12)
      v10 = **(llvm::EVT ****)(a2 + 16);
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v10, (uint64_t)&v12);
    if (__OFADD__(v9, v12))
      v7 = ((uint64_t)(v9 + v12) >> 63) ^ 0x8000000000000000;
    else
      v7 = v9 + v12;
    --v3;
  }
  while (v3);
  return v7;
}

void sub_1C61E87EC(llvm::OptimizationRemarkEmitter *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  char *v7;
  _QWORD v8[2];
  _QWORD v9[10];
  void *v10;
  unsigned int v11;
  _QWORD v12[35];

  v12[34] = *MEMORY[0x1E0C80C00];
  v8[0] = a2;
  v8[1] = a3;
  v4 = ****(_QWORD ****)a1;
  if (*(_QWORD *)(v4 + 128)
    || (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v4 + 72) + 48))(*(_QWORD *)(v4 + 72)))
  {
    sub_1C51247C0(v9, (uint64_t)v8);
    llvm::OptimizationRemarkEmitter::emit(a1, (llvm::DiagnosticInfoOptimizationBase *)v9);
    v9[0] = &off_1E814E790;
    v5 = v10;
    if (v11)
    {
      v6 = (unint64_t)v11 << 6;
      v7 = (char *)v10 - 64;
      do
      {
        sub_1C4765530((uint64_t)&v7[v6]);
        v6 -= 64;
      }
      while (v6);
      v5 = v10;
    }
    if (v5 != v12)
      free(v5);
  }
}

unint64_t sub_1C61E88D8(uint64_t a1, uint64_t a2, llvm::Type ***a3, uint64_t a4)
{
  llvm::TargetLoweringBase *v8;
  llvm::EVT **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v8 = *(llvm::TargetLoweringBase **)(a1 + 24);
  v9 = (llvm::EVT **)a4;
  if ((*(_DWORD *)(a4 + 8) & 0xFE) == 0x12)
    v9 = **(llvm::EVT ****)(a4 + 16);
  llvm::TargetLoweringBase::getTypeLegalizationCost(v8, *(const llvm::DataLayout **)(a1 + 8), v9, (uint64_t)&v13);
  v10 = v13;
  v11 = sub_1C5121DC4(a1, a2, a3, *(llvm::Type ****)(a4 + 24), 0, 0, 0);
  if (__OFADD__(v10, v11))
    return ((v10 + v11) >> 63) ^ 0x8000000000000000;
  else
    return v10 + v11;
}

unint64_t sub_1C61E8988(uint64_t a1, int a2, int a3, llvm::FixedVectorType *a4, uint64_t a5, uint64_t a6)
{
  llvm::FixedVectorType **v11;
  llvm::Type ***v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD v21[2];
  uint64_t v22;
  int v23;

  llvm::VectorType::get(a4, (llvm::Type *)(*(unsigned int *)(a5 + 32) | ((unint64_t)(*(_BYTE *)(a5 + 8) == 19) << 32)));
  v12 = (llvm::Type ***)v11;
  v13 = sub_1C61E7EC8(a1, 13, v11, a6);
  if (a3)
    v14 = 39;
  else
    v14 = 40;
  v15 = sub_1C5121DC4(a1, v14, v12, (llvm::Type ***)a5, 0, a6, 0);
  v21[0] = v15;
  v21[1] = v16;
  if (a2)
  {
    sub_1C5121850(a1, 17);
    v18 = v17;
    v22 = 2;
    v23 = 0;
    sub_1C4848B64((uint64_t)v21, (uint64_t)&v22);
    v15 = v21[0];
  }
  else
  {
    v18 = 0;
  }
  v19 = v13 + v18;
  if (__OFADD__(v13, v18))
    v19 = ((uint64_t)(v13 + v18) >> 63) ^ 0x8000000000000000;
  if (__OFADD__(v19, v15))
    return ((uint64_t)(v19 + v15) >> 63) ^ 0x8000000000000000;
  else
    return v19 + v15;
}

void llvm::initializeLocalStackSlotPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F9470);
  if (v2 != -1)
  {
    v5[0] = sub_1C51251F4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F9470, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

BOOL sub_1C61E8B34(uint64_t a1, int *a2)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v8;
  unsigned __int8 v9;

  sub_1C49CE3B4(a1, a2, (uint64_t)&v8);
  v4 = v9;
  if (v9)
  {
    v5 = *a2;
    v6 = *(unsigned int *)(a1 + 48);
    if (v6 >= *(_DWORD *)(a1 + 52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 40, a1 + 56, v6 + 1, 4);
      LODWORD(v6) = *(_DWORD *)(a1 + 48);
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v6) = v5;
    ++*(_DWORD *)(a1 + 48);
  }
  return v4 != 0;
}

uint64_t llvm::getMVTForLLT(unint64_t a1)
{
  const char *v1;
  int v2;
  char v3;
  const char *v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  char v13;
  char v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;

  v18 = a1;
  if ((a1 & 0xFFFFFFFFFFFFFFF9) != 0 && (a1 & 4) != 0)
  {
    v17 = sub_1C492E6FC(&v18);
    v2 = sub_1C4825F50((unint64_t *)&v17);
    if ((_DWORD)v1 == 1)
    if (v2 > 31)
    {
      v13 = 6;
      v14 = 7;
      if (v2 != 128)
        v14 = 0;
      if (v2 != 64)
        v13 = v14;
      if (v2 == 32)
        v3 = 5;
      else
        v3 = v13;
    }
    else
    {
      switch(v2)
      {
        case 1:
          v3 = 2;
          break;
        case 8:
          v3 = 3;
          break;
        case 16:
          v3 = 4;
          break;
        default:
          v3 = 0;
          break;
      }
    }
    v15 = v18;
    v16 = 0x800000000000000;
    if ((v18 & 2) == 0)
      v16 = 0x8000000000000;
    if ((v16 & v18) != 0)
    {
      llvm::reportInvalidSizeRequest((llvm *)"Possible incorrect use of LLT::getNumElements() for scalable vector. Scalable flag may be dropped, use LLT::getElementCount() instead", v1);
      v15 = v18;
    }
    return sub_1C47AC934(v3, (unsigned __int16)(v15 >> 3));
  }
  else
  {
    v5 = sub_1C4825F50(&v18);
    if ((_DWORD)v4 == 1)
    if (v5 == 128)
      v6 = 7;
    else
      v6 = 0;
    if (v5 == 64)
      v7 = 6;
    else
      v7 = v6;
    if (v5 == 32)
      v8 = 5;
    else
      v8 = v7;
    if (v5 == 16)
      v9 = 4;
    else
      v9 = 0;
    if (v5 == 8)
      v10 = 3;
    else
      v10 = v9;
    if (v5 == 1)
      v11 = 2;
    else
      v11 = v10;
    if (v5 <= 31)
      return v11;
    else
      return v8;
  }
}

unint64_t llvm::getApproximateEVTForLLT(unint64_t a1, uint64_t a2, llvm::LLVMContext *a3)
{
  const char *v4;
  llvm::LLVMContext *v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t ApproximateEVTForLLT;
  uint64_t v11;
  unint64_t v12;

  v12 = a1;
  if ((a1 & 0xFFFFFFFFFFFFFFF9) != 0 && (a1 & 4) != 0)
  {
    v8 = sub_1C492E6FC(&v12);
    ApproximateEVTForLLT = llvm::getApproximateEVTForLLT(v8, a2, a3);
    v11 = 0x800000000000000;
    if ((v12 & 2) == 0)
      v11 = 0x8000000000000;
    return sub_1C47AC578(a3, ApproximateEVTForLLT, v9, (llvm::Type *)((unsigned __int16)(v12 >> 3) | ((unint64_t)((v11 & v12) != 0) << 32)));
  }
  else
  {
    v5 = (llvm::LLVMContext *)sub_1C4825F50(&v12);
    if ((_DWORD)v4 == 1)
    return sub_1C4815B1C(a3, v5);
  }
}

void *llvm::getFltSemanticForLLT(unint64_t a1)
{
  llvm::APFloatBase *v1;
  const char *v2;
  uint64_t v3;
  __int128 v4;
  llvm::APFloatBase *v6;
  unint64_t v7;

  v7 = a1;
  v1 = (llvm::APFloatBase *)sub_1C4825F50(&v7);
  if ((_DWORD)v2 == 1)
  {
    v6 = v1;
    v1 = v6;
  }
  *((_QWORD *)&v4 + 1) = v1;
  *(_QWORD *)&v4 = (char *)v1 - 16;
  v3 = v4 >> 4;
  switch(v3)
  {
    case 1:
      return llvm::APFloatBase::IEEEsingle(v1);
    case 7:
      return llvm::APFloatBase::IEEEquad(v1);
    case 3:
      return llvm::APFloatBase::IEEEdouble(v1);
  }
  return llvm::APFloatBase::IEEEhalf(v1);
}

uint64_t llvm::createLowerEmuTLSPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C5126828(v1);
}

unint64_t llvm::MachineBasicBlock::getEndSymbol(llvm::MachineBasicBlock *this)
{
  unint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10[4];
  __int16 v11;
  const char *v12;
  __int16 v13;
  uint64_t v14[4];
  __int16 v15;
  const char *v16;
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  uint64_t v20[5];
  uint64_t v21[5];
  uint64_t v22[5];
  _BYTE v23[40];

  result = *((_QWORD *)this + 28);
  if (!result)
  {
    v3 = *((_QWORD *)this + 4);
    v4 = *(_QWORD *)(v3 + 24);
    v5 = *(_QWORD *)(v4 + 152);
    v7 = *(_QWORD *)(v5 + 104);
    v6 = *(_QWORD *)(v5 + 112);
    v19 = 261;
    v18[0] = v7;
    v18[1] = v6;
    v16 = "BB_END";
    v17 = 259;
    sub_1C4825FE4(v18, (uint64_t *)&v16, (uint64_t)v20);
    v8 = *(_DWORD *)(v3 + 336);
    v15 = 264;
    LODWORD(v14[0]) = v8;
    sub_1C4825FE4(v20, v14, (uint64_t)v21);
    v12 = "_";
    v13 = 259;
    sub_1C4825FE4(v21, (uint64_t *)&v12, (uint64_t)v22);
    v9 = *((_DWORD *)this + 6);
    v11 = 265;
    LODWORD(v10[0]) = v9;
    sub_1C4825FE4(v22, v10, (uint64_t)v23);
    result = llvm::MCContext::getOrCreateSymbol(v4, (uint64_t)v23);
    *((_QWORD *)this + 28) = result;
  }
  return result;
}

void llvm::MachineBasicBlock::print(llvm::MachineBasicBlock *this, llvm::raw_ostream *a2, const llvm::SlotIndexes *a3, int a4)
{
  const llvm::Function **v5;
  llvm::raw_ostream *v6;
  const llvm::Function *v10;
  uint64_t v11;
  llvm::SlotTracker *v12[2];
  BOOL v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = (const llvm::Function **)*((_QWORD *)this + 4);
  if (v5)
  {
    v10 = *v5;
    v11 = *((_QWORD *)*v5 + 5);
    v12[0] = (llvm::SlotTracker *)&off_1E814DC18;
    v12[1] = 0;
    v13 = v11 != 0;
    v14 = 1;
    v19 = 0;
    v18 = 0;
    v16 = 0;
    v17 = 0;
    v15 = v11;
    llvm::ModuleSlotTracker::incorporateFunction(v12, v10);
    llvm::MachineBasicBlock::print(this, a2, v12, a3, a4);
    llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v12);
  }
  else
  {
    v6 = sub_1C4816AD8(a2, "Can't print out MachineBasicBlock because parent MachineFunction");
    sub_1C4816AD8(v6, " is null\n");
  }
}

BOOL llvm::MachineBasicBlock::hasEHPadSuccessor(llvm::MachineBasicBlock *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _BOOL8 result;
  BOOL v5;

  v2 = *((_QWORD *)this + 11);
  v1 = *((_QWORD *)this + 12);
  if (v2 == v1)
    return 0;
  v3 = v2 + 8;
  do
  {
    result = *(_BYTE *)(*(_QWORD *)(v3 - 8) + 184) != 0;
    if (*(_BYTE *)(*(_QWORD *)(v3 - 8) + 184))
      v5 = 1;
    else
      v5 = v3 == v1;
    v3 += 8;
  }
  while (!v5);
  return result;
}

BOOL llvm::MachineBasicBlock::isEntryBlock(llvm::MachineBasicBlock *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 4) + 328) == (_QWORD)this;
}

void llvm::MachineBasicBlock::dump(llvm::MachineBasicBlock *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  llvm::MachineBasicBlock::print(this, v2, 0, 1);
}

BOOL llvm::MachineBasicBlock::mayHaveInlineAsmBr(llvm::MachineBasicBlock *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _BOOL8 result;
  BOOL v5;

  v2 = *((_QWORD *)this + 11);
  v1 = *((_QWORD *)this + 12);
  if (v2 == v1)
    return 0;
  v3 = v2 + 8;
  do
  {
    result = *(_BYTE *)(*(_QWORD *)(v3 - 8) + 202) != 0;
    if (*(_BYTE *)(*(_QWORD *)(v3 - 8) + 202))
      v5 = 1;
    else
      v5 = v3 == v1;
    v3 += 8;
  }
  while (!v5);
  return result;
}

char *llvm::MachineBasicBlock::getName(llvm::MachineBasicBlock *this)
{
  llvm::Value *v1;

  v1 = (llvm::Value *)*((_QWORD *)this + 2);
  if (v1)
    return llvm::Value::getName(v1);
  else
    return (char *)&unk_1C86ACCDB;
}

llvm::raw_ostream *llvm::MachineBasicBlock::printAsOperand(llvm::MachineBasicBlock *this, llvm::raw_ostream *a2)
{
  _BYTE *v4;
  llvm::raw_ostream *v5;

  v4 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v4 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 37);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v4 + 1;
    *v4 = 37;
  }
  v5 = sub_1C4816AD8(a2, "bb.");
  return llvm::raw_ostream::operator<<(v5, *((int *)this + 6));
}

uint64_t llvm::MachineBasicBlock::addLiveIn(_QWORD *a1, int a2, uint64_t a3)
{
  __int16 v6;
  unsigned __int16 *v7;
  void **v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t VirtualRegister;
  llvm::MachineFunction *v16;
  llvm::MachineInstr *v17;
  _OWORD *v18;
  _OWORD *v19;
  unsigned __int8 *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;

  v6 = a2;
  v7 = (unsigned __int16 *)a1[19];
  v8 = (void **)(a1 + 19);
  while (1)
  {
    if (v7 == (unsigned __int16 *)a1[20])
    {
      v9 = 0;
      goto LABEL_6;
    }
    if (*v7 == (unsigned __int16)a2)
      break;
    v7 += 8;
  }
  v9 = *((_QWORD *)v7 + 1) != 0;
LABEL_6:
  v10 = llvm::MachineBasicBlock::SkipPHIsAndLabels((uint64_t)a1, a1[7]);
  v11 = a1[4];
  v12 = *(_QWORD **)(v11 + 40);
  v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 16) + 104))(*(_QWORD *)(v11 + 16));
  if (v9 && a1 + 6 != (_QWORD *)v10)
  {
    while (**(_WORD **)(v10 + 16) == 19)
    {
      v14 = *(_QWORD *)(v10 + 32);
      if (*(_DWORD *)(v14 + 36) == a2)
      {
        VirtualRegister = *(unsigned int *)(v14 + 4);
        llvm::MachineRegisterInfo::constrainRegClass(v12, *(_DWORD *)(v14 + 4), a3, 0);
        return VirtualRegister;
      }
      if ((*(_BYTE *)v10 & 4) == 0)
      {
        while ((*(_WORD *)(v10 + 44) & 8) != 0)
          v10 = *(_QWORD *)(v10 + 8);
      }
      v10 = *(_QWORD *)(v10 + 8);
      if ((_QWORD *)v10 == a1 + 6)
      {
        v10 = (uint64_t)(a1 + 6);
        break;
      }
    }
  }
  VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister((uint64_t)v12, a3, (unsigned __int8 *)&unk_1C86ACCDB, 0);
  v21 = 0;
  v16 = sub_1C4787570((uint64_t)a1, (unint64_t *)v10, &v21, *(_QWORD *)(v13 + 8) + 912, VirtualRegister);
  *((_QWORD *)&v22 + 1) = 0;
  v23 = 0;
  v24 = 0;
  LODWORD(v22) = 0x4000000;
  DWORD1(v22) = a2;
  llvm::MachineInstr::addOperand(v17, v16, (const llvm::MachineOperand *)&v22);
  if (v21)
    llvm::MetadataTracking::untrack((uint64_t)&v21, v21);
  if (!v9)
  {
    LOWORD(v22) = v6;
    *((_QWORD *)&v22 + 1) = -1;
    v18 = (_OWORD *)a1[20];
    if ((unint64_t)v18 >= a1[21])
    {
      v19 = sub_1C51140B0(v8, &v22);
    }
    else
    {
      *v18 = v22;
      v19 = v18 + 1;
    }
    a1[20] = v19;
  }
  return VirtualRegister;
}

llvm::MachineBasicBlock *llvm::MachineBasicBlock::moveBefore(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2)
{
  llvm::MachineBasicBlock *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2 != this)
  {
    v2 = (llvm::MachineBasicBlock *)*((_QWORD *)this + 1);
    if (v2 != a2 && v2 != this)
    {
      v4 = *(_QWORD *)v2;
      v5 = *(_QWORD *)this;
      *(_QWORD *)(v5 + 8) = v2;
      *(_QWORD *)v2 = v5;
      v6 = *(_QWORD *)a2;
      *(_QWORD *)(v4 + 8) = a2;
      *(_QWORD *)this = v6;
      *(_QWORD *)(v6 + 8) = this;
      *(_QWORD *)a2 = v4;
    }
  }
  return this;
}

uint64_t *llvm::MachineBasicBlock::moveAfter(uint64_t *this, llvm::MachineBasicBlock *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = (uint64_t *)*((_QWORD *)a2 + 1);
  v3 = (uint64_t *)this[1];
  if (v2 != this && v3 != v2 && v3 != this)
  {
    v6 = *v3;
    v7 = *this;
    *(_QWORD *)(v7 + 8) = v3;
    *v3 = v7;
    v8 = *v2;
    *(_QWORD *)(v6 + 8) = v2;
    *this = v8;
    *(_QWORD *)(v8 + 8) = this;
    *v2 = v6;
  }
  return this;
}

char *llvm::MachineBasicBlock::findBranchDebugLoc@<X0>(llvm::MachineBasicBlock *this@<X0>, unsigned __int8 **a2@<X8>)
{
  char *result;
  char *v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  llvm::DILocation *v14;
  const llvm::DILocation *v15;
  const llvm::DILocation *v16;
  llvm::DILocation *MergedLocation;
  uint64_t v18;
  unsigned __int8 *v19;

  *a2 = 0;
  result = (char *)llvm::MachineBasicBlock::getFirstTerminator(this);
  v5 = (char *)this + 48;
  if (v5 != result)
  {
    v6 = (uint64_t)result;
    do
    {
      v7 = *(_WORD *)(v6 + 44);
      v8 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8);
      if ((v7 & 0xC) != 0 && (v7 & 4) == 0)
      {
        v10 = v6;
        if ((v8 & 0x400) != 0)
        {
LABEL_16:
          result = (char *)sub_1C47C0F04(a2, (unsigned __int8 **)(v6 + 56));
          if ((*(_BYTE *)v6 & 4) == 0)
          {
            while ((*(_WORD *)(v6 + 44) & 8) != 0)
              v6 = *(_QWORD *)(v6 + 8);
          }
          v11 = *(_QWORD *)(v6 + 8);
          while (2)
          {
            if ((char *)v11 == v5)
              return result;
            v12 = *(_QWORD *)(*(_QWORD *)(v11 + 16) + 8);
            if ((*(_WORD *)(v11 + 44) & 0xC) != 0 && (*(_WORD *)(v11 + 44) & 4) == 0)
            {
              v18 = v11;
              if ((v12 & 0x400) != 0)
                goto LABEL_26;
              while ((*(_WORD *)(v18 + 44) & 8) != 0)
              {
                v18 = *(_QWORD *)(v18 + 8);
                if ((*(_BYTE *)(*(_QWORD *)(v18 + 16) + 9) & 4) != 0)
                  goto LABEL_26;
              }
            }
            else if ((v12 & 0x400) != 0)
            {
LABEL_26:
              v14 = (llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)a2);
              v15 = (const llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)(v11 + 56));
              MergedLocation = llvm::DILocation::getMergedLocation(v14, v15, v16);
              llvm::DebugLoc::DebugLoc((llvm::DebugLoc *)&v19, MergedLocation);
              result = (char *)sub_1C49264C4(a2, &v19);
              if (v19)
                result = (char *)llvm::MetadataTracking::untrack((uint64_t)&v19, v19);
            }
            if ((*(_BYTE *)v11 & 4) == 0)
            {
              while ((*(_WORD *)(v11 + 44) & 8) != 0)
                v11 = *(_QWORD *)(v11 + 8);
            }
            v11 = *(_QWORD *)(v11 + 8);
            continue;
          }
        }
        while ((*(_WORD *)(v10 + 44) & 8) != 0)
        {
          v10 = *(_QWORD *)(v10 + 8);
          if ((*(_BYTE *)(*(_QWORD *)(v10 + 16) + 9) & 4) != 0)
            goto LABEL_16;
        }
      }
      else if ((v8 & 0x400) != 0)
      {
        goto LABEL_16;
      }
      if ((v7 & 8) != 0 && (*(_QWORD *)v6 & 4) == 0)
      {
        do
          v6 = *(_QWORD *)(v6 + 8);
        while ((*(_WORD *)(v6 + 44) & 8) != 0);
      }
      v6 = *(_QWORD *)(v6 + 8);
    }
    while ((char *)v6 != v5);
  }
  return result;
}

char *llvm::MachineBasicBlock::transferSuccessors(char *this, llvm::MachineBasicBlock *a2)
{
  llvm::MachineBasicBlock **v3;
  char *v4;
  llvm::MachineBasicBlock *v5;
  int *v6;
  char *v7;
  char *v8;

  if (this != (char *)a2)
  {
    v3 = (llvm::MachineBasicBlock **)*((_QWORD *)a2 + 11);
    if (v3 != *((llvm::MachineBasicBlock ***)a2 + 12))
    {
      v4 = this;
      do
      {
        v5 = *v3;
        v6 = (int *)*((_QWORD *)a2 + 14);
        if (v6 == *((int **)a2 + 15))
          llvm::MachineBasicBlock::addSuccessorWithoutProb(v4, v5);
        else
          llvm::MachineBasicBlock::addSuccessor(v4, v5, *v6);
        v7 = (char *)*((_QWORD *)a2 + 11);
        v8 = (char *)*((_QWORD *)a2 + 12);
        if (v7 != v8)
        {
          while (*(llvm::MachineBasicBlock **)v7 != v5)
          {
            v7 += 8;
            if (v7 == v8)
            {
              v7 = (char *)*((_QWORD *)a2 + 12);
              break;
            }
          }
        }
        this = llvm::MachineBasicBlock::removeSuccessor((uint64_t)a2, v7, 0);
        v3 = (llvm::MachineBasicBlock **)*((_QWORD *)a2 + 11);
      }
      while (v3 != *((llvm::MachineBasicBlock ***)a2 + 12));
    }
  }
  return this;
}

BOOL llvm::MachineBasicBlock::canFallThrough(llvm::MachineBasicBlock *this)
{
  return llvm::MachineBasicBlock::getFallThrough(this) != 0;
}

uint64_t sub_1C61E969C(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  result = sub_1C512C5A4(*(_QWORD *)(a1 + 288), a2);
  v4 = *(unsigned int *)(a1 + 448);
  v5 = *(unsigned int *)(a1 + 608);
  if (v5 >= *(_DWORD *)(a1 + 612))
  {
    result = (uint64_t)llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 600, a1 + 616, v5 + 1, 8);
    LODWORD(v5) = *(_DWORD *)(a1 + 608);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 600) + 8 * v5) = v4;
  ++*(_DWORD *)(a1 + 608);
  return result;
}

void llvm::MachineBasicBlock::ReplaceUsesOfBlockWith(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3)
{
  llvm::MachineBasicBlock *v3;
  llvm::MachineBasicBlock *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  llvm::MachineBasicBlock *v12;

  v3 = (llvm::MachineBasicBlock *)((char *)this + 48);
  v4 = (llvm::MachineBasicBlock *)*((_QWORD *)this + 7);
  if ((llvm::MachineBasicBlock *)((char *)this + 48) == v4)
    goto LABEL_21;
  while (1)
  {
    v3 = (llvm::MachineBasicBlock *)(*(_QWORD *)v3 & 0xFFFFFFFFFFFFFFF8);
    v5 = *(_QWORD *)(*((_QWORD *)v3 + 2) + 8);
    if ((*((_WORD *)v3 + 22) & 0xC) == 0 || (*((_WORD *)v3 + 22) & 4) != 0)
    {
      if ((v5 & 0x200) == 0)
        goto LABEL_21;
      goto LABEL_7;
    }
    if ((v5 & 0x200) == 0)
      break;
LABEL_7:
    v7 = *((unsigned int *)v3 + 10);
    if ((_DWORD)v7)
    {
      v8 = 0;
      v9 = 32 * v7;
      do
      {
        v10 = *((_QWORD *)v3 + 4);
        if (*(_BYTE *)(v10 + v8) == 4)
        {
          v11 = v10 + v8;
          if (*(llvm::MachineBasicBlock **)(v11 + 16) == a2)
            *(_QWORD *)(v11 + 16) = a3;
        }
        v8 += 32;
      }
      while (v9 != v8);
      v4 = (llvm::MachineBasicBlock *)*((_QWORD *)this + 7);
    }
    if (v4 == v3)
      goto LABEL_21;
  }
  v12 = v3;
  while ((*((_WORD *)v12 + 22) & 8) != 0)
  {
    v12 = (llvm::MachineBasicBlock *)*((_QWORD *)v12 + 1);
    if ((*(_BYTE *)(*((_QWORD *)v12 + 2) + 9) & 2) != 0)
      goto LABEL_7;
  }
LABEL_21:
  llvm::MachineBasicBlock::replaceSuccessor(this, a2, a3);
}

__n128 sub_1C61E97B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 *v8;
  __n128 *v9;
  __n128 result;
  _QWORD v11[3];

  sub_1C4774094((llvm::SmallPtrSetImplBase *)(a1 + 1032), a4);
  v11[0] = a2;
  v11[1] = a3;
  v11[2] = a4;
  v8 = (__n128 *)sub_1C4DC1E54(a1 + 248, (unint64_t)v11);
  v9 = (__n128 *)(*(_QWORD *)(a1 + 248) + 24 * *(unsigned int *)(a1 + 256));
  result = *v8;
  v9[1].n128_u64[0] = v8[1].n128_u64[0];
  *v9 = result;
  ++*(_DWORD *)(a1 + 256);
  return result;
}

llvm::MachineInstr *llvm::MachineBasicBlock::remove_instr(llvm::MachineBasicBlock *this, llvm::MachineInstr *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = sub_1C512C844((uint64_t)a2);
  *((_WORD *)a2 + 22) &= 0xFFF3u;
  llvm::ilist_traits<llvm::MachineInstr>::removeNodeFromList(v3, (uint64_t)a2);
  v4 = (unint64_t *)*((_QWORD *)a2 + 1);
  v5 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFF8;
  *v4 = v5 | *v4 & 7;
  *(_QWORD *)(v5 + 8) = v4;
  *(_QWORD *)a2 &= 7uLL;
  *((_QWORD *)a2 + 1) = 0;
  return a2;
}

_QWORD *llvm::MachineBasicBlock::setSuccProbability(_QWORD *result, uint64_t a2, int a3)
{
  uint64_t v3;

  v3 = result[14];
  if (v3 != result[15])
    *(_DWORD *)(v3 + ((a2 - result[11]) >> 1)) = a3;
  return result;
}

uint64_t llvm::MachineBasicBlock::clearLiveIns(uint64_t this)
{
  *(_QWORD *)(this + 160) = *(_QWORD *)(this + 152);
  return this;
}

uint64_t llvm::MachineBasicBlock::liveout_begin@<X0>(llvm::MachineBasicBlock *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  uint64_t PersonalityFn;

  v4 = *((_QWORD *)this + 4);
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 16) + 120))(*(_QWORD *)(v4 + 16));
  if ((*(_WORD *)(*(_QWORD *)v4 + 18) & 8) != 0)
  {
    PersonalityFn = llvm::Function::getPersonalityFn(*(llvm::Function **)v4);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 712))(v5, PersonalityFn);
    v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 720))(v5, PersonalityFn);
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  return sub_1C512E018(a2, (uint64_t)this, v7, v6, 0);
}

uint64_t sub_1C61E9970(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t *v3;
  uint64_t *i;
  uint64_t v5;
  uint64_t v6;

  v1 = (uint64_t *)a1[1];
  if (a1[3] != *(_QWORD *)(*v1 + 160))
    return 1;
  v3 = (uint64_t *)a1[2];
  for (i = v1 + 1; ; ++i)
  {
    a1[1] = i;
    if (i == v3)
      break;
    v5 = *i;
    v6 = *(_QWORD *)(v5 + 152);
    if (v6 != *(_QWORD *)(v5 + 160))
    {
      a1[3] = v6;
      return 1;
    }
  }
  return 0;
}

unsigned __int16 *sub_1C61E99C4(unsigned __int16 *a1)
{
  unsigned __int16 *v2;
  int v3;

  *((_QWORD *)a1 + 3) += 16;
  if (sub_1C61E9970(a1))
  {
    do
    {
      if (!*(_BYTE *)(**((_QWORD **)a1 + 1) + 184))
        break;
      v2 = (unsigned __int16 *)*((_QWORD *)a1 + 3);
      v3 = *v2;
      if (v3 != *a1 && v3 != a1[1])
        break;
      *((_QWORD *)a1 + 3) = v2 + 8;
    }
    while ((sub_1C61E9970(a1) & 1) != 0);
  }
  return a1;
}

void llvm::initializeMachineBlockFrequencyInfoPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F4F0);
  if (v2 != -1)
  {
    v5[0] = sub_1C512ED4C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F4F0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::MachineBlockFrequencyInfo *llvm::MachineBlockFrequencyInfo::MachineBlockFrequencyInfo(llvm::MachineBlockFrequencyInfo *this)
{
  llvm::PassRegistry *v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = (llvm::PassRegistry *)sub_1C4776848((uint64_t)this, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  *(_QWORD *)v2 = &off_1E8143F80;
  *((_QWORD *)v2 + 31) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  v3 = atomic_load(&qword_1ED82F4F0);
  if (v3 != -1)
  {
    v7[0] = sub_1C512ED4C;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F4F0, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void *llvm::MachineBlockFrequencyInfo::getAnalysisUsage(llvm::MachineBlockFrequencyInfo *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBranchProbabilityInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineLoopInfo::ID);
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void llvm::MachineBlockFrequencyInfo::view(llvm::MachineBlockFrequencyInfo *this, const llvm::Twine *a2, char a3)
{
  _WORD v3[20];
  llvm::MachineBlockFrequencyInfo *v4;

  v4 = this;
  v3[16] = 257;
  sub_1C5131164((uint64_t)&v4, a2, a3, (llvm::Twine *)v3);
}

uint64_t *llvm::MachineBlockFrequencyInfo::getBlockProfileCount(llvm::MachineBlockFrequencyInfo *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t *result;

  result = (uint64_t *)*((_QWORD *)this + 31);
  if (result)
    return sub_1C61E9C8C((uint64_t)result, *(uint64_t ****)result[16], (uint64_t)a2, 0);
  return result;
}

uint64_t *sub_1C61E9C8C(uint64_t a1, uint64_t ***a2, uint64_t a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v10 = 0;
  if ((sub_1C4F763D4(*(_QWORD *)(a1 + 160), *(_DWORD *)(a1 + 176), a3, &v10) & 1) != 0
    && (v7 = *(unsigned int *)(v10 + 8), v7 != 0xFFFFFFFFLL))
  {
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24 * v7 + 16);
  }
  else
  {
    v8 = 0;
  }
  return llvm::BlockFrequencyInfoImplBase::getProfileCountFromFreq((llvm::BlockFrequencyInfoImplBase *)a1, a2, v8, a4);
}

uint64_t *****llvm::MachineBlockFrequencyInfo::getProfileCountFromFreq(llvm::MachineBlockFrequencyInfo *this, uint64_t a2)
{
  uint64_t *****result;

  result = (uint64_t *****)*((_QWORD *)this + 31);
  if (result)
    return (uint64_t *****)llvm::BlockFrequencyInfoImplBase::getProfileCountFromFreq((llvm::BlockFrequencyInfoImplBase *)result, *result[16], a2, 0);
  return result;
}

uint64_t llvm::MachineBlockFrequencyInfo::onEdgeSplit(llvm::MachineBlockFrequencyInfo *this, const llvm::MachineBasicBlock *a2, const llvm::MachineBasicBlock *a3, const llvm::MachineBranchProbabilityInfo *a4)
{
  uint64_t v8;
  unint64_t v9;
  int EdgeProbability;

  v8 = sub_1C51321FC(*((_QWORD *)this + 31), (uint64_t)a2);
  EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(a4, a2, a3);
  v9 = llvm::BranchProbability::scale((llvm::BranchProbability *)&EdgeProbability, v8);
  return sub_1C61E9DBC(*((_QWORD *)this + 31), (uint64_t)a3, v9);
}

uint64_t sub_1C61E9DBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  int v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v12;
  uint64_t v13;

  v12 = a2;
  v6 = a1 + 160;
  if (sub_1C4F763D4(*(_QWORD *)(a1 + 160), *(_DWORD *)(a1 + 176), a2, &v13))
  {
    v13 = 0;
    if (sub_1C4F763D4(*(_QWORD *)(a1 + 160), *(_DWORD *)(a1 + 176), a2, &v13))
      v7 = *(_DWORD *)(v13 + 8);
    else
      v7 = -1;
    LODWORD(v13) = v7;
  }
  else
  {
    LODWORD(v13) = -1431655765 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3);
    v8 = v13;
    *((_DWORD *)sub_1C5132A08(v6, &v12) + 2) = v8;
    v9 = *(_QWORD **)(a1 + 16);
    if ((unint64_t)v9 >= *(_QWORD *)(a1 + 24))
    {
      v10 = sub_1C5134800((void **)(a1 + 8));
    }
    else
    {
      v10 = v9 + 3;
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
    }
    *(_QWORD *)(a1 + 16) = v10;
  }
  return llvm::BlockFrequencyInfoImplBase::setBlockFreq(a1, (unsigned int *)&v13, a3);
}

uint64_t llvm::MachineBlockFrequencyInfo::getMBPI(llvm::MachineBlockFrequencyInfo *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 31);
  if (v1)
    return *(_QWORD *)(v1 + 112);
  else
    return 0;
}

llvm::raw_ostream *sub_1C61E9ECC(uint64_t a1, llvm::ScaledNumberBase *a2, uint64_t a3)
{
  int v5;
  int v7;
  uint64_t v8;

  v8 = 0;
  if (sub_1C4F763D4(*(_QWORD *)(a1 + 160), *(_DWORD *)(a1 + 176), a3, &v8))
    v5 = *(_DWORD *)(v8 + 8);
  else
    v5 = -1;
  v7 = v5;
  return llvm::BlockFrequencyInfoImplBase::printBlockFreq(a1, a2, &v7);
}

llvm::MachineBlockFrequencyInfo *llvm::callDefaultCtor<llvm::MachineBlockFrequencyInfo>()
{
  llvm::MachineBlockFrequencyInfo *v0;

  v0 = (llvm::MachineBlockFrequencyInfo *)operator new();
  return llvm::MachineBlockFrequencyInfo::MachineBlockFrequencyInfo(v0);
}

void sub_1C61E9F5C(uint64_t a1@<X0>, unsigned int *a2@<X1>, _QWORD *a3@<X8>)
{
  sub_1C61E9F70(a3, *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * *a2));
}

void sub_1C61E9F70(_QWORD *a1, uint64_t a2)
{
  int v4;
  llvm::Value *v5;
  char *Name;
  uint64_t v7;
  uint64_t *v8;
  const char *v9;
  __int16 v10;
  uint64_t v11[4];
  __int16 v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[5];
  uint64_t v16[4];
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  uint64_t v20[5];

  v18[0] = (uint64_t)"BB";
  v19 = 259;
  v4 = *(_DWORD *)(a2 + 24);
  v17 = 265;
  LODWORD(v16[0]) = v4;
  sub_1C4825FE4(v18, v16, (uint64_t)v20);
  if (*(_QWORD *)(a2 + 16))
  {
    v13 = "[";
    v14 = 259;
    sub_1C4825FE4(v20, (uint64_t *)&v13, (uint64_t)v15);
    v5 = *(llvm::Value **)(a2 + 16);
    if (v5)
    {
      Name = llvm::Value::getName(v5);
    }
    else
    {
      v7 = 0;
      Name = (char *)&unk_1C86ACCDB;
    }
    v12 = 261;
    v11[0] = (uint64_t)Name;
    v11[1] = v7;
    sub_1C4825FE4(v15, v11, (uint64_t)v16);
    v9 = "]";
    v10 = 259;
    sub_1C4825FE4(v16, (uint64_t *)&v9, (uint64_t)v18);
    v8 = v18;
  }
  else
  {
    v8 = v20;
  }
  llvm::Twine::str((llvm::Twine *)v8, a1);
}

uint64_t sub_1C61EA06C(uint64_t a1, uint64_t a2)
{
  int v3;
  int v5;
  uint64_t v6;

  v6 = 0;
  if (sub_1C4F763D4(*(_QWORD *)(a1 + 160), *(_DWORD *)(a1 + 176), a2, &v6))
    v3 = *(_DWORD *)(v6 + 8);
  else
    v3 = -1;
  v5 = v3;
  return llvm::BlockFrequencyInfoImplBase::getFloatingBlockFreq(a1, &v5);
}

void sub_1C61EA0CC(_WORD *a1, __int128 *a2, uint64_t *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7F9608, 0, 0);
  dword_1ED7F9688 = 0;
  qword_1ED7F9690 = (uint64_t)&unk_1E81349F0;
  unk_1ED7F9698 = 0;
  qword_1ED7F9608 = (uint64_t)&unk_1E8134938;
  qword_1ED7F96A0 = (uint64_t)&unk_1E81349A0;
  unk_1ED7F96A8 = &qword_1ED7F9608;
  qword_1ED7F96B0 = (uint64_t)&unk_1ED7F96C0;
  qword_1ED7F96B8 = 0x800000000;
  qword_1ED7F9840 = (uint64_t)&unk_1E8134B90;
  qword_1ED7F9858 = (uint64_t)&qword_1ED7F9840;
  sub_1C5132928(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F9608);
}

void sub_1C61EA184(_WORD *a1, __int128 *a2, uint64_t *a3)
{
  sub_1C47AD050((uint64_t)&llvm::ViewBlockLayoutWithBFI, 0, 0);
  dword_1ED82F318 = 0;
  qword_1ED82F320 = (uint64_t)&unk_1E81349F0;
  unk_1ED82F328 = 0;
  llvm::ViewBlockLayoutWithBFI = (uint64_t)&unk_1E8134938;
  qword_1ED82F330 = (uint64_t)&unk_1E81349A0;
  unk_1ED82F338 = &llvm::ViewBlockLayoutWithBFI;
  qword_1ED82F340 = (uint64_t)&unk_1ED82F350;
  qword_1ED82F348 = 0x800000000;
  qword_1ED82F4D0 = (uint64_t)&unk_1E8134B90;
  qword_1ED82F4E8 = (uint64_t)&qword_1ED82F4D0;
  sub_1C5132998(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::ViewBlockLayoutWithBFI);
}

void sub_1C61EA23C(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  __int16 v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  __int16 v10;
  unint64_t v11;
  __int16 v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  _QWORD *v21;
  char *v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  void *v28[3];
  uint64_t v29;
  __int16 v30;
  void *__p;
  char *v32;
  uint64_t v33[2];
  int v34;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t v37;
  void **v38;

  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_1C51335AC(a1, &v35);
  v2 = v35;
  if (v35 == v36)
    goto LABEL_2;
  v33[0] = 0;
  v33[1] = 0;
  v34 = 0;
  sub_1C617C408(&__p, v36 - v35);
  v29 = 0;
  v30 = 0;
  v3 = v35;
  if (v36 != v35)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    do
    {
      v28[0] = 0;
      v28[0] = (void *)v3[v7];
      sub_1C61BEB98(v33, v28)[1] = v7;
      v8 = sub_1C61EA06C(a1, (uint64_t)v28[0]);
      v9 = (char *)__p + v4;
      *(_QWORD *)v9 = v8;
      *((_WORD *)v9 + 4) = v10;
      v11 = sub_1C617C634(v6, v5, *(_QWORD *)((char *)__p + v4), *(_WORD *)((char *)__p + v4 + 8));
      v29 = v11;
      v5 = v12;
      v30 = v12;
      if (v12 < 0x4000)
      {
        v6 = v11;
      }
      else
      {
        v6 = -1;
        v29 = -1;
        v5 = 0x3FFF;
        v30 = 0x3FFF;
      }
      ++v7;
      v3 = v35;
      v4 += 16;
    }
    while (v7 < v36 - v35);
  }
  v13 = (char *)__p;
  v14 = v32;
  while (v13 != v14)
  {
    sub_1C4DB4640((uint64_t)v13, (uint64_t)&v29);
    v13 += 16;
  }
  memset(v28, 0, sizeof(v28));
  sub_1C5133AA4(a1, &v35, (uint64_t)v33, v28);
  sub_1C4DB4FE8(v28, (uint64_t *)&__p);
  v15 = *(_QWORD *)(a1 + 128);
  v16 = v15 + 320;
  v17 = *(_QWORD *)(v15 + 328);
  if (v17 != v15 + 320)
  {
    while (1)
    {
      v38 = 0;
      if ((sub_1C4F763D4(*(_QWORD *)(a1 + 160), *(_DWORD *)(a1 + 176), v17, &v38) & 1) == 0)
        goto LABEL_17;
      v18 = *((unsigned int *)v38 + 2);
      if (v18 == 0xFFFFFFFFLL)
        goto LABEL_17;
      if (!v34)
        goto LABEL_22;
      v19 = (v34 - 1) & ((v17 >> 4) ^ (v17 >> 9));
      v20 = *(_QWORD *)(v33[0] + 16 * v19);
      if (v17 != v20)
        break;
LABEL_21:
      v38 = (void **)v17;
      v21 = sub_1C61BEB98(v33, &v38);
      v22 = (char *)__p + 16 * v21[1];
      v23 = *(_QWORD *)(a1 + 8) + 24 * v18;
      v24 = *((_WORD *)v22 + 4);
      *(_QWORD *)v23 = *(_QWORD *)v22;
      *(_WORD *)(v23 + 8) = v24;
LABEL_17:
      v17 = *(_QWORD *)(v17 + 8);
      if (v17 == v16)
        goto LABEL_23;
    }
    v26 = 1;
    while (v20 != -4096)
    {
      v27 = v19 + v26++;
      v19 = v27 & (v34 - 1);
      v20 = *(_QWORD *)(v33[0] + 16 * v19);
      if (v17 == v20)
        goto LABEL_21;
    }
LABEL_22:
    v25 = *(_QWORD *)(a1 + 8) + 24 * v18;
    *(_QWORD *)v25 = 0;
    *(_WORD *)(v25 + 8) = 0;
    goto LABEL_17;
  }
LABEL_23:
  v38 = v28;
  sub_1C4DB60AC(&v38);
  if (__p)
  {
    v32 = (char *)__p;
    operator delete(__p);
  }
  MEMORY[0x1CAA32FB4](v33[0], 8);
  v2 = v35;
LABEL_2:
  if (v2)
  {
    v36 = v2;
    operator delete(v2);
  }
}

_DWORD *sub_1C61EA4EC(llvm::bfi_detail::IrreducibleGraph *this, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int v11;
  _DWORD *result;
  unsigned int v13;
  unsigned int v14;

  if (a2)
  {
    llvm::bfi_detail::IrreducibleGraph::addNodesInLoop((uint64_t)this, a2);
    v8 = *(unsigned int *)(a2 + 104);
    if ((_DWORD)v8)
    {
      v9 = *(unsigned int **)(a2 + 96);
      v10 = 4 * v8;
      do
      {
        v11 = *v9++;
        v14 = v11;
        sub_1C51333F4((uint64_t)this, &v14, a2, a3);
        v10 -= 4;
      }
      while (v10);
    }
  }
  else
  {
    llvm::bfi_detail::IrreducibleGraph::addNodesInFunction((uint64_t *)this);
    if (*(_QWORD *)(*(_QWORD *)this + 72) != *(_QWORD *)(*(_QWORD *)this + 64))
    {
      v5 = 1;
      do
      {
        v13 = v5 - 1;
        sub_1C51333F4((uint64_t)this, &v13, 0, a3);
      }
      while (0xAAAAAAAAAAAAAAABLL
            * ((uint64_t)(*(_QWORD *)(*(_QWORD *)this + 72) - *(_QWORD *)(*(_QWORD *)this + 64)) >> 3) > v5++);
    }
  }
  result = sub_1C617C220((_DWORD *)this + 12, (_DWORD *)this + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)result + 1);
  return result;
}

void sub_1C61EA5E0(uint64_t *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t *i;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;

  v4 = *(_QWORD *)(*(_QWORD *)(*a1 + 136) + 8 * *a3);
  v5 = *(uint64_t **)(v4 + 88);
  for (i = *(uint64_t **)(v4 + 96); v5 != i; ++v5)
  {
    v11 = *v5;
    v12 = *a1;
    v15 = 0;
    if (sub_1C4F763D4(*(_QWORD *)(v12 + 160), *(_DWORD *)(v12 + 176), v11, &v15))
      v13 = *(_DWORD *)(v15 + 8);
    else
      v13 = -1;
    v14 = v13;
    llvm::bfi_detail::IrreducibleGraph::addEdge(a2, (uint64_t)a3, &v14, a4);
  }
}

uint64_t sub_1C61EA690(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v6;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  HIBYTE(v6) = 0;
  *(_BYTE *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 25) = v6;
  MEMORY[0x1CAA32FB4](0, 8);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  MEMORY[0x1CAA32FB4](0, 8);
  *(_BYTE *)(a1 + 16) = 0;
  return a1;
}

uint64_t *****sub_1C61EA72C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6;
  int v7;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;

  v16 = a3;
  if (*(_BYTE *)a2)
  {
    v6 = -1;
  }
  else
  {
    v10 = *(_QWORD *)(a3 + 32);
    v11 = *(_QWORD *)(a2 + 16);
    if (v11)
      v12 = v10 == v11;
    else
      v12 = 0;
    if (!v12)
    {
      if (v11)
        sub_1C6125098((_DWORD *)(a2 + 24));
      *(_QWORD *)(a2 + 16) = v10;
      v13 = *(_QWORD *)(v10 + 328);
      if (v13 != v10 + 320)
      {
        v14 = 0;
        do
        {
          v15 = v13;
          *((_DWORD *)sub_1C6128C08((uint64_t *)(a2 + 24), &v15) + 2) = v14++;
          v13 = *(_QWORD *)(v13 + 8);
        }
        while (v13 != v10 + 320);
      }
    }
    v6 = *((_DWORD *)sub_1C6128C08((uint64_t *)(a2 + 24), &v16) + 2);
    a3 = v16;
  }
  if (dword_1ED82F318)
    v7 = dword_1ED82F318;
  else
    v7 = dword_1ED7F9688;
  return sub_1C51344C0(a1, a3, a4, v7, v6);
}

void llvm::initializeMachineBlockPlacementPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F9860);
  if (v2 != -1)
  {
    v5[0] = sub_1C5134B98;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F9860, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeMachineBlockPlacementStatsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7F9868);
  if (v2 != -1)
  {
    v5[0] = sub_1C5134C4C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7F9868, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61EA8E8(uint64_t a1)
{
  void *v2;

  sub_1C61EA930((unsigned int *)(a1 + 152));
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 152), 8);
  v2 = *(void **)(a1 + 72);
  if (v2 != (void *)(a1 + 88))
    free(v2);
  return a1;
}

void sub_1C61EA930(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  void *v4;

  v1 = a1[4];
  if ((_DWORD)v1)
  {
    v2 = 32 * v1;
    v3 = (_QWORD *)(*(_QWORD *)a1 + 16);
    do
    {
      if (*((_DWORD *)v3 - 4) <= 0xFFFFFFFD)
      {
        v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

void *sub_1C61EA984(uint64_t a1, uint64_t *a2)
{
  void *result;
  uint64_t v5;
  uint64_t v6;
  _BYTE v7[24];

  result = sub_1C61EAB5C((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    v5 = *a2;
    v6 = *(unsigned int *)(a1 + 144);
    if (v6 >= *(_DWORD *)(a1 + 148))
    {
      result = llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 136, a1 + 152, v6 + 1, 8);
      LODWORD(v6) = *(_DWORD *)(a1 + 144);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 144);
  }
  return result;
}

void *sub_1C61EAA04(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BYTE v11[24];
  uint64_t v12;
  uint64_t v13;

  if (a2 != a3)
  {
    v12 = v3;
    v13 = v4;
    v6 = a2;
    v7 = (uint64_t)result;
    v8 = (uint64_t)result + 136;
    do
    {
      result = sub_1C61EAB5C((uint64_t)v11, v7, v6);
      if (v11[16])
      {
        v9 = *v6;
        v10 = *(unsigned int *)(v7 + 144);
        if (v10 >= *(unsigned int *)(v7 + 148))
        {
          result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v7 + 152, v10 + 1, 8);
          v10 = *(unsigned int *)(v7 + 144);
        }
        *(_QWORD *)(*(_QWORD *)(v7 + 136) + 8 * v10) = v9;
        ++*(_DWORD *)(v7 + 144);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

uint64_t sub_1C61EAAB0(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 16;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 8 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 8 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61EAB5C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *result;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v14 = 0;
  result = (_QWORD *)sub_1C61EAAB0(a2, *a3, &v14);
  v7 = v14;
  if ((_DWORD)result)
  {
    v8 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v9 = 16;
    }
    else
    {
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(unsigned int *)(a2 + 16);
    }
    v10 = 0;
    v11 = v8 + 8 * v9;
  }
  else
  {
    result = sub_1C61EAC18((_DWORD *)a2, a3, v14);
    v7 = result;
    *result = *a3;
    v12 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v13 = 16;
    }
    else
    {
      v12 = *(_QWORD *)(a2 + 8);
      v13 = *(unsigned int *)(a2 + 16);
    }
    v11 = v12 + 8 * v13;
    v10 = 1;
  }
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

_QWORD *sub_1C61EAC18(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 16;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C5139BE8((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61EAAB0((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

uint64_t sub_1C61EACD4(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 136);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C61EAAB0((uint64_t)v5, v10, &v11);
      *v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1C61EAD94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;

  v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
    return sub_1C4EB69AC(a1, a2, a3);
  v4 = (uint64_t *)(*(_QWORD *)a1 + 16 * v3);
  *v4 = a2;
  v4[1] = a3;
  *(_DWORD *)(a1 + 8) = v3 + 1;
  return a1;
}

uint64_t sub_1C61EADBC(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
    return sub_1C513B9A4(a1, a2, a3);
  v4 = *(_QWORD *)a1 + 16 * v3;
  *(_DWORD *)v4 = a2;
  *(_QWORD *)(v4 + 8) = a3;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

llvm::SmallPtrSetImplBase *sub_1C61EADEC(llvm::SmallPtrSetImplBase *this, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t v6;

  *(_QWORD *)this = (char *)this + 32;
  *((_QWORD *)this + 1) = (char *)this + 32;
  *((_QWORD *)this + 2) = 2;
  *((_DWORD *)this + 6) = 0;
  if (a2 != a3)
  {
    v5 = a2;
    do
    {
      v6 = *v5++;
      sub_1C4774094(this, v6);
    }
    while (v5 != a3);
  }
  return this;
}

_QWORD *sub_1C61EAE50(uint64_t a1, uint64_t *a2)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  result = (_QWORD *)sub_1C513CDA8((_DWORD *)a1, *a2);
  if ((_DWORD)result)
  {
    result = *(_QWORD **)(a1 + 136);
    v5 = *(unsigned int *)(a1 + 144);
    v6 = &result[v5];
    if ((_DWORD)v5)
    {
      v7 = 8 * v5;
      while (*result != *a2)
      {
        ++result;
        v7 -= 8;
        if (!v7)
        {
          result = v6;
          break;
        }
      }
    }
    if (v6 != result + 1)
    {
      result = memmove(result, result + 1, (char *)v6 - (char *)(result + 1));
      LODWORD(v5) = *(_DWORD *)(a1 + 144);
    }
    *(_DWORD *)(a1 + 144) = v5 - 1;
  }
  return result;
}

_QWORD *sub_1C61EAECC(_QWORD *result, int a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;

  if (a2)
  {
    v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (*((_DWORD *)result + 4) <= v4)
      return sub_1C4FA9EF4((uint64_t)result, v4 + 1);
  }
  return result;
}

_QWORD *sub_1C61EAF18(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61EAF84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61EB074(a1, a2, v7);
    *(_OWORD *)v5 = *(_OWORD *)a2;
    v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1C61EAF84(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v20;

  if (a2)
  {
    v5 = ((37 * a4) | (unint64_t)(0x2500000000 * a3))
       + ~((unint64_t)(37 * a4) << 32);
    v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    v8 = a2 - 1;
    v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~((_DWORD)v7 << 27)));
    v10 = (_QWORD *)(a1 + 24 * v9);
    v11 = *v10;
    v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      v14 = 1;
    }
    else
    {
      v16 = 0;
      v17 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v16)
          v18 = 0;
        else
          v18 = v12 == -2;
        if (v18 && v11 == -2)
          v16 = v10;
        v20 = v9 + v17++;
        v9 = v20 & v8;
        v10 = (_QWORD *)(a1 + 24 * (v20 & v8));
        v11 = *v10;
        v12 = v10[1];
        v14 = 1;
        if (*v10 == a3 && v12 == a4)
          goto LABEL_8;
      }
      v14 = 0;
      if (v16)
        v10 = v16;
    }
  }
  else
  {
    v10 = 0;
    v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

_QWORD *sub_1C61EB074(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v9;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C513E3D8(a1, v6);
  v9 = 0;
  sub_1C61EAF84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61EB128(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v13;
  uint64_t *v14;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 24 * v6;
    do
    {
      *v7 = -1;
      v7[1] = -1;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    v10 = a2[1];
    if ((*a2 != -1 || v10 != -1) && (v9 != -2 || v10 != -2))
    {
      v14 = 0;
      result = sub_1C61EAF84(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
      v13 = v14;
      *v14 = *a2;
      v13[1] = a2[1];
      v13[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

void sub_1C61EB1F4(__int128 *a1, int **a2, _WORD *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F9930, 0, 0);
  dword_1ED7F99B0 = 0;
  qword_1ED7F99B8 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F99C0 = 0;
  qword_1ED7F9930 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F99C8 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F99D0 = (uint64_t)&off_1E7F95260;
  qword_1ED7F99E8 = (uint64_t)&qword_1ED7F99D0;
  llvm::cl::Option::setArgStr(v6, "align-all-nofallthru-blocks", 0x1BuLL);
  xmmword_1ED7F9950 = *a1;
  dword_1ED7F99B0 = **a2;
  byte_1ED7F99C4 = 1;
  dword_1ED7F99C0 = dword_1ED7F99B0;
  word_1ED7F993A = (32 * (*a3 & 3)) | word_1ED7F993A & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F9930);
}

void sub_1C61EB2D0(__int128 *a1, int **a2, _WORD *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7F9AB0, 0, 0);
  dword_1ED7F9B30 = 0;
  qword_1ED7F9B38 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7F9B40 = 0;
  qword_1ED7F9AB0 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7F9B48 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7F9B50 = (uint64_t)&off_1E7F95260;
  qword_1ED7F9B68 = (uint64_t)&qword_1ED7F9B50;
  llvm::cl::Option::setArgStr(v6, "block-placement-exit-block-bias", 0x1FuLL);
  xmmword_1ED7F9AD0 = *a1;
  dword_1ED7F9B30 = **a2;
  byte_1ED7F9B44 = 1;
  dword_1ED7F9B40 = dword_1ED7F9B30;
  word_1ED7F9ABA = (32 * (*a3 & 3)) | word_1ED7F9ABA & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7F9AB0);
}

void sub_1C61EB3AC(__int128 *a1, int **a2, _WORD *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7FA230, 0, 0);
  dword_1ED7FA2B0 = 0;
  qword_1ED7FA2B8 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7FA2C0 = 0;
  qword_1ED7FA230 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7FA2C8 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7FA2D0 = (uint64_t)&off_1E7F95260;
  qword_1ED7FA2E8 = (uint64_t)&qword_1ED7FA2D0;
  llvm::cl::Option::setArgStr(v6, "tail-dup-placement-aggressive-threshold", 0x27uLL);
  xmmword_1ED7FA250 = *a1;
  dword_1ED7FA2B0 = **a2;
  byte_1ED7FA2C4 = 1;
  dword_1ED7FA2C0 = dword_1ED7FA2B0;
  word_1ED7FA23A = (32 * (*a3 & 3)) | word_1ED7FA23A & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FA230);
}

void llvm::initializeMachineBranchProbabilityInfoPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F4F8);
  if (v2 != -1)
  {
    v5[0] = sub_1C513EF20;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F4F8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::MachineBranchProbabilityInfo *llvm::MachineBranchProbabilityInfo::MachineBranchProbabilityInfo(llvm::MachineBranchProbabilityInfo *this)
{
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v5;
  _QWORD v6[2];

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::MachineBranchProbabilityInfo::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E8144200;
  PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  v2 = atomic_load(&qword_1ED82F4F8);
  if (v2 != -1)
  {
    v6[0] = sub_1C513EF20;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1ED82F4F8, &v5, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void sub_1C61EB588(llvm::ImmutablePass *a1)
{
  llvm::ImmutablePass::~ImmutablePass(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61EB5AC(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

llvm::MachineBranchProbabilityInfo *llvm::callDefaultCtor<llvm::MachineBranchProbabilityInfo>()
{
  llvm::MachineBranchProbabilityInfo *v0;

  v0 = (llvm::MachineBranchProbabilityInfo *)operator new();
  return llvm::MachineBranchProbabilityInfo::MachineBranchProbabilityInfo(v0);
}

void sub_1C61EB5E0(__int128 *a1, int **a2, _WORD *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&llvm::StaticLikelyProb, 0, 0);
  dword_1ED82F580 = 0;
  qword_1ED82F588 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED82F590 = 0;
  llvm::StaticLikelyProb = (uint64_t)&unk_1E819E3B0;
  qword_1ED82F598 = (uint64_t)&unk_1E819E2C0;
  qword_1ED82F5A0 = (uint64_t)&off_1E7F95260;
  qword_1ED82F5B8 = (uint64_t)&qword_1ED82F5A0;
  llvm::cl::Option::setArgStr(v6, "static-likely-prob", 0x12uLL);
  xmmword_1ED82F520 = *a1;
  dword_1ED82F580 = **a2;
  byte_1ED82F594 = 1;
  dword_1ED82F590 = dword_1ED82F580;
  word_1ED82F50A = (32 * (*a3 & 3)) | word_1ED82F50A & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::StaticLikelyProb);
}

void llvm::initializeMachineCombinerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FA538);
  if (v2 != -1)
  {
    v5[0] = sub_1C513F3D4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FA538, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C61EB720(_WORD *a1, __n128 *a2, char **a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FA6C0, 0, 0);
  byte_1ED7FA740 = 0;
  qword_1ED7FA748 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7FA750 = 0;
  qword_1ED7FA6C0 = (uint64_t)&unk_1E819E898;
  qword_1ED7FA758 = (uint64_t)&off_1E819E9A0;
  qword_1ED7FA760 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7FA778 = (uint64_t)&qword_1ED7FA760;
  sub_1C5140E3C(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FA6C0);
}

void llvm::initializeMachineCopyPropagationPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FA788);
  if (v2 != -1)
  {
    v5[0] = sub_1C5140FE8;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FA788, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C61EB828(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  void *v11;
  void *v12;
  uint64_t *v13;

  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 56 * v6;
    do
    {
      *v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v13 = 0;
      sub_1C5143964(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      v10 = v13;
      v11 = v13 + 5;
      *v13 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v11, 2, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      v12 = (void *)a2[2];
      if (v12 != (void *)a2[1])
        free(v12);
    }
    a2 += 7;
  }
}

void llvm::initializeMachineCSEPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FA790);
  if (v2 != -1)
  {
    v5[0] = sub_1C5144A00;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FA790, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61EB95C(uint64_t a1, const llvm::MachineInstr *const *a2, llvm::MachineInstrExpressionTrait *this, uint64_t **a4)
{
  int v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t result;
  uint64_t *v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  int v16;
  uint64_t *v17;

  if ((_DWORD)a2)
  {
    v7 = (_DWORD)a2 - 1;
    v8 = llvm::MachineInstrExpressionTrait::getHashValue(this, a2) & ((_DWORD)a2 - 1);
    v9 = (uint64_t *)(a1 + 16 * v8);
    if ((sub_1C5147408(*(_QWORD *)this, *v9) & 1) != 0)
    {
      result = 1;
    }
    else
    {
      v11 = 0;
      v12 = 1;
      while (*v9)
      {
        if (v11)
          v13 = 0;
        else
          v13 = *v9 == -1;
        if (v13)
          v11 = v9;
        v17 = v11;
        v14 = v12 + 1;
        v8 = (v8 + v12) & v7;
        v9 = (uint64_t *)(a1 + 16 * v8);
        v15 = sub_1C5147408(*(_QWORD *)this, *v9);
        v11 = v17;
        v16 = v15;
        result = 1;
        v12 = v14;
        if (v16)
          goto LABEL_4;
      }
      result = 0;
      if (v11)
        v9 = v11;
    }
  }
  else
  {
    v9 = 0;
    result = 0;
  }
LABEL_4:
  *a4 = v9;
  return result;
}

uint64_t *sub_1C61EBA48(uint64_t a1, llvm::MachineInstrExpressionTrait *this)
{
  char v4;
  uint64_t *v5;
  uint64_t *v7;

  v7 = 0;
  v4 = sub_1C61EB95C(*(_QWORD *)a1, (const llvm::MachineInstr *const *)*(unsigned int *)(a1 + 16), this, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61EBAB0(a1, this, v7);
    *v5 = *(_QWORD *)this;
    v5[1] = 0;
  }
  return v5;
}

uint64_t *sub_1C61EBAB0(uint64_t a1, llvm::MachineInstrExpressionTrait *a2, uint64_t *a3)
{
  int v5;
  unsigned int v6;
  uint64_t *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C5147F60(a1, v6);
  v8 = 0;
  sub_1C61EB95C(*(_QWORD *)a1, (const llvm::MachineInstr *const *)*(unsigned int *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61EBB5C(uint64_t result, llvm::MachineInstrExpressionTrait *this, llvm::MachineInstrExpressionTrait *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 16 * v6;
    do
    {
      *v7 = 0;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (this != a3)
  {
    if ((unint64_t)(*(_QWORD *)this + 1) >= 2)
    {
      v10 = 0;
      result = sub_1C61EB95C(*(_QWORD *)v5, (const llvm::MachineInstr *const *)*(unsigned int *)(v5 + 16), this, &v10);
      v9 = v10;
      *v10 = *(_QWORD *)this;
      v9[1] = *((_QWORD *)this + 1);
      ++*(_DWORD *)(v5 + 8);
    }
    this = (llvm::MachineInstrExpressionTrait *)((char *)this + 16);
  }
  return result;
}

void llvm::initializeCheckDebugMachineModulePass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FA798);
  if (v2 != -1)
  {
    v5[0] = sub_1C51487FC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FA798, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createCheckDebugMachineModulePass(llvm *this)
{
  uint64_t result;

  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = &unk_1EF8F6F2B;
  *(_DWORD *)(result + 24) = 4;
  *(_QWORD *)result = &off_1E8144508;
  return result;
}

llvm::MachineBasicBlock *llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getCyclePreheader(uint64_t a1)
{
  llvm::MachineBasicBlock *result;
  llvm::MachineBasicBlock *v2;

  result = (llvm::MachineBasicBlock *)llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getCyclePredecessor(a1);
  if (result)
  {
    v2 = result;
    if (((*((_QWORD *)result + 12) - *((_QWORD *)result + 11)) & 0x7FFFFFFF8) == 8)
    {
      if (llvm::MachineBasicBlock::isLegalToHoistInto(result))
        return v2;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

{
  return __ZNK4llvm12GenericCycleINS_17GenericSSAContextINS_15MachineFunctionEEEE17getCyclePreheaderEv(a1);
}

llvm::MachineCycleInfoWrapperPass *llvm::MachineCycleInfoWrapperPass::MachineCycleInfoWrapperPass(llvm::MachineCycleInfoWrapperPass *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848((uint64_t)this, (uint64_t)llvm::MachineCycleInfoWrapperPass::ID);
  *(_QWORD *)v2 = &off_1E81445A8;
  *(_QWORD *)(v2 + 248) = 0;
  *(_QWORD *)(v2 + 256) = 0;
  *(_QWORD *)(v2 + 272) = 0;
  *(_QWORD *)(v2 + 280) = 0;
  *(_DWORD *)(v2 + 288) = 0;
  *(_QWORD *)(v2 + 296) = 0;
  *(_QWORD *)(v2 + 304) = 0;
  *(_DWORD *)(v2 + 312) = 0;
  *(_QWORD *)(v2 + 328) = 0;
  *(_QWORD *)(v2 + 336) = 0;
  *(_QWORD *)(v2 + 320) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED82F680);
  if (v3 != -1)
  {
    v7[0] = sub_1C514BE6C;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F680, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeMachineCycleInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F680);
  if (v2 != -1)
  {
    v5[0] = sub_1C514BE6C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F680, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void *llvm::MachineCycleInfoWrapperPass::getAnalysisUsage(llvm::MachineFunctionPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void llvm::MachineCycleInfoWrapperPass::print(llvm::Value ***this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  llvm::raw_ostream *v5;
  size_t v6;
  char *Name;
  size_t v8;
  void *v9;

  v5 = sub_1C4816AD8(a2, "MachineCycleInfo for function: ");
  Name = llvm::MachineFunction::getName(this[31]);
  v8 = v6;
  v9 = (void *)*((_QWORD *)v5 + 4);
  if (v6 <= *((_QWORD *)v5 + 3) - (_QWORD)v9)
  {
    if (v6)
    {
      memcpy(v9, Name, v6);
      *((_QWORD *)v5 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v5, Name, v6);
  }
  sub_1C4816AD8(v5, "\n");
  llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::print((uint64_t)(this + 32), a2);
}

void MachineCycleInfoPrinterPass::MachineCycleInfoPrinterPass(MachineCycleInfoPrinterPass *this)
{
  llvm::PassRegistry *v1;
  unint64_t v2;
  unint64_t PassRegistry;
  _QWORD *v4;
  _QWORD v5[2];

  v1 = (llvm::PassRegistry *)sub_1C4776848((uint64_t)this, (uint64_t)&MachineCycleInfoPrinterPass::ID);
  *(_QWORD *)v1 = &off_1E8144668;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v1);
  v2 = atomic_load(&qword_1ED7FA7A0);
  if (v2 != -1)
  {
    v5[0] = sub_1C514BF9C;
    v5[1] = &PassRegistry;
    v4 = v5;
    std::__call_once(&qword_1ED7FA7A0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeMachineCycleInfoPrinterPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FA7A0);
  if (v2 != -1)
  {
    v5[0] = sub_1C514BF9C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FA7A0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void *MachineCycleInfoPrinterPass::getAnalysisUsage(MachineCycleInfoPrinterPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineCycleInfoWrapperPass::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t MachineCycleInfoPrinterPass::runOnMachineFunction(MachineCycleInfoPrinterPass *this, llvm::MachineFunction *a2)
{
  char **v2;
  char *v3;
  llvm *v4;
  void *v5;

  v2 = (char **)**((_QWORD **)this + 1);
  do
  {
    v3 = *v2;
    v2 += 2;
  }
  while (v3 != llvm::MachineCycleInfoWrapperPass::ID);
  v4 = (llvm *)(*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v2 - 1) + 96))(*(v2 - 1), llvm::MachineCycleInfoWrapperPass::ID);
  v5 = llvm::errs(v4);
  (*(void (**)(llvm *, void *, _QWORD))(*(_QWORD *)v4 + 40))(v4, v5, 0);
  return 0;
}

void sub_1C61EC06C(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E81445A8;
  sub_1C514C254((uint64_t)a1 + 256);
  sub_1C4926674(a1);
}

void sub_1C61EC0A0(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E81445A8;
  sub_1C514C254((uint64_t)a1 + 256);
  sub_1C4926674(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61EC0EC(llvm::Pass *a1)
{
  sub_1C4926674(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::MachineCycleInfoWrapperPass *llvm::callDefaultCtor<llvm::MachineCycleInfoWrapperPass>()
{
  llvm::MachineCycleInfoWrapperPass *v0;

  v0 = (llvm::MachineCycleInfoWrapperPass *)operator new();
  return llvm::MachineCycleInfoWrapperPass::MachineCycleInfoWrapperPass(v0);
}

void llvm::callDefaultCtor<MachineCycleInfoPrinterPass>()
{
  MachineCycleInfoPrinterPass *v0;

  v0 = (MachineCycleInfoPrinterPass *)operator new();
  MachineCycleInfoPrinterPass::MachineCycleInfoPrinterPass(v0);
}

void sub_1C61EC164()
{
  JUMPOUT(0x1CAA32FC0);
}

__n128 sub_1C61EC178(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E8144728;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1C61EC1B0(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E8144728;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *sub_1C61EC1D0(uint64_t a1, llvm::raw_ostream *a2)
{
  return sub_1C61EC1D8((_QWORD *)(a1 + 8), a2);
}

_QWORD *sub_1C61EC1D8(_QWORD *result, llvm::raw_ostream *this)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t (**v8)(void);
  _BYTE *v9;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(*result + 16);
  if ((_DWORD)v2)
  {
    v4 = *(uint64_t **)(*result + 8);
    v5 = 8 * v2;
    v6 = 1;
    while (1)
    {
      v7 = *v4;
      if ((v6 & 1) == 0)
      {
        v9 = (_BYTE *)*((_QWORD *)this + 4);
        if ((unint64_t)v9 >= *((_QWORD *)this + 3))
        {
          llvm::raw_ostream::write(this, 32);
        }
        else
        {
          *((_QWORD *)this + 4) = v9 + 1;
          *v9 = 32;
        }
      }
      llvm::GenericSSAContext<llvm::MachineFunction>::print(v7, v10);
      if (!v11)
        sub_1C485C2F0();
      (*(void (**)(_QWORD *, llvm::raw_ostream *))(*v11 + 48))(v11, this);
      result = v11;
      if (v11 == v10)
        break;
      if (v11)
      {
        v8 = (uint64_t (**)(void))(*v11 + 40);
LABEL_8:
        result = (_QWORD *)(*v8)();
      }
      v6 = 0;
      ++v4;
      v5 -= 8;
      if (!v5)
        return result;
    }
    v8 = (uint64_t (**)(void))(v10[0] + 32);
    goto LABEL_8;
  }
  return result;
}

void sub_1C61EC30C()
{
  JUMPOUT(0x1CAA32FC0);
}

__n128 sub_1C61EC320(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E8144770;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1C61EC358(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E8144770;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t (***sub_1C61EC378(uint64_t a1, llvm::raw_ostream *a2))()
{
  return sub_1C61EC380((uint64_t *)(a1 + 8), a2);
}

uint64_t (***sub_1C61EC380(uint64_t *a1, llvm::raw_ostream *a2))()
{
  uint64_t v4;
  llvm::raw_ostream *v5;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t (***result)();
  uint64_t (**v11)(void);
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _BYTE *v19;
  uint64_t (**v20)(void);
  uint64_t (**v21)();
  _QWORD v22[2];
  uint64_t (***v23)();
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = sub_1C4816AD8(a2, "depth=");
  v6 = llvm::raw_ostream::operator<<(v5, *(unsigned int *)(v4 + 80));
  v7 = sub_1C4816AD8(v6, ": entries(");
  v8 = a1[1];
  v21 = &off_1E8144728;
  v22[0] = v4;
  v22[1] = v8;
  v23 = &v21;
  sub_1C61EC1D8(v22, v7);
  v9 = (_BYTE *)*((_QWORD *)v7 + 4);
  if ((unint64_t)v9 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 41);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v9 + 1;
    *v9 = 41;
  }
  result = v23;
  if (v23 == &v21)
  {
    v11 = v21 + 4;
  }
  else
  {
    if (!v23)
      goto LABEL_8;
    v11 = *v23 + 5;
  }
  result = (uint64_t (***)())(*v11)();
LABEL_8:
  v12 = *(uint64_t **)(v4 + 56);
  v13 = *(uint64_t **)(v4 + 64);
  if (v12 != v13)
  {
    while (1)
    {
      v14 = *v12;
      v15 = *(_QWORD *)(v4 + 8);
      v16 = *(unsigned int *)(v4 + 16);
      if ((_DWORD)v16)
      {
        v17 = 8 * v16;
        v18 = *(_QWORD **)(v4 + 8);
        while (*v18 != v14)
        {
          ++v18;
          v17 -= 8;
          if (!v17)
          {
            v18 = (_QWORD *)(v15 + 8 * v16);
            break;
          }
        }
      }
      else
      {
        v18 = *(_QWORD **)(v4 + 8);
      }
      if (v16 != ((uint64_t)v18 - v15) >> 3)
        goto LABEL_24;
      v19 = (_BYTE *)*((_QWORD *)a2 + 4);
      if ((unint64_t)v19 >= *((_QWORD *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 32);
      }
      else
      {
        *((_QWORD *)a2 + 4) = v19 + 1;
        *v19 = 32;
      }
      llvm::GenericSSAContext<llvm::MachineFunction>::print(v14, &v21);
      if (!v23)
        sub_1C485C2F0();
      ((void (*)(uint64_t (***)(), llvm::raw_ostream *))(*v23)[6])(v23, a2);
      result = v23;
      if (v23 == &v21)
        break;
      if (v23)
      {
        v20 = *v23 + 5;
LABEL_23:
        result = (uint64_t (***)())(*v20)();
      }
LABEL_24:
      if (++v12 == v13)
        return result;
    }
    v20 = v21 + 4;
    goto LABEL_23;
  }
  return result;
}

void llvm::initializeDebugifyMachineModulePass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FA7A8);
  if (v2 != -1)
  {
    v5[0] = sub_1C514CC60;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FA7A8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createDebugifyMachineModulePass(llvm *this)
{
  uint64_t result;

  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = &unk_1EF8F6F39;
  *(_DWORD *)(result + 24) = 4;
  *(_QWORD *)result = &off_1E81447B8;
  return result;
}

void llvm::initializeMachineDominanceFrontierPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F688);
  if (v2 != -1)
  {
    v5[0] = sub_1C514F00C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F688, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::MachineDominanceFrontier *llvm::MachineDominanceFrontier::MachineDominanceFrontier(llvm::MachineDominanceFrontier *this)
{
  llvm::PassRegistry *v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = (llvm::PassRegistry *)sub_1C4776848((uint64_t)this, (uint64_t)&llvm::MachineDominanceFrontier::ID);
  *(_QWORD *)v2 = &off_1E81448A0;
  *((_QWORD *)v2 + 31) = (char *)v2 + 256;
  *((_QWORD *)v2 + 32) = 0;
  *((_QWORD *)v2 + 33) = 0;
  *((_QWORD *)v2 + 34) = (char *)v2 + 288;
  *((_QWORD *)v2 + 35) = 0x100000000;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  v3 = atomic_load(&qword_1ED82F688);
  if (v3 != -1)
  {
    v7[0] = sub_1C514F00C;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F688, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::MachineDominanceFrontier::runOnMachineFunction(void ****this, llvm::MachineFunction *a2)
{
  void **v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  ((void (*)(void ****, llvm::MachineFunction *))(*this)[11])(this, a2);
  v3 = *this[1];
  do
  {
    v4 = *v3;
    v3 += 2;
  }
  while (v4 != &llvm::MachineDominatorTree::ID);
  v5 = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v3 - 1) + 96))(*(v3 - 1), &llvm::MachineDominatorTree::ID);
  v6 = sub_1C50F0988(v5);
  llvm::ForwardDominanceFrontierBase<llvm::MachineBasicBlock>::analyze((uint64_t)(this + 31), v6);
  return 0;
}

void llvm::MachineDominanceFrontier::releaseMemory(llvm::MachineDominanceFrontier *this)
{
  sub_1C61910D0((uint64_t)this + 248, *((_QWORD **)this + 32));
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 31) = (char *)this + 256;
}

void *llvm::MachineDominanceFrontier::getAnalysisUsage(llvm::MachineDominanceFrontier *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void sub_1C61EC830(uint64_t a1)
{
  sub_1C61EC87C(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::MachineDominanceFrontier *llvm::callDefaultCtor<llvm::MachineDominanceFrontier>()
{
  llvm::MachineDominanceFrontier *v0;

  v0 = (llvm::MachineDominanceFrontier *)operator new();
  return llvm::MachineDominanceFrontier::MachineDominanceFrontier(v0);
}

void sub_1C61EC87C(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1E81448A0;
  v2 = *(void **)(a1 + 272);
  if (v2 != (void *)(a1 + 288))
    free(v2);
  sub_1C61910D0(a1 + 248, *(_QWORD **)(a1 + 256));
  sub_1C4926674((llvm::Pass *)a1);
}

void llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::setIDom(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 != a2)
  {
    v5 = *(_QWORD **)(v2 + 24);
    v6 = *(unsigned int *)(v2 + 32);
    v7 = &v5[v6];
    if ((_DWORD)v6)
    {
      v9 = 8 * v6;
      while (*v5 != a1)
      {
        ++v5;
        v9 -= 8;
        if (!v9)
        {
          v5 = v7;
          break;
        }
      }
    }
    if (v7 != v5 + 1)
    {
      memmove(v5, v5 + 1, (char *)v7 - (char *)(v5 + 1));
      LODWORD(v6) = *(_DWORD *)(v2 + 32);
    }
    *(_DWORD *)(v2 + 32) = v6 - 1;
    *(_QWORD *)(a1 + 8) = a2;
    v8 = *(unsigned int *)(a2 + 32);
    if (v8 >= *(_DWORD *)(a2 + 36))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, a2 + 40, v8 + 1, 8);
      LODWORD(v8) = *(_DWORD *)(a2 + 32);
    }
    *(_QWORD *)(*(_QWORD *)(a2 + 24) + 8 * v8) = a1;
    ++*(_DWORD *)(a2 + 32);
    llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::UpdateLevel(a1);
  }
}

{
  __ZN4llvm15DomTreeNodeBaseINS_17MachineBasicBlockEE7setIDomEPS2_(a1, a2);
}

void llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::UpdateLevel(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD v10[65];

  v10[64] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(*(_QWORD *)(a1 + 8) + 16) + 1)
  {
    v7 = v10;
    v9 = 64;
    v10[0] = a1;
    v1 = 1;
    do
    {
      v2 = *((_QWORD *)v7 + --v1);
      v8 = v1;
      *(_DWORD *)(v2 + 16) = *(_DWORD *)(*(_QWORD *)(v2 + 8) + 16) + 1;
      v3 = *(unsigned int *)(v2 + 32);
      if ((_DWORD)v3)
      {
        v4 = *(uint64_t **)(v2 + 24);
        v5 = 8 * v3;
        do
        {
          v6 = *v4;
          if (*(_DWORD *)(*v4 + 16) != *(_DWORD *)(*(_QWORD *)(*v4 + 8) + 16) + 1)
          {
            if (v1 >= v9)
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v7, (uint64_t)v10, v1 + 1, 8);
              v1 = v8;
            }
            *((_QWORD *)v7 + v1) = v6;
            v1 = ++v8;
          }
          ++v4;
          v5 -= 8;
        }
        while (v5);
      }
    }
    while (v1);
    if (v7 != v10)
      free(v7);
  }
}

{
  __ZN4llvm15DomTreeNodeBaseINS_17MachineBasicBlockEE11UpdateLevelEv(a1);
}

llvm::raw_ostream *llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v4;
  uint64_t v5;
  uint64_t v6;
  llvm::MachineBasicBlock **v7;
  uint64_t v8;
  llvm::MachineBasicBlock *v9;

  sub_1C4816AD8(a2, "=============================--------------------------------\n");
  sub_1C4816AD8(a2, "Inorder Dominator Tree: ");
  if (!*(_BYTE *)(a1 + 64))
  {
    v4 = sub_1C4816AD8(a2, "DFSNumbers invalid: ");
    sub_1C5E21910(v4, *(unsigned int *)(a1 + 68), 0, 0, 0);
    sub_1C4816AD8(v4, " slow queries.");
  }
  sub_1C4816AD8(a2, "\n");
  v5 = *(_QWORD *)(a1 + 48);
  if (v5)
    sub_1C61ECBEC(v5, a2, 1u);
  sub_1C4816AD8(a2, "Roots: ");
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(llvm::MachineBasicBlock ***)a1;
    v8 = 8 * v6;
    do
    {
      v9 = *v7++;
      llvm::MachineBasicBlock::printAsOperand(v9, a2);
      sub_1C4816AD8(a2, " ");
      v8 -= 8;
    }
    while (v8);
  }
  return sub_1C4816AD8(a2, "\n");
}

{
  return __ZNK4llvm17DominatorTreeBaseINS_17MachineBasicBlockELb0EE5printERNS_11raw_ostreamE(a1, a2);
}

llvm::raw_ostream *sub_1C61ECBEC(uint64_t a1, llvm::raw_ostream *a2, unsigned int a3)
{
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm::raw_ostream *result;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v6 = llvm::raw_ostream::indent(a2, 2 * a3);
  v7 = sub_1C4816AD8(v6, "[");
  sub_1C5E21910(v7, a3, 0, 0, 0);
  v8 = sub_1C4816AD8(v7, "] ");
  result = sub_1C61ED144(v8, a1);
  v10 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v10)
  {
    v11 = *(uint64_t **)(a1 + 24);
    v12 = a3 + 1;
    v13 = 8 * v10;
    do
    {
      v14 = *v11++;
      result = (llvm::raw_ostream *)sub_1C61ECBEC(v14, a2, v12);
      v13 -= 8;
    }
    while (v13);
  }
  return result;
}

BOOL llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::verify(uint64_t a1, int a2)
{
  _QWORD *v4;
  _BOOL8 v5;
  _QWORD v7[5];
  int v8;
  uint64_t v9;

  v4 = operator new(8uLL);
  v7[0] = v4;
  *v4 = 0;
  v7[1] = v4 + 1;
  v7[2] = v4 + 1;
  v9 = 0;
  v7[3] = 0;
  v7[4] = 0;
  v8 = 0;
  v5 = 0;
  if (sub_1C5157D08(a1))
    v5 = sub_1C5157EFC(a1)
      && sub_1C51583C0((uint64_t)v7, a1)
      && sub_1C51587C0(a1)
      && sub_1C5158B94(a1)
      && ((a2 - 1) > 1
       || sub_1C5158F48((uint64_t)v7, a1) && (a2 != 2 || sub_1C51597C8((uint64_t)v7, a1)));
  sub_1C515725C((uint64_t)v7);
  return v5;
}

void *llvm::MachineDominatorTree::getAnalysisUsage(llvm::MachineFunctionPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

llvm::MachineDominatorTree *llvm::MachineDominatorTree::MachineDominatorTree(llvm::MachineDominatorTree *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848((uint64_t)this, (uint64_t)&llvm::MachineDominatorTree::ID);
  *(_QWORD *)v2 = &off_1E8144970;
  *(_QWORD *)(v2 + 248) = v2 + 264;
  *(_QWORD *)(v2 + 256) = 0x2000000000;
  *(_QWORD *)(v2 + 1032) = v2 + 1064;
  *(_QWORD *)(v2 + 1040) = v2 + 1064;
  *(_QWORD *)(v2 + 1048) = 32;
  *(_DWORD *)(v2 + 1056) = 0;
  *(_QWORD *)(v2 + 1320) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED82F690);
  if (v3 != -1)
  {
    v7[0] = sub_1C51514A4;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F690, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

uint64_t llvm::MachineDominatorTree::verifyAnalysis(llvm::MachineDominatorTree *this)
{
  uint64_t result;
  BOOL v2;
  llvm::raw_ostream *v3;

  result = *((_QWORD *)this + 165);
  if (result)
    v2 = llvm::VerifyMachineDomInfo == 0;
  else
    v2 = 1;
  if (!v2)
  {
    result = llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::verify(result, 1);
    if ((result & 1) == 0)
    {
      v3 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
      sub_1C4816AD8(v3, "MachineDominatorTree verification failed\n");
      abort();
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MachineDominatorTree::print(llvm::MachineDominatorTree *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  llvm::raw_ostream *result;

  result = (llvm::raw_ostream *)*((_QWORD *)this + 165);
  if (result)
    return llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::print((uint64_t)result, a2);
  return result;
}

void sub_1C61ECE9C(llvm::Pass *a1)
{
  sub_1C61ECEE8(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::MachineDominatorTree *llvm::callDefaultCtor<llvm::MachineDominatorTree>()
{
  llvm::MachineDominatorTree *v0;

  v0 = (llvm::MachineDominatorTree *)operator new();
  return llvm::MachineDominatorTree::MachineDominatorTree(v0);
}

void sub_1C61ECEE8(llvm::Pass *a1)
{
  uint64_t v1;
  void *v2;
  _QWORD *v3;
  llvm::Pass *v4;
  llvm::Pass *v5;
  llvm::Pass *v6;

  *(_QWORD *)a1 = &off_1E8144970;
  v1 = *((_QWORD *)a1 + 165);
  *((_QWORD *)a1 + 165) = 0;
  if (v1)
  {
    v4 = a1;
    sub_1C4DC4DE4((uint64_t)a1 + 1320, v1);
    a1 = v4;
  }
  v2 = (void *)*((_QWORD *)a1 + 130);
  if (v2 != *((void **)a1 + 129))
  {
    v5 = a1;
    free(v2);
    a1 = v5;
  }
  v3 = (_QWORD *)*((_QWORD *)a1 + 31);
  if (v3 == (_QWORD *)((char *)a1 + 264))
  {
    sub_1C4926674(a1);
  }
  else
  {
    v6 = a1;
    free(v3);
    sub_1C4926674(v6);
  }
}

void sub_1C61ECF78(_BYTE **a1, _WORD *a2, __n128 *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FA7B0, 0, 0);
  byte_1ED7FA841 = 0;
  qword_1ED7FA830 = 0;
  unk_1ED7FA838 = &off_1E7F9E8D8;
  qword_1ED7FA7B0 = (uint64_t)&unk_1E8138EB8;
  qword_1ED7FA848 = (uint64_t)&off_1E819E9A0;
  qword_1ED7FA850 = (uint64_t)&unk_1E8138F20;
  qword_1ED7FA868 = (uint64_t)&qword_1ED7FA850;
  sub_1C61ED01C(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FA7B0);
}

__n128 sub_1C61ED01C(_BYTE **a1, _WORD *a2, __n128 *a3)
{
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7FA7B0, "verify-machine-dom-info", 0x17uLL);
  sub_1C4EB7838((llvm *)&qword_1ED7FA830, &qword_1ED7FA7B0, *a1);
  word_1ED7FA7BA = (32 * (*a2 & 3)) | word_1ED7FA7BA & 0xFF9F;
  result = *a3;
  xmmword_1ED7FA7D0 = (__int128)*a3;
  return result;
}

void sub_1C61ED094(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C5157AA0(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_13:
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
    v4 = 72 * v3;
    v5 = *(_QWORD *)a1 + 56;
    while (1)
    {
      v6 = *(_QWORD *)(v5 - 56);
      if (v6 == -8192)
        goto LABEL_11;
      if (v6 != -4096)
        break;
LABEL_12:
      v5 += 72;
      v4 -= 72;
      if (!v4)
        goto LABEL_13;
    }
    v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7)
      free(v7);
LABEL_11:
    *(_QWORD *)(v5 - 56) = -4096;
    goto LABEL_12;
  }
}

llvm::raw_ostream *sub_1C61ED144(llvm::raw_ostream *a1, uint64_t a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  llvm::raw_ostream *v6;

  if (*(_QWORD *)a2)
    llvm::MachineBasicBlock::printAsOperand(*(llvm::MachineBasicBlock **)a2, a1);
  else
    sub_1C4816AD8(a1, " <<exit node>>");
  v4 = sub_1C4816AD8(a1, " {");
  sub_1C5E21910(v4, *(unsigned int *)(a2 + 72), 0, 0, 0);
  v5 = sub_1C4816AD8(v4, ",");
  sub_1C5E21910(v5, *(unsigned int *)(a2 + 76), 0, 0, 0);
  v6 = sub_1C4816AD8(v5, "} [");
  sub_1C5E21910(v6, *(unsigned int *)(a2 + 16), 0, 0, 0);
  sub_1C4816AD8(v6, "]\n");
  return a1;
}

BOOL sub_1C61ED220(uint64_t *a1, int a2, uint64_t a3)
{
  _BOOL8 v3;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  unsigned int *v13;
  char *v14;
  BOOL v15;
  char *v16;
  char *v17;
  uint64_t v18;

  if (*(_DWORD *)(a3 + 8) != a2)
    return 0;
  sub_1C618F7A4((llvm::SmallPtrSetImplBase *)&v16, a1, &a1[a2]);
  v6 = *(unsigned int *)(a3 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(uint64_t **)a3;
    v8 = 8 * v6 - 8;
    do
    {
      v9 = *v7++;
      v10 = (char *)sub_1C477672C((uint64_t)&v16, v9);
      v12 = v16;
      v11 = v17;
      v13 = (unsigned int *)&v18 + 1;
      if (v17 != v16)
        v13 = (unsigned int *)&v18;
      v14 = &v17[8 * *v13];
      v3 = v10 != v14;
      v15 = v10 == v14 || v8 == 0;
      v8 -= 8;
    }
    while (!v15);
  }
  else
  {
    v3 = 1;
    v12 = v16;
    v11 = v17;
  }
  if (v11 != v12)
    free(v11);
  return v3;
}

llvm::raw_ostream *sub_1C61ED2E8(unsigned int *a1)
{
  llvm::raw_ostream *v2;
  llvm::raw_ostream *v3;
  llvm::raw_ostream *v4;
  llvm::raw_ostream *result;
  _BYTE *v6;

  v2 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  if (a1 && *(_QWORD *)a1)
    llvm::MachineBasicBlock::printAsOperand(*(llvm::MachineBasicBlock **)a1, v2);
  else
    sub_1C4816AD8(v2, "nullptr");
  v3 = sub_1C4816AD8(v2, " {");
  sub_1C5E21910(v3, a1[18], 0, 0, 0);
  v4 = sub_1C4816AD8(v3, ", ");
  result = sub_1C5E21910(v4, a1[19], 0, 0, 0);
  v6 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v6 >= *((_QWORD *)v4 + 3))
    return llvm::raw_ostream::write(v4, 125);
  *((_QWORD *)v4 + 4) = v6 + 1;
  *v6 = 125;
  return result;
}

llvm::raw_ostream *sub_1C61ED3B8(llvm *a1, unsigned int *a2, unsigned int *a3)
{
  llvm::raw_ostream *v6;
  llvm *v7;
  llvm::raw_ostream *v8;
  llvm *v9;
  llvm::raw_ostream *v10;
  llvm *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int **v14;
  uint64_t v15;
  unsigned int *v16;
  llvm *v17;
  llvm::raw_ostream *v18;
  llvm::raw_ostream *v19;
  _BYTE *v20;
  llvm::raw_ostream *result;
  const char *v22;
  const char *v23;
  llvm::raw_ostream *v24;

  v6 = (llvm::raw_ostream *)llvm::errs(a1);
  sub_1C4816AD8(v6, "Incorrect DFS numbers for:\n\tParent ");
  v7 = sub_1C61ED2E8(*(unsigned int **)a1);
  v8 = (llvm::raw_ostream *)llvm::errs(v7);
  sub_1C4816AD8(v8, "\n\tChild ");
  v9 = sub_1C61ED2E8(a2);
  if (a3)
  {
    v24 = (llvm::raw_ostream *)llvm::errs(v9);
    sub_1C4816AD8(v24, "\n\tSecond child ");
    v9 = sub_1C61ED2E8(a3);
  }
  v10 = (llvm::raw_ostream *)llvm::errs(v9);
  v11 = sub_1C4816AD8(v10, "\nAll children: ");
  v12 = *((_QWORD *)a1 + 1);
  v13 = *(unsigned int *)(v12 + 8);
  if ((_DWORD)v13)
  {
    v14 = *(unsigned int ***)v12;
    v15 = 8 * v13;
    do
    {
      v16 = *v14++;
      v17 = sub_1C61ED2E8(v16);
      v18 = (llvm::raw_ostream *)llvm::errs(v17);
      v11 = sub_1C4816AD8(v18, ", ");
      v15 -= 8;
    }
    while (v15);
  }
  v19 = (llvm::raw_ostream *)llvm::errs(v11);
  v20 = (_BYTE *)*((_QWORD *)v19 + 4);
  if ((unint64_t)v20 >= *((_QWORD *)v19 + 3))
  {
    v19 = llvm::raw_ostream::write(v19, 10);
  }
  else
  {
    *((_QWORD *)v19 + 4) = v20 + 1;
    *v20 = 10;
  }
  result = (llvm::raw_ostream *)llvm::errs(v19);
  v22 = (const char *)*((_QWORD *)result + 4);
  v23 = (const char *)*((_QWORD *)result + 2);
  if (v22 != v23)
  {
    *((_QWORD *)result + 4) = v23;
    return (llvm::raw_ostream *)llvm::raw_ostream::flush_tied_then_write(result, v23, v22 - v23);
  }
  return result;
}

uint64_t llvm::MachineFrameInfo::CreateVariableSizedObject(unsigned __int8 *a1, unsigned __int8 a2, uint64_t a3)
{
  unsigned __int8 v5;
  unint64_t v6;
  __int128 v7;
  __int128 v8;
  char *v9;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  a1[36] = 1;
  if (a2 > *a1 && a1[1] == 0)
    v5 = *a1;
  else
    v5 = a2;
  v11 = 0uLL;
  LOBYTE(v12) = v5;
  *(_DWORD *)((char *)&v12 + 1) = 0;
  *((_QWORD *)&v12 + 1) = a3;
  LODWORD(v13) = 256;
  BYTE4(v13) = 0;
  v6 = *((_QWORD *)a1 + 2);
  if (v6 >= *((_QWORD *)a1 + 3))
  {
    v9 = sub_1C515B9A4((void **)a1 + 1, (uint64_t)&v11);
  }
  else
  {
    v7 = v11;
    v8 = v12;
    *(_QWORD *)(v6 + 32) = v13;
    *(_OWORD *)v6 = v7;
    *(_OWORD *)(v6 + 16) = v8;
    v9 = (char *)(v6 + 40);
  }
  *((_QWORD *)a1 + 2) = v9;
  if (a1[60] < v5)
    a1[60] = v5;
  return ~*((_DWORD *)a1 + 8) - 858993459 * ((unint64_t)&v9[-*((_QWORD *)a1 + 1)] >> 3);
}

char *llvm::MachineFrameInfo::getPristineRegs@<X0>(llvm::MachineFrameInfo *this@<X0>, const llvm::MachineFunction *a2@<X1>, char *a3@<X8>)
{
  uint64_t v6;
  int v7;
  char *result;
  unsigned int v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned __int16 *v20;
  int v21;

  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 2) + 176))(*((_QWORD *)a2 + 2));
  v7 = *(_DWORD *)(v6 + 16);
  *(_QWORD *)a3 = a3 + 16;
  *((_QWORD *)a3 + 1) = 0x600000000;
  result = sub_1C4765AA4(a3, (v7 + 63) >> 6, 0);
  *((_DWORD *)a3 + 16) = v7;
  if (*((_BYTE *)this + 104))
  {
    result = (char *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*((llvm::MachineRegisterInfo **)a2 + 5));
    if (result)
    {
      v9 = *(unsigned __int16 *)result;
      if (*(_WORD *)result)
      {
        v10 = *(_QWORD *)a3;
        v11 = (unsigned __int16 *)(result + 2);
        do
        {
          *(_QWORD *)(v10 + 8 * (v9 >> 6)) |= 1 << v9;
          v12 = *v11++;
          v9 = v12;
        }
        while (v12);
      }
    }
    v13 = (unsigned int *)*((_QWORD *)this + 10);
    v14 = (unsigned int *)*((_QWORD *)this + 11);
    if (v13 != v14)
    {
      if (v6)
        v15 = (uint64_t *)(v6 + 8);
      else
        v15 = 0;
      v16 = v15[6];
      v17 = *v15;
      v18 = *(_QWORD *)a3;
      do
      {
        if (v16)
        {
          v19 = *v13;
          v20 = (unsigned __int16 *)(v16 + 2 * *(unsigned int *)(v17 + 24 * *v13 + 4));
          do
          {
            result = (char *)((unsigned __int16)v19 >> 6);
            *(_QWORD *)(v18 + 8 * (_QWORD)result) &= ~(1 << v19);
            v21 = *v20++;
            v19 += v21;
          }
          while (v21);
        }
        v13 += 3;
      }
      while (v13 != v14);
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MachineFrameInfo::dump(llvm::MachineFrameInfo *this, const llvm::MachineFunction *a2)
{
  llvm *v4;

  v4 = llvm::dbgs(this);
  return llvm::MachineFrameInfo::print(this, a2, v4);
}

llvm::raw_ostream *llvm::MachineFunctionProperties::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  unsigned int v2;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  llvm::raw_ostream *v7;

  v2 = *((_DWORD *)this + 16);
  if (v2)
  {
    v4 = (uint64_t)this;
    v5 = 0;
    v6 = (char *)&unk_1C86AE2AB;
    do
    {
      if (((*(_QWORD *)(*(_QWORD *)v4 + 8 * (v5 >> 6)) >> v5) & 1) != 0)
      {
        v7 = sub_1C4816AD8(a2, v6);
        this = sub_1C4816AD8(v7, off_1E8144B08[v5]);
        v2 = *(_DWORD *)(v4 + 64);
        v6 = ", ";
      }
      ++v5;
    }
    while (v5 < v2);
  }
  return this;
}

unint64_t llvm::MachineFunction::getOrCreateJumpTableInfo(llvm::MachineFunction *this, int a2)
{
  unint64_t result;

  result = *((_QWORD *)this + 9);
  if (!result)
  {
    result = sub_1C484358C((uint64_t)this + 128, 32, 3);
    *(_DWORD *)result = a2;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 8) = 0;
    *((_QWORD *)this + 9) = result;
  }
  return result;
}

uint64_t llvm::MachineFunction::getDenormalMode(uint64_t **a1, void *a2)
{
  return llvm::Function::getDenormalMode(*a1, a2);
}

uint64_t llvm::MachineFunction::assignBeginEndSections(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;

  v1 = this + 320;
  v2 = *(_QWORD *)(this + 328);
  *(_BYTE *)(v2 + 200) = 1;
  v3 = *(_QWORD *)(v2 + 8);
  if (v3 != this + 320)
  {
    v6 = v2 + 192;
    v4 = *(_DWORD *)(v2 + 192);
    v5 = *(_DWORD *)(v6 + 4);
    do
    {
      if (v4 != *(_DWORD *)(v3 + 192) || v5 != *(_DWORD *)(v3 + 196))
      {
        *(_BYTE *)(v3 + 200) = 1;
        *(_BYTE *)(*(_QWORD *)v3 + 201) = 1;
        v4 = *(_DWORD *)(v3 + 192);
        v5 = *(_DWORD *)(v3 + 196);
      }
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != v1);
  }
  *(_BYTE *)(*(_QWORD *)v1 + 201) = 1;
  return this;
}

void llvm::MachineFunction::copyCallSiteInfo(llvm::MachineFunction *this, const llvm::MachineInstr *a2, const llvm::MachineInstr *a3)
{
  unsigned __int16 *v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  BOOL v8;
  const llvm::MachineInstr *v9;
  uint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  const llvm::MachineInstr *v13;
  void *v14[2];
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v13 = a3;
  v4 = (unsigned __int16 *)*((_QWORD *)a3 + 2);
  if ((v4[4] & 0x80) != 0
    && ((v5 = *v4, v6 = v5 > 0x1F, v7 = (1 << v5) & 0x8E000000, !v6) ? (v8 = v7 == 0) : (v8 = 1), v8))
  {
    v9 = (const llvm::MachineInstr *)sub_1C515E7A8((unint64_t)a2);
    v10 = llvm::MachineFunction::getCallSiteInfo(this, v9);
    if (*((_QWORD *)this + 93) + 32 * *((unsigned int *)this + 190) != v10)
    {
      v11 = (uint64_t *)((char *)this + 744);
      v14[0] = v15;
      v14[1] = (void *)0x100000000;
      if (*(_DWORD *)(v10 + 16))
        sub_1C61EF4B8((uint64_t)v14, v10 + 8);
      v12 = sub_1C61EF588(v11, &v13);
      sub_1C61EF4B8((uint64_t)(v12 + 1), (uint64_t)v14);
      if (v14[0] != v15)
        free(v14[0]);
    }
  }
  else
  {
    llvm::MachineFunction::eraseCallSiteInfo((int32x2_t *)this, a2);
  }
}

double llvm::MachineFunction::getMachineMemOperand(llvm::MachineFunction *this, const llvm::MachineMemOperand *a2, const llvm::MachinePointerInfo *a3, uint64_t a4)
{
  unint64_t v7;
  __int16 v8;
  char v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;
  double result;

  v7 = sub_1C484358C((uint64_t)this + 128, 80, 3);
  v8 = *((_WORD *)a2 + 16);
  v9 = *((_BYTE *)a2 + 34);
  v10 = *((_WORD *)a2 + 18);
  v11 = ((unint64_t)(a4 & 0x1FFFFFFF) << 6) | 1;
  if (a4 == -1)
    v11 = 0;
  v12 = *((_QWORD *)a3 + 2);
  *(_OWORD *)v7 = *(_OWORD *)a3;
  *(_QWORD *)(v7 + 16) = v12;
  *(_QWORD *)(v7 + 24) = v11;
  *(_WORD *)(v7 + 32) = v8;
  *(_BYTE *)(v7 + 34) = v9;
  *(_QWORD *)(v7 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_WORD *)(v7 + 36) = v10;
  return result;
}

double llvm::MachineFunction::getMachineMemOperand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7;
  __int16 v8;
  char v9;
  __int16 v10;
  uint64_t v11;
  double result;

  v7 = sub_1C484358C(a1 + 128, 80, 3);
  v8 = *(_WORD *)(a2 + 32);
  v9 = *(_BYTE *)(a2 + 34);
  v10 = *(_WORD *)(a2 + 36);
  v11 = *(_QWORD *)(a3 + 16);
  *(_OWORD *)v7 = *(_OWORD *)a3;
  *(_QWORD *)(v7 + 16) = v11;
  *(_QWORD *)(v7 + 24) = a4;
  *(_WORD *)(v7 + 32) = v8;
  *(_BYTE *)(v7 + 34) = v9;
  *(_QWORD *)(v7 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_WORD *)(v7 + 36) = v10;
  return result;
}

void llvm::MachineFunction::dump(llvm::MachineFunction *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  llvm::MachineFunction::print((llvm::Value **)this, v2, 0);
}

void llvm::MachineFunction::print(llvm::Value **this, llvm::raw_ostream *a2, const llvm::SlotIndexes *a3)
{
  llvm::raw_ostream *v6;
  size_t v7;
  char *Name;
  size_t v9;
  void *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  uint64_t v13;
  llvm::Value *v14;
  uint64_t v15;
  llvm::Value *v16;
  int *v17;
  int *v18;
  llvm::SlotTracker **v19;
  int *v20;
  void (**v21)(void);
  llvm::raw_ostream *v22;
  void (**v23)(void);
  int v24;
  _BYTE *v25;
  llvm::raw_ostream *i;
  _BYTE *v27;
  llvm::raw_ostream *v28;
  size_t v29;
  char *v30;
  size_t v31;
  void *v32;
  llvm::SlotTracker *v33[3];
  llvm::SlotTracker **v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v6 = sub_1C4816AD8(a2, "# Machine code for function ");
  Name = llvm::Value::getName(*this);
  v9 = v7;
  v10 = (void *)*((_QWORD *)v6 + 4);
  if (v7 <= *((_QWORD *)v6 + 3) - (_QWORD)v10)
  {
    if (v7)
    {
      memcpy(v10, Name, v7);
      *((_QWORD *)v6 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v6, Name, v7);
  }
  sub_1C4816AD8(v6, ": ");
  llvm::MachineFunctionProperties::print((llvm::raw_ostream *)(this + 45), a2);
  v11 = (_BYTE *)*((_QWORD *)a2 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((_QWORD *)a2 + 4) = v11 + 1;
    *v11 = 10;
  }
  llvm::MachineFrameInfo::print(this[7], (const llvm::MachineFunction *)this, a2);
  v12 = this[9];
  if (v12)
    llvm::MachineJumpTableInfo::print(v12, a2);
  llvm::MachineConstantPool::print(this[8], a2);
  v13 = (*(uint64_t (**)(llvm::Value *))(*(_QWORD *)this[2] + 176))(this[2]);
  v14 = this[5];
  if (v14 && *((_QWORD *)v14 + 57) != *((_QWORD *)v14 + 58))
  {
    v15 = v13;
    sub_1C4816AD8(a2, "Function Live Ins: ");
    v16 = this[5];
    v17 = (int *)*((_QWORD *)v16 + 57);
    v18 = (int *)*((_QWORD *)v16 + 58);
    if (v17 != v18)
    {
      llvm::printReg(*v17, v15, 0, 0, (uint64_t)v33);
      v19 = v34;
      if (!v34)
LABEL_43:
        sub_1C485C2F0();
      v20 = v17 + 2;
      while (1)
      {
        (*((void (**)(llvm::SlotTracker **, llvm::raw_ostream *))*v19 + 6))(v19, a2);
        if (v34 == v33)
        {
          v21 = (void (**)(void))((char *)v33[0] + 32);
        }
        else
        {
          if (!v34)
            goto LABEL_19;
          v21 = (void (**)(void))((char *)*v34 + 40);
        }
        (*v21)();
LABEL_19:
        if (*(v20 - 1))
        {
          v22 = sub_1C4816AD8(a2, " in ");
          llvm::printReg(*(v20 - 1), v15, 0, 0, (uint64_t)v33);
          if (!v34)
            goto LABEL_43;
          (*((void (**)(llvm::SlotTracker **, llvm::raw_ostream *))*v34 + 6))(v34, v22);
          if (v34 == v33)
          {
            v23 = (void (**)(void))((char *)v33[0] + 32);
            goto LABEL_24;
          }
          if (v34)
          {
            v23 = (void (**)(void))((char *)*v34 + 40);
LABEL_24:
            (*v23)();
          }
        }
        if (v20 == v18)
          break;
        sub_1C4816AD8(a2, ", ");
        v24 = *v20;
        v20 += 2;
        llvm::printReg(v24, v15, 0, 0, (uint64_t)v33);
        v19 = v34;
        if (!v34)
          goto LABEL_43;
      }
    }
    v25 = (_BYTE *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v25 >= *((_QWORD *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v25 + 1;
      *v25 = 10;
    }
  }
  llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v33, *((_QWORD *)*this + 5), 1);
  llvm::ModuleSlotTracker::incorporateFunction(v33, *this);
  for (i = this[41]; i != (llvm::raw_ostream *)(this + 40); i = (llvm::raw_ostream *)*((_QWORD *)i + 1))
  {
    v27 = (_BYTE *)*((_QWORD *)a2 + 4);
    if ((unint64_t)v27 >= *((_QWORD *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((_QWORD *)a2 + 4) = v27 + 1;
      *v27 = 10;
    }
    llvm::MachineBasicBlock::print(i, a2, v33, a3, 1);
  }
  v28 = sub_1C4816AD8(a2, "\n# End machine code for function ");
  v30 = llvm::Value::getName(*this);
  v31 = v29;
  v32 = (void *)*((_QWORD *)v28 + 4);
  if (v29 <= *((_QWORD *)v28 + 3) - (_QWORD)v32)
  {
    if (v29)
    {
      memcpy(v32, v30, v29);
      *((_QWORD *)v28 + 4) += v31;
    }
  }
  else
  {
    llvm::raw_ostream::write(v28, v30, v29);
  }
  sub_1C4816AD8(v28, ".\n\n");
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v33);
}

char *llvm::MachineFunction::getName(llvm::Value **this)
{
  return llvm::Value::getName(*this);
}

llvm::raw_ostream *llvm::MachineJumpTableInfo::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t (**v7)(void);
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t (**v13)(void);
  _BYTE *v14;
  _BYTE *v15;
  uint64_t (**v16)();
  int v17;
  uint64_t (***v18)();
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 1) != *((_QWORD *)this + 2))
  {
    v3 = this;
    this = sub_1C4816AD8(a2, "Jump Tables:\n");
    v4 = -1431655765 * ((*((_QWORD *)v3 + 2) - *((_QWORD *)v3 + 1)) >> 3);
    if (!(_DWORD)v4)
      goto LABEL_29;
    v5 = 0;
    while (1)
    {
      v18 = &v16;
      v16 = &off_1E8144AD0;
      v17 = v5;
      sub_1C5160434((uint64_t)&v16, a2);
      v6 = (_BYTE *)*((_QWORD *)a2 + 4);
      if ((unint64_t)v6 >= *((_QWORD *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 58);
      }
      else
      {
        *((_QWORD *)a2 + 4) = v6 + 1;
        *v6 = 58;
      }
      this = (llvm::raw_ostream *)v18;
      if (v18 == &v16)
        break;
      if (v18)
      {
        v7 = *v18 + 5;
LABEL_10:
        this = (llvm::raw_ostream *)(*v7)();
      }
      v8 = *((_QWORD *)v3 + 1) + 24 * v5;
      v10 = *(uint64_t **)v8;
      v9 = *(uint64_t **)(v8 + 8);
      while (v10 != v9)
      {
        v11 = *v10;
        v12 = (_BYTE *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v12 >= *((_QWORD *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, 32);
        }
        else
        {
          *((_QWORD *)a2 + 4) = v12 + 1;
          *v12 = 32;
        }
        llvm::printMBBReference(v11, &v16);
        if (!v18)
          sub_1C485C2F0();
        ((void (*)(uint64_t (***)(), llvm::raw_ostream *))(*v18)[6])(v18, a2);
        this = (llvm::raw_ostream *)v18;
        if (v18 == &v16)
        {
          v13 = v16 + 4;
        }
        else
        {
          if (!v18)
            goto LABEL_21;
          v13 = *v18 + 5;
        }
        this = (llvm::raw_ostream *)(*v13)();
LABEL_21:
        ++v10;
      }
      v14 = (_BYTE *)*((_QWORD *)a2 + 4);
      if ((unint64_t)v14 >= *((_QWORD *)a2 + 3))
      {
        this = llvm::raw_ostream::write(a2, 10);
      }
      else
      {
        *((_QWORD *)a2 + 4) = v14 + 1;
        *v14 = 10;
      }
      if (++v5 == v4)
      {
LABEL_29:
        v15 = (_BYTE *)*((_QWORD *)a2 + 4);
        if ((unint64_t)v15 >= *((_QWORD *)a2 + 3))
          return llvm::raw_ostream::write(a2, 10);
        *((_QWORD *)a2 + 4) = v15 + 1;
        *v15 = 10;
        return this;
      }
    }
    v7 = v16 + 4;
    goto LABEL_10;
  }
  return this;
}

llvm::raw_ostream *llvm::MachineConstantPool::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  llvm::Value *v10;
  llvm::raw_ostream *v11;

  if (*((_QWORD *)this + 1) != *((_QWORD *)this + 2))
  {
    v3 = this;
    this = sub_1C4816AD8(a2, "Constant Pool:\n");
    v4 = *((_QWORD *)v3 + 2) - *((_QWORD *)v3 + 1);
    if ((v4 & 0xFFFFFFFF0) != 0)
    {
      v5 = 0;
      v6 = 0;
      v7 = (v4 >> 4);
      do
      {
        v8 = sub_1C4816AD8(a2, "  cp#");
        sub_1C5E21910(v8, v6, 0, 0, 0);
        sub_1C4816AD8(v8, ": ");
        v9 = *((_QWORD *)v3 + 1) + v5;
        v10 = *(llvm::Value **)v9;
        if (*(_BYTE *)(v9 + 9))
          (*(void (**)(llvm::Value *, llvm::raw_ostream *))(*(_QWORD *)v10 + 48))(v10, a2);
        else
          llvm::Value::printAsOperand(v10, a2, 0, 0);
        v11 = sub_1C4816AD8(a2, ", align=");
        sub_1C5E21910(v11, 1 << *(_BYTE *)(*((_QWORD *)v3 + 1) + v5 + 8), 0, 0, 0);
        this = sub_1C4816AD8(a2, "\n");
        ++v6;
        v5 += 16;
      }
      while (v7 != v6);
    }
  }
  return this;
}

uint64_t llvm::MachineFunction::needsFrameMoves(llvm::MachineFunction *this)
{
  uint64_t v2;
  llvm::AttributeList *v3;

  if (*(_BYTE *)(*((_QWORD *)this + 4) + 2108))
    return 1;
  if ((*(_WORD *)(*((_QWORD *)this + 1) + 1064) & 0x10) != 0)
    return 1;
  v2 = *(_QWORD *)this;
  v3 = (llvm::AttributeList *)(*(_QWORD *)this + 112);
  if (llvm::AttributeList::getUWTableKind(v3)
    || !*(_QWORD *)v3
    || (*(_BYTE *)(*(_QWORD *)v3 + 16) & 0x20) == 0)
  {
    return 1;
  }
  else
  {
    return (*(unsigned __int16 *)(v2 + 18) >> 3) & 1;
  }
}

llvm::MachineBasicBlock **llvm::MachineFunction::getOrCreateLandingPadInfo(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2)
{
  char *v3;
  llvm::MachineBasicBlock **v4;
  unsigned int v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD v9[3];
  _QWORD v10[3];
  _QWORD v11[3];
  _BYTE v12[48];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = (char *)*((_QWORD *)this + 65);
  v4 = (llvm::MachineBasicBlock **)*((_QWORD *)this + 64);
  v5 = -286331153 * ((unint64_t)(v3 - (char *)v4) >> 3);
  if (v5)
  {
    v6 = -286331153 * ((unint64_t)(v3 - (char *)v4) >> 3);
    while (*v4 != a2)
    {
      v4 += 15;
      if (!--v6)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v9[0] = a2;
    v9[1] = v10;
    v9[2] = 0x100000000;
    v10[1] = v11;
    v10[2] = 0x100000000;
    v11[1] = v12;
    v11[2] = 0x100000000;
    memset(&v12[16], 0, 32);
    if ((unint64_t)v3 >= *((_QWORD *)this + 66))
      v7 = sub_1C516001C((void **)this + 64, (uint64_t)v9);
    else
      v7 = sub_1C61EF394(v3, (uint64_t)v9) + 15;
    *((_QWORD *)this + 65) = v7;
    sub_1C61EEFF0(v9);
    return (llvm::MachineBasicBlock **)(*((_QWORD *)this + 64) + 120 * v5);
  }
  return v4;
}

_DWORD *llvm::MachineFunction::addInvoke(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2, llvm::MCSymbol *a3, llvm::MCSymbol *a4)
{
  _DWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = llvm::MachineFunction::getOrCreateLandingPadInfo(this, a2);
  v7 = (uint64_t)result;
  v8 = result[4];
  if (v8 >= result[5])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(result + 2), (uint64_t)(result + 6), v8 + 1, 8);
    LODWORD(v8) = *(_DWORD *)(v7 + 16);
  }
  *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * v8) = a3;
  ++*(_DWORD *)(v7 + 16);
  v9 = *(unsigned int *)(v7 + 40);
  if (v9 >= *(_DWORD *)(v7 + 44))
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod(v7 + 32, v7 + 48, v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(v7 + 40);
  }
  *(_QWORD *)(*(_QWORD *)(v7 + 32) + 8 * v9) = a4;
  ++*(_DWORD *)(v7 + 40);
  return result;
}

char *llvm::MachineFunction::addCleanup(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2)
{
  llvm::MachineBasicBlock **LandingPadInfo;
  llvm::MachineBasicBlock *v3;
  char *result;
  int v5;

  LandingPadInfo = llvm::MachineFunction::getOrCreateLandingPadInfo(this, a2);
  v5 = 0;
  v3 = LandingPadInfo[13];
  if (v3 >= LandingPadInfo[14])
  {
    result = sub_1C4E36640((char **)LandingPadInfo + 12, &v5);
  }
  else
  {
    *(_DWORD *)v3 = 0;
    result = (char *)v3 + 4;
  }
  LandingPadInfo[13] = (llvm::MachineBasicBlock *)result;
  return result;
}

char *llvm::MachineFunction::addCatchTypeInfo(llvm::MachineFunction *a1, llvm::MachineBasicBlock *a2, uint64_t a3, uint64_t a4)
{
  char *result;
  char *v8;
  char **v9;
  uint64_t v10;
  uint64_t v11;
  int TypeIDFor;
  _DWORD *v13;
  int v14;

  result = (char *)llvm::MachineFunction::getOrCreateLandingPadInfo(a1, a2);
  if (a4)
  {
    v8 = result;
    v9 = (char **)(result + 96);
    v10 = 8 * a4;
    v11 = a3 - 8;
    do
    {
      TypeIDFor = llvm::MachineFunction::getTypeIDFor(a1, *(const llvm::GlobalValue **)(v11 + v10));
      v14 = TypeIDFor;
      v13 = (_DWORD *)*((_QWORD *)v8 + 13);
      if ((unint64_t)v13 >= *((_QWORD *)v8 + 14))
      {
        result = sub_1C4E36640(v9, &v14);
      }
      else
      {
        *v13 = TypeIDFor;
        result = (char *)(v13 + 1);
      }
      *((_QWORD *)v8 + 13) = result;
      v10 -= 8;
    }
    while (v10);
  }
  return result;
}

void llvm::MachineFunction::addFilterTypeInfo(llvm::MachineFunction *a1, llvm::MachineBasicBlock *a2, uint64_t a3, unint64_t a4)
{
  llvm::MachineBasicBlock **LandingPadInfo;
  char *v8;
  int FilterIDFor;
  llvm::MachineBasicBlock *v10;
  char *v11;
  uint64_t v12;
  int v13;
  char *v14;
  char *v15;
  char *v16;

  LandingPadInfo = llvm::MachineFunction::getOrCreateLandingPadInfo(a1, a2);
  v8 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if (a4)
  {
    if (a4 >> 62)
      abort();
    v8 = (char *)operator new(4 * a4);
    v14 = v8;
    v16 = &v8[4 * a4];
    bzero(v8, 4 * a4);
    v15 = v16;
    if ((_DWORD)a4)
    {
      v12 = 0;
      do
      {
        *(_DWORD *)&v8[4 * v12] = llvm::MachineFunction::getTypeIDFor(a1, *(const llvm::GlobalValue **)(a3 + 8 * v12));
        ++v12;
      }
      while (a4 != v12);
    }
  }
  FilterIDFor = llvm::MachineFunction::getFilterIDFor((uint64_t)a1, &v14);
  v13 = FilterIDFor;
  v10 = LandingPadInfo[13];
  if (v10 >= LandingPadInfo[14])
  {
    v11 = sub_1C4E36640((char **)LandingPadInfo + 12, &v13);
  }
  else
  {
    *(_DWORD *)v10 = FilterIDFor;
    v11 = (char *)v10 + 4;
  }
  LandingPadInfo[13] = (llvm::MachineBasicBlock *)v11;
  if (v8)
    operator delete(v8);
}

unint64_t llvm::MachineFunction::getTypeIDFor(llvm::MachineFunction *this, const llvm::GlobalValue *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  const llvm::GlobalValue *v8;

  v8 = a2;
  v3 = (_QWORD *)*((_QWORD *)this + 82);
  v4 = *((_QWORD *)this + 81);
  if ((((unint64_t)v3 - v4) & 0x7FFFFFFF8) != 0)
  {
    v5 = 0;
    while (*(const llvm::GlobalValue **)(v4 + 8 * v5) != a2)
    {
      if ((((unint64_t)v3 - v4) >> 3) == ++v5)
        goto LABEL_5;
    }
    return (v5 + 1);
  }
  else
  {
LABEL_5:
    if ((unint64_t)v3 >= *((_QWORD *)this + 83))
    {
      v6 = sub_1C4DFEA3C((void **)this + 81, &v8);
    }
    else
    {
      *v3 = a2;
      v6 = v3 + 1;
    }
    *((_QWORD *)this + 82) = v6;
    return ((unint64_t)v6 - *((_QWORD *)this + 81)) >> 3;
  }
}

uint64_t llvm::MachineFunction::getFilterIDFor(uint64_t a1, char **a2)
{
  unsigned int *v4;
  unsigned int *v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  _DWORD *v14;
  char *v15;
  char *v16;
  int v18;
  int v19;

  v4 = *(unsigned int **)(a1 + 696);
  v5 = *(unsigned int **)(a1 + 704);
  for (i = a2[1] - *a2; v4 != v5; ++v4)
  {
    v7 = *v4;
    v8 = i & 0x3FFFFFFFCLL;
    while (v7 && v8)
    {
      v9 = *(_DWORD *)(*(_QWORD *)(a1 + 672) + 4 * v7 - 4);
      v10 = *(_DWORD *)&(*a2)[v8 - 4];
      v8 -= 4;
      --v7;
      if (v9 != v10)
        goto LABEL_8;
    }
    if (!v8)
      return ~(_DWORD)v7;
LABEL_8:
    ;
  }
  v11 = *(_QWORD *)(a1 + 680) - *(_QWORD *)(a1 + 672);
  sub_1C515E708(a1 + 672, (i >> 2) + (v11 >> 2) + 1);
  sub_1C4E36A24((char **)(a1 + 672), *(char **)(a1 + 680), *a2, a2[1], (a2[1] - *a2) >> 2);
  v12 = *(_DWORD **)(a1 + 680);
  v13 = ((unint64_t)v12 - *(_QWORD *)(a1 + 672)) >> 2;
  v19 = v13;
  v14 = *(_DWORD **)(a1 + 704);
  if ((unint64_t)v14 >= *(_QWORD *)(a1 + 712))
  {
    v15 = sub_1C4E36640((char **)(a1 + 696), &v19);
    v12 = *(_DWORD **)(a1 + 680);
  }
  else
  {
    *v14 = v13;
    v15 = (char *)(v14 + 1);
  }
  v7 = v11 >> 2;
  *(_QWORD *)(a1 + 704) = v15;
  v18 = 0;
  if ((unint64_t)v12 >= *(_QWORD *)(a1 + 688))
  {
    v16 = sub_1C4E36640((char **)(a1 + 672), &v18);
  }
  else
  {
    *v12 = 0;
    v16 = (char *)(v12 + 1);
  }
  *(_QWORD *)(a1 + 680) = v16;
  return ~(_DWORD)v7;
}

unsigned int *llvm::MachineFunction::setCallSiteLandingPad(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  unsigned int *v6;
  uint64_t v8;

  v8 = a2;
  v6 = (unsigned int *)sub_1C61EF05C(a1 + 536, &v8);
  return sub_1C4860A74(v6 + 2, a3, &a3[4 * a4]);
}

uint64_t llvm::MachineFunction::getCallSiteInfo(llvm::MachineFunction *this, const llvm::MachineInstr *a2)
{
  const llvm::MachineInstr *v4;
  uint64_t v5;

  if ((*(_WORD *)(*((_QWORD *)this + 1) + 1064) & 1) == 0)
    return *((_QWORD *)this + 93) + 32 * *((unsigned int *)this + 190);
  v4 = a2;
  v5 = 0;
  if (sub_1C61805E8((uint64_t *)this + 93, &v4, &v5))
    return v5;
  else
    return *((_QWORD *)this + 93) + 32 * *((unsigned int *)this + 190);
}

int32x2_t llvm::MachineFunction::eraseCallSiteInfo(int32x2_t *this, const llvm::MachineInstr *a2)
{
  const llvm::MachineInstr *v3;
  uint64_t v4;
  int32x2_t result;
  _QWORD *v6;
  _QWORD *v7;

  v3 = (const llvm::MachineInstr *)sub_1C515E7A8((unint64_t)a2);
  v4 = llvm::MachineFunction::getCallSiteInfo((llvm::MachineFunction *)this, v3);
  if (*(_QWORD *)&this[93] + 32 * this[95].u32[0] != v4)
  {
    v6 = (_QWORD *)v4;
    v7 = *(_QWORD **)(v4 + 8);
    if (v7 != v6 + 3)
      free(v7);
    *v6 = -8192;
    result = vadd_s32(this[94], (int32x2_t)0x1FFFFFFFFLL);
    this[94] = result;
  }
  return result;
}

void llvm::MachineFunction::moveCallSiteInfo(llvm::MachineFunction *this, const llvm::MachineInstr *a2, const llvm::MachineInstr *a3)
{
  unsigned __int16 *v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  BOOL v8;
  const llvm::MachineInstr *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  const llvm::MachineInstr *v14;
  void *v15[2];
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v14 = a3;
  v4 = (unsigned __int16 *)*((_QWORD *)a3 + 2);
  if ((v4[4] & 0x80) != 0
    && ((v5 = *v4, v6 = v5 > 0x1F, v7 = (1 << v5) & 0x8E000000, !v6) ? (v8 = v7 == 0) : (v8 = 1), v8))
  {
    v9 = (const llvm::MachineInstr *)sub_1C515E7A8((unint64_t)a2);
    v10 = llvm::MachineFunction::getCallSiteInfo(this, v9);
    if (*((_QWORD *)this + 93) + 32 * *((unsigned int *)this + 190) != v10)
    {
      v11 = (_QWORD *)v10;
      v15[0] = v16;
      v15[1] = (void *)0x100000000;
      if (*(_DWORD *)(v10 + 16))
        sub_1C61EF278((uint64_t)v15, v10 + 8);
      v12 = (_QWORD *)v11[1];
      if (v12 != v11 + 3)
        free(v12);
      *v11 = -8192;
      *((int32x2_t *)this + 94) = vadd_s32(*(int32x2_t *)((char *)this + 752), (int32x2_t)0x1FFFFFFFFLL);
      v13 = sub_1C61EF588((uint64_t *)this + 93, &v14);
      sub_1C61EF4B8((uint64_t)(v13 + 1), (uint64_t)v15);
      if (v15[0] != v16)
        free(v15[0]);
    }
  }
  else
  {
    llvm::MachineFunction::eraseCallSiteInfo((int32x2_t *)this, a2);
  }
}

__n128 llvm::MachineFunction::makeDebugValueSubstitution(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  __n128 *v5;
  __n128 *v6;
  __n128 result;
  _QWORD v8[2];
  int v9;

  v8[0] = a2;
  v8[1] = a3;
  v9 = a4;
  v5 = (__n128 *)sub_1C5160200(a1 + 920, (unint64_t)v8, 1);
  v6 = (__n128 *)(*(_QWORD *)(a1 + 920) + 20 * *(unsigned int *)(a1 + 928));
  result = *v5;
  v6[1].n128_u32[0] = v5[1].n128_u32[0];
  *v6 = result;
  ++*(_DWORD *)(a1 + 928);
  return result;
}

uint64_t llvm::MachineJumpTableInfo::getEntrySize(llvm::MachineJumpTableInfo *this, const llvm::DataLayout *a2)
{
  return ((uint64_t (*)(uint64_t, const llvm::DataLayout *))((char *)sub_1C61EEB00
                                                                    + 4 * byte_1C85FB230[*(unsigned int *)this]))(8, a2);
}

uint64_t sub_1C61EEB00()
{
  return 4;
}

unint64_t sub_1C61EEB08(int a1, llvm::DataLayout *this)
{
  return llvm::DataLayout::getPointerSize(this, 0);
}

uint64_t sub_1C61EEB14()
{
  return 0;
}

void llvm::MachineJumpTableInfo::getEntryAlignment(llvm::MachineJumpTableInfo *this, const llvm::DataLayout *a2)
{
  __asm { BR              X10 }
}

uint64_t sub_1C61EEB48(int a1, llvm::DataLayout *this, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  return 1 << llvm::DataLayout::getIntegerAlignment(this, 0x20u, 1);
}

void sub_1C61EEB6C(int a1, llvm::DataLayout *this)
{
  llvm::DataLayout::getPointerABIAlignment(this, 0);
  JUMPOUT(0x1C61EEB60);
}

void sub_1C61EEB84()
{
  JUMPOUT(0x1C61EEB54);
}

uint64_t llvm::MachineJumpTableInfo::ReplaceMBBInJumpTables(llvm::MachineJumpTableInfo *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  llvm::MachineBasicBlock **v7;
  llvm::MachineBasicBlock **v8;

  v3 = *((_QWORD *)this + 2) - *((_QWORD *)this + 1);
  if (v3)
  {
    v4 = 0;
    v5 = 0xAAAAAAAAAAAAAAABLL * (v3 >> 3);
    do
    {
      v6 = *((_QWORD *)this + 1) + 24 * v4;
      v7 = *(llvm::MachineBasicBlock ***)v6;
      v8 = *(llvm::MachineBasicBlock ***)(v6 + 8);
      while (v7 != v8)
      {
        if (*v7 == a2)
          *v7 = a3;
        ++v7;
      }
      ++v4;
    }
    while (v4 != v5);
  }
  return 0;
}

llvm::raw_ostream *llvm::MachineJumpTableInfo::dump(llvm::MachineJumpTableInfo *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return llvm::MachineJumpTableInfo::print(this, v2);
}

uint64_t llvm::MachineConstantPoolEntry::getSizeInBytes(uint64_t **this, const llvm::DataLayout *a2)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  int v7;
  BOOL v8;
  const char *v9;
  char v10;
  uint64_t v11;

  v3 = **this;
  if (*((_BYTE *)this + 9))
    return (*(uint64_t (**)(void))(v3 + 24))();
  sub_1C4768AD0((uint64_t)a2, v3);
  v6 = (unint64_t)(v5 + 7) >> 3;
  v8 = v7 == 1;
  llvm::DataLayout::getAlignment((uint64_t)a2, v3);
  v11 = ((1 << v10) + 0xFFFFFFFFLL + v6) & -(1 << v10);
  if (v8)
  return v11;
}

uint64_t llvm::MachineConstantPoolEntry::getSectionKind(llvm::MachineConstantPoolEntry *this, const llvm::DataLayout *a2)
{
  unsigned int v5;
  unint64_t v6;

  if (*((_BYTE *)this + 9) || llvm::Constant::getRelocationInfo(*(llvm::Constant **)this) == 2)
    return 20;
  HIDWORD(v6) = llvm::MachineConstantPoolEntry::getSizeInBytes((uint64_t **)this, a2);
  LODWORD(v6) = HIDWORD(v6) - 4;
  v5 = v6 >> 2;
  if (v5 > 7)
    return 4;
  else
    return dword_1C85FB280[v5];
}

uint64_t llvm::MachineConstantPool::getConstantPoolIndex(unsigned __int8 *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v6;
  _OWORD *v7;
  char *v8;
  uint64_t v9;
  uint64_t v11;
  __int128 v12;

  v11 = a2;
  if (*a1 < a3)
    *a1 = a3;
  v6 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, _QWORD))(*(_QWORD *)a2 + 32))(a2, a1, a3);
  if ((_DWORD)v6 == -1)
  {
    BYTE8(v12) = a3;
    BYTE9(v12) = 1;
    *(_QWORD *)&v12 = a2;
    v7 = (_OWORD *)*((_QWORD *)a1 + 2);
    if ((unint64_t)v7 >= *((_QWORD *)a1 + 3))
    {
      v8 = sub_1C51604B8((char **)a1 + 1, &v12);
    }
    else
    {
      *v7 = v12;
      v8 = (char *)(v7 + 1);
    }
    *((_QWORD *)a1 + 2) = v8;
    return ((unint64_t)&v8[-*((_QWORD *)a1 + 1)] >> 4) - 1;
  }
  else
  {
    v9 = v6;
    sub_1C61EF798((uint64_t)(a1 + 32), &v11, (uint64_t)&v12);
  }
  return v9;
}

llvm::raw_ostream *llvm::MachineConstantPool::dump(llvm::MachineConstantPool *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return llvm::MachineConstantPool::print(this, v2);
}

uint64_t sub_1C61EEE48(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = *(void **)(a1 + 560);
  if (v2 != (void *)(a1 + 576))
    free(v2);
  v3 = *(void **)(a1 + 448);
  if (v3 != (void *)(a1 + 464))
    free(v3);
  sub_1C61EEEDC((char **)(a1 + 176));
  v4 = *(void **)(a1 + 96);
  if (v4 != (void *)(a1 + 112))
    free(v4);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 72), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 48), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 24), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)a1, 8);
  return a1;
}

char **sub_1C61EEEDC(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = v3 << 6;
    do
    {
      v5 = *(char **)&v2[v4 - 48];
      if (&v2[v4 - 32] != v5)
        free(v5);
      v4 -= 64;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

uint64_t sub_1C61EEF4C(uint64_t a1)
{
  sub_1C61EEF8C((unsigned int *)(a1 + 24));
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 24), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)a1, 8);
  return a1;
}

void sub_1C61EEF8C(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;

  v1 = a1[4];
  if ((_DWORD)v1)
  {
    v2 = 72 * v1;
    v3 = (void **)(*(_QWORD *)a1 + 16);
    do
    {
      if (((unint64_t)*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v3 != *(v3 - 1))
        free(*v3);
      v3 += 9;
      v2 -= 72;
    }
    while (v2);
  }
}

_QWORD *sub_1C61EEFF0(_QWORD *a1)
{
  void *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v2 = (void *)a1[12];
  if (v2)
  {
    a1[13] = v2;
    operator delete(v2);
  }
  v3 = (_QWORD *)a1[7];
  if (v3 != a1 + 9)
    free(v3);
  v4 = (_QWORD *)a1[4];
  if (v4 != a1 + 6)
    free(v4);
  v5 = (_QWORD *)a1[1];
  if (v5 != a1 + 3)
    free(v5);
  return a1;
}

_QWORD *sub_1C61EF05C(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61DBB84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61EF0D4(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x400000000;
  }
  return v5;
}

_QWORD *sub_1C61EF0D4(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C515FA90(a1, v6);
  v8 = 0;
  sub_1C61DBB84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61EF184(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 40 * v6;
    do
    {
      *v7 = -4096;
      v7 += 5;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61DBB84(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C4EA2F88(v11, v4 + 8);
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1C61EF278(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  void *v6;
  _DWORD *v7;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a1 != a2)
  {
    v5 = (const void *)(a2 + 16);
    v4 = *(const void **)a2;
    if (v4 != v5)
    {
      v6 = *(void **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *(const void **)a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_6;
    }
    v7 = (_DWORD *)(a2 + 8);
    v9 = *(unsigned int *)(a2 + 8);
    v10 = *(unsigned int *)(a1 + 8);
    if (v10 >= v9)
    {
      if ((_DWORD)v9)
        memmove(*(void **)a1, v4, 8 * v9 - 2);
      goto LABEL_16;
    }
    if (*(_DWORD *)(a1 + 12) >= v9)
    {
      if ((_DWORD)v10)
      {
        memmove(*(void **)a1, v4, 8 * v10 - 2);
LABEL_12:
        v11 = *v7;
        if (v10 != v11)
          memcpy((void *)(*(_QWORD *)a1 + 8 * v10), (const void *)(*(_QWORD *)a2 + 8 * v10), *(_QWORD *)a2 + 8 * v11 - (*(_QWORD *)a2 + 8 * v10));
LABEL_16:
        *(_DWORD *)(a1 + 8) = v9;
LABEL_6:
        *v7 = 0;
        return a1;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v9, 8);
    }
    v10 = 0;
    goto LABEL_12;
  }
  return a1;
}

_QWORD *sub_1C61EF394(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;

  *a1 = *(_QWORD *)a2;
  a1[1] = a1 + 3;
  v4 = (uint64_t)(a1 + 1);
  a1[2] = 0x100000000;
  if (*(_DWORD *)(a2 + 16))
    sub_1C614D378(v4, a2 + 8);
  a1[4] = a1 + 6;
  a1[5] = 0x100000000;
  if (*(_DWORD *)(a2 + 40))
    sub_1C614D378((uint64_t)(a1 + 4), a2 + 32);
  a1[7] = a1 + 9;
  a1[8] = 0x100000000;
  if (*(_DWORD *)(a2 + 64))
    sub_1C6180FA8((uint64_t)(a1 + 7), a2 + 56);
  a1[11] = *(_QWORD *)(a2 + 88);
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  *((_OWORD *)a1 + 6) = *(_OWORD *)(a2 + 96);
  a1[14] = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 112) = 0;
  return a1;
}

_QWORD *sub_1C61EF45C(_QWORD *a1, __n128 *a2)
{
  *a1 = a2->n128_u64[0];
  sub_1C614D378((uint64_t)(a1 + 1), (uint64_t)&a2->n128_i64[1]);
  sub_1C614D378((uint64_t)(a1 + 4), (uint64_t)&a2[2]);
  sub_1C6180FA8((uint64_t)(a1 + 7), (uint64_t)&a2[3].n128_i64[1]);
  a1[11] = a2[5].n128_u64[1];
  sub_1C6184574((uint64_t)(a1 + 12), a2 + 6);
  return a1;
}

uint64_t sub_1C61EF4B8(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a1 != a2)
  {
    v4 = *(unsigned int *)(a2 + 8);
    v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if ((_DWORD)v4)
        memmove(*(void **)a1, *(const void **)a2, 8 * v4 - 2);
      goto LABEL_10;
    }
    if (*(_DWORD *)(a1 + 12) >= v4)
    {
      if ((_DWORD)v5)
      {
        memmove(*(void **)a1, *(const void **)a2, 8 * v5 - 2);
LABEL_6:
        v6 = *(unsigned int *)(a2 + 8);
        if (v5 != v6)
          memcpy((void *)(*(_QWORD *)a1 + 8 * v5), (const void *)(*(_QWORD *)a2 + 8 * v5), *(_QWORD *)a2 + 8 * v6 - (*(_QWORD *)a2 + 8 * v5));
LABEL_10:
        *(_DWORD *)(a1 + 8) = v4;
        return a1;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, v4, 8);
    }
    v5 = 0;
    goto LABEL_6;
  }
  return a1;
}

_QWORD *sub_1C61EF588(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61805E8(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61EF5F8((uint64_t)a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x100000000;
  }
  return v5;
}

_QWORD *sub_1C61EF5F8(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C5160148(a1, v7);
  v9 = 0;
  sub_1C61805E8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

void sub_1C61EF6A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  _QWORD *v12;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 32 * v6;
    do
    {
      *v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v12 = 0;
        sub_1C61805E8((uint64_t *)a1, (_QWORD *)v4, &v12);
        v9 = v12;
        *v12 = *(_QWORD *)v4;
        v9[2] = 0x100000000;
        v9[1] = v9 + 3;
        v10 = (uint64_t)(v9 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C61EF278(v10, v4 + 8);
        ++*(_DWORD *)(a1 + 8);
        v11 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v11)
          free(v11);
      }
      v4 += 32;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1C61EF798@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61B75F0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61B7684(a1, a2, v10);
    v7 = (_QWORD *)result;
    *(_QWORD *)result = *a2;
    v8 = 1;
  }
  v9 = *(_QWORD *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v9;
  *(_BYTE *)(a3 + 16) = v8;
  return result;
}

uint64_t llvm::MachineFunctionPass::createPrinterPass(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::createMachineFunctionPrinterPass(a2, a3);
}

void sub_1C61EF83C(uint64_t a1)
{
  sub_1C50B4134(a1);
  JUMPOUT(0x1CAA32FC0);
}

void llvm::initializeMachineFunctionPrinterPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FA930);
  if (v2 != -1)
  {
    v5[0] = sub_1C5160F74;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FA930, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createMachineFunctionSplitterPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C516148C(v1);
}

void llvm::initializeUnpackMachineBundlesPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FAAD0);
  if (v2 != -1)
  {
    v5[0] = sub_1C5161CD4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FAAD0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeFinalizeMachineBundlesPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FAAD8);
  if (v2 != -1)
  {
    v5[0] = sub_1C5161F54;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FAAD8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

_QWORD *sub_1C61EF9B4(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  if (!a3 || (*(_BYTE *)a3 & 4) == 0)
  {
    while ((*(_WORD *)(a3 + 44) & 8) != 0)
      a3 = *(_QWORD *)(a3 + 8);
  }
  v6 = *(_QWORD *)(a3 + 8);
  if (v6 != a4)
  {
    do
    {
      if (!v6 || (v7 = v6, (*(_BYTE *)v6 & 4) == 0))
      {
        v7 = v6;
        if ((*(_WORD *)(v6 + 44) & 8) != 0)
        {
          v7 = v6;
          do
            v7 = *(_QWORD *)(v7 + 8);
          while ((*(_WORD *)(v7 + 44) & 8) != 0);
        }
      }
      v8 = *(_QWORD *)(v7 + 8);
      llvm::MachineInstr::bundleWithPred(v6);
      v6 = v8;
    }
    while (v8 != a4);
  }
  return a1;
}

uint64_t *sub_1C61EFA50(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  llvm::MachineBasicBlock::insert(*a1, a2, a3);
  v6 = a1[2];
  if (a1[1] == a2)
  {
    if (v6 != a2)
      llvm::MachineInstr::bundleWithSucc(a3);
    a1[1] = a3;
  }
  else if (v6 == a2)
  {
    llvm::MachineInstr::bundleWithPred(a3);
  }
  else
  {
    *(_WORD *)(a3 + 44) |= 0xCu;
  }
  return a1;
}

unint64_t *llvm::MachineInstr::moveBefore(unint64_t **this, unint64_t **a2)
{
  return sub_1C48532D0(a2[3], (unint64_t *)a2, this[3], (unint64_t *)this);
}

const llvm::MachineInstr *llvm::MachineInstr::cloneMemRefs(const llvm::MachineInstr *this, llvm::MachineFunction *a2, const llvm::MachineInstr *a3)
{
  unint64_t v3;
  int *v4;
  BOOL v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int *v10;
  BOOL v12;
  uint64_t v13;
  int *v14;
  int *v15;
  unint64_t v16;
  int *v17;
  unint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  _BYTE *v22;

  if (this == a3)
    return this;
  v3 = *((_QWORD *)this + 6);
  if (v3 < 8)
    goto LABEL_13;
  v4 = (int *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((*((_QWORD *)this + 6) & 7) != 1 || v4 == 0)
  {
    v6 = (*((_QWORD *)this + 6) & 7) != 3 || v4 == 0;
    if (!v6 && *((_BYTE *)v4 + 4))
    {
      v4 = *(int **)&v4[2 * *v4 + 2];
      goto LABEL_14;
    }
LABEL_13:
    v4 = 0;
  }
LABEL_14:
  v9 = *((_QWORD *)a3 + 6);
  v7 = (unint64_t *)((char *)a3 + 48);
  v8 = v9;
  if (v9 < 8)
    goto LABEL_25;
  v10 = (int *)(v8 & 0xFFFFFFFFFFFFFFF8);
  if ((v8 & 7) != 1 || v10 == 0)
  {
    v12 = (v8 & 7) != 3 || v10 == 0;
    if (!v12 && *((_BYTE *)v10 + 4))
    {
      v10 = *(int **)&v10[2 * *v10 + 2];
      goto LABEL_26;
    }
LABEL_25:
    v10 = 0;
  }
LABEL_26:
  if (v4 == v10)
  {
    if (v3 >= 8)
    {
      v15 = (int *)(v3 & 0xFFFFFFFFFFFFFFF8);
      if ((*((_QWORD *)this + 6) & 7) == 2 && (v16 = v3 & 0xFFFFFFFFFFFFFFF8, v15)
        || (v16 = 0, (*((_QWORD *)this + 6) & 7) != 3)
        || !v15)
      {
LABEL_42:
        if (v8 >= 8)
        {
          v17 = (int *)(v8 & 0xFFFFFFFFFFFFFFF8);
          if ((v8 & 7) == 2 && (v18 = v8 & 0xFFFFFFFFFFFFFFF8, v17) || (v18 = 0, (v8 & 7) != 3) || !v17)
          {
LABEL_50:
            if (v16 != v18)
              goto LABEL_27;
            if (v3 >= 8)
            {
              v19 = 0;
              if ((*((_QWORD *)this + 6) & 7) != 3 || (v20 = (_BYTE *)(v3 & 0xFFFFFFFFFFFFFFF8)) == 0)
              {
LABEL_62:
                if (v8 >= 8)
                {
                  v21 = 0;
                  if ((v8 & 7) != 3 || (v22 = (_BYTE *)(v8 & 0xFFFFFFFFFFFFFFF8), (v8 & 0xFFFFFFFFFFFFFFF8) == 0))
                  {
LABEL_68:
                    if (v19 == v21)
                    {
                      *((_QWORD *)this + 6) = v8;
                      return this;
                    }
                    goto LABEL_27;
                  }
                  if (v22[6])
                  {
                    v21 = *(_QWORD *)&v22[8 * *(int *)v22 + 8 + 8 * (v22[5] + v22[4])];
                    goto LABEL_68;
                  }
                }
                v21 = 0;
                goto LABEL_68;
              }
              if (v20[6])
              {
                v19 = *(_QWORD *)&v20[8 * *(int *)v20 + 8 + 8 * (v20[5] + v20[4])];
                goto LABEL_62;
              }
            }
            v19 = 0;
            goto LABEL_62;
          }
          if (*((_BYTE *)v17 + 5))
          {
            v18 = *(_QWORD *)&v17[2 * *v17 + 2 + 2 * *((unsigned __int8 *)v17 + 4)];
            goto LABEL_50;
          }
        }
        v18 = 0;
        goto LABEL_50;
      }
      if (*((_BYTE *)v15 + 5))
      {
        v16 = *(_QWORD *)&v15[2 * *v15 + 2 + 2 * *((unsigned __int8 *)v15 + 4)];
        goto LABEL_42;
      }
    }
    v16 = 0;
    goto LABEL_42;
  }
LABEL_27:
  if (v8 < 8)
  {
    v7 = 0;
    v13 = 0;
  }
  else if ((v8 & 7) != 0)
  {
    v7 = 0;
    v13 = 0;
    if ((v8 & 7) == 3)
    {
      v14 = (int *)(v8 & 0xFFFFFFFFFFFFFFF8);
      if (v14)
      {
        v13 = *v14;
        v7 = (unint64_t *)(v14 + 2);
      }
    }
  }
  else
  {
    *v7 = v8 & 0xFFFFFFFFFFFFFFF8;
    v13 = 1;
  }
  return (const llvm::MachineInstr *)llvm::MachineInstr::setMemRefs((unint64_t)this, a2, v7, v13);
}

uint64_t llvm::MachineInstr::setPreInstrSymbol(uint64_t this, llvm::MachineFunction *a2, llvm::MCSymbol *a3)
{
  unint64_t *v4;
  unint64_t v5;
  llvm::MCSymbol *v6;
  BOOL v8;
  uint64_t v9;
  BOOL v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  char v16;
  char v17;

  v4 = (unint64_t *)(this + 48);
  v5 = *(_QWORD *)(this + 48);
  if (v5 < 8)
    goto LABEL_12;
  v6 = (llvm::MCSymbol *)(v5 & 0xFFFFFFFFFFFFFFF8);
  if ((*(_QWORD *)(this + 48) & 7) != 1 || v6 == 0)
  {
    v8 = (*(_QWORD *)(this + 48) & 7) != 3 || v6 == 0;
    if (!v8 && *((_BYTE *)v6 + 4))
    {
      v6 = (llvm::MCSymbol *)*((_QWORD *)v6 + *(int *)v6 + 1);
      goto LABEL_13;
    }
LABEL_12:
    v6 = 0;
  }
LABEL_13:
  if (v6 == a3)
    return this;
  v9 = *(_QWORD *)(this + 48) & 7;
  if (a3 || v9 != 1)
  {
    if (v5 < 8)
    {
      v4 = 0;
      v12 = 0;
      v13 = 0;
    }
    else
    {
      if ((v5 & 7) == 0)
      {
        v13 = 0;
        v14 = 0;
        *v4 = v5 & 0xFFFFFFFFFFFFFFF8;
        v12 = 1;
        return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, (uint64_t)a3, v13, v14);
      }
      v10 = v9 != 3;
      v11 = (unsigned __int8 *)(v5 & 0xFFFFFFFFFFFFFFF8);
      if (!v11)
        v10 = 1;
      if (v10)
      {
        v4 = 0;
        v12 = 0;
      }
      else
      {
        v4 = (unint64_t *)(v11 + 8);
        v12 = *(int *)v11;
      }
      v15 = v9 != 2 || v11 == 0;
      v16 = v15;
      v17 = v10 | v16 ^ 1;
      if (v15)
        v13 = 0;
      else
        v13 = (uint64_t)v11;
      if ((v17 & 1) == 0)
      {
        v13 = v11[5] ? *(_QWORD *)&v11[8 * *(int *)v11 + 8 + 8 * v11[4]] : 0;
        if (v11[6])
        {
          v14 = *(_QWORD *)&v11[8 * *(int *)v11 + 8 + 8 * v11[5] + 8 * v11[4]];
          return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, (uint64_t)a3, v13, v14);
        }
      }
    }
    v14 = 0;
    return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, (uint64_t)a3, v13, v14);
  }
  *v4 = 0;
  return this;
}

uint64_t llvm::MachineInstr::setPostInstrSymbol(uint64_t this, llvm::MachineFunction *a2, llvm::MCSymbol *a3)
{
  unint64_t *v4;
  unint64_t v5;
  unsigned __int8 *v6;
  BOOL v8;
  uint64_t v9;
  BOOL v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  char v16;
  char v17;

  v4 = (unint64_t *)(this + 48);
  v5 = *(_QWORD *)(this + 48);
  if (v5 < 8)
    goto LABEL_12;
  v6 = (unsigned __int8 *)(v5 & 0xFFFFFFFFFFFFFFF8);
  if ((*(_QWORD *)(this + 48) & 7) != 2 || v6 == 0)
  {
    v8 = (*(_QWORD *)(this + 48) & 7) != 3 || v6 == 0;
    if (!v8 && v6[5])
    {
      v6 = *(unsigned __int8 **)&v6[8 * *(int *)v6 + 8 + 8 * v6[4]];
      goto LABEL_13;
    }
LABEL_12:
    v6 = 0;
  }
LABEL_13:
  if (v6 == (unsigned __int8 *)a3)
    return this;
  v9 = *(_QWORD *)(this + 48) & 7;
  if (a3 || v9 != 2)
  {
    if (v5 < 8)
    {
      v4 = 0;
      v12 = 0;
      v13 = 0;
    }
    else
    {
      if ((v5 & 7) == 0)
      {
        v13 = 0;
        v14 = 0;
        *v4 = v5 & 0xFFFFFFFFFFFFFFF8;
        v12 = 1;
        return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, v13, (uint64_t)a3, v14);
      }
      v10 = v9 != 3;
      v11 = (_BYTE *)(v5 & 0xFFFFFFFFFFFFFFF8);
      if (!v11)
        v10 = 1;
      if (v10)
      {
        v4 = 0;
        v12 = 0;
      }
      else
      {
        v4 = (unint64_t *)(v11 + 8);
        v12 = *(int *)v11;
      }
      v15 = v9 != 1 || v11 == 0;
      v16 = v15;
      v17 = v10 | v16 ^ 1;
      if (v15)
        v13 = 0;
      else
        v13 = (uint64_t)v11;
      if ((v17 & 1) == 0)
      {
        v13 = v11[4] ? *(_QWORD *)&v11[8 * *(int *)v11 + 8] : 0;
        if (v11[6])
        {
          v14 = *(_QWORD *)&v11[8 * *(int *)v11 + 8 + 8 * v11[5] + 8 * v11[4]];
          return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, v13, (uint64_t)a3, v14);
        }
      }
    }
    v14 = 0;
    return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, v13, (uint64_t)a3, v14);
  }
  *v4 = 0;
  return this;
}

uint64_t llvm::MachineInstr::setHeapAllocMarker(uint64_t this, llvm::MachineFunction *a2, llvm::MDNode *a3)
{
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  _BYTE *v8;
  _BOOL4 v9;
  llvm::MDNode *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = (_QWORD *)(this + 48);
  v5 = *(_QWORD *)(this + 48);
  if (v5 < 8)
  {
    if (a3)
    {
      v12 = 0;
      v4 = 0;
      v11 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    v6 = *(_QWORD *)(this + 48) & 7;
    v7 = v6 != 3;
    v8 = (_BYTE *)(v5 & 0xFFFFFFFFFFFFFFF8);
    v9 = v8 == 0;
    if (!v8)
      v7 = 1;
    if (v7 || !v8[6])
      v10 = 0;
    else
      v10 = *(llvm::MDNode **)&v8[8 * *(int *)v8 + 8 + 8 * (v8[5] + v8[4])];
    if (v10 != a3)
    {
      if (v6)
      {
        if (v7)
        {
          v4 = 0;
          v11 = 0;
        }
        else
        {
          v4 = v8 + 8;
          v11 = *(int *)v8;
        }
        if (v6 == 1 && v8)
        {
          v13 = 0;
          v12 = (uint64_t)v8;
          return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
        }
        if (!v7)
        {
          if (v8[4])
            v12 = *(_QWORD *)&v8[8 * *(int *)v8 + 8];
          else
            v12 = 0;
          if (v8[5])
          {
            v13 = *(_QWORD *)&v8[8 * *(int *)v8 + 8 + 8 * v8[4]];
            return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
          }
          goto LABEL_12;
        }
LABEL_19:
        v12 = 0;
        if (v6 != 2 || v9)
          v13 = 0;
        else
          v13 = (uint64_t)v8;
        return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
      }
      *v4 = v8;
      v11 = 1;
      if (v8)
      {
        v6 = 0;
        v9 = 0;
        goto LABEL_19;
      }
      v12 = 0;
LABEL_12:
      v13 = 0;
      return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
    }
  }
  return this;
}

const llvm::MachineInstr *llvm::MachineInstr::cloneInstrSymbols(const llvm::MachineInstr *this, llvm::MachineFunction *a2, const llvm::MachineInstr *a3)
{
  const llvm::MachineInstr *v5;
  unint64_t v6;
  llvm::MCSymbol *v7;
  BOOL v9;
  unint64_t v10;
  uint64_t v11;
  llvm::MCSymbol *v12;
  BOOL v13;
  llvm::MCSymbol *v14;
  unint64_t v15;
  llvm::MDNode *v16;
  _BYTE *v17;

  if (this != a3)
  {
    v5 = this;
    v6 = *((_QWORD *)a3 + 6);
    if (v6 < 8)
      goto LABEL_13;
    v7 = (llvm::MCSymbol *)(v6 & 0xFFFFFFFFFFFFFFF8);
    if ((v6 & 7) == 1 && v7 != 0)
      goto LABEL_14;
    v9 = (v6 & 7) != 3 || v7 == 0;
    if (!v9 && *((_BYTE *)v7 + 4))
      v7 = (llvm::MCSymbol *)*((_QWORD *)v7 + *(int *)v7 + 1);
    else
LABEL_13:
      v7 = 0;
LABEL_14:
    llvm::MachineInstr::setPreInstrSymbol((uint64_t)this, a2, v7);
    v10 = *((_QWORD *)a3 + 6);
    if (v10 < 8)
      goto LABEL_23;
    v11 = *((_QWORD *)a3 + 6) & 7;
    v12 = (llvm::MCSymbol *)(v10 & 0xFFFFFFFFFFFFFFF8);
    v13 = v11 != 2 || v12 == 0;
    v14 = v12;
    if (!v13)
      goto LABEL_24;
    v14 = 0;
    if (v11 != 3 || !v12)
      goto LABEL_24;
    if (*((_BYTE *)v12 + 5))
      v14 = (llvm::MCSymbol *)*((_QWORD *)v12 + *(int *)v12 + *((unsigned __int8 *)v12 + 4) + 1);
    else
LABEL_23:
      v14 = 0;
LABEL_24:
    llvm::MachineInstr::setPostInstrSymbol((uint64_t)v5, a2, v14);
    v15 = *((_QWORD *)a3 + 6);
    if (v15 < 8)
      goto LABEL_28;
    v16 = 0;
    if ((*((_QWORD *)a3 + 6) & 7) != 3)
      return (const llvm::MachineInstr *)llvm::MachineInstr::setHeapAllocMarker((uint64_t)v5, a2, v16);
    v17 = (_BYTE *)(v15 & 0xFFFFFFFFFFFFFFF8);
    if (!v17)
      return (const llvm::MachineInstr *)llvm::MachineInstr::setHeapAllocMarker((uint64_t)v5, a2, v16);
    if (v17[6])
      v16 = *(llvm::MDNode **)&v17[8 * *(int *)v17 + 8 + 8 * (v17[5] + v17[4])];
    else
LABEL_28:
      v16 = 0;
    return (const llvm::MachineInstr *)llvm::MachineInstr::setHeapAllocMarker((uint64_t)v5, a2, v16);
  }
  return this;
}

llvm::MachineInstr *llvm::MachineInstr::removeFromBundle(llvm::MachineBasicBlock **this)
{
  return llvm::MachineBasicBlock::remove_instr(this[3], (llvm::MachineInstr *)this);
}

uint64_t llvm::MachineInstr::bundleWithSucc(uint64_t this)
{
  *(_WORD *)(this + 44) |= 8u;
  *(_WORD *)(*(_QWORD *)(this + 8) + 44) |= 4u;
  return this;
}

uint64_t llvm::MachineInstr::unbundleFromPred(uint64_t this)
{
  *(_WORD *)(this + 44) &= ~4u;
  *(_WORD *)((*(_QWORD *)this & 0xFFFFFFFFFFFFFFF8) + 44) &= ~8u;
  return this;
}

uint64_t llvm::MachineInstr::getInlineAsmDialect(llvm::MachineInstr *this)
{
  return (*(_DWORD *)(*((_QWORD *)this + 4) + 48) >> 2) & 1;
}

uint64_t llvm::MachineInstr::findInlineAsmFlagIdx(llvm::MachineInstr *this, unsigned int a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t result;
  unsigned int v7;

  if (a2 >= 2)
  {
    v3 = *((_DWORD *)this + 10);
    if (v3 >= 3)
    {
      v4 = 0;
      v5 = *((_QWORD *)this + 4);
      result = 2;
      while (*(_BYTE *)(v5 + 32 * result) == 1)
      {
        v7 = result + ((unsigned __int16)*(_DWORD *)(v5 + 32 * result + 16) >> 3) + 1;
        if (v7 > a2)
        {
          if (a3)
            *a3 = v4;
          return result;
        }
        ++v4;
        result = result + ((unsigned __int16)*(_DWORD *)(v5 + 32 * result + 16) >> 3) + 1;
        if (v7 >= v3)
          return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t llvm::MachineInstr::getDebugLabel(llvm::MachineInstr *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 4) + 16);
}

uint64_t llvm::MachineInstr::getRegClassConstraintEffectForVReg(unint64_t a1, int a2, uint64_t a3, llvm::TargetInstrInfo *a4, llvm::TargetRegisterInfo *a5, int a6)
{
  uint64_t RegClassConstraintEffect;
  uint64_t v11;
  uint64_t v12;
  llvm::MachineInstr *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  RegClassConstraintEffect = a3;
  if (a6)
  {
    sub_1C516AD9C(&v25, a1);
    if (RegClassConstraintEffect)
    {
      v12 = v27;
      v11 = v28;
      if (v27 != v28)
      {
        do
        {
          v13 = *(llvm::MachineInstr **)(v12 + 8);
          v14 = v12 - *(_QWORD *)(v25 + 32);
          v15 = *((_QWORD *)v13 + 4);
          v16 = (v14 >> 5);
          if (!*(_BYTE *)(v15 + 32 * v16) && *(_DWORD *)(v15 + 32 * v16 + 4) == a2)
          {
            RegClassConstraintEffect = llvm::MachineInstr::getRegClassConstraintEffect(v13, v14 >> 5, RegClassConstraintEffect, a4, a5);
            v12 = v27;
            v11 = v28;
          }
          v12 += 32;
          v27 = v12;
          if (v12 == v11)
          {
            v18 = *(_QWORD *)(v25 + 8);
            if (v18 == v26)
            {
              v12 = v11;
            }
            else
            {
              v12 = v11;
              if ((*(_WORD *)(v18 + 44) & 4) != 0)
              {
                while (1)
                {
                  v12 = *(_QWORD *)(v18 + 32);
                  v19 = *(unsigned int *)(v18 + 40);
                  v11 = v12 + 32 * v19;
                  if ((_DWORD)v19)
                    break;
                  v18 = *(_QWORD *)(v18 + 8);
                  if (v18 == v26 || (*(_WORD *)(v18 + 44) & 4) == 0)
                  {
                    v27 = v12;
                    v28 = v12 + 32 * v19;
                    v11 = v28;
                    goto LABEL_21;
                  }
                }
                v27 = *(_QWORD *)(v18 + 32);
                v28 = v12 + 32 * v19;
                v25 = v18;
                continue;
              }
            }
LABEL_21:
            v25 = v26;
          }
        }
        while (v12 != v11 && RegClassConstraintEffect != 0);
      }
    }
  }
  else if (a3)
  {
    v20 = *(unsigned int *)(a1 + 40);
    if ((_DWORD)v20)
    {
      v21 = 0;
      v22 = 1;
      do
      {
        v23 = *(_QWORD *)(a1 + 32);
        if (!*(_BYTE *)(v23 + v21) && *(_DWORD *)(v23 + v21 + 4) == a2)
          RegClassConstraintEffect = llvm::MachineInstr::getRegClassConstraintEffect((llvm::MachineInstr *)a1, (v22 - 1), RegClassConstraintEffect, a4, a5);
        if (v22 >= v20)
          break;
        ++v22;
        v21 += 32;
      }
      while (RegClassConstraintEffect);
    }
  }
  return RegClassConstraintEffect;
}

uint64_t llvm::MachineInstr::getRegClassConstraintEffect(llvm::MachineInstr *a1, uint64_t a2, uint64_t a3, llvm::TargetInstrInfo *a4, llvm::TargetRegisterInfo *a5)
{
  unsigned int v7;
  uint64_t RegClassConstraint;
  uint64_t v10;
  uint64_t v11;

  v7 = a2;
  RegClassConstraint = llvm::MachineInstr::getRegClassConstraint(a1, a2, a4, a5);
  v10 = (*(_DWORD *)(*((_QWORD *)a1 + 4) + 32 * v7) >> 8) & 0xFFF;
  if ((_DWORD)v10)
  {
    v11 = *(_QWORD *)a5;
    if (RegClassConstraint)
      return (*(uint64_t (**)(llvm::TargetRegisterInfo *, uint64_t, uint64_t))(v11 + 184))(a5, a3, RegClassConstraint);
    else
      return (*(uint64_t (**)(llvm::TargetRegisterInfo *, uint64_t, uint64_t))(v11 + 200))(a5, a3, v10);
  }
  else if (RegClassConstraint)
  {
    return llvm::TargetRegisterInfo::getCommonSubClass((uint64_t)a5, a3, RegClassConstraint);
  }
  else
  {
    return a3;
  }
}

uint64_t llvm::MachineInstr::getBundleSize(llvm::MachineInstr *this)
{
  uint64_t v1;

  if ((*((_WORD *)this + 22) & 8) == 0)
    return 0;
  LODWORD(v1) = 0;
  do
  {
    v1 = (v1 + 1);
    this = (llvm::MachineInstr *)*((_QWORD *)this + 1);
  }
  while ((*((_WORD *)this + 22) & 8) != 0);
  return v1;
}

uint64_t llvm::MachineInstr::findFirstPredOperandIdx(llvm::MachineInstr *this)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  char *v4;
  char v5;

  v1 = *((_QWORD *)this + 2);
  if ((*(_BYTE *)(v1 + 10) & 0x40) == 0)
    return 0xFFFFFFFFLL;
  v3 = *((unsigned int *)this + 10);
  if (!(_DWORD)v3)
    return 0xFFFFFFFFLL;
  result = 0;
  v4 = (char *)(*(_QWORD *)(v1 + 40) + 2);
  while (1)
  {
    v5 = *v4;
    v4 += 6;
    if ((v5 & 2) != 0)
      break;
    if (v3 == ++result)
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t llvm::MachineInstr::isConstantValuePHI(llvm::MachineInstr *this)
{
  int v1;
  uint64_t v4;
  uint64_t result;
  unsigned int v6;
  unsigned int v7;

  v1 = **((unsigned __int16 **)this + 2);
  if (v1 != 69 && v1 != 0)
    return 0;
  v4 = *((_QWORD *)this + 4);
  result = *(unsigned int *)(v4 + 36);
  v6 = *((_DWORD *)this + 10);
  if (v6 >= 4)
  {
    v7 = 3;
    while (*(_DWORD *)(v4 + 32 * v7 + 4) == (_DWORD)result)
    {
      v7 += 2;
      if (v7 >= v6)
        return result;
    }
    return 0;
  }
  return result;
}

void llvm::MachineInstr::dump(llvm::MachineInstr *this)
{
  llvm *v2;
  llvm *v3;
  llvm *v4;

  v2 = llvm::dbgs(this);
  v3 = sub_1C4816AD8(v2, "  ");
  v4 = llvm::dbgs(v3);
  llvm::MachineInstr::print(this, v4, 1, 0, 0, 1, 0);
}

void llvm::MachineInstr::print(llvm::MachineInstr *this, llvm::raw_ostream *a2, char a3, char a4, char a5, int a6, const llvm::TargetInstrInfo *a7)
{
  const llvm::TargetInstrInfo *v7;
  uint64_t v14;
  const llvm::Function **v15;
  const llvm::Function *v16;
  uint64_t v17;
  const llvm::Function *v18[15];

  v7 = a7;
  v18[14] = *(const llvm::Function **)MEMORY[0x1E0C80C00];
  v14 = *((_QWORD *)this + 3);
  if (v14 && (v15 = *(const llvm::Function ***)(v14 + 32)) != 0)
  {
    v16 = *v15;
    v17 = *((_QWORD *)*v15 + 5);
    if (!a7)
      v7 = (const llvm::TargetInstrInfo *)(*(uint64_t (**)(const llvm::Function *))(*(_QWORD *)v15[2] + 104))(v15[2]);
    llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v18, v17, 1);
    llvm::ModuleSlotTracker::incorporateFunction(v18, v16);
  }
  else
  {
    llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v18, 0, 1);
  }
  llvm::MachineInstr::print(this, a2, (llvm::ModuleSlotTracker *)v18, a3, a4, a5, a6, v7);
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v18);
}

void llvm::MachineInstr::dumprImpl(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, llvm::SmallPtrSetImplBase *a5)
{
  llvm *v10;
  char v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t UniqueVRegDef;

  if (a3 < a4)
  {
    v10 = (llvm *)sub_1C4774094(a5, a1);
    if (v11)
    {
      if (a3)
      {
        v12 = llvm::fdbgs(v10);
        v10 = llvm::formatted_raw_ostream::PadToColumn((llvm::formatted_raw_ostream *)v12, 2 * a3);
      }
      v13 = llvm::fdbgs(v10);
      llvm::MachineInstr::print((llvm::MachineInstr *)a1, (llvm::raw_ostream *)v13, 1, 0, 0, 1, 0);
      v14 = *(unsigned int *)(a1 + 40);
      if ((_DWORD)v14)
      {
        v15 = *(_QWORD *)(a1 + 32);
        v16 = 32 * v14;
        v17 = (unsigned int *)(v15 + 4);
        do
        {
          if ((*(v17 - 1) & 0x10000FF) == 0 && *v17 - 1 >= 0x3FFFFFFF)
          {
            UniqueVRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(a2, *v17);
            if (UniqueVRegDef)
              llvm::MachineInstr::dumprImpl(UniqueVRegDef, a2, a3 + 1, a4, a5);
          }
          v17 += 8;
          v16 -= 32;
        }
        while (v16);
      }
    }
  }
}

void llvm::MachineInstr::dumpr(llvm::MachineInstr *this, const llvm::MachineRegisterInfo *a2, uint64_t a3)
{
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  int v6;
  _BYTE v7[128];

  v3 = v7;
  v4 = v7;
  v5 = 16;
  v6 = 0;
  llvm::MachineInstr::dumprImpl((uint64_t)this, (uint64_t)a2, 0, a3, (llvm::SmallPtrSetImplBase *)&v3);
  if (v4 != v3)
    free(v4);
}

char *sub_1C61F08E4(int a1)
{
  return off_1E8145070[a1 - 1];
}

llvm::MachineFunction *llvm::BuildMI(uint64_t a1, unint64_t *a2, unsigned __int8 **a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  llvm::MachineFunction *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v10 = *(llvm::MachineFunction **)(a1 + 32);
  llvm::BuildMI(v10, a3, a4, a5, a6, a7, a8);
  v12 = v11;
  llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)(a1 + 40), v11);
  v13 = *a2 & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)v12 = v13 | *(_QWORD *)v12 & 7;
  *(_QWORD *)(v12 + 8) = a2;
  *(_QWORD *)(v13 + 8) = v12;
  *a2 = *a2 & 7 | v12;
  return v10;
}

llvm::MachineInstr **llvm::BuildMI(uint64_t a1, unint64_t *a2, unsigned __int8 **a3, uint64_t a4, int a5, int *a6, uint64_t a7, uint64_t a8)
{
  llvm::MachineInstr **v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v10 = *(llvm::MachineInstr ***)(a1 + 32);
  llvm::BuildMI(v10, a3, a4, a5, a6, a7, a8);
  v12 = v11;
  llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)(a1 + 40), v11);
  v13 = *a2 & 0xFFFFFFFFFFFFFFF8;
  *(_QWORD *)v12 = v13 | *(_QWORD *)v12 & 7;
  *(_QWORD *)(v12 + 8) = a2;
  *(_QWORD *)(v13 + 8) = v12;
  *a2 = *a2 & 7 | v12;
  return v10;
}

llvm::MachineInstr *llvm::buildDbgValueForSpill(uint64_t a1, unint64_t *a2, uint64_t a3, int a4, int a5)
{
  llvm::DIExpression *v10;
  llvm::MachineInstr *v11;
  llvm::MachineFunction *v12;
  llvm::MachineInstr *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v10 = sub_1C516A018(a3, a5);
  v12 = sub_1C477A100(a1, a2, (unsigned __int8 **)(a3 + 56), *(_QWORD *)(a3 + 16));
  v13 = v11;
  v14 = **(unsigned __int16 **)(a3 + 16);
  if (v14 == 13)
  {
    LODWORD(v21) = 5;
    *((_QWORD *)&v21 + 1) = 0;
    LODWORD(v22) = a4;
    llvm::MachineInstr::addOperand(v11, v12, (const llvm::MachineOperand *)&v21);
    LODWORD(v21) = 1;
    *((_QWORD *)&v21 + 1) = 0;
    *(_QWORD *)&v22 = 0;
    llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
    v14 = **(unsigned __int16 **)(a3 + 16);
  }
  v15 = *(_QWORD *)(*(_QWORD *)(a3 + 32) + ((unint64_t)(v14 != 14) << 6) + 16);
  LODWORD(v21) = 14;
  *((_QWORD *)&v21 + 1) = 0;
  *(_QWORD *)&v22 = v15;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
  LODWORD(v21) = 14;
  *((_QWORD *)&v21 + 1) = 0;
  *(_QWORD *)&v22 = v10;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
  if (**(_WORD **)(a3 + 16) == 14)
  {
    v16 = *(unsigned int *)(a3 + 40);
    if ((_DWORD)v16 != 2)
    {
      v18 = *(_QWORD *)(a3 + 32) + 64;
      v19 = 32 * v16 - 64;
      do
      {
        if (*(_BYTE *)v18 || *(_DWORD *)(v18 + 4) != a5)
        {
          v20 = *(_OWORD *)(v18 + 16);
          v21 = *(_OWORD *)v18;
          v22 = v20;
        }
        else
        {
          LODWORD(v21) = 5;
          *((_QWORD *)&v21 + 1) = 0;
          LODWORD(v22) = a4;
        }
        llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
        v18 += 32;
        v19 -= 32;
      }
      while (v19);
    }
  }
  return v13;
}

llvm::MachineInstr *llvm::buildDbgValueForSpill(uint64_t a1, unint64_t *a2, uint64_t a3, int a4, uint64_t a5)
{
  llvm::DIExpression *v10;
  llvm::MachineInstr *v11;
  llvm::MachineFunction *v12;
  llvm::MachineInstr *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  __int128 v24;
  __int128 v26;
  __int128 v27;

  v10 = sub_1C516A264(a3, *(uint64_t **)a5, *(_DWORD *)(a5 + 8));
  v12 = sub_1C477A100(a1, a2, (unsigned __int8 **)(a3 + 56), *(_QWORD *)(a3 + 16));
  v13 = v11;
  v14 = **(unsigned __int16 **)(a3 + 16);
  if (v14 == 13)
  {
    LODWORD(v26) = 5;
    *((_QWORD *)&v26 + 1) = 0;
    LODWORD(v27) = a4;
    llvm::MachineInstr::addOperand(v11, v12, (const llvm::MachineOperand *)&v26);
    LODWORD(v26) = 1;
    *((_QWORD *)&v26 + 1) = 0;
    *(_QWORD *)&v27 = 0;
    llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
    v14 = **(unsigned __int16 **)(a3 + 16);
  }
  v15 = *(_QWORD *)(*(_QWORD *)(a3 + 32) + ((unint64_t)(v14 != 14) << 6) + 16);
  LODWORD(v26) = 14;
  *((_QWORD *)&v26 + 1) = 0;
  *(_QWORD *)&v27 = v15;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
  LODWORD(v26) = 14;
  *((_QWORD *)&v26 + 1) = 0;
  *(_QWORD *)&v27 = v10;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
  if (**(_WORD **)(a3 + 16) == 14)
  {
    v16 = *(unsigned int *)(a3 + 40);
    if ((_DWORD)v16 != 2)
    {
      v17 = *(_QWORD *)(a3 + 32);
      v18 = (__int128 *)(v17 + 32 * v16);
      v19 = (__int128 *)(v17 + 64);
      do
      {
        v20 = *(uint64_t **)a5;
        v21 = *(unsigned int *)(a5 + 8);
        if ((_DWORD)v21)
        {
          v22 = 8 * v21;
          v23 = *(uint64_t **)a5;
          while ((__int128 *)*v23 != v19)
          {
            ++v23;
            v22 -= 8;
            if (!v22)
            {
              v23 = &v20[v21];
              break;
            }
          }
        }
        else
        {
          v23 = *(uint64_t **)a5;
        }
        if (v21 == v23 - v20)
        {
          v24 = v19[1];
          v26 = *v19;
          v27 = v24;
        }
        else
        {
          LODWORD(v26) = 5;
          *((_QWORD *)&v26 + 1) = 0;
          LODWORD(v27) = a4;
        }
        llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
        v19 += 2;
      }
      while (v19 != v18);
    }
  }
  return v13;
}

uint64_t llvm::MachineInstr::getFoldedRestoreSize(llvm::MachineInstr *this, const llvm::TargetInstrInfo *a2)
{
  int v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  void *v8[2];
  _QWORD v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  v8[0] = v9;
  v8[1] = (void *)0x200000000;
  if ((*(unsigned int (**)(const llvm::TargetInstrInfo *, llvm::MachineInstr *, void **))(*(_QWORD *)a2 + 88))(a2, this, v8))
  {
    v3 = sub_1C516ABE4((uint64_t)v8, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 3) + 32) + 56));
    v4 = v3 & 0xFFFFFF00;
    v5 = v3;
    v6 = 0x100000000;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v4 = 0;
  }
  if (v8[0] != v9)
    free(v8[0]);
  return v6 | v4 | v5;
}

uint64_t llvm::MachineInstr::getDebugInstrNum(llvm::MachineInstr *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((unsigned int *)this + 16);
  if (!(_DWORD)v1)
  {
    v2 = *(_QWORD *)(*((_QWORD *)this + 3) + 32);
    v1 = (*(_DWORD *)(v2 + 912) + 1);
    *(_DWORD *)(v2 + 912) = v1;
    *((_DWORD *)this + 16) = v1;
  }
  return v1;
}

BOOL sub_1C61F0E70(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v7;
  int Align;
  int AddrSpace;

  if ((*(_QWORD *)a1 & 4) != 0)
    v2 = 0;
  else
    v2 = *(_QWORD *)a1 & 0xFFFFFFFFFFFFFFF8;
  if ((*(_QWORD *)a2 & 4) != 0)
    v3 = 0;
  else
    v3 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFF8;
  if (v2 != v3)
    return 0;
  if ((*(_QWORD *)a1 & 0xFFFFFFFFFFFFFFF8 & ((uint64_t)(*(_QWORD *)a1 << 61) >> 63)) != (*(_QWORD *)a2 & 0xFFFFFFFFFFFFFFF8 & ((uint64_t)(*(_QWORD *)a2 << 61) >> 63)))
    return 0;
  v7 = sub_1C4831E04(a1);
  if (v7 != sub_1C4831E04(a2))
    return 0;
  if (*(_QWORD *)(a1 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  if (*(unsigned __int16 *)(a1 + 32) != *(unsigned __int16 *)(a2 + 32))
    return 0;
  if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64(*(int64x2_t *)(a1 + 40), *(int64x2_t *)(a2 + 40)), (int32x4_t)vceqq_s64(*(int64x2_t *)(a1 + 56), *(int64x2_t *)(a2 + 56)))), 0xFuLL))) & 1) == 0)return 0;
  if (*(_QWORD *)(a1 + 72) != *(_QWORD *)(a2 + 72))
    return 0;
  Align = llvm::MachineMemOperand::getAlign((llvm::MachineMemOperand *)a1);
  if (Align != llvm::MachineMemOperand::getAlign((llvm::MachineMemOperand *)a2))
    return 0;
  AddrSpace = llvm::MachinePointerInfo::getAddrSpace((llvm::MachinePointerInfo *)a1);
  return AddrSpace == llvm::MachinePointerInfo::getAddrSpace((llvm::MachinePointerInfo *)a2);
}

uint64_t sub_1C61F0F94(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void (**v6)(void);
  uint64_t result;
  uint64_t (**v8)(void);
  uint64_t v9[2];
  uint64_t (**v10)();
  int v11;
  uint64_t (***v12)();
  uint64_t (**v13)();
  int v14;
  uint64_t (***v15)();
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = &off_1E8144FC0;
  v14 = a3;
  v15 = &v13;
  v3 = *(_QWORD *)(a2 + 32);
  if (**(_WORD **)(a2 + 16) == 14)
  {
    v4 = v3 + 64;
    v5 = *(unsigned int *)(a2 + 40);
  }
  else
  {
    v5 = 1;
    v4 = *(_QWORD *)(a2 + 32);
  }
  v9[0] = v4;
  v9[1] = v3 + 32 * v5;
  v12 = &v10;
  v10 = &off_1E8144FC0;
  v11 = a3;
  sub_1C61F10A8(a1, v9, &v10);
  if (v12 == &v10)
  {
    v6 = (void (**)(void))(v10 + 4);
  }
  else
  {
    if (!v12)
      goto LABEL_8;
    v6 = (void (**)(void))(*v12 + 5);
  }
  (*v6)();
LABEL_8:
  result = (uint64_t)v15;
  if (v15 == &v13)
  {
    v8 = v13 + 4;
  }
  else
  {
    if (!v15)
      return result;
    v8 = *v15 + 5;
  }
  return (*v8)();
}

uint64_t sub_1C61F10A8(_QWORD *a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  void (**v13)(void);
  _QWORD *v14;
  uint64_t v15;
  uint64_t result;
  uint64_t (**v17)(void);
  _QWORD v18[3];
  _QWORD *v19;
  uint64_t v20[2];
  _BYTE v21[24];
  _BYTE *v22;
  _QWORD v23[3];
  _QWORD *v24;
  uint64_t v25[2];
  _BYTE v26[24];
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = a2[1];
  v8 = (_QWORD *)a3[3];
  if (v8)
  {
    if (v8 == a3)
    {
      v24 = v23;
      (*(void (**)(_QWORD *, _QWORD *))(*a3 + 24))(a3, v23);
    }
    else
    {
      v24 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v8 + 16))(v8);
    }
  }
  else
  {
    v24 = 0;
  }
  sub_1C61F1568(v25, v6, v7, v23);
  v9 = a2[1];
  v10 = (_QWORD *)a3[3];
  if (v10)
  {
    if (v10 == a3)
    {
      v19 = v18;
      (*(void (**)(_QWORD *, _QWORD *))(*a3 + 24))(a3, v18);
    }
    else
    {
      v19 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
    }
  }
  else
  {
    v19 = 0;
  }
  sub_1C61F1568(v20, v9, v9, v18);
  sub_1C61F133C(a1, v25, v20);
  v11 = v22;
  if (v22 == v21)
  {
    v12 = 4;
    v11 = v21;
  }
  else
  {
    if (!v22)
      goto LABEL_9;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_9:
  if (v19 == v18)
  {
    v13 = (void (**)(void))(v18[0] + 32);
  }
  else
  {
    if (!v19)
      goto LABEL_13;
    v13 = (void (**)(void))(*v19 + 40);
  }
  (*v13)();
LABEL_13:
  v14 = v27;
  if (v27 == v26)
  {
    v15 = 4;
    v14 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_17;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_17:
  result = (uint64_t)v24;
  if (v24 == v23)
  {
    v17 = (uint64_t (**)(void))(v23[0] + 32);
  }
  else
  {
    if (!v24)
      return result;
    v17 = (uint64_t (**)(void))(*v24 + 40);
  }
  return (*v17)();
}

void sub_1C61F12B4()
{
  JUMPOUT(0x1CAA32FC0);
}

_DWORD *sub_1C61F12C8(uint64_t a1)
{
  _DWORD *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_1E8144FC0;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1C61F1300(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_1E8144FC0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

BOOL sub_1C61F1320(uint64_t a1, uint64_t a2)
{
  return !*(_BYTE *)a2 && *(_DWORD *)(a2 + 4) == *(_DWORD *)(a1 + 8);
}

_QWORD *sub_1C61F133C(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *result;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[2];
  _BYTE v15[24];
  _BYTE *v16;
  _QWORD v17[2];
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = a2[1];
  v17[0] = *a2;
  v17[1] = v5;
  v6 = v18;
  v7 = (_QWORD *)a2[5];
  if (v7)
  {
    if (v7 == a2 + 2)
    {
      v19 = v18;
      (*(void (**)(_QWORD *, _BYTE *))(*v7 + 24))(v7, v18);
    }
    else
    {
      v19 = (_BYTE *)a2[5];
      a2[5] = 0;
    }
  }
  else
  {
    v19 = 0;
  }
  v8 = a3[1];
  v14[0] = *a3;
  v14[1] = v8;
  v9 = v15;
  v10 = (_QWORD *)a3[5];
  if (v10)
  {
    if (v10 == a3 + 2)
    {
      v16 = v15;
      (*(void (**)(_QWORD *, _BYTE *))(*v10 + 24))(v10, v15);
    }
    else
    {
      v16 = (_BYTE *)a3[5];
      a3[5] = 0;
    }
  }
  else
  {
    v16 = 0;
  }
  result = sub_1C61F14A0(a1, v17, v14);
  if (v16 == v15)
  {
    v12 = 4;
  }
  else
  {
    if (!v16)
      goto LABEL_9;
    v12 = 5;
    v9 = v16;
  }
  result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v9 + 8 * v12))(v9);
LABEL_9:
  if (v19 == v18)
  {
    v13 = 4;
  }
  else
  {
    if (!v19)
      return result;
    v13 = 5;
    v6 = v19;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v6 + 8 * v13))(v6);
}

_QWORD *sub_1C61F14A0(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v5;
  _QWORD *v6;

  *a1 = *a2;
  a1[1] = a2[1];
  v5 = (_QWORD *)a2[5];
  if (v5)
  {
    if (v5 == a2 + 2)
    {
      a1[5] = a1 + 2;
      (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[5] + 24))(a2[5], a1 + 2);
    }
    else
    {
      a1[5] = v5;
      a2[5] = 0;
    }
  }
  else
  {
    a1[5] = 0;
  }
  a1[6] = *a3;
  a1[7] = a3[1];
  v6 = (_QWORD *)a3[5];
  if (v6)
  {
    if (v6 == a3 + 2)
    {
      a1[11] = a1 + 8;
      (*(void (**)(_QWORD))(*(_QWORD *)a3[5] + 24))(a3[5]);
    }
    else
    {
      a1[11] = v6;
      a3[5] = 0;
    }
  }
  else
  {
    a1[11] = 0;
  }
  return a1;
}

uint64_t *sub_1C61F1568(uint64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v7;
  void (**v8)(void);
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)a4[3];
  if (v7)
  {
    if (v7 == a4)
    {
      v11 = v10;
      (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v10);
    }
    else
    {
      v11 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v7 + 16))(v7);
    }
  }
  else
  {
    v11 = 0;
  }
  sub_1C61F165C(a1, a2, a3, (uint64_t)v10);
  if (v11 == v10)
  {
    v8 = (void (**)(void))(v10[0] + 32);
    goto LABEL_6;
  }
  if (v11)
  {
    v8 = (void (**)(void))(*v11 + 40);
LABEL_6:
    (*v8)();
  }
  return a1;
}

uint64_t sub_1C61F165C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = a2;
  a1[1] = a3;
  v5 = *(_QWORD *)(a4 + 24);
  if (v5)
  {
    if (v5 == a4)
    {
      a1[5] = (uint64_t)(a1 + 2);
      (*(void (**)(_QWORD))(**(_QWORD **)(a4 + 24) + 24))(*(_QWORD *)(a4 + 24));
    }
    else
    {
      a1[5] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
    }
  }
  else
  {
    a1[5] = 0;
  }
  if (*a1 == a1[1])
    return (uint64_t)a1;
  while (1)
  {
    v6 = a1[5];
    if (!v6)
      break;
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 48))(v6) & 1) == 0)
    {
      v7 = a1[1];
      v8 = *a1 + 32;
      *a1 = v8;
      if (v8 != v7)
        continue;
    }
    return (uint64_t)a1;
  }
  sub_1C485C2F0();
  return sub_1C61F1700();
}

uint64_t sub_1C61F1700@<X0>(uint64_t a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void (**v6)(void);
  uint64_t result;
  uint64_t (**v8)(void);
  uint64_t v9[2];
  uint64_t (**v10)();
  int v11;
  uint64_t (***v12)();
  uint64_t (**v13)();
  int v14;
  uint64_t (***v15)();
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = &off_1E8145008;
  v14 = a2;
  v15 = &v13;
  v3 = *(_QWORD *)(a1 + 32);
  if (**(_WORD **)(a1 + 16) == 14)
  {
    v4 = v3 + 64;
    v5 = *(unsigned int *)(a1 + 40);
  }
  else
  {
    v5 = 1;
    v4 = *(_QWORD *)(a1 + 32);
  }
  v9[0] = v4;
  v9[1] = v3 + 32 * v5;
  v12 = &v10;
  v10 = &off_1E8145008;
  v11 = a2;
  sub_1C61F1814(v9, &v10, a3);
  if (v12 == &v10)
  {
    v6 = (void (**)(void))(v10 + 4);
  }
  else
  {
    if (!v12)
      goto LABEL_8;
    v6 = (void (**)(void))(*v12 + 5);
  }
  (*v6)();
LABEL_8:
  result = (uint64_t)v15;
  if (v15 == &v13)
  {
    v8 = v13 + 4;
  }
  else
  {
    if (!v15)
      return result;
    v8 = *v15 + 5;
  }
  return (*v8)();
}

uint64_t sub_1C61F1814@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  void (**v13)(void);
  _QWORD *v14;
  uint64_t v15;
  uint64_t result;
  uint64_t (**v17)(void);
  _QWORD v18[3];
  _QWORD *v19;
  uint64_t v20[2];
  _BYTE v21[24];
  _BYTE *v22;
  _QWORD v23[3];
  _QWORD *v24;
  uint64_t v25[2];
  _BYTE v26[24];
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v7 = a1[1];
  v8 = (_QWORD *)a2[3];
  if (v8)
  {
    if (v8 == a2)
    {
      v24 = v23;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v23);
    }
    else
    {
      v24 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v8 + 16))(v8);
    }
  }
  else
  {
    v24 = 0;
  }
  sub_1C61F1568(v25, v6, v7, v23);
  v9 = a1[1];
  v10 = (_QWORD *)a2[3];
  if (v10)
  {
    if (v10 == a2)
    {
      v19 = v18;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v18);
    }
    else
    {
      v19 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
    }
  }
  else
  {
    v19 = 0;
  }
  sub_1C61F1568(v20, v9, v9, v18);
  sub_1C61F1AA8(v25, v20, a3);
  v11 = v22;
  if (v22 == v21)
  {
    v12 = 4;
    v11 = v21;
  }
  else
  {
    if (!v22)
      goto LABEL_9;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_9:
  if (v19 == v18)
  {
    v13 = (void (**)(void))(v18[0] + 32);
  }
  else
  {
    if (!v19)
      goto LABEL_13;
    v13 = (void (**)(void))(*v19 + 40);
  }
  (*v13)();
LABEL_13:
  v14 = v27;
  if (v27 == v26)
  {
    v15 = 4;
    v14 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_17;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_17:
  result = (uint64_t)v24;
  if (v24 == v23)
  {
    v17 = (uint64_t (**)(void))(v23[0] + 32);
  }
  else
  {
    if (!v24)
      return result;
    v17 = (uint64_t (**)(void))(*v24 + 40);
  }
  return (*v17)();
}

void sub_1C61F1A20()
{
  JUMPOUT(0x1CAA32FC0);
}

_DWORD *sub_1C61F1A34(uint64_t a1)
{
  _DWORD *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = &off_1E8145008;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1C61F1A6C(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = &off_1E8145008;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

BOOL sub_1C61F1A8C(uint64_t a1, uint64_t a2)
{
  return !*(_BYTE *)a2 && *(_DWORD *)(a2 + 4) == *(_DWORD *)(a1 + 8);
}

_QWORD *sub_1C61F1AA8@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *result;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[2];
  _BYTE v15[24];
  _BYTE *v16;
  _QWORD v17[2];
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = a1[1];
  v17[0] = *a1;
  v17[1] = v5;
  v6 = v18;
  v7 = (_QWORD *)a1[5];
  if (v7)
  {
    if (v7 == a1 + 2)
    {
      v19 = v18;
      (*(void (**)(_QWORD *, _BYTE *))(*v7 + 24))(v7, v18);
    }
    else
    {
      v19 = (_BYTE *)a1[5];
      a1[5] = 0;
    }
  }
  else
  {
    v19 = 0;
  }
  v8 = a2[1];
  v14[0] = *a2;
  v14[1] = v8;
  v9 = v15;
  v10 = (_QWORD *)a2[5];
  if (v10)
  {
    if (v10 == a2 + 2)
    {
      v16 = v15;
      (*(void (**)(_QWORD *, _BYTE *))(*v10 + 24))(v10, v15);
    }
    else
    {
      v16 = (_BYTE *)a2[5];
      a2[5] = 0;
    }
  }
  else
  {
    v16 = 0;
  }
  result = sub_1C61F14A0(a3, v17, v14);
  if (v16 == v15)
  {
    v12 = 4;
  }
  else
  {
    if (!v16)
      goto LABEL_9;
    v12 = 5;
    v9 = v16;
  }
  result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v9 + 8 * v12))(v9);
LABEL_9:
  if (v19 == v18)
  {
    v13 = 4;
  }
  else
  {
    if (!v19)
      return result;
    v13 = 5;
    v6 = v19;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v6 + 8 * v13))(v6);
}

void llvm::initializeMachineLICMPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FAAE0);
  if (v2 != -1)
  {
    v5[0] = sub_1C516AE24;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FAAE0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializeEarlyMachineLICMPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FAAE8);
  if (v2 != -1)
  {
    v5[0] = sub_1C516AED0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FAAE8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

_QWORD *sub_1C61F1CDC(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  *a1 = off_1E8145160;
  v2 = a1 + 71;
  v3 = (_QWORD *)a1[74];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
LABEL_3:
    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_4;
  }
  if (v3)
  {
    v4 = 5;
    goto LABEL_3;
  }
LABEL_4:
  a1[19] = &off_1E81451C8;
  v5 = (_QWORD *)a1[21];
  if (v5 != a1 + 23)
    free(v5);
  return sub_1C47A80D0(a1);
}

_QWORD *sub_1C61F1D5C(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E81451C8;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

uint64_t sub_1C61F1D9C(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int v12;

  v12 = 0;
  v8 = sub_1C6159B48(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v12);
  if ((v8 & 1) != 0)
    return v8;
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C61F1E14(v11);
}

uint64_t sub_1C61F1E14(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 160) + 24))
    return 2;
  else
    return 3;
}

void sub_1C61F1E2C(_QWORD *a1)
{
  sub_1C61F1CDC(a1);
  JUMPOUT(0x1CAA32FC0);
}

unint64_t sub_1C61F1E50(uint64_t a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth(a1 + 152, a1);
}

uint64_t sub_1C61F1E5C(uint64_t a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::generic_parser_base *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C61F1E6C(llvm::raw_ostream *result, int a2, int a3)
{
  int v3;
  uint64_t (**v4)();
  int v5;
  char v6;

  if (a3)
  {
    v3 = *((_DWORD *)result + 32);
LABEL_3:
    v4 = &off_1E8145218;
    v6 = 1;
    v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((_BYTE *)result + 148))
  {
    v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3)
      goto LABEL_3;
  }
  return result;
}

_QWORD *sub_1C61F1ED8(uint64_t a1, uint64_t a2)
{
  return sub_1C4B03438((_QWORD *)(a1 + 152), a2);
}

void sub_1C61F1EE0(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E81451C8;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61F1F30(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1C61F1F38(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1C61F1F4C(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1C61F1F60(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1C61F1F74(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 12) && *(_BYTE *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void sub_1C61F1FA0(unsigned int *a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  v2 = a1[2];
  if (v2 || a1[3])
  {
    v3 = a1[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C516DC3C(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_13:
      *((_QWORD *)a1 + 1) = 0;
      return;
    }
    v4 = *(_QWORD *)a1;
    v5 = 32 * v3;
    while (1)
    {
      if (*(_DWORD *)v4 == -2)
        goto LABEL_11;
      if (*(_DWORD *)v4 != -1)
        break;
LABEL_12:
      v4 += 32;
      v5 -= 32;
      if (!v5)
        goto LABEL_13;
    }
    v6 = *(void **)(v4 + 8);
    if (v6)
    {
      *(_QWORD *)(v4 + 16) = v6;
      operator delete(v6);
    }
LABEL_11:
    *(_DWORD *)v4 = -1;
    goto LABEL_12;
  }
}

_QWORD *sub_1C61F2048(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  _QWORD *result;

  v3 = sub_1C516E440(a1, a2);
  result = (_QWORD *)(*(_QWORD *)a1 + 48 * *(unsigned int *)(a1 + 8));
  *result = result + 2;
  result[1] = 0x800000000;
  if (*(_DWORD *)(v3 + 8))
    result = (_QWORD *)sub_1C4EA3168((uint64_t)result, v3);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

_DWORD *sub_1C61F20A8(uint64_t a1, _DWORD *a2)
{
  int v3;
  int v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  _DWORD *v9;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    v9 = 0;
LABEL_5:
    v6 = sub_1C61F2160(a1, a2, v9);
    *(_QWORD *)v6 = *a2;
    return v6;
  }
  v4 = v3 - 1;
  v5 = (37 * *a2) & (v3 - 1);
  v6 = (_DWORD *)(*(_QWORD *)a1 + 8 * v5);
  v7 = *v6;
  if (*a2 != *v6)
  {
    v10 = 0;
    v11 = 1;
    while (v7 != -1)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v7 == -2;
      if (v12)
        v10 = v6;
      v13 = v5 + v11++;
      v5 = v13 & v4;
      v6 = (_DWORD *)(*(_QWORD *)a1 + 8 * (v13 & v4));
      v7 = *v6;
      if (*a2 == *v6)
        return v6;
    }
    if (v10)
      v9 = v10;
    else
      v9 = v6;
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1C61F2160(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  _DWORD *v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  BOOL v21;
  unsigned int v22;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
      goto LABEL_3;
    sub_1C50C4EB4(a1, v6);
    v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      v17 = v16 - 1;
      v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v18);
      v19 = *a3;
      if (*a2 == *a3)
        goto LABEL_3;
      v12 = 0;
      v20 = 1;
      while (v19 != -1)
      {
        if (v12)
          v21 = 0;
        else
          v21 = v19 == -2;
        if (v21)
          v12 = a3;
        v22 = v18 + v20++;
        v18 = v22 & v17;
        a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v18);
        v19 = *a3;
        if (*a2 == *a3)
          goto LABEL_3;
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1C50C4EB4(a1, 2 * v6);
  v8 = *(_DWORD *)(a1 + 16);
  if (!v8)
    goto LABEL_24;
  v9 = v8 - 1;
  v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v10);
  v11 = *a3;
  if (*a2 == *a3)
    goto LABEL_3;
  v12 = 0;
  v13 = 1;
  while (v11 != -1)
  {
    if (v12)
      v14 = 0;
    else
      v14 = v11 == -2;
    if (v14)
      v12 = a3;
    v15 = v10 + v13++;
    v10 = v15 & v9;
    a3 = (_DWORD *)(*(_QWORD *)a1 + 8 * v10);
    v11 = *a3;
    if (*a2 == *a3)
      goto LABEL_3;
  }
LABEL_21:
  if (v12)
    a3 = v12;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C61F22E4(__int128 *a1, int **a2, _WORD *a3, uint64_t a4)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FADF0, 0, 0);
  dword_1ED7FAE70 = 0;
  qword_1ED7FAE78 = (uint64_t)&off_1E8145218;
  *(_QWORD *)&dword_1ED7FAE80 = 0;
  qword_1ED7FADF0 = (uint64_t)off_1E8145160;
  qword_1ED7FAE88 = (uint64_t)&off_1E81451C8;
  qword_1ED7FAE90 = (uint64_t)&qword_1ED7FADF0;
  qword_1ED7FAE98 = (uint64_t)&unk_1ED7FAEA8;
  qword_1ED7FAEA0 = 0x800000000;
  qword_1ED7FB028 = (uint64_t)&off_1E8145498;
  qword_1ED7FB040 = (uint64_t)&qword_1ED7FB028;
  sub_1C61F239C(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FADF0);
}

void sub_1C61F239C(__int128 *a1, int **a2, _WORD *a3, uint64_t a4)
{
  int *v8;

  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7FADF0, "disable-hoisting-to-hotter-blocks", 0x21uLL);
  xmmword_1ED7FAE10 = *a1;
  v8 = *a2;
  dword_1ED7FAE70 = **a2;
  byte_1ED7FAE84 = 1;
  dword_1ED7FAE80 = *v8;
  word_1ED7FADFA = (32 * (*a3 & 3)) | word_1ED7FADFA & 0xFF9F;
  sub_1C516F260(*(_QWORD *)a4, *(_DWORD *)(a4 + 8));
}

void sub_1C61F2438()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61F244C()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E8145498;
  return result;
}

void sub_1C61F2470(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E8145498;
}

void sub_1C61F248C(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  char v10;
  _QWORD v11[5];
  int v12;
  char v13;

  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  v11[3] = a5;
  v11[4] = &off_1E8145218;
  v13 = 1;
  v12 = a3;
  v7 = sub_1C516F2A4((unint64_t)v11);
  v8 = qword_1ED7FAE98 + 48 * qword_1ED7FAEA0;
  v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(_QWORD *)(v8 + 32) = &off_1E8145238;
  v10 = *(_BYTE *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(_BYTE *)(v8 + 44) = v10;
  *(_QWORD *)(v8 + 32) = &off_1E8145218;
  LODWORD(qword_1ED7FAEA0) = qword_1ED7FAEA0 + 1;
  llvm::cl::AddLiteralOption(qword_1ED7FAE90, a1, a2);
}

void sub_1C61F2540(unint64_t a1)
{
  _OWORD *v1;
  _OWORD *v2;
  uint64_t v3;
  _OWORD *v4;
  __int128 v5;
  int v6;
  int v7;
  unint64_t v8;

  v8 = 0;
  v1 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)&qword_1ED7FAE98, a1, 48, &v8);
  v2 = (_OWORD *)qword_1ED7FAE98;
  if ((_DWORD)qword_1ED7FAEA0)
  {
    v3 = qword_1ED7FAE98 + 48 * qword_1ED7FAEA0;
    v4 = v1;
    do
    {
      v5 = v2[1];
      *v4 = *v2;
      v4[1] = v5;
      *((_QWORD *)v4 + 4) = &off_1E8145238;
      v6 = *((_DWORD *)v2 + 10);
      *((_BYTE *)v4 + 44) = *((_BYTE *)v2 + 44);
      *((_DWORD *)v4 + 10) = v6;
      *((_QWORD *)v4 + 4) = &off_1E8145218;
      v2 += 3;
      v4 += 3;
    }
    while (v2 != (_OWORD *)v3);
    v2 = (_OWORD *)qword_1ED7FAE98;
  }
  v7 = v8;
  if (v2 != (_OWORD *)&unk_1ED7FAEA8)
    free(v2);
  qword_1ED7FAE98 = (uint64_t)v1;
  HIDWORD(qword_1ED7FAEA0) = v7;
}

_QWORD *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitingBlocks(_QWORD *result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v2 = (uint64_t *)result[4];
  v3 = (uint64_t *)result[5];
  if (v3 != v2)
  {
    v5 = result;
    v6 = (uint64_t)(result + 7);
    do
    {
      v7 = *v2;
      v8 = *(uint64_t **)(*v2 + 88);
      v9 = *(uint64_t **)(*v2 + 96);
      while (v8 != v9)
      {
        result = sub_1C477672C(v6, *v8);
        v10 = v5[8];
        if (v10 == v5[7])
          v11 = 76;
        else
          v11 = 72;
        if (result == (_QWORD *)(v10 + 8 * *(unsigned int *)((char *)v5 + v11)))
        {
          v12 = *(unsigned int *)(a2 + 8);
          if (v12 >= *(unsigned int *)(a2 + 12))
          {
            result = llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v12 + 1, 8);
            v12 = *(unsigned int *)(a2 + 8);
          }
          *(_QWORD *)(*(_QWORD *)a2 + 8 * v12) = v7;
          ++*(_DWORD *)(a2 + 8);
          break;
        }
        ++v8;
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

{
  return __ZNK4llvm8LoopBaseINS_17MachineBasicBlockENS_11MachineLoopEE16getExitingBlocksERNS_15SmallVectorImplIPS1_EE(result, a2);
}

_QWORD *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBasicBlockToLoop(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v5;

  v5 = a2;
  result = sub_1C5173680(a3, &v5);
  for (result[1] = a1; a1; a1 = (_QWORD *)*a1)
    result = llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBlockEntry((uint64_t)a1, v5);
  return result;
}

{
  return __ZN4llvm8LoopBaseINS_17MachineBasicBlockENS_11MachineLoopEE19addBasicBlockToLoopEPS1_RNS_12LoopInfoBaseIS1_S2_EE(a1, a2, a3);
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print(_QWORD *a1, llvm::raw_ostream *a2, int a3, char a4, int a5)
{
  llvm::raw_ostream *v8;
  unint64_t v9;
  _QWORD *v10;
  llvm::raw_ostream *v11;
  llvm::MachineBasicBlock **v12;
  uint64_t v13;
  unsigned int v14;
  llvm::MachineBasicBlock *v15;
  uint64_t v16;
  llvm::MachineBasicBlock **v17;
  llvm::MachineBasicBlock **v18;
  uint64_t *v19;
  uint64_t *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  llvm::MachineBasicBlock *v29;

  llvm::raw_ostream::indent(a2, 2 * a5);
  v8 = sub_1C4816AD8(a2, "Loop at depth ");
  LODWORD(v9) = 0;
  v10 = a1;
  do
  {
    v10 = (_QWORD *)*v10;
    v9 = (v9 + 1);
  }
  while (v10);
  v11 = llvm::raw_ostream::operator<<(v8, v9);
  sub_1C4816AD8(v11, " containing: ");
  v12 = (llvm::MachineBasicBlock **)a1[4];
  if ((llvm::MachineBasicBlock **)a1[5] != v12)
  {
    v13 = 0;
    v14 = 0;
    v29 = *v12;
    do
    {
      v15 = v12[v13];
      if ((a3 & 1) != 0)
      {
        sub_1C4816AD8(a2, "\n");
      }
      else
      {
        if (v14)
          sub_1C4816AD8(a2, ",");
        llvm::MachineBasicBlock::printAsOperand(v15, a2);
      }
      if (v15 == v29)
        sub_1C4816AD8(a2, "<header>");
      v16 = *(_QWORD *)a1[4];
      v17 = *(llvm::MachineBasicBlock ***)(v16 + 64);
      v18 = *(llvm::MachineBasicBlock ***)(v16 + 72);
      if (v17 != v18)
      {
        while (*v17 != v15)
        {
          if (++v17 == v18)
          {
            v17 = v18;
            break;
          }
        }
      }
      if (v17 != v18)
        sub_1C4816AD8(a2, "<latch>");
      v20 = (uint64_t *)*((_QWORD *)v15 + 11);
      v19 = (uint64_t *)*((_QWORD *)v15 + 12);
      while (v20 != v19)
      {
        v21 = sub_1C477672C((uint64_t)(a1 + 7), *v20);
        v22 = a1[8];
        if (v22 == a1[7])
          v23 = 76;
        else
          v23 = 72;
        if (v21 == (_QWORD *)(v22 + 8 * *(unsigned int *)((char *)a1 + v23)))
        {
          sub_1C4816AD8(a2, "<exiting>");
          break;
        }
        ++v20;
      }
      if (a3)
        llvm::MachineBasicBlock::print(v15, a2, 0, 1);
      v12 = (llvm::MachineBasicBlock **)a1[4];
      v13 = ++v14;
    }
    while (v14 < (unint64_t)((uint64_t)(a1[5] - (_QWORD)v12) >> 3));
  }
  if ((a4 & 1) != 0)
  {
    sub_1C4816AD8(a2, "\n");
    v25 = (uint64_t *)a1[1];
    v24 = (uint64_t *)a1[2];
    while (v25 != v24)
    {
      v26 = *v25++;
      llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print(v26, a2, 0, 1, (a5 + 2));
    }
  }
}

{
  __ZNK4llvm8LoopBaseINS_17MachineBasicBlockENS_11MachineLoopEE5printERNS_11raw_ostreamEbbj(a1, a2, a3, a4, a5);
}

llvm::MachineLoopInfo *llvm::MachineLoopInfo::MachineLoopInfo(llvm::MachineLoopInfo *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848((uint64_t)this, (uint64_t)&llvm::MachineLoopInfo::ID);
  *(_QWORD *)v2 = &off_1E81454E0;
  *(_QWORD *)(v2 + 248) = 0;
  *(_QWORD *)(v2 + 256) = 0;
  *(_DWORD *)(v2 + 264) = 0;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 288) = 0u;
  *(_QWORD *)(v2 + 304) = 0;
  *(_QWORD *)(v2 + 312) = v2 + 328;
  *(_QWORD *)(v2 + 320) = 0x400000000;
  *(_QWORD *)(v2 + 360) = v2 + 376;
  *(_QWORD *)(v2 + 368) = 0;
  *(_QWORD *)(v2 + 376) = 0;
  *(_QWORD *)(v2 + 384) = 1;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED82F698);
  if (v3 != -1)
  {
    v7[0] = sub_1C5172DEC;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F698, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void *llvm::MachineLoopInfo::getAnalysisUsage(llvm::MachineLoopInfo *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t *llvm::MachineLoop::getTopBlock(llvm::MachineLoop *this)
{
  uint64_t *v1;
  uint64_t *v2;
  char *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = (uint64_t *)**((_QWORD **)this + 4);
  v2 = *(uint64_t **)(v1[4] + 328);
  if (v1 != v2)
  {
    v4 = (char *)this + 56;
    while (1)
    {
      v5 = *v1;
      v6 = sub_1C477672C((uint64_t)v4, *v1);
      v7 = *((_QWORD *)this + 8);
      v8 = v7 == *((_QWORD *)this + 7) ? 76 : 72;
      if (v6 == (_QWORD *)(v7 + 8 * *(unsigned int *)((char *)this + v8)))
        break;
      v1 = (uint64_t *)v5;
      if ((uint64_t *)v5 == v2)
        return v2;
    }
  }
  return v1;
}

void llvm::MachineLoop::dump(llvm::MachineLoop *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print(this, v2, 0, 1, 0);
}

void sub_1C61F2B34(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E81454E0;
  llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopInfoBase((_QWORD *)a1 + 31);
  sub_1C4926674(a1);
}

void sub_1C61F2B64(llvm::Pass *a1)
{
  *(_QWORD *)a1 = &off_1E81454E0;
  llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopInfoBase((_QWORD *)a1 + 31);
  sub_1C4926674(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::MachineLoopInfo *llvm::callDefaultCtor<llvm::MachineLoopInfo>()
{
  llvm::MachineLoopInfo *v0;

  v0 = (llvm::MachineLoopInfo *)operator new();
  return llvm::MachineLoopInfo::MachineLoopInfo(v0);
}

llvm::MachineModuleInfo *llvm::MachineModuleInfo::MachineModuleInfo(llvm::MachineModuleInfo *this, const llvm::LLVMTargetMachine *a2)
{
  *(_QWORD *)this = a2;
  llvm::MCContext::MCContext((uint64_t)this + 8, (__int128 *)a2 + 28, *((_QWORD *)a2 + 70), *((_QWORD *)a2 + 71), *((_QWORD *)a2 + 73), 0, (uint64_t)a2 + 1128, 0, 0, 0);
  *((_QWORD *)this + 257) = 0;
  *((_DWORD *)this + 534) = 0;
  *((_QWORD *)this + 274) = 0;
  *((_QWORD *)this + 260) = 0;
  *(_OWORD *)((char *)this + 2088) = 0u;
  *((_OWORD *)this + 132) = 0u;
  *((_DWORD *)this + 532) = 0;
  *((_QWORD *)this + 268) = 0;
  *((_QWORD *)this + 270) = 0;
  *((_QWORD *)this + 269) = 0;
  *((_QWORD *)this + 22) = (*(uint64_t (**)(const llvm::LLVMTargetMachine *))(*(_QWORD *)a2 + 24))(a2);
  *((_QWORD *)this + 259) = 0;
  *((_DWORD *)this + 526) = 0;
  *((_DWORD *)this + 534) = 0;
  *((_WORD *)this + 1054) = 0;
  return this;
}

void llvm::MachineModuleInfo::~MachineModuleInfo(llvm::MachineModuleInfo *this)
{
  llvm::MCContext *v2;
  uint64_t v3;
  llvm::MachineModuleInfo *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *((_QWORD *)this + 261) = *((_QWORD *)this + 260);
  v2 = (llvm::MachineModuleInfo *)((char *)this + 8);
  llvm::MCContext::reset((llvm::MachineModuleInfo *)((char *)this + 8));
  v3 = *((_QWORD *)this + 259);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_QWORD *)this + 259) = 0;
  v4 = (llvm::MachineModuleInfo *)*((_QWORD *)this + 274);
  if (v4 == (llvm::MachineModuleInfo *)((char *)this + 2168))
  {
    v5 = 4;
    v4 = (llvm::MachineModuleInfo *)((char *)this + 2168);
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v4 + 8 * v5))();
    goto LABEL_6;
  }
  if (v4)
  {
    v5 = 5;
    goto LABEL_5;
  }
LABEL_6:
  v6 = *((_QWORD *)this + 270);
  *((_QWORD *)this + 270) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  sub_1C5174EBC((unsigned int *)this + 528);
  MEMORY[0x1CAA32FB4](*((_QWORD *)this + 264), 8);
  v7 = (void *)*((_QWORD *)this + 260);
  if (v7)
  {
    *((_QWORD *)this + 261) = v7;
    operator delete(v7);
  }
  llvm::MCContext::~MCContext(v2);
}

uint64_t llvm::createFreeMachineFunctionPass(llvm *this)
{
  uint64_t result;

  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = &unk_1EF8F2EF8;
  *(_DWORD *)(result + 24) = 2;
  *(_QWORD *)result = &off_1E8145670;
  return result;
}

llvm::MachineModuleInfoWrapperPass *llvm::MachineModuleInfoWrapperPass::MachineModuleInfoWrapperPass(llvm::MachineModuleInfoWrapperPass *this, const llvm::LLVMTargetMachine *a2)
{
  _QWORD *v3;
  void (**v4)(_QWORD *);
  unint64_t v6;
  unint64_t v8;
  _QWORD *v9;
  _QWORD v10[2];
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = &llvm::MachineModuleInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(_QWORD *)this = &off_1E81455A8;
  llvm::MachineModuleInfo::MachineModuleInfo((llvm::MachineModuleInfoWrapperPass *)((char *)this + 32), a2);
  if (sub_1C51748FC(*((_QWORD *)this + 4)))
  {
    v11[0] = &off_1E8145710;
    v11[1] = this;
    v12 = v11;
    sub_1C61F3014((_QWORD *)this + 275, v11);
    v3 = v12;
    if (v12 == v11)
    {
      v4 = (void (**)(_QWORD *))(v11[0] + 32);
      v3 = v11;
LABEL_4:
      (*v4)(v3);
      goto LABEL_5;
    }
    if (v12)
    {
      v4 = (void (**)(_QWORD *))(*v12 + 40);
      goto LABEL_4;
    }
  }
LABEL_5:
  if (!atomic_load(qword_1ED830BC0))
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1ED830BC0, (void *(*)(void))sub_1C624602C, (void (*)(void *))sub_1C62460B0);
  v8 = qword_1ED830BC0[0];
  v6 = atomic_load(&qword_1ED82F6A0);
  if (v6 != -1)
  {
    v10[0] = sub_1C5174A50;
    v10[1] = &v8;
    v9 = v10;
    std::__call_once(&qword_1ED82F6A0, &v9, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeMachineModuleInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F6A0);
  if (v2 != -1)
  {
    v5[0] = sub_1C5174A50;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F6A0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::MachineModuleInfoWrapperPass::getAnalysisUsage(llvm::MachineModuleInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  if (*((_QWORD *)this + 278) || *((_QWORD *)this + 274))
    sub_1C4771E64((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::FunctionGroupInfoWrapperPass::ID);
  return llvm::Pass::getAnalysisUsage(this, a2);
}

void sub_1C61F2FA0(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E81455A8;
  llvm::MachineModuleInfo::~MachineModuleInfo((llvm::MachineModuleInfo *)(a1 + 32));
  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
}

void sub_1C61F2FD0(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E81455A8;
  llvm::MachineModuleInfo::~MachineModuleInfo((llvm::MachineModuleInfo *)(a1 + 32));
  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61F3014(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void (**v6)(_QWORD *);
  _QWORD v7[3];
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      v8 = v7;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v7);
    }
    else
    {
      v8 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v3 + 16))(v3);
    }
  }
  else
  {
    v8 = 0;
  }
  sub_1C48C35D8(v7, a1);
  v4 = v8;
  if (v8 == v7)
  {
    v6 = (void (**)(_QWORD *))(v7[0] + 32);
    v4 = v7;
LABEL_11:
    (*v6)(v4);
    return a1;
  }
  if (v8)
  {
    v6 = (void (**)(_QWORD *))(*v8 + 40);
    goto LABEL_11;
  }
  return a1;
}

llvm::MachineModuleInfoWrapperPass *llvm::callDefaultCtor<llvm::MachineModuleInfoWrapperPass>()
{
  llvm::MachineModuleInfoWrapperPass *v0;

  v0 = (llvm::MachineModuleInfoWrapperPass *)operator new();
  return llvm::MachineModuleInfoWrapperPass::MachineModuleInfoWrapperPass(v0, 0);
}

void sub_1C61F3134(_QWORD *a1)
{
  sub_1C61F3258(a1);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61F3158(_QWORD *a1)
{
  *a1 = &off_1E8145810;
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C61F3190(_QWORD *a1)
{
  *a1 = &off_1E8145810;
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61F31D8(_QWORD *a1)
{
  *a1 = &off_1E8145838;
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C61F3210(_QWORD *a1)
{
  *a1 = &off_1E8145838;
  MEMORY[0x1CAA32FB4](a1[1], 8);
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61F3258(_QWORD *a1)
{
  *a1 = &off_1E81457E8;
  MEMORY[0x1CAA32FB4](a1[7], 8);
  MEMORY[0x1CAA32FB4](a1[4], 8);
  MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

uint64_t llvm::MachineModuleSlotTracker::processMachineFunctionMetadata(llvm::MachineModuleSlotTracker *this, llvm::AbstractSlotTrackerStorage *a2, const llvm::MachineFunction *a3)
{
  char *v3;
  char *v4;
  char *i;
  unint64_t v7;
  int *v8;
  int *v9;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;

  v3 = (char *)a3 + 320;
  v4 = (char *)*((_QWORD *)a3 + 41);
  if (v4 != (char *)a3 + 320)
  {
    do
    {
      for (i = (char *)*((_QWORD *)v4 + 7); i != v4 + 48; i = (char *)*((_QWORD *)i + 1))
      {
        v8 = (int *)(i + 48);
        v7 = *((_QWORD *)i + 6);
        if (v7 < 8)
          continue;
        if ((v7 & 7) != 0)
        {
          v9 = (int *)(v7 & 0xFFFFFFFFFFFFFFF8);
          if ((*((_QWORD *)i + 6) & 7) != 3 || v9 == 0)
            continue;
          v12 = *v9;
          v8 = v9 + 2;
          v11 = v12;
          if (!(_DWORD)v12)
            continue;
          v13 = &v8[2 * v11];
        }
        else
        {
          *((_QWORD *)i + 6) = v7 & 0xFFFFFFFFFFFFFFF8;
          v13 = (int *)(i + 56);
        }
        do
        {
          v14 = *(_QWORD *)(*(_QWORD *)v8 + 48);
          v16 = *(_QWORD *)(*(_QWORD *)v8 + 56);
          v15 = *(_QWORD *)(*(_QWORD *)v8 + 64);
          if (*(_QWORD *)(*(_QWORD *)v8 + 40))
            result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(_QWORD *)a2 + 24))(a2);
          if (v14)
            result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *, uint64_t))(*(_QWORD *)a2 + 24))(a2, v14);
          if (v16)
            result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *, uint64_t))(*(_QWORD *)a2 + 24))(a2, v16);
          if (v15)
            result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *, uint64_t))(*(_QWORD *)a2 + 24))(a2, v15);
          v8 += 2;
        }
        while (v8 != v13);
      }
      v4 = (char *)*((_QWORD *)v4 + 1);
    }
    while (v4 != v3);
  }
  return result;
}

uint64_t llvm::MachineModuleSlotTracker::processMachineModule(uint64_t this, llvm::AbstractSlotTrackerStorage *a2, const llvm::Module *a3, int a4)
{
  _QWORD *v4;
  uint64_t v6;
  const Function *v7;
  const Function *v8;
  llvm::MachineModuleSlotTracker *MachineFunction;

  if (a4)
  {
    v4 = (_QWORD *)*((_QWORD *)a3 + 4);
    if (v4 != (_QWORD *)((char *)a3 + 24))
    {
      v6 = this;
      v7 = *(const Function **)(this + 112);
      while (1)
      {
        v8 = (const Function *)(v4 - 7);
        if (!v4)
          v8 = 0;
        if (v8 == v7)
          break;
        v4 = (_QWORD *)v4[1];
        if (v4 == (_QWORD *)((char *)a3 + 24))
          return this;
      }
      *(_DWORD *)(this + 128) = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(_QWORD *)a2 + 16))(a2);
      MachineFunction = (llvm::MachineModuleSlotTracker *)llvm::MachineModuleInfo::getMachineFunction(*(llvm::MachineModuleInfo **)(v6 + 120), v7);
      if (MachineFunction)
        llvm::MachineModuleSlotTracker::processMachineFunctionMetadata(MachineFunction, a2, MachineFunction);
      this = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(_QWORD *)a2 + 16))(a2);
      *(_DWORD *)(v6 + 132) = this;
    }
  }
  return this;
}

uint64_t llvm::MachineModuleSlotTracker::processMachineFunction(uint64_t this, llvm::AbstractSlotTrackerStorage *a2, const Function *a3, char a4)
{
  uint64_t v5;
  llvm::MachineModuleSlotTracker *MachineFunction;

  if ((a4 & 1) == 0)
  {
    v5 = this;
    if (*(const Function **)(this + 112) == a3)
    {
      *(_DWORD *)(this + 128) = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(_QWORD *)a2 + 16))(a2);
      MachineFunction = (llvm::MachineModuleSlotTracker *)llvm::MachineModuleInfo::getMachineFunction(*(llvm::MachineModuleInfo **)(v5 + 120), a3);
      if (MachineFunction)
        llvm::MachineModuleSlotTracker::processMachineFunctionMetadata(MachineFunction, a2, MachineFunction);
      this = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(_QWORD *)a2 + 16))(a2);
      *(_DWORD *)(v5 + 132) = this;
    }
  }
  return this;
}

void llvm::MachineModuleSlotTracker::collectMachineMDNodes(uint64_t a1, char **a2)
{
  llvm::ModuleSlotTracker::collectMDNodes(a1, a2, *(_DWORD *)(a1 + 128), *(unsigned int *)(a1 + 132));
}

llvm::MachineModuleSlotTracker *llvm::MachineModuleSlotTracker::MachineModuleSlotTracker(llvm::MachineModuleSlotTracker *this, const llvm::MachineFunction *a2, char a3)
{
  _QWORD *v5;
  void (**v6)(void);
  void (**v7)(void);
  _QWORD v9[3];
  _QWORD *v10;
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD *)llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)this, *(const llvm::Module **)(*(_QWORD *)a2 + 40), a3);
  *v5 = &off_1E8145888;
  v5[14] = *(_QWORD *)a2;
  v5[15] = *((_QWORD *)a2 + 4);
  v5[16] = 0;
  v11[0] = &off_1E81458A8;
  v11[1] = v5;
  v12 = v11;
  llvm::ModuleSlotTracker::setProcessHook((uint64_t)v5, v11);
  if (v12 == v11)
  {
    v6 = (void (**)(void))(v11[0] + 32);
  }
  else
  {
    if (!v12)
      goto LABEL_5;
    v6 = (void (**)(void))(*v12 + 40);
  }
  (*v6)();
LABEL_5:
  v9[0] = &off_1E81458F0;
  v9[1] = this;
  v10 = v9;
  llvm::ModuleSlotTracker::setProcessHook((uint64_t)this, v9);
  if (v10 == v9)
  {
    v7 = (void (**)(void))(v9[0] + 32);
    goto LABEL_8;
  }
  if (v10)
  {
    v7 = (void (**)(void))(*v10 + 40);
LABEL_8:
    (*v7)();
  }
  return this;
}

void llvm::MachineModuleSlotTracker::~MachineModuleSlotTracker(llvm::MachineModuleSlotTracker *this)
{
  llvm::ModuleSlotTracker::~ModuleSlotTracker(this);
  JUMPOUT(0x1CAA32FC0);
}

llvm::MachineOperand *llvm::MachineOperand::ChangeToFrameIndex(llvm::MachineOperand *this, int a2, __int16 a3)
{
  llvm::MachineOperand *result;
  int v7;

  result = llvm::MachineOperand::removeRegFromUses(this);
  v7 = *(_DWORD *)this;
  *((_DWORD *)this + 4) = a2;
  *(_DWORD *)this = v7 & 0xFFF00000 | ((a3 & 0xFFF) << 8) | 5;
  return result;
}

unint64_t sub_1C61F36A0(_BYTE *a1, int *a2, uint64_t *a3)
{
  _OWORD v7[4];
  _OWORD v8[3];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  v10 = sub_1C4D9B584();
  LOBYTE(v7[0]) = *a1;
  return sub_1C61F40A0((char *)v7, (_OWORD *)((char *)v7 + 1), (char *)v8, *a2, a3);
}

unint64_t sub_1C61F3750(_BYTE *a1, int *a2, uint64_t *a3, uint64_t a4)
{
  _OWORD v9[4];
  _OWORD v10[3];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  v12 = sub_1C4D9B584();
  LOBYTE(v9[0]) = *a1;
  return sub_1C61F4120((char *)v9, (_OWORD *)((char *)v9 + 1), (char *)v10, *a2, a3, a4);
}

unint64_t sub_1C61F3808(char *a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  _OWORD v9[4];
  _OWORD v10[3];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  v12 = sub_1C4D9B584();
  return sub_1C61F4214((char *)v9, v9, (char *)v10, *a1, a2, a3, a4);
}

unint64_t sub_1C61F38BC(_BYTE *a1, int *a2, uint64_t *a3)
{
  _OWORD v7[4];
  _OWORD v8[3];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  v10 = sub_1C4D9B584();
  LOBYTE(v7[0]) = *a1;
  return sub_1C50FDABC((char *)v7, 0, (_OWORD *)((char *)v7 + 1), (char *)v8, a2, a3);
}

unint64_t sub_1C61F3970(_BYTE *a1, int *a2, int *a3)
{
  _OWORD v7[4];
  _OWORD v8[3];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  v10 = sub_1C4D9B584();
  LOBYTE(v7[0]) = *a1;
  return sub_1C517CF98((char *)v7, 0, (_OWORD *)((char *)v7 + 1), (char *)v8, a2, a3);
}

unint64_t sub_1C61F3A24(char *a1, int *a2, uint64_t a3)
{
  _OWORD v7[4];
  _OWORD v8[3];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  v10 = sub_1C4D9B584();
  return sub_1C61F4320((char *)v7, v7, (char *)v8, *a1, a2, a3);
}

uint64_t llvm::MachineOperand::getTargetIndexName(llvm::MachineOperand *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v1 = *((_QWORD *)this + 1);
  if (!v1)
    return 0;
  v2 = *(_QWORD *)(v1 + 24);
  if (!v2)
    return 0;
  v3 = *(_QWORD *)(v2 + 32);
  if (!v3)
    return 0;
  v4 = *((_DWORD *)this + 4);
  v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 16) + 104))(*(_QWORD *)(v3 + 16));
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 1096))(v5);
  if (!v7)
    return 0;
  v8 = v6 + 8;
  v9 = 16 * v7;
  while (*(_DWORD *)(v8 - 8) != v4)
  {
    v8 += 16;
    v9 -= 16;
    if (!v9)
      return 0;
  }
  return *(_QWORD *)v8;
}

llvm::raw_ostream *llvm::MachineOperand::printSubRegIdx(llvm::MachineOperand *this, llvm::raw_ostream *a2, uint64_t a3, const llvm::TargetRegisterInfo *a4)
{
  sub_1C4816AD8(this, "%subreg.");
  if (a3)
    return sub_1C4816AD8(this, *(char **)(*(_QWORD *)(a3 + 224) + 8 * ((_DWORD)a2 - 1)));
  else
    return sub_1C5E21910(this, (unint64_t)a2, 0, 0, 0);
}

llvm::raw_ostream *llvm::MachineOperand::printSymbol(llvm::MachineOperand *this, llvm::raw_ostream *a2, llvm::MCSymbol *a3)
{
  llvm::raw_ostream *v4;

  v4 = sub_1C4816AD8(this, "<mcsymbol ");
  llvm::MCSymbol::print(a2, v4, 0);
  return sub_1C4816AD8(v4, ">");
}

llvm::raw_ostream *llvm::MachineOperand::printStackObjectReference(llvm::raw_ostream *a1, unsigned int a2, int a3, const void *a4, size_t a5)
{
  unint64_t v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *result;
  llvm::raw_ostream *v11;
  _BYTE *v12;
  void *v13;

  v6 = a2;
  if (a3)
  {
    v7 = sub_1C4816AD8(a1, "%fixed-stack.");
    return sub_1C5E21910(v7, v6, 0, 0, 0);
  }
  else
  {
    v11 = sub_1C4816AD8(a1, "%stack.");
    result = sub_1C5E21910(v11, v6, 0, 0, 0);
    if (a5)
    {
      v12 = (_BYTE *)*((_QWORD *)a1 + 4);
      if ((unint64_t)v12 >= *((_QWORD *)a1 + 3))
      {
        llvm::raw_ostream::write(a1, 46);
      }
      else
      {
        *((_QWORD *)a1 + 4) = v12 + 1;
        *v12 = 46;
      }
      v13 = (void *)*((_QWORD *)a1 + 4);
      if (a5 <= *((_QWORD *)a1 + 3) - (_QWORD)v13)
      {
        result = (llvm::raw_ostream *)memcpy(v13, a4, a5);
        *((_QWORD *)a1 + 4) += a5;
      }
      else
      {
        return llvm::raw_ostream::write(a1, (const char *)a4, a5);
      }
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MachineOperand::printOperandOffset(llvm::raw_ostream *this, uint64_t a2)
{
  llvm::raw_ostream *v3;
  unint64_t v4;

  if (a2)
  {
    if (a2 < 0)
    {
      v3 = sub_1C4816AD8(this, " - ");
      v4 = -a2;
    }
    else
    {
      v3 = sub_1C4816AD8(this, " + ");
      v4 = a2;
    }
    return llvm::raw_ostream::operator<<(v3, v4);
  }
  return this;
}

llvm::raw_ostream *llvm::MachineOperand::printIRSlotNumber(llvm::MachineOperand *this, llvm::raw_ostream *a2)
{
  if ((_DWORD)a2 == -1)
    return sub_1C4816AD8(this, "<badref>");
  else
    return llvm::raw_ostream::operator<<(this, (int)a2);
}

void llvm::MachineOperand::print(llvm::MachineOperand *this, llvm::raw_ostream *a2, const llvm::TargetRegisterInfo *a3, const llvm::TargetIntrinsicInfo *a4)
{
  llvm::MachineOperand::print(this, a2, 0, (uint64_t)a3, (uint64_t)a4);
}

void llvm::MachineOperand::print(llvm::raw_ostream *a1, llvm::MachineOperand *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const llvm::Function *v12[2];
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = *(_QWORD *)(v9 + 24);
    if (v10)
    {
      v11 = *(_QWORD *)(v10 + 32);
      if (v11)
      {
        a4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 16) + 176))(*(_QWORD *)(v11 + 16));
        a5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 8) + 56))(*(_QWORD *)(v11 + 8));
      }
    }
  }
  v12[0] = (const llvm::Function *)&off_1E814DC18;
  v12[1] = 0;
  v13 = 256;
  v18 = 0;
  v17 = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  llvm::MachineOperand::print(a1, a2, v12, a3, 0, 0, 1, 1, 0, a4, a5);
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v12);
}

void llvm::MachineOperand::dump(llvm::MachineOperand *this)
{
  llvm *v2;
  _BYTE *v3;

  v2 = llvm::dbgs(this);
  llvm::MachineOperand::print(this, v2, 0, 0, 0);
  v3 = (_BYTE *)*((_QWORD *)v2 + 4);
  if ((unint64_t)v3 >= *((_QWORD *)v2 + 3))
  {
    llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((_QWORD *)v2 + 4) = v3 + 1;
    *v3 = 10;
  }
}

uint64_t llvm::MachinePointerInfo::getConstantPool@<X0>(llvm::PseudoSourceValueManager **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  int v5;

  result = llvm::PseudoSourceValueManager::getConstantPool(this[54]);
  *(_QWORD *)a2 = result | 4;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 20) = 0;
  if (result)
    v5 = *(_DWORD *)(result + 12);
  else
    v5 = 0;
  *(_DWORD *)(a2 + 16) = v5;
  return result;
}

uint64_t llvm::MachinePointerInfo::getJumpTable@<X0>(llvm::PseudoSourceValueManager **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  int v5;

  result = llvm::PseudoSourceValueManager::getJumpTable(this[54]);
  *(_QWORD *)a2 = result | 4;
  *(_QWORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 20) = 0;
  if (result)
    v5 = *(_DWORD *)(result + 12);
  else
    v5 = 0;
  *(_DWORD *)(a2 + 16) = v5;
  return result;
}

uint64_t llvm::MachinePointerInfo::getUnknownStack@<X0>(llvm::MachinePointerInfo *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  int v5;

  result = llvm::MachineFunction::getDataLayout(this);
  v5 = *(_DWORD *)(result + 4);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = v5;
  *(_BYTE *)(a2 + 20) = 0;
  return result;
}

__n128 llvm::MachineMemOperand::refineAlignment(llvm::MachineMemOperand *this, const llvm::MachineMemOperand *a2)
{
  unsigned int v2;
  __n128 result;

  v2 = *((unsigned __int8 *)a2 + 34);
  if (v2 >= *((unsigned __int8 *)this + 34))
  {
    *((_BYTE *)this + 34) = v2;
    result = *(__n128 *)a2;
    *(_QWORD *)((char *)this + 13) = *(_QWORD *)((char *)a2 + 13);
    *(__n128 *)this = result;
  }
  return result;
}

uint64_t sub_1C61F3FD0(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned __int8 *)(a1 + 16));
}

void sub_1C61F4004(__n128 *a1, int **a2, _WORD *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FB108, 0, 0);
  dword_1ED7FB188 = 0;
  qword_1ED7FB190 = (uint64_t)&off_1E7FA9DC8;
  *(_QWORD *)&dword_1ED7FB198 = 0;
  qword_1ED7FB108 = (uint64_t)&unk_1E819E418;
  qword_1ED7FB1A0 = (uint64_t)&unk_1E819E230;
  qword_1ED7FB1A8 = (uint64_t)&off_1E7FA9D80;
  qword_1ED7FB1C0 = (uint64_t)&qword_1ED7FB1A8;
  sub_1C517CE0C(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FB108);
}

unint64_t sub_1C61F40A0(char *a1, _DWORD *__dst, char *a3, int a4, uint64_t *a5)
{
  _QWORD *v8;
  char *v9;
  uint64_t v11;
  int v12[2];

  v11 = 0;
  v8 = sub_1C4ED49B0(a1, &v11, __dst, (unint64_t)a3, a4);
  *(_QWORD *)v12 = v11;
  v9 = (char *)sub_1C50FDB34(a1, (uint64_t *)v12, v8, (unint64_t)a3, *a5);
  return sub_1C4E37BA0(a1, *(uint64_t *)v12, v9, a3);
}

unint64_t sub_1C61F4120(char *a1, _DWORD *__dst, char *a3, int a4, uint64_t *a5, uint64_t a6)
{
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v13;
  uint64_t v14;

  v13 = 0;
  v10 = sub_1C4ED49B0(a1, &v13, __dst, (unint64_t)a3, a4);
  v14 = v13;
  v11 = sub_1C50FDB34(a1, &v14, v10, (unint64_t)a3, *a5);
  return sub_1C61F41A8(a1, v14, v11, a3, a6);
}

unint64_t sub_1C61F41A8(char *a1, uint64_t a2, _QWORD *a3, char *a4, uint64_t a5)
{
  unint64_t v8;
  char *v9;
  int v11[2];

  *(_QWORD *)v11 = a2;
  v8 = llvm::hash_value(*(_QWORD **)a5, *(_QWORD *)(a5 + 8));
  v9 = (char *)sub_1C4E37644(a1, (uint64_t *)v11, a3, (unint64_t)a4, v8);
  return sub_1C4E37BA0(a1, *(uint64_t *)v11, v9, a4);
}

unint64_t sub_1C61F4214(char *a1, _BYTE *__dst, char *a3, char a4, int *a5, uint64_t *a6, uint64_t *a7)
{
  _BYTE *v12;
  _QWORD *v13;
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  v12 = sub_1C4ED4714(a1, &v15, __dst, (unint64_t)a3, a4);
  v16 = v15;
  v13 = sub_1C4ED49B0(a1, &v16, v12, (unint64_t)a3, *a5);
  return sub_1C61F42AC(a1, v16, v13, a3, *a6, a7);
}

unint64_t sub_1C61F42AC(char *a1, uint64_t a2, _QWORD *a3, char *a4, uint64_t a5, uint64_t *a6)
{
  _QWORD *v9;
  char *v10;
  uint64_t v12;
  int v13[2];

  v12 = a2;
  v9 = sub_1C50FDB34(a1, &v12, a3, (unint64_t)a4, a5);
  *(_QWORD *)v13 = v12;
  v10 = (char *)sub_1C50FDB34(a1, (uint64_t *)v13, v9, (unint64_t)a4, *a6);
  return sub_1C4E37BA0(a1, *(uint64_t *)v13, v10, a4);
}

unint64_t sub_1C61F4320(char *a1, _BYTE *__dst, char *a3, char a4, int *a5, uint64_t a6)
{
  _BYTE *v10;
  _QWORD *v11;
  uint64_t v13;
  uint64_t v14;

  v13 = 0;
  v10 = sub_1C4ED4714(a1, &v13, __dst, (unint64_t)a3, a4);
  v14 = v13;
  v11 = sub_1C4ED49B0(a1, &v14, v10, (unint64_t)a3, *a5);
  return sub_1C61F43A8(a1, v14, v11, a3, a6);
}

unint64_t sub_1C61F43A8(char *a1, uint64_t a2, _QWORD *a3, char *a4, uint64_t a5)
{
  unint64_t v8;
  char *v9;
  int v11[2];

  *(_QWORD *)v11 = a2;
  v8 = sub_1C517D118(*(_QWORD **)a5, *(_QWORD *)a5 + 4 * *(_QWORD *)(a5 + 8));
  v9 = (char *)sub_1C4E37644(a1, (uint64_t *)v11, a3, (unint64_t)a4, v8);
  return sub_1C4E37BA0(a1, *(uint64_t *)v11, v9, a4);
}

llvm::MachineOptimizationRemarkEmitterPass *llvm::MachineOptimizationRemarkEmitterPass::MachineOptimizationRemarkEmitterPass(llvm::MachineOptimizationRemarkEmitterPass *this)
{
  llvm::PassRegistry *v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = (llvm::PassRegistry *)sub_1C4776848((uint64_t)this, (uint64_t)llvm::MachineOptimizationRemarkEmitterPass::ID);
  *(_QWORD *)v2 = &off_1E8145958;
  *((_QWORD *)v2 + 31) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  v3 = atomic_load(&qword_1ED82F6A8);
  if (v3 != -1)
  {
    v7[0] = sub_1C517D600;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F6A8, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeMachineOptimizationRemarkEmitterPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F6A8);
  if (v2 != -1)
  {
    v5[0] = sub_1C517D600;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F6A8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void *llvm::MachineOptimizationRemarkEmitterPass::getAnalysisUsage(llvm::MachineOptimizationRemarkEmitterPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, llvm::LazyMachineBlockFrequencyInfoPass::ID);
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void sub_1C61F4554(llvm::Pass *a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &off_1E8145958;
  v2 = *((_QWORD *)a1 + 31);
  *((_QWORD *)a1 + 31) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C40A4A59CD2);
  sub_1C4926674(a1);
}

void sub_1C61F45A0(llvm::Pass *a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &off_1E8145958;
  v2 = *((_QWORD *)a1 + 31);
  *((_QWORD *)a1 + 31) = 0;
  if (v2)
    MEMORY[0x1CAA32FC0](v2, 0x20C40A4A59CD2);
  sub_1C4926674(a1);
  JUMPOUT(0x1CAA32FC0);
}

llvm::MachineOptimizationRemarkEmitterPass *llvm::callDefaultCtor<llvm::MachineOptimizationRemarkEmitterPass>()
{
  llvm::MachineOptimizationRemarkEmitterPass *v0;

  v0 = (llvm::MachineOptimizationRemarkEmitterPass *)operator new();
  return llvm::MachineOptimizationRemarkEmitterPass::MachineOptimizationRemarkEmitterPass(v0);
}

uint64_t llvm::createMachineOutlinerPass(llvm *this)
{
  char v1;
  uint64_t v2;
  uint64_t result;

  v1 = (char)this;
  v2 = operator new();
  result = sub_1C517D698(v2);
  *(_BYTE *)(result + 36) = v1;
  return result;
}

void llvm::initializeMachineOutlinerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FB1D0);
  if (v2 != -1)
  {
    v5[0] = sub_1C517D770;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FB1D0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C61F46C8(uint64_t a1, uint64_t a2, llvm::MachineInstrExpressionTrait *this, _DWORD *a4)
{
  uint64_t result;
  uint64_t *v9;
  char v10;
  uint64_t v11;
  uint64_t *v12;

  v12 = 0;
  result = sub_1C5181698((uint64_t *)a2, this, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C5181784(a2, (uint64_t)this, this, v12);
    v9 = (uint64_t *)result;
    *(_QWORD *)result = *(_QWORD *)this;
    *(_DWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1C61F4760(uint64_t a1, int a2, int a3, uint64_t *a4, uint64_t *a5, uint64_t a6, int a7, unsigned int a8)
{
  unint64_t v9;
  uint64_t result;

  v9 = *(_QWORD *)(a1 + 8);
  if (v9 >= *(_QWORD *)(a1 + 16))
  {
    result = sub_1C5181B44((__int128 **)a1, a2, a3, *a4, *a5, a6, a7, a8);
  }
  else
  {
    *(_DWORD *)v9 = a2;
    *(_DWORD *)(v9 + 4) = a3;
    *(_QWORD *)(v9 + 8) = *a4;
    *(_QWORD *)(v9 + 16) = *a5;
    *(_QWORD *)(v9 + 24) = a6;
    *(_DWORD *)(v9 + 32) = 0;
    *(_QWORD *)(v9 + 40) = 0;
    *(_QWORD *)(v9 + 48) = v9 + 64;
    *(_QWORD *)(v9 + 56) = 0x600000000;
    *(_DWORD *)(v9 + 112) = 0;
    *(_QWORD *)(v9 + 120) = 0;
    *(_QWORD *)(v9 + 128) = v9 + 144;
    *(_QWORD *)(v9 + 136) = 0x600000000;
    *(_DWORD *)(v9 + 192) = 0;
    *(_WORD *)(v9 + 200) = 0;
    *(_DWORD *)(v9 + 204) = a7;
    *(_DWORD *)(v9 + 208) = 0;
    *(_DWORD *)(v9 + 212) = a8;
    *(_DWORD *)(v9 + 216) = 0;
    result = v9 + 224;
  }
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t sub_1C61F47F0(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;

  v4 = *a2;
  v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *(_QWORD *)(a1 + 48) = a1 + 64;
  v6 = a1 + 48;
  *(_QWORD *)(a1 + 56) = 0x600000000;
  if (*((_DWORD *)a2 + 14))
    sub_1C476B4F4(v6, (uint64_t)(a2 + 3));
  *(_QWORD *)(a1 + 128) = a1 + 144;
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 15);
  *(_QWORD *)(a1 + 136) = 0x600000000;
  if (*((_DWORD *)a2 + 34))
    sub_1C476B4F4(a1 + 128, (uint64_t)(a2 + 8));
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a2 + 48);
  v7 = *(__int128 *)((char *)a2 + 200);
  *(_DWORD *)(a1 + 216) = *((_DWORD *)a2 + 54);
  *(_OWORD *)(a1 + 200) = v7;
  return a1;
}

uint64_t sub_1C61F48A0(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;

  v4 = *a2;
  v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *(_QWORD *)(a1 + 48) = a1 + 64;
  v6 = a1 + 48;
  *(_QWORD *)(a1 + 56) = 0x600000000;
  if (*((_DWORD *)a2 + 14))
    sub_1C49DA960(v6, (uint64_t)(a2 + 3));
  *(_QWORD *)(a1 + 128) = a1 + 144;
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 15);
  *(_QWORD *)(a1 + 136) = 0x600000000;
  if (*((_DWORD *)a2 + 34))
    sub_1C49DA960(a1 + 128, (uint64_t)(a2 + 8));
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a2 + 48);
  v7 = *(__int128 *)((char *)a2 + 200);
  *(_DWORD *)(a1 + 216) = *((_DWORD *)a2 + 54);
  *(_OWORD *)(a1 + 200) = v7;
  return a1;
}

void sub_1C61F4950(uint64_t a1)
{
  if (*(_QWORD *)a1)
  {
    sub_1C5181AD4(a1, *(char **)a1);
    operator delete(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
}

void sub_1C61F4988(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v4;

  if (a2 != a3)
  {
    v4 = (char *)sub_1C5183588(a3, *(_QWORD *)(a1 + 8), a2);
    sub_1C5181AD4(a1, v4);
  }
}

void llvm::initializeMachinePipelinerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FB358);
  if (v2 != -1)
  {
    v5[0] = sub_1C51861B4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FB358, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::MachinePipeliner::scheduleLoop(uint64_t *****this, llvm::MachineLoop *a2)
{
  llvm::MachineLoop **v4;
  llvm::MachineLoop **v5;
  int v6;
  llvm::MachineLoop *v7;
  uint64_t ****v8;
  uint64_t v9;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  unint64_t v20;
  char *v21;
  unsigned __int8 *v22;
  const void *v23[10];
  void *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t (**v27)(llvm::DiagnosticInfoWithLocationBase *__hidden);
  int v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  char v37;
  char v38;
  void *v39;
  uint64_t v40;
  _BYTE v41[260];
  int v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v4 = (llvm::MachineLoop **)*((_QWORD *)a2 + 1);
  v5 = (llvm::MachineLoop **)*((_QWORD *)a2 + 2);
  if (v4 == v5)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    v6 = 0;
    do
    {
      v7 = *v4++;
      v6 |= llvm::MachinePipeliner::scheduleLoop((llvm::MachinePipeliner *)this, v7);
    }
    while (v4 != v5);
  }
  llvm::MachinePipeliner::setPragmaPipelineOptions((llvm::MachinePipeliner *)this, a2);
  if ((llvm::MachinePipeliner::canPipelineLoop((llvm::MachinePipeliner *)this, a2) & 1) != 0)
    return llvm::MachinePipeliner::swingModuloScheduler((llvm::MachinePipeliner *)this, a2);
  v8 = this[32];
  v9 = *(_QWORD *)****v8;
  if (*(_QWORD *)(v9 + 128)
    || (*(unsigned int (**)(_QWORD))(**(_QWORD **)(v9 + 72) + 48))(*(_QWORD *)(v9 + 72)))
  {
    llvm::MachineLoop::getStartLoc(a2, &v22);
    v11 = (int)v22;
    if (v22)
    {
      v12 = *(_QWORD *)&v22[-8 * *((unsigned int *)v22 + 2)];
      if (*(_BYTE *)v12 != 15)
        v12 = *(_QWORD *)(v12 - 8 * *(unsigned int *)(v12 + 8));
      v13 = *((_DWORD *)v22 + 1);
      v11 = *((unsigned __int16 *)v22 + 1);
    }
    else
    {
      v12 = 0;
      v13 = 0;
    }
    v14 = **((_QWORD **)a2 + 4);
    v15 = **(_QWORD **)(v14 + 32);
    v28 = 16;
    v29 = 2;
    v30 = v15;
    v31 = v12;
    v32 = v13;
    v33 = v11;
    v34 = "pipeliner";
    v35 = "canPipelineLoop";
    v36 = 15;
    v37 = 0;
    v38 = 0;
    v39 = v41;
    v40 = 0x400000000;
    v41[256] = 0;
    v42 = -1;
    v43 = v14;
    v27 = (uint64_t (**)(llvm::DiagnosticInfoWithLocationBase *__hidden))&unk_1E8141F00;
    v23[0] = "Failed to pipeline loop";
    v23[1] = (const void *)23;
    sub_1C53B17B4((uint64_t)&v39, v23);
    sub_1C61F875C((uint64_t)v23, (uint64_t)&v27);
    v23[0] = &unk_1E8141F00;
    v27 = &off_1E814E790;
    v16 = v39;
    if ((_DWORD)v40)
    {
      v17 = (unint64_t)v40 << 6;
      v18 = (char *)v39 - 64;
      do
      {
        sub_1C4765530((uint64_t)&v18[v17]);
        v17 -= 64;
      }
      while (v17);
      v16 = v39;
    }
    if (v16 != v41)
      free(v16);
    if (v22)
      llvm::MetadataTracking::untrack((uint64_t)&v22, v22);
    llvm::MachineOptimizationRemarkEmitter::emit(v8, (llvm::DiagnosticInfoOptimizationBase *)v23);
    v23[0] = &off_1E814E790;
    v19 = (uint64_t *)v24;
    if (v25)
    {
      v20 = (unint64_t)v25 << 6;
      v21 = (char *)v24 - 64;
      do
      {
        sub_1C4765530((uint64_t)&v21[v20]);
        v20 -= 64;
      }
      while (v20);
      v19 = (uint64_t *)v24;
    }
    if (v19 != &v26)
      free(v19);
  }
  return v6 & 1;
}

uint64_t llvm::MachinePipeliner::swingModuloScheduler(llvm::MachinePipeliner *this, llvm::MachineLoop *a2)
{
  void **v4;
  void *v5;
  uint64_t v6;
  llvm::MachineBasicBlock *v7;
  _QWORD *v8;
  int v9;
  _QWORD *v10;
  unint64_t i;
  uint64_t v12;
  unint64_t FirstTerminator;
  uint64_t v14;
  _BYTE v16[3248];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = (void **)**((_QWORD **)this + 1);
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != &llvm::LiveIntervals::ID);
  v6 = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), &llvm::LiveIntervals::ID);
  sub_1C61F78D0((uint64_t)v16, (uint64_t)this, (uint64_t)a2, v6, (uint64_t)this + 296, *((_DWORD *)this + 135));
  v7 = (llvm::MachineBasicBlock *)**((_QWORD **)a2 + 4);
  llvm::ScheduleDAGInstrs::startBlock((uint64_t)v16, v7);
  v8 = (_QWORD *)((char *)v7 + 48);
  v9 = -1;
  v10 = (_QWORD *)((char *)v7 + 48);
  do
  {
    v10 = (_QWORD *)v10[1];
    ++v9;
  }
  while (v10 != v8);
  for (i = llvm::MachineBasicBlock::getFirstTerminator(v7); (_QWORD *)i != v8; --v9)
  {
    if (!i || (*(_BYTE *)i & 4) == 0)
    {
      while ((*(_WORD *)(i + 44) & 8) != 0)
        i = *(_QWORD *)(i + 8);
    }
    i = *(_QWORD *)(i + 8);
  }
  v12 = *((_QWORD *)v7 + 7);
  FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator(v7);
  llvm::ScheduleDAGInstrs::enterRegion((uint64_t)v16, (uint64_t)v7, v12, FirstTerminator, v9);
  llvm::SwingSchedulerDAG::schedule((llvm::SwingSchedulerDAG *)v16);
  llvm::ScheduleDAGInstrs::exitRegion((llvm::ScheduleDAGInstrs *)v16);
  llvm::SwingSchedulerDAG::finishBlock((llvm::SwingSchedulerDAG *)v16);
  v14 = v16[2648];
  sub_1C61F7A34((uint64_t)v16);
  return v14;
}

uint64_t llvm::MachinePipeliner::preprocessPhiNodes(llvm::MachinePipeliner *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v3;
  void **v4;
  void *v5;
  uint64_t result;
  uint64_t v7;
  char *v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  llvm::MachineOperand *v13;
  unsigned int VirtualRegister;
  llvm::MachineBasicBlock *v15;
  unint64_t *FirstTerminator;
  llvm::MachineFunction *v17;
  unsigned int v18;
  llvm::MachineFunction **v19;
  uint64_t v20;
  llvm::MachineFunction *v22[2];
  unsigned __int8 *v23;

  v3 = *(_QWORD *)(*((_QWORD *)this + 31) + 40);
  v4 = (void **)**((_QWORD **)this + 1);
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != &llvm::LiveIntervals::ID);
  result = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), &llvm::LiveIntervals::ID);
  v7 = *((_QWORD *)a2 + 7);
  if ((llvm::MachineBasicBlock *)v7 != (llvm::MachineBasicBlock *)((char *)a2 + 48))
  {
    v20 = *(_QWORD *)(result + 288);
    v8 = (char *)*((_QWORD *)a2 + 7);
    while (!**((_WORD **)v8 + 2) || **((_WORD **)v8 + 2) == 69)
    {
      v8 = (char *)*((_QWORD *)v8 + 1);
      if (v8 == (char *)a2 + 48)
      {
        v8 = (char *)a2 + 48;
        break;
      }
    }
    while ((char *)v7 != v8)
    {
      v9 = *(_DWORD *)(v7 + 40);
      if (v9 != 1)
      {
        v10 = *(_QWORD *)(*(_QWORD *)(v3 + 24) + 16 * (*(_DWORD *)(*(_QWORD *)(v7 + 32) + 4) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
        v11 = 1;
        do
        {
          v12 = v11;
          v13 = (llvm::MachineOperand *)(*(_QWORD *)(v7 + 32) + 32 * v11);
          if ((*(_DWORD *)v13 & 0xFFF00) != 0)
          {
            VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(v3, v10, "", 0);
            v15 = *(llvm::MachineBasicBlock **)(*(_QWORD *)(v7 + 32) + 32 * (v12 + 1) + 16);
            FirstTerminator = (unint64_t *)llvm::MachineBasicBlock::getFirstTerminator(v15);
            llvm::MachineBasicBlock::findDebugLoc((uint64_t)v15, (uint64_t)FirstTerminator, &v23);
            v22[0] = sub_1C4787570((uint64_t)v15, FirstTerminator, &v23, *(_QWORD *)(*((_QWORD *)this + 36) + 8) + 912, VirtualRegister);
            v22[1] = v17;
            LODWORD(v15) = *((_DWORD *)v13 + 1);
            v18 = sub_1C61F5084(v13);
            v19 = sub_1C47BF4F4(v22, (int)v15, v18, (*(_DWORD *)v13 >> 8) & 0xFFF);
            sub_1C4850BC8(v20, (uint64_t)v19[1], 0);
            result = llvm::MachineOperand::setReg((uint64_t)v13, VirtualRegister);
            *(_DWORD *)v13 &= 0xFFF000FF;
            if (v23)
              result = llvm::MetadataTracking::untrack((uint64_t)&v23, v23);
          }
          v11 = v12 + 2;
        }
        while (v9 != v12 + 2);
      }
      if ((*(_BYTE *)v7 & 4) == 0)
      {
        while ((*(_WORD *)(v7 + 44) & 8) != 0)
          v7 = *(_QWORD *)(v7 + 8);
      }
      v7 = *(_QWORD *)(v7 + 8);
    }
  }
  return result;
}

uint64_t sub_1C61F5084(llvm::MachineOperand *a1)
{
  unsigned int v1;
  int v2;
  _BOOL4 isRenamable;
  unsigned int v5;

  v1 = *(_DWORD *)a1;
  if ((*((_DWORD *)a1 + 1) - 1) <= 0x3FFFFFFE)
  {
    v5 = *(_DWORD *)a1;
    isRenamable = llvm::MachineOperand::isRenamable(a1);
    v1 = v5;
    if (isRenamable)
      v2 = 512;
    else
      v2 = 0;
  }
  else
  {
    v2 = 0;
  }
  return (v1 >> 23) & 0x26 | (v1 >> 21) & 0x100 | HIBYTE(v1) & 0x80 | (16 * (HIBYTE(v1) & 1 & (v1 >> 26))) | (8 * (!(v1 & 0x1000000) & (v1 >> 26))) | v2;
}

void *llvm::MachinePipeliner::getAnalysisUsage(llvm::MachinePipeliner *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AAResultsWrapperPass::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineLoopInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::LiveIntervals::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineOptimizationRemarkEmitterPass::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::SwingSchedulerDAG::addLoopCarriedDependences(llvm::Type *****this, llvm::AAResults *a2)
{
  llvm::UndefValue *VoidTy;
  llvm::Type *v4;
  llvm::Type ****v5;
  int64_t v6;
  uint64_t v8;
  uint64_t v9;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unsigned int v23;
  __int128 *v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  _QWORD *v32;
  unsigned int *v33;
  uint64_t v34;
  int v35;
  const llvm::MachineInstr *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  __int128 v43;
  _QWORD *v44;
  __int128 v45;
  uint64_t v46;
  BOOL v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  llvm::Type ****v51;
  llvm::UndefValue *v52;
  uint64_t *v53;
  uint64_t *v54;
  llvm::Type *****v56;
  uint64_t *v57;
  BOOL v58[2];
  uint64_t v59;
  uint64_t v60;
  llvm::MachineOperand *v61;
  llvm::MachineOperand *v62;
  _QWORD v63[2];
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  _BYTE v70[32];
  _QWORD *v71;
  uint64_t v72;
  _OWORD v73[4];
  __int128 *v74;
  uint64_t v75;
  __int128 v76;
  _OWORD v77[4];
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v63[0] = 0;
  v63[1] = 0;
  v64 = 0;
  v66 = 0;
  v67 = 0;
  v65 = 0;
  VoidTy = (llvm::UndefValue *)llvm::Type::getVoidTy(***this[4], a2);
  v52 = llvm::UndefValue::get(VoidTy, v4);
  v6 = (int64_t)this[6];
  v5 = this[7];
  v56 = this;
  if ((llvm::Type ****)v6 != v5)
  {
    v51 = this[7];
    do
    {
      v8 = *(_QWORD *)(v6 + 8);
      v9 = *(_QWORD *)(*(_QWORD *)(v8 + 16) + 8);
      if ((*(_WORD *)(v8 + 44) & 0xC) != 0 && (*(_WORD *)(v8 + 44) & 4) == 0)
      {
        v17 = *(_QWORD *)(v6 + 8);
        if ((v9 & 0x80) != 0)
          goto LABEL_29;
        while ((*(_WORD *)(v17 + 44) & 8) != 0)
        {
          v17 = *(_QWORD *)(v17 + 8);
          if ((*(_BYTE *)(*(_QWORD *)(v17 + 16) + 8) & 0x80) != 0)
            goto LABEL_29;
        }
      }
      else if ((v9 & 0x80) != 0)
      {
        goto LABEL_29;
      }
      if (sub_1C5166344(*(_QWORD *)(v6 + 8))
        || llvm::MachineInstr::hasUnmodeledSideEffects((llvm::MachineInstr *)v8)
        || llvm::MachineInstr::hasOrderedMemoryRef((llvm::MachineInstr *)v8)
        && (!sub_1C5073EC0(v8, 1)
         || (llvm::MachineInstr::isDereferenceableInvariantLoad((llvm::MachineInstr *)v8, a2) & 1) == 0))
      {
LABEL_29:
        sub_1C61F5B54((uint64_t)v63);
        goto LABEL_24;
      }
      if (!sub_1C5073EC0(v8, 1))
      {
        if (sub_1C5073F60(v8, 1))
        {
          v68 = (uint64_t *)v70;
          v69 = 0x400000000;
          sub_1C518C4FC(v8, (uint64_t)&v68);
          if ((_DWORD)v69)
          {
            v16 = v68;
            v18 = &v68[v69];
            goto LABEL_33;
          }
          if (HIDWORD(v69))
          {
            v49 = 0;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, (uint64_t)v70, 1uLL, 8);
            v49 = v69;
          }
          v68[v49] = (uint64_t)v52;
          v16 = v68;
          v47 = __CFADD__((_DWORD)v69, 1);
          v50 = v69 + 1;
          LODWORD(v69) = v69 + 1;
          if (!v47)
          {
            v18 = &v68[v50];
LABEL_33:
            v53 = v18;
LABEL_34:
            v54 = v16;
            v19 = sub_1C61F5CC0((uint64_t)v63, *v16);
            if (v66 == v19)
              goto LABEL_84;
            v20 = *(unsigned int *)(v19 + 16);
            if (!(_DWORD)v20)
              goto LABEL_84;
            v21 = *(uint64_t **)(v19 + 8);
            v57 = &v21[v20];
LABEL_37:
            v22 = *v21;
            v74 = v77;
            v75 = (uint64_t)v77;
            *(_QWORD *)&v76 = 8;
            DWORD2(v76) = 0;
            v71 = v73;
            HIDWORD(v72) = 8;
            *(_QWORD *)&v73[0] = v22;
            v23 = 1;
            v24 = v77;
            v25 = v77;
            while (1)
            {
              v26 = v71[--v23];
              LODWORD(v72) = v23;
              v27 = *(unsigned int *)(v26 + 120);
              if ((_DWORD)v27)
                break;
LABEL_50:
              if (!v23)
              {
                v35 = 1;
                goto LABEL_53;
              }
            }
            v28 = *(uint64_t **)(v26 + 112);
            v29 = 16 * v27;
            while (1)
            {
              v30 = *v28;
              if ((~*(_DWORD *)v28 & 6) == 0)
              {
                v31 = v30 & 0xFFFFFFFFFFFFFFF8;
                v32 = sub_1C477672C((uint64_t)&v74, v30 & 0xFFFFFFFFFFFFFFF8);
                v24 = v74;
                v25 = (__int128 *)v75;
                v33 = (unsigned int *)&v76 + 1;
                if ((__int128 *)v75 != v74)
                  v33 = (unsigned int *)&v76;
                if (v32 == (_QWORD *)(v75 + 8 * *v33))
                {
                  if (v6 == v31)
                  {
                    v35 = 0;
LABEL_53:
                    if (v71 != (_QWORD *)v73)
                    {
                      free(v71);
                      v24 = v74;
                      v25 = (__int128 *)v75;
                    }
                    if (v25 != v24)
                      free(v25);
                    if (v35)
                    {
                      v36 = *(const llvm::MachineInstr **)(v22 + 8);
                      v61 = 0;
                      v62 = 0;
                      v59 = 0;
                      v60 = 0;
                      *(_WORD *)v58 = 0;
                      if (llvm::TargetInstrInfo::getMemOperandWithOffset((llvm::TargetInstrInfo *)v56[2], v36, &v62, &v60, &v58[1], (const llvm::TargetRegisterInfo *)v56[3]))
                      {
                        if (llvm::TargetInstrInfo::getMemOperandWithOffset((llvm::TargetInstrInfo *)v56[2], (const llvm::MachineInstr *)v8, &v61, &v59, v58, (const llvm::TargetRegisterInfo *)v56[3])&& llvm::MachineOperand::isIdenticalTo(v62, v61)&& v58[1] == v58[0]&& (int)v60 < (int)v59)
                        {
                          goto LABEL_77;
                        }
                      }
                      if (!a2)
                        goto LABEL_77;
                      v37 = *((_QWORD *)v36 + 6);
                      if ((v37 & 7) != 0)
                      {
                        v38 = *(_QWORD *)((v37 & 0xFFFFFFFFFFFFFFF8) + 8);
                      }
                      else
                      {
                        v38 = v37 & 0xFFFFFFFFFFFFFFF8;
                        *((_QWORD *)v36 + 6) = v38;
                      }
                      v39 = *(_QWORD *)(v8 + 48);
                      if ((v39 & 7) != 0)
                      {
                        v40 = *(_QWORD *)((v39 & 0xFFFFFFFFFFFFFFF8) + 8);
                      }
                      else
                      {
                        v40 = v39 & 0xFFFFFFFFFFFFFFF8;
                        *(_QWORD *)(v8 + 48) = v40;
                      }
                      if ((*(_QWORD *)v38 & 4) != 0)
                        goto LABEL_77;
                      v41 = *(_QWORD *)v38 & 0xFFFFFFFFFFFFFFF8;
                      if (!v41)
                        goto LABEL_77;
                      if ((*(_QWORD *)v40 & 4) != 0)
                        goto LABEL_77;
                      v42 = *(_QWORD *)v40 & 0xFFFFFFFFFFFFFFF8;
                      if (!v42 || v41 == v42 && *(_QWORD *)(v38 + 8) <= *(_QWORD *)(v40 + 8))
                        goto LABEL_77;
                      v74 = (__int128 *)(*(_QWORD *)v38 & 0xFFFFFFFFFFFFFFF8);
                      v75 = -2;
                      v43 = *(_OWORD *)(v38 + 56);
                      v76 = *(_OWORD *)(v38 + 40);
                      v77[0] = v43;
                      v44 = (*(_QWORD *)v40 & 4) != 0 ? 0 : (_QWORD *)(*(_QWORD *)v40 & 0xFFFFFFFFFFFFFFF8);
                      v71 = v44;
                      v72 = -2;
                      v45 = *(_OWORD *)(v40 + 56);
                      v73[0] = *(_OWORD *)(v40 + 40);
                      v73[1] = v45;
                      if (llvm::AAResults::alias((uint64_t)a2, (uint64_t)&v74, (uint64_t)&v71))
                      {
LABEL_77:
                        v74 = (__int128 *)(v22 | 6);
                        v75 = 0x100000000;
                        llvm::SUnit::addPred(v6, (const llvm::SDep *)&v74, 1);
                      }
                    }
                    if (++v21 == v57)
                    {
LABEL_84:
                      v16 = v54 + 1;
                      if (v54 + 1 == v53)
                      {
                        v16 = v68;
                        v5 = v51;
                        break;
                      }
                      goto LABEL_34;
                    }
                    goto LABEL_37;
                  }
                  v34 = v72;
                  if (v72 >= (unint64_t)HIDWORD(v72))
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, (uint64_t)v73, v72 + 1, 8);
                    v34 = v72;
                  }
                  v71[v34] = v31;
                  LODWORD(v72) = v72 + 1;
                  sub_1C4774094((llvm::SmallPtrSetImplBase *)&v74, v31);
                  v24 = v74;
                  v25 = (__int128 *)v75;
                }
              }
              v28 += 2;
              v29 -= 16;
              if (!v29)
              {
                v23 = v72;
                goto LABEL_50;
              }
            }
          }
          if (v16 != (uint64_t *)v70)
            goto LABEL_23;
        }
        goto LABEL_24;
      }
      v74 = &v76;
      v75 = 0x400000000;
      sub_1C518C4FC(v8, (uint64_t)&v74);
      if ((_DWORD)v75)
      {
        v11 = (char *)v74;
        v12 = (char *)v74 + 8 * v75;
      }
      else
      {
        if (HIDWORD(v75))
        {
          v46 = 0;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, (uint64_t)&v76, 1uLL, 8);
          v46 = v75;
        }
        *((_QWORD *)v74 + v46) = v52;
        v11 = (char *)v74;
        v47 = __CFADD__((_DWORD)v75, 1);
        v48 = v75 + 1;
        LODWORD(v75) = v75 + 1;
        if (v47)
          goto LABEL_21;
        v12 = (char *)v74 + 8 * v48;
      }
      do
      {
        v71 = *(_QWORD **)v11;
        v13 = sub_1C61F5BA8((uint64_t)v63, (uint64_t *)&v71);
        v14 = v13;
        v15 = *(unsigned int *)(v13 + 8);
        if (v15 >= *(unsigned int *)(v13 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v13 + 16, v15 + 1, 8);
          v15 = *(unsigned int *)(v14 + 8);
        }
        *(_QWORD *)(*(_QWORD *)v14 + 8 * v15) = v6;
        ++*(_DWORD *)(v14 + 8);
        v11 += 8;
      }
      while (v11 != v12);
      v11 = (char *)v74;
LABEL_21:
      if (v11 != (char *)&v76)
      {
        v16 = (uint64_t *)v11;
LABEL_23:
        free(v16);
      }
LABEL_24:
      v6 += 272;
    }
    while ((llvm::Type ****)v6 != v5);
  }
  return sub_1C61F7CF0((uint64_t)v63);
}

uint64_t llvm::SwingSchedulerDAG::findCircuits(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  signed int i;
  int32x2_t v10[167];

  v10[166] = *(int32x2_t *)MEMORY[0x1E0C80C00];
  v4 = (uint64_t *)(a1 + 48);
  sub_1C518D154(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  sub_1C5191464((uint64_t)v10, v4, a1 + 2688);
  llvm::SwingSchedulerDAG::Circuits::createAdjacencyStructure((uint64_t **)v10, (llvm::TargetInstrInfo **)a1);
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *v4;
  v7 = -252645135 * ((unint64_t)(v5 - *v4) >> 4);
  if (v7)
  {
    for (i = 0; i != v7; ++i)
    {
      sub_1C61F6390((uint64_t)v10);
      llvm::SwingSchedulerDAG::Circuits::circuit(v10, i, i, a2, 0);
    }
    v6 = *(_QWORD *)(a1 + 48);
    v5 = *(_QWORD *)(a1 + 56);
  }
  sub_1C518D154(v6, v5);
  return sub_1C61F7F70((uint64_t)v10);
}

_QWORD *llvm::SwingSchedulerDAG::fuseRecs(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned int v13;
  _QWORD *result;
  uint64_t v15;

  v2 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v2)
  {
    v4 = *(_QWORD *)a2;
    v5 = *(_QWORD *)a2 + 88 * v2;
    v6 = *(_QWORD *)a2;
    do
    {
      v7 = v6;
      v6 += 88;
      if (v6 == v5)
      {
        v8 = v5;
      }
      else
      {
        v8 = v6;
        do
        {
          v9 = *(uint64_t **)(v8 + 24);
          if (*(_DWORD *)(**(_QWORD **)(v7 + 24) + 192) == *(_DWORD *)(*v9 + 192))
          {
            v10 = *(_DWORD *)(v8 + 52);
            if (v10 - *(_DWORD *)(v7 + 52) >= 1)
              *(_DWORD *)(v7 + 52) = v10;
            v11 = *(uint64_t **)(v8 + 32);
            if (v9 != v11)
            {
              do
              {
                v12 = *v9++;
                v15 = v12;
                sub_1C518D044((_QWORD *)v7, &v15);
              }
              while (v9 != v11);
              v4 = *(_QWORD *)a2;
              v2 = *(unsigned int *)(a2 + 8);
            }
            sub_1C519329C(v8 + 88, v4 + 88 * v2, v8);
            v13 = *(_DWORD *)(a2 + 8) - 1;
            *(_DWORD *)(a2 + 8) = v13;
            result = sub_1C6176BF8((_QWORD *)(*(_QWORD *)a2 + 88 * v13));
            v4 = *(_QWORD *)a2;
            v2 = *(unsigned int *)(a2 + 8);
            v5 = *(_QWORD *)a2 + 88 * v2;
          }
          else
          {
            v8 += 88;
          }
        }
        while (v8 != v5);
      }
      v5 = v8;
    }
    while (v6 != v8);
  }
  return result;
}

void llvm::SwingSchedulerDAG::removeDuplicateNodes(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD v13[2];

  v2 = *a2;
  v12 = *a2;
  v3 = *((_DWORD *)a2 + 2);
  if (v3)
  {
    v5 = v2 + 88 * v3;
    do
    {
      v6 = v2 + 88;
      if (v2 + 88 != v5)
      {
        do
        {
          v7 = *(uint64_t **)(v6 + 24);
          v8 = *(uint64_t **)(v6 + 32);
          v13[0] = &v12;
          v13[1] = v6;
          if (v7 != v8)
          {
            while (1)
            {
              v9 = v7 + 1;
              if (sub_1C5194410((uint64_t)v13, v7))
                break;
              ++v7;
              if (v9 == v8)
              {
                v7 = v8;
                goto LABEL_12;
              }
            }
            while (v9 != v8)
            {
              if ((sub_1C5194410((uint64_t)v13, v9) & 1) == 0)
                *v7++ = *v9;
              ++v9;
            }
          }
LABEL_12:
          v10 = *(uint64_t **)(v6 + 24);
          if (v7 != *(uint64_t **)(v6 + 32))
            *(_QWORD *)(v6 + 32) = v7;
          if (v10 == v7)
          {
            sub_1C519329C(v6 + 88, *a2 + 88 * *((unsigned int *)a2 + 2), v6);
            v11 = *((_DWORD *)a2 + 2) - 1;
            *((_DWORD *)a2 + 2) = v11;
            sub_1C6176BF8((_QWORD *)(*a2 + 88 * v11));
            v5 = *a2 + 88 * *((unsigned int *)a2 + 2);
          }
          else
          {
            v6 += 88;
          }
        }
        while (v6 != v5);
        v2 = v12;
        v5 = v6;
      }
      v2 += 88;
      v12 = v2;
    }
    while (v2 != v5);
  }
}

void sub_1C61F5B54(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  sub_1C4ECAD30((_DWORD *)a1);
  v2 = *(_QWORD *)(a1 + 24);
  for (i = *(_QWORD *)(a1 + 32); i != v2; i -= 56)
  {
    v4 = *(void **)(i - 48);
    if ((void *)(i - 32) != v4)
      free(v4);
  }
  *(_QWORD *)(a1 + 32) = v2;
}

uint64_t sub_1C61F5BA8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v8;
  char v9;
  uint64_t v10;
  int v11;
  void *v12;
  uint64_t v13;
  _BYTE v14[32];
  uint64_t v15;
  void *v16;
  uint64_t v17;
  _QWORD v18[5];

  v18[4] = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = 0;
  sub_1C51934B8(a1, &v10, &v11, (uint64_t)&v8);
  v4 = v8;
  if (v9)
  {
    v12 = v14;
    v13 = 0x400000000;
    v15 = *a2;
    v16 = v18;
    v17 = 0x400000000;
    sub_1C5193314((uint64_t *)(a1 + 24), (uint64_t)&v15);
    if (v16 != v18)
      free(v16);
    if (v12 != v14)
      free(v12);
    v5 = *(_QWORD *)(a1 + 24);
    v6 = -1227133513 * ((unint64_t)(*(_QWORD *)(a1 + 32) - v5) >> 3) - 1;
    *(_DWORD *)(v4 + 8) = v6;
  }
  else
  {
    v6 = *(_DWORD *)(v8 + 8);
    v5 = *(_QWORD *)(a1 + 24);
  }
  return v5 + 56 * v6 + 8;
}

uint64_t sub_1C61F5CC0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a2;
  v5 = 0;
  if (!sub_1C47AD1C0(a1, &v4, &v5) || v5 == *(_QWORD *)a1 + 16 * *(unsigned int *)(a1 + 16))
    return *(_QWORD *)(a1 + 32);
  else
    return *(_QWORD *)(a1 + 24) + 56 * *(unsigned int *)(v5 + 8);
}

uint64_t llvm::SwingSchedulerDAG::canUseLastOffsetValue(llvm::SwingSchedulerDAG *this, llvm::MachineInstr *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, uint64_t *a6)
{
  uint64_t result;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  llvm::MachineInstr *VRegDef;
  llvm::MachineInstr *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  llvm::MachineInstr *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;

  if (((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 760))(*((_QWORD *)this + 2)) & 1) != 0)
    return 0;
  v32 = 0;
  v13 = (*(uint64_t (**)(_QWORD, llvm::MachineInstr *, char *, uint64_t *))(**((_QWORD **)this + 2) + 688))(*((_QWORD *)this + 2), a2, (char *)&v32 + 4, &v32);
  result = 0;
  if (v13)
  {
    v14 = *((_QWORD *)a2 + 3);
    v15 = *(_QWORD *)(*(_QWORD *)(v14 + 32) + 40);
    result = llvm::MachineRegisterInfo::getVRegDef(v15, *(_DWORD *)(*((_QWORD *)a2 + 4) + 32 * HIDWORD(v32) + 4));
    if (result)
    {
      v16 = **(unsigned __int16 **)(result + 16);
      if (v16 != 69 && v16 != 0)
        return 0;
      v18 = *(_DWORD *)(result + 40);
      if (v18 == 1)
        return 0;
      v19 = *(_QWORD *)(result + 32);
      v20 = 1;
      while (*(_QWORD *)(v19 + 32 * (v20 + 1) + 16) != v14)
      {
        v20 += 2;
        if (v18 == v20)
          return 0;
      }
      v21 = v19 + 32 * v20;
      v22 = *(_DWORD *)(v21 + 4);
      if (!v22)
        return 0;
      VRegDef = (llvm::MachineInstr *)llvm::MachineRegisterInfo::getVRegDef(v15, *(_DWORD *)(v21 + 4));
      if (!VRegDef || VRegDef == a2)
        return 0;
      v25 = VRegDef;
      result = (*(uint64_t (**)(_QWORD, llvm::MachineInstr *))(**((_QWORD **)this + 2) + 760))(*((_QWORD *)this + 2), VRegDef);
      if ((_DWORD)result)
      {
        v31 = 0;
        v26 = (*(uint64_t (**)(_QWORD, llvm::MachineInstr *, char *, uint64_t *))(**((_QWORD **)this + 2)
                                                                                         + 688))(*((_QWORD *)this + 2), v25, (char *)&v31 + 4, &v31);
        result = 0;
        if (v26)
        {
          v27 = *(_QWORD *)(*((_QWORD *)a2 + 4) + 32 * v32 + 16);
          v28 = *(_QWORD *)(*((_QWORD *)v25 + 4) + 32 * v31 + 16);
          v29 = llvm::MachineFunction::CloneMachineInstr(*((llvm::MachineFunction **)this + 4), a2);
          *(_QWORD *)(*((_QWORD *)v29 + 4) + 32 * v32 + 16) = v28 + v27;
          v30 = (*(uint64_t (**)(_QWORD, llvm::MachineInstr *, llvm::MachineInstr *))(**((_QWORD **)this + 2)
                                                                                              + 1064))(*((_QWORD *)this + 2), v29, v25);
          llvm::MachineFunction::deleteMachineInstr(*((llvm::MachineFunction **)this + 4), v29);
          if (v30)
          {
            *a3 = HIDWORD(v32);
            *a4 = v32;
            *a5 = v22;
            *a6 = v28;
            return 1;
          }
          return 0;
        }
      }
    }
  }
  return result;
}

int *sub_1C61F5F34(uint64_t *a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *result;
  int v6;
  int v7;
  int v8;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 4);
  if ((_DWORD)v3)
  {
    LODWORD(v4) = (37 * *a2) & (v3 - 1);
    result = (int *)(v2 + 8 * v4);
    v6 = *result;
    if (*a2 == *result)
      return result;
    v7 = 1;
    while (v6 != 0x7FFFFFFF)
    {
      v8 = v4 + v7++;
      v4 = v8 & (v3 - 1);
      v6 = *(_DWORD *)(v2 + 8 * v4);
      if (*a2 == v6)
        return (int *)(v2 + 8 * v4);
    }
  }
  return (int *)(v2 + 8 * v3);
}

uint64_t llvm::SwingSchedulerDAG::isLoopCarriedDep(llvm::TargetInstrInfo **this, llvm::SUnit *a2, const llvm::SDep *a3, int a4)
{
  llvm::MachineInstr *v7;
  llvm::MachineInstr *v8;
  uint64_t result;
  const llvm::TargetRegisterInfo *v10;
  llvm::MachineOperand *v11;
  uint64_t v12;
  uint64_t VRegDef;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v28;
  int v29;
  BOOL v30[2];
  uint64_t v31;
  uint64_t v32;
  llvm::MachineOperand *v33;
  llvm::MachineOperand *v34;
  unsigned int v35[2];

  if ((*(_QWORD *)a3 & 4) == 0)
    return 0;
  if ((*(_QWORD *)a3 & 6) == 6 && *((_DWORD *)a3 + 2) == 3)
    return 0;
  if ((*(_QWORD *)a3 & 6) == 4 || byte_1ED7FB7A0 == 0)
    return 1;
  v7 = a4
     ? *(llvm::MachineInstr **)((*(_QWORD *)a3 & 0xFFFFFFFFFFFFFFF8) + 8)
     : (llvm::MachineInstr *)*((_QWORD *)a2 + 1);
  v8 = a4
     ? (llvm::MachineInstr *)*((_QWORD *)a2 + 1)
     : *(llvm::MachineInstr **)((*(_QWORD *)a3 & 0xFFFFFFFFFFFFFFF8) + 8);
  if (llvm::MachineInstr::hasUnmodeledSideEffects(v8)
    || llvm::MachineInstr::hasUnmodeledSideEffects(v7)
    || sub_1C5166344((uint64_t)v8)
    || sub_1C5166344((uint64_t)v7)
    || llvm::MachineInstr::hasOrderedMemoryRef(v8)
    || llvm::MachineInstr::hasOrderedMemoryRef(v7))
  {
    return 1;
  }
  result = sub_1C5073F60((uint64_t)v7, 1);
  if ((_DWORD)result)
  {
    result = sub_1C5073EC0((uint64_t)v8, 1);
    if ((_DWORD)result)
    {
      *(_QWORD *)v35 = 0;
      if (!llvm::SwingSchedulerDAG::computeDelta((llvm::SwingSchedulerDAG *)this, v8, &v35[1]))
        return 1;
      if (!llvm::SwingSchedulerDAG::computeDelta((llvm::SwingSchedulerDAG *)this, v7, v35))
        return 1;
      v33 = 0;
      v34 = 0;
      v31 = 0;
      v32 = 0;
      *(_WORD *)v30 = 0;
      v10 = (const llvm::TargetRegisterInfo *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this[4] + 2) + 176))(*((_QWORD *)this[4] + 2));
      if (!llvm::TargetInstrInfo::getMemOperandWithOffset(this[2], v8, &v34, &v32, &v30[1], v10))
        return 1;
      if (!llvm::TargetInstrInfo::getMemOperandWithOffset(this[2], v7, &v33, &v31, v30, v10))
        return 1;
      v11 = v34;
      if (!llvm::MachineOperand::isIdenticalTo(v34, v33))
        return 1;
      v12 = (uint64_t)this[5];
      VRegDef = llvm::MachineRegisterInfo::getVRegDef(v12, *((_DWORD *)v11 + 1));
      if (!VRegDef || **(_WORD **)(VRegDef + 16) != 69 && **(_WORD **)(VRegDef + 16))
        return 1;
      v14 = *(_DWORD *)(VRegDef + 40);
      v15 = v14 - 1;
      if (v14 == 1)
      {
        v16 = 0;
      }
      else
      {
        v17 = 0;
        v16 = 0;
        v18 = *(_QWORD *)(VRegDef + 32);
        v19 = (unsigned int *)(v18 + 36);
        do
        {
          if (*(llvm::TargetInstrInfo **)(v18 + 32 * (v17 + 2) + 16) == this[115])
            v16 = *v19;
          v17 += 2;
          v19 += 16;
        }
        while (v15 != v17);
      }
      v20 = llvm::MachineRegisterInfo::getVRegDef(v12, v16);
      v29 = 0;
      if (!v20
        || !(*(unsigned int (**)(llvm::TargetInstrInfo *, uint64_t, int *))(*(_QWORD *)this[2] + 712))(this[2], v20, &v29))
      {
        return 1;
      }
      v21 = *((_QWORD *)v8 + 6);
      if ((v21 & 7) != 0)
      {
        v22 = *(_QWORD *)((v21 & 0xFFFFFFFFFFFFFFF8) + 8);
      }
      else
      {
        v22 = v21 & 0xFFFFFFFFFFFFFFF8;
        *((_QWORD *)v8 + 6) = v21 & 0xFFFFFFFFFFFFFFF8;
      }
      v23 = sub_1C4831E04(v22);
      v24 = *((_QWORD *)v7 + 6);
      if ((v24 & 7) != 0)
      {
        v25 = *(_QWORD *)((v24 & 0xFFFFFFFFFFFFFFF8) + 8);
      }
      else
      {
        v25 = v24 & 0xFFFFFFFFFFFFFFF8;
        *((_QWORD *)v7 + 6) = v24 & 0xFFFFFFFFFFFFFFF8;
      }
      v26 = sub_1C4831E04(v25);
      if (v23 == -1 || v26 == -1)
        return 1;
      v28 = v26;
      result = 1;
      if (v35[1] == v35[0] && v23 <= v35[1] && v28 <= v35[0])
        return (uint64_t)(v32 + v23) < (uint64_t)(v31 + v28);
    }
  }
  return result;
}

llvm::SwingSchedulerDAG::Circuits *llvm::SwingSchedulerDAG::Circuits::unblock(llvm::SwingSchedulerDAG::Circuits *this, unsigned int a2)
{
  uint64_t v2;
  llvm::SwingSchedulerDAG::Circuits *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  *(_QWORD *)(*((_QWORD *)this + 7) + 8 * (a2 >> 6)) &= ~(1 << a2);
  v2 = *((_QWORD *)this + 16) + ((uint64_t)(int)a2 << 6);
  if (*(_DWORD *)(v2 + 20) != *(_DWORD *)(v2 + 24))
  {
    v3 = this;
    do
    {
      v4 = *(uint64_t **)(v2 + 8);
      if (v4 == *(uint64_t **)v2)
        v5 = 20;
      else
        v5 = 16;
      v6 = *(unsigned int *)(v2 + v5);
      if ((_DWORD)v6)
      {
        v7 = 8 * v6;
        v8 = &v4[v6];
        while ((unint64_t)*v4 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v4;
          v7 -= 8;
          if (!v7)
          {
            v4 = v8;
            break;
          }
        }
      }
      v9 = *v4;
      this = (llvm::SwingSchedulerDAG::Circuits *)sub_1C477672C(v2, *v4);
      v10 = *(_QWORD *)(v2 + 8);
      if (v10 == *(_QWORD *)v2)
        v11 = 20;
      else
        v11 = 16;
      if (this != (llvm::SwingSchedulerDAG::Circuits *)(v10 + 8 * *(unsigned int *)(v2 + v11)))
      {
        *(_QWORD *)this = -2;
        ++*(_DWORD *)(v2 + 24);
      }
      v12 = *(unsigned int *)(v9 + 192);
      if (((*(_QWORD *)(*((_QWORD *)v3 + 7) + ((v12 >> 3) & 0x1FFFFFF8)) >> v12) & 1) != 0)
        this = (llvm::SwingSchedulerDAG::Circuits *)llvm::SwingSchedulerDAG::Circuits::unblock(v3, v12);
    }
    while (*(_DWORD *)(v2 + 20) != *(_DWORD *)(v2 + 24));
  }
  return this;
}

void sub_1C61F6390(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  _BYTE v8[32];

  sub_1C6189548((unsigned int *)(a1 + 8));
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 32);
  v2 = *(unsigned int *)(a1 + 64);
  if ((_DWORD)v2)
    bzero(*(void **)(a1 + 56), 8 * v2);
  v3 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(_QWORD *)(*(_QWORD *)a1 + 8) - **(_QWORD **)a1) >> 4);
  v4 = v8;
  v5 = v8;
  v6 = 4;
  v7 = 0;
  sub_1C5191690(a1 + 128, v3, (llvm::SmallPtrSetImplBase *)&v4);
  if (v5 != v4)
    free(v5);
  *(_DWORD *)(a1 + 1320) = 0;
}

void llvm::SwingSchedulerDAG::addConnectedNodes(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v18 = a2;
  v19 = a2;
  sub_1C518D044(a3, &v19);
  sub_1C518D044((_QWORD *)a4, &v18);
  v8 = *(unsigned int *)(a2 + 120);
  if ((_DWORD)v8)
  {
    v9 = 16 * v8;
    v10 = (_DWORD *)(*(_QWORD *)(a2 + 112) + 8);
    do
    {
      v11 = *((_QWORD *)v10 - 1);
      if ((~*(v10 - 2) & 6) != 0 || *v10 != 3)
      {
        v12 = v11 & 0xFFFFFFFFFFFFFFF8;
        if ((sub_1C61B75F0(*(_QWORD *)a4, *(_DWORD *)(a4 + 16), v11 & 0xFFFFFFFFFFFFFFF8, &v19) & 1) == 0)
          llvm::SwingSchedulerDAG::addConnectedNodes(a1, v12, a3, a4);
      }
      v10 += 4;
      v9 -= 16;
    }
    while (v9);
  }
  v13 = *(unsigned int *)(a2 + 40);
  if ((_DWORD)v13)
  {
    v14 = 16 * v13;
    v15 = (_DWORD *)(*(_QWORD *)(a2 + 32) + 8);
    do
    {
      v16 = *((_QWORD *)v15 - 1);
      if ((~*(v15 - 2) & 6) != 0 || *v15 != 3)
      {
        v17 = v16 & 0xFFFFFFFFFFFFFFF8;
        if ((sub_1C61B75F0(*(_QWORD *)a4, *(_DWORD *)(a4 + 16), v16 & 0xFFFFFFFFFFFFFFF8, &v19) & 1) == 0)
          llvm::SwingSchedulerDAG::addConnectedNodes(a1, v17, a3, a4);
      }
      v15 += 4;
      v14 -= 16;
    }
    while (v14);
  }
}

__n128 sub_1C61F657C(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  __n128 result;
  __int128 v6;

  v3 = sub_1C5193854(a1, a2);
  v4 = *(_QWORD *)a1 + 88 * *(unsigned int *)(a1 + 8);
  *(_QWORD *)v4 = 0;
  *(_QWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  sub_1C4DFE328(v4, v3);
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  v4 += 24;
  *(_QWORD *)(v4 + 16) = 0;
  sub_1C4DFE394((_QWORD *)v4, *(const void **)(v3 + 24), *(_QWORD *)(v3 + 32), (uint64_t)(*(_QWORD *)(v3 + 32) - *(_QWORD *)(v3 + 24)) >> 3);
  result = *(__n128 *)(v3 + 48);
  v6 = *(_OWORD *)(v3 + 64);
  *(_DWORD *)(v4 + 56) = *(_DWORD *)(v3 + 80);
  *(_OWORD *)(v4 + 40) = v6;
  *(__n128 *)(v4 + 24) = result;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void *sub_1C61F6608(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BYTE v11[24];
  uint64_t v12;
  uint64_t v13;

  if (a2 != a3)
  {
    v12 = v3;
    v13 = v4;
    v6 = a2;
    v7 = (uint64_t)result;
    v8 = (uint64_t)result + 72;
    do
    {
      result = sub_1C61F8DF8((uint64_t)v11, v7, v6);
      if (v11[16])
      {
        v9 = *v6;
        v10 = *(unsigned int *)(v7 + 80);
        if (v10 >= *(unsigned int *)(v7 + 84))
        {
          result = llvm::SmallVectorBase<unsigned int>::grow_pod(v8, v7 + 88, v10 + 1, 8);
          v10 = *(unsigned int *)(v7 + 80);
        }
        *(_QWORD *)(*(_QWORD *)(v7 + 72) + 8 * v10) = v9;
        ++*(_DWORD *)(v7 + 80);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

void *sub_1C61F66B4(uint64_t a1, uint64_t *a2)
{
  void *result;
  uint64_t v5;
  uint64_t v6;
  _BYTE v7[24];

  result = sub_1C61F8DF8((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    v5 = *a2;
    v6 = *(unsigned int *)(a1 + 80);
    if (v6 >= *(_DWORD *)(a1 + 84))
    {
      result = llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 72, a1 + 88, v6 + 1, 8);
      LODWORD(v6) = *(_DWORD *)(a1 + 80);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 80);
  }
  return result;
}

_QWORD *sub_1C61F6734(uint64_t a1, uint64_t *a2)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  result = (_QWORD *)sub_1C51944AC((_DWORD *)a1, *a2);
  if ((_DWORD)result)
  {
    result = *(_QWORD **)(a1 + 72);
    v5 = *(unsigned int *)(a1 + 80);
    v6 = &result[v5];
    if ((_DWORD)v5)
    {
      v7 = 8 * v5;
      while (*result != *a2)
      {
        ++result;
        v7 -= 8;
        if (!v7)
        {
          result = v6;
          break;
        }
      }
    }
    if (v6 != result + 1)
    {
      result = memmove(result, result + 1, (char *)v6 - (char *)(result + 1));
      LODWORD(v5) = *(_DWORD *)(a1 + 80);
    }
    *(_DWORD *)(a1 + 80) = v5 - 1;
  }
  return result;
}

uint64_t llvm::SMSchedule::insert(llvm::SMSchedule *this, llvm::SUnit *a2, int a3, int a4, int a5)
{
  int v5;
  int v9;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned __int16 *v17;
  BOOL v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int16 *v26;
  uint64_t *v27;
  _DWORD *v28;
  int v29;
  int v31;
  int v32;
  llvm::SUnit *v33;

  v33 = a2;
  if (a3 > a4)
    v5 = -1;
  else
    v5 = 1;
  v29 = v5;
  if (v5 + a4 == a3)
    return 0;
  v9 = a3;
  v11 = (char *)this + 80;
  while (1)
  {
    if (*((_BYTE *)this + 96))
    {
      v13 = *((_QWORD *)this + 13);
      *(_QWORD *)(v13 + 40) = 1;
      v14 = *(_QWORD *)(v13 + 24);
      if (v14)
        sub_1C61DCC98(v14);
    }
    else
    {
      v12 = *((unsigned int *)this + 66);
      if ((_DWORD)v12)
        bzero(*((void **)this + 32), 8 * v12);
    }
    v15 = *((_DWORD *)this + 13);
    v16 = (v9 - *((_DWORD *)this + 12)) % a5 + *((_DWORD *)this + 12);
    v31 = v16;
    if (v16 <= v15)
    {
      do
      {
        v19 = sub_1C61F81C8((uint64_t)this, &v31);
        v20 = v19[2];
        if (v19[3] != v20)
        {
          v21 = v19[5];
          v22 = (_QWORD *)(v20 + 8 * (v21 >> 9));
          v23 = (uint64_t *)(*v22 + 8 * (v21 & 0x1FF));
          v24 = *(_QWORD *)(v20 + (((v19[6] + v21) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v19[6] + v21) & 0x1FF);
          while (v23 != (uint64_t *)v24)
          {
            v25 = *v23;
            (*(void (**)(_QWORD))(**((_QWORD **)this + 8) + 104))(*((_QWORD *)this + 8));
            v26 = *(unsigned __int16 **)(*(_QWORD *)(v25 + 8) + 16);
            if (*v26 >= 0x14u)
              llvm::ResourceManager::reserveResources((uint64_t)v11, (uint64_t)v26);
            if ((uint64_t *)((char *)++v23 - *v22) == (uint64_t *)4096)
            {
              v27 = (uint64_t *)v22[1];
              ++v22;
              v23 = v27;
            }
          }
        }
        v16 += a5;
        v31 = v16;
      }
      while (v16 <= *((_DWORD *)this + 13));
    }
    (*(void (**)(_QWORD))(**((_QWORD **)this + 8) + 104))(*((_QWORD *)this + 8));
    v17 = *(unsigned __int16 **)(*((_QWORD *)a2 + 1) + 16);
    if (*v17 < 0x14u || llvm::ResourceManager::canReserveResources((uint64_t)v11, (uint64_t)v17))
      break;
    v18 = v9 == a4;
    v9 += v29;
    if (v18)
      return 0;
  }
  v32 = v9;
  v28 = sub_1C61F81C8((uint64_t)this, &v32);
  sub_1C48410F0((_QWORD *)v28 + 1, &v33);
  sub_1C519462C((uint64_t *)this + 3, (unint64_t)v33, (uint64_t)v33, v9);
  if (v9 > *((_DWORD *)this + 13))
    *((_DWORD *)this + 13) = v9;
  if (v9 < *((_DWORD *)this + 12))
    *((_DWORD *)this + 12) = v9;
  return 1;
}

void llvm::SMSchedule::finalizeSchedule(llvm::SMSchedule *this, llvm::SwingSchedulerDAG *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  int v18;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  _QWORD *v25;
  _QWORD *v26;
  __int128 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  _QWORD *v37;
  unint64_t **v38;
  unint64_t *v39;
  unint64_t *v40;
  uint64_t v41;
  unint64_t *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  int v54;

  v4 = *((_DWORD *)this + 12);
  LODWORD(v48) = v4;
  v5 = *((_DWORD *)this + 14);
  if (v5 < 1)
  {
    v18 = v5 + v4;
  }
  else
  {
    v6 = v4;
    do
    {
      v7 = (*((_DWORD *)this + 13) - v6) / v5;
      if (v7 >= 1)
      {
        v8 = 1;
        do
        {
          LODWORD(v51) = v4 + *((_DWORD *)this + 14) * v8;
          v9 = sub_1C61F81C8((uint64_t)this, (int *)&v51);
          v10 = v9[2];
          if (v9[3] != v10)
          {
            v11 = v9[6] + v9[5];
            v12 = (_QWORD *)(v10 + 8 * (v11 >> 9));
            v13 = *v12 + 8 * (v11 & 0x1FF);
            v14 = *(_QWORD *)(v10 + ((v9[5] >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v9[5] & 0x1FFLL);
            while (v13 != v14)
            {
              *(_QWORD *)&v51 = 0;
              v15 = v13;
              if (v13 == *v12)
                v15 = *(v12 - 1) + 4096;
              *(_QWORD *)&v51 = *(_QWORD *)(v15 - 8);
              v16 = sub_1C61F81C8((uint64_t)this, (int *)&v48);
              sub_1C61F6E60((_QWORD *)v16 + 1, &v51);
              if (v13 == *v12)
              {
                v17 = *--v12;
                v13 = v17 + 4096;
              }
              v13 -= 8;
            }
          }
          v36 = v8++ == v7;
        }
        while (!v36);
        v6 = *((_DWORD *)this + 12);
        v5 = *((_DWORD *)this + 14);
      }
      LODWORD(v48) = ++v4;
      v18 = v6 + v5;
    }
    while (v4 < v6 + v5);
  }
  if (v18 <= *((_DWORD *)this + 13))
  {
    do
      sub_1C61F7168((uint64_t)this, v18);
    while (v18++ < *((_DWORD *)this + 13));
  }
  v20 = *((_QWORD *)a2 + 6);
  v21 = *((_QWORD *)a2 + 7);
  while (v20 != v21)
  {
    llvm::SwingSchedulerDAG::applyInstrChange(a2, *(llvm::MachineInstr **)(v20 + 8), this);
    v20 += 272;
  }
  v22 = *((_DWORD *)this + 12);
  v54 = v22;
  v23 = *((_DWORD *)this + 14);
  if (v23 >= 1)
  {
    v24 = v23 + v22;
    do
    {
      v25 = sub_1C61F81C8((uint64_t)this, &v54);
      v26 = v25;
      v27 = 0uLL;
      v52 = 0u;
      v53 = 0u;
      v51 = 0u;
      v28 = v25[5];
      v29 = v25[2];
      v30 = v25[3];
      if (v30 == v29)
      {
        v49 = 0uLL;
        v50 = 0uLL;
        v30 = v29;
        v48 = 0uLL;
      }
      else
      {
        v31 = v28 >> 9;
        v32 = (_QWORD *)(v29 + 8 * (v28 >> 9));
        v33 = (_QWORD *)(*v32 + 8 * (v25[5] & 0x1FFLL));
        v34 = *(_QWORD *)(v29 + (((v25[6] + v28) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v25[6] + v28) & 0x1FF);
        if (v33 != (_QWORD *)v34)
        {
          do
          {
            *(_QWORD *)&v48 = 0;
            *(_QWORD *)&v48 = *v33;
            v35 = **(unsigned __int16 **)(*(_QWORD *)(v48 + 8) + 16);
            v36 = v35 == 69 || v35 == 0;
            if (v36)
            {
              sub_1C48410F0(&v51, &v48);
              v27 = 0uLL;
            }
            if ((_QWORD *)((char *)++v33 - *v32) == (_QWORD *)4096)
            {
              v37 = (_QWORD *)v32[1];
              ++v32;
              v33 = v37;
            }
          }
          while (v33 != (_QWORD *)v34);
          v28 = v26[5];
          v29 = v26[2];
          v30 = v26[3];
          v31 = v28 >> 9;
        }
        v49 = v27;
        v50 = v27;
        v48 = v27;
        if (v30 == v29)
        {
          v29 = v30;
        }
        else
        {
          v38 = (unint64_t **)(v29 + 8 * v31);
          v39 = *v38;
          v40 = &(*v38)[v28 & 0x1FF];
          v41 = *(_QWORD *)(v29 + (((v26[6] + v28) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v26[6] + v28) & 0x1FF);
          if (v40 != (unint64_t *)v41)
          {
            do
            {
              if (**(_WORD **)(*(_QWORD *)(*v40 + 8) + 16) && **(_WORD **)(*(_QWORD *)(*v40 + 8) + 16) != 69)
              {
                llvm::SMSchedule::orderDependence((uint64_t)this, (uint64_t)a2, *v40, &v48);
                v39 = *v38;
              }
              if ((char *)++v40 - (char *)v39 == 4096)
              {
                v42 = v38[1];
                ++v38;
                v39 = v42;
                v40 = v42;
              }
            }
            while (v40 != (unint64_t *)v41);
            v29 = v26[2];
            v30 = v26[3];
            v28 = v26[5];
          }
        }
      }
      v43 = v26[1];
      v44 = v52;
      *(_OWORD *)(v26 + 1) = v51;
      *(_QWORD *)&v51 = v43;
      *((_QWORD *)&v51 + 1) = v29;
      v45 = v26[4];
      *(_OWORD *)(v26 + 3) = v44;
      *(_QWORD *)&v52 = v30;
      *((_QWORD *)&v52 + 1) = v45;
      v46 = v26[6];
      v47 = *((_QWORD *)&v53 + 1);
      v26[5] = v53;
      v26[6] = v47;
      *(_QWORD *)&v53 = v28;
      *((_QWORD *)&v53 + 1) = v46;
      sub_1C518FD8C((uint64_t)(v26 + 1), &v48);
      llvm::SwingSchedulerDAG::fixupRegisterOverlaps((uint64_t)a2, v26 + 1);
      sub_1C484143C((uint64_t)&v48);
      sub_1C484143C((uint64_t)&v51);
      v54 = ++v22;
    }
    while (v22 < v24);
  }
}

uint64_t llvm::SwingSchedulerDAG::findDefInLoop(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t VRegDef;
  int v5;
  char v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  int v15;
  _BYTE v16[64];

  v12 = v16;
  v13 = v16;
  v14 = 8;
  v15 = 0;
  v3 = *(_QWORD *)(a1 + 40);
LABEL_2:
  VRegDef = llvm::MachineRegisterInfo::getVRegDef(v3, a2);
LABEL_3:
  while (1)
  {
    v5 = **(unsigned __int16 **)(VRegDef + 16);
    if (v5 != 69 && v5 != 0)
      break;
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v12, VRegDef);
    if (!v7)
      break;
    v8 = *(_DWORD *)(VRegDef + 40);
    if (v8 >= 2)
    {
      v9 = *(_QWORD *)(VRegDef + 32);
      v10 = 1;
      while (*(_QWORD *)(v9 + 32 * (v10 + 1) + 16) != *(_QWORD *)(a1 + 920))
      {
        v10 += 2;
        if (v10 >= v8)
          goto LABEL_3;
      }
      v3 = *(_QWORD *)(a1 + 40);
      a2 = *(_DWORD *)(v9 + 32 * v10 + 4);
      goto LABEL_2;
    }
  }
  if (v13 != v12)
    free(v13);
  return VRegDef;
}

void sub_1C61F6E60(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = a1[4];
  if (!v4)
  {
    sub_1C61F9138((uint64_t)a1);
    v4 = a1[4];
  }
  v5 = a1[1];
  v6 = (_QWORD *)(v5 + 8 * (v4 >> 9));
  if (a1[2] == v5)
    v7 = 0;
  else
    v7 = *v6 + 8 * (v4 & 0x1FF);
  if (v7 == *v6)
    v7 = *(v6 - 1) + 4096;
  *(_QWORD *)(v7 - 8) = *a2;
  v8 = a1[5] + 1;
  a1[4] = v4 - 1;
  a1[5] = v8;
}

BOOL llvm::SMSchedule::isLoopCarried(llvm::SMSchedule *this, llvm::SwingSchedulerDAG *a2, llvm::MachineInstr *a3)
{
  int v3;
  _BOOL8 result;
  uint64_t *v8;
  int v9;
  unint64_t v10;
  _QWORD *v11;
  char *v12;
  char *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  _QWORD *v20;
  unint64_t v21;
  BOOL v22;
  _QWORD *v23;
  char *v24;
  unint64_t v25;
  BOOL v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  unsigned int *v30;
  int v31;
  uint64_t VRegDef;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  char *v36;
  unint64_t v37;
  BOOL v38;
  _QWORD *v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  char *v44;
  unint64_t v45;
  BOOL v46;
  _QWORD *v47;
  int v48;
  uint64_t v50;
  llvm::MachineInstr *v51;

  v3 = **((unsigned __int16 **)a3 + 2);
  if (v3 != 69 && v3 != 0)
    return 0;
  v8 = (uint64_t *)((char *)a2 + 952);
  v50 = 0;
  v51 = a3;
  v9 = sub_1C61252B8((uint64_t *)a2 + 119, &v51, &v50);
  v10 = 0;
  if (v9)
    v10 = *(_QWORD *)(v50 + 8);
  v12 = (char *)this + 32;
  v11 = (_QWORD *)*((_QWORD *)this + 4);
  if (!v11)
    goto LABEL_10;
  v20 = (_QWORD *)*((_QWORD *)this + 4);
  v13 = (char *)this + 32;
  do
  {
    v21 = v20[4];
    v22 = v21 >= v10;
    if (v21 >= v10)
      v23 = v20;
    else
      v23 = v20 + 1;
    if (v22)
      v13 = (char *)v20;
    v20 = (_QWORD *)*v23;
  }
  while (*v23);
  if (v13 == v12 || *((_QWORD *)v13 + 4) > v10)
LABEL_10:
    v13 = (char *)this + 32;
  v14 = *((_DWORD *)this + 12);
  v15 = *((_DWORD *)this + 14);
  if (!v11)
    goto LABEL_12;
  v24 = (char *)this + 32;
  do
  {
    v25 = v11[4];
    v26 = v25 >= v10;
    if (v25 >= v10)
      v27 = v11;
    else
      v27 = v11 + 1;
    if (v26)
      v24 = (char *)v11;
    v11 = (_QWORD *)*v27;
  }
  while (*v27);
  if (v24 == v12 || *((_QWORD *)v24 + 4) > v10)
LABEL_12:
    v16 = -1;
  else
    v16 = (*((_DWORD *)v24 + 10) - v14) / v15;
  v17 = *((_DWORD *)a3 + 10);
  v18 = v17 - 1;
  if (v17 == 1)
  {
    v19 = 0;
  }
  else
  {
    v28 = 0;
    v19 = 0;
    v29 = *((_QWORD *)a3 + 4);
    v30 = (unsigned int *)(v29 + 36);
    do
    {
      if (*(_QWORD *)(v29 + 32 * (v28 + 2) + 16) == *((_QWORD *)a3 + 3))
        v19 = *v30;
      v28 += 2;
      v30 += 16;
    }
    while (v18 != v28);
  }
  v31 = *((_DWORD *)v13 + 10);
  VRegDef = llvm::MachineRegisterInfo::getVRegDef(*((_QWORD *)this + 9), v19);
  v50 = 0;
  v51 = (llvm::MachineInstr *)VRegDef;
  if ((sub_1C61252B8(v8, &v51, &v50) & 1) == 0)
    return 1;
  v33 = *(_QWORD *)(v50 + 8);
  if (!v33)
    return 1;
  result = 1;
  if (**(_WORD **)(*(_QWORD *)(v33 + 8) + 16) && **(_WORD **)(*(_QWORD *)(v33 + 8) + 16) != 69)
  {
    v34 = *(_QWORD **)v12;
    if (!*(_QWORD *)v12)
      goto LABEL_56;
    v35 = *(_QWORD **)v12;
    v36 = (char *)this + 32;
    do
    {
      v37 = v35[4];
      v38 = v37 >= v33;
      if (v37 >= v33)
        v39 = v35;
      else
        v39 = v35 + 1;
      if (v38)
        v36 = (char *)v35;
      v35 = (_QWORD *)*v39;
    }
    while (*v39);
    if (v36 == v12 || *((_QWORD *)v36 + 4) > v33)
LABEL_56:
      v36 = (char *)this + 32;
    v40 = *((_DWORD *)v36 + 10);
    v41 = *((_DWORD *)this + 12);
    v42 = *((_DWORD *)this + 14);
    v43 = (v40 - v41) % v42;
    if (!v34)
      goto LABEL_68;
    v44 = (char *)this + 32;
    do
    {
      v45 = v34[4];
      v46 = v45 >= v33;
      if (v45 >= v33)
        v47 = v34;
      else
        v47 = v34 + 1;
      if (v46)
        v44 = (char *)v34;
      v34 = (_QWORD *)*v47;
    }
    while (*v47);
    if (v44 != v12 && *((_QWORD *)v44 + 4) <= v33)
      v48 = (*((_DWORD *)v44 + 10) - v41) / v42;
    else
LABEL_68:
      v48 = -1;
    return v43 > (v31 - v14) % v15 || v48 <= v16;
  }
  return result;
}

int32x2_t sub_1C61F7168(uint64_t a1, int a2)
{
  int32x2_t result;
  _DWORD *v4;
  _DWORD *v5;

  v5 = 0;
  if (sub_1C61F8240(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, &v5))
  {
    v4 = v5;
    sub_1C484143C((uint64_t)(v5 + 2));
    *v4 = 0x80000000;
    result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

llvm::raw_ostream *llvm::NodeSet::print(llvm::NodeSet *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm::raw_ostream *v9;
  llvm::raw_ostream *v10;
  llvm::raw_ostream *v11;
  llvm::raw_ostream *v12;
  llvm::raw_ostream *v13;
  uint64_t *v14;
  uint64_t *v15;
  llvm::raw_ostream *v16;
  llvm::raw_ostream *v17;
  llvm::raw_ostream *v18;
  uint64_t v19;

  v4 = sub_1C4816AD8(a2, "Num nodes ");
  v5 = llvm::raw_ostream::operator<<(v4, ((*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) >> 3));
  v6 = sub_1C4816AD8(v5, " rec ");
  v7 = llvm::raw_ostream::operator<<(v6, *((unsigned int *)this + 13));
  v8 = sub_1C4816AD8(v7, " mov ");
  v9 = llvm::raw_ostream::operator<<(v8, *((int *)this + 14));
  v10 = sub_1C4816AD8(v9, " depth ");
  v11 = llvm::raw_ostream::operator<<(v10, *((unsigned int *)this + 15));
  v12 = sub_1C4816AD8(v11, " col ");
  v13 = llvm::raw_ostream::operator<<(v12, *((unsigned int *)this + 16));
  sub_1C4816AD8(v13, "\n");
  v14 = (uint64_t *)*((_QWORD *)this + 3);
  v15 = (uint64_t *)*((_QWORD *)this + 4);
  while (v14 != v15)
  {
    v16 = sub_1C4816AD8(a2, "   SU(");
    v17 = llvm::raw_ostream::operator<<(v16, *(unsigned int *)(*v14 + 192));
    v18 = sub_1C4816AD8(v17, ") ");
    v19 = *v14++;
    llvm::MachineInstr::print(*(llvm::MachineInstr **)(v19 + 8), v18, 1, 0, 0, 1, 0);
  }
  return sub_1C4816AD8(a2, "\n");
}

llvm::raw_ostream *llvm::SMSchedule::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  int v2;
  uint64_t v4;
  _QWORD *v5;
  int v6;
  int64_t i;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int *v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  llvm::raw_ostream *v19;
  llvm::raw_ostream *v20;
  llvm::raw_ostream *v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t v24;
  BOOL v25;
  _QWORD *v26;
  int v27;
  llvm::raw_ostream *v28;
  llvm::raw_ostream *v29;
  llvm::raw_ostream *v30;
  unint64_t *v31;
  int v32;
  unsigned int v33;

  v2 = *((_DWORD *)this + 14);
  if (v2 >= 1)
  {
    v4 = (uint64_t)this;
    v5 = (_QWORD *)((char *)this + 32);
    v6 = *((_DWORD *)this + 12);
    for (i = v6; i < v6 + v2; ++i)
    {
      v8 = *(_QWORD *)v4;
      v9 = *(_DWORD *)(v4 + 16);
      if (v9)
      {
        v10 = (v9 - 1) & (37 * i);
        v11 = (int *)(v8 + 56 * v10);
        v12 = *v11;
        if (*v11 == (_DWORD)i)
          goto LABEL_5;
        v32 = 1;
        while (v12 != 0x7FFFFFFF)
        {
          v33 = v10 + v32++;
          v10 = v33 & (v9 - 1);
          v11 = (int *)(v8 + 56 * v10);
          v12 = *v11;
          if (*v11 == (_DWORD)i)
            goto LABEL_5;
        }
      }
      v11 = (int *)(v8 + 56 * v9);
LABEL_5:
      v13 = *((_QWORD *)v11 + 2);
      if (*((_QWORD *)v11 + 3) != v13)
      {
        v14 = *((_QWORD *)v11 + 5);
        v15 = (_QWORD *)(v13 + 8 * (v14 >> 9));
        v16 = (unint64_t *)(*v15 + 8 * (v14 & 0x1FF));
        v17 = *(_QWORD *)(v13 + (((*((_QWORD *)v11 + 6) + v14) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*((_QWORD *)v11 + 6) + v14) & 0x1FF);
        if (v16 != (unint64_t *)v17)
        {
          do
          {
            v18 = *v16;
            v19 = sub_1C4816AD8(a2, "cycle ");
            v20 = llvm::raw_ostream::operator<<(v19, i);
            v21 = sub_1C4816AD8(v20, " (");
            v22 = (_QWORD *)*v5;
            if (!*v5)
              goto LABEL_18;
            v23 = v5;
            do
            {
              v24 = v22[4];
              v25 = v24 >= v18;
              if (v24 >= v18)
                v26 = v22;
              else
                v26 = v22 + 1;
              if (v25)
                v23 = v22;
              v22 = (_QWORD *)*v26;
            }
            while (*v26);
            if (v23 != v5 && v23[4] <= v18)
              v27 = (*((_DWORD *)v23 + 10) - *(_DWORD *)(v4 + 48)) / *(_DWORD *)(v4 + 56);
            else
LABEL_18:
              v27 = -1;
            v28 = llvm::raw_ostream::operator<<(v21, v27);
            sub_1C4816AD8(v28, ") ");
            v29 = sub_1C4816AD8(a2, "(");
            v30 = llvm::raw_ostream::operator<<(v29, *(unsigned int *)(v18 + 192));
            sub_1C4816AD8(v30, ") ");
            llvm::MachineInstr::print(*(llvm::MachineInstr **)(v18 + 8), a2, 1, 0, 0, 1, 0);
            this = sub_1C4816AD8(a2, "\n");
            if ((unint64_t *)((char *)++v16 - *v15) == (unint64_t *)4096)
            {
              v31 = (unint64_t *)v15[1];
              ++v15;
              v16 = v31;
            }
          }
          while (v16 != (unint64_t *)v17);
          v6 = *(_DWORD *)(v4 + 48);
          v2 = *(_DWORD *)(v4 + 56);
        }
      }
    }
  }
  return this;
}

llvm::raw_ostream *llvm::SMSchedule::dump(llvm::SMSchedule *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return llvm::SMSchedule::print(this, v2);
}

llvm::raw_ostream *llvm::NodeSet::dump(llvm::NodeSet *this)
{
  llvm *v2;

  v2 = llvm::dbgs(this);
  return llvm::NodeSet::print(this, v2);
}

void llvm::ResourceManager::initProcResourceVectors(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;

  sub_1C6154790((uint64_t)a3, *(unsigned int *)(a2 + 48));
  v5 = *(unsigned int *)(a2 + 48);
  if (v5 >= 2)
  {
    v6 = 0;
    v7 = *(_QWORD *)(a2 + 32);
    v8 = v5 - 1;
    v9 = (_QWORD *)(*a3 + 8);
    v10 = (_QWORD *)(v7 + 56);
    do
    {
      if (!*v10)
        *v9 = 1 << v6++;
      ++v9;
      v10 += 4;
      --v8;
    }
    while (v8);
    v11 = *a3;
    for (i = 1; i != v5; ++i)
    {
      v13 = v7 + 32 * i;
      v14 = *(unsigned int **)(v13 + 24);
      if (v14)
      {
        v15 = 1 << v6;
        *(_QWORD *)(v11 + 8 * i) = 1 << v6;
        v16 = *(unsigned int *)(v13 + 8);
        if ((_DWORD)v16)
        {
          do
          {
            v17 = *v14++;
            v15 |= *(_QWORD *)(v11 + 8 * v17);
            *(_QWORD *)(v11 + 8 * i) = v15;
            --v16;
          }
          while (v16);
        }
        ++v6;
      }
    }
  }
}

BOOL llvm::ResourceManager::canReserveResources(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _WORD *i;

  if (*(_BYTE *)(a1 + 16))
    return llvm::DFAPacketizer::canReserveResources(*(_QWORD *)(a1 + 24), a2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(v3 + 40);
  if ((~*(unsigned __int16 *)(v4 + 24 * *(unsigned __int16 *)(a2 + 6) + 8) & 0x1FFF) == 0)
    return 1;
  v5 = v4 + 24 * *(unsigned __int16 *)(a2 + 6);
  if (!*(_WORD *)(v5 + 12))
    return 1;
  v6 = 4 * *(unsigned __int16 *)(v5 + 12);
  for (i = (_WORD *)(*(_QWORD *)(*(_QWORD *)a1 + 136) + 4 * *(unsigned __int16 *)(v5 + 10) + 2);
        !*i
     || *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8 * (unsigned __int16)*(i - 1)) < (unint64_t)*(unsigned int *)(*(_QWORD *)(v3 + 32) + 32 * (unsigned __int16)*(i - 1) + 8);
        i += 2)
  {
    v6 -= 4;
    if (!v6)
      return 1;
  }
  return 0;
}

uint64_t llvm::ResourceManager::reserveResources(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _WORD *v5;

  if (*(_BYTE *)(result + 16))
    return llvm::DFAPacketizer::reserveResources(*(_QWORD *)(result + 24), a2);
  v2 = *(_QWORD *)(*(_QWORD *)(result + 8) + 40);
  if ((~*(unsigned __int16 *)(v2 + 24 * *(unsigned __int16 *)(a2 + 6) + 8) & 0x1FFF) != 0)
  {
    v3 = v2 + 24 * *(unsigned __int16 *)(a2 + 6);
    if (*(_WORD *)(v3 + 12))
    {
      v4 = 4 * *(unsigned __int16 *)(v3 + 12);
      v5 = (_WORD *)(*(_QWORD *)(*(_QWORD *)result + 136) + 4 * *(unsigned __int16 *)(v3 + 10) + 2);
      do
      {
        if (*v5)
          ++*(_QWORD *)(*(_QWORD *)(result + 176) + 8 * (unsigned __int16)*(v5 - 1));
        v5 += 2;
        v4 -= 4;
      }
      while (v4);
    }
  }
  return result;
}

void sub_1C61F7770(uint64_t *a1)
{
  sub_1C61F8180(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61F7794(uint64_t a1)
{
  sub_1C61F7A34(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61F77BC()
{
  JUMPOUT(0x1CAA32FC0);
}

uint64_t llvm::callDefaultCtor<llvm::MachinePipeliner>()
{
  uint64_t v0;

  v0 = operator new();
  return sub_1C61F77F8(v0);
}

uint64_t sub_1C61F77F8(uint64_t a1)
{
  _QWORD *v2;
  llvm::PassRegistry *v3;
  unint64_t v4;
  unint64_t PassRegistry;
  _QWORD *v7;
  _QWORD v8[2];

  v2 = (_QWORD *)sub_1C4776848(a1, (uint64_t)&llvm::MachinePipeliner::ID);
  *v2 = &off_1E8145AF0;
  v2[36] = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  llvm::RegisterClassInfo::RegisterClassInfo((llvm::RegisterClassInfo *)(v2 + 37));
  *(_BYTE *)(a1 + 536) = 0;
  *(_OWORD *)(a1 + 540) = 0u;
  *(_DWORD *)(a1 + 556) = 0;
  *(_QWORD *)(a1 + 560) = a1 + 576;
  *(_QWORD *)(a1 + 568) = 0x400000000;
  *(_QWORD *)(a1 + 712) = 0;
  *(_QWORD *)(a1 + 704) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  v4 = atomic_load(&qword_1ED7FB358);
  if (v4 != -1)
  {
    v8[0] = sub_1C51861B4;
    v8[1] = &PassRegistry;
    v7 = v8;
    std::__call_once(&qword_1ED7FB358, &v7, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return a1;
}

uint64_t sub_1C61F78D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  llvm::ScheduleDAGInstrs *v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v16;
  uint64_t v17;
  _QWORD *v18;

  v12 = llvm::ScheduleDAGInstrs::ScheduleDAGInstrs((llvm::ScheduleDAGInstrs *)a1, *(const llvm::TargetSubtargetInfo ***)(a2 + 248), *(const llvm::MachineLoopInfo **)(a2 + 264), 0);
  *(_QWORD *)v12 = &off_1E8145BB0;
  *((_QWORD *)v12 + 329) = a2;
  *((_QWORD *)v12 + 330) = 0;
  *((_BYTE *)v12 + 2648) = 0;
  *((_QWORD *)v12 + 332) = a3;
  *((_QWORD *)v12 + 333) = a4;
  *((_QWORD *)v12 + 334) = a5;
  *(_DWORD *)(a1 + 2680) = a6;
  llvm::ScheduleDAGTopologicalSort::ScheduleDAGTopologicalSort((uint64_t)v12 + 2688, a1 + 48, a1 + 344);
  *(_OWORD *)(a1 + 3132) = 0u;
  *(_OWORD *)(a1 + 3120) = 0u;
  *(_OWORD *)(a1 + 3104) = 0u;
  *(_OWORD *)(a1 + 3152) = 0u;
  *(_OWORD *)(a1 + 3168) = 0u;
  *(_OWORD *)(a1 + 3180) = 0u;
  *(_OWORD *)(a1 + 3200) = 0u;
  *(_DWORD *)(a1 + 3216) = 0;
  *(_QWORD *)(a1 + 3224) = 0;
  *(_QWORD *)(a1 + 3240) = 0;
  *(_QWORD *)(a1 + 3232) = 0;
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)(a2 + 248) + 16) + 336))(*(_QWORD *)(*(_QWORD *)(a2 + 248) + 16), a1 + 3224);
  if (byte_1ED82F730)
  {
    v13 = (_QWORD *)operator new();
    *v13 = &off_1E8145C40;
    v18 = v13;
    v14 = *(_QWORD **)(a1 + 3232);
    if ((unint64_t)v14 >= *(_QWORD *)(a1 + 3240))
    {
      v16 = sub_1C483904C((char **)(a1 + 3224), (uint64_t *)&v18);
      v17 = (uint64_t)v18;
      *(_QWORD *)(a1 + 3232) = v16;
      v18 = 0;
      if (v17)
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 16))(v17);
    }
    else
    {
      *v14 = v13;
      *(_QWORD *)(a1 + 3232) = v14 + 1;
    }
  }
  return a1;
}

void sub_1C61F7A34(uint64_t a1)
{
  void *v2;
  void **v3;

  *(_QWORD *)a1 = &off_1E8145BB0;
  v3 = (void **)(a1 + 3224);
  sub_1C50AF7B4(&v3);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 3200), 8);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 3176), 8);
  sub_1C6176BF8((_QWORD *)(a1 + 3128));
  v2 = *(void **)(a1 + 3104);
  if (v2)
  {
    *(_QWORD *)(a1 + 3112) = v2;
    operator delete(v2);
  }
  sub_1C5190E2C((_QWORD *)(a1 + 2688));
  sub_1C50AF658(a1);
}

_QWORD *sub_1C61F7AB4(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v2 = a1[53];
  a1[53] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (_QWORD *)a1[47];
  if (v3 != a1 + 49)
    free(v3);
  sub_1C484143C((uint64_t)(a1 + 41));
  sub_1C484143C((uint64_t)(a1 + 35));
  MEMORY[0x1CAA32FB4](a1[32], 8);
  MEMORY[0x1CAA32FB4](a1[29], 8);
  MEMORY[0x1CAA32FB4](a1[26], 8);
  sub_1C61F7B84((uint64_t)(a1 + 23));
  MEMORY[0x1CAA32FB4](a1[23], 8);
  sub_1C61F7B84((uint64_t)(a1 + 20));
  MEMORY[0x1CAA32FB4](a1[20], 8);
  v4 = (_QWORD *)a1[14];
  if (v4 != a1 + 16)
    free(v4);
  v5 = (_QWORD *)a1[8];
  if (v5 != a1 + 10)
    free(v5);
  return a1;
}

void sub_1C61F7B84(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v1 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v1)
  {
    v2 = 80 * v1;
    v3 = *(_QWORD *)a1 + 24;
    do
    {
      if ((*(_QWORD *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4)
          free(v4);
      }
      v3 += 80;
      v2 -= 80;
    }
    while (v2);
  }
}

uint64_t sub_1C61F7BE8(uint64_t a1)
{
  uint64_t v2;

  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 104), 8);
  sub_1C47655E8(a1 + 80, *(_QWORD **)(a1 + 88));
  v2 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return a1;
}

_QWORD *sub_1C61F7C38(_QWORD *a1)
{
  void *v2;

  MEMORY[0x1CAA32FB4](a1[7], 8);
  MEMORY[0x1CAA32FB4](a1[4], 8);
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_1C61F7C80(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((unsigned int *)a1 + 4);
  v3 = *a1;
  if ((_DWORD)v2)
  {
    v4 = 56 * v2;
    v5 = v3 + 8;
    do
    {
      if ((*(_DWORD *)(v5 - 8) - 0x7FFFFFFF) >= 2)
        v5 = sub_1C484143C(v5);
      v5 += 56;
      v4 -= 56;
    }
    while (v4);
    v3 = *a1;
  }
  MEMORY[0x1CAA32FB4](v3, 8);
  return a1;
}

uint64_t sub_1C61F7CF0(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 24);
  sub_1C5191028(&v3);
  MEMORY[0x1CAA32FB4](*(_QWORD *)a1, 8);
  return a1;
}

uint64_t sub_1C61F7D34(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;

  v4 = a2[20];
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v4;
  *(_BYTE *)(a1 + 16) = (*(uint64_t (**)(_QWORD *))(*a2 + 344))(a2);
  *(_QWORD *)(a1 + 32) = a1 + 48;
  *(_QWORD *)(a1 + 24) = 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 48);
  *(_QWORD *)(a1 + 40) = 0x1000000000;
  sub_1C4765AA4((char *)(a1 + 32), v5, 0);
  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 48);
  *(_QWORD *)(a1 + 176) = a1 + 192;
  *(_QWORD *)(a1 + 184) = 0x1000000000;
  v7 = sub_1C4765AA4((char *)(a1 + 176), v6, 0);
  if (*(_BYTE *)(a1 + 16))
  {
    v8 = (*(uint64_t (**)(_QWORD *))(*a2 + 104))(a2);
    v7 = (char *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 1056))(v8, a2);
    v9 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v7;
    if (v9)
    {
      sub_1C61DCC08(v9 + 8);
      v7 = (char *)MEMORY[0x1CAA32FC0](v9, 0x1070C405C112D20);
    }
  }
  llvm::ResourceManager::initProcResourceVectors((uint64_t)v7, *(_QWORD *)(a1 + 8), (_QWORD *)(a1 + 32));
  return a1;
}

_QWORD *sub_1C61F7E34(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)a1[22];
  if (v2 != a1 + 24)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  v4 = a1[3];
  a1[3] = 0;
  if (v4)
  {
    sub_1C61DCC08(v4 + 8);
    MEMORY[0x1CAA32FC0](v4, 0x1070C405C112D20);
  }
  return a1;
}

void sub_1C61F7EAC(uint64_t a1, unint64_t a2, const llvm::SmallPtrSetImplBase *a3)
{
  const void **v6;
  const void **v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v6 = (const void **)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 64, &v14);
  v7 = v6;
  if (a2)
  {
    v8 = a2;
    do
    {
      v6 = (const void **)((char *)llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)v6, v6 + 4, a3)+ 64);
      --v8;
    }
    while (v8);
  }
  v9 = *(char **)a1;
  v10 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v10)
  {
    v11 = v10 << 6;
    do
    {
      v12 = *(void **)&v9[v11 - 56];
      if (v12 != *(void **)&v9[v11 - 64])
        free(v12);
      v11 -= 64;
    }
    while (v11);
    v9 = *(char **)a1;
  }
  v13 = v14;
  if (v9 != (char *)(a1 + 16))
    free(v9);
  *(_QWORD *)a1 = v7;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t sub_1C61F7F70(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;

  v2 = *(_QWORD *)(a1 + 1312);
  if (v2)
  {
    v3 = *(void **)v2;
    if (*(_QWORD *)v2)
    {
      *(_QWORD *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x1CAA32FC0](v2, 0x10C402FEFCB83);
  }
  sub_1C5191A4C((char **)(a1 + 784));
  sub_1C61F7FEC((char **)(a1 + 128));
  v4 = *(void **)(a1 + 56);
  if (v4 != (void *)(a1 + 72))
    free(v4);
  sub_1C6176BF8((_QWORD *)(a1 + 8));
  return a1;
}

char **sub_1C61F7FEC(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = v3 << 6;
    do
    {
      v5 = *(void **)&v2[v4 - 56];
      if (v5 != *(void **)&v2[v4 - 64])
        free(v5);
      v4 -= 64;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

_QWORD *sub_1C61F8058(_QWORD *a1, unsigned int a2)
{
  uint64_t v3;
  _QWORD *result;
  int v5;
  _QWORD *v6;

  if (a2 <= 8)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    v3 = a2;
    result = operator new(8 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      v6 = &result[v3];
      goto LABEL_6;
    }
  }
  result = a1 + 1;
  v6 = a1 + 9;
  do
LABEL_6:
    *result++ = -4096;
  while (result != v6);
  return result;
}

uint64_t sub_1C61F80D8(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  v1 = result;
  v2 = *(_DWORD *)(result + 8);
  if (v2 || *(_DWORD *)(result + 12))
  {
    v3 = *(unsigned int *)(result + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
      return sub_1C5191AC4(result);
    if (!(_DWORD)v3)
    {
LABEL_12:
      *(_QWORD *)(v1 + 8) = 0;
      return result;
    }
    v4 = 56 * v3;
    result = *(_QWORD *)result + 8;
    while (1)
    {
      v5 = *(_DWORD *)(result - 8);
      if (v5 == 0x80000000)
        goto LABEL_10;
      if (v5 != 0x7FFFFFFF)
        break;
LABEL_11:
      result += 56;
      v4 -= 56;
      if (!v4)
        goto LABEL_12;
    }
    result = sub_1C484143C(result);
LABEL_10:
    *(_DWORD *)(result - 8) = 0x7FFFFFFF;
    goto LABEL_11;
  }
  return result;
}

void sub_1C61F8180(uint64_t *a1)
{
  uint64_t *v2;

  *a1 = (uint64_t)&off_1E8145AF0;
  v2 = (uint64_t *)a1[70];
  if (v2 != a1 + 72)
    free(v2);
  sub_1C61D92E0(a1 + 37);
  sub_1C4926674((llvm::Pass *)a1);
}

_DWORD *sub_1C61F81C8(uint64_t a1, int *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C61F8240(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61F82E0(a1, a2, v7);
    *v5 = *a2;
    *(_OWORD *)(v5 + 10) = 0u;
    *(_OWORD *)(v5 + 6) = 0u;
    *(_OWORD *)(v5 + 2) = 0u;
  }
  return v5;
}

uint64_t sub_1C61F8240(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  int v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  _DWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  if (a2)
  {
    v4 = a2 - 1;
    v5 = (37 * a3) & (a2 - 1);
    v6 = (_DWORD *)(a1 + 56 * v5);
    v7 = *v6;
    if (*v6 == a3)
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      while (v7 != 0x7FFFFFFF)
      {
        if (v10)
          v12 = 0;
        else
          v12 = v7 == 0x80000000;
        if (v12)
          v10 = v6;
        v13 = v5 + v11++;
        v5 = v13 & v4;
        v6 = (_DWORD *)(a1 + 56 * (v13 & v4));
        v7 = *v6;
        v8 = 1;
        if (*v6 == a3)
          goto LABEL_4;
      }
      v8 = 0;
      if (v10)
        v6 = v10;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1C61F82E0(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C5191C10(a1, v6);
  v8 = 0;
  sub_1C61F8240(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != 0x7FFFFFFF)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61F8394(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  _DWORD *v11;

  v4 = a2;
  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_DWORD **)result;
    v8 = 56 * v6;
    do
    {
      *v7 = 0x7FFFFFFF;
      v7 += 14;
      v8 -= 56;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_DWORD *)v4;
      if ((*(_DWORD *)v4 - 0x7FFFFFFF) >= 2)
      {
        v11 = 0;
        sub_1C61F8240(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
        v10 = v11;
        *v11 = *(_DWORD *)v4;
        v10[1] = *(_QWORD *)(v4 + 8);
        v10[2] = *(_QWORD *)(v4 + 16);
        v10[3] = *(_QWORD *)(v4 + 24);
        v10[4] = *(_QWORD *)(v4 + 32);
        *(_OWORD *)(v4 + 24) = 0u;
        *(_OWORD *)(v4 + 8) = 0u;
        v10[5] = *(_QWORD *)(v4 + 40);
        v10[6] = *(_QWORD *)(v4 + 48);
        *(_QWORD *)(v4 + 40) = 0;
        *(_QWORD *)(v4 + 48) = 0;
        ++*(_DWORD *)(v5 + 8);
        result = sub_1C484143C(v4 + 8);
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
  return result;
}

llvm::cl::Option *sub_1C61F8494(llvm::cl::Option *a1, char *a2, __n128 *a3, _WORD *a4, _DWORD **a5)
{
  uint64_t v10;

  v10 = sub_1C47AD050((uint64_t)a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(_QWORD *)(v10 + 136) = &off_1E7FA9DC8;
  *(_QWORD *)(v10 + 144) = 0;
  *(_QWORD *)v10 = &unk_1E819E418;
  *(_QWORD *)(v10 + 152) = &unk_1E819E230;
  *(_QWORD *)(v10 + 160) = &off_1E7FA9D80;
  *(_QWORD *)(v10 + 184) = v10 + 160;
  sub_1C5191CD4(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

void sub_1C61F8540(_WORD *a1, char **a2)
{
  uint64_t v4;
  char *v5;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7FB8A0, 0, 0);
  byte_1ED7FB920 = 0;
  qword_1ED7FB928 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7FB930 = 0;
  qword_1ED7FB8A0 = (uint64_t)&unk_1E819E898;
  qword_1ED7FB938 = (uint64_t)&off_1E819E9A0;
  qword_1ED7FB940 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7FB958 = (uint64_t)&qword_1ED7FB940;
  llvm::cl::Option::setArgStr(v4, "pipeliner-show-mask", 0x13uLL);
  word_1ED7FB8AA = (32 * (*a1 & 3)) | word_1ED7FB8AA & 0xFF9F;
  v5 = *a2;
  byte_1ED7FB920 = **a2;
  byte_1ED7FB931 = 1;
  byte_1ED7FB930 = *v5;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FB8A0);
}

void sub_1C61F8614(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1C47AD050((uint64_t)&llvm::SwpEnableCopyToPhi, 0, 0);
  byte_1ED82F730 = 0;
  qword_1ED82F738 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED82F740 = 0;
  llvm::SwpEnableCopyToPhi = (uint64_t)&unk_1E819E898;
  qword_1ED82F748 = (uint64_t)&off_1E819E9A0;
  qword_1ED82F750 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED82F768 = (uint64_t)&qword_1ED82F750;
  sub_1C61F86C8(a1, a2, a3, a4);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::SwpEnableCopyToPhi);
}

__n128 sub_1C61F86C8(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  char *v8;
  __n128 result;

  llvm::cl::Option::setArgStr((uint64_t)&llvm::SwpEnableCopyToPhi, "pipeliner-enable-copytophi", 0x1AuLL);
  word_1ED82F6BA = word_1ED82F6BA & 0xFF9F | (32 * (*a1 & 3));
  v8 = *a2;
  byte_1ED82F730 = **a2;
  byte_1ED82F741 = 1;
  byte_1ED82F740 = *v8;
  word_1ED82F6BA = word_1ED82F6BA & 0xFFF8 | *a3 & 7;
  result = *a4;
  xmmword_1ED82F6D0 = (__int128)*a4;
  return result;
}

uint64_t sub_1C61F875C(uint64_t a1, uint64_t a2)
{
  int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)a1 = &unk_1E814E610;
  v4 = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v4;
  *(_QWORD *)a1 = &off_1E814E760;
  v5 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = v5;
  *(_QWORD *)a1 = &off_1E814E790;
  v6 = *(_OWORD *)(a2 + 40);
  v7 = *(_OWORD *)(a2 + 56);
  v8 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = a1 + 96;
  v9 = a1 + 80;
  *(_QWORD *)(v9 - 8) = v8;
  *(_OWORD *)(v9 - 24) = v7;
  *(_OWORD *)(v9 - 40) = v6;
  *(_QWORD *)(v9 + 8) = 0x400000000;
  if (*(_DWORD *)(a2 + 88))
    sub_1C4E5CE00(v9, a2 + 80);
  *(_QWORD *)(a1 + 352) = *(_QWORD *)(a2 + 352);
  *(_QWORD *)a1 = &unk_1E8145C70;
  *(_QWORD *)(a1 + 360) = *(_QWORD *)(a2 + 360);
  return a1;
}

void sub_1C61F882C(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 88, &v5);
  sub_1C61F8898(a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61F8898(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    v5 = *(_QWORD *)a1;
    v6 = 88 * v2;
    do
    {
      sub_1C6182CAC(a2, v5);
      v7 = *(_OWORD *)(v5 + 48);
      v8 = *(_OWORD *)(v5 + 64);
      *(_DWORD *)(a2 + 80) = *(_DWORD *)(v5 + 80);
      *(_OWORD *)(a2 + 48) = v7;
      *(_OWORD *)(a2 + 64) = v8;
      v5 += 88;
      a2 += 88;
      v6 -= 88;
    }
    while (v6);
    v9 = *(_DWORD *)(a1 + 8);
    if (v9)
    {
      v10 = *(_QWORD *)a1;
      v11 = 88 * v9;
      v12 = v10 - 88;
      do
      {
        sub_1C6176BF8((_QWORD *)(v12 + v11));
        v11 -= 88;
      }
      while (v11);
    }
  }
}

_QWORD *sub_1C61F8928(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C617A1AC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C617A248(a1, a2, v7);
    *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
    v5[2] = 0;
  }
  return v5;
}

uint64_t *sub_1C61F8998(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 != *result)
  {
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)(v4 + v7 - 56);
      *(_QWORD *)(v6 + v7 - 48) = v6 + v7 - 32;
      result = (uint64_t *)(v6 + v7 - 48);
      *(result - 1) = v8;
      result[1] = 0x400000000;
      if (*(_DWORD *)(v4 + v7 - 40))
        result = (uint64_t *)sub_1C614D378((uint64_t)result, v4 + v7 - 48);
      v7 -= 56;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  v9 = *v3;
  *v3 = v6;
  a2[1] = v9;
  v10 = v3[1];
  v3[1] = a2[2];
  a2[2] = v10;
  v11 = v3[2];
  v3[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

_DWORD *sub_1C61F8A6C(uint64_t a1, _DWORD *a2)
{
  int v2;
  int v3;
  unsigned int v4;
  _DWORD *v5;
  int v6;
  _DWORD *v8;
  _DWORD *v9;
  int v10;
  BOOL v12;
  unsigned int v13;

  v2 = *(_DWORD *)(a1 + 16);
  if (!v2)
  {
    v8 = 0;
LABEL_10:
    v5 = sub_1C61F8B28(a1, (uint64_t)a2, a2, v8);
    *(_QWORD *)v5 = *a2;
    return v5;
  }
  v3 = v2 - 1;
  v4 = (37 * *a2) & (v2 - 1);
  v5 = (_DWORD *)(*(_QWORD *)a1 + 8 * v4);
  v6 = *v5;
  if (*a2 != *v5)
  {
    v9 = 0;
    v10 = 1;
    while (v6 != 0x7FFFFFFF)
    {
      if (v9)
        v12 = 0;
      else
        v12 = v6 == 0x80000000;
      if (v12)
        v9 = v5;
      v13 = v4 + v10++;
      v4 = v13 & v3;
      v5 = (_DWORD *)(*(_QWORD *)a1 + 8 * (v13 & v3));
      v6 = *v5;
      if (*a2 == *v5)
        return v5;
    }
    if (v9)
      v8 = v9;
    else
      v8 = v5;
    goto LABEL_10;
  }
  return v5;
}

_DWORD *sub_1C61F8B28(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v6;
  unsigned int v7;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  _DWORD *v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  BOOL v22;
  unsigned int v23;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
      goto LABEL_3;
    sub_1C49FB7A8(a1, v7);
    v15 = *(_DWORD *)(a1 + 16);
    if (v15)
    {
      v16 = v15 - 1;
      v17 = (37 * *a3) & v16;
      a4 = (_DWORD *)(*(_QWORD *)a1 + 8 * v17);
      v18 = *a4;
      if (*a3 == *a4)
        goto LABEL_3;
      v13 = 0;
      v19 = 1;
      while (v18 != 0x7FFFFFFF)
      {
        if (v13)
          v20 = 0;
        else
          v20 = v18 == 0x80000000;
        if (v20)
          v13 = a4;
        v21 = v17 + v19++;
        v17 = v21 & v16;
        a4 = (_DWORD *)(*(_QWORD *)a1 + 8 * v17);
        v18 = *a4;
        if (*a3 == *a4)
          goto LABEL_3;
      }
      goto LABEL_10;
    }
LABEL_24:
    a4 = 0;
    goto LABEL_3;
  }
  sub_1C49FB7A8(a1, 2 * v7);
  v9 = *(_DWORD *)(a1 + 16);
  if (!v9)
    goto LABEL_24;
  v10 = v9 - 1;
  v11 = (37 * *a3) & v10;
  a4 = (_DWORD *)(*(_QWORD *)a1 + 8 * v11);
  v12 = *a4;
  if (*a3 == *a4)
    goto LABEL_3;
  v13 = 0;
  v14 = 1;
  while (v12 != 0x7FFFFFFF)
  {
    if (v13)
      v22 = 0;
    else
      v22 = v12 == 0x80000000;
    if (v22)
      v13 = a4;
    v23 = v11 + v14++;
    v11 = v23 & v10;
    a4 = (_DWORD *)(*(_QWORD *)a1 + 8 * v11);
    v12 = *a4;
    if (*a3 == *a4)
      goto LABEL_3;
  }
LABEL_10:
  if (v13)
    a4 = v13;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != 0x7FFFFFFF)
    --*(_DWORD *)(a1 + 12);
  return a4;
}

_QWORD *sub_1C61F8CBC(_QWORD *result)
{
  int v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  int v5;

  v1 = *(_DWORD *)result;
  if (*(_DWORD *)result > 1u || *((_DWORD *)result + 1))
  {
    if ((v1 & 1) != 0)
    {
      v3 = result + 1;
      v4 = result + 9;
    }
    else
    {
      v2 = *((unsigned int *)result + 4);
      if (((2 * v1) & 0xFFFFFFFC) < v2 && v2 >= 0x41)
        return sub_1C61F8D34(result);
      if (!(_DWORD)v2)
      {
        v5 = 0;
LABEL_11:
        *(_DWORD *)result = v5;
        *((_DWORD *)result + 1) = 0;
        return result;
      }
      v3 = (_QWORD *)result[1];
      v4 = &v3[v2];
    }
    do
      *v3++ = -4096;
    while (v3 != v4);
    v5 = *(_DWORD *)result & 1;
    goto LABEL_11;
  }
  return result;
}

_QWORD *sub_1C61F8D34(_QWORD *result)
{
  _QWORD *v1;
  unsigned int v2;
  char v3;
  int v4;
  unsigned int v5;
  _QWORD *v6;
  _QWORD *v7;

  v1 = result;
  v2 = *(_DWORD *)result;
  v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if ((v3 & 0x3E) == 0x1C)
    v4 = 64;
  else
    v4 = 1 << (33 - v3);
  if (v2 >= 2)
    v5 = v4;
  else
    v5 = 0;
  if ((v2 & 1) != 0 && v5 < 9)
  {
    v6 = result + 1;
    *result = 1;
    v7 = result + 9;
    goto LABEL_10;
  }
  if ((v2 & 1) != 0)
    return sub_1C61F8058(v1, v5);
  if (v5 != *((_DWORD *)result + 4))
  {
    MEMORY[0x1CAA32FB4](result[1], 8);
    return sub_1C61F8058(v1, v5);
  }
  *result = 0;
  if (!v5)
    return result;
  v6 = (_QWORD *)result[1];
  v7 = &v6[v5];
  do
LABEL_10:
    *v6++ = -4096;
  while (v6 != v7);
  return result;
}

_QWORD *sub_1C61F8DF8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *result;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v14 = 0;
  result = (_QWORD *)sub_1C61F8EB4(a2, *a3, &v14);
  v7 = v14;
  if ((_DWORD)result)
  {
    v8 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v9 = 8;
    }
    else
    {
      v8 = *(_QWORD *)(a2 + 8);
      v9 = *(unsigned int *)(a2 + 16);
    }
    v10 = 0;
    v11 = v8 + 8 * v9;
  }
  else
  {
    result = sub_1C61F8F60((_DWORD *)a2, a3, v14);
    v7 = result;
    *result = *a3;
    v12 = a2 + 8;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      v13 = 8;
    }
    else
    {
      v12 = *(_QWORD *)(a2 + 8);
      v13 = *(unsigned int *)(a2 + 16);
    }
    v11 = v12 + 8 * v13;
    v10 = 1;
  }
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1C61F8EB4(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 8;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 8 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 8 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C61F8F60(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 8;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C51938BC((uint64_t)a1, v6);
  v8 = 0;
  sub_1C61F8EB4((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

uint64_t sub_1C61F901C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;

  v5 = (_DWORD *)result;
  v6 = *(_DWORD *)result;
  *(_QWORD *)result = *(_DWORD *)result & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(result + 8);
    v9 = (_QWORD *)(result + 72);
  }
  else
  {
    v7 = *(unsigned int *)(result + 16);
    if (!(_DWORD)v7)
      goto LABEL_10;
    v8 = *(_QWORD **)(result + 8);
    v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v11 = 0;
      result = sub_1C61F8EB4((uint64_t)v5, v10, &v11);
      *v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

_QWORD *sub_1C61F90DC(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4926528(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C51944FC(a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void sub_1C61F9138(uint64_t a1)
{
  char *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;

  v2 = *(char **)(a1 + 8);
  v3 = *(_BYTE **)(a1 + 16);
  if (v3 == v2)
    v4 = 0;
  else
    v4 = ((v3 - v2) << 6) - 1;
  v5 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v4 - (*(_QWORD *)(a1 + 40) + v5)) < 0x200)
  {
    v6 = *(char **)(a1 + 24);
    v7 = *(char **)a1;
    v8 = (uint64_t)&v6[-*(_QWORD *)a1];
    if (v3 - v2 >= (unint64_t)v8)
    {
      if (v6 == v7)
        v10 = 1;
      else
        v10 = v8 >> 2;
      v23 = a1 + 24;
      if (v10 >> 61)
        sub_1C4764EE4();
      v20 = (char *)operator new(8 * v10);
      v21 = v20;
      *(_QWORD *)&v22 = v20;
      *((_QWORD *)&v22 + 1) = &v20[8 * v10];
      v19 = operator new(0x1000uLL);
      sub_1C61351F0((uint64_t)&v20, &v19);
      v11 = *(char **)(a1 + 8);
      if (v11 == *(char **)(a1 + 16))
      {
        v12 = *(char **)(a1 + 8);
      }
      else
      {
        do
        {
          sub_1C4DBA538((uint64_t)&v20, v11);
          v11 += 8;
        }
        while (v11 != *(char **)(a1 + 16));
        v12 = *(char **)(a1 + 8);
      }
      v13 = *(char **)a1;
      v14 = v21;
      *(_QWORD *)a1 = v20;
      *(_QWORD *)(a1 + 8) = v14;
      v20 = v13;
      v21 = v12;
      v15 = *(_QWORD *)(a1 + 24);
      v16 = v22;
      *(_OWORD *)(a1 + 16) = v22;
      *(_QWORD *)&v22 = v11;
      *((_QWORD *)&v22 + 1) = v15;
      if (v16 - (_QWORD)v14 == 8)
        v17 = 256;
      else
        v17 = *(_QWORD *)(a1 + 32) + 512;
      *(_QWORD *)(a1 + 32) = v17;
      if (v11 != v12)
        *(_QWORD *)&v22 = &v11[(v12 - v11 + 7) & 0xFFFFFFFFFFFFFFF8];
      if (v13)
        operator delete(v13);
    }
    else
    {
      if (v2 == v7)
      {
        v20 = (char *)operator new(0x1000uLL);
        sub_1C61351F0(a1, &v20);
        v9 = *(_QWORD *)(a1 + 16);
        v20 = *(char **)(v9 - 8);
        *(_QWORD *)(a1 + 16) = v9 - 8;
      }
      else
      {
        v20 = (char *)operator new(0x1000uLL);
      }
      sub_1C6135314((void **)a1, &v20);
      if (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8) == 8)
        v18 = 256;
      else
        v18 = *(_QWORD *)(a1 + 32) + 512;
      *(_QWORD *)(a1 + 32) = v18;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 32) = v5 + 512;
    v20 = (char *)*((_QWORD *)v3 - 1);
    *(_QWORD *)(a1 + 16) = v3 - 8;
    sub_1C6135314((void **)a1, &v20);
  }
}

llvm::raw_ostream *llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v4;
  uint64_t v5;
  uint64_t v6;
  llvm::MachineBasicBlock **v7;
  uint64_t v8;
  llvm::MachineBasicBlock *v9;

  sub_1C4816AD8(a2, "=============================--------------------------------\n");
  sub_1C4816AD8(a2, "Inorder PostDominator Tree: ");
  if (!*(_BYTE *)(a1 + 88))
  {
    v4 = sub_1C4816AD8(a2, "DFSNumbers invalid: ");
    sub_1C5E21910(v4, *(unsigned int *)(a1 + 92), 0, 0, 0);
    sub_1C4816AD8(v4, " slow queries.");
  }
  sub_1C4816AD8(a2, "\n");
  v5 = *(_QWORD *)(a1 + 72);
  if (v5)
    sub_1C61ECBEC(v5, a2, 1u);
  sub_1C4816AD8(a2, "Roots: ");
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(llvm::MachineBasicBlock ***)a1;
    v8 = 8 * v6;
    do
    {
      v9 = *v7++;
      llvm::MachineBasicBlock::printAsOperand(v9, a2);
      sub_1C4816AD8(a2, " ");
      v8 -= 8;
    }
    while (v8);
  }
  return sub_1C4816AD8(a2, "\n");
}

{
  return __ZNK4llvm17DominatorTreeBaseINS_17MachineBasicBlockELb1EE5printERNS_11raw_ostreamE(a1, a2);
}

BOOL llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::verify(uint64_t a1, int a2)
{
  _QWORD *v4;
  _BOOL8 v5;
  _QWORD v7[5];
  int v8;
  uint64_t v9;

  v4 = operator new(8uLL);
  v7[0] = v4;
  *v4 = 0;
  v7[1] = v4 + 1;
  v7[2] = v4 + 1;
  v9 = 0;
  v7[3] = 0;
  v7[4] = 0;
  v8 = 0;
  v5 = 0;
  if (sub_1C519D9D8(a1))
    v5 = sub_1C519DC0C(a1)
      && sub_1C519E030((uint64_t)v7, a1)
      && sub_1C519E3C8(a1)
      && sub_1C519E79C(a1)
      && ((a2 - 1) > 1
       || sub_1C519EB38((uint64_t)v7, a1) && (a2 != 2 || sub_1C519EE98((uint64_t)v7, a1)));
  sub_1C519B258((uint64_t)v7);
  return v5;
}

void llvm::initializeMachinePostDominatorTreePass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82F770);
  if (v2 != -1)
  {
    v5[0] = sub_1C5197650;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82F770, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::MachinePostDominatorTree *llvm::MachinePostDominatorTree::MachinePostDominatorTree(llvm::MachinePostDominatorTree *this)
{
  llvm::PassRegistry *v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = (llvm::PassRegistry *)sub_1C4776848((uint64_t)this, (uint64_t)&llvm::MachinePostDominatorTree::ID);
  *(_QWORD *)v2 = &off_1E8145CA8;
  *((_QWORD *)v2 + 31) = 0;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  v3 = atomic_load(&qword_1ED82F770);
  if (v3 != -1)
  {
    v7[0] = sub_1C5197650;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED82F770, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void *llvm::MachinePostDominatorTree::getAnalysisUsage(llvm::MachineFunctionPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::MachinePostDominatorTree::verifyAnalysis(llvm::MachinePostDominatorTree *this)
{
  uint64_t result;
  BOOL v2;
  llvm::raw_ostream *v3;

  result = *((_QWORD *)this + 31);
  if (result)
    v2 = llvm::VerifyMachineDomInfo == 0;
  else
    v2 = 1;
  if (!v2)
  {
    result = llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::verify(result, 1);
    if ((result & 1) == 0)
    {
      v3 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
      sub_1C4816AD8(v3, "MachinePostDominatorTree verification failed\n");
      abort();
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MachinePostDominatorTree::print(llvm::MachinePostDominatorTree *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  return llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::print(*((_QWORD *)this + 31), a2);
}

llvm::MachinePostDominatorTree *llvm::callDefaultCtor<llvm::MachinePostDominatorTree>()
{
  llvm::MachinePostDominatorTree *v0;

  v0 = (llvm::MachinePostDominatorTree *)operator new();
  return llvm::MachinePostDominatorTree::MachinePostDominatorTree(v0);
}

uint64_t sub_1C61F968C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;

  v6 = 0;
  if (sub_1C61F96EC(a1, a2, &v6))
    return v6;
  v4 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v5 = 4;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(_DWORD *)(a1 + 16);
  }
  return v4 + 72 * v5;
}

uint64_t sub_1C61F96EC(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 72 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 72 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t sub_1C61F97A0(uint64_t result, uint64_t a2)
{
  int v2;
  int v3;

  if (*(_BYTE *)(result + 24))
    return sub_1C6182300(result, a2);
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)result = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  v2 = *(_DWORD *)(result + 12);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  v3 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(_BYTE *)(result + 24) = 1;
  return result;
}

void sub_1C61F9808(char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;

  sub_1C519BFB0(a1);
  v6 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(uint64_t **)a2;
    v8 = 8 * v6;
    v9 = 1;
    do
    {
      v10 = *v7++;
      v9 = sub_1C519FA70((uint64_t)a1, v10, v9, a3);
      v8 -= 8;
    }
    while (v8);
  }
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyBBInRegion(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  char *v12;

  result = llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(a1, (uint64_t)a2);
  if ((result & 1) == 0)
  {
    v12 = "Broken region found: enumerated BB not in region!";
    goto LABEL_14;
  }
  v5 = *a1;
  v6 = (uint64_t *)a2[11];
  v7 = (uint64_t *)a2[12];
  if (v6 != v7)
  {
    v8 = a1[4];
    while (1)
    {
      v9 = *v6;
      result = llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(a1, *v6);
      if ((result & 1) == 0 && v8 != v9)
        break;
      if (++v6 == v7)
        goto LABEL_7;
    }
    v12 = "Broken region found: edges leaving the region must go to the exit node!";
LABEL_14:
    llvm::report_fatal_error((llvm *)v12, (const char *)1);
  }
LABEL_7:
  if ((_QWORD *)(v5 & 0xFFFFFFFFFFFFFFF8) != a2)
  {
    v11 = (uint64_t *)a2[8];
    v10 = (uint64_t *)a2[9];
    while (1)
    {
      if (v11 == v10)
        return result;
      result = llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(a1, *v11);
      if ((result & 1) == 0)
        break;
      ++v11;
    }
    v12 = "Broken region found: edges entering the region must go to the entry node!";
    goto LABEL_14;
  }
  return result;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE16verifyBBInRegionEPNS_17MachineBasicBlockE(a1, a2);
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyWalk(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v5;
  uint64_t result;
  unint64_t *v7;
  uint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t **v12;
  unint64_t v13;
  BOOL v14;
  uint64_t **v15;
  uint64_t *v16;

  v16 = a2;
  v5 = a1[4];
  sub_1C47BC21C(a3, (unint64_t *)&v16, &v16);
  result = llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyBBInRegion(a1, v16);
  v7 = (unint64_t *)v16[11];
  v8 = v16[12];
  if (v7 != (unint64_t *)v8)
  {
    v9 = a3 + 1;
    do
    {
      v10 = *v7;
      if (*v7 != v5)
      {
        v11 = *v9;
        if (!*v9)
          goto LABEL_17;
        v12 = a3 + 1;
        do
        {
          v13 = v11[4];
          v14 = v13 >= v10;
          if (v13 >= v10)
            v15 = (uint64_t **)v11;
          else
            v15 = (uint64_t **)(v11 + 1);
          if (v14)
            v12 = (uint64_t **)v11;
          v11 = *v15;
        }
        while (*v15);
        if (v12 == v9 || v10 < (unint64_t)v12[4])
LABEL_17:
          result = llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyWalk(a1);
      }
      ++v7;
    }
    while (v7 != (unint64_t *)v8);
  }
  return result;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE10verifyWalkEPNS_17MachineBasicBlockEPNSt3__13setIS6_NS7_4lessIS6_EENS7_9allocatorIS6_EEEE(a1, a2, a3);
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegionNest(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;

  v2 = (uint64_t *)a1[5];
  v3 = (uint64_t *)a1[6];
  while (v2 != v3)
  {
    v4 = *v2++;
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegionNest(v4);
  }
  llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegion(a1);
}

{
  __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE16verifyRegionNestEv(a1);
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegion(uint64_t *a1)
{
  uint64_t *v1;
  _QWORD *v2[2];

  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::VerifyRegionInfo)
  {
    v2[0] = 0;
    v2[1] = 0;
    v1 = (uint64_t *)v2;
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyWalk(a1, (uint64_t *)(*a1 & 0xFFFFFFFFFFFFFFF8), &v1);
    sub_1C47655E8((uint64_t)&v1, v2[0]);
  }
}

{
  __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE12verifyRegionEv(a1);
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getEnteringBlock(_QWORD *a1)
{
  unint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;

  v1 = *a1 & 0xFFFFFFFFFFFFFFF8;
  v2 = *(uint64_t **)(v1 + 64);
  v3 = *(uint64_t **)(v1 + 72);
  if (v2 != v3)
  {
    v5 = 0;
    while (1)
    {
      v6 = *v2;
      if (!sub_1C49FA70C(a1[3], *v2)
        || (llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(a1, v6) & 1) != 0)
      {
        v6 = v5;
      }
      else if (v5)
      {
        return 0;
      }
      ++v2;
      v5 = v6;
      if (v2 == v3)
        return v6;
    }
  }
  return 0;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE16getEnteringBlockEv(a1);
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::isSimple(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1[4])
    return 0;
  result = llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getEnteringBlock(a1);
  if (result)
  {
    v3 = a1[4];
    if (!v3 || (v4 = *(uint64_t **)(v3 + 64), v5 = *(uint64_t **)(v3 + 72), v4 == v5))
    {
LABEL_14:
      v7 = 0;
    }
    else
    {
      v6 = 0;
      do
      {
        v7 = *v4;
        if (llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(a1, *v4))
        {
          if (v6)
            goto LABEL_14;
        }
        else
        {
          v7 = v6;
        }
        ++v4;
        v6 = v7;
      }
      while (v4 != v5);
    }
    return v7 != 0;
  }
  return result;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE8isSimpleEv(a1);
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::elements(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  _OWORD v8[4];
  uint64_t v9;
  void *__p;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  sub_1C51A2350((uint64_t)&v13, a1);
  v4 = *a1 & 0xFFFFFFFFFFFFFFF8;
  if (!llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getSubRegionNode(a1, v4))
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getBBNode((uint64_t)a1, v4);
  v9 = 0;
  __p = 0;
  memset(v8, 0, sizeof(v8));
  v5 = (char *)v8 + 8;
  v6 = (char *)v8 + 8;
  v7 = 8;
  v11 = 0;
  v12 = 0;
  sub_1C61AE17C(a2, (uint64_t)&v13, (uint64_t)&v5);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  if (v6 != v5)
    free(v6);
  if (v15)
  {
    v16 = v15;
    operator delete(v15);
  }
  if (v14 != v13)
    free(v14);
}

{
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  _OWORD v8[4];
  uint64_t v9;
  void *__p;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  sub_1C51A2350((uint64_t)&v13, a1);
  v4 = *a1 & 0xFFFFFFFFFFFFFFF8;
  if (!llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getSubRegionNode(a1, v4))
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getBBNode((uint64_t)a1, v4);
  v9 = 0;
  __p = 0;
  memset(v8, 0, sizeof(v8));
  v5 = (char *)v8 + 8;
  v6 = (char *)v8 + 8;
  v7 = 8;
  v11 = 0;
  v12 = 0;
  sub_1C61AE17C(a2, (uint64_t)&v13, (uint64_t)&v5);
  if (__p)
  {
    v11 = __p;
    operator delete(__p);
  }
  if (v6 != v5)
    free(v6);
  if (v15)
  {
    v16 = v15;
    operator delete(v15);
  }
  if (v14 != v13)
    free(v14);
}

{
  __ZN4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE8elementsEv(a1, a2);
}

{
  __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE8elementsEv(a1, a2);
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(_QWORD *a1, _QWORD *a2)
{
  uint64_t result;

  if (!a1[4])
    return 1;
  result = llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(a1, *a2 & 0xFFFFFFFFFFFFFFF8);
  if ((_DWORD)result)
  {
    if ((llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(a1, a2[4]) & 1) == 0)
      return a2[4] == a1[4];
    return 1;
  }
  return result;
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE8containsEPKNS_13MachineRegionE(a1, a2);
}

uint64_t *llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getBBNode(uint64_t a1, unint64_t a2)
{
  _QWORD *v4;
  uint64_t **v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  uint64_t **v9;
  _QWORD *v10;
  __int128 v12;

  v4 = *(_QWORD **)(a1 + 72);
  if (!v4)
    goto LABEL_12;
  v5 = (uint64_t **)(a1 + 72);
  do
  {
    v6 = v4[4];
    v7 = v6 >= a2;
    if (v6 >= a2)
      v8 = v4;
    else
      v8 = v4 + 1;
    if (v7)
      v5 = (uint64_t **)v4;
    v4 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v5 == (uint64_t **)(a1 + 72) || (unint64_t)v5[4] > a2)
  {
LABEL_12:
    v9 = (uint64_t **)(a1 + 64);
    v10 = (_QWORD *)operator new();
    *v10 = a2 & 0xFFFFFFFFFFFFFFFBLL;
    v10[1] = a1;
    *(_QWORD *)&v12 = a2;
    *((_QWORD *)&v12 + 1) = v10;
    v5 = sub_1C51A371C(v9, a2, &v12);
    if (*((_QWORD *)&v12 + 1))
      MEMORY[0x1CAA32FC0](*((_QWORD *)&v12 + 1), 0x1020C405730B0C9);
  }
  return v5[5];
}

{
  return __ZNK4llvm10RegionBaseINS_12RegionTraitsINS_15MachineFunctionEEEE9getBBNodeEPNS_17MachineBasicBlockE(a1, a2);
}

_QWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::~RegionInfoBase(_QWORD *a1)
{
  *a1 = &unk_1E8145D68;
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::releaseMemory((uint64_t)a1);
  MEMORY[0x1CAA32FB4](a1[5], 8);
  return a1;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEED2Ev(a1);
}

unsigned int *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::releaseMemory(uint64_t a1)
{
  unsigned int *result;
  uint64_t v3;
  void **v4;

  result = sub_1C61446F0((unsigned int *)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    sub_1C61FA9B0(*(_QWORD **)(v3 + 72));
    *(_QWORD *)(v3 + 64) = v3 + 72;
    *(_QWORD *)(v3 + 80) = 0;
    *(_QWORD *)(v3 + 72) = 0;
    v4 = (void **)(v3 + 40);
    sub_1C51A35F8(&v4);
    result = (unsigned int *)MEMORY[0x1CAA32FC0](v3, 0x1020C406A19994FLL);
  }
  *(_QWORD *)(a1 + 32) = 0;
  return result;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE13releaseMemoryEv(a1);
}

BOOL llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::isCommonDomFrontier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL8 result;

  v4 = *(uint64_t **)(a2 + 64);
  v5 = *(uint64_t **)(a2 + 72);
  if (v4 == v5)
    return 1;
  while (1)
  {
    v9 = *v4;
    v10 = *(_QWORD *)(a1 + 8);
    llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v10);
    if (llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates(*(_QWORD *)(v10 + 1320), a3, v9))
    {
      v11 = *(_QWORD *)(a1 + 8);
      llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v11);
      result = llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates(*(_QWORD *)(v11 + 1320), a4, v9);
      if (!result)
        break;
    }
    if (++v4 == v5)
      return 1;
  }
  return result;
}

{
  return __ZNK4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE19isCommonDomFrontierEPNS_17MachineBasicBlockES6_S6_(a1, a2, a3, a4);
}

_QWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::insertShortCut(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  BOOL v6;
  _QWORD *result;
  uint64_t v8;
  uint64_t v9;

  v5 = a3;
  v8 = a2;
  v9 = 0;
  if (sub_1C6144BDC(*(_QWORD *)a4, *(_DWORD *)(a4 + 16), a3, &v9))
    v6 = v9 == *(_QWORD *)a4 + 16 * *(unsigned int *)(a4 + 16);
  else
    v6 = 1;
  if (!v6)
    v5 = *(_QWORD *)(v9 + 8);
  result = sub_1C61FAC0C((_DWORD *)a4, &v8);
  result[1] = v5;
  return result;
}

{
  return __ZNK4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE14insertShortCutEPNS_17MachineBasicBlockES6_PNS_8DenseMapIS6_S6_NS_12DenseMapInfoIS6_vEENS_6detail12DenseMapPairIS6_S6_EEEE(a1, a2, a3, a4);
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::getNextPostDom(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  BOOL v7;
  uint64_t v9;

  v4 = (uint64_t)a2;
  v6 = *a2;
  v9 = 0;
  if (sub_1C6144BDC(*(_QWORD *)a3, *(_DWORD *)(a3 + 16), v6, &v9))
    v7 = v9 == *(_QWORD *)a3 + 16 * *(unsigned int *)(a3 + 16);
  else
    v7 = 1;
  if (!v7)
    v4 = sub_1C498DE30(*(_QWORD *)(a1 + 16), *(_QWORD *)(v9 + 8));
  return *(_QWORD *)(v4 + 8);
}

{
  return __ZNK4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE14getNextPostDomEPNS_15DomTreeNodeBaseINS_17MachineBasicBlockEEEPNS_8DenseMapIPS6_SA_NS_12DenseMapInfoISA_vEENS_6detail12DenseMapPairISA_SA_EEEE(a1, a2, a3);
}

_QWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::createRegion(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v9;
  _BYTE v10[24];
  uint64_t v11;
  _QWORD *v12;

  v6 = *(_QWORD **)(a2 + 88);
  if (((*(_QWORD *)(a2 + 96) - (_QWORD)v6) & 0x7FFFFFFF0) == 0 && *v6 == a3)
    return 0;
  v7 = (_QWORD *)operator new();
  v9 = a1[1];
  *v7 = a2 | 4;
  v7[1] = 0;
  v7[2] = a1;
  v7[3] = v9;
  v7[4] = a3;
  v7[5] = 0;
  v7[6] = 0;
  v7[7] = 0;
  v7[10] = 0;
  v7[9] = 0;
  v7[8] = v7 + 9;
  v11 = a2;
  v12 = v7;
  sub_1C6187718((uint64_t)v10, (uint64_t)(a1 + 5), &v11, &v12);
  (*(void (**)(_QWORD *, _QWORD *))(*a1 + 16))(a1, v7);
  return v7;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE12createRegionEPNS_17MachineBasicBlockES6_(a1, a2, a3);
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::findRegionsWithEntry(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t **v11;
  uint64_t v12;
  uint64_t **Region;

  result = sub_1C498DE30(a1[2], a2);
  if (result)
  {
    v7 = (uint64_t *)result;
    v8 = 0;
    v9 = a2;
    do
    {
      result = llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::getNextPostDom((uint64_t)a1, v7, a3);
      if (!result)
        break;
      v7 = (uint64_t *)result;
      v10 = *(_QWORD *)result;
      if (!*(_QWORD *)result)
        break;
      if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::isRegion((uint64_t)a1, a2, v10))
      {
        Region = (uint64_t **)llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::createRegion(a1, a2, v10);
        v11 = Region;
        if (v8)
          llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::addSubRegion(Region, v8, 0);
        v9 = v10;
      }
      else
      {
        v11 = v8;
      }
      v12 = a1[1];
      llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v12);
      result = llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates(*(_QWORD *)(v12 + 1320), a2, v10);
      v8 = v11;
    }
    while ((result & 1) != 0);
    if (v9 != a2)
      return (uint64_t)llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::insertShortCut((uint64_t)a1, a2, v9, a3);
  }
  return result;
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE20findRegionsWithEntryEPNS_17MachineBasicBlockEPNS_8DenseMapIS6_S6_NS_12DenseMapInfoIS6_vEENS_6detail12DenseMapPairIS6_S6_EEEE(a1, a2, a3);
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::buildRegionsTree(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  BOOL v9;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *(_QWORD *)a2;
  v17 = *(_QWORD *)a2;
  while ((uint64_t *)v6 == a3[4])
    a3 = (uint64_t **)a3[1];
  v8 = (_QWORD *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 40);
  v18 = 0;
  if (sub_1C6144BDC(v7, *(_DWORD *)(a1 + 56), v6, &v18))
    v9 = v18 == *v8 + 16 * *(unsigned int *)(a1 + 56);
  else
    v9 = 1;
  if (v9)
  {
    sub_1C6180A54(a1 + 40, &v17)[1] = a3;
    v10 = a3;
  }
  else
  {
    v10 = *(uint64_t ***)(v18 + 8);
    v11 = v10;
    do
    {
      v12 = v11;
      v11 = (uint64_t **)v11[1];
    }
    while (v11);
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::addSubRegion(a3, v12, 0);
  }
  v13 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v13)
  {
    v14 = *(uint64_t **)(a2 + 24);
    v15 = 8 * v13;
    do
    {
      v16 = *v14++;
      llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::buildRegionsTree(a1, v16, v10);
      v15 -= 8;
    }
    while (v15);
  }
}

{
  __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE16buildRegionsTreeEPNS_15DomTreeNodeBaseINS_17MachineBasicBlockEEEPNS_13MachineRegionE(a1, a2, a3);
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::calculate(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[2];
  int v7;

  v6[0] = 0;
  v6[1] = 0;
  v7 = 0;
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::scanForRegions((_QWORD *)a1, a2, (uint64_t)v6);
  v4 = sub_1C49FA70C(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 328));
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::buildRegionsTree(a1, v4, *(uint64_t ***)(a1 + 32));
  return MEMORY[0x1CAA32FB4](v6[0], 8);
}

{
  return __ZN4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE9calculateERS2_(a1, a2);
}

llvm::raw_ostream *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::dump(uint64_t **a1)
{
  llvm *v2;

  v2 = llvm::dbgs((llvm *)a1);
  sub_1C4816AD8(v2, "Region tree:\n");
  llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::print(a1[4], v2, 1, 0, llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::printStyle);
  return sub_1C4816AD8(v2, "End region tree\n");
}

{
  return __ZNK4llvm14RegionInfoBaseINS_12RegionTraitsINS_15MachineFunctionEEEE4dumpEv(a1);
}

void llvm::MachineRegionInfo::~MachineRegionInfo(llvm::MachineRegionInfo *this)
{
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::~RegionInfoBase(this);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t llvm::MachineRegionInfo::updateStatistics(llvm::MachineRegionInfo *this, llvm::MachineRegion *a2)
{
  return llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::isSimple(a2);
}

uint64_t llvm::MachineRegionInfo::recalculate(llvm::MachineRegionInfo *this, llvm::MachineFunction *a2, llvm::MachineDominatorTree *a3, llvm::MachinePostDominatorTree *a4, llvm::MachineDominanceFrontier *a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = a5;
  v7 = *((_QWORD *)a2 + 41);
  v8 = operator new();
  v9 = *((_QWORD *)this + 1);
  *(_QWORD *)v8 = v7 | 4;
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 16) = this;
  *(_QWORD *)(v8 + 24) = v9;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_QWORD *)(v8 + 80) = 0;
  *(_QWORD *)(v8 + 72) = 0;
  *(_QWORD *)(v8 + 64) = v8 + 72;
  *((_QWORD *)this + 4) = v8;
  llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::isSimple((_QWORD *)v8);
  return llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::calculate((uint64_t)this, (uint64_t)a2);
}

llvm::MachineRegionInfoPass *llvm::MachineRegionInfoPass::MachineRegionInfoPass(llvm::MachineRegionInfoPass *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = sub_1C4776848((uint64_t)this, (uint64_t)&llvm::MachineRegionInfoPass::ID);
  *(_QWORD *)v2 = &off_1E8145DB8;
  *(_QWORD *)(v2 + 288) = 0;
  *(_QWORD *)(v2 + 296) = 0;
  *(_QWORD *)(v2 + 280) = 0;
  *(_DWORD *)(v2 + 304) = 0;
  *(_QWORD *)(v2 + 248) = &off_1E8145D90;
  PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  v3 = atomic_load(&qword_1ED7FBBA0);
  if (v3 != -1)
  {
    v7[0] = sub_1C51A3528;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED7FBBA0, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return this;
}

void llvm::initializeMachineRegionInfoPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FBBA0);
  if (v2 != -1)
  {
    v5[0] = sub_1C51A3528;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FBBA0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::MachineRegionInfoPass::runOnMachineFunction(void ****this, llvm::MachineFunction *a2)
{
  void **v4;
  void *v5;
  llvm::MachineDominatorTree *v6;
  char **v7;
  char *v8;
  llvm::MachinePostDominatorTree *v9;
  void **v10;
  void *v11;
  llvm::MachineDominanceFrontier *v12;

  ((void (*)(void ****))(*this)[11])(this);
  v4 = *this[1];
  do
  {
    v5 = *v4;
    v4 += 2;
  }
  while (v5 != &llvm::MachineDominatorTree::ID);
  v6 = (llvm::MachineDominatorTree *)(*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v4 - 1) + 96))(*(v4 - 1), &llvm::MachineDominatorTree::ID);
  v7 = (char **)*this[1];
  do
  {
    v8 = *v7;
    v7 += 2;
  }
  while (v8 != llvm::MachinePostDominatorTree::ID);
  v9 = (llvm::MachinePostDominatorTree *)(*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v7 - 1) + 96))(*(v7 - 1), llvm::MachinePostDominatorTree::ID);
  v10 = *this[1];
  do
  {
    v11 = *v10;
    v10 += 2;
  }
  while (v11 != &llvm::MachineDominanceFrontier::ID);
  v12 = (llvm::MachineDominanceFrontier *)(*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v10 - 1) + 96))(*(v10 - 1), &llvm::MachineDominanceFrontier::ID);
  llvm::MachineRegionInfo::recalculate((llvm::MachineRegionInfo *)(this + 31), a2, v6, v9, v12);
  return 0;
}

unsigned int *llvm::MachineRegionInfoPass::releaseMemory(llvm::MachineRegionInfoPass *this)
{
  return llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::releaseMemory((uint64_t)this + 248);
}

void llvm::MachineRegionInfoPass::verifyAnalysis(uint64_t **this)
{
  char *v2;

  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::VerifyRegionInfo)
  {
    v2 = (char *)(this + 31);
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegionNest(this[35]);
    llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyBBMap((uint64_t)v2, this[35]);
  }
}

void *llvm::MachineRegionInfoPass::getAnalysisUsage(llvm::MachineRegionInfoPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachinePostDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineDominanceFrontier::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

llvm::raw_ostream *llvm::MachineRegionInfoPass::print(uint64_t **this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  sub_1C4816AD8(a2, "Region tree:\n");
  llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::print(this[35], a2, 1, 0, llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::printStyle);
  return sub_1C4816AD8(a2, "End region tree\n");
}

llvm::raw_ostream *llvm::MachineRegionInfoPass::dump(uint64_t **this)
{
  return llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::dump(this + 31);
}

llvm::MachineRegionInfoPass *llvm::callDefaultCtor<llvm::MachineRegionInfoPass>()
{
  llvm::MachineRegionInfoPass *v0;

  v0 = (llvm::MachineRegionInfoPass *)operator new();
  return llvm::MachineRegionInfoPass::MachineRegionInfoPass(v0);
}

void sub_1C61FA9B0(_QWORD *a1)
{
  uint64_t v2;

  if (a1)
  {
    sub_1C61FA9B0(*a1);
    sub_1C61FA9B0(a1[1]);
    v2 = a1[5];
    a1[5] = 0;
    if (v2)
      MEMORY[0x1CAA32FC0](v2, 0x1020C405730B0C9);
    operator delete(a1);
  }
}

char *sub_1C61FAA08(char *result)
{
  llvm::SmallPtrSetImplBase *v1;
  void **v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  char v10;
  uint64_t v11;
  _OWORD *v12;
  __int128 v13;
  __int128 v14;

  v1 = (llvm::SmallPtrSetImplBase *)result;
  v2 = (void **)(result + 96);
  v3 = *((_QWORD *)result + 13);
  while (2)
  {
    v4 = *(_QWORD **)(v3 - 32);
    if (!*(_BYTE *)(v3 - 8))
    {
      result = (char *)sub_1C61FAB84((unint64_t *)&v13, *(_QWORD *)(v3 - 32));
      *(_OWORD *)(v3 - 24) = v13;
      *(_BYTE *)(v3 - 8) = 1;
    }
    while (1)
    {
      v5 = *(_QWORD *)(v3 - 24) & 6;
      if (v5)
      {
        v6 = *v4 & 4;
      }
      else
      {
        v6 = *(_QWORD *)((*v4 & 0xFFFFFFFFFFFFFFF8) + 96);
        v5 = *(_QWORD *)(v3 - 16);
      }
      if (v5 == v6)
        break;
      v7 = sub_1C61FAB28((unint64_t *)(v3 - 24));
      v9 = sub_1C51A36C8(v7, v8);
      result = (char *)sub_1C4774094(v1, (uint64_t)v9);
      if (v10)
      {
        *(_QWORD *)&v13 = v9;
        BYTE8(v13) = 0;
        BYTE8(v14) = 0;
        v12 = (_OWORD *)*((_QWORD *)v1 + 13);
        if ((unint64_t)v12 >= *((_QWORD *)v1 + 14))
        {
          result = (char *)sub_1C4DD17E8(v2, &v13);
        }
        else
        {
          *v12 = v13;
          v12[1] = v14;
          result = (char *)(v12 + 2);
        }
        *((_QWORD *)v1 + 13) = result;
        return result;
      }
    }
    v11 = *((_QWORD *)v1 + 12);
    v3 = *((_QWORD *)v1 + 13) - 32;
    *((_QWORD *)v1 + 13) = v3;
    if (v11 != v3)
      continue;
    break;
  }
  return result;
}

unint64_t sub_1C61FAB28(unint64_t *a1)
{
  unint64_t result;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;

  result = *a1;
  if ((result & 6) != 0)
  {
    *a1 = result & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  else
  {
    v3 = *(uint64_t **)((*(_QWORD *)(result & 0xFFFFFFFFFFFFFFF8) & 0xFFFFFFFFFFFFFFF8) + 96);
    v4 = (uint64_t *)(a1[1] + 8);
    do
    {
      a1[1] = (unint64_t)v4;
      if (v4 == v3)
        break;
      v5 = *v4++;
    }
    while (*(_QWORD *)(*(_QWORD *)((result & 0xFFFFFFFFFFFFFFF8) + 8) + 32) == v5);
  }
  return result;
}

unint64_t *sub_1C61FAB84(unint64_t *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  v2 = *(_QWORD *)a2 >> 1;
  v3 = *(_QWORD **)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFFFF8) + 88);
  *result = v2 & 2 | a2 & 0xFFFFFFFFFFFFFFF9;
  result[1] = (unint64_t)v3;
  if ((v2 & 2) != 0)
  {
    if (*(_QWORD *)(*(_QWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 8) + 32) == *(_QWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 32))
      *result = a2 & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  else
  {
    v4 = *(_QWORD **)((*(_QWORD *)a2 & 0xFFFFFFFFFFFFFFF8) + 96);
    if (v4 != v3)
    {
      v5 = *(_QWORD *)(*(_QWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 8) + 32);
      do
      {
        if (v5 != *v3)
          break;
        result[1] = (unint64_t)++v3;
      }
      while (v3 != v4);
    }
  }
  return result;
}

_QWORD *sub_1C61FAC0C(_DWORD *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C4926528((uint64_t)a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C4AA2FF4(a1, (uint64_t)a2, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t llvm::MachineRegisterInfo::getLiveInPhysReg(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 456);
  v3 = *(_QWORD *)(a1 + 464) - v2;
  if (!v3)
    return 0;
  v4 = (_DWORD *)(v2 + 4);
  v5 = 8 * (v3 >> 3);
  while (*v4 != a2)
  {
    v4 += 2;
    v5 -= 8;
    if (!v5)
      return 0;
  }
  return *(v4 - 1);
}

uint64_t sub_1C61FACB0(uint64_t result)
{
  _DWORD *v1;
  _DWORD *v2;
  uint64_t v3;

  v1 = *(_DWORD **)(result + 32);
  if (**(_WORD **)(result + 16) == 14)
  {
    v3 = *(unsigned int *)(result + 40);
    if ((_DWORD)v3 == 2)
      return result;
    v2 = &v1[8 * v3];
    v1 += 16;
  }
  else
  {
    v2 = v1 + 8;
  }
  do
  {
    if (!*(_BYTE *)v1)
    {
      result = llvm::MachineOperand::setReg((uint64_t)v1, 0);
      *v1 &= 0xFFF000FF;
    }
    v1 += 8;
  }
  while (v1 != v2);
  return result;
}

void llvm::initializeMachineSchedulerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82FB38);
  if (v2 != -1)
  {
    v5[0] = sub_1C51A6550;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82FB38, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializePostMachineSchedulerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FBC68);
  if (v2 != -1)
  {
    v5[0] = sub_1C51A6604;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FBC68, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

llvm::raw_ostream *llvm::ReadyQueue::dump(const char **this)
{
  llvm *v2;
  llvm::raw_ostream *v3;
  const char *v4;
  char *v5;
  const char *v6;
  char v7;
  int v8;
  const char *v9;
  size_t v10;
  size_t v11;
  llvm::raw_ostream *v12;
  llvm *v13;
  uint64_t *v14;
  uint64_t *i;
  uint64_t v16;
  llvm *v17;
  llvm *v18;

  v2 = llvm::dbgs((llvm *)this);
  v3 = sub_1C4816AD8(v2, "Queue ");
  v6 = this[1];
  v5 = (char *)(this + 1);
  v4 = v6;
  v7 = v5[23];
  v8 = v7;
  if (v7 >= 0)
    v9 = v5;
  else
    v9 = v4;
  v10 = v7 & 0x7F;
  if (v8 >= 0)
    v11 = v10;
  else
    v11 = *((_QWORD *)v5 + 1);
  v12 = llvm::raw_ostream::write(v3, v9, v11);
  v13 = sub_1C4816AD8(v12, ": ");
  v14 = (uint64_t *)*((_QWORD *)v5 + 3);
  for (i = (uint64_t *)*((_QWORD *)v5 + 4); v14 != i; v13 = sub_1C4816AD8(v17, " "))
  {
    v16 = *v14++;
    v17 = llvm::dbgs(v13);
    sub_1C5E21910(v17, *(unsigned int *)(v16 + 192), 0, 0, 0);
  }
  v18 = llvm::dbgs(v13);
  return sub_1C4816AD8(v18, "\n");
}

uint64_t llvm::ScheduleDAGMI::releaseSucc(uint64_t result, uint64_t a2, uint64_t a3)
{
  _DWORD *v4;
  unsigned int v5;
  int v6;
  BOOL v7;

  v4 = (_DWORD *)(*(_QWORD *)a3 & 0xFFFFFFFFFFFFFFF8);
  if ((~*(_DWORD *)a3 & 6) != 0 || *(_DWORD *)(a3 + 8) < 4u)
  {
    v5 = *(_DWORD *)(a3 + 12) + *(_DWORD *)(a2 + 248);
    if (v4[62] < v5)
      v4[62] = v5;
    v6 = v4[52] - 1;
    v4[52] = v6;
    if (v6)
      v7 = 1;
    else
      v7 = result + 344 == (_QWORD)v4;
    if (!v7)
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 2648) + 120))(*(_QWORD *)(result + 2648));
  }
  else
  {
    --v4[54];
    if (*(_DWORD *)(a3 + 8) == 5)
      *(_QWORD *)(result + 2704) = v4;
  }
  return result;
}

uint64_t llvm::ScheduleDAGMI::enterRegion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_QWORD *)(a1 + 928) = a3;
  *(_QWORD *)(a1 + 936) = a4;
  *(_DWORD *)(a1 + 944) = a5;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 2648) + 24))(*(_QWORD *)(a1 + 2648), a3, a4, a5);
}

llvm::raw_ostream *llvm::ScheduleDAGMI::dumpSchedule(llvm::raw_ostream *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  llvm *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *((_QWORD *)this + 116);
  v2 = *((_QWORD *)this + 117);
  if (v1 != v2)
  {
    v3 = (uint64_t)this;
    v4 = (uint64_t *)((char *)this + 952);
    do
    {
      v7 = 0;
      v8 = v1;
      v5 = sub_1C61252B8(v4, &v8, &v7);
      if ((v5 & 1) != 0 && *(_QWORD *)(v7 + 8))
      {
        this = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
      }
      else
      {
        v6 = llvm::dbgs((llvm *)v5);
        this = sub_1C4816AD8(v6, "Missing SUnit\n");
      }
      if (!v1 || (*(_BYTE *)v1 & 4) == 0)
      {
        while ((*(_WORD *)(v1 + 44) & 8) != 0)
          v1 = *(_QWORD *)(v1 + 8);
      }
      v1 = *(_QWORD *)(v1 + 8);
    }
    while (v1 != v2);
  }
  return this;
}

llvm::raw_ostream *llvm::ScheduleDAGMILive::dump(llvm::raw_ostream *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t i;
  llvm *v4;
  llvm *v5;
  llvm *v6;
  uint64_t mustBeginGroup;
  char *v8;
  llvm *v9;
  llvm *v10;
  _BYTE *v11;

  v1 = (uint64_t)this;
  if (*((_QWORD *)this + 10))
    this = llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)this, (llvm::SDep **)this + 9);
  v2 = *(_QWORD *)(v1 + 48);
  for (i = *(_QWORD *)(v1 + 56); v2 != i; v2 += 272)
  {
    v4 = llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)v1, (llvm::SDep **)v2);
    if (*(_BYTE *)(v1 + 3120))
    {
      v5 = llvm::dbgs(v4);
      sub_1C4816AD8(v5, "  Pressure Diff      : ");
      v4 = llvm::PressureDiff::dump((llvm::PressureDiff *)(*(_QWORD *)(v1 + 3104) + ((unint64_t)*(unsigned int *)(v2 + 192) << 6)), *(const llvm::TargetRegisterInfo **)(v1 + 24));
    }
    v6 = llvm::dbgs(v4);
    sub_1C4816AD8(v6, "  Single Issue       : ");
    mustBeginGroup = llvm::TargetSchedModel::mustBeginGroup(v1 + 632, *(_QWORD *)(v2 + 8), 0);
    if (!(_DWORD)mustBeginGroup
      || (mustBeginGroup = llvm::TargetSchedModel::mustEndGroup((llvm::TargetSchedModel *)(v1 + 632), *(const llvm::MachineInstr **)(v2 + 8), 0), v8 = "true;",
          (mustBeginGroup & 1) == 0))
    {
      v8 = "false;";
    }
    v9 = llvm::dbgs((llvm *)mustBeginGroup);
    v10 = sub_1C4816AD8(v9, v8);
    this = llvm::dbgs(v10);
    v11 = (_BYTE *)*((_QWORD *)this + 4);
    if ((unint64_t)v11 >= *((_QWORD *)this + 3))
    {
      this = llvm::raw_ostream::write(this, 10);
    }
    else
    {
      *((_QWORD *)this + 4) = v11 + 1;
      *v11 = 10;
    }
  }
  if (*(_QWORD *)(v1 + 352))
    return llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)v1, (llvm::SDep **)(v1 + 344));
  return this;
}

uint64_t sub_1C61FB26C(int a1, llvm::SUnit *this)
{
  char *v3;

  if (a1 == 1)
  {
    if ((*((_BYTE *)this + 236) & 2) == 0)
      llvm::SUnit::ComputeHeight(this);
    v3 = (char *)this + 244;
  }
  else
  {
    if ((*((_BYTE *)this + 236) & 1) == 0)
      llvm::SUnit::ComputeDepth(this);
    v3 = (char *)this + 240;
  }
  return *(unsigned int *)v3;
}

uint64_t llvm::SchedBoundary::getOtherResourceCount(llvm::SchedBoundary *this, unsigned int *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *a2 = 0;
  if (!byte_1ED8303C8)
    return 0;
  v3 = *((_QWORD *)this + 1);
  if (!*(_QWORD *)(v3 + 40))
    return 0;
  v4 = *((_QWORD *)this + 2);
  result = (*(_DWORD *)(v4 + 8) + *(_DWORD *)(v3 + 272) * *((_DWORD *)this + 42));
  v6 = *(_DWORD *)(v3 + 48);
  if (v6 != 1)
  {
    v7 = *((_QWORD *)this + 22);
    v8 = *(_QWORD *)(v4 + 16);
    v9 = 1;
    do
    {
      v10 = (*(_DWORD *)(v8 + 4 * v9) + *(_DWORD *)(v7 + 4 * v9));
      if (v10 > result)
      {
        *a2 = v9;
        result = v10;
      }
      ++v9;
    }
    while (v6 != (_DWORD)v9);
  }
  return result;
}

uint64_t llvm::GenericSchedulerBase::SchedCandidate::initResourceDelta(uint64_t this, const llvm::ScheduleDAGMI *a2, const llvm::TargetSchedModel *a3)
{
  _DWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;

  v4 = (_DWORD *)this;
  if (*(_QWORD *)(this + 4))
  {
    v5 = *(_QWORD *)(this + 16);
    this = *(_QWORD *)(v5 + 24);
    if (!this)
    {
      this = llvm::TargetSchedModel::resolveSchedClass((const llvm::ScheduleDAGMI *)((char *)a2 + 632), *(const llvm::MachineInstr **)(v5 + 8));
      *(_QWORD *)(v5 + 24) = this;
    }
    if (*(_WORD *)(this + 12))
    {
      v6 = v4[1];
      v7 = v4[2];
      v8 = 4 * *(unsigned __int16 *)(this + 12);
      v9 = (unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)a3 + 22) + 136) + 4 * *(unsigned __int16 *)(this + 10) + 2);
      do
      {
        v10 = *(v9 - 1);
        if (v6 == v10)
          v4[10] += *v9;
        if (v7 == v10)
          v4[11] += *v9;
        v9 += 2;
        v8 -= 4;
      }
      while (v8);
    }
  }
  return this;
}

uint64_t llvm::GenericSchedulerBase::setPolicy(uint64_t a1, uint64_t a2, char a3, uint64_t a4, llvm::SchedBoundary *this)
{
  int OtherResourceCount;
  int v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t result;
  unsigned int v17;

  OtherResourceCount = 0;
  v17 = 0;
  if (this)
    OtherResourceCount = llvm::SchedBoundary::getOtherResourceCount(this, &v17);
  LOBYTE(v10) = byte_1ED8303C8;
  if (byte_1ED8303C8)
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 16) + 40))
      v11 = OtherResourceCount == 0;
    else
      v11 = 1;
    if (!v11)
    {
      result = sub_1C51ABBBC(a4);
      v10 = 1;
      if (OtherResourceCount - *(_DWORD *)(*(_QWORD *)(a1 + 16) + 276) * (int)result > *(_DWORD *)(*(_QWORD *)(a1 + 16) + 276))
        goto LABEL_14;
      goto LABEL_11;
    }
    LOBYTE(v10) = 0;
  }
  result = 0;
LABEL_11:
  if ((a3 & 1) != 0)
    goto LABEL_13;
  v12 = *(_DWORD *)(a4 + 148);
  v13 = *(_DWORD *)(a1 + 32);
  if (v12 > v13)
    goto LABEL_13;
  if (!v12)
    goto LABEL_27;
  if ((v10 & 1) == 0)
  {
    result = sub_1C51ABBBC(a4);
    v12 = *(_DWORD *)(a4 + 148);
    v13 = *(_DWORD *)(a1 + 32);
  }
  if (result + v12 > v13)
  {
LABEL_13:
    v10 = 0;
    *(_BYTE *)a2 = 1;
  }
  else
  {
LABEL_27:
    v10 = 0;
  }
LABEL_14:
  v14 = *(_DWORD *)(a4 + 260);
  v15 = v17;
  if (v14 != v17)
  {
    if (*(_BYTE *)(a4 + 264) && !*(_DWORD *)(a2 + 4))
      *(_DWORD *)(a2 + 4) = v14;
    if (v10)
      *(_DWORD *)(a2 + 8) = v15;
  }
  return result;
}

llvm::raw_ostream *llvm::GenericScheduler::dumpPolicy(llvm::GenericScheduler *this)
{
  llvm *v2;
  llvm::raw_ostream *v3;
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm::raw_ostream *v9;

  v2 = llvm::dbgs(this);
  v3 = sub_1C4816AD8(v2, "GenericScheduler RegionPolicy: ");
  v4 = sub_1C4816AD8(v3, " ShouldTrackPressure=");
  v5 = llvm::raw_ostream::operator<<(v4, *((unsigned __int8 *)this + 136));
  v6 = sub_1C4816AD8(v5, " OnlyTopDown=");
  v7 = llvm::raw_ostream::operator<<(v6, *((unsigned __int8 *)this + 138));
  v8 = sub_1C4816AD8(v7, " OnlyBottomUp=");
  v9 = llvm::raw_ostream::operator<<(v8, *((unsigned __int8 *)this + 139));
  return sub_1C4816AD8(v9, "\n");
}

uint64_t llvm::tryPressure(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  unsigned int v9;
  unsigned int v10;
  _BYTE *v11;
  unsigned int v14;
  int v17;
  int v18;
  int v21;
  int v22;
  int v23;
  int v24;
  BOOL v25;
  int v26;
  int v27;

  v9 = a1[1];
  v10 = a2[1];
  if (v9 >> 15 > v10 >> 15)
    goto LABEL_2;
  if (v9 >> 15 < v10 >> 15)
    goto LABEL_6;
  if (*(unsigned __int8 *)(a4 + 25) == *(unsigned __int8 *)(a3 + 25))
  {
    v17 = *a1;
    v18 = *a2;
    if (v17 == v18)
    {
      if ((__int16)v9 < (__int16)v10)
      {
LABEL_2:
        v11 = (_BYTE *)(a3 + 24);
LABEL_3:
        *v11 = a5;
        return 1;
      }
      if ((__int16)v9 > (__int16)v10)
      {
LABEL_6:
        v14 = *(unsigned __int8 *)(a4 + 24);
        v11 = (_BYTE *)(a4 + 24);
        if (v14 <= a5)
          return 1;
        goto LABEL_3;
      }
    }
    else
    {
      if (*a1)
      {
        v21 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a6 + 272))(a6, a7, (unsigned __int16)(v17 - 1));
        v22 = *a2;
      }
      else
      {
        v21 = 0x7FFFFFFF;
        v22 = *a2;
      }
      if (v22)
        v23 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a6 + 272))(a6, a7, (unsigned __int16)(v18 - 1));
      else
        v23 = 0x7FFFFFFF;
      v24 = (__int16)a1[1];
      v25 = v24 < 0;
      if (v24 >= 0)
        v26 = v21;
      else
        v26 = v23;
      if (v25)
        v27 = v21;
      else
        v27 = v23;
      if (v26 > v27)
        goto LABEL_2;
      if (v26 < v27)
        goto LABEL_6;
    }
  }
  return 0;
}

void llvm::GenericScheduler::initCandidate(llvm::GenericScheduler *this, llvm::GenericSchedulerBase::SchedCandidate *a2, const llvm::MachineInstr **a3, int a4, const llvm::RegPressureTracker *a5, llvm::RegPressureTracker *a6)
{
  uint64_t v6;
  const llvm::MachineInstr *v8;
  unsigned __int16 *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_QWORD *)a2 + 2) = a3;
  *((_BYTE *)a2 + 25) = a4;
  v6 = *((_QWORD *)this + 16);
  if (*(_BYTE *)(v6 + 3120))
  {
    if (a4)
    {
      llvm::RegPressureTracker::getMaxDownwardPressureDelta((uint64_t)a6, a3[1], (uint64_t)a2 + 26, *(_QWORD *)(v6 + 3808), (uint64_t)(*(_QWORD *)(v6 + 3816) - *(_QWORD *)(v6 + 3808)) >> 2, *(_QWORD *)(v6 + 3128), (uint64_t)(*(_QWORD *)(v6 + 3136) - *(_QWORD *)(v6 + 3128)) >> 2);
    }
    else
    {
      v8 = a3[1];
      v9 = (unsigned __int16 *)(*(_QWORD *)(v6 + 3104) + ((unint64_t)*((unsigned int *)a3 + 48) << 6));
      v10 = (char *)a2 + 26;
      v11 = *(_QWORD *)(v6 + 3808);
      v12 = (*(_QWORD *)(v6 + 3816) - v11) >> 2;
      v13 = *(_QWORD *)(v6 + 3128);
      if (byte_1ED82FA38)
        llvm::RegPressureTracker::getMaxUpwardPressureDelta((uint64_t)a6, v8, (uint64_t)v9, (uint64_t)v10, v11, v12, v13, (*(_QWORD *)(v6 + 3136) - v13) >> 2);
      else
        llvm::RegPressureTracker::getUpwardPressureDelta((uint64_t)a5, (uint64_t)v8, v9, (uint64_t)v10, v11, v12, v13);
    }
  }
}

const llvm::TargetSchedModel **llvm::GenericScheduler::pickNodeFromQueue(const llvm::TargetSchedModel **this, uint64_t a2, uint64_t *a3, llvm::RegPressureTracker *a4, uint64_t a5)
{
  const llvm::MachineInstr ***v5;
  const llvm::MachineInstr ***v6;
  const llvm::TargetSchedModel **v11;
  uint64_t v12;
  const llvm::MachineInstr **v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  _WORD v18[7];
  uint64_t v19;

  v5 = *(const llvm::MachineInstr ****)(a2 + 56);
  v6 = *(const llvm::MachineInstr ****)(a2 + 64);
  if (v5 != v6)
  {
    v11 = this;
    v12 = a5 + 26;
    do
    {
      v13 = *v5;
      v15 = *a3;
      v16 = *((_DWORD *)a3 + 2);
      v19 = 0;
      v17 = 0;
      memset(v18, 0, sizeof(v18));
      llvm::GenericScheduler::initCandidate((llvm::GenericScheduler *)v11, (llvm::GenericSchedulerBase::SchedCandidate *)&v15, v13, *(_DWORD *)(a2 + 24) == 1, a4, a4);
      if (*(unsigned __int8 *)(a5 + 25) == HIBYTE(v18[0]))
        v14 = a2;
      else
        v14 = 0;
      this = (const llvm::TargetSchedModel **)(*((uint64_t (**)(const llvm::TargetSchedModel **, uint64_t, uint64_t *, uint64_t))*v11
                                               + 17))(v11, a5, &v15, v14);
      if ((_DWORD)this)
      {
        if (!v19)
          this = (const llvm::TargetSchedModel **)llvm::GenericSchedulerBase::SchedCandidate::initResourceDelta((uint64_t)&v15, v11[16], v11[2]);
        *(_QWORD *)(a5 + 16) = v17;
        *(_WORD *)(a5 + 24) = v18[0];
        *(_QWORD *)v12 = *(_QWORD *)&v18[1];
        *(_DWORD *)(v12 + 8) = *(_DWORD *)&v18[5];
        *(_QWORD *)(a5 + 40) = v19;
      }
      ++v5;
    }
    while (v5 != v6);
  }
  return this;
}

uint64_t llvm::GenericScheduler::pickNode(llvm::GenericScheduler *this, BOOL *a2)
{
  llvm::SchedBoundary *v4;
  char *v5;
  _QWORD *v6;
  llvm::SchedBoundary *v7;
  uint64_t v8;
  _BYTE v10[12];

  if (*(_QWORD *)(*((_QWORD *)this + 16) + 2680) == *(_QWORD *)(*((_QWORD *)this + 16) + 2688))
    return 0;
  v4 = (llvm::GenericScheduler *)((char *)this + 144);
  v5 = (char *)this + 1552;
  v6 = (_QWORD *)((char *)this + 1568);
  v7 = (llvm::GenericScheduler *)((char *)this + 848);
  do
  {
    if (*((_BYTE *)this + 138))
    {
      v8 = llvm::SchedBoundary::pickOnlyChoice(v4);
      if (!v8)
      {
        v10[0] = 0;
        *(_QWORD *)&v10[4] = 0;
        *((_DWORD *)v5 + 2) = 0;
        *(_QWORD *)v5 = *(_QWORD *)v10;
        *((_QWORD *)this + 199) = 0;
        *v6 = 0;
        v6[1] = 0;
        *(_QWORD *)((char *)v6 + 14) = 0;
        llvm::GenericScheduler::pickNodeFromQueue((const llvm::TargetSchedModel **)this, (uint64_t)v4, (uint64_t *)v10, (llvm::RegPressureTracker *)(*((_QWORD *)this + 16) + 4160), (uint64_t)v5);
        v8 = *((_QWORD *)this + 196);
      }
      *a2 = 1;
    }
    else if (*((_BYTE *)this + 139))
    {
      v8 = llvm::SchedBoundary::pickOnlyChoice(v7);
      if (!v8)
      {
        v10[0] = 0;
        *(_QWORD *)&v10[4] = 0;
        *((_DWORD *)this + 402) = 0;
        *((_QWORD *)this + 200) = *(_QWORD *)v10;
        *((_QWORD *)this + 205) = 0;
        *((_QWORD *)this + 203) = 0;
        *((_QWORD *)this + 202) = 0;
        *(_QWORD *)((char *)this + 1630) = 0;
        llvm::GenericScheduler::pickNodeFromQueue((const llvm::TargetSchedModel **)this, (uint64_t)v7, (uint64_t *)v10, (llvm::RegPressureTracker *)(*((_QWORD *)this + 16) + 4840), (uint64_t)this + 1600);
        v8 = *((_QWORD *)this + 202);
      }
      *a2 = 0;
    }
    else
    {
      v8 = llvm::GenericScheduler::pickNodeBidirectional(this, a2);
    }
  }
  while ((*(_WORD *)(v8 + 228) & 0x400) != 0);
  if (!*(_DWORD *)(v8 + 208))
    llvm::SchedBoundary::removeReady((uint64_t)v4, v8);
  if (!*(_DWORD *)(v8 + 212))
    llvm::SchedBoundary::removeReady((uint64_t)v7, v8);
  return v8;
}

uint64_t llvm::createGenericSchedLive(llvm *this, llvm::MachineSchedContext *a2)
{
  uint64_t v3;
  uint64_t v4;
  double v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  char *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;

  v3 = operator new();
  v4 = operator new();
  v13 = sub_1C49BD128(v4, (uint64_t)this);
  v5 = sub_1C4838D9C((llvm::ScheduleDAGInstrs *)v3, (uint64_t)this, &v13);
  v6 = v13;
  v13 = 0;
  if (v6)
    (*(void (**)(uint64_t, double))(*(_QWORD *)v6 + 16))(v6, v5);
  v7 = (_QWORD *)operator new();
  v7[1] = 0;
  v7[2] = 0;
  *v7 = &off_1E8146668;
  v12 = v7;
  v8 = *(_QWORD **)(v3 + 2664);
  if ((unint64_t)v8 >= *(_QWORD *)(v3 + 2672))
  {
    v10 = sub_1C483904C((char **)(v3 + 2656), (uint64_t *)&v12);
    v11 = (uint64_t)v12;
    *(_QWORD *)(v3 + 2664) = v10;
    v12 = 0;
    if (v11)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
  }
  else
  {
    *v8 = v7;
    *(_QWORD *)(v3 + 2664) = v8 + 1;
  }
  return v3;
}

void llvm::PostGenericScheduler::initialize(llvm::PostGenericScheduler *this, llvm::ScheduleDAGMI *a2)
{
  uint64_t v3;
  llvm::SchedRemainder *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *((_QWORD *)this + 16) = a2;
  v3 = *((_QWORD *)a2 + 3);
  *((_QWORD *)this + 2) = (char *)a2 + 632;
  *((_QWORD *)this + 3) = v3;
  v4 = (llvm::PostGenericScheduler *)((char *)this + 32);
  llvm::SchedRemainder::init((llvm::PostGenericScheduler *)((char *)this + 32), a2, (llvm::ScheduleDAGMI *)((char *)a2 + 632));
  llvm::SchedBoundary::init((llvm::PostGenericScheduler *)((char *)this + 136), *((llvm::ScheduleDAGMI **)this + 16), *((const llvm::TargetSchedModel **)this + 2), v4);
  *((_DWORD *)this + 212) = 0;
  if (!*((_QWORD *)this + 34))
  {
    if (byte_1ED830488)
    {
      v5 = *((_QWORD *)this + 2);
      if (*(_QWORD *)(v5 + 168))
        v6 = v5 + 72;
      else
        v6 = 0;
    }
    else
    {
      v6 = 0;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 16) + 32) + 16);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 104))(v7);
    *((_QWORD *)this + 34) = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v8 + 872))(v8, v6, *((_QWORD *)this + 16));
  }
}

void llvm::PostGenericScheduler::registerRoots(llvm::PostGenericScheduler *this)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  llvm::SUnit **v5;
  uint64_t v6;
  llvm::SUnit *v7;
  unsigned int v8;
  llvm::raw_ostream *v9;
  llvm::raw_ostream *v10;

  v2 = *((_QWORD *)this + 16);
  if ((*(_BYTE *)(v2 + 580) & 1) == 0)
    llvm::SUnit::ComputeDepth((llvm::SUnit *)(v2 + 344));
  v3 = *(_DWORD *)(v2 + 584);
  *((_DWORD *)this + 8) = v3;
  v4 = *((unsigned int *)this + 212);
  if ((_DWORD)v4)
  {
    v5 = (llvm::SUnit **)*((_QWORD *)this + 105);
    v6 = 8 * v4;
    do
    {
      v7 = *v5;
      if ((*((_BYTE *)*v5 + 236) & 1) == 0)
      {
        llvm::SUnit::ComputeDepth(*v5);
        v3 = *((_DWORD *)this + 8);
      }
      v8 = *((_DWORD *)v7 + 60);
      if (v8 > v3)
      {
        if ((*((_BYTE *)v7 + 236) & 1) == 0)
        {
          llvm::SUnit::ComputeDepth(v7);
          v8 = *((_DWORD *)v7 + 60);
        }
        *((_DWORD *)this + 8) = v8;
        v3 = v8;
      }
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
  if (byte_1ED82F978)
  {
    v9 = (llvm::raw_ostream *)llvm::errs(this);
    v10 = sub_1C4816AD8(v9, "Critical Path(PGS-RR): ");
    sub_1C5E21910(v10, *((unsigned int *)this + 8), 0, 0, 0);
    sub_1C4816AD8(v10, " \n");
  }
}

BOOL llvm::PostGenericScheduler::tryCandidate(llvm::PostGenericScheduler *this, llvm::GenericSchedulerBase::SchedCandidate *a2, llvm::GenericSchedulerBase::SchedCandidate *a3, llvm::SchedBoundary *a4)
{
  uint64_t v5;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  char *v17;
  char v18;
  uint64_t v20;
  int v23;
  int v24;
  int v25;
  int v26;

  v5 = *((_QWORD *)a2 + 2);
  if (!v5)
    goto LABEL_51;
  v7 = *((_QWORD *)a3 + 2);
  if ((*(_WORD *)(v7 + 228) & 0x4000) != 0)
  {
    v9 = 252;
    if (*((_DWORD *)this + 40) == 1)
      v9 = 248;
    v10 = *(_DWORD *)(v7 + v9);
    v11 = *((_DWORD *)this + 71);
    v12 = v10 >= v11;
    v8 = v10 - v11;
    if (!v12)
      v8 = 0;
  }
  else
  {
    v8 = 0;
  }
  if ((*(_WORD *)(v5 + 228) & 0x4000) != 0)
  {
    v14 = 252;
    if (*((_DWORD *)this + 40) == 1)
      v14 = 248;
    v15 = *(_DWORD *)(v5 + v14);
    v16 = *((_DWORD *)this + 71);
    v12 = v15 >= v16;
    v13 = v15 - v16;
    if (!v12)
      v13 = 0;
  }
  else
  {
    v13 = 0;
  }
  if (v8 < v13)
  {
    v17 = (char *)a3 + 24;
LABEL_16:
    v18 = 5;
LABEL_17:
    *v17 = v18;
    return *((_BYTE *)a3 + 24) != 0;
  }
  if (v8 > v13)
  {
    v17 = (char *)a2 + 24;
    if (*((unsigned __int8 *)a2 + 24) < 6u)
      return *((_BYTE *)a3 + 24) != 0;
    goto LABEL_16;
  }
  v20 = *(_QWORD *)(*((_QWORD *)this + 16) + 2704);
  if (v7 == v20 && v5 != v20)
  {
    v17 = (char *)a3 + 24;
LABEL_35:
    v18 = 6;
    goto LABEL_17;
  }
  if (v5 == v20 && v7 != v20)
  {
    v17 = (char *)a2 + 24;
    if (*((unsigned __int8 *)a2 + 24) < 7u)
      return *((_BYTE *)a3 + 24) != 0;
    goto LABEL_35;
  }
  v23 = *((_DWORD *)a3 + 10);
  v24 = *((_DWORD *)a2 + 10);
  if (v23 < v24)
  {
    v17 = (char *)a3 + 24;
LABEL_34:
    v18 = 9;
    goto LABEL_17;
  }
  if (v23 > v24)
  {
    v17 = (char *)a2 + 24;
    if (*((unsigned __int8 *)a2 + 24) < 0xAu)
      return *((_BYTE *)a3 + 24) != 0;
    goto LABEL_34;
  }
  v25 = *((_DWORD *)a3 + 11);
  v26 = *((_DWORD *)a2 + 11);
  if (v25 > v26)
  {
    v17 = (char *)a3 + 24;
LABEL_43:
    v18 = 10;
    goto LABEL_17;
  }
  if (v25 < v26)
  {
    v17 = (char *)a2 + 24;
    if (*((unsigned __int8 *)a2 + 24) < 0xBu)
      return *((_BYTE *)a3 + 24) != 0;
    goto LABEL_43;
  }
  if (*(_BYTE *)a2)
  {
    if ((llvm::tryLatency(a3, a2, (llvm::PostGenericScheduler *)((char *)this + 136), a4) & 1) != 0)
      return *((_BYTE *)a3 + 24) != 0;
    v7 = *((_QWORD *)a3 + 2);
    v5 = *((_QWORD *)a2 + 2);
  }
  if (*(_DWORD *)(v7 + 192) >= *(_DWORD *)(v5 + 192))
    return 0;
LABEL_51:
  *((_BYTE *)a3 + 24) = 16;
  return 1;
}

uint64_t llvm::PostGenericScheduler::pickNodeFromQueue(uint64_t this, llvm::GenericSchedulerBase::SchedCandidate *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  const llvm::TargetSchedModel **v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _BYTE v11[14];
  uint64_t v12;

  v2 = *(uint64_t **)(this + 192);
  v3 = *(uint64_t **)(this + 200);
  if (v2 != v3)
  {
    v5 = (const llvm::TargetSchedModel **)this;
    v6 = (char *)a2 + 26;
    do
    {
      v7 = *v2;
      v8 = *(_QWORD *)a2;
      v9 = *((_DWORD *)a2 + 2);
      v12 = 0;
      *(_QWORD *)v11 = 256;
      *(_QWORD *)&v11[6] = 0;
      v10 = v7;
      llvm::GenericSchedulerBase::SchedCandidate::initResourceDelta((uint64_t)&v8, v5[16], v5[2]);
      this = (*((uint64_t (**)(const llvm::TargetSchedModel **, llvm::GenericSchedulerBase::SchedCandidate *, uint64_t *))*v5
              + 17))(v5, a2, &v8);
      if ((_DWORD)this)
      {
        *((_QWORD *)a2 + 2) = v10;
        *((_WORD *)a2 + 12) = *(_WORD *)v11;
        *(_QWORD *)v6 = *(_QWORD *)&v11[2];
        *((_DWORD *)v6 + 2) = *(_DWORD *)&v11[10];
        *((_QWORD *)a2 + 5) = v12;
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return this;
}

double llvm::createGenericSchedPostRA(llvm *this, llvm::MachineSchedContext *a2)
{
  uint64_t v3;
  _QWORD *v4;
  double result;

  v3 = operator new();
  v4 = (_QWORD *)operator new();
  sub_1C61FC9BC(v4, (uint64_t)this);
  llvm::ScheduleDAGInstrs::ScheduleDAGInstrs((llvm::ScheduleDAGInstrs *)v3, *((const llvm::TargetSubtargetInfo ***)this + 1), *((const llvm::MachineLoopInfo **)this + 2), 1);
  *(_QWORD *)v3 = &off_1E8145ED0;
  *(_OWORD *)(v3 + 2632) = *(_OWORD *)((char *)this + 40);
  *(_QWORD *)(v3 + 2648) = v4;
  result = 0.0;
  *(_OWORD *)(v3 + 2656) = 0u;
  *(_OWORD *)(v3 + 2672) = 0u;
  *(_OWORD *)(v3 + 2688) = 0u;
  *(_QWORD *)(v3 + 2704) = 0;
  return result;
}

llvm::raw_ostream *llvm::ScheduleDAGMI::viewGraph(llvm *a1)
{
  llvm::raw_ostream *v1;
  llvm::raw_ostream *v2;

  v1 = (llvm::raw_ostream *)llvm::errs(a1);
  v2 = sub_1C4816AD8(v1, "ScheduleDAGMI::viewGraph is only available in debug builds on ");
  return sub_1C4816AD8(v2, "systems with Graphviz or gv!\n");
}

uint64_t sub_1C61FC058()
{
  return 0;
}

void sub_1C61FC064(_QWORD *a1)
{
  sub_1C49BD404(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61FC08C(_QWORD *a1)
{
  sub_1C61FC5F8(a1);
  JUMPOUT(0x1CAA32FC0);
}

uint64_t sub_1C61FC0B4()
{
  return 0;
}

void sub_1C61FC0C0(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 228) & 0x400) == 0)
    llvm::SchedBoundary::releaseNode(a1 + 136, a2, *(_DWORD *)(a2 + 248), 0, 0);
}

_DWORD *sub_1C61FC0E0(_DWORD *result, uint64_t a2)
{
  _DWORD *v3;
  uint64_t v4;

  v3 = result;
  v4 = result[212];
  if (v4 >= result[213])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(result + 210), (uint64_t)(result + 214), v4 + 1, 8);
    LODWORD(v4) = v3[212];
  }
  *(_QWORD *)(*((_QWORD *)v3 + 105) + 8 * v4) = a2;
  ++v3[212];
  return result;
}

_QWORD *sub_1C61FC140(_QWORD *a1)
{
  _QWORD *v2;

  qword_1ED82FB50 = 0;
  *a1 = off_1E8146410;
  a1[1] = &off_1E8146498;
  v2 = (_QWORD *)a1[3];
  if (v2 != a1 + 5)
    free(v2);
  return a1;
}

uint64_t sub_1C61FC190(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v12 = 0;
  v8 = sub_1C61FC508(a1 + 168, (_QWORD *)a1, a3, a4, a5, a6, &v12);
  if ((v8 & 1) != 0)
    return v8;
  *(_QWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 672);
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C61FC208(v11);
}

uint64_t sub_1C61FC208(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 176) + 24))
    return 2;
  else
    return 3;
}

void sub_1C61FC220(_QWORD *a1)
{
  sub_1C51AE448(a1);
  JUMPOUT(0x1CAA32FC0);
}

unint64_t sub_1C61FC244(uint64_t a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth(a1 + 168, a1);
}

uint64_t sub_1C61FC250(uint64_t a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::generic_parser_base *)(a1 + 168), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *sub_1C61FC260(llvm::raw_ostream *result, int a2, int a3)
{
  uint64_t v3;
  _QWORD v4[2];
  char v5;

  if (a3)
  {
    v3 = *((_QWORD *)result + 16);
LABEL_3:
    v5 = 1;
    v4[0] = &off_1E81464E8;
    v4[1] = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 168), result, (const llvm::cl::GenericOptionValue *)v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((_BYTE *)result + 152))
  {
    v3 = *((_QWORD *)result + 16);
    if (*((_QWORD *)result + 18) != v3)
      goto LABEL_3;
  }
  return result;
}

_QWORD *sub_1C61FC2C8(uint64_t a1, uint64_t a2)
{
  return sub_1C4B03438((_QWORD *)(a1 + 168), a2);
}

void sub_1C61FC2D0(_QWORD *a1)
{
  _QWORD *v2;

  *(a1 - 1) = off_1E8146410;
  qword_1ED82FB50 = 0;
  *a1 = &off_1E8146498;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
}

void sub_1C61FC31C(_QWORD *a1)
{
  _QWORD *v2;

  qword_1ED82FB50 = 0;
  *a1 = off_1E8146410;
  a1[1] = &off_1E8146498;
  v2 = (_QWORD *)a1[3];
  if (v2 != a1 + 5)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C61FC37C(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  sub_1C51AE504(a1 + 8, a2, a3, a4, a5, a6);
}

uint64_t sub_1C61FC384(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  result = llvm::cl::generic_parser_base::findOption(a1 + 8, a2, a3);
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_DWORD *)(a1 + 32);
  v7 = v5 + 56 * v6;
  v8 = v5 + 56 * result + 56;
  if (v8 != v7)
  {
    v9 = 56 * v6 - 56 * result - 56;
    do
    {
      v10 = *(_OWORD *)(v8 + 16);
      *(_OWORD *)(v8 - 56) = *(_OWORD *)v8;
      *(_OWORD *)(v8 - 40) = v10;
      *(_QWORD *)(v8 - 16) = *(_QWORD *)(v8 + 40);
      *(_BYTE *)(v8 - 8) = *(_BYTE *)(v8 + 48);
      v8 += 56;
      v9 -= 56;
    }
    while (v9);
    v6 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v6 - 1;
  return result;
}

void sub_1C61FC414(uint64_t a1)
{
  sub_1C61FC31C((_QWORD *)(a1 - 8));
}

uint64_t sub_1C61FC41C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1C61FC424(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * a2 + 16);
}

uint64_t sub_1C61FC438(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 16) + 56 * a2 + 32;
}

_QWORD *sub_1C61FC44C(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E8146498;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

void sub_1C61FC48C(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E8146498;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  JUMPOUT(0x1CAA32FC0);
}

BOOL sub_1C61FC4DC(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 16) && *(_BYTE *)(a1 + 16) && *(_QWORD *)(a1 + 8) != *(_QWORD *)(a2 + 8);
}

uint64_t sub_1C61FC508(uint64_t a1, _QWORD *a2, const void *a3, size_t a4, const void *a5, size_t a6, _QWORD *a7)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v13;
  uint64_t *v14;
  llvm::raw_ostream *v15;
  uint64_t result;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  if (v8)
    a4 = a6;
  if (v8)
    a3 = a5;
  v11 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v11)
  {
    v13 = *(_QWORD *)(a1 + 16);
    while (*(_QWORD *)(v13 + 8) != a4 || a4 && memcmp(*(const void **)v13, a3, a4))
    {
      v13 += 56;
      if (!--v11)
        goto LABEL_13;
    }
    result = 0;
    *a7 = *(_QWORD *)(v13 + 40);
  }
  else
  {
LABEL_13:
    v20 = 1283;
    v19[0] = (uint64_t)"Cannot find option named '";
    v19[2] = (uint64_t)a3;
    v19[3] = a4;
    v17 = "'!";
    v18 = 259;
    v14 = sub_1C4825FE4(v19, (uint64_t *)&v17, (uint64_t)v21);
    v15 = (llvm::raw_ostream *)llvm::errs((llvm *)v14);
    return llvm::cl::Option::error(a2, (llvm::Twine *)v21, 0, 0, v15);
  }
  return result;
}

_QWORD *sub_1C61FC5F8(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  *a1 = &off_1E8146000;
  v2 = (_QWORD *)a1[105];
  if (v2 != a1 + 107)
    free(v2);
  llvm::SchedBoundary::~SchedBoundary((llvm::SchedBoundary *)(a1 + 17));
  *a1 = &off_1E7FA8528;
  v3 = (_QWORD *)a1[6];
  if (v3 != a1 + 8)
    free(v3);
  return a1;
}

void sub_1C61FC664(_WORD *a1, __n128 *a2, char **a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FBEB0, 0, 0);
  byte_1ED7FBF30 = 0;
  qword_1ED7FBF38 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7FBF40 = 0;
  qword_1ED7FBEB0 = (uint64_t)&unk_1E819E898;
  qword_1ED7FBF48 = (uint64_t)&off_1E819E9A0;
  qword_1ED7FBF50 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7FBF68 = (uint64_t)&qword_1ED7FBF50;
  sub_1C51AEEA8(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FBEB0);
}

void sub_1C61FC708(uint64_t **a1, _WORD *a2, __n128 *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FC270, 0, 0);
  *(_OWORD *)&xmmword_1ED7FC2F0 = 0u;
  *(_OWORD *)&qword_1ED7FC300 = 0u;
  *(&xmmword_1ED7FC2F0 + 1) = (uint64_t (*)(_QWORD))&off_1E81464E8;
  qword_1ED7FC270 = (uint64_t)off_1E81463A8;
  qword_1ED7FC320 = (uint64_t)&qword_1ED7FC270;
  unk_1ED7FC328 = &unk_1ED7FC338;
  qword_1ED7FC330 = 0x800000000;
  qword_1ED7FC310 = (uint64_t)off_1E8146410;
  unk_1ED7FC318 = &unk_1E8146448;
  qword_1ED7FC4F8 = (uint64_t)&off_1E81465C0;
  qword_1ED7FC510 = (uint64_t)&qword_1ED7FC4F8;
  sub_1C51AEF2C(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FC270);
  sub_1C51AEFB0();
}

void sub_1C61FC7C0()
{
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C61FC7D4()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E81465C0;
  return result;
}

void sub_1C61FC7F8(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E81465C0;
}

void sub_1C61FC814(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FC0F0, 0, 0);
  byte_1ED7FC170 = 0;
  qword_1ED7FC178 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7FC180 = 0;
  qword_1ED7FC0F0 = (uint64_t)&unk_1E819E898;
  qword_1ED7FC188 = (uint64_t)&off_1E819E9A0;
  qword_1ED7FC190 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7FC1A8 = (uint64_t)&qword_1ED7FC190;
  sub_1C51AF008(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FC0F0);
}

void sub_1C61FC8B8(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FC1B0, 0, 0);
  byte_1ED7FC230 = 0;
  qword_1ED7FC238 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7FC240 = 0;
  qword_1ED7FC1B0 = (uint64_t)&unk_1E819E898;
  qword_1ED7FC248 = (uint64_t)&off_1E819E9A0;
  qword_1ED7FC250 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7FC268 = (uint64_t)&qword_1ED7FC250;
  sub_1C51AF08C(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FC1B0);
}

_DWORD *sub_1C61FC95C(uint64_t *a1, _DWORD *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C51B1F1C(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C51B1FBC((uint64_t)a1, (uint64_t)a2, a2, v7);
    *(_QWORD *)v5 = *a2;
    v5[2] = 0;
  }
  return v5;
}

_QWORD *sub_1C61FC9BC(_QWORD *a1, uint64_t a2)
{
  const char *v4;
  __int16 v5;

  a1[3] = 0;
  a1[4] = 0;
  a1[1] = a2;
  a1[2] = 0;
  a1[6] = a1 + 8;
  a1[7] = 0x1000000000;
  *(_QWORD *)((char *)a1 + 37) = 0;
  *a1 = &off_1E8146000;
  a1[16] = 0;
  v4 = "TopQ";
  v5 = 259;
  sub_1C49BD288((uint64_t)(a1 + 17), 1, (uint64_t)&v4);
  a1[105] = a1 + 107;
  a1[106] = 0x800000000;
  return a1;
}

void llvm::initializeMachineSinkingPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FC518);
  if (v2 != -1)
  {
    v5[0] = sub_1C51B3448;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FC518, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializePostRAMachineSinkingPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FC520);
  if (v2 != -1)
  {
    v5[0] = sub_1C51B34F4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FC520, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

_DWORD *sub_1C61FCB14(_QWORD *a1, unsigned int a2)
{
  _DWORD *result;
  _DWORD *v4;
  uint64_t v5;
  int v6;

  if (a2 <= 4)
  {
    *a1 = 1;
LABEL_3:
    result = a1 + 1;
    v4 = a1 + 9;
    goto LABEL_4;
  }
  *(_DWORD *)a1 &= ~1u;
  v5 = a2;
  result = operator new(16 * a2, (std::align_val_t)8uLL);
  a1[1] = result;
  a1[2] = v5;
  v6 = *(_DWORD *)a1;
  *a1 = *(_DWORD *)a1 & 1;
  if ((v6 & 1) != 0)
    goto LABEL_3;
  v4 = &result[4 * v5];
  do
  {
LABEL_4:
    *result = -1;
    result += 4;
  }
  while (result != v4);
  return result;
}

uint64_t *sub_1C61FCB94(uint64_t *a1)
{
  sub_1C51B6C58(a1);
  if ((*(_BYTE *)a1 & 1) == 0)
    MEMORY[0x1CAA32FB4](a1[1], 8);
  return a1;
}

void sub_1C61FCBD0(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 32, &v5);
  sub_1C61FCC3C((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61FCC3C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  v2 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v2)
  {
    v4 = *a1 + 32 * v2;
    v5 = a2 + 24;
    v6 = *a1 + 8;
    do
    {
      v7 = v6 - 8;
      *(_QWORD *)(v5 - 24) = *(_QWORD *)(v6 - 8);
      *(_QWORD *)(v5 - 16) = v5;
      *(_QWORD *)(v5 - 8) = 0x200000000;
      if (*(_DWORD *)(v6 + 8))
        sub_1C4EA2F88(v5 - 16, v6);
      v5 += 32;
      v6 += 32;
    }
    while (v7 + 32 != v4);
    v8 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v8)
    {
      v9 = *a1;
      v10 = 32 * v8;
      do
      {
        v11 = *(void **)(v9 + v10 - 24);
        if ((void *)(v9 + v10 - 8) != v11)
          free(v11);
        v10 -= 32;
      }
      while (v10);
    }
  }
}

uint64_t *sub_1C61FCCF8(unsigned int *a1)
{
  unsigned int v2;
  uint64_t *result;
  unsigned int v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  _DWORD *v8;

  v2 = *a1;
  result = sub_1C51B6C58((uint64_t *)a1);
  v4 = __clz((v2 >> 1) - 1);
  if (v4 - 28 >= 3)
    v5 = 1 << (33 - v4);
  else
    v5 = 64;
  if (v2 >= 2)
    v6 = v5;
  else
    v6 = 0;
  if ((*a1 & 1) != 0 && v6 < 5)
  {
    v7 = a1 + 2;
    *(_QWORD *)a1 = 1;
    v8 = a1 + 18;
    do
    {
LABEL_16:
      *v7 = -1;
      v7 += 4;
    }
    while (v7 != v8);
    return result;
  }
  if ((*a1 & 1) != 0)
    return (uint64_t *)sub_1C61FCB14(a1, v6);
  if (v6 != a1[4])
  {
    MEMORY[0x1CAA32FB4](*((_QWORD *)a1 + 1), 8);
    return (uint64_t *)sub_1C61FCB14(a1, v6);
  }
  *(_QWORD *)a1 = 0;
  if (v6)
  {
    v7 = (_DWORD *)*((_QWORD *)a1 + 1);
    v8 = &v7[4 * v6];
    goto LABEL_16;
  }
  return result;
}

uint64_t *sub_1C61FCDC4(uint64_t *a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v5;
  char **v6;
  uint64_t v7;

  v2 = *((_DWORD *)a1 + 4);
  v3 = *a1;
  if (v2)
  {
    v5 = 88 * v2;
    v6 = (char **)(v3 + 8);
    do
    {
      if (*((_DWORD *)v6 - 2) <= 0xFFFFFFFD)
      {
        v7 = v5;
        v6 = sub_1C51BCBA0(v6);
        v5 = v7;
      }
      v6 += 11;
      v5 -= 88;
    }
    while (v5);
    v3 = *a1;
  }
  MEMORY[0x1CAA32FB4](v3, 8);
  return a1;
}

_DWORD *sub_1C61FCE3C(_DWORD *a1)
{
  int v2;
  _DWORD *v3;
  uint64_t v4;
  _DWORD *result;
  _DWORD *v6;
  uint64_t v7;

  v2 = *a1;
  if (*a1 > 1u)
  {
    if ((v2 & 1) != 0)
    {
      result = a1 + 2;
      v6 = a1 + 34;
      goto LABEL_8;
    }
    result = (_DWORD *)*((_QWORD *)a1 + 1);
    v7 = a1[4];
    if ((_DWORD)v7)
    {
      v6 = &result[8 * v7];
LABEL_8:
      while (*result >= 0xFFFFFFFE)
      {
        result += 8;
        if (result == v6)
          return v6;
      }
    }
  }
  else
  {
    if (v2)
    {
      v3 = a1 + 2;
      v4 = 4;
    }
    else
    {
      v3 = (_DWORD *)*((_QWORD *)a1 + 1);
      v4 = a1[4];
    }
    return &v3[8 * v4];
  }
  return result;
}

uint64_t sub_1C61FCEB0(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
    return sub_1C61FD5A0(a1, a2, a3);
  v5 = (_QWORD *)(*(_QWORD *)a1 + 32 * v4);
  *v5 = *a2;
  v5[2] = 0x200000000;
  v5[1] = v5 + 3;
  result = (uint64_t)(v5 + 1);
  if (*(_DWORD *)(a3 + 8))
    result = sub_1C4EA2F88(result, a3);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1C61FCF28(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v8;
  char v9;
  uint64_t v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = 0;
  sub_1C61FD698((uint64_t)&v8, a1, &v10, &v11);
  v4 = v8;
  if (v9)
  {
    v12 = &v14;
    v13 = 0x200000000;
    v15 = *a2;
    v16 = v18;
    v17 = 0x200000000;
    sub_1C51BD954((uint64_t *)(a1 + 24), (uint64_t)&v15);
    if (v16 != v18)
      free(v16);
    if (v12 != &v14)
      free(v12);
    v5 = *(_QWORD *)(a1 + 24);
    v6 = ((unint64_t)(*(_QWORD *)(a1 + 32) - v5) >> 5) - 1;
    *(_DWORD *)(v4 + 8) = v6;
  }
  else
  {
    v6 = *(_DWORD *)(v8 + 8);
    v5 = *(_QWORD *)(a1 + 24);
  }
  return v5 + 32 * v6 + 8;
}

_DWORD *sub_1C61FD038(_DWORD *a1, int *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C61FD0A8((uint64_t)a1, *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61FD14C(a1, a2, v7);
    *v5 = *a2;
    *((_QWORD *)v5 + 1) = v5 + 6;
    *((_QWORD *)v5 + 2) = 0x200000000;
  }
  return v5;
}

uint64_t sub_1C61FD0A8(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  _DWORD *v9;
  int v10;
  uint64_t result;
  BOOL v12;
  int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_8;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & (37 * a2);
  v7 = (_DWORD *)(v3 + 32 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
LABEL_17:
    result = 1;
  }
  else
  {
    v9 = 0;
    v10 = 1;
    while (v8 != -1)
    {
      if (v9)
        v12 = 0;
      else
        v12 = v8 == -2;
      if (v12)
        v9 = v7;
      v13 = v6 + v10++;
      v6 = v13 & v5;
      v7 = (_DWORD *)(v3 + 32 * v6);
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_17;
    }
    result = 0;
    if (v9)
      v7 = v9;
  }
LABEL_8:
  *a3 = v7;
  return result;
}

_DWORD *sub_1C61FD14C(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v3;
  unsigned int v4;
  uint64_t v7;
  _DWORD *v8;

  v3 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v4 = 4;
  else
    v4 = a1[4];
  if (4 * v3 + 4 >= 3 * v4)
  {
    v4 *= 2;
  }
  else if (v4 + ~v3 - a1[1] > v4 >> 3)
  {
    goto LABEL_5;
  }
  v7 = (uint64_t)a1;
  sub_1C51BCE70((uint64_t)a1, v4);
  v8 = 0;
  sub_1C61FD0A8(v7, *a2, &v8);
  a1 = (_DWORD *)v7;
  a3 = v8;
LABEL_5:
  *a1 += 2;
  if (*a3 != -1)
    --a1[1];
  return a3;
}

void sub_1C61FD20C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  void *v13;
  _DWORD *v14;

  v4 = a2;
  v6 = *(_DWORD *)a1;
  *(_QWORD *)a1 = *(_DWORD *)a1 & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_DWORD *)(a1 + 8);
    v9 = (_DWORD *)(a1 + 136);
  }
  else
  {
    v7 = *(unsigned int *)(a1 + 16);
    if (!(_DWORD)v7)
      goto LABEL_6;
    v8 = *(_DWORD **)(a1 + 8);
    v9 = &v8[8 * v7];
  }
  do
  {
    *v8 = -1;
    v8 += 8;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      v10 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        v14 = 0;
        sub_1C61FD0A8(a1, v10, &v14);
        v11 = v14;
        *v14 = *(_DWORD *)v4;
        *((_QWORD *)v11 + 2) = 0x200000000;
        *((_QWORD *)v11 + 1) = v11 + 6;
        v12 = (uint64_t)(v11 + 2);
        if (*(_DWORD *)(v4 + 16))
          sub_1C4EA2F88(v12, v4 + 8);
        *(_DWORD *)a1 += 2;
        v13 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v13)
          free(v13);
      }
      v4 += 32;
    }
    while (v4 != a3);
  }
}

_DWORD *sub_1C61FD30C(uint64_t a1, int *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C51BD0CC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61FD384(a1, a2, v7);
    *v5 = *a2;
    *((_QWORD *)v5 + 1) = v5 + 6;
    *((_QWORD *)v5 + 2) = 0x200000000;
  }
  return v5;
}

_DWORD *sub_1C61FD384(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C51BD168(a1, v6);
  v8 = 0;
  sub_1C51BD0CC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

char **sub_1C61FD438(char **result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  char **v5;
  unsigned int v6;
  char *v7;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  uint64_t v11;
  _DWORD *v12;

  v4 = a2;
  v5 = result;
  result[1] = 0;
  v6 = *((_DWORD *)result + 4);
  if (v6)
  {
    v7 = *result;
    v8 = 88 * v6;
    do
    {
      *(_DWORD *)v7 = -1;
      v7 += 88;
      v8 -= 88;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        v12 = 0;
        sub_1C51BD0CC((uint64_t)*v5, *((_DWORD *)v5 + 4), v9, &v12);
        v10 = v12;
        *v12 = *(_DWORD *)v4;
        *((_QWORD *)v10 + 2) = 0x200000000;
        *((_QWORD *)v10 + 1) = v10 + 6;
        v11 = (uint64_t)(v10 + 2);
        if (*(_DWORD *)(v4 + 16))
          sub_1C51BD22C(v11, v4 + 8);
        ++*((_DWORD *)v5 + 2);
        result = sub_1C51BCBA0((char **)(v4 + 8));
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
  return result;
}

double sub_1C61FD518(char **a1, char **a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  double result;

  v4 = *a1;
  v5 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v5)
  {
    v6 = 32 * v5;
    do
    {
      v7 = *(char **)&v4[v6 - 24];
      if (&v4[v6 - 8] != v7)
        free(v7);
      v6 -= 32;
    }
    while (v6);
    v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2))
    free(v4);
  *a1 = *a2;
  result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

uint64_t sub_1C61FD5A0(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  char *v6;
  char *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v12;

  v12 = 0;
  v6 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, 0, 32, &v12);
  v7 = &v6[32 * *(unsigned int *)(a1 + 8)];
  *(_QWORD *)v7 = *a2;
  *((_QWORD *)v7 + 2) = 0x200000000;
  *((_QWORD *)v7 + 1) = v7 + 24;
  v8 = (uint64_t)(v7 + 8);
  if (*(_DWORD *)(a3 + 8))
    sub_1C4EA2F88(v8, a3);
  sub_1C61FCC3C((uint64_t *)a1, (uint64_t)v6);
  v9 = v12;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v6;
  v10 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v10;
  *(_DWORD *)(a1 + 12) = v9;
  return (uint64_t)&v6[32 * v10 - 32];
}

uint64_t sub_1C61FD65C(uint64_t a1)
{
  sub_1C51BD740(a1);
  if ((*(_BYTE *)a1 & 1) == 0)
    MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 8), 8);
  return a1;
}

uint64_t sub_1C61FD698(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;

  v12 = 0;
  result = sub_1C4926528(a2, a3, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C48BE074(a2, (uint64_t)a3, a3, v12);
    v9 = (_QWORD *)result;
    *(_QWORD *)result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t *sub_1C61FD730(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 != *result)
  {
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)(v4 + v7 - 32);
      *(_QWORD *)(v6 + v7 - 24) = v6 + v7 - 8;
      result = (uint64_t *)(v6 + v7 - 24);
      *(result - 1) = v8;
      result[1] = 0x200000000;
      if (*(_DWORD *)(v4 + v7 - 16))
        result = (uint64_t *)sub_1C4EA2F88((uint64_t)result, v4 + v7 - 24);
      v7 -= 32;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  v9 = *v3;
  *v3 = v6;
  a2[1] = v9;
  v10 = v3[1];
  v3[1] = a2[2];
  a2[2] = v10;
  v11 = v3[2];
  v3[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

void llvm::MachineSSAUpdater::~MachineSSAUpdater(llvm::MachineSSAUpdater *this)
{
  _QWORD *v1;

  v1 = *(_QWORD **)this;
  if (*(_QWORD *)this)
  {
    MEMORY[0x1CAA32FB4](*v1, 8);
    MEMORY[0x1CAA32FC0](v1, 0x1020C405AF6BDC9);
  }
}

uint64_t llvm::MachineSSAUpdater::Initialize(uint64_t a1, uint64_t a2)
{
  unsigned int *v4;
  uint64_t result;

  v4 = *(unsigned int **)a1;
  if (v4)
  {
    result = (uint64_t)sub_1C61446F0(v4);
  }
  else
  {
    result = operator new();
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 16) = 0;
    *(_QWORD *)a1 = result;
  }
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

uint64_t llvm::MachineSSAUpdater::Initialize(uint64_t a1, int a2)
{
  return llvm::MachineSSAUpdater::Initialize(a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) + 16 * (a2 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8);
}

_QWORD *llvm::MachineSSAUpdater::AddAvailableValue(uint64_t *a1, uint64_t a2, int a3)
{
  _QWORD *result;
  uint64_t v5;

  v5 = a2;
  result = sub_1C6144C70(*a1, &v5);
  *((_DWORD *)result + 2) = a3;
  return result;
}

uint64_t sub_1C61FD93C(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t *v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  _QWORD v13[101];

  v13[100] = *MEMORY[0x1E0C80C00];
  v10 = a2;
  v11 = v13;
  v12 = 0x6400000000;
  v4 = sub_1C61FDAAC((uint64_t)a1, a2, (uint64_t)&v11);
  if ((_DWORD)v12)
  {
    sub_1C51BF010(a1, (uint64_t *)&v11, v4);
    sub_1C51BF194((uint64_t)v11, v12);
    sub_1C51BF238(a1, (uint64_t)&v11);
    v8 = *(unsigned int *)(*(_QWORD *)(sub_1C6180A54((uint64_t)(a1 + 3), &v10)[1] + 16) + 8);
  }
  else
  {
    v5 = (unint64_t *)(a2 + 48);
    for (i = *(_QWORD *)(a2 + 56); (unint64_t *)i != v5; i = *(_QWORD *)(i + 8))
    {
      if (**(_WORD **)(i + 16) && **(_WORD **)(i + 16) != 69)
      {
        v5 = (unint64_t *)i;
        break;
      }
    }
    sub_1C51BED80(0xAu, a2, v5, *(_QWORD *)(*a1 + 8), *(_QWORD *)(*a1 + 32), *(_QWORD *)(*a1 + 24));
    v8 = *(unsigned int *)(*(_QWORD *)(v7 + 32) + 4);
    *((_DWORD *)sub_1C6144C70(a1[1], &v10) + 2) = v8;
  }
  if (v11 != v13)
    free(v11);
  return v8;
}

uint64_t sub_1C61FDA78(uint64_t a1)
{
  sub_1C4926AE8(a1 + 48);
  MEMORY[0x1CAA32FB4](*(_QWORD *)(a1 + 24), 8);
  return a1;
}

unint64_t sub_1C61FDAAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int i;
  uint64_t v14;
  int j;
  _DWORD *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  _QWORD *v35;
  uint64_t *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  _BYTE v47[80];
  void *v48;
  uint64_t v49;
  _BYTE v50[512];
  _QWORD *v51;
  uint64_t v52;
  _QWORD v53[12];

  v53[10] = *MEMORY[0x1E0C80C00];
  v42 = a2;
  v51 = v53;
  v52 = 0xA00000000;
  v48 = v50;
  v49 = 0x4000000000;
  v5 = a1 + 48;
  v6 = sub_1C484358C(a1 + 48, 64, 3);
  *(_QWORD *)v6 = a2;
  *(_DWORD *)(v6 + 8) = 0;
  *(_QWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  v7 = a1 + 24;
  *(_QWORD *)(v6 + 48) = 0;
  *(_QWORD *)(v6 + 56) = 0;
  sub_1C6180A54(a1 + 24, &v42)[1] = v6;
  v8 = v49;
  if (v49 >= HIDWORD(v49))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, (uint64_t)v50, v49 + 1, 8);
    v8 = v49;
  }
  *((_QWORD *)v48 + v8) = v6;
  v45 = v47;
  v46 = 0xA00000000;
  v9 = __CFADD__((_DWORD)v49, 1);
  v10 = v49 + 1;
  LODWORD(v49) = v49 + 1;
  if (!v9)
  {
    do
    {
      v23 = *((_QWORD *)v48 + v10 - 1);
      LODWORD(v49) = v10 - 1;
      LODWORD(v46) = 0;
      sub_1C514C6DC((unsigned int *)&v45, (uint64_t)v45, *(char **)(*(_QWORD *)v23 + 64), *(char **)(*(_QWORD *)v23 + 72));
      v24 = v46;
      *(_DWORD *)(v23 + 40) = v46;
      if ((_DWORD)v24)
      {
        v25 = sub_1C484358C(v5, 8 * v24, 3);
        v26 = *(_DWORD *)(v23 + 40);
        *(_QWORD *)(v23 + 48) = v25;
        if (v26)
        {
          v27 = 0;
          do
          {
            v28 = v27;
            v29 = *((_QWORD *)v45 + v27);
            v41 = v29;
            v30 = sub_1C6180A54(a1 + 24, &v41);
            v31 = v30[1];
            if (v31)
            {
              *(_QWORD *)(*(_QWORD *)(v23 + 48) + 8 * v28) = v31;
            }
            else
            {
              v35 = v30;
              v36 = *(uint64_t **)(a1 + 8);
              v43 = 0;
              v44 = v29;
              if (sub_1C61252B8(v36, &v44, &v43))
                v37 = *(_DWORD *)(v43 + 8);
              else
                v37 = 0;
              v32 = sub_1C484358C(v5, 64, 3);
              v33 = v32;
              *(_QWORD *)v32 = v29;
              *(_DWORD *)(v32 + 8) = v37;
              if (v37)
                v34 = v32;
              else
                v34 = 0;
              *(_QWORD *)(v32 + 16) = v34;
              *(_DWORD *)(v32 + 24) = 0;
              *(_QWORD *)(v32 + 32) = 0;
              *(_DWORD *)(v32 + 40) = 0;
              *(_QWORD *)(v32 + 48) = 0;
              *(_QWORD *)(v32 + 56) = 0;
              v35[1] = v32;
              *(_QWORD *)(*(_QWORD *)(v23 + 48) + 8 * v28) = v32;
              if (v37)
              {
                v38 = v52;
                if (v52 >= (unint64_t)HIDWORD(v52))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, (uint64_t)v53, v52 + 1, 8);
                  v38 = v52;
                }
                v51[v38] = v33;
                LODWORD(v52) = v52 + 1;
              }
              else
              {
                v39 = v49;
                if (v49 >= (unint64_t)HIDWORD(v49))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, (uint64_t)v50, v49 + 1, 8);
                  v39 = v49;
                }
                *((_QWORD *)v48 + v39) = v33;
                LODWORD(v49) = v49 + 1;
              }
            }
            v27 = v28 + 1;
          }
          while ((_DWORD)v28 + 1 != *(_DWORD *)(v23 + 40));
        }
      }
      else
      {
        *(_QWORD *)(v23 + 48) = 0;
      }
      v10 = v49;
    }
    while ((_DWORD)v49);
  }
  v11 = sub_1C484358C(v5, 64, 3);
  *(_QWORD *)v11 = 0;
  *(_DWORD *)(v11 + 8) = 0;
  *(_QWORD *)(v11 + 16) = 0;
  *(_DWORD *)(v11 + 24) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 48) = 0;
  *(_QWORD *)(v11 + 56) = 0;
  v12 = v52;
  for (i = v49; (_DWORD)v52; v12 = v52)
  {
    v14 = v51[v12 - 1];
    LODWORD(v52) = v12 - 1;
    *(_QWORD *)(v14 + 32) = v11;
    *(_DWORD *)(v14 + 24) = -1;
    if (i >= HIDWORD(v49))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, (uint64_t)v50, i + 1, 8);
      i = v49;
    }
    *((_QWORD *)v48 + i) = v14;
    i = v49 + 1;
    LODWORD(v49) = v49 + 1;
  }
  for (j = 1; i; LODWORD(v49) = i)
  {
    while (1)
    {
      v16 = (_DWORD *)*((_QWORD *)v48 + i - 1);
      if (v16[6] == -2)
        break;
      v16[6] = -2;
      v18 = *(uint64_t **)(*(_QWORD *)v16 + 88);
      v17 = *(uint64_t **)(*(_QWORD *)v16 + 96);
      if (v18 != v17)
      {
        do
        {
          v19 = sub_1C6180A54(v7, v18)[1];
          if (v19 && !*(_DWORD *)(v19 + 24))
          {
            *(_DWORD *)(v19 + 24) = -1;
            v20 = v49;
            if (v49 >= (unint64_t)HIDWORD(v49))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, (uint64_t)v50, v49 + 1, 8);
              v20 = v49;
            }
            *((_QWORD *)v48 + v20) = v19;
            LODWORD(v49) = v49 + 1;
          }
          ++v18;
        }
        while (v18 != v17);
        i = v49;
      }
      if (!i)
        goto LABEL_27;
    }
    v16[6] = j;
    if (!v16[2])
    {
      v21 = *(unsigned int *)(a3 + 8);
      if (v21 >= *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, a3 + 16, v21 + 1, 8);
        v21 = *(unsigned int *)(a3 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a3 + 8 * v21) = v16;
      ++*(_DWORD *)(a3 + 8);
      i = v49;
    }
    ++j;
    --i;
  }
LABEL_27:
  *(_DWORD *)(v11 + 24) = j;
  if (v45 != v47)
    free(v45);
  if (v48 != v50)
    free(v48);
  if (v51 != v53)
    free(v51);
  return v11;
}

_QWORD *sub_1C61FDFB0(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *(_QWORD *)(a2 + 56);
  if (v3 != a2 + 48)
  {
    v5 = result;
    v6 = *(_QWORD *)(a2 + 56);
    while (!**(_WORD **)(v6 + 16) || **(_WORD **)(v6 + 16) == 69)
    {
      v6 = *(_QWORD *)(v6 + 8);
      if (v6 == a2 + 48)
      {
        v6 = a2 + 48;
        break;
      }
    }
    while (v3 != v6)
    {
      result = (_QWORD *)sub_1C51BF3D8((uint64_t)v5, v3);
      v7 = *(uint64_t **)a3;
      v8 = *(unsigned int *)(a3 + 8);
      if ((_DWORD)result)
        return sub_1C61FE138(v5, (uint64_t)v7, v8);
      if ((_DWORD)v8)
      {
        v9 = 8 * v8;
        do
        {
          v10 = *v7++;
          *(_QWORD *)(v10 + 56) = 0;
          v9 -= 8;
        }
        while (v9);
      }
      if (!v3 || (*(_BYTE *)v3 & 4) == 0)
      {
        while ((*(_WORD *)(v3 + 44) & 8) != 0)
          v3 = *(_QWORD *)(v3 + 8);
      }
      v3 = *(_QWORD *)(v3 + 8);
    }
  }
  return result;
}

uint64_t sub_1C61FE088(unsigned int a1, uint64_t a2)
{
  uint64_t result;
  int v3;
  BOOL v4;

  result = llvm::MachineRegisterInfo::getVRegDef(a2, a1);
  if (!result)
    return 0;
  v3 = **(unsigned __int16 **)(result + 16);
  v4 = v3 == 69 || v3 == 0;
  if (!v4 || *(_DWORD *)(result + 40) >= 2u)
    return 0;
  return result;
}

void sub_1C61FE0D0(llvm::MachineInstr *a1, int a2, uint64_t a3)
{
  llvm::MachineFunction *v5;
  _DWORD v6[2];
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *(llvm::MachineFunction **)(a3 + 32);
  v7 = 0;
  v8 = 0;
  v6[0] = 0;
  v6[1] = a2;
  v9 = 0;
  llvm::MachineInstr::addOperand(a1, v5, (const llvm::MachineOperand *)v6);
  v7 = 0;
  v8 = a3;
  v6[0] = 4;
  llvm::MachineInstr::addOperand(a1, v5, (const llvm::MachineOperand *)v6);
}

_QWORD *sub_1C61FE138(_QWORD *result, uint64_t a2, unsigned int a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  if (a3)
  {
    v4 = result;
    v5 = (uint64_t)(result + 3);
    v6 = 8 * a3;
    do
    {
      v7 = *(_QWORD *)(*(_QWORD *)a2 + 56);
      if (v7)
      {
        v9 = *(_QWORD *)(v7 + 24);
        v8 = *(_QWORD *)(v7 + 32);
        v11 = v9;
        v10 = *(_DWORD *)(v8 + 4);
        *((_DWORD *)sub_1C6144C70(v4[1], &v11) + 2) = v10;
        result = sub_1C6180A54(v5, &v11);
        *(_DWORD *)(result[1] + 8) = v10;
      }
      a2 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void llvm::initializeStripDebugMachineModulePass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FCB28);
  if (v2 != -1)
  {
    v5[0] = sub_1C51BF5F0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FCB28, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createStripDebugMachineModulePass(llvm *this)
{
  char v1;
  uint64_t result;

  v1 = (char)this;
  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = &unk_1EF8F6FA2;
  *(_DWORD *)(result + 24) = 4;
  *(_QWORD *)result = &off_1E8146A48;
  *(_BYTE *)(result + 28) = v1;
  return result;
}

void llvm::initializeMachineTraceMetricsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82FB58);
  if (v2 != -1)
  {
    v5[0] = sub_1C51BF9D0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82FB58, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

double llvm::MachineTraceMetrics::MachineTraceMetrics(llvm::MachineTraceMetrics *this)
{
  uint64_t v1;
  double result;

  v1 = sub_1C4776848((uint64_t)this, (uint64_t)&llvm::MachineTraceMetrics::ID);
  *(_QWORD *)v1 = &off_1E8146AF0;
  *(_QWORD *)(v1 + 280) = 0;
  *(_OWORD *)(v1 + 248) = 0u;
  *(_OWORD *)(v1 + 264) = 0u;
  *(_OWORD *)(v1 + 320) = xmmword_1C8663800;
  *(_OWORD *)(v1 + 336) = unk_1C8663810;
  *(_QWORD *)(v1 + 352) = 0;
  *(_OWORD *)(v1 + 288) = llvm::MCSchedModel::Default;
  *(_OWORD *)(v1 + 304) = unk_1C86637F0;
  *(_OWORD *)(v1 + 376) = unk_1C86637F0;
  *(_OWORD *)(v1 + 392) = xmmword_1C8663800;
  *(_OWORD *)(v1 + 408) = unk_1C8663810;
  *(_QWORD *)(v1 + 424) = 0;
  *(_OWORD *)(v1 + 360) = llvm::MCSchedModel::Default;
  *(_OWORD *)(v1 + 448) = 0u;
  *(_OWORD *)(v1 + 464) = 0u;
  *(_OWORD *)(v1 + 432) = 0u;
  *(_QWORD *)(v1 + 480) = v1 + 496;
  *(_QWORD *)(v1 + 488) = 0x1000000000;
  *(_QWORD *)(v1 + 560) = 0;
  *(_QWORD *)(v1 + 568) = v1 + 584;
  *(_QWORD *)&result = 0x400000000;
  *(_QWORD *)(v1 + 576) = 0x400000000;
  *(_QWORD *)(v1 + 616) = v1 + 632;
  *(_QWORD *)(v1 + 632) = 0;
  *(_QWORD *)(v1 + 624) = 0;
  return result;
}

void *llvm::MachineTraceMetrics::getAnalysisUsage(llvm::MachineTraceMetrics *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBranchProbabilityInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineLoopInfo::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::MachineTraceMetrics::runOnMachineFunction(llvm::MachineTraceMetrics *this, llvm::MachineFunction *a2)
{
  const llvm::TargetSubtargetInfo *v3;
  uint64_t v4;
  uint64_t v5;
  char **v6;
  char *v7;

  *((_QWORD *)this + 31) = a2;
  v3 = (const llvm::TargetSubtargetInfo *)*((_QWORD *)a2 + 2);
  *((_QWORD *)this + 32) = (*(uint64_t (**)(const llvm::TargetSubtargetInfo *))(*(_QWORD *)v3 + 104))(v3);
  v4 = (*(uint64_t (**)(const llvm::TargetSubtargetInfo *))(*(_QWORD *)v3 + 176))(v3);
  v5 = *(_QWORD *)(*((_QWORD *)this + 31) + 40);
  *((_QWORD *)this + 33) = v4;
  *((_QWORD *)this + 34) = v5;
  v6 = (char **)**((_QWORD **)this + 1);
  do
  {
    v7 = *v6;
    v6 += 2;
  }
  while (v7 != llvm::MachineLoopInfo::ID);
  *((_QWORD *)this + 35) = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v6 - 1) + 96))(*(v6 - 1), llvm::MachineLoopInfo::ID);
  llvm::TargetSchedModel::init((llvm::MachineTraceMetrics *)((char *)this + 288), v3);
  sub_1C61FEEFC((uint64_t)this + 568, ((*(_QWORD *)(*((_QWORD *)this + 31) + 112) - *(_QWORD *)(*((_QWORD *)this + 31) + 104)) >> 3));
  sub_1C49F6D78((uint64_t)this + 616, *((_DWORD *)this + 84)* ((*(_QWORD *)(*((_QWORD *)this + 31) + 112) - *(_QWORD *)(*((_QWORD *)this + 31) + 104)) >> 3));
  return 0;
}

uint64_t llvm::MachineTraceMetrics::releaseMemory(llvm::MachineTraceMetrics *this)
{
  uint64_t result;

  *((_QWORD *)this + 31) = 0;
  *((_DWORD *)this + 144) = 0;
  result = *((_QWORD *)this + 79);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  *((_QWORD *)this + 79) = 0;
  return result;
}

_DWORD *llvm::MachineTraceMetrics::getResources(llvm::MachineTraceMetrics *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v2;
  _DWORD *v3;
  _BYTE *v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unsigned __int16 *v12;
  _DWORD *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  uint64_t v16;
  int v17;
  _QWORD *v18;
  unsigned int v19;
  int *v20;
  uint64_t v21;
  int *v22;
  int v23;
  int v24;
  int v25;
  void *v26[2];
  _QWORD v27[18];

  v27[16] = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 71) + 8 * *((int *)a2 + 6);
  v3 = (_DWORD *)v2;
  if (*(_DWORD *)v2 != -1)
    return v3;
  *(_BYTE *)(v2 + 4) = 0;
  v7 = (_BYTE *)(v2 + 4);
  v8 = *((unsigned int *)this + 84);
  v26[0] = v27;
  v26[1] = (void *)0x2000000000;
  sub_1C4893E04((char *)v26, v8, 0);
  v9 = *((_QWORD *)a2 + 7);
  if ((const llvm::MachineBasicBlock *)v9 != (const llvm::MachineBasicBlock *)((char *)a2 + 48))
  {
    v10 = 0;
    while (1)
    {
      if ((sub_1C47BEF78(v9) & 1) != 0)
        goto LABEL_6;
      if ((*(_WORD *)(v9 + 44) & 0xC) != 0 && (*(_WORD *)(v9 + 44) & 4) == 0)
        break;
      if ((*(_BYTE *)(*(_QWORD *)(v9 + 16) + 8) & 0x80) != 0)
        goto LABEL_15;
LABEL_16:
      ++v10;
      if (!llvm::TargetSchedModel::hasInstrSchedModel((llvm::MachineTraceMetrics *)((char *)this + 288)))
        goto LABEL_18;
      v12 = (unsigned __int16 *)llvm::TargetSchedModel::resolveSchedClass((llvm::MachineTraceMetrics *)((char *)this + 288), (const llvm::MachineInstr *)v9);
      if ((~v12[4] & 0x1FFF) == 0 || !v12[6])
        goto LABEL_18;
      v13 = v26[0];
      v14 = 4 * v12[6];
      v15 = (unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)this + 58) + 136) + 4 * v12[5] + 2);
      do
      {
        v16 = *(v15 - 1);
        v17 = *v15;
        v15 += 2;
        v13[v16] += v17;
        v14 -= 4;
      }
      while (v14);
LABEL_6:
      if (!v9)
        goto LABEL_21;
LABEL_18:
      if ((*(_BYTE *)v9 & 4) == 0)
      {
LABEL_21:
        while ((*(_WORD *)(v9 + 44) & 8) != 0)
          v9 = *(_QWORD *)(v9 + 8);
      }
      v9 = *(_QWORD *)(v9 + 8);
      if ((const llvm::MachineBasicBlock *)v9 == (const llvm::MachineBasicBlock *)((char *)a2 + 48))
        goto LABEL_29;
    }
    if (!llvm::MachineInstr::hasPropertyInBundle(v9, 128, 1))
      goto LABEL_16;
LABEL_15:
    *v7 = 1;
    goto LABEL_16;
  }
  v10 = 0;
LABEL_29:
  *v3 = v10;
  v18 = v26[0];
  if ((_DWORD)v8)
  {
    v19 = *((_DWORD *)a2 + 6) * v8;
    v20 = (int *)*((_QWORD *)this + 60);
    v21 = *((_QWORD *)this + 77);
    v22 = (int *)v26[0];
    do
    {
      v24 = *v22++;
      v23 = v24;
      v25 = *v20++;
      *(_DWORD *)(v21 + 4 * v19++) = v25 * v23;
      --v8;
    }
    while (v8);
  }
  if (v18 != v27)
    free(v18);
  return v3;
}

llvm::MachineTraceMetrics::Ensemble *llvm::MachineTraceMetrics::Ensemble::Ensemble(llvm::MachineTraceMetrics::Ensemble *this, llvm::MachineTraceMetrics *a2)
{
  uint64_t v3;
  unsigned int v4;

  *(_QWORD *)this = &unk_1E8146BB0;
  *((_QWORD *)this + 1) = (char *)this + 24;
  *((_QWORD *)this + 2) = 0x400000000;
  *((_QWORD *)this + 47) = 0;
  *((_QWORD *)this + 48) = 0;
  *((_DWORD *)this + 98) = 0;
  *((_QWORD *)this + 50) = (char *)this + 416;
  *((_QWORD *)this + 51) = 0;
  *((_QWORD *)this + 52) = (char *)this + 432;
  *((_QWORD *)this + 53) = 0;
  *((_QWORD *)this + 54) = a2;
  sub_1C61FEFF0((uint64_t)this + 8, *((unsigned int *)a2 + 144));
  v3 = *((_QWORD *)this + 54);
  v4 = *(_DWORD *)(v3 + 336);
  sub_1C49F6D78((uint64_t)this + 400, *(unsigned int *)(v3 + 576) * (unint64_t)v4);
  sub_1C49F6D78((uint64_t)this + 416, *(unsigned int *)(*((_QWORD *)this + 54) + 576) * (unint64_t)v4);
  return this;
}

void llvm::MachineTraceMetrics::Ensemble::~Ensemble(llvm::MachineTraceMetrics::Ensemble *this)
{
  char *v2;
  char *v3;
  char *v4;

  *(_QWORD *)this = &unk_1E8146BB0;
  v2 = (char *)this + 416;
  v3 = (char *)*((_QWORD *)this + 52);
  if (v3 != (char *)this + 432)
    free(v3);
  v4 = (char *)*((_QWORD *)this + 50);
  if (v4 != v2)
    free(v4);
  MEMORY[0x1CAA32FB4](*((_QWORD *)this + 47), 8);
  sub_1C61FEF7C((char **)this + 1);
}

void llvm::MachineTraceMetrics::Ensemble::computeDepthResources(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  const llvm::MachineBasicBlock *v9;
  uint64_t v10;
  unsigned int v11;
  _DWORD *Resources;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int *v18;
  int *v19;
  int v20;
  int v21;
  int v22;

  v3 = *((_DWORD *)a2 + 6);
  v4 = v3;
  v5 = *((_QWORD *)this + 1);
  v6 = (unsigned int *)*((_QWORD *)this + 54);
  v7 = v6[84];
  v8 = v7 * v3;
  v9 = *(const llvm::MachineBasicBlock **)(v5 + 88 * v3);
  if (v9)
  {
    v11 = *((_DWORD *)v9 + 6);
    Resources = llvm::MachineTraceMetrics::getResources((llvm::MachineTraceMetrics *)v6, v9);
    v13 = v5 + 88 * v11;
    v14 = v5 + 88 * v4;
    *(_DWORD *)(v14 + 24) = *Resources + *(_DWORD *)(v13 + 24);
    *(_DWORD *)(v14 + 16) = *(_DWORD *)(v13 + 16);
    if ((_DWORD)v7)
    {
      v15 = *((_QWORD *)this + 54);
      v16 = *((_QWORD *)this + 50);
      v17 = *(_DWORD *)(v15 + 336) * v11;
      v18 = (int *)(v16 + 4 * v17);
      v19 = (int *)(*(_QWORD *)(v15 + 616) + 4 * v17);
      do
      {
        v21 = *v18++;
        v20 = v21;
        v22 = *v19++;
        *(_DWORD *)(v16 + 4 * v8++) = v22 + v20;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v10 = v5 + 88 * v3;
    *(_DWORD *)(v10 + 24) = 0;
    *(_DWORD *)(v10 + 16) = v3;
    if ((_DWORD)v7)
      bzero((void *)(*((_QWORD *)this + 50) + 4 * v8), 4 * v7);
  }
}

int *llvm::MachineTraceMetrics::Ensemble::computeHeightResources(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  int v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  int *result;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  int v22;
  int v23;
  int v24;

  v4 = *((_DWORD *)a2 + 6);
  v5 = *((_QWORD *)this + 1);
  v6 = (unsigned int *)*((_QWORD *)this + 54);
  v7 = v6[84];
  v8 = v7 * v4;
  result = llvm::MachineTraceMetrics::getResources((llvm::MachineTraceMetrics *)v6, a2);
  v10 = *result;
  v11 = v5 + 88 * v4;
  *(_DWORD *)(v11 + 28) = *result;
  v12 = (_DWORD *)(v11 + 28);
  v13 = *((_QWORD *)this + 54);
  v14 = *((_DWORD *)a2 + 6);
  v15 = *(unsigned int *)(v13 + 336);
  v16 = (int *)(*(_QWORD *)(v13 + 616) + 4 * (v15 * v14));
  v17 = *(_QWORD *)(v12 - 5);
  if (v17)
  {
    v18 = *(_DWORD *)(v17 + 24);
    v19 = *((_QWORD *)this + 1) + 88 * v18;
    *v12 = *(_DWORD *)(v19 + 28) + v10;
    *(_DWORD *)(v5 + 88 * v4 + 20) = *(_DWORD *)(v19 + 20);
    if ((_DWORD)v7)
    {
      v20 = *((_QWORD *)this + 52);
      v21 = (int *)(v20 + 4 * v18 * v15);
      do
      {
        v23 = *v21++;
        v22 = v23;
        v24 = *v16++;
        *(_DWORD *)(v20 + 4 * v8++) = v24 + v22;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    *(_DWORD *)(v5 + 88 * v4 + 20) = v14;
    if ((_DWORD)v15)
      return (int *)memmove((void *)(*((_QWORD *)this + 52) + 4 * v8), v16, 4 * v15);
  }
  return result;
}

llvm::MachineTraceMetrics::Ensemble *llvm::MachineTraceMetrics::getEnsemble(llvm::MachineTraceMetrics *a1, unsigned int a2)
{
  char *v3;
  llvm::MachineTraceMetrics::Ensemble *result;
  llvm::MachineTraceMetrics::Ensemble **v5;
  llvm::MachineTraceMetrics::Ensemble *v6;

  v3 = (char *)a1 + 8 * a2;
  result = (llvm::MachineTraceMetrics::Ensemble *)*((_QWORD *)v3 + 79);
  if (!result)
  {
    v5 = (llvm::MachineTraceMetrics::Ensemble **)(v3 + 632);
    v6 = (llvm::MachineTraceMetrics::Ensemble *)operator new();
    result = llvm::MachineTraceMetrics::Ensemble::Ensemble(v6, a1);
    *(_QWORD *)result = &off_1E8146BE8;
    *v5 = result;
  }
  return result;
}

void llvm::MachineTraceMetrics::invalidate(llvm::MachineTraceMetrics *this, const llvm::MachineBasicBlock *a2)
{
  llvm::MachineTraceMetrics::Ensemble *v2;

  *(_DWORD *)(*((_QWORD *)this + 71) + 8 * *((int *)a2 + 6)) = -1;
  v2 = (llvm::MachineTraceMetrics::Ensemble *)*((_QWORD *)this + 79);
  if (v2)
    llvm::MachineTraceMetrics::Ensemble::invalidate(v2, a2);
}

_QWORD *llvm::MachineTraceMetrics::Ensemble::addLiveIns(_QWORD *result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  if (a5)
  {
    v5 = result;
    v6 = *(_QWORD *)(a2 + 24);
    v7 = *(unsigned int *)(*(_QWORD *)(a2 + 32) + 32 * a3 + 4);
    v8 = 8 * a5;
    v9 = a4 - 8;
    do
    {
      v10 = *(_QWORD *)(v9 + v8);
      if (v10 == v6)
        break;
      v11 = v5[1] + 88 * *(int *)(v10 + 24);
      v12 = v11 + 40;
      v13 = *(unsigned int *)(v11 + 48);
      if (v13 >= *(unsigned int *)(v11 + 52))
      {
        result = llvm::SmallVectorBase<unsigned int>::grow_pod(v11 + 40, v11 + 56, v13 + 1, 8);
        v13 = *(unsigned int *)(v12 + 8);
      }
      *(_QWORD *)(*(_QWORD *)v12 + 8 * v13) = v7;
      ++*(_DWORD *)(v12 + 8);
      v8 -= 8;
    }
    while (v8);
  }
  return result;
}

llvm::MachineTraceMetrics::Ensemble *llvm::MachineTraceMetrics::Ensemble::getTrace(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  int v4;
  uint64_t v5;

  v4 = *((_DWORD *)a2 + 6);
  v5 = *((_QWORD *)this + 1);
  if (*(_DWORD *)(v5 + 88 * v4 + 24) == -1 || *(_DWORD *)(v5 + 88 * v4 + 28) == -1)
    llvm::MachineTraceMetrics::Ensemble::computeTrace(this, a2);
  if (!*(_BYTE *)(v5 + 88 * v4 + 32))
    llvm::MachineTraceMetrics::Ensemble::computeInstrDepths(this, a2);
  if (!*(_BYTE *)(v5 + 88 * v4 + 33))
    llvm::MachineTraceMetrics::Ensemble::computeInstrHeights(this, a2);
  return this;
}

uint64_t llvm::MachineTraceMetrics::Trace::getInstrSlack(llvm::MachineTraceMetrics::Trace *this, const llvm::MachineInstr *a2)
{
  uint64_t *v3;
  int v4;
  uint64_t v5;
  uint64_t v7;
  const llvm::MachineInstr *v8;

  v3 = (uint64_t *)(*(_QWORD *)this + 376);
  v7 = 0;
  v8 = a2;
  v4 = sub_1C61252B8(v3, &v8, &v7);
  v5 = 0;
  if (v4)
    v5 = *(_QWORD *)(v7 + 8);
  return (*(_DWORD *)(*((_QWORD *)this + 1) + 36) - (HIDWORD(v5) + v5));
}

uint64_t llvm::MachineTraceMetrics::Trace::getPHIDepth(llvm::MachineTraceMetrics::Trace *this, const llvm::MachineInstr *a2)
{
  uint64_t v4;
  uint64_t v5;
  const llvm::MachineInstr **v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  void *v13[2];
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(*(_QWORD *)this + 432);
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 248) + 104)
                 + 0xFFFFFFFDD1745D18
                 * ((*((_QWORD *)this + 1) - *(_QWORD *)(*(_QWORD *)this + 8)) >> 3));
  v13[0] = v14;
  v13[1] = (void *)0x100000000;
  sub_1C51C0E4C(a2, (uint64_t)v13, v5, *(_QWORD *)(v4 + 272));
  v6 = (const llvm::MachineInstr **)v13[0];
  v7 = *(_QWORD *)v13[0];
  v8 = (uint64_t *)(*(_QWORD *)this + 376);
  v11 = 0;
  v12 = v7;
  if (sub_1C61252B8(v8, &v12, &v11))
    v9 = *(unsigned int *)(v11 + 8);
  else
    v9 = 0;
  if ((sub_1C47BEF78((uint64_t)*v6) & 1) == 0)
    v9 = llvm::TargetSchedModel::computeOperandLatency((llvm::TargetSchedModel *)(*(_QWORD *)(*(_QWORD *)this + 432) + 288), *v6, *((unsigned int *)v6 + 2), a2, *((unsigned int *)v6 + 3))+ v9;
  if (v13[0] != v14)
    free(v13[0]);
  return v9;
}

void sub_1C61FEDB0(llvm::Pass *a1)
{
  sub_1C61FEE94(a1);
  JUMPOUT(0x1CAA32FC0);
}

double llvm::callDefaultCtor<llvm::MachineTraceMetrics>()
{
  llvm::MachineTraceMetrics *v0;

  v0 = (llvm::MachineTraceMetrics *)operator new();
  return llvm::MachineTraceMetrics::MachineTraceMetrics(v0);
}

uint64_t sub_1C61FEDFC(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t result;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;

  v12 = 0;
  result = sub_1C4926528(a2, a3, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C49D7988(a2, (uint64_t)a3, a3, v12);
    v9 = (_QWORD *)result;
    *(_QWORD *)result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

void sub_1C61FEE94(llvm::Pass *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;

  *(_QWORD *)a1 = &off_1E8146AF0;
  v2 = (_QWORD *)*((_QWORD *)a1 + 77);
  if (v2 != (_QWORD *)((char *)a1 + 632))
    free(v2);
  v3 = (_QWORD *)*((_QWORD *)a1 + 71);
  if (v3 != (_QWORD *)((char *)a1 + 584))
    free(v3);
  v4 = (_QWORD *)*((_QWORD *)a1 + 60);
  if (v4 != (_QWORD *)((char *)a1 + 496))
    free(v4);
  sub_1C4926674(a1);
}

void sub_1C61FEEFC(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, a1 + 16, a2, 8);
        v2 = *(unsigned int *)(a1 + 8);
      }
      if (v2 != a2)
        memset_pattern16((void *)(*(_QWORD *)a1 + 8 * v2), &unk_1C85FB530, 8 * a2 - 8 * v2);
    }
    *(_DWORD *)(a1 + 8) = a2;
  }
}

char **sub_1C61FEF7C(char **a1)
{
  char *v2;
  unsigned int v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    v4 = 88 * v3;
    do
    {
      v5 = *(char **)&v2[v4 - 48];
      if (&v2[v4 - 32] != v5)
        free(v5);
      v4 -= 88;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

void sub_1C61FEFF0(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  void **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2)
      {
        sub_1C61FF0DC(a1, a2);
        v2 = *(unsigned int *)(a1 + 8);
      }
      if (v2 != a2)
      {
        v7 = *(_QWORD *)a1 + 88 * a2;
        v8 = *(_QWORD *)a1 + 88 * v2;
        do
        {
          *(_OWORD *)(v8 + 32) = 0uLL;
          *(_OWORD *)(v8 + 48) = 0uLL;
          *(_QWORD *)(v8 + 80) = 0;
          *(_OWORD *)(v8 + 64) = 0uLL;
          *(_OWORD *)v8 = 0uLL;
          *(_OWORD *)(v8 + 16) = 0uLL;
          *(_QWORD *)(v8 + 24) = -1;
          *(_QWORD *)(v8 + 40) = v8 + 56;
          *(_DWORD *)(v8 + 52) = 4;
          v8 += 88;
        }
        while (v8 != v7);
      }
    }
    else
    {
      v5 = (void **)(*(_QWORD *)a1 + 88 * v2 - 48);
      v6 = 88 * a2 - 88 * v2;
      do
      {
        if (v5 + 2 != *v5)
          free(*v5);
        v5 -= 11;
        v6 += 88;
      }
      while (v6);
    }
    *(_DWORD *)(a1 + 8) = a2;
  }
}

void sub_1C61FF0DC(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 88, &v5);
  sub_1C61FF148((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C61FF148(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v4 = *a1;
    v5 = *a1 + 88 * v2;
    v6 = (_QWORD *)(a2 + 40);
    v7 = v4 + 40;
    do
    {
      v8 = *(_OWORD *)(v7 - 40);
      v9 = *(_QWORD *)(v7 - 8);
      *(_OWORD *)(v6 - 3) = *(_OWORD *)(v7 - 24);
      *(_OWORD *)(v6 - 5) = v8;
      *(v6 - 1) = v9;
      *v6 = v6 + 2;
      v6[1] = 0x400000000;
      if (*(_DWORD *)(v7 + 8))
        v6 = (_QWORD *)sub_1C614D378((uint64_t)v6, v7);
      v10 = v7 - 40;
      v6 += 11;
      v7 += 88;
    }
    while (v10 + 88 != v5);
    v11 = *((_DWORD *)a1 + 2);
    if (v11)
    {
      v12 = *a1;
      v13 = 88 * v11;
      do
      {
        v14 = *(void **)(v12 + v13 - 48);
        if ((void *)(v12 + v13 - 32) != v14)
          free(v14);
        v13 -= 88;
      }
      while (v13);
    }
  }
}

_DWORD *sub_1C61FF21C(uint64_t a1, unsigned int *a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  _DWORD *result;
  unint64_t v9;
  uint64_t v10;
  __int128 v11;

  v3 = *a2;
  v4 = *(_QWORD *)(a1 + 208);
  v5 = *(unsigned __int8 *)(v4 + v3);
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_QWORD *)a1;
  if (v6 <= v5)
  {
LABEL_4:
    result = (_DWORD *)(v7 + 24 * v6);
  }
  else
  {
    while (1)
    {
      result = (_DWORD *)(v7 + 24 * v5);
      if (*result == (_DWORD)v3)
        break;
      v5 += 256;
      if (v5 >= v6)
        goto LABEL_4;
    }
  }
  if (result == (_DWORD *)(v7 + 24 * v6))
  {
    *(_BYTE *)(v4 + v3) = v6;
    v9 = sub_1C4DC1E54(a1, (unint64_t)a2);
    v10 = *(_QWORD *)a1 + 24 * *(unsigned int *)(a1 + 8);
    v11 = *(_OWORD *)v9;
    *(_QWORD *)(v10 + 16) = *(_QWORD *)(v9 + 16);
    *(_OWORD *)v10 = v11;
    LODWORD(v10) = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v10;
    return (_DWORD *)(*(_QWORD *)a1 + 24 * v10 - 24);
  }
  return result;
}

void llvm::initializeMachineVerifierPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82FB60);
  if (v2 != -1)
  {
    v5[0] = sub_1C51C3714;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82FB60, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

BOOL llvm::MachineFunction::verify(llvm::MachineFunction *this, llvm::Pass *a2, const char *a3, int a4)
{
  int v5;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  const char *v11;
  __int16 v12;
  uint64_t v13[4];
  _QWORD v14[13];
  int v15;
  _QWORD v16[10];
  _DWORD v17[14];
  __int128 v18;
  int v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD v22[10];
  _QWORD v23[10];
  _QWORD v24[10];
  _OWORD v25[3];
  uint64_t v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v14[0] = a2;
  v14[1] = a3;
  v14[10] = v16;
  v14[11] = v16;
  v14[12] = 8;
  v15 = 0;
  v16[8] = v17;
  v16[9] = 0x600000000;
  v17[12] = 0;
  v18 = 0u;
  v19 = 0;
  v20 = v22;
  v21 = 0x1000000000;
  v22[8] = v23;
  v22[9] = 0x1000000000;
  v23[8] = v24;
  v23[9] = 0x1000000000;
  v24[8] = v25;
  v24[9] = 0x400000000;
  v27 = 0;
  v26 = 0;
  v25[2] = 0u;
  v5 = sub_1C51C3A7C((uint64_t)v14, (uint64_t)this);
  sub_1C51CBCF8((uint64_t)v14);
  if (a4 && v5)
  {
    v11 = "Found ";
    v12 = 259;
    v10 = 264;
    LODWORD(v9[0]) = v5;
    sub_1C6131AAC((uint64_t *)&v11, v9, (uint64_t)v13);
    v7 = " machine code errors.";
    v8 = 259;
    sub_1C6131AAC(v13, (uint64_t *)&v7, (uint64_t)v14);
    llvm::report_fatal_error((uint64_t)v14, 1);
  }
  return v5 == 0;
}

void sub_1C61FF4A8(llvm::SmallPtrSetImplBase *this@<X1>, uint64_t a2@<X0>, _QWORD *a3@<X8>)
{
  _BYTE *v4;
  uint64_t v5;
  void *__p;
  _BYTE *v7;

  sub_1C61E5F8C(&v5, *(_QWORD *)(*(_QWORD *)a2 + 328), this);
  v4 = __p;
  *a3 = v5;
  a3[2] = 0;
  a3[3] = 0;
  a3[1] = 0;
  sub_1C4D6CDA0(a3 + 1, v4, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v4) >> 3));
  if (__p)
  {
    v7 = __p;
    operator delete(__p);
  }
}

unsigned int *sub_1C61FF520(unsigned int *result, unsigned __int16 *a2, uint64_t a3)
{
  unsigned int *v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  int v14;
  int v15;

  v5 = result;
  v6 = (unsigned __int16 *)*((_QWORD *)a2 + 1);
  v7 = *(unsigned __int16 **)(a3 + 8);
  if (v6 == v7)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = (unsigned __int16 *)*((_QWORD *)a2 + 1);
    do
    {
      ++v8;
      if (!*v9++)
        v9 = 0;
    }
    while (v9 != v7);
  }
  v11 = result[2];
  if (v8 + v11 > (unint64_t)result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v8 + v11, 4);
    v6 = (unsigned __int16 *)*((_QWORD *)a2 + 1);
    v7 = *(unsigned __int16 **)(a3 + 8);
    v11 = v5[2];
  }
  if (v6 != v7)
  {
    v12 = (_DWORD *)(*(_QWORD *)v5 + 4 * v11);
    LOWORD(v13) = a2[8];
    v14 = *a2;
    do
    {
      *v12++ = (unsigned __int16)v13;
      v15 = *v6++;
      v13 = v15 + v14;
      if (!v15)
        v6 = 0;
      v14 = v13;
    }
    while (v6 != v7);
  }
  v5[2] = v11 + v8;
  return result;
}

void sub_1C61FF5F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  _OWORD v7[4];
  void *v8[2];
  _OWORD v9[8];
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  _QWORD v14[17];

  v14[16] = *MEMORY[0x1E0C80C00];
  sub_1C486F76C((uint64_t)&v11, a2);
  v8[0] = 0;
  memset(v9, 0, sizeof(v9));
  v10 = 0;
  memset(v7, 0, sizeof(v7));
  v4 = (char *)v7 + 8;
  v5 = (char *)v7 + 8;
  v6 = 8;
  v8[1] = (char *)v9 + 8;
  DWORD1(v9[0]) = 8;
  sub_1C51D0DEC((uint64_t)&v11, (uint64_t)&v4, a1, v3);
  if (v8[1] != (char *)v9 + 8)
    free(v8[1]);
  if (v5 != v4)
    free(v5);
  if (v13 != v14)
    free(v13);
  if (v12 != v11)
    free(v12);
}

_DWORD *sub_1C61FF704(_DWORD *result, int a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;

  if (a2)
  {
    v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (result[4] <= v4)
      return sub_1C4978DF8((uint64_t)result, v4 + 1);
  }
  return result;
}

void llvm::initializeMIRAddFSDiscriminatorsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FCB30);
  if (v2 != -1)
  {
    v5[0] = sub_1C51D3DC4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FCB30, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createMIRAddFSDiscriminatorsPass(int a1)
{
  uint64_t v2;
  uint64_t result;
  int v4;

  v2 = operator new();
  result = sub_1C4776848(v2, (uint64_t)&llvm::MIRAddFSDiscriminators::ID);
  *(_QWORD *)result = &off_1E8146CE8;
  v4 = 6 * a1 + 2;
  if (!a1)
    v4 = 0;
  *(_DWORD *)(result + 256) = v4;
  *(_DWORD *)(result + 260) = 6 * a1 + 7;
  return result;
}

void sub_1C61FF824(llvm::Pass *a1)
{
  sub_1C4926674(a1);
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C61FF848()
{
  return "Add FS discriminators in MIR";
}

double llvm::callDefaultCtor<llvm::MIRAddFSDiscriminators>()
{
  uint64_t v0;
  _QWORD *v1;
  double result;

  v0 = operator new();
  v1 = (_QWORD *)sub_1C4776848(v0, (uint64_t)&llvm::MIRAddFSDiscriminators::ID);
  *v1 = &off_1E8146CE8;
  *(_QWORD *)&result = 0xD00000008;
  v1[32] = 0xD00000008;
  return result;
}

uint64_t sub_1C61FF8A4(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;

  if (a2)
  {
    v2 = result;
    v6 = xmmword_1C85F6FF0;
    v7 = -1;
    v4 = xmmword_1C85FAB10;
    v5 = 0x100000001;
    v3 = 48 * a2;
    do
    {
      result = sub_1C61FF93C(v2, (uint64_t)&v6);
      if ((result & 1) == 0)
      {
        result = sub_1C61FF93C(v2, (uint64_t)&v4);
        if ((result & 1) == 0)
          result = MEMORY[0x1CAA32FB4](*(_QWORD *)(v2 + 24), 8);
      }
      v2 += 48;
      v3 -= 48;
    }
    while (v3);
  }
  return result;
}

BOOL sub_1C61FF93C(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  size_t v7;

  v4 = *(const void **)a1;
  v5 = *(const void **)a2;
  if (v5 == (const void *)-2)
  {
    if (v4 != (const void *)-2)
      return 0;
  }
  else
  {
    if (v5 == (const void *)-1)
    {
      if (v4 == (const void *)-1)
        return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20);
      return 0;
    }
    v7 = *(_QWORD *)(a2 + 8);
    if (*(_QWORD *)(a1 + 8) != v7 || v7 && memcmp(v4, v5, v7))
      return 0;
  }
  return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20);
}

uint64_t sub_1C61FF9C0(uint64_t a1, uint64_t a2)
{
  char v4;
  uint64_t v5;
  uint64_t v7;

  v7 = 0;
  v4 = sub_1C61FFA40(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C61FFC58(a1, a2, v7);
    *(_OWORD *)v5 = *(_OWORD *)a2;
    *(_DWORD *)(v5 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(v5 + 20) = *(_DWORD *)(a2 + 20);
    *(_QWORD *)(v5 + 32) = 0;
    *(_QWORD *)(v5 + 40) = 0;
    *(_QWORD *)(v5 + 24) = 0;
  }
  return v5;
}

uint64_t sub_1C61FFA40(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BOOL4 v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;

  if (a2)
  {
    v16 = xmmword_1C85F6FF0;
    v17 = -1;
    v14 = xmmword_1C85FAB10;
    v15 = 0x100000001;
    v8 = a2 - 1;
    v9 = sub_1C61FFB70(a3) & (a2 - 1);
    v10 = a1 + 48 * v9;
    if (sub_1C61FF93C(a3, v10))
    {
      result = 1;
    }
    else
    {
      v11 = 0;
      v12 = 1;
      while (!sub_1C61FF93C(v10, (uint64_t)&v16))
      {
        if (sub_1C61FF93C(v10, (uint64_t)&v14) && v11 == 0)
          v11 = v10;
        v9 = (v9 + v12) & v8;
        v10 = a1 + 48 * v9;
        v13 = sub_1C61FF93C(a3, v10);
        result = 1;
        ++v12;
        if (v13)
          goto LABEL_5;
      }
      result = 0;
      if (v11)
        v10 = v11;
    }
LABEL_5:
    *a4 = v10;
  }
  else
  {
    result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1C61FFB70(uint64_t a1)
{
  unint64_t HashValue;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*(_QWORD **)a1, *(_QWORD *)(a1 + 8));
  v3 = sub_1C61FFBE0(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  v4 = (v3 | (HashValue << 32)) + ~((unint64_t)v3 << 32);
  v5 = (v4 ^ (v4 >> 22)) + ~((v4 ^ (v4 >> 22)) << 13);
  v6 = (9 * (v5 ^ (v5 >> 8))) ^ ((9 * (v5 ^ (v5 >> 8))) >> 15);
  return ((v6 + ~(v6 << 27)) >> 31) ^ ((_DWORD)v6 + ~((_DWORD)v6 << 27));
}

uint64_t sub_1C61FFBE0(int a1, int a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  v2 = (((unint64_t)(37 * a2) << 32) - 1) ^ ((((unint64_t)(37 * a2) << 32) - 1) >> 22);
  v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  v5 = ((v4 >> 31) ^ v4 | ((unint64_t)(37 * a1) << 32))
     + ~((unint64_t)((v4 >> 31) ^ v4) << 32);
  v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
  v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
  return ((v7 + ~(v7 << 27)) >> 31) ^ ((_DWORD)v7 + ~((_DWORD)v7 << 27));
}

uint64_t sub_1C61FFC58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  unsigned int v6;
  __int128 v9;
  uint64_t v10;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C51D449C(a1, v6);
  *(_QWORD *)&v9 = 0;
  sub_1C61FFA40(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, (uint64_t *)&v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  v9 = xmmword_1C85F6FF0;
  v10 = -1;
  if (!sub_1C61FF93C(a3, (uint64_t)&v9))
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C61FFD2C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD *v9;
  int v10;
  int v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  _OWORD *v16;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    v7 = *(_QWORD *)result;
    v8 = *(_QWORD *)result + 48 * v6;
    do
    {
      *(_OWORD *)v7 = xmmword_1C85F6FF0;
      *(_QWORD *)(v7 + 16) = -1;
      v7 += 48;
    }
    while (v7 != v8);
  }
  v14 = xmmword_1C85F6FF0;
  v15 = -1;
  v12 = xmmword_1C85FAB10;
  v13 = 0x100000001;
  while (a2 != a3)
  {
    result = sub_1C61FF93C(a2, (uint64_t)&v14);
    if ((result & 1) == 0)
    {
      result = sub_1C61FF93C(a2, (uint64_t)&v12);
      if ((result & 1) == 0)
      {
        v16 = 0;
        sub_1C61FFA40(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), a2, (uint64_t *)&v16);
        v9 = v16;
        *v16 = *(_OWORD *)a2;
        *((_DWORD *)v9 + 4) = *(_DWORD *)(a2 + 16);
        *((_DWORD *)v9 + 5) = *(_DWORD *)(a2 + 20);
        *((_DWORD *)v9 + 10) = 0;
        *((_QWORD *)v9 + 3) = 0;
        *((_QWORD *)v9 + 4) = 0;
        *((_QWORD *)v9 + 3) = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a2 + 24) = 0;
        *((_DWORD *)v9 + 8) = *(_DWORD *)(a2 + 32);
        *(_DWORD *)(a2 + 32) = 0;
        v10 = *((_DWORD *)v9 + 9);
        *((_DWORD *)v9 + 9) = *(_DWORD *)(a2 + 36);
        *(_DWORD *)(a2 + 36) = v10;
        v11 = *((_DWORD *)v9 + 10);
        *((_DWORD *)v9 + 10) = *(_DWORD *)(a2 + 40);
        *(_DWORD *)(a2 + 40) = v11;
        ++*(_DWORD *)(v5 + 8);
        result = MEMORY[0x1CAA32FB4](0, 8);
      }
    }
    a2 += 48;
  }
  return result;
}

uint64_t sub_1C61FFE7C(uint64_t a1, uint64_t a2)
{
  char v4;
  uint64_t v5;
  uint64_t v7;

  v7 = 0;
  v4 = sub_1C61FFEF4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C620001C(a1, a2, v7);
    *(_OWORD *)v5 = *(_OWORD *)a2;
    *(_DWORD *)(v5 + 16) = *(_DWORD *)(a2 + 16);
    *(_QWORD *)(v5 + 20) = *(unsigned int *)(a2 + 20);
  }
  return v5;
}

uint64_t sub_1C61FFEF4(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BOOL4 v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;

  if (a2)
  {
    v16 = xmmword_1C85F6FF0;
    v17 = -1;
    v14 = xmmword_1C85FAB10;
    v15 = 0x100000001;
    v8 = a2 - 1;
    v9 = sub_1C61FFB70(a3) & (a2 - 1);
    v10 = a1 + 32 * v9;
    if (sub_1C61FF93C(a3, v10))
    {
      result = 1;
    }
    else
    {
      v11 = 0;
      v12 = 1;
      while (!sub_1C61FF93C(v10, (uint64_t)&v16))
      {
        if (sub_1C61FF93C(v10, (uint64_t)&v14) && v11 == 0)
          v11 = v10;
        v9 = ((_DWORD)v9 + v12) & v8;
        v10 = a1 + 32 * v9;
        v13 = sub_1C61FF93C(a3, v10);
        result = 1;
        ++v12;
        if (v13)
          goto LABEL_5;
      }
      result = 0;
      if (v11)
        v10 = v11;
    }
LABEL_5:
    *a4 = v10;
  }
  else
  {
    result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1C620001C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  unsigned int v6;
  __int128 v9;
  uint64_t v10;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C51D4570(a1, v6);
  *(_QWORD *)&v9 = 0;
  sub_1C61FFEF4(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, (uint64_t *)&v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  v9 = xmmword_1C85F6FF0;
  v10 = -1;
  if (!sub_1C61FF93C(a3, (uint64_t)&v9))
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C62000F0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  _OWORD *v14;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD *)result;
    v8 = *(_QWORD *)result + 32 * v6;
    do
    {
      *(_OWORD *)v7 = xmmword_1C85F6FF0;
      *(_QWORD *)(v7 + 16) = -1;
      v7 += 32;
    }
    while (v7 != v8);
  }
  v12 = xmmword_1C85F6FF0;
  v13 = -1;
  v10 = xmmword_1C85FAB10;
  v11 = 0x100000001;
  while (a2 != a3)
  {
    result = sub_1C61FF93C(a2, (uint64_t)&v12);
    if ((result & 1) == 0)
    {
      result = sub_1C61FF93C(a2, (uint64_t)&v10);
      if ((result & 1) == 0)
      {
        v14 = 0;
        result = sub_1C61FFEF4(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), a2, (uint64_t *)&v14);
        v9 = v14;
        *v14 = *(_OWORD *)a2;
        v9[4] = *(_DWORD *)(a2 + 16);
        v9[5] = *(_DWORD *)(a2 + 20);
        v9[6] = *(_DWORD *)(a2 + 24);
        ++*(_DWORD *)(v5 + 8);
      }
    }
    a2 += 32;
  }
  return result;
}

void llvm::initializeMIRProfileLoaderPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FCB38);
  if (v2 != -1)
  {
    v5[0] = sub_1C51D4638;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FCB38, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t *llvm::MIRProfileLoader::setBranchProbs(uint64_t *this, llvm::MachineFunction *a2)
{
  char *v2;
  char *v3;
  llvm::MachineBlockFrequencyInfo **v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  llvm::MachineBlockFrequencyInfo **v19;
  unint64_t v20;
  uint64_t MBPI;
  int EdgeProbability;
  unint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  int v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;

  v2 = (char *)a2 + 320;
  v3 = (char *)*((_QWORD *)a2 + 41);
  if (v3 != (char *)a2 + 320)
  {
    v4 = (llvm::MachineBlockFrequencyInfo **)this;
    v5 = (uint64_t)(this + 115);
    v6 = this + 4;
    v7 = (uint64_t)(this + 7);
    do
    {
      v30 = v3;
      if (((*((_QWORD *)v3 + 12) - *((_QWORD *)v3 + 11)) & 0x7FFFFFFF0) != 0)
      {
        v29 = 0;
        v29 = sub_1C6180A54(v5, (uint64_t *)&v30)[1];
        this = sub_1C61BEB98(v6, &v29);
        v8 = (uint64_t *)*((_QWORD *)v3 + 11);
        v9 = (uint64_t *)*((_QWORD *)v3 + 12);
        if (v8 != v9)
        {
          v10 = 0;
          do
          {
            v11 = *v8++;
            v27 = v3;
            v28 = v11;
            this = sub_1C6200D70(v7, (uint64_t *)&v27);
            v10 += this[2];
          }
          while (v8 != v9);
          if (v10)
          {
            if (HIDWORD(v10))
            {
              v12 = v10 / 0xFFFFFFFF + 1;
              v10 /= (v10 / 0xFFFFFFFF) + 1;
            }
            else
            {
              LODWORD(v12) = 1;
            }
            v13 = *((_QWORD *)v3 + 11);
            v25 = (uint64_t *)*((_QWORD *)v3 + 12);
            if ((uint64_t *)v13 != v25)
            {
              v23 = v12;
              v24 = v6;
              v14 = (uint64_t *)*((_QWORD *)v3 + 11);
              do
              {
                v15 = v5;
                v16 = *v14;
                v27 = v3;
                v28 = v16;
                v17 = v7;
                v18 = sub_1C6200D70(v7, (uint64_t *)&v27);
                v19 = v4;
                v20 = v18[2] / v23;
                MBPI = llvm::MachineBlockFrequencyInfo::getMBPI(v4[143]);
                EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(MBPI, v3, v13);
                this = (uint64_t *)llvm::BranchProbability::BranchProbability(&v26, v20, v10);
                if (EdgeProbability != v26)
                  this = llvm::MachineBasicBlock::setSuccProbability(v3, v13, v26);
                ++v14;
                v13 += 8;
                v5 = v15;
                v4 = v19;
                v6 = v24;
                v7 = v17;
              }
              while (v14 != v25);
            }
          }
        }
      }
      v3 = (char *)*((_QWORD *)v3 + 1);
    }
    while (v3 != v2);
  }
  return this;
}

unint64_t sub_1C6200418(llvm::LLVMContext **a1)
{
  uint64_t v2;
  unint64_t v3;
  llvm::sampleprof::SampleProfileReaderItaniumRemapper *v5;

  v2 = (*((uint64_t (**)(llvm::LLVMContext **))*a1 + 3))(a1);
  if ((_DWORD)v2)
  {
    v3 = v2 & 0xFFFFFFFF00000000;
  }
  else
  {
    v5 = a1[14];
    if (v5)
      llvm::sampleprof::SampleProfileReaderItaniumRemapper::applyRemapping(v5, a1[6]);
    llvm::sampleprof::FunctionSamples::UseMD5 = (*((uint64_t (**)(llvm::LLVMContext **))*a1 + 9))(a1);
    if (!atomic_load(qword_1EF8F7270))
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EF8F7270, (void *(*)(void))sub_1C5AA3244, (void (*)(void *))sub_1C5AA3278);
    v3 = 0;
    LODWORD(v2) = 0;
  }
  return v2 | v3;
}

uint64_t llvm::MIRProfileLoader::runOnFunction(llvm::MIRProfileLoader *this, llvm::Function **a2)
{
  llvm::Value *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[2];
  int v12;

  v4 = *a2;
  sub_1C620057C((uint64_t)this);
  v5 = *((_QWORD *)this + 132);
  v6 = sub_1C6200B8C(v4);
  v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v6, v7);
  *((_QWORD *)this + 133) = v8;
  if (!v8 || !*(_QWORD *)(v8 + 56) || !sub_1C62005F0(*a2))
    return 0;
  v11[0] = 0;
  v11[1] = 0;
  v12 = 0;
  v9 = sub_1C62006C0(this, (uint64_t ****)a2, (uint64_t)v11);
  llvm::MIRProfileLoader::setBranchProbs((uint64_t *)this, (llvm::MachineFunction *)a2);
  MEMORY[0x1CAA32FB4](v11[0], 8);
  return v9;
}

void sub_1C620057C(uint64_t a1)
{
  sub_1C61446F0((unsigned int *)(a1 + 32));
  sub_1C6201058((unsigned int *)(a1 + 56));
  sub_1C4E4DBF0(a1 + 80);
  *(_DWORD *)(a1 + 376) = 0;
  sub_1C6143384(*(_QWORD **)(a1 + 904));
  *(_QWORD *)(a1 + 896) = a1 + 904;
  *(_QWORD *)(a1 + 912) = 0;
  *(_QWORD *)(a1 + 904) = 0;
  sub_1C61446F0((unsigned int *)(a1 + 920));
  sub_1C62010AC(a1 + 968);
  sub_1C62010AC(a1 + 992);
  sub_1C62011C0((_DWORD *)(a1 + 1016));
  *(_QWORD *)(a1 + 1040) = 0;
}

uint64_t sub_1C62005F0(llvm::Function *a1)
{
  uint64_t Subprogram;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _BYTE v10[40];
  void *v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _BYTE *v17;

  Subprogram = llvm::Function::getSubprogram(a1);
  if (Subprogram)
    return *(unsigned int *)(Subprogram + 24);
  if (!byte_1ED837AD8)
  {
    v4 = **(_QWORD **)a1;
    v9 = 1283;
    v8[0] = (uint64_t)"No debug information found in function ";
    v8[2] = (uint64_t)llvm::Value::getName(a1);
    v8[3] = v5;
    v6 = ": Function profile not used";
    v7 = 259;
    sub_1C4825FE4(v8, (uint64_t *)&v6, (uint64_t)v10);
    v12 = 8;
    v13 = 1;
    v11 = &unk_1E814E700;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = v10;
    llvm::LLVMContext::diagnose(v4, (const llvm::DiagnosticInfo *)&v11);
  }
  return 0;
}

uint64_t sub_1C62006C0(_QWORD *a1, uint64_t ****a2, uint64_t a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;

  v6 = *(_DWORD *)(a3 + 8);
  v7 = sub_1C51D554C((_QWORD *(***)(unint64_t *__return_ptr, _QWORD, uint64_t))a1, (uint64_t)a2);
  if (v6)
    v8 = 1;
  else
    v8 = v7;
  if ((_DWORD)v8 == 1)
  {
    sub_1C6201268((uint64_t)a1, a2, a3);
    sub_1C51D5624((uint64_t)a1, (char *)a2);
    sub_1C62012C8(a1, (uint64_t)a2, a3);
  }
  return v8;
}

uint64_t llvm::MIRProfileLoaderPass::runOnMachineFunction(llvm::MIRProfileLoaderPass *this, llvm::MachineFunction *a2)
{
  uint64_t v2;
  void **v6;
  void *v7;
  _QWORD *v8;
  void **v9;
  void *v10;
  uint64_t v11;
  char **v12;
  char *v13;
  uint64_t v14;
  char **v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char **v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  llvm::MachineBlockFrequencyInfo *v23;
  uint64_t v24;
  llvm::MachineBlockFrequencyInfo *v25;
  const llvm::MachineBranchProbabilityInfo *MBPI;
  char **v27;
  char *v28;
  const llvm::MachineLoopInfo *v29;
  BOOL v30;
  uint64_t v31;
  char *v32;
  size_t v33;
  size_t v34;
  uint64_t *v35;
  uint64_t v36;
  llvm::MachineBlockFrequencyInfo *v37;
  char *v38;
  uint64_t v39;
  char *Name;
  size_t v41;
  size_t v42;
  uint64_t *v43;
  uint64_t v44;
  _QWORD v45[2];
  char *v46;
  uint64_t v47;
  __int16 v48;

  if (!*(_BYTE *)(*((_QWORD *)this + 37) + 1164))
    return 0;
  v6 = (void **)**((_QWORD **)this + 1);
  do
  {
    v7 = *v6;
    v6 += 2;
  }
  while (v7 != &llvm::MachineBlockFrequencyInfo::ID);
  *((_QWORD *)this + 38) = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v6 - 1) + 96))(*(v6 - 1), &llvm::MachineBlockFrequencyInfo::ID);
  v8 = (_QWORD *)*((_QWORD *)this + 37);
  v9 = (void **)**((_QWORD **)this + 1);
  do
  {
    v10 = *v9;
    v9 += 2;
  }
  while (v10 != &llvm::MachineDominatorTree::ID);
  v11 = (*(uint64_t (**)(_QWORD, void *))(*(_QWORD *)*(v9 - 1) + 96))(*(v9 - 1), &llvm::MachineDominatorTree::ID);
  v12 = (char **)**((_QWORD **)this + 1);
  do
  {
    v13 = *v12;
    v12 += 2;
  }
  while (v13 != llvm::MachinePostDominatorTree::ID);
  v14 = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v12 - 1) + 96))(*(v12 - 1), llvm::MachinePostDominatorTree::ID);
  v15 = (char **)**((_QWORD **)this + 1);
  do
  {
    v16 = *v15;
    v15 += 2;
  }
  while (v16 != llvm::MachineLoopInfo::ID);
  v17 = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v15 - 1) + 96))(*(v15 - 1), llvm::MachineLoopInfo::ID);
  v18 = *((_QWORD *)this + 38);
  v19 = (char **)**((_QWORD **)this + 1);
  do
  {
    v20 = *v19;
    v19 += 2;
  }
  while (v20 != llvm::MachineOptimizationRemarkEmitterPass::ID);
  v21 = *(_QWORD *)((*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v19 - 1) + 96))(*(v19 - 1), llvm::MachineOptimizationRemarkEmitterPass::ID)+ 248);
  v8[118] = v11;
  v8[119] = v14;
  v8[120] = v17;
  v8[143] = v18;
  v8[142] = v21;
  llvm::MachineFunction::RenumberBlocks(a2, 0);
  if (byte_1ED7FCE00 && dword_1ED82F318)
  {
    v22 = byte_1ED82C79F & 0x7F;
    if (byte_1ED82C79F < 0)
      v22 = qword_1ED82C790;
    if (!v22)
      goto LABEL_19;
    Name = llvm::Value::getName(*(llvm::Value **)a2);
    v42 = v41;
    if (byte_1ED82C79F >= 0)
      v43 = &qword_1ED82C788;
    else
      v43 = (uint64_t *)qword_1ED82C788;
    v44 = qword_1ED82C790;
    if (byte_1ED82C79F >= 0)
      v44 = byte_1ED82C79F & 0x7F;
    if (v42 == v44 && (!v42 || !memcmp(Name, v43, v42)))
    {
LABEL_19:
      v23 = (llvm::MachineBlockFrequencyInfo *)*((_QWORD *)this + 38);
      v48 = 1283;
      v45[0] = "MIR_Prof_loader_b.";
      v46 = llvm::MachineFunction::getName((llvm::Value **)a2);
      v47 = v24;
      llvm::MachineBlockFrequencyInfo::view(v23, (const llvm::Twine *)v45, 0);
    }
  }
  v2 = llvm::MIRProfileLoader::runOnFunction(*((llvm::MIRProfileLoader **)this + 37), (llvm::Function **)a2);
  if ((_DWORD)v2)
  {
    v25 = (llvm::MachineBlockFrequencyInfo *)*((_QWORD *)this + 38);
    MBPI = (const llvm::MachineBranchProbabilityInfo *)llvm::MachineBlockFrequencyInfo::getMBPI(v25);
    v27 = (char **)**((_QWORD **)this + 1);
    do
    {
      v28 = *v27;
      v27 += 2;
    }
    while (v28 != llvm::MachineLoopInfo::ID);
    v29 = (const llvm::MachineLoopInfo *)(*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)*(v27 - 1) + 96))(*(v27 - 1), llvm::MachineLoopInfo::ID);
    llvm::MachineBlockFrequencyInfo::calculate(v25, a2, MBPI, v29);
  }
  if (byte_1ED7FCEC0)
    v30 = dword_1ED82F318 == 0;
  else
    v30 = 1;
  if (!v30)
  {
    v31 = byte_1ED82C79F & 0x7F;
    if (byte_1ED82C79F < 0)
      v31 = qword_1ED82C790;
    if (!v31)
      goto LABEL_39;
    v32 = llvm::Value::getName(*(llvm::Value **)a2);
    v34 = v33;
    v35 = byte_1ED82C79F >= 0 ? &qword_1ED82C788 : (uint64_t *)qword_1ED82C788;
    v36 = qword_1ED82C790;
    if (byte_1ED82C79F >= 0)
      v36 = byte_1ED82C79F & 0x7F;
    if (v34 == v36 && (!v34 || !memcmp(v32, v35, v34)))
    {
LABEL_39:
      v37 = (llvm::MachineBlockFrequencyInfo *)*((_QWORD *)this + 38);
      v38 = llvm::MachineFunction::getName((llvm::Value **)a2);
      v48 = 1283;
      v45[0] = "MIR_prof_loader_a.";
      v46 = v38;
      v47 = v39;
      llvm::MachineBlockFrequencyInfo::view(v37, (const llvm::Twine *)v45, 0);
    }
  }
  return v2;
}

uint64_t llvm::MIRProfileLoaderPass::doInitialization(llvm::MIRProfileLoaderPass *this, const llvm::MemoryBuffer **a2)
{
  llvm::MIRProfileLoader *v2;
  int v3;
  int v4;
  int v5;

  v2 = (llvm::MIRProfileLoader *)*((_QWORD *)this + 37);
  v3 = *((_DWORD *)this + 70);
  *((_DWORD *)v2 + 288) = v3;
  v4 = 6 * v3;
  if (v3)
    v5 = 6 * v3 + 2;
  else
    v5 = 0;
  *((_DWORD *)v2 + 289) = v5;
  *((_DWORD *)v2 + 290) = v4 + 7;
  return llvm::MIRProfileLoader::doInitialization(v2, a2);
}

void *llvm::MIRProfileLoaderPass::getAnalysisUsage(llvm::MIRProfileLoaderPass *this, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBlockFrequencyInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachinePostDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::MachineLoopInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineOptimizationRemarkEmitterPass::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void sub_1C6200B58(llvm::Pass *a1)
{
  sub_1C51D51A0(a1);
  JUMPOUT(0x1CAA32FC0);
}

const char *sub_1C6200B7C()
{
  return "SampleFDO loader in MIR";
}

uint64_t sub_1C6200B8C(llvm::Value *a1)
{
  uint64_t ValueAsString;
  uint64_t v3;
  uint64_t v4;
  char *Name;
  unint64_t v6;
  uint64_t FnAttribute;

  FnAttribute = llvm::Function::getFnAttribute((uint64_t)a1, "sample-profile-suffix-elision-policy", 0x24uLL);
  ValueAsString = llvm::Attribute::getValueAsString((llvm::Attribute *)&FnAttribute);
  v4 = v3;
  Name = llvm::Value::getName(a1);
  return sub_1C51D4FD4((uint64_t)Name, v6, ValueAsString, v4);
}

void sub_1C6200BF0(int **a1, __int128 *a2)
{
  uint64_t v4;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7FCC00, 0, 0);
  dword_1ED7FCC80 = 0;
  qword_1ED7FCC88 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7FCC90 = 0;
  qword_1ED7FCC00 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7FCC98 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7FCCA0 = (uint64_t)&off_1E7F95260;
  qword_1ED7FCCB8 = (uint64_t)&qword_1ED7FCCA0;
  llvm::cl::Option::setArgStr(v4, "fs-profile-debug-prob-diff-threshold", 0x24uLL);
  dword_1ED7FCC80 = **a1;
  byte_1ED7FCC94 = 1;
  dword_1ED7FCC90 = dword_1ED7FCC80;
  xmmword_1ED7FCC20 = *a2;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FCC00);
}

void sub_1C6200CB0(int **a1, __int128 *a2)
{
  uint64_t v4;

  v4 = sub_1C47AD050((uint64_t)&qword_1ED7FCCC0, 0, 0);
  dword_1ED7FCD40 = 0;
  qword_1ED7FCD48 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7FCD50 = 0;
  qword_1ED7FCCC0 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7FCD58 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7FCD60 = (uint64_t)&off_1E7F95260;
  qword_1ED7FCD78 = (uint64_t)&qword_1ED7FCD60;
  llvm::cl::Option::setArgStr(v4, "fs-profile-debug-bw-threshold", 0x1DuLL);
  dword_1ED7FCD40 = **a1;
  byte_1ED7FCD54 = 1;
  dword_1ED7FCD50 = dword_1ED7FCD40;
  xmmword_1ED7FCCE0 = *a2;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FCCC0);
}

_QWORD *sub_1C6200D70(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C6200DDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C6200ECC(a1, a2, v7);
    *(_OWORD *)v5 = *(_OWORD *)a2;
    v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1C6200DDC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v20;

  if (a2)
  {
    v5 = ((a4 >> 4) ^ (a4 >> 9) | ((unint64_t)((a3 >> 4) ^ (a3 >> 9)) << 32))
       + ~((unint64_t)((a4 >> 4) ^ (a4 >> 9)) << 32);
    v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    v8 = a2 - 1;
    v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~((_DWORD)v7 << 27)));
    v10 = (_QWORD *)(a1 + 24 * v9);
    v11 = *v10;
    v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      v14 = 1;
    }
    else
    {
      v16 = 0;
      v17 = 1;
      while (v11 != -4096 || v12 != -4096)
      {
        if (v16)
          v18 = 0;
        else
          v18 = v12 == -8192;
        if (v18 && v11 == -8192)
          v16 = v10;
        v20 = v9 + v17++;
        v9 = v20 & v8;
        v10 = (_QWORD *)(a1 + 24 * (v20 & v8));
        v11 = *v10;
        v12 = v10[1];
        v14 = 1;
        if (*v10 == a3 && v12 == a4)
          goto LABEL_8;
      }
      v14 = 0;
      if (v16)
        v10 = v16;
    }
  }
  else
  {
    v10 = 0;
    v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

_QWORD *sub_1C6200ECC(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1C51D5284(a1, v6);
    v8 = 0;
    sub_1C6200DDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096 || a3[1] != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C6200F88(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  uint64_t v8;
  int64x2_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(int64x2_t **)result;
    v8 = 24 * v6;
    v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *v7 = v9;
      v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v10 = *a2;
    v11 = a2[1];
    if ((*a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      v14 = 0;
      result = sub_1C6200DDC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v10, v11, &v14);
      v12 = v14;
      *v14 = *a2;
      v13 = a2[2];
      v12[1] = a2[1];
      v12[2] = v13;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

unsigned int *sub_1C6201058(unsigned int *result)
{
  unsigned int v1;
  _QWORD *v2;
  uint64_t v3;

  if (*((_QWORD *)result + 1))
  {
    v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if (v1)
      {
        v2 = *(_QWORD **)result;
        v3 = *(_QWORD *)result + 24 * v1;
        do
        {
          *v2 = -4096;
          v2[1] = -4096;
          v2 += 3;
        }
        while (v2 != (_QWORD *)v3);
      }
      *((_QWORD *)result + 1) = 0;
    }
    else
    {
      return sub_1C4DD9E20(result);
    }
  }
  return result;
}

void sub_1C62010AC(uint64_t a1)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    v3 = *(_DWORD *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C51D534C(a1);
      return;
    }
    if (!v3)
    {
LABEL_13:
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
    v4 = 88 * v3;
    v5 = *(_QWORD *)a1 + 24;
    while (1)
    {
      v6 = *(_QWORD *)(v5 - 24);
      if (v6 == -8192)
        goto LABEL_11;
      if (v6 != -4096)
        break;
LABEL_12:
      v5 += 88;
      v4 -= 88;
      if (!v4)
        goto LABEL_13;
    }
    v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7)
      free(v7);
LABEL_11:
    *(_QWORD *)(v5 - 24) = -4096;
    goto LABEL_12;
  }
}

void sub_1C620115C(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    v2 = 88 * v1;
    v3 = *(_QWORD *)a1 + 24;
    do
    {
      if ((*(_QWORD *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4)
          free(v4);
      }
      v3 += 88;
      v2 -= 88;
    }
    while (v2);
  }
}

void sub_1C62011C0(_DWORD *a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = a1[2];
  if (v2 || a1[3])
  {
    v3 = a1[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1C51D5458(a1);
      return;
    }
    if (!(_DWORD)v3)
    {
LABEL_12:
      *((_QWORD *)a1 + 1) = 0;
      return;
    }
    v4 = 32 * v3;
    v5 = *(_QWORD *)a1 + 8;
    while (1)
    {
      v6 = *(_QWORD *)(v5 - 8);
      if (v6 == -8192)
        goto LABEL_10;
      if (v6 != -4096)
        break;
LABEL_11:
      v5 += 32;
      v4 -= 32;
      if (!v4)
        goto LABEL_12;
    }
    sub_1C47655E8(v5, *(_QWORD **)(v5 + 8));
LABEL_10:
    *(_QWORD *)(v5 - 8) = -4096;
    goto LABEL_11;
  }
}

void sub_1C6201268(uint64_t a1, uint64_t ****a2, uint64_t a3)
{
  llvm::Function::setEntryCount(*a2, *(_QWORD *)(*(_QWORD *)(a1 + 1064) + 64) + 1, 0, a3);
  if (!byte_1ED837B98)
    sub_1C51D64A0(a1, (uint64_t)a2);
  sub_1C62013A4(a1, (uint64_t)a2);
}

_QWORD *sub_1C62012C8(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t *v6;
  uint64_t ***v7;
  _QWORD *v8;
  uint64_t v9;
  _BYTE v10[24];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (byte_1ED837B98)
  {
    v5 = result;
    v9 = *(_QWORD *)(a2 + 328);
    sub_1C51D6394((uint64_t)v10, (_QWORD *(***)(unint64_t *__return_ptr, _QWORD, uint64_t))result, v9);
    v6 = v5 + 4;
    result = sub_1C61BEB98(v6, &v9);
    if (result[1])
    {
      if (byte_1ED837C58 || (v10[16] & 1) != 0)
      {
        v7 = *(uint64_t ****)a2;
        v8 = sub_1C61BEB98(v6, &v9);
        return (_QWORD *)llvm::Function::setEntryCount(v7, v8[1], 0, a3);
      }
    }
  }
  return result;
}

void sub_1C62013A4(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  uint64_t v22;
  int v23;
  _BYTE v24[128];
  _QWORD *v25;

  v2 = (_QWORD *)(a2 + 320);
  v3 = *(_QWORD **)(a2 + 328);
  if (v3 != (_QWORD *)(a2 + 320))
  {
    v4 = a1 + 968;
    v5 = a1 + 992;
    do
    {
      v25 = v3;
      v20 = v24;
      v21 = v24;
      v22 = 16;
      v23 = 0;
      sub_1C6201558(v4, (uint64_t *)&v25);
      v6 = (uint64_t *)v3[8];
      v7 = (uint64_t *)v3[9];
      while (v6 != v7)
      {
        v8 = *v6;
        sub_1C4774094((llvm::SmallPtrSetImplBase *)&v20, *v6);
        if (v9)
        {
          v10 = sub_1C6201558(v4, (uint64_t *)&v25);
          v11 = v10;
          v12 = *((unsigned int *)v10 + 4);
          if (v12 >= *((unsigned int *)v10 + 5))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v10 + 1), (uint64_t)(v10 + 3), v12 + 1, 8);
            v12 = *((unsigned int *)v11 + 4);
          }
          *(_QWORD *)(v11[1] + 8 * v12) = v8;
          ++*((_DWORD *)v11 + 4);
        }
        ++v6;
      }
      sub_1C4E4DBF0((uint64_t)&v20);
      sub_1C6201558(v5, (uint64_t *)&v25);
      v13 = (uint64_t *)v3[11];
      v14 = (uint64_t *)v3[12];
      while (v13 != v14)
      {
        v15 = *v13;
        sub_1C4774094((llvm::SmallPtrSetImplBase *)&v20, *v13);
        if (v16)
        {
          v17 = sub_1C6201558(v5, (uint64_t *)&v25);
          v18 = v17;
          v19 = *((unsigned int *)v17 + 4);
          if (v19 >= *((unsigned int *)v17 + 5))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v17 + 1), (uint64_t)(v17 + 3), v19 + 1, 8);
            v19 = *((unsigned int *)v18 + 4);
          }
          *(_QWORD *)(v18[1] + 8 * v19) = v15;
          ++*((_DWORD *)v18 + 4);
        }
        ++v13;
      }
      if (v21 != v20)
        free(v21);
      v3 = (_QWORD *)v3[1];
    }
    while (v3 != v2);
  }
}

_QWORD *sub_1C6201558(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61DE1A0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C62015D0(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x800000000;
  }
  return v5;
}

_QWORD *sub_1C62015D0(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C51D6814(a1, v6);
  v8 = 0;
  sub_1C61DE1A0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C6201680(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 88 * v6;
    do
    {
      *v7 = -4096;
      v7 += 11;
      v8 -= 88;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v13 = 0;
        sub_1C61DE1A0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        v10 = v13;
        *v13 = *(_QWORD *)v4;
        v10[2] = 0x800000000;
        v10[1] = v10 + 3;
        v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C614D378(v11, v4 + 8);
        ++*(_DWORD *)(a1 + 8);
        v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12)
          free(v12);
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
}

char *sub_1C6201778(char *result)
{
  char *v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v1 = result;
  v2 = (void **)(result + 8);
  v3 = *((_QWORD *)result + 2);
  while (2)
  {
    v4 = *(_QWORD *)(v3 - 24);
    if (!*(_BYTE *)(v3 - 8))
    {
      *(_QWORD *)(v3 - 16) = *(_QWORD *)(v4 + 64);
      *(_BYTE *)(v3 - 8) = 1;
    }
    while (1)
    {
      v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 72))
        break;
      *(_QWORD *)(v3 - 16) = v5 + 1;
      v6 = *v5;
      result = (char *)sub_1C4774094(*(llvm::SmallPtrSetImplBase **)v1, *v5);
      if (v7)
      {
        *(_QWORD *)&v11 = v6;
        BYTE8(v11) = 0;
        LOBYTE(v12) = 0;
        v9 = *((_QWORD *)v1 + 2);
        if (v9 >= *((_QWORD *)v1 + 3))
        {
          result = sub_1C4D8DBBC(v2, (uint64_t)&v11);
        }
        else
        {
          v10 = v11;
          *(_QWORD *)(v9 + 16) = v12;
          *(_OWORD *)v9 = v10;
          result = (char *)(v9 + 24);
        }
        *((_QWORD *)v1 + 2) = result;
        return result;
      }
    }
    v8 = *((_QWORD *)v1 + 1);
    v3 = *((_QWORD *)v1 + 2) - 24;
    *((_QWORD *)v1 + 2) = v3;
    if (v8 != v3)
      continue;
    break;
  }
  return result;
}

_QWORD *sub_1C620185C(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[8];
  if (v2)
  {
    a1[9] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[5];
  if (v3)
  {
    a1[6] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1C620189C(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1C51D75AC(a3, a1, a2);
}

llvm::sampleprof::FunctionSamples *sub_1C62018AC(uint64_t a1, uint64_t a2)
{
  llvm::sampleprof::FunctionSamples *result;
  uint64_t v4;
  char v5;
  const llvm::DILocation *v6;

  v6 = *(const llvm::DILocation **)(a2 + 56);
  if (!v6)
    return *(llvm::sampleprof::FunctionSamples **)(a1 + 1064);
  sub_1C6201C30(a1 + 8, &v6, (uint64_t)&v4);
  if (!v5)
    return *(llvm::sampleprof::FunctionSamples **)(v4 + 8);
  result = llvm::sampleprof::FunctionSamples::findFunctionSamples(*(llvm::sampleprof::FunctionSamples **)(a1 + 1064), v6, *(llvm::sampleprof::SampleProfileReaderItaniumRemapper **)(*(_QWORD *)(a1 + 1056) + 112));
  *(_QWORD *)(v4 + 8) = result;
  return result;
}

const std::error_category *sub_1C620192C@<X0>(const std::error_category *a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  const std::error_category *result;
  std::error_category v6;
  std::error_category_vtbl *v7;
  const std::error_category *v8;
  unsigned int equivalent;
  unsigned int v10;
  std::error_category_vtbl *v11;

  v7 = a1[10].__vftable;
  result = a1 + 10;
  v6.__vftable = v7;
  if (!v7)
    goto LABEL_14;
  v8 = result;
  do
  {
    equivalent = v6.equivalent;
    if (equivalent >= a2)
    {
      if (equivalent == a2)
      {
        if (HIDWORD(v6.equivalent) < a3)
          v6.__vftable = (std::error_category_vtbl *)((char *)v6.__vftable + 8);
        else
          v8 = (const std::error_category *)v6.__vftable;
      }
      else
      {
        v8 = (const std::error_category *)v6.__vftable;
      }
    }
    else
    {
      v6.__vftable = (std::error_category_vtbl *)((char *)v6.__vftable + 8);
    }
    v6.__vftable = (std::error_category_vtbl *)v6.~error_category;
  }
  while (v6.__vftable);
  if (v8 == result || (v10 = v8[4].__vftable, v10 > a2) || v10 == a2 && HIDWORD(v8[4].__vftable) > a3)
  {
LABEL_14:
    result = std::system_category();
    *(_BYTE *)(a4 + 16) |= 1u;
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = result;
  }
  else
  {
    v11 = v8[5].__vftable;
    *(_BYTE *)(a4 + 16) &= ~1u;
    *(_QWORD *)a4 = v11;
  }
  return result;
}

void sub_1C62019E4(uint64_t ****a1, uint64_t a2)
{
  _QWORD *v4;
  unint64_t v5;
  char *v6;
  uint64_t v7;
  _QWORD v8[10];
  void *v9;
  unsigned int v10;
  _QWORD v11[35];

  v11[34] = *MEMORY[0x1E0C80C00];
  if (llvm::LLVMContext::getLLVMRemarkStreamer((llvm::LLVMContext *)****a1)
    || (v7 = *(_QWORD *)(*(_QWORD *)****a1 + 72), (*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7)))
  {
    sub_1C51D7704(v8, a2);
    llvm::MachineOptimizationRemarkEmitter::emit(a1, (llvm::DiagnosticInfoOptimizationBase *)v8);
    v8[0] = &off_1E814E790;
    v4 = v9;
    if (v10)
    {
      v5 = (unint64_t)v10 << 6;
      v6 = (char *)v9 - 64;
      do
      {
        sub_1C4765530((uint64_t)&v6[v5]);
        v5 -= 64;
      }
      while (v5);
      v4 = v9;
    }
    if (v4 != v11)
      free(v4);
  }
}

uint64_t sub_1C6201AE8(uint64_t a1, uint64_t a2)
{
  int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;

  *(_QWORD *)a1 = &unk_1E814E610;
  v4 = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(a2 + 12);
  *(_DWORD *)(a1 + 8) = v4;
  *(_QWORD *)a1 = &off_1E814E760;
  v5 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = v5;
  *(_QWORD *)a1 = &off_1E814E790;
  v6 = *(_OWORD *)(a2 + 40);
  v7 = *(_OWORD *)(a2 + 56);
  v8 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = a1 + 96;
  v9 = a1 + 80;
  *(_QWORD *)(v9 - 8) = v8;
  *(_OWORD *)(v9 - 24) = v7;
  *(_OWORD *)(v9 - 40) = v6;
  *(_QWORD *)(v9 + 8) = 0x400000000;
  if (*(_DWORD *)(a2 + 88))
    sub_1C51D79F8(v9, a2 + 80);
  *(_QWORD *)(a1 + 352) = *(_QWORD *)(a2 + 352);
  *(_QWORD *)a1 = &unk_1E8145C70;
  *(_QWORD *)(a1 + 360) = *(_QWORD *)(a2 + 360);
  return a1;
}

double sub_1C6201BB8(char **a1, char **a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  double result;

  v4 = *a1;
  v5 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v5)
  {
    v6 = v5 << 6;
    v7 = v4 - 64;
    do
    {
      sub_1C4765530((uint64_t)&v7[v6]);
      v6 -= 64;
    }
    while (v6);
    v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2))
    free(v4);
  *a1 = *a2;
  result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

uint64_t sub_1C6201C30@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  _QWORD *v10;

  v10 = 0;
  result = sub_1C61252B8((uint64_t *)a1, a2, &v10);
  v7 = v10;
  if ((result & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61B60A0(a1, (uint64_t)a2, a2, v10);
    v7 = (_QWORD *)result;
    *(_QWORD *)result = *a2;
    *(_QWORD *)(result + 8) = 0;
    v8 = 1;
  }
  v9 = *(_QWORD *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a3 = v7;
  *(_QWORD *)(a3 + 8) = v9;
  *(_BYTE *)(a3 + 16) = v8;
  return result;
}

uint64_t llvm::createRegAllocScoringPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C6201D6C(v1);
}

void sub_1C6201CE0(llvm::Pass *a1)
{
  sub_1C4926674(a1);
  JUMPOUT(0x1CAA32FC0);
}

void *sub_1C6201D04(llvm::MachineFunctionPass *a1, llvm::AnalysisUsage *a2)
{
  *((_BYTE *)a2 + 160) = 1;
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::RegAllocEvictionAdvisorAnalysis::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  sub_1C4771E64((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AAResultsWrapperPass::ID);
  return llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1C6201D6C(uint64_t a1)
{
  llvm::PassRegistry *v2;
  unint64_t v3;
  unint64_t PassRegistry;
  _QWORD *v6;
  _QWORD v7[2];

  v2 = (llvm::PassRegistry *)sub_1C4776848(a1, (uint64_t)&llvm::RegAllocScoring::ID);
  *(_QWORD *)v2 = &off_1E8146EF8;
  PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  v3 = atomic_load(&qword_1ED7FCF00);
  if (v3 != -1)
  {
    v7[0] = sub_1C51D837C;
    v7[1] = &PassRegistry;
    v6 = v7;
    std::__call_once(&qword_1ED7FCF00, &v6, (void (__cdecl *)(void *))sub_1C4776838);
  }
  return a1;
}

uint64_t llvm::callDefaultCtor<llvm::RegAllocScoring>()
{
  uint64_t v0;

  v0 = operator new();
  return sub_1C6201D6C(v0);
}

llvm::MachineInstr *llvm::ModuloScheduleExpander::cloneInstr(llvm::MachineFunction **this, llvm::MachineInstr *a2, int a3, int a4)
{
  llvm::MachineInstr *v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  unsigned int TiedOperandIdx;

  v8 = llvm::MachineFunction::CloneMachineInstr(this[1], a2);
  if (**((unsigned __int16 **)a2 + 2) - 1 <= 1)
  {
    v9 = *((unsigned int *)a2 + 10);
    if ((_DWORD)v9)
    {
      v11 = 0;
      v12 = 0;
      v13 = 32 * v9;
      do
      {
        v14 = *(_DWORD *)(*((_QWORD *)a2 + 4) + v11);
        v15 = v14 & 0x10000FF;
        if ((v14 & 0x10000FF) == 0)
          break;
        v16 = v14 & 0xF00000;
        if (v15 == 0x1000000 && v16 != 0)
        {
          TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx(a2, v12);
          llvm::MachineInstr::tieOperands((uint64_t)v8, v12, TiedOperandIdx);
        }
        v11 += 32;
        v12 = (v12 + 1);
      }
      while (v13 != v11);
    }
  }
  llvm::ModuloScheduleExpander::updateMemOperands((llvm::ModuloScheduleExpander *)this, v8, a2, a3 - a4);
  return v8;
}

uint64_t llvm::ModuloScheduleExpander::splitLifetimes(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t VirtualRegister;
  uint64_t v22;
  uint64_t v23;
  llvm::MachineFunction *v24;
  llvm::MachineInstr *v25;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t *v33;
  unsigned __int8 **v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _DWORD v38[2];
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1[1] + 16) + 176))(*(_QWORD *)(a1[1] + 16));
  v37 = (_QWORD *)result;
  v7 = a2 + 48;
  v8 = *(_QWORD *)(a2 + 56);
  if (v8 != a2 + 48)
  {
    v9 = *(_QWORD *)(a2 + 56);
    while (!**(_WORD **)(v9 + 16) || **(_WORD **)(v9 + 16) == 69)
    {
      v9 = *(_QWORD *)(v9 + 8);
      if (v9 == v7)
      {
        v9 = a2 + 48;
        break;
      }
    }
    while (v8 != v9)
    {
      v10 = *(unsigned int *)(*(_QWORD *)(v8 + 32) + 4);
      v11 = a1[3];
      if ((v10 & 0x80000000) != 0)
        v12 = (uint64_t *)(*(_QWORD *)(v11 + 24) + 16 * (v10 & 0x7FFFFFFF) + 8);
      else
        v12 = (uint64_t *)(*(_QWORD *)(v11 + 272) + 8 * v10);
      v13 = *v12;
      if (*v12)
      {
        while ((*(_BYTE *)(v13 + 3) & 1) != 0)
        {
          v13 = *(_QWORD *)(v13 + 24);
          if (!v13)
            goto LABEL_13;
        }
        v14 = *(_QWORD *)(v13 + 8);
        v15 = **(unsigned __int16 **)(v14 + 16);
        if (v15 != 69 && v15 != 0)
          goto LABEL_73;
        if (*(_QWORD *)(v14 + 24) != a2)
          goto LABEL_73;
        v17 = *(_DWORD *)(v8 + 40);
        if (v17 == 1)
          goto LABEL_73;
LABEL_21:
        v18 = *(_QWORD *)(v8 + 32);
        v19 = 1;
        while (*(_QWORD *)(v18 + 32 * (v19 + 1) + 16) != a2)
        {
          v19 += 2;
          if (v17 == v19)
            goto LABEL_27;
        }
        if ((v20 = *(_DWORD *)(v18 + 32 * v19 + 4)) != 0
          && (result = llvm::MachineRegisterInfo::getVRegDef(a1[3], v20)) != 0
          && *(_QWORD *)(result + 24) == a2
          && **(_WORD **)(result + 16)
          && (**(_WORD **)(result + 16) != 69 ? (v29 = result == v7) : (v29 = 1), !v29))
        {
          v22 = 0;
          v35 = result;
          v33 = a3;
          v34 = (unsigned __int8 **)(result + 56);
          v23 = result;
          do
          {
            result = llvm::MachineInstr::findRegisterUseOperandIdx(v23, v10, 0, 0);
            if ((_DWORD)result != -1)
            {
              if ((_DWORD)v22)
              {
                VirtualRegister = v22;
              }
              else
              {
                VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(a1[3], *(_QWORD *)(*(_QWORD *)(a1[3] + 24) + 16 * (v10 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
                LODWORD(v22) = VirtualRegister;
                v24 = sub_1C4779044(a2, v35, v34, *(_QWORD *)(a1[4] + 8) + 912, VirtualRegister);
                v39 = 0;
                v38[0] = 0;
                v38[1] = v10;
                v40 = 0;
                v41 = 0;
                llvm::MachineInstr::addOperand(v25, v24, (const llvm::MachineOperand *)v38);
              }
              result = llvm::MachineInstr::substituteRegister(v23, v10, v22, 0, v37);
              v22 = VirtualRegister;
            }
            v23 = *(_QWORD *)(v23 + 8);
          }
          while (v23 != v7);
          if (!(_DWORD)v22)
          {
            v14 = *(_QWORD *)(v13 + 8);
            a3 = v33;
            goto LABEL_27;
          }
          a3 = v33;
          v30 = *((unsigned int *)v33 + 2);
          if ((_DWORD)v30)
          {
            v31 = v22;
            v28 = *v33;
            v36 = *v33 + 8 * v30;
            v32 = v31;
            do
            {
              v26 = *(_QWORD *)v28 + 48;
              for (i = *(_QWORD *)(*(_QWORD *)v28 + 56); i != v26; i = *(_QWORD *)(i + 8))
              {
                result = llvm::MachineInstr::findRegisterUseOperandIdx(i, v10, 0, 0);
                if ((_DWORD)result != -1)
                  result = llvm::MachineInstr::substituteRegister(i, v10, v32, 0, v37);
                if (!i || (*(_BYTE *)i & 4) == 0)
                {
                  while ((*(_WORD *)(i + 44) & 8) != 0)
                    i = *(_QWORD *)(i + 8);
                }
              }
              v28 += 8;
              a3 = v33;
            }
            while (v28 != v36);
          }
        }
        else
        {
LABEL_73:
        {
LABEL_27:
          while (1)
          {
            v13 = *(_QWORD *)(v13 + 24);
            if (!v13)
              break;
            if ((*(_BYTE *)(v13 + 3) & 1) == 0 && *(_QWORD *)(v13 + 8) != v14)
            {
              v14 = *(_QWORD *)(v13 + 8);
              goto LABEL_21;
            }
          }
        }
        }
LABEL_13:
        if (!v8)
          goto LABEL_17;
      }
      if ((*(_BYTE *)v8 & 4) == 0)
      {
LABEL_17:
        while ((*(_WORD *)(v8 + 44) & 8) != 0)
          v8 = *(_QWORD *)(v8 + 8);
      }
      v8 = *(_QWORD *)(v8 + 8);
    }
  }
  return result;
}

void llvm::ModuloScheduleExpander::addBranches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, _QWORD *a5, uint64_t a6)
{
  uint64_t *v7;
  unsigned int v9;
  unsigned int v10;
  uint64_t *v11;
  llvm::MachineBasicBlock *v12;
  llvm::MachineBasicBlock *v13;
  unsigned __int16 v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  int v20;
  BOOL v22;
  uint64_t v23;
  int v24;
  unsigned int v27;
  unsigned __int8 *v29;
  void *v30;
  uint64_t v31;
  _BYTE v32[128];
  _QWORD *v33;
  uint64_t v34;
  _QWORD v35[6];

  v7 = a4;
  v9 = 0;
  v35[4] = *MEMORY[0x1E0C80C00];
  v33 = v35;
  v24 = *(_DWORD *)(a3 + 8);
  v10 = v24 - 1;
  v34 = 0x400000000;
  v11 = a4;
  v27 = v24 - 1;
  do
  {
    v12 = *(llvm::MachineBasicBlock **)(*(_QWORD *)a3 + 8 * v10);
    v13 = *(llvm::MachineBasicBlock **)(*a5 + 8 * v9);
    v30 = v32;
    v31 = 0x400000000;
    v14 = (*(uint64_t (**)(_QWORD, _QWORD, llvm::MachineBasicBlock *, void **))(**(_QWORD **)(a1 + 72) + 24))(*(_QWORD *)(a1 + 72), v10 + 1, v12, &v30);
    if (v14 > 0xFFu)
    {
      if ((_BYTE)v14)
      {
        v17 = *(_QWORD *)(a1 + 32);
        v29 = 0;
        v16 = (*(uint64_t (**)(uint64_t, llvm::MachineBasicBlock *, uint64_t *, _QWORD, void *, _QWORD, unsigned __int8 **, _QWORD))(*(_QWORD *)v17 + 272))(v17, v12, v11, 0, v30, v31, &v29, 0);
        if (v29)
          llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
        sub_1C51DF50C((uint64_t)v13, (uint64_t)v12);
      }
      else
      {
        llvm::MachineBasicBlock::addSuccessor(v12, v13, -1);
        llvm::MachineBasicBlock::removeSuccessor(v12, (llvm::MachineBasicBlock *)v11, 0);
        llvm::MachineBasicBlock::removeSuccessor((llvm::MachineBasicBlock *)v7, v13, 0);
        v23 = *(_QWORD *)(a1 + 32);
        v29 = 0;
        v16 = (*(uint64_t (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, _QWORD, void *, _QWORD, unsigned __int8 **, _QWORD))(*(_QWORD *)v23 + 272))(v23, v12, v13, 0, v30, v31, &v29, 0);
        if (v29)
          llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
        sub_1C51DF50C((uint64_t)v13, (uint64_t)v7);
        if (v11 != v7)
        {
          sub_1C487FE80((uint64_t)(v7 + 5), v7[7], (uint64_t)(v7 + 6));
          llvm::MachineBasicBlock::eraseFromParent((llvm::MachineBasicBlock *)v7);
        }
        if (v11 == a4)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 72) + 48))(*(_QWORD *)(a1 + 72));
          *(_QWORD *)(a1 + 64) = 0;
        }
        sub_1C487FE80((uint64_t)(v11 + 5), v11[7], (uint64_t)(v11 + 6));
        llvm::MachineBasicBlock::eraseFromParent((llvm::MachineBasicBlock *)v11);
      }
    }
    else
    {
      llvm::MachineBasicBlock::addSuccessor(v12, v13, -1);
      v15 = *(_QWORD *)(a1 + 32);
      v29 = 0;
      v16 = (*(uint64_t (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, uint64_t *, void *, _QWORD, unsigned __int8 **, _QWORD))(*(_QWORD *)v15 + 272))(v15, v12, v13, v11, v30, v31, &v29, 0);
      if (v29)
        llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
    }
    v18 = (_QWORD *)(*((_QWORD *)v12 + 6) & 0xFFFFFFFFFFFFFFF8);
    if ((_QWORD *)((char *)v12 + 48) != v18 && v16 != 0)
    {
      v20 = v16 - 1;
      do
      {
        llvm::ModuloScheduleExpander::updateInstruction(a1, (uint64_t)v18, 0, v10, 0, a6);
        v18 = (_QWORD *)(*v18 & 0xFFFFFFFFFFFFFFF8);
        v22 = v20-- != 0;
      }
      while ((_QWORD *)((char *)v12 + 48) != v18 && v22);
    }
    if (v30 != v32)
      free(v30);
    ++v9;
    --v10;
    v11 = (uint64_t *)v12;
    v7 = (uint64_t *)v13;
  }
  while (v9 <= v27);
  if (*(_QWORD *)(a1 + 64))
  {
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 72) + 40))(*(_QWORD *)(a1 + 72), *(_QWORD *)(*(_QWORD *)a3 + 8 * v27));
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 72) + 32))(*(_QWORD *)(a1 + 72), -v24);
  }
  if (v33 != v35)
    free(v33);
}

void llvm::ModuloScheduleExpander::updateMemOperands(llvm::ModuloScheduleExpander *this, llvm::MachineInstr *a2, llvm::MachineInstr *a3, int a4)
{
  unint64_t v5;
  char *v6;
  _DWORD *v10;
  BOOL v11;
  int *v12;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t MachineMemOperand;
  uint64_t v28;
  unint64_t v29;
  unsigned int v30;
  void *v31;
  uint64_t v32;
  _QWORD v33[3];

  v33[2] = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v6 = (char *)a2 + 48;
    v5 = *((_QWORD *)a2 + 6);
    if (v5 >= 8)
    {
      if ((v5 & 7) == 0)
      {
        v31 = v33;
        v32 = 0x200000000;
        v5 &= 0xFFFFFFFFFFFFFFF8;
        *(_QWORD *)v6 = v5;
        if (!v5)
          goto LABEL_18;
        goto LABEL_11;
      }
      v10 = (_DWORD *)(v5 & 0xFFFFFFFFFFFFFFF8);
      v11 = (*((_QWORD *)a2 + 6) & 7) != 3 || v10 == 0;
      if (!v11 && *v10)
      {
        v31 = v33;
        v32 = 0x200000000;
LABEL_11:
        if ((v5 & 7) == 0)
        {
          *((_QWORD *)a2 + 6) = v5 & 0xFFFFFFFFFFFFFFF8;
          v15 = (char *)a2 + 56;
          goto LABEL_23;
        }
        v12 = (int *)(v5 & 0xFFFFFFFFFFFFFFF8);
        if ((v5 & 7) != 3 || v12 == 0)
        {
          LODWORD(v5) = 0;
        }
        else
        {
          v29 = *v12;
          v6 = (char *)(v12 + 2);
          v5 = v29;
          if ((_DWORD)v29)
          {
            v15 = &v6[8 * v5];
LABEL_23:
            LODWORD(v5) = 0;
            do
            {
              v16 = *(_QWORD *)v6;
              v17 = *(unsigned __int16 *)(*(_QWORD *)v6 + 32);
              if ((v17 & 4) == 0
                && ((~v17 & 0x30) != 0 ? (v18 = (*(_WORD *)(v16 + 36) & 0xF00) == 0) : (v18 = 0),
                    v18 && (*(_QWORD *)v16 >= 8uLL ? (v19 = (*(_QWORD *)v16 & 4) == 0) : (v19 = 0), v19)))
              {
                v30 = 0;
                if (a4 == -1 || !llvm::ModuloScheduleExpander::computeDelta(this, a3, &v30))
                {
                  v24 = *((_QWORD *)this + 1);
                  v25 = v16;
                  v26 = 0;
                  v23 = 0;
                }
                else
                {
                  v20 = v30 * a4;
                  v21 = *((_QWORD *)this + 1);
                  v22 = sub_1C4831E04(v16);
                  if (v22 == -1)
                    v23 = 0;
                  else
                    v23 = ((v22 & 0x1FFFFFFF) << 6) | 1;
                  v24 = v21;
                  v25 = v16;
                  v26 = v20;
                }
                MachineMemOperand = llvm::MachineFunction::getMachineMemOperand(v24, v25, v26, v23);
                v28 = v32;
                if (v32 >= (unint64_t)HIDWORD(v32))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, (uint64_t)v33, v32 + 1, 8);
                  v28 = v32;
                }
                *((_QWORD *)v31 + v28) = MachineMemOperand;
              }
              else
              {
                if (v5 >= HIDWORD(v32))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, (uint64_t)v33, v5 + 1, 8);
                  LODWORD(v5) = v32;
                }
                *((_QWORD *)v31 + v5) = v16;
              }
              LODWORD(v5) = v32 + 1;
              LODWORD(v32) = v32 + 1;
              v6 += 8;
            }
            while (v6 != v15);
            v14 = v31;
            goto LABEL_19;
          }
        }
LABEL_18:
        v14 = v33;
LABEL_19:
        llvm::MachineInstr::setMemRefs((unint64_t)a2, *((llvm::MachineFunction **)this + 1), v14, v5);
        if (v31 != v33)
          free(v31);
      }
    }
  }
}

uint64_t llvm::ModuloScheduleExpander::findDefInLoop(llvm::ModuloScheduleExpander *this, unsigned int a2)
{
  uint64_t v3;
  uint64_t VRegDef;
  int v5;
  char v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  int v15;
  _BYTE v16[64];

  v12 = v16;
  v13 = v16;
  v14 = 8;
  v15 = 0;
  v3 = *((_QWORD *)this + 3);
LABEL_2:
  VRegDef = llvm::MachineRegisterInfo::getVRegDef(v3, a2);
LABEL_3:
  while (1)
  {
    v5 = **(unsigned __int16 **)(VRegDef + 16);
    if (v5 != 69 && v5 != 0)
      break;
    sub_1C4774094((llvm::SmallPtrSetImplBase *)&v12, VRegDef);
    if (!v7)
      break;
    v8 = *(_DWORD *)(VRegDef + 40);
    if (v8 >= 2)
    {
      v9 = *(_QWORD *)(VRegDef + 32);
      v10 = 1;
      while (*(_QWORD *)(v9 + 32 * (v10 + 1) + 16) != *((_QWORD *)this + 6))
      {
        v10 += 2;
        if (v10 >= v8)
          goto LABEL_3;
      }
      v3 = *((_QWORD *)this + 3);
      a2 = *(_DWORD *)(v9 + 32 * v10 + 4);
      goto LABEL_2;
    }
  }
  if (v13 != v12)
    free(v13);
  return VRegDef;
}

uint64_t llvm::ModuloScheduleExpander::getPrevMapVal(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  unint64_t v12;
  uint64_t v13;
  uint64_t VRegDef;
  uint64_t v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  BOOL v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v32;
  unsigned int v33;
  unsigned int *v34;
  int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  int v39;

  v39 = a4;
  if (a2 <= a3)
    return 0;
  v10 = a4;
  v12 = a2;
  v13 = *(_QWORD *)(a1 + 24);
  while (1)
  {
    VRegDef = llvm::MachineRegisterInfo::getVRegDef(v13, v10);
    if (a3 == a5)
    {
      v15 = a6 + 24 * (v12 - 1);
      v16 = *(_DWORD *)(v15 + 16);
      if (v16)
      {
        v17 = v16 - 1;
        v18 = v17 & (37 * v10);
        v19 = *(_DWORD *)(*(_QWORD *)v15 + 8 * v18);
        if ((_DWORD)v10 == v19)
          goto LABEL_36;
        v37 = 1;
        while (v19 != -1)
        {
          v38 = v18 + v37++;
          v18 = v38 & v17;
          v19 = *(_DWORD *)(*(_QWORD *)v15 + 8 * v18);
          if ((_DWORD)v10 == v19)
            goto LABEL_36;
        }
      }
    }
    v15 = a6 + 24 * v12;
    v21 = *(_DWORD *)(v15 + 16);
    if (v21)
    {
      v22 = v21 - 1;
      v23 = v22 & (37 * v10);
      v24 = *(_DWORD *)(*(_QWORD *)v15 + 8 * v23);
      if ((_DWORD)v10 == v24)
      {
LABEL_36:
        v34 = sub_1C476BFEC(v15, &v39) + 1;
        return *v34;
      }
      v35 = 1;
      while (v24 != -1)
      {
        v36 = v23 + v35++;
        v23 = v36 & v22;
        v24 = *(_DWORD *)(*(_QWORD *)v15 + 8 * v23);
        if ((_DWORD)v10 == v24)
          goto LABEL_36;
      }
    }
    v25 = **(unsigned __int16 **)(VRegDef + 16);
    v26 = v25 == 69 || v25 == 0;
    if (!v26 || *(_QWORD *)(VRegDef + 24) != a7)
      return v10;
    v27 = a3 + 1;
    if (v12 == v27)
      break;
    if (v12 <= v27)
      return 0;
    v28 = *(_DWORD *)(VRegDef + 40);
    if (v28 == 1)
    {
LABEL_22:
      v10 = 0;
    }
    else
    {
      v29 = *(_QWORD *)(VRegDef + 32);
      v20 = 1;
      while (*(_QWORD *)(v29 + 32 * (v20 + 1) + 16) != a7)
      {
        v20 += 2;
        if (v28 == v20)
          goto LABEL_22;
      }
      v10 = *(unsigned int *)(v29 + 32 * v20 + 4);
    }
    --v12;
    v39 = v10;
  }
  v30 = *(_DWORD *)(VRegDef + 40);
  if (v30 == 1)
    return 0;
  v32 = *(_QWORD *)(VRegDef + 32);
  v33 = 1;
  while (*(_QWORD *)(v32 + 32 * (v33 + 1) + 16) == a7)
  {
    v10 = 0;
    v33 += 2;
    if (v30 == v33)
      return v10;
  }
  v34 = (unsigned int *)(v32 + 32 * v33 + 4);
  return *v34;
}

unint64_t llvm::PeelingModuloScheduleExpander::peelKernel(uint64_t a1, int a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;

  v4 = llvm::PeelSingleBlockLoop(a2, *(unint64_t **)(a1 + 48), *(_QWORD **)(a1 + 24), *(_QWORD *)(a1 + 32));
  v14 = v4;
  if (a2)
    sub_1C617CB38((_QWORD *)(a1 + 328), &v14);
  else
    sub_1C51DF784(a1 + 280, &v14);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 56);
  for (i = (uint64_t *)(v4 + 56); ; i = (uint64_t *)(v7 + 8))
  {
    v7 = *i;
    v8 = *(_QWORD *)(*(_QWORD *)(v5 + 16) + 8);
    if ((*(_WORD *)(v5 + 44) & 0xC) != 0 && (*(_WORD *)(v5 + 44) & 4) == 0)
      break;
    if ((v8 & 0x200) != 0)
      return v4;
LABEL_9:
    v12 = v5;
    sub_1C61B6040((uint64_t *)(a1 + 232), &v12)[1] = v5;
    v12 = v7;
    sub_1C61B6040((uint64_t *)(a1 + 232), &v12)[1] = v5;
    v12 = v4;
    v13 = v5;
    sub_1C62047D8(a1 + 256, (uint64_t *)&v12)[2] = v7;
    v12 = *(_QWORD *)(a1 + 48);
    v13 = v5;
    sub_1C62047D8(a1 + 256, (uint64_t *)&v12)[2] = v5;
    if ((*(_BYTE *)v5 & 4) == 0)
    {
      while ((*(_WORD *)(v5 + 44) & 8) != 0)
        v5 = *(_QWORD *)(v5 + 8);
    }
    v5 = *(_QWORD *)(v5 + 8);
    if (!v7 || (*(_BYTE *)v7 & 4) == 0)
    {
      while ((*(_WORD *)(v7 + 44) & 8) != 0)
        v7 = *(_QWORD *)(v7 + 8);
    }
  }
  v10 = v5;
  if ((v8 & 0x200) == 0)
  {
    while ((*(_WORD *)(v10 + 44) & 8) != 0)
    {
      v10 = *(_QWORD *)(v10 + 8);
      if ((*(_BYTE *)(*(_QWORD *)(v10 + 16) + 9) & 2) != 0)
        return v4;
    }
    goto LABEL_9;
  }
  return v4;
}

uint64_t llvm::PeelingModuloScheduleExpander::getEquivalentRegisterIn(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int RegisterDefOperandIdx;
  uint64_t v7;
  uint64_t v9[2];
  uint64_t UniqueVRegDef;

  UniqueVRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(*(_QWORD *)(a1 + 24), a2);
  RegisterDefOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx(UniqueVRegDef, a2, 0, 0, 0);
  v7 = sub_1C61B6040((uint64_t *)(a1 + 232), &UniqueVRegDef)[1];
  v9[0] = a3;
  v9[1] = v7;
  return *(unsigned int *)(*(_QWORD *)(sub_1C62047D8(a1 + 256, v9)[2] + 32) + 32 * RegisterDefOperandIdx + 4);
}

uint64_t sub_1C6202DAC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
    return sub_1C51E3E94(a1, a2, a3);
  v4 = *(_QWORD *)a1 + 16 * v3;
  *(_QWORD *)v4 = a2;
  *(_DWORD *)(v4 + 8) = a3;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

uint64_t llvm::PeelingModuloScheduleExpander::moveStageBetweenBlocks(llvm::PeelingModuloScheduleExpander *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3, int a4)
{
  llvm::MachineBasicBlock *v5;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  char *v15;
  int v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  int VirtualRegister;
  char *v23;
  uint64_t *v24;
  llvm::MachineFunction *v25;
  llvm::MachineInstr *v26;
  llvm::MachineInstr *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t VRegDef;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  llvm::MachineInstr **v35;
  uint64_t v36;
  llvm::MachineInstr *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  unsigned int NumExplicitDefs;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  uint64_t UniqueVRegDef;
  int v50;
  BOOL v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v58;
  unsigned int v59;
  char *v60;
  uint64_t *v61;
  uint64_t *v62;
  int v63;
  char *v64;
  unsigned int v65;
  _QWORD v68[2];
  int v69;
  uint64_t v70[2];
  unsigned int v71;
  uint64_t v72;
  unsigned __int8 *v73;
  void *v74;
  uint64_t v75;
  _QWORD v76[6];

  v5 = a3;
  v76[4] = *MEMORY[0x1E0C80C00];
  v7 = (char *)a2 + 48;
  v8 = (char *)*((_QWORD *)a2 + 7);
  v9 = (char *)a2 + 48;
  if (v8 != (char *)a2 + 48)
  {
    v9 = (char *)*((_QWORD *)a2 + 7);
    while (!**((_WORD **)v9 + 2) || **((_WORD **)v9 + 2) == 69)
    {
      v9 = (char *)*((_QWORD *)v9 + 1);
      if (v9 == v7)
      {
        v9 = (char *)a2 + 48;
        break;
      }
    }
  }
  v68[0] = 0;
  v68[1] = 0;
  v69 = 0;
  v10 = (char *)a3 + 48;
  v11 = *((_QWORD *)a3 + 7);
  if ((llvm::MachineBasicBlock *)v11 != (llvm::MachineBasicBlock *)((char *)a3 + 48))
  {
    while (!**(_WORD **)(v11 + 16) || **(_WORD **)(v11 + 16) == 69)
    {
      v11 = *(_QWORD *)(v11 + 8);
      if ((char *)v11 == v10)
        goto LABEL_39;
    }
    if (v10 != (char *)v11)
    {
      v64 = (char *)this + 256;
      v12 = (uint64_t *)((char *)this + 232);
      v13 = (uint64_t *)((char *)a2 + 40);
      v61 = (uint64_t *)((char *)a2 + 40);
      do
      {
        if (!v11 || (v14 = v11, (*(_BYTE *)v11 & 4) == 0))
        {
          v14 = v11;
          if ((*(_WORD *)(v11 + 44) & 8) != 0)
          {
            v14 = v11;
            do
              v14 = *(_QWORD *)(v14 + 8);
            while ((*(_WORD *)(v14 + 44) & 8) != 0);
          }
        }
        v15 = *(char **)(v14 + 8);
        v16 = **(unsigned __int16 **)(v11 + 16);
        v17 = v16 == 69 || v16 == 0;
        if (v17 && sub_1C51DFE64((uint64_t *)this, v11) != a4)
        {
          LODWORD(v72) = *(_DWORD *)(*(_QWORD *)(v11 + 32) + 4);
          VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*((_QWORD *)this + 3), *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 3) + 24) + 16 * (v72 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
          v70[0] = 0;
          v23 = v7;
          if (*((char **)a2 + 7) != v7)
          {
            v23 = (char *)*((_QWORD *)a2 + 7);
            while (!**((_WORD **)v23 + 2) || **((_WORD **)v23 + 2) == 69)
            {
              v23 = (char *)*((_QWORD *)v23 + 1);
              if (v23 == v7)
              {
                v23 = v7;
                break;
              }
            }
          }
          v24 = v12;
          v73 = 0;
          v63 = VirtualRegister;
          v25 = sub_1C4787570((uint64_t)a2, (unint64_t *)v23, &v73, *(_QWORD *)(*((_QWORD *)this + 4) + 8), VirtualRegister);
          v27 = v26;
          v75 = 0;
          LODWORD(v74) = 0;
          HIDWORD(v74) = v72;
          v76[0] = 0;
          v76[1] = 0;
          llvm::MachineInstr::addOperand(v26, v25, (const llvm::MachineOperand *)&v74);
          v75 = 0;
          v76[0] = a3;
          LODWORD(v74) = 4;
          llvm::MachineInstr::addOperand(v27, v25, (const llvm::MachineOperand *)&v74);
          if (v73)
            llvm::MetadataTracking::untrack((uint64_t)&v73, v73);
          v70[0] = (uint64_t)v27;
          v73 = (unsigned __int8 *)v11;
          v28 = sub_1C61B6040(v24, &v73)[1];
          v74 = a2;
          v75 = v28;
          sub_1C62047D8((uint64_t)v64, (uint64_t *)&v74)[2] = v27;
          v12 = v24;
          v74 = (void *)v11;
          v29 = sub_1C61B6040(v24, &v74)[1];
          sub_1C61B6040(v24, v70)[1] = v29;
          sub_1C61482A0((uint64_t)v68, (int *)&v72)[1] = v63;
          v5 = a3;
          v13 = v61;
        }
        if (sub_1C51DFE64((uint64_t *)this, v11) == a4)
        {
          llvm::MachineInstr::removeFromParent((llvm::MachineInstr *)v11);
          llvm::ilist_traits<llvm::MachineInstr>::addNodeToList(v13, v11);
          v18 = *(_QWORD *)v9 & 0xFFFFFFFFFFFFFFF8;
          *(_QWORD *)v11 = v18 | *(_QWORD *)v11 & 7;
          *(_QWORD *)(v11 + 8) = v9;
          *(_QWORD *)(v18 + 8) = v11;
          *(_QWORD *)v9 = *(_QWORD *)v9 & 7 | v11;
          v74 = (void *)v11;
          v19 = sub_1C61B6040(v12, &v74)[1];
          v74 = a2;
          v75 = v19;
          sub_1C62047D8((uint64_t)v64, (uint64_t *)&v74)[2] = v11;
          v74 = 0;
          v20 = v19;
          v5 = a3;
          if (sub_1C6200DDC(*((_QWORD *)this + 32), *((_DWORD *)this + 68), (uint64_t)a3, v20, &v74))
          {
            v21 = v74;
            *(_QWORD *)v74 = -8192;
            v21[1] = -8192;
            *((int32x2_t *)this + 33) = vadd_s32(*(int32x2_t *)((char *)this + 264), (int32x2_t)0x1FFFFFFFFLL);
          }
        }
        v11 = (uint64_t)v15;
      }
      while (v15 != v10);
      v8 = (char *)*((_QWORD *)a2 + 7);
    }
  }
LABEL_39:
  v74 = v76;
  v75 = 0x400000000;
  v30 = v7;
  if (v8 != v7)
  {
    v30 = v8;
    while (!**((_WORD **)v30 + 2) || **((_WORD **)v30 + 2) == 69)
    {
      v30 = (char *)*((_QWORD *)v30 + 1);
      if (v30 == v7)
      {
        v30 = v7;
        break;
      }
    }
  }
  if (v8 != v30)
  {
    do
    {
      VRegDef = llvm::MachineRegisterInfo::getVRegDef(*((_QWORD *)this + 3), *(_DWORD *)(*((_QWORD *)v8 + 4) + 36));
      if (sub_1C51DFE64((uint64_t *)this, VRegDef) == a4)
      {
        v32 = *((_QWORD *)v8 + 4);
        v33 = *(_DWORD *)(v32 + 4);
        llvm::MachineRegisterInfo::replaceRegWith(*((_QWORD **)this + 3), v33, *(_DWORD *)(v32 + 36));
        llvm::MachineOperand::setReg(*((_QWORD *)v8 + 4), v33);
        v34 = v75;
        if (v75 >= (unint64_t)HIDWORD(v75))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, (uint64_t)v76, v75 + 1, 8);
          v34 = v75;
        }
        *((_QWORD *)v74 + v34) = v8;
        LODWORD(v75) = v75 + 1;
      }
      if ((*v8 & 4) == 0)
      {
        while ((*((_WORD *)v8 + 22) & 8) != 0)
          v8 = (char *)*((_QWORD *)v8 + 1);
      }
      v8 = (char *)*((_QWORD *)v8 + 1);
    }
    while (v8 != v30);
    if ((_DWORD)v75)
    {
      v35 = (llvm::MachineInstr **)v74;
      v36 = 8 * v75;
      do
      {
        v37 = *v35++;
        llvm::MachineInstr::eraseFromParent(v37);
        v36 -= 8;
      }
      while (v36);
    }
  }
  v38 = *((_QWORD *)a2 + 7);
  if ((char *)v38 == v7)
    goto LABEL_93;
  v39 = (char *)*((_QWORD *)a2 + 7);
  while (!**((_WORD **)v39 + 2) || **((_WORD **)v39 + 2) == 69)
  {
    v39 = (char *)*((_QWORD *)v39 + 1);
    if (v39 == v7)
    {
      v39 = v7;
      break;
    }
  }
  while (!**(_WORD **)(v38 + 16) || **(_WORD **)(v38 + 16) == 69)
  {
    v38 = *(_QWORD *)(v38 + 8);
    if ((char *)v38 == v7)
      goto LABEL_93;
  }
  if (v7 == (char *)v38)
    goto LABEL_93;
  v62 = (uint64_t *)((char *)this + 232);
  v60 = (char *)this + 208;
  do
  {
    v40 = *(_QWORD *)(v38 + 32);
    NumExplicitDefs = llvm::MachineInstr::getNumExplicitDefs((llvm::MachineInstr *)v38);
    v42 = *(unsigned int *)(v38 + 40);
    if (NumExplicitDefs == (_DWORD)v42)
      goto LABEL_70;
    v43 = v40 + 32 * v42;
    v44 = v40 + 32 * NumExplicitDefs;
    do
    {
      if (*(_BYTE *)v44)
        goto LABEL_74;
      v45 = *(_DWORD *)(v44 + 4);
      if (v69)
      {
        v46 = (v69 - 1) & (37 * v45);
        v47 = *(_DWORD *)(v68[0] + 8 * v46);
        if (v45 == v47)
        {
LABEL_78:
          LODWORD(v70[0]) = *(_DWORD *)(v44 + 4);
          v48 = sub_1C61482A0((uint64_t)v68, (int *)v70)[1];
LABEL_79:
          llvm::MachineOperand::setReg(v44, v48);
          goto LABEL_74;
        }
        v58 = 1;
        while (v47 != -1)
        {
          v59 = v46 + v58++;
          v46 = v59 & (v69 - 1);
          v47 = *(_DWORD *)(v68[0] + 8 * v46);
          if (v45 == v47)
            goto LABEL_78;
        }
      }
      UniqueVRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(*((_QWORD *)this + 3), v45);
      if (UniqueVRegDef)
      {
        v50 = **(unsigned __int16 **)(UniqueVRegDef + 16);
        v51 = v50 == 69 || v50 == 0;
        if (v51 && *(llvm::MachineBasicBlock **)(UniqueVRegDef + 24) == v5)
        {
          v72 = 0;
          v73 = (unsigned __int8 *)UniqueVRegDef;
          v52 = (uint64_t)llvm::MachineFunction::CloneMachineInstr(*((llvm::MachineFunction **)this + 1), (const llvm::MachineInstr *)UniqueVRegDef);
          v72 = v52;
          llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)a2 + 5, v52);
          v53 = *(_QWORD *)v39 & 0xFFFFFFFFFFFFFFF8;
          *(_QWORD *)v52 = v53 | *(_QWORD *)v52 & 7;
          *(_QWORD *)(v52 + 8) = v39;
          *(_QWORD *)(v53 + 8) = v52;
          *(_QWORD *)v39 = *(_QWORD *)v39 & 7 | v52;
          v71 = *(_DWORD *)(*((_QWORD *)v73 + 4) + 4);
          v65 = llvm::MachineRegisterInfo::createVirtualRegister(*((_QWORD *)this + 3), *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 3) + 24) + 16 * (v71 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
          llvm::MachineOperand::setReg(*(_QWORD *)(v72 + 32), v65);
          llvm::MachineOperand::setReg(*(_QWORD *)(v72 + 32) + 32, v71);
          *(_QWORD *)(*(_QWORD *)(v72 + 32) + 80) = **((_QWORD **)a2 + 8);
          sub_1C61482A0((uint64_t)v68, (int *)&v71)[1] = v65;
          v54 = sub_1C61B6040(v62, &v73)[1];
          sub_1C61B6040(v62, &v72)[1] = v54;
          v55 = v72;
          v56 = sub_1C61B6040(v62, &v73)[1];
          v70[0] = (uint64_t)a2;
          v70[1] = v56;
          sub_1C62047D8((uint64_t)this + 256, v70)[2] = v55;
          LODWORD(v55) = *((_DWORD *)sub_1C5119DE8((uint64_t)v60, (uint64_t *)&v73) + 2);
          *((_DWORD *)sub_1C5119DE8((uint64_t)v60, &v72) + 2) = v55;
          v48 = v65;
          v5 = a3;
          goto LABEL_79;
        }
      }
LABEL_74:
      v44 += 32;
    }
    while (v44 != v43);
    if (!v38)
      goto LABEL_91;
LABEL_70:
    if ((*(_BYTE *)v38 & 4) == 0)
    {
LABEL_91:
      while ((*(_WORD *)(v38 + 44) & 8) != 0)
        v38 = *(_QWORD *)(v38 + 8);
    }
    v38 = *(_QWORD *)(v38 + 8);
  }
  while ((char *)v38 != v7);
LABEL_93:
  if (v74 != v76)
    free(v74);
  return MEMORY[0x1CAA32FB4](v68[0], 4);
}

uint64_t llvm::PeelingModuloScheduleExpander::getPhiCanonicalReg(llvm::PeelingModuloScheduleExpander *this, llvm::MachineInstr *VRegDef, llvm::MachineInstr *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  llvm::MachineInstr *v12;

  v12 = a3;
  v5 = *((_DWORD *)sub_1C5119DE8((uint64_t)this + 208, (uint64_t *)&v12) + 2);
  if (!v5)
    return *(unsigned int *)(*((_QWORD *)VRegDef + 4) + 4);
  v6 = *((_QWORD *)this + 3);
  do
  {
    v7 = *((_QWORD *)VRegDef + 4);
    if (*(_QWORD *)(v7 + 80) == *((_QWORD *)VRegDef + 3))
      v8 = 32;
    else
      v8 = 96;
    v9 = v7 + v8;
    v10 = *(unsigned int *)(v9 + 4);
    VRegDef = (llvm::MachineInstr *)llvm::MachineRegisterInfo::getVRegDef(v6, *(_DWORD *)(v9 + 4));
    --v5;
  }
  while (v5);
  return v10;
}

void llvm::PeelingModuloScheduleExpander::peelPrologAndEpilogs(llvm::PeelingModuloScheduleExpander *this)
{
  uint64_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  _QWORD *v9;
  _QWORD *v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int v14;
  llvm::MachineBasicBlock *v15;
  _QWORD *v16;
  _BYTE *v17;
  _QWORD *v18;
  int v19;
  unint64_t v20;
  unint64_t i;
  _QWORD *v22;
  unint64_t j;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t *v29;
  _QWORD **v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int PhiCanonicalReg;
  llvm::MachineInstr *UniqueVRegDef;
  uint64_t v37;
  unsigned __int16 **v38;
  int v39;
  uint64_t v41;
  unsigned int v42;
  char *v43;
  char *v44;
  llvm::MachineBasicBlock *v45;
  llvm::MachineBasicBlock *v46;
  llvm::MachineInstr *FirstInstrTerminator;
  char *v48;
  char *v49;
  unint64_t v50;
  uint64_t v51;
  llvm::MachineInstr **v52;
  uint64_t v53;
  llvm::MachineInstr *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  unint64_t LCSSAExitingBlock;
  llvm::MachineInstr *v59;
  void *v60;
  uint64_t v61;
  _QWORD v62[8];
  void *v63[2];
  uint64_t v64;
  int v65;
  void *v66;
  unsigned int v67;
  uint64_t v68;
  int v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)((char *)this + 48);
  sub_1C496F858((uint64_t)&v66, *(_DWORD *)(*(_QWORD *)this + 80), 1);
  sub_1C496F858((uint64_t)v63, *(_DWORD *)(*(_QWORD *)this + 80), 1);
  v3 = sub_1C62049DC((uint64_t)this + 160, v2);
  sub_1C49DA960((uint64_t)(v3 + 1), (uint64_t)&v66);
  *((_DWORD *)v3 + 18) = v69;
  v4 = sub_1C62049DC((uint64_t)this + 184, v2);
  sub_1C49DA960((uint64_t)(v4 + 1), (uint64_t)v63);
  *((_DWORD *)v4 + 18) = v65;
  if (v67)
    bzero(v66, 8 * v67);
  if (*(int *)(*(_QWORD *)this + 80) >= 2)
  {
    v5 = 0;
    do
    {
      *((_QWORD *)v66 + (v5 >> 6)) |= 1 << v5;
      v6 = llvm::PeelingModuloScheduleExpander::peelKernel((uint64_t)this, 0);
      v7 = *((unsigned int *)this + 18);
      if (v7 >= *((unsigned int *)this + 19))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 64, (uint64_t)this + 80, v7 + 1, 8);
        v7 = *((unsigned int *)this + 18);
      }
      *(_QWORD *)(*((_QWORD *)this + 8) + 8 * v7) = v6;
      v8 = *((_DWORD *)this + 18) + 1;
      *((_DWORD *)this + 18) = v8;
      v9 = sub_1C62049DC((uint64_t)this + 160, (uint64_t *)(*((_QWORD *)this + 8) + 8 * v8 - 8));
      sub_1C49DA960((uint64_t)(v9 + 1), (uint64_t)&v66);
      *((_DWORD *)v9 + 18) = v69;
      v10 = sub_1C62049DC((uint64_t)this + 184, (uint64_t *)(*((_QWORD *)this + 8) + 8 * *((unsigned int *)this + 18) - 8));
      sub_1C49DA960((uint64_t)(v10 + 1), (uint64_t)&v66);
      *((_DWORD *)v10 + 18) = v69;
      ++v5;
    }
    while (v5 < *(_DWORD *)(*(_QWORD *)this + 80) - 1);
  }
  LCSSAExitingBlock = llvm::PeelingModuloScheduleExpander::CreateLCSSAExitingBlock(this);
  sub_1C51E05D0(LCSSAExitingBlock, *((_QWORD **)this + 3), *((_QWORD *)this + 5), 1);
  if (*(int *)(*(_QWORD *)this + 80) >= 2)
  {
    v11 = 1;
    do
    {
      v12 = llvm::PeelingModuloScheduleExpander::peelKernel((uint64_t)this, 1);
      v13 = *((unsigned int *)this + 30);
      if (v13 >= *((unsigned int *)this + 31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 112, (uint64_t)this + 128, v13 + 1, 8);
        v13 = *((unsigned int *)this + 30);
      }
      *(_QWORD *)(*((_QWORD *)this + 14) + 8 * v13) = v12;
      v14 = *((_DWORD *)this + 30) + 1;
      *((_DWORD *)this + 30) = v14;
      v15 = *(llvm::MachineBasicBlock **)(*((_QWORD *)this + 14) + 8 * v14 - 8);
      llvm::PeelingModuloScheduleExpander::filterInstructions(this, v15, *(_DWORD *)(*(_QWORD *)this + 80) - v11);
      sub_1C51E05D0((uint64_t)v15, *((_QWORD **)this + 3), *((_QWORD *)this + 5), 1);
      v16 = (_QWORD *)((char *)v15 + 48);
      v17 = (_BYTE *)*((_QWORD *)v15 + 7);
      if (v17 != (char *)v15 + 48)
      {
        v18 = (_QWORD *)*((_QWORD *)v15 + 7);
        while (!*(_WORD *)v18[2] || *(_WORD *)v18[2] == 69)
        {
          v18 = (_QWORD *)v18[1];
          if (v18 == v16)
          {
            v18 = v16;
            break;
          }
        }
        while (v17 != (_BYTE *)v18)
        {
          v19 = *(_DWORD *)(*(_QWORD *)this + 80) - v11;
          v60 = v17;
          *((_DWORD *)sub_1C61E3C38((uint64_t)this + 208, (uint64_t *)&v60) + 2) = v19;
          if (!v17 || (*v17 & 4) == 0)
          {
            while ((*((_WORD *)v17 + 22) & 8) != 0)
              v17 = (_BYTE *)*((_QWORD *)v17 + 1);
          }
          v17 = (_BYTE *)*((_QWORD *)v17 + 1);
        }
      }
      ++v11;
    }
    while (v11 < *(_DWORD *)(*(_QWORD *)this + 80));
  }
  v20 = *((unsigned int *)this + 30);
  if ((_DWORD)v20)
  {
    for (i = 0; i < v20; ++i)
    {
      v22 = v66;
      if (v67)
        bzero(v66, 8 * v67);
      for (j = i; j < v20; ++j)
      {
        v24 = i - j + *(_DWORD *)(*(_QWORD *)this + 80) - 1;
        v25 = (int)j;
        if ((int)j > i)
        {
          do
          {
            v26 = v25 - 1;
            llvm::PeelingModuloScheduleExpander::moveStageBetweenBlocks(this, *(llvm::MachineBasicBlock **)(*((_QWORD *)this + 14) + 8 * v25 - 8), *(llvm::MachineBasicBlock **)(*((_QWORD *)this + 14) + 8 * v25), v24);
            v25 = v26;
          }
          while (v26 > i);
          v22 = v66;
          v20 = *((unsigned int *)this + 30);
        }
        v22[v24 >> 6] |= 1 << v24;
      }
      v27 = sub_1C62049DC((uint64_t)this + 160, (uint64_t *)(*((_QWORD *)this + 14) + 8 * i));
      sub_1C49DA960((uint64_t)(v27 + 1), (uint64_t)&v66);
      *((_DWORD *)v27 + 18) = v69;
      v28 = sub_1C62049DC((uint64_t)this + 184, (uint64_t *)(*((_QWORD *)this + 14) + 8 * i));
      sub_1C49DA960((uint64_t)(v28 + 1), (uint64_t)v63);
      *((_DWORD *)v28 + 18) = v65;
      v20 = *((unsigned int *)this + 30);
    }
  }
  if (*((_DWORD *)this + 18))
  {
    v29 = (uint64_t *)*((_QWORD *)this + 8);
    v30 = (_QWORD **)*((_QWORD *)this + 14);
    do
    {
      v31 = *(_QWORD *)(*v30)[8];
      llvm::MachineBasicBlock::addSuccessor((_QWORD *)*v29, *v30, -1);
      v32 = (uint64_t)(*v30 + 6);
      v33 = (*v30)[7];
      if (v33 != v32)
      {
        v34 = (*v30)[7];
        while (!**(_WORD **)(v34 + 16) || **(_WORD **)(v34 + 16) == 69)
        {
          v34 = *(_QWORD *)(v34 + 8);
          if (v34 == v32)
          {
            v34 = (uint64_t)(*v30 + 6);
            break;
          }
        }
        while (v33 != v34)
        {
          PhiCanonicalReg = *(_DWORD *)(*(_QWORD *)(v33 + 32) + 36);
          v59 = 0;
          UniqueVRegDef = (llvm::MachineInstr *)llvm::MachineRegisterInfo::getUniqueVRegDef(*((_QWORD *)this + 3), PhiCanonicalReg);
          v59 = UniqueVRegDef;
          if (UniqueVRegDef && *((_QWORD *)UniqueVRegDef + 3) == v31)
          {
            v38 = (unsigned __int16 **)sub_1C61B6040((uint64_t *)this + 29, &v59)[1];
            v39 = *v38[2];
            if (v39 == 69 || v39 == 0)
              PhiCanonicalReg = llvm::PeelingModuloScheduleExpander::getPhiCanonicalReg(this, (llvm::MachineInstr *)v38, v59);
            PhiCanonicalReg = llvm::PeelingModuloScheduleExpander::getEquivalentRegisterIn((uint64_t)this, PhiCanonicalReg, *v29);
          }
          v61 = 0;
          LODWORD(v60) = 0;
          HIDWORD(v60) = PhiCanonicalReg;
          v62[0] = 0;
          v62[1] = 0;
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v33, (const llvm::MachineOperand *)&v60);
          v37 = *v29;
          v61 = 0;
          v62[0] = v37;
          LODWORD(v60) = 4;
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v33, (const llvm::MachineOperand *)&v60);
          if ((*(_BYTE *)v33 & 4) == 0)
          {
            while ((*(_WORD *)(v33 + 44) & 8) != 0)
              v33 = *(_QWORD *)(v33 + 8);
          }
          v33 = *(_QWORD *)(v33 + 8);
        }
      }
      ++v29;
      ++v30;
    }
    while (v29 != (uint64_t *)(*((_QWORD *)this + 8) + 8 * *((unsigned int *)this + 18)));
  }
  v60 = v62;
  v61 = 0x800000000;
  sub_1C6203E0C((_QWORD *)this + 35, (uint64_t)&v60);
  v41 = *((_QWORD *)this + 6);
  v42 = v61;
  if (v61 >= HIDWORD(v61))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, (uint64_t)v62, v61 + 1, 8);
    v42 = v61;
  }
  *((_QWORD *)v60 + v42) = v41;
  LODWORD(v61) = v61 + 1;
  sub_1C6203E0C((_QWORD *)this + 41, (uint64_t)&v60);
  if ((_DWORD)v61)
  {
    v43 = (char *)v60;
    v44 = (char *)v60 + 8 * v61;
    do
    {
      v46 = (llvm::MachineBasicBlock *)*((_QWORD *)v44 - 1);
      v44 -= 8;
      v45 = v46;
      FirstInstrTerminator = (llvm::MachineInstr *)llvm::MachineBasicBlock::getFirstInstrTerminator(v46);
      v48 = (char *)v46 + 48;
      while (1)
      {
        v49 = (char *)v45 + 48;
        if (*((char **)v45 + 7) != v48)
        {
          v49 = (char *)*((_QWORD *)v45 + 7);
          while (!**((_WORD **)v49 + 2) || **((_WORD **)v49 + 2) == 69)
          {
            v49 = (char *)*((_QWORD *)v49 + 1);
            if (v49 == v48)
            {
              v49 = (char *)v45 + 48;
              break;
            }
          }
        }
        if (FirstInstrTerminator == (llvm::MachineInstr *)(*(_QWORD *)v49 & 0xFFFFFFFFFFFFFFF8))
          break;
        v50 = *(_QWORD *)FirstInstrTerminator & 0xFFFFFFFFFFFFFFF8;
        llvm::PeelingModuloScheduleExpander::rewriteUsesOf(this, FirstInstrTerminator);
        FirstInstrTerminator = (llvm::MachineInstr *)v50;
      }
    }
    while (v44 != v43);
  }
  v51 = *((unsigned int *)this + 96);
  if ((_DWORD)v51)
  {
    v52 = (llvm::MachineInstr **)*((_QWORD *)this + 47);
    v53 = 8 * v51;
    do
    {
      v54 = *v52;
      v55 = *((_QWORD *)this + 5);
      if (v55)
        llvm::SlotIndexes::removeMachineInstrFromMaps(*(int32x2_t **)(v55 + 288), *v52);
      llvm::MachineInstr::eraseFromParent(v54);
      ++v52;
      v53 -= 8;
    }
    while (v53);
  }
  *((_DWORD *)this + 96) = 0;
  if ((_DWORD)v61)
  {
    v56 = 8 * v61;
    v57 = (char *)v60 - 8;
    do
    {
      sub_1C51E05D0(*(_QWORD *)&v57[v56], *((_QWORD **)this + 3), *((_QWORD *)this + 5), 0);
      v56 -= 8;
    }
    while (v56);
  }
  sub_1C51E05D0(LCSSAExitingBlock, *((_QWORD **)this + 3), *((_QWORD *)this + 5), 0);
  if (v60 != v62)
    free(v60);
  if (v63[0] != &v64)
    free(v63[0]);
  if (v66 != &v68)
    free(v66);
}

uint64_t *sub_1C6203E0C(_QWORD *a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t **v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v12;

  v3 = a1[4];
  v4 = a1[1];
  v5 = a1[2];
  v6 = (uint64_t **)(v4 + 8 * (v3 >> 9));
  if (v5 == v4)
  {
    v7 = 0;
    v10 = 0;
    v9 = (uint64_t **)(v4 + 8 * ((a1[5] + v3) >> 9));
  }
  else
  {
    v7 = &(*v6)[v3 & 0x1FF];
    v8 = a1[5] + v3;
    v9 = (uint64_t **)(v4 + 8 * (v8 >> 9));
    v10 = &(*v9)[v8 & 0x1FF];
  }
  v12 = a2;
  return sub_1C51E3FD4(v6, v7, v9, v10, &v12);
}

uint64_t llvm::PeelingModuloScheduleExpander::fixupBranches(llvm::PeelingModuloScheduleExpander *this)
{
  uint64_t v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  llvm::MachineBasicBlock *v7;
  llvm::MachineBasicBlock *v8;
  llvm::MachineBasicBlock **v9;
  llvm::MachineBasicBlock *v10;
  llvm::MachineBasicBlock *v11;
  llvm::MachineBasicBlock *v12;
  unsigned __int16 v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v23;
  void *v24;
  uint64_t v25;
  _QWORD v26[17];

  v26[16] = *MEMORY[0x1E0C80C00];
  v2 = *((unsigned int *)this + 18);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = *((_QWORD *)this + 8) + 8 * v2;
    LODWORD(v5) = *(_DWORD *)(*(_QWORD *)this + 80);
    v6 = *((_QWORD *)this + 14) + 8 * *((unsigned int *)this + 30);
    do
    {
      v5 = (v5 - 1);
      v8 = *(llvm::MachineBasicBlock **)(v4 - 8);
      v4 -= 8;
      v7 = v8;
      v9 = (llvm::MachineBasicBlock **)*((_QWORD *)v8 + 11);
      v11 = *(llvm::MachineBasicBlock **)(v6 - 8);
      v6 -= 8;
      v10 = v11;
      v12 = *v9;
      v24 = v26;
      v25 = 0x400000000;
      (*(void (**)(_QWORD, llvm::MachineBasicBlock *, _QWORD))(**((_QWORD **)this + 4) + 264))(*((_QWORD *)this + 4), v7, 0);
      v13 = (*(uint64_t (**)(_QWORD, uint64_t, llvm::MachineBasicBlock *, void **))(**((_QWORD **)this + 53)
                                                                                           + 24))(*((_QWORD *)this + 53), v5, v7, &v24);
      if (v13 > 0xFFu)
      {
        if ((_BYTE)v13)
        {
          llvm::MachineBasicBlock::removeSuccessor(v7, v10, 0);
          v15 = (_QWORD *)((char *)v10 + 48);
          v16 = *((_QWORD *)v10 + 7);
          if ((_QWORD *)v16 != v15)
          {
            v17 = v16;
            while (!**(_WORD **)(v17 + 16) || **(_WORD **)(v17 + 16) == 69)
            {
              v17 = *(_QWORD *)(v17 + 8);
              if ((_QWORD *)v17 == v15)
              {
                v17 = (uint64_t)v15;
                break;
              }
            }
            while (v16 != v17)
            {
              llvm::MachineInstr::removeOperand(v16, 4u);
              llvm::MachineInstr::removeOperand(v16, 3u);
              if (!v16 || (*(_BYTE *)v16 & 4) == 0)
              {
                while ((*(_WORD *)(v16 + 44) & 8) != 0)
                  v16 = *(_QWORD *)(v16 + 8);
              }
              v16 = *(_QWORD *)(v16 + 8);
            }
          }
        }
        else
        {
          llvm::MachineBasicBlock::removeSuccessor(v7, v12, 0);
          v18 = (_QWORD *)((char *)v12 + 48);
          v19 = *((_QWORD *)v12 + 7);
          if ((_QWORD *)v19 != v18)
          {
            v20 = v19;
            while (!**(_WORD **)(v20 + 16) || **(_WORD **)(v20 + 16) == 69)
            {
              v20 = *(_QWORD *)(v20 + 8);
              if ((_QWORD *)v20 == v18)
              {
                v20 = (uint64_t)v18;
                break;
              }
            }
            while (v19 != v20)
            {
              llvm::MachineInstr::removeOperand(v19, 2u);
              llvm::MachineInstr::removeOperand(v19, 1u);
              if (!v19 || (*(_BYTE *)v19 & 4) == 0)
              {
                while ((*(_WORD *)(v19 + 44) & 8) != 0)
                  v19 = *(_QWORD *)(v19 + 8);
              }
              v19 = *(_QWORD *)(v19 + 8);
            }
          }
          v21 = *((_QWORD *)this + 4);
          v23 = 0;
          (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, _QWORD, _QWORD, _QWORD, unsigned __int8 **, _QWORD))(*(_QWORD *)v21 + 272))(v21, v7, v10, 0, 0, 0, &v23, 0);
          if (v23)
            llvm::MetadataTracking::untrack((uint64_t)&v23, v23);
          v3 = 1;
        }
      }
      else
      {
        v14 = *((_QWORD *)this + 4);
        v23 = 0;
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void *, _QWORD, unsigned __int8 **, _QWORD))(*(_QWORD *)v14 + 272))(v14, v7, v10, v12, v24, v25, &v23, 0);
        if (v23)
          llvm::MetadataTracking::untrack((uint64_t)&v23, v23);
      }
      if (v24 != v26)
        free(v24);
    }
    while (v4 != *((_QWORD *)this + 8));
    if ((v3 & 1) != 0)
      return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 53) + 48))(*((_QWORD *)this + 53));
  }
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 53) + 32))(*((_QWORD *)this + 53), (1 - *(_DWORD *)(*(_QWORD *)this + 80)));
  return (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 53) + 40))(*((_QWORD *)this + 53), *(_QWORD *)(*((_QWORD *)this + 8) + 8 * *((unsigned int *)this + 18) - 8));
}

uint64_t llvm::PeelingModuloScheduleExpander::expand(llvm::PeelingModuloScheduleExpander *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[16];

  *((_QWORD *)this + 6) = llvm::MachineLoop::getTopBlock(**(llvm::MachineLoop ***)this);
  *((_QWORD *)this + 7) = llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopPreheader(**(_QWORD **)this);
  (*(void (**)(_QWORD *__return_ptr, _QWORD, _QWORD))(**((_QWORD **)this + 4) + 280))(v6, *((_QWORD *)this + 4), *((_QWORD *)this + 6));
  v2 = v6[0];
  v6[0] = 0;
  v3 = *((_QWORD *)this + 53);
  *((_QWORD *)this + 53) = v2;
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    v4 = v6[0];
    v6[0] = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  sub_1C51E0DA4((uint64_t)v6, **(_QWORD ***)this, *(_QWORD *)this, *((_QWORD *)this + 6));
  sub_1C51E0E40((uint64_t)v6);
  sub_1C51E1B90(v6);
  llvm::PeelingModuloScheduleExpander::peelPrologAndEpilogs(this);
  return llvm::PeelingModuloScheduleExpander::fixupBranches(this);
}

llvm::raw_ostream *sub_1C620429C(llvm::raw_ostream *a1, uint64_t *a2)
{
  char v2;
  BOOL v3;
  size_t v4;
  size_t v5;
  size_t v6;

  v2 = *((_BYTE *)a2 + 23);
  v3 = v2 < 0;
  v4 = a2[1];
  if (v2 < 0)
    a2 = (uint64_t *)*a2;
  v5 = v2 & 0x7F;
  if (v3)
    v6 = v4;
  else
    v6 = v5;
  return llvm::raw_ostream::write(a1, (const char *)a2, v6);
}

void llvm::initializeModuloScheduleTestPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FD120);
  if (v2 != -1)
  {
    v5[0] = sub_1C51E280C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FD120, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

_DWORD *sub_1C6204320(_DWORD *result, unsigned int a2)
{
  _DWORD *v3;
  uint64_t v4;

  v3 = result;
  v4 = result[2];
  if (v4 >= result[3])
  {
    result = llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v4 + 1, 8);
    LODWORD(v4) = v3[2];
  }
  *(_QWORD *)(*(_QWORD *)v3 + 8 * v4) = a2 | 0x100000000;
  ++v3[2];
  return result;
}

unsigned int *sub_1C6204384(unsigned int *result, uint64_t a2, uint64_t a3)
{
  unsigned int *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  v5 = result;
  v6 = result[2];
  if (v6 + a2 > (unint64_t)result[3])
  {
    result = (unsigned int *)llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)result, (uint64_t)(result + 4), v6 + a2, 8);
    v6 = v5[2];
  }
  v7 = (_QWORD *)(*(_QWORD *)v5 + 8 * v6);
  v8 = a2;
  do
  {
    *v7++ = a3;
    --v8;
  }
  while (v8);
  v5[2] += a2;
  return result;
}

_DWORD *sub_1C62043FC(uint64_t a1)
{
  int v2;
  _DWORD *result;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  int v7;

  v2 = *(_DWORD *)(a1 + 8);
  result = *(_DWORD **)a1;
  v4 = *(unsigned int *)(a1 + 16);
  v5 = &result[3 * v4];
  if (!v2)
    return v5;
  if ((_DWORD)v4)
  {
    v6 = 12 * v4;
    while (1)
    {
      v7 = result[1];
      if ((*result != -1 || v7 != -1) && (*result != -2 || v7 != -2))
        break;
      result += 3;
      v6 -= 12;
      if (!v6)
        return v5;
    }
  }
  return result;
}

uint64_t sub_1C6204454(uint64_t a1, int a2, int a3, int a4, _QWORD *a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  _DWORD *v10;
  int v11;
  int v12;
  uint64_t v14;
  _DWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v20;

  if (a2)
  {
    v5 = ((37 * a4) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)(37 * a4) << 32);
    v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    v8 = a2 - 1;
    v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~((_DWORD)v7 << 27)));
    v10 = (_DWORD *)(a1 + 12 * v9);
    v11 = *v10;
    v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      v14 = 1;
    }
    else
    {
      v16 = 0;
      v17 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v16)
          v18 = 0;
        else
          v18 = v12 == -2;
        if (v18 && v11 == -2)
          v16 = v10;
        v20 = v9 + v17++;
        v9 = v20 & v8;
        v10 = (_DWORD *)(a1 + 12 * (v20 & v8));
        v11 = *v10;
        v12 = v10[1];
        v14 = 1;
        if (*v10 == a3 && v12 == a4)
          goto LABEL_8;
      }
      v14 = 0;
      if (v16)
        v10 = v16;
    }
  }
  else
  {
    v10 = 0;
    v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

uint64_t sub_1C6204540(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  uint64_t result;
  _DWORD *v9;
  char v10;
  uint64_t v11;
  _DWORD *v12;

  v12 = 0;
  result = sub_1C6204454(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C62045E8(a2, a3, v12);
    v9 = (_DWORD *)result;
    *(_DWORD *)result = *a3;
    *(_DWORD *)(result + 4) = a3[1];
    *(_DWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 12 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

_DWORD *sub_1C62045E8(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5;
  unsigned int v6;
  _DWORD *v9;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C51E32A0(a1, v6);
  v9 = 0;
  sub_1C6204454(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C620469C(uint64_t result, int *a2, int *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  int *v13;
  int *v14;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)result;
    v8 = 12 * v6;
    do
    {
      *v7 = -1;
      v7 = (_QWORD *)((char *)v7 + 12);
      v8 -= 12;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v9 = *a2;
    v10 = a2[1];
    if ((*a2 != -1 || v10 != -1) && (v9 != -2 || v10 != -2))
    {
      v14 = 0;
      result = sub_1C6204454(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
      v13 = v14;
      *v14 = *a2;
      v13[1] = a2[1];
      v13[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

_DWORD *sub_1C6204768(uint64_t a1, int *a2)
{
  char v4;
  _DWORD *v5;
  _DWORD *v7;

  v7 = 0;
  v4 = sub_1C6204454(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C62045E8(a1, a2, v7);
    *v5 = *a2;
    *(_QWORD *)(v5 + 1) = a2[1];
  }
  return v5;
}

_QWORD *sub_1C62047D8(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C6200DDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C6204848(a1, a2, v7);
    *v5 = *a2;
    v5[1] = a2[1];
    v5[2] = 0;
  }
  return v5;
}

_QWORD *sub_1C6204848(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1C51E3DCC(a1, v6);
    v8 = 0;
    sub_1C6200DDC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096 || a3[1] != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t sub_1C6204904(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  int64x2_t *v7;
  uint64_t v8;
  int64x2_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;

  v5 = result;
  *(_QWORD *)(result + 8) = 0;
  v6 = *(unsigned int *)(result + 16);
  if ((_DWORD)v6)
  {
    v7 = *(int64x2_t **)result;
    v8 = 24 * v6;
    v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *v7 = v9;
      v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    v10 = *a2;
    v11 = a2[1];
    if ((*a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      v13 = 0;
      result = sub_1C6200DDC(*(_QWORD *)v5, *(_DWORD *)(v5 + 16), v10, v11, &v13);
      v12 = v13;
      *v13 = *a2;
      v12[1] = a2[1];
      v12[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

_QWORD *sub_1C62049DC(uint64_t a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61B57BC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C6204A58(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x600000000;
    *((_DWORD *)v5 + 18) = 0;
  }
  return v5;
}

_QWORD *sub_1C6204A58(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C51E3F10(a1, v6);
  v8 = 0;
  sub_1C61B57BC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

void sub_1C6204B08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 80 * v6;
    do
    {
      *v7 = -4096;
      v7 += 10;
      v8 -= 80;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      v9 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v12 = 0;
        sub_1C61B57BC(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
        v10 = v12;
        *v12 = *(_QWORD *)v4;
        v10[1] = v10 + 3;
        v10[2] = 0x600000000;
        if (*(_DWORD *)(v4 + 16))
          sub_1C476B4F4((uint64_t)(v10 + 1), v4 + 8);
        *((_DWORD *)v10 + 18) = *(_DWORD *)(v4 + 72);
        ++*(_DWORD *)(a1 + 8);
        v11 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v11)
          free(v11);
      }
      v4 += 80;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1C6204C08(uint64_t result, int a2)
{
  int v2;
  uint64_t v3;

  if (a2)
  {
    v2 = a2;
    v3 = result;
    do
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 96))(v3);
      --v2;
    }
    while (v2);
  }
  return result;
}

void llvm::initializePatchableFunctionPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FD128);
  if (v2 != -1)
  {
    v5[0] = sub_1C51E46AC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FD128, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::MBFIWrapper::getBlockFreq(llvm::MBFIWrapper *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  const llvm::MachineBasicBlock *v9;

  v8 = 0;
  v9 = a2;
  if (sub_1C61252B8((uint64_t *)this + 1, &v9, &v8))
  {
    v4 = v8;
    v5 = *((_QWORD *)this + 1);
    v6 = *((unsigned int *)this + 6);
  }
  else
  {
    v5 = *((_QWORD *)this + 1);
    v6 = *((unsigned int *)this + 6);
    v4 = v5 + 16 * v6;
  }
  if (v4 == v5 + 16 * v6)
    return llvm::MachineBlockFrequencyInfo::getBlockFreq(*(llvm::MachineBlockFrequencyInfo **)this, a2);
  else
    return *(_QWORD *)(v4 + 8);
}

_QWORD *llvm::MBFIWrapper::setBlockFreq(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v5;

  v5 = a2;
  result = sub_1C6204DEC((uint64_t *)(a1 + 8), &v5);
  result[1] = a3;
  return result;
}

uint64_t *llvm::MBFIWrapper::getBlockProfileCount(llvm::MBFIWrapper *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  llvm::MachineBlockFrequencyInfo *v7;
  uint64_t v9;
  const llvm::MachineBasicBlock *v10;

  v9 = 0;
  v10 = a2;
  if (sub_1C61252B8((uint64_t *)this + 1, &v10, &v9))
  {
    v4 = v9;
    v5 = *((_QWORD *)this + 1);
    v6 = *((unsigned int *)this + 6);
  }
  else
  {
    v5 = *((_QWORD *)this + 1);
    v6 = *((unsigned int *)this + 6);
    v4 = v5 + 16 * v6;
  }
  v7 = *(llvm::MachineBlockFrequencyInfo **)this;
  if (v4 == v5 + 16 * v6)
    return llvm::MachineBlockFrequencyInfo::getBlockProfileCount(v7, a2);
  else
    return (uint64_t *)llvm::MachineBlockFrequencyInfo::getProfileCountFromFreq(v7, *(_QWORD *)(v4 + 8));
}

void llvm::MBFIWrapper::view(llvm::MachineBlockFrequencyInfo **this, const llvm::Twine *a2, char a3)
{
  llvm::MachineBlockFrequencyInfo::view(*this, a2, a3);
}

uint64_t llvm::MBFIWrapper::getEntryFreq(llvm::MachineBlockFrequencyInfo **this)
{
  return llvm::MachineBlockFrequencyInfo::getEntryFreq(*this);
}

_QWORD *sub_1C6204DEC(uint64_t *a1, _QWORD *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C61252B8(a1, a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C6204E48((uint64_t)a1, a2, v7);
    *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

_QWORD *sub_1C6204E48(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C4FA9EF4(a1, v6);
  v8 = 0;
  sub_1C61252B8((uint64_t *)a1, a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

uint64_t llvm::MIRPrinter::print(llvm::MIRPrinter *this, const llvm::MachineFunction *a2)
{
  uint64_t v4;
  int v5;
  _DWORD *v6;
  uint64_t v7;
  const llvm::Function **v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  unsigned int v14;
  __int128 *v15;
  __int128 *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  const llvm::MachineBasicBlock *v22;
  char v24;
  void (**v25)(llvm::raw_ostream *__hidden);
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  int v32;
  _BYTE *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  char v39;
  char v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  __int16 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  int v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _DWORD v61[7];
  int v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  _BYTE v66[32];
  uint64_t v67;
  __int128 v68;
  char *v69;
  char *v70;
  void *v71;
  uint64_t v72;
  _BYTE v73[128];
  _BYTE v74[136];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  llvm::MIRPrinter::initRegisterMaskIds(this, a2);
  v40 = 0;
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0u;
  v46 = 0u;
  v47 = 0;
  v54 = 0u;
  v55 = 0u;
  v56 = 0u;
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  memset(v61, 0, sizeof(v61));
  v49 = 0u;
  v50 = 0u;
  v51 = 0u;
  v52 = 0u;
  v53 = 0u;
  v48 = -1;
  v62 = 5;
  v63 = 0u;
  v64 = 0u;
  v65 = 0u;
  memset(v66, 0, sizeof(v66));
  v67 = 0;
  *(_QWORD *)&v34 = llvm::MachineFunction::getName((llvm::Value **)a2);
  *((_QWORD *)&v34 + 1) = v4;
  LOWORD(v35) = *((unsigned __int8 *)a2 + 352) | 0x100;
  BYTE2(v35) = *((_BYTE *)a2 + 353);
  BYTE8(v35) = *((_BYTE *)a2 + 355);
  *(_DWORD *)((char *)&v35 + 9) = *((_DWORD *)a2 + 158);
  BYTE13(v35) = *((_BYTE *)a2 + 636);
  v5 = **((_DWORD **)a2 + 45);
  BYTE3(v35) = (v5 & 0x20) != 0;
  BYTE4(v35) = (v5 & 0x40) != 0;
  BYTE5(v35) = (v5 & 0x80) != 0;
  BYTE6(v35) = (v5 & 0x10) != 0;
  BYTE14(v35) = (v5 & 0x200) != 0;
  HIBYTE(v35) = (v5 & 0x400) != 0;
  v6 = (_DWORD *)*((_QWORD *)a2 + 5);
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 2) + 176))(*((_QWORD *)a2 + 2));
  llvm::MIRPrinter::convert(v7, (uint64_t)&v34, v6, v7);
  v8 = (const llvm::Function **)llvm::MachineModuleSlotTracker::MachineModuleSlotTracker((llvm::MachineModuleSlotTracker *)v74, a2, 1);
  v9 = llvm::ModuleSlotTracker::incorporateFunction(v8, *(const llvm::Function **)a2);
  llvm::MIRPrinter::convert((uint64_t)v9, v10, (uint64_t)&v41, *((_QWORD *)a2 + 7));
  llvm::MIRPrinter::convertStackObjects((uint64_t)this, &v34, (uint64_t)a2, (llvm::ModuleSlotTracker *)v74);
  llvm::MIRPrinter::convertCallSiteObjects(v11, (uint64_t)&v34, (uint64_t)a2);
  v14 = *((_DWORD *)a2 + 232);
  if (v14)
  {
    v15 = (__int128 *)*((_QWORD *)a2 + 115);
    v16 = (__int128 *)((char *)v15 + 20 * v14);
    v12 = *(char **)&v61[3];
    do
    {
      v68 = *v15;
      LODWORD(v69) = *((_DWORD *)v15 + 4);
      if ((unint64_t)v12 >= *(_QWORD *)&v61[5])
      {
        v12 = sub_1C51EA60C((void **)&v61[1], (uint64_t)&v68);
      }
      else
      {
        v17 = v68;
        *((_DWORD *)v12 + 4) = (_DWORD)v69;
        *(_OWORD *)v12 = v17;
        v12 += 20;
      }
      *(_QWORD *)&v61[3] = v12;
      v15 = (__int128 *)((char *)v15 + 20);
    }
    while (v15 != v16);
  }
  v18 = *((_QWORD *)a2 + 8);
  if (v18)
    llvm::MIRPrinter::convert((uint64_t)v12, &v34, v18);
  v19 = *((_QWORD *)a2 + 9);
  if (v19)
    llvm::MIRPrinter::convert((uint64_t)v12, v13, (uint64_t)&v62, v19);
  v20 = (*(uint64_t (**)(_QWORD, const llvm::MachineFunction *))(**((_QWORD **)a2 + 1) + 40))(*((_QWORD *)a2 + 1), a2);
  v21 = *(void **)((char *)&v59 + 4);
  *(_QWORD *)((char *)&v59 + 4) = v20;
  if (v21)
    v21 = (void *)(*(uint64_t (**)(void *))(*(_QWORD *)v21 + 8))(v21);
  v26 = 0;
  v30 = 0;
  v31 = 0;
  v25 = (void (**)(llvm::raw_ostream *__hidden))&unk_1E81A7208;
  v33 = v66;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v22 = (const llvm::MachineBasicBlock *)*((_QWORD *)a2 + 41);
  if (v22 != (const llvm::MachineFunction *)((char *)a2 + 320))
  {
    v24 = 0;
    do
    {
      if ((v24 & 1) != 0)
        sub_1C4816AD8((llvm::raw_ostream *)&v25, "\n");
      *(_QWORD *)&v68 = &v25;
      *((_QWORD *)&v68 + 1) = v74;
      v69 = (char *)this + 8;
      v70 = (char *)this + 32;
      v71 = v73;
      v72 = 0x800000000;
      llvm::MIPrinter::print((llvm::MIPrinter *)&v68, v22);
      v21 = v71;
      if (v71 != v73)
        free(v71);
      v22 = (const llvm::MachineBasicBlock *)*((_QWORD *)v22 + 1);
      v24 = 1;
    }
    while (v22 != (const llvm::MachineFunction *)((char *)a2 + 320));
    if (v29 != v27)
      v21 = (void *)llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v25);
  }
  llvm::MIRPrinter::convertMachineMetadataNodes((uint64_t)v21, &v34, (uint64_t)a2, (uint64_t)v74);
  llvm::yaml::Output::Output((llvm::yaml::Output *)&v68, *(llvm::raw_ostream **)this, 0, 70);
  if (!byte_1ED7FD1B0)
    v73[47] = 1;
  sub_1C62055D4((llvm::yaml::Output *)&v68, &v34);
  llvm::yaml::Output::~Output((llvm::yaml::Output *)&v68);
  v25 = off_1E81A6E70;
  if (v32 == 1 && v27)
    MEMORY[0x1CAA32F9C](v27, 0x1000C8077774924);
  llvm::MachineModuleSlotTracker::~MachineModuleSlotTracker((llvm::MachineModuleSlotTracker *)v74);
  return sub_1C51E9D94((uint64_t)&v34);
}

uint64_t llvm::MIRPrinter::initRegisterMaskIds(llvm::MIRPrinter *this, const llvm::MachineFunction *a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  _BYTE v10[24];
  uint64_t v11;
  uint64_t v12;

  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 2) + 176))(*((_QWORD *)a2 + 2));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 72))(v3);
  if (v5)
  {
    v6 = result;
    v7 = 0;
    v8 = (char *)this + 8;
    v9 = 8 * v5;
    do
    {
      v11 = *(_QWORD *)(v6 + 8 * v7);
      v12 = v7;
      result = sub_1C6144658((uint64_t)v10, (uint64_t)v8, &v11, &v12);
      ++v7;
      v9 -= 8;
    }
    while (v9);
  }
  return result;
}

llvm::yaml::Output *sub_1C62055D4(llvm::yaml::Output *a1, _OWORD *a2)
{
  llvm::yaml::Output::beginDocuments(a1);
  if (llvm::yaml::Output::preflightDocument(a1, 0))
  {
    (*(void (**)(llvm::yaml::Output *))(*(_QWORD *)a1 + 104))(a1);
    sub_1C51EA724((uint64_t *)a1, a2);
    (*(void (**)(llvm::yaml::Output *))(*(_QWORD *)a1 + 112))(a1);
    llvm::yaml::Output::postflightDocument(a1);
  }
  llvm::yaml::Output::endDocuments(a1);
  return a1;
}

llvm::raw_ostream *llvm::MIPrinter::printStackObjectReference(llvm::MIPrinter *this, int a2)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  int *v6;
  int v7;
  llvm::raw_ostream *v8;
  int *v9;
  int *v10;
  int *v11;
  char v12;
  int v13;
  int *v14;
  size_t v15;
  size_t v16;
  int v18;
  unsigned int v19;

  v2 = (uint64_t *)*((_QWORD *)this + 3);
  v3 = *v2;
  v4 = *((_DWORD *)v2 + 4);
  if (v4)
  {
    v5 = (v4 - 1) & (37 * a2);
    v6 = (int *)(v3 + 40 * v5);
    v7 = *v6;
    if (*v6 == a2)
      goto LABEL_3;
    v18 = 1;
    while (v7 != 0x7FFFFFFF)
    {
      v19 = v5 + v18++;
      v5 = v19 & (v4 - 1);
      v6 = (int *)(v3 + 40 * v5);
      v7 = *v6;
      if (*v6 == a2)
        goto LABEL_3;
    }
  }
  v6 = (int *)(v3 + 40 * v4);
LABEL_3:
  v8 = *(llvm::raw_ostream **)this;
  v11 = (int *)*((_QWORD *)v6 + 1);
  v10 = v6 + 2;
  v9 = v11;
  v12 = *((_BYTE *)v10 + 23);
  v13 = v12;
  if (v12 >= 0)
    v14 = v10;
  else
    v14 = v9;
  v15 = v12 & 0x7F;
  if (v13 >= 0)
    v16 = v15;
  else
    v16 = *((_QWORD *)v10 + 1);
  return llvm::MachineOperand::printStackObjectReference(v8, v10[6], *((unsigned __int8 *)v10 + 28), v14, v16);
}

void llvm::guessSuccessors(llvm::MachineBasicBlock *this, uint64_t a2, char *a3)
{
  char *v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  unint64_t v13;
  char v14;
  uint64_t LastNonDebugInstr;
  char hasPropertyInBundle;
  _BYTE *v18;
  _BYTE *v19;
  uint64_t v20;
  int v21;
  _BYTE v22[64];

  v18 = v22;
  v19 = v22;
  v20 = 8;
  v21 = 0;
  v5 = (char *)this + 48;
  v6 = *((_QWORD *)this + 7);
  if ((llvm::MachineBasicBlock *)v6 != (llvm::MachineBasicBlock *)((char *)this + 48))
  {
    do
    {
      if (**(_WORD **)(v6 + 16))
      {
        if (**(_WORD **)(v6 + 16) != 69)
        {
          v8 = *(unsigned int *)(v6 + 40);
          if ((_DWORD)v8)
          {
            v9 = 32 * v8;
            v10 = (uint64_t *)(*(_QWORD *)(v6 + 32) + 16);
            do
            {
              if (*((_BYTE *)v10 - 16) == 4)
              {
                v11 = *v10;
                sub_1C4774094((llvm::SmallPtrSetImplBase *)&v18, *v10);
                if (v12)
                {
                  v13 = *(unsigned int *)(a2 + 8);
                  if (v13 >= *(unsigned int *)(a2 + 12))
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, a2 + 16, v13 + 1, 8);
                    v13 = *(unsigned int *)(a2 + 8);
                  }
                  *(_QWORD *)(*(_QWORD *)a2 + 8 * v13) = v11;
                  ++*(_DWORD *)(a2 + 8);
                }
              }
              v10 += 4;
              v9 -= 32;
            }
            while (v9);
            if (!v6)
              goto LABEL_17;
          }
        }
      }
      if ((*(_BYTE *)v6 & 4) == 0)
      {
LABEL_17:
        while ((*(_WORD *)(v6 + 44) & 8) != 0)
          v6 = *(_QWORD *)(v6 + 8);
      }
      v6 = *(_QWORD *)(v6 + 8);
    }
    while ((char *)v6 != v5);
  }
  v14 = 1;
  LastNonDebugInstr = llvm::MachineBasicBlock::getLastNonDebugInstr(this, 1);
  if (v5 != (char *)LastNonDebugInstr)
  {
    if ((*(_WORD *)(LastNonDebugInstr + 44) & 0xC) != 0 && (*(_WORD *)(LastNonDebugInstr + 44) & 4) == 0)
      hasPropertyInBundle = llvm::MachineInstr::hasPropertyInBundle(LastNonDebugInstr, 256, 1);
    else
      hasPropertyInBundle = *(_BYTE *)(*(_QWORD *)(LastNonDebugInstr + 16) + 9) & 1;
    v14 = hasPropertyInBundle ^ 1;
  }
  *a3 = v14;
  if (v19 != v18)
    free(v19);
}

BOOL llvm::MIPrinter::canPredictBranchProbabilities(llvm::MIPrinter *this, const llvm::MachineBasicBlock *a2)
{
  char *v3;
  char *v4;
  _BOOL8 v5;
  _QWORD *v7;
  uint64_t v8;
  int *v9;
  int *v10;
  int v11;
  int v12;
  int v13;
  BOOL v14;
  void *v15;
  uint64_t v16;
  _BYTE v17[32];
  void *v18;
  uint64_t v19;
  _QWORD v20[5];

  v20[4] = *MEMORY[0x1E0C80C00];
  if (((*((_QWORD *)a2 + 12) - *((_QWORD *)a2 + 11)) & 0x7FFFFFFF0) == 0)
    return 1;
  v3 = (char *)*((_QWORD *)a2 + 14);
  v4 = (char *)*((_QWORD *)a2 + 15);
  if (v3 == v4)
    return 1;
  v18 = v20;
  v19 = 0x800000000;
  sub_1C617D750((unsigned int *)&v18, v3, v4);
  sub_1C50D6C6C((unsigned int *)v18, (unsigned int *)v18 + v19);
  v15 = v17;
  v16 = 0x800000000;
  sub_1C4893E04((char *)&v15, v19, -1);
  sub_1C50D6C6C((unsigned int *)v15, (unsigned int *)v15 + v16);
  v7 = v18;
  if ((_DWORD)v19)
  {
    v8 = 4 * v19 - 4;
    v9 = (int *)v15;
    v10 = (int *)v18;
    do
    {
      v12 = *v9++;
      v11 = v12;
      v13 = *v10++;
      v5 = v13 == v11;
      v14 = v13 != v11 || v8 == 0;
      v8 -= 4;
    }
    while (!v14);
  }
  else
  {
    v5 = 1;
  }
  if (v15 != v17)
  {
    free(v15);
    v7 = v18;
  }
  if (v7 != v20)
    free(v7);
  return v5;
}

llvm::raw_ostream *llvm::MIRFormatter::printIRValue(llvm::MIRFormatter *this, llvm::raw_ostream *a2, const llvm::Value *a3, llvm::ModuleSlotTracker *a4)
{
  unsigned int v7;
  llvm::raw_ostream *result;
  _BYTE *v9;
  uint64_t LocalSlot;
  _BYTE *v11;
  char *Name;
  size_t v13;

  v7 = *((unsigned __int8 *)a2 + 16);
  if (v7 <= 3)
    return (llvm::raw_ostream *)llvm::Value::printAsOperand(a2, this, 0, a3);
  if (v7 > 0x14)
  {
    sub_1C4816AD8(this, "%ir.");
    if ((*((_BYTE *)a2 + 23) & 0x10) != 0)
    {
      Name = llvm::Value::getName(a2);
      return llvm::printLLVMNameWithoutPrefix(this, (llvm::raw_ostream *)Name, v13);
    }
    else
    {
      if (*((_QWORD *)a3 + 4))
        LocalSlot = llvm::ModuleSlotTracker::getLocalSlot((llvm::SlotTracker **)a3, a2);
      else
        LocalSlot = 0xFFFFFFFFLL;
      return llvm::MachineOperand::printIRSlotNumber(this, (llvm::raw_ostream *)LocalSlot);
    }
  }
  else
  {
    v9 = (_BYTE *)*((_QWORD *)this + 4);
    if ((unint64_t)v9 >= *((_QWORD *)this + 3))
    {
      llvm::raw_ostream::write(this, 96);
    }
    else
    {
      *((_QWORD *)this + 4) = v9 + 1;
      *v9 = 96;
    }
    result = (llvm::raw_ostream *)llvm::Value::printAsOperand(a2, this, 1, a3);
    v11 = (_BYTE *)*((_QWORD *)this + 4);
    if ((unint64_t)v11 >= *((_QWORD *)this + 3))
    {
      return llvm::raw_ostream::write(this, 96);
    }
    else
    {
      *((_QWORD *)this + 4) = v11 + 1;
      *v11 = 96;
    }
  }
  return result;
}

void llvm::printMIR(llvm *this, const std::string *a2, const llvm::Module *a3)
{
  _BYTE v4[128];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  llvm::yaml::Output::Output((llvm::yaml::Output *)v4, this, 0, 70);
  sub_1C6205B94((llvm::yaml::Output *)v4, a2);
  llvm::yaml::Output::~Output((llvm::yaml::Output *)v4);
}

llvm::yaml::Output *sub_1C6205B94(llvm::yaml::Output *a1, const std::string *a2)
{
  llvm::yaml::Output::beginDocuments(a1);
  if (llvm::yaml::Output::preflightDocument(a1, 0))
  {
    sub_1C51F458C((uint64_t)a1, a2);
    llvm::yaml::Output::postflightDocument(a1);
  }
  llvm::yaml::Output::endDocuments(a1);
  return a1;
}

uint64_t llvm::printMIR(llvm *this, llvm::raw_ostream *a2, const llvm::MachineFunction *a3)
{
  _QWORD v4[3];
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v4[1] = 0;
  v4[2] = 0;
  v4[0] = this;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  llvm::MIRPrinter::print((llvm::MIRPrinter *)v4, a2);
  return sub_1C51EA500((uint64_t)v4);
}

void sub_1C6205C24(_WORD *a1, char **a2, __n128 *a3)
{
  sub_1C47AD050((uint64_t)&qword_1ED7FD1F0, 0, 0);
  byte_1ED7FD270 = 0;
  qword_1ED7FD278 = (uint64_t)&off_1E7F9E8D8;
  *(_QWORD *)&byte_1ED7FD280 = 0;
  qword_1ED7FD1F0 = (uint64_t)&unk_1E819E898;
  qword_1ED7FD288 = (uint64_t)&off_1E819E9A0;
  qword_1ED7FD290 = (uint64_t)&off_1E7F9E8F8;
  qword_1ED7FD2A8 = (uint64_t)&qword_1ED7FD290;
  sub_1C51EA588(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FD1F0);
}

uint64_t sub_1C6205CC8(_QWORD *a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  uint64_t result;
  char v7;
  uint64_t v8;

  v8 = 0;
  v7 = 0;
  result = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD, char *, uint64_t *))(*a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if ((_DWORD)result)
  {
    sub_1C51EDDA4(a1, a3);
    return (*(uint64_t (**)(_QWORD *, uint64_t))(*a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1C6205D50(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4, uint64_t a5)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t result;
  char v13;
  uint64_t v14;

  v14 = 0;
  v13 = 0;
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a3 == *a4)
    v11 = v10;
  else
    v11 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, a2, a5, v11, &v13, &v14);
  if ((_DWORD)result)
  {
    sub_1C495C3FC(a1, a3);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v14);
  }
  else if (v13)
  {
    *a3 = *a4;
  }
  return result;
}

uint64_t sub_1C6205E1C(_QWORD *a1, unsigned int *a2)
{
  uint64_t result;
  char v5;
  uint64_t v6;

  v6 = 0;
  v5 = 0;
  result = (*(uint64_t (**)(_QWORD *, const char *, uint64_t, _QWORD, char *, uint64_t *))(*a1 + 120))(a1, "id", 1, 0, &v5, &v6);
  if ((_DWORD)result)
  {
    sub_1C51EE1E4(a1, a2);
    return (*(uint64_t (**)(_QWORD *, uint64_t))(*a1 + 128))(a1, v6);
  }
  return result;
}

uint64_t sub_1C6205E94(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  double v6;
  char v7;
  uint64_t v8;

  v8 = 0;
  v7 = 0;
  result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _QWORD, char *, uint64_t *))(*a1 + 120))(a1, a2, 1, 0, &v7, &v8);
  if ((_DWORD)result)
  {
    v6 = sub_1C51EE360(a1, a3);
    return (*(uint64_t (**)(uint64_t *, uint64_t, double))(*a1 + 128))(a1, v8, v6);
  }
  return result;
}

__n128 sub_1C6205F04(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 v8;
  __n128 result;
  double v10;
  char v11;
  uint64_t v12;

  if ((*(unsigned int (**)(uint64_t *))(*a1 + 16))(a1))
    v8 = sub_1C49C7600((unsigned __int8 *)a3, (unsigned __int8 *)a4);
  else
    v8 = 0;
  v12 = 0;
  v11 = 0;
  if ((*(unsigned int (**)(uint64_t *, uint64_t, _QWORD, _BOOL8, char *, uint64_t *))(*a1 + 120))(a1, a2, 0, v8, &v11, &v12))
  {
    v10 = sub_1C51EE360(a1, a3);
    (*(void (**)(uint64_t *, uint64_t, double))(*a1 + 128))(a1, v12, v10);
  }
  else if (v11)
  {
    std::string::operator=((std::string *)a3, (const std::string *)a4);
    result = *(__n128 *)(a4 + 24);
    *(__n128 *)(a3 + 24) = result;
  }
  return result;
}

void sub_1C6205FD0(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 0x4EC4EC4EC4EC4EC5 * ((v3 - *(_QWORD *)a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1C51EE5A4((char **)a1, v6);
  }
  else if (!v5)
  {
    v7 = *(_QWORD *)a1 + 104 * a2;
    while (v3 != v7)
      v3 = sub_1C51EA338(v3 - 104);
    *(_QWORD *)(a1 + 8) = v7;
  }
}

void sub_1C6206050(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        v3 = sub_1C51EA338(v3 - 104);
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1C62060AC(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *(_QWORD *)a1) >> 4);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1C51EE850((void ***)a1, v6);
  }
  else if (!v5)
  {
    v7 = *(_QWORD *)a1 + 80 * a2;
    while (v3 != v7)
      v3 = sub_1C51EA378(v3 - 80);
    *(_QWORD *)(a1 + 8) = v7;
  }
}

void sub_1C6206124(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        v3 = sub_1C51EA378(v3 - 80);
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1C6206180(uint64_t a1, uint64_t a2)
{
  void **v4;

  if (*(_BYTE *)(a2 + 24))
  {
    if (*(_BYTE *)(a1 + 24))
    {
      if (a1 != a2)
        sub_1C51EEEA8((void **)a1, *(std::string **)a2, *(std::string **)(a2 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
    }
    else
    {
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      sub_1C51EF120((_QWORD *)a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
      *(_BYTE *)(a1 + 24) = 1;
    }
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    v4 = (void **)a1;
    sub_1C51E9EC0(&v4);
    *(_BYTE *)(a1 + 24) = 0;
  }
  return a1;
}

__n128 sub_1C6206234(uint64_t *a1, uint64_t a2, __int128 *a3)
{
  _BOOL8 v6;
  __n128 result;
  __int128 v8;
  char v9;
  uint64_t v10;

  if ((*(unsigned int (**)(uint64_t *))(*a1 + 16))(a1))
    v6 = sub_1C6206360((unsigned __int8 *)a2, (unsigned __int8 *)a3);
  else
    v6 = 0;
  v10 = 0;
  v9 = 0;
  if ((*(unsigned int (**)(uint64_t *, const char *, _QWORD, _BOOL8, char *, uint64_t *))(*a1 + 120))(a1, "frameInfo", 0, v6, &v9, &v10))
  {
    (*(void (**)(uint64_t *))(*a1 + 104))(a1);
    sub_1C51EF234(a1, a2);
    (*(void (**)(uint64_t *))(*a1 + 112))(a1);
    (*(void (**)(uint64_t *, uint64_t))(*a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    v8 = *a3;
    *(_OWORD *)(a2 + 10) = *(__int128 *)((char *)a3 + 10);
    *(_OWORD *)a2 = v8;
    std::string::operator=((std::string *)(a2 + 32), (const std::string *)(a3 + 2));
    *(_OWORD *)(a2 + 56) = *(__int128 *)((char *)a3 + 56);
    *(_OWORD *)(a2 + 72) = *(__int128 *)((char *)a3 + 72);
    std::string::operator=((std::string *)(a2 + 88), (const std::string *)((char *)a3 + 88));
    *(_OWORD *)(a2 + 112) = a3[7];
    std::string::operator=((std::string *)(a2 + 128), (const std::string *)(a3 + 8));
    result = *(__n128 *)((char *)a3 + 152);
    *(__n128 *)(a2 + 152) = result;
  }
  return result;
}

BOOL sub_1C6206360(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2
      && a1[1] == a2[1]
      && a1[2] == a2[2]
      && a1[3] == a2[3]
      && *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1)
      && *((_DWORD *)a1 + 4) == *((_DWORD *)a2 + 4)
      && *((_DWORD *)a1 + 5) == *((_DWORD *)a2 + 5)
      && a1[24] == a2[24]
      && a1[25] == a2[25]
      && sub_1C49C7600(a1 + 32, a2 + 32)
      && *((_DWORD *)a1 + 18) == *((_DWORD *)a2 + 18)
      && *((_DWORD *)a1 + 19) == *((_DWORD *)a2 + 19)
      && a1[80] == a2[80]
      && a1[81] == a2[81]
      && a1[82] == a2[82]
      && a1[83] == a2[83]
      && *((_DWORD *)a1 + 21) == *((_DWORD *)a2 + 21)
      && sub_1C49C7600(a1 + 88, a2 + 88)
      && sub_1C49C7600(a1 + 128, a2 + 128);
}

uint64_t sub_1C62064B8(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t *a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t result;
  char v11;
  uint64_t v12;

  v12 = 0;
  v11 = 0;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a3 == *a4)
    v9 = v8;
  else
    v9 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, a2, 0, v9, &v11, &v12);
  if ((_DWORD)result)
  {
    sub_1C51EF528(a1, a3);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v12);
  }
  else if (v11)
  {
    *a3 = *a4;
  }
  return result;
}

uint64_t sub_1C6206580(uint64_t *a1, uint64_t *a2, _DWORD *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  v10 = 0;
  v9 = 0;
  v6 = (*(uint64_t (**)(uint64_t *))(*a1 + 16))(a1);
  if (*(_DWORD *)a2 == *a3)
    v7 = v6;
  else
    v7 = 0;
  result = (*(uint64_t (**)(uint64_t *, const char *, _QWORD, uint64_t, char *, uint64_t *))(*a1 + 120))(a1, "offsetAdjustment", 0, v7, &v9, &v10);
  if ((_DWORD)result)
  {
    sub_1C495C580(a1, a2);
    return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *(_DWORD *)a2 = *a3;
  }
  return result;
}

uint64_t sub_1C6206640(uint64_t *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t result;
  char v13;
  uint64_t v14;

  v14 = 0;
  v13 = 0;
  v10 = (*(uint64_t (**)(uint64_t *))(*a1 + 16))(a1);
  if (*a3 == *a4)
    v11 = v10;
  else
    v11 = 0;
  result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, char *, uint64_t *))(*a1 + 120))(a1, a2, a5, v11, &v13, &v14);
  if ((_DWORD)result)
  {
    sub_1C4832A78(a1, a3);
    return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 128))(a1, v14);
  }
  else if (v13)
  {
    *a3 = *a4;
  }
  return result;
}

uint64_t sub_1C620670C(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  v10 = 0;
  v9 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == *a3)
    v7 = v6;
  else
    v7 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD, uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, "type", 0, v7, &v9, &v10);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
    sub_1C62067E0(a1, a2);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1C62067E0(uint64_t a1, _DWORD *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t result;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2)
    v5 = 0;
  else
    v5 = v4;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "default", v5))
    *a2 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 1)
    v7 = v6;
  else
    v7 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "spill-slot", v7);
  if ((_DWORD)result)
    *a2 = 1;
  return result;
}

uint64_t sub_1C6206878(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  v10 = 0;
  v9 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == *a3)
    v7 = v6;
  else
    v7 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD, uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, "offset", 0, v7, &v9, &v10);
  if ((_DWORD)result)
  {
    sub_1C51EF720(a1, a2);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1C620692C(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  v10 = 0;
  v9 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == *a3)
    v7 = v6;
  else
    v7 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD, uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, "stack-id", 0, v7, &v9, &v10);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
    sub_1C6206A00(a1, a2);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1C6206A00(uint64_t a1, _DWORD *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t result;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2)
    v5 = 0;
  else
    v5 = v4;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "default", v5))
    *a2 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 1)
    v7 = v6;
  else
    v7 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "sgpr-spill", v7))
    *a2 = 1;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 2)
    v9 = v8;
  else
    v9 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "scalable-vector", v9))
  {
    *a2 = 2;
  }
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 3)
    v11 = v10;
  else
    v11 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "wasm-local", v11))
    *a2 = 3;
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 255)
    v13 = v12;
  else
    v13 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "noalloc", v13);
  if ((_DWORD)result)
    *a2 = 255;
  return result;
}

void sub_1C6206B58(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0x34F72C234F72C235 * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1C51EF894(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 232 * a2;
    while (v3 != v7)
      v3 = sub_1C51EA3B8(v3 - 232);
    a1[1] = v7;
  }
}

void sub_1C6206BD8(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        v3 = sub_1C51EA3B8(v3 - 232);
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1C6206C34(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v4 = *a2;
  v5 = a2[1];
  v6 = a2[2];
  *(_OWORD *)(a1 + 42) = *(__int128 *)((char *)a2 + 42);
  *(_OWORD *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)a1 = v4;
  std::string::operator=((std::string *)(a1 + 64), (const std::string *)(a2 + 4));
  *(_OWORD *)(a1 + 88) = *(__int128 *)((char *)a2 + 88);
  *(_BYTE *)(a1 + 104) = *((_BYTE *)a2 + 104);
  std::string::operator=((std::string *)(a1 + 112), (const std::string *)(a2 + 7));
  *(_OWORD *)(a1 + 136) = *(__int128 *)((char *)a2 + 136);
  std::string::operator=((std::string *)(a1 + 152), (const std::string *)((char *)a2 + 152));
  *(_OWORD *)(a1 + 176) = a2[11];
  std::string::operator=((std::string *)(a1 + 192), (const std::string *)a2 + 8);
  *(_OWORD *)(a1 + 216) = *(__int128 *)((char *)a2 + 216);
  return a1;
}

uint64_t sub_1C6206CC4(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  v10 = 0;
  v9 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == *a3)
    v7 = v6;
  else
    v7 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD, uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, "type", 0, v7, &v9, &v10);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
    sub_1C6206D98(a1, a2);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1C6206D98(uint64_t a1, _DWORD *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t result;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2)
    v5 = 0;
  else
    v5 = v4;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "default", v5))
    *a2 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 1)
    v7 = v6;
  else
    v7 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "spill-slot", v7))
    *a2 = 1;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 2)
    v9 = v8;
  else
    v9 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "variable-sized", v9);
  if ((_DWORD)result)
    *a2 = 2;
  return result;
}

uint64_t sub_1C6206E70(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t result;
  char v7;
  uint64_t v8;

  v8 = 0;
  v7 = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if ((_DWORD)result)
  {
    sub_1C51EF528(a1, a3);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v8);
  }
  return result;
}

void sub_1C6206EF8(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = a1[1];
  v4 = 0xAF8AF8AF8AF8AF8BLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1C51EFB70(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 280 * a2;
    while (v3 != v7)
      v3 = sub_1C51EA418(v3 - 280);
    a1[1] = v7;
  }
}

void sub_1C6206F78(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        v3 = sub_1C51EA418(v3 - 280);
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1C6206FD4(uint64_t a1, const std::string *a2)
{
  const std::string *v2;
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v2 = a2;
  v4 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)&a2->__r_.__value_.__l + 2);
  *(_OWORD *)a1 = v4;
  std::string::operator=((std::string *)(a1 + 24), a2 + 1);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)&v2[2].__r_.__value_.__l.__data_;
  v5 = *(_OWORD *)&v2[3].__r_.__value_.__r.__words[1];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v2[2].__r_.__value_.__r.__words[2];
  *(_OWORD *)(a1 + 80) = v5;
  std::string::operator=((std::string *)(a1 + 96), v2 + 4);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)&v2[5].__r_.__value_.__l.__data_;
  v6 = *(_OWORD *)&v2[5].__r_.__value_.__r.__words[2];
  *(_QWORD *)(a1 + 152) = v2[6].__r_.__value_.__l.__size_;
  *(_OWORD *)(a1 + 136) = v6;
  std::string::operator=((std::string *)(a1 + 160), (const std::string *)((char *)v2 + 160));
  *(_OWORD *)(a1 + 184) = *(_OWORD *)&v2[7].__r_.__value_.__r.__words[2];
  std::string::operator=((std::string *)(a1 + 200), (const std::string *)((char *)v2 + 200));
  *(_OWORD *)(a1 + 224) = *(_OWORD *)&v2[9].__r_.__value_.__r.__words[1];
  v2 += 10;
  std::string::operator=((std::string *)(a1 + 240), v2);
  *(_OWORD *)(a1 + 264) = *(_OWORD *)&v2[1].__r_.__value_.__l.__data_;
  return a1;
}

uint64_t sub_1C6207090(uint64_t *a1, uint64_t *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v4 = (*(uint64_t (**)(uint64_t *))(*a1 + 24))(a1);
  if ((*(unsigned int (**)(uint64_t *))(*a1 + 16))(a1))
    v5 = ((unint64_t)(a2[1] - *a2) >> 5);
  else
    v5 = v4;
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i != v5; ++i)
    {
      v11 = 0;
      if ((*(unsigned int (**)(uint64_t *, unint64_t, uint64_t *))(*a1 + 32))(a1, i, &v11))
      {
        v8 = *a2;
        if (i >= (a2[1] - *a2) >> 5)
        {
          sub_1C62072CC(a2, i + 1);
          v8 = *a2;
        }
        v9 = v8 + v6;
        (*(void (**)(uint64_t *))(*a1 + 144))(a1);
        sub_1C62071B4(a1, v9);
        (*(void (**)(uint64_t *))(*a1 + 152))(a1);
        (*(void (**)(uint64_t *, uint64_t))(*a1 + 40))(a1, v11);
      }
      v6 += 32;
    }
  }
  return (*(uint64_t (**)(uint64_t *))(*a1 + 48))(a1);
}

void sub_1C62071B4(uint64_t *a1, uint64_t a2)
{
  std::string *v4[3];
  std::string **v5;

  sub_1C6133C1C(a1, (uint64_t)"bb", (_DWORD *)a2, 1);
  sub_1C6133C1C(a1, (uint64_t)"offset", (_DWORD *)(a2 + 4), 1);
  memset(v4, 0, sizeof(v4));
  sub_1C51EFFE4(a1, (int64x2_t *)(a2 + 8), v4);
  v5 = v4;
  sub_1C51EA488((void ***)&v5);
}

uint64_t sub_1C6207240(uint64_t *a1, _WORD *a2)
{
  uint64_t result;
  char v5;
  uint64_t v6;

  v6 = 0;
  v5 = 0;
  result = (*(uint64_t (**)(uint64_t *, const char *, uint64_t, _QWORD, char *, uint64_t *))(*a1 + 120))(a1, "arg", 1, 0, &v5, &v6);
  if ((_DWORD)result)
  {
    sub_1C51F0450(a1, a2);
    return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 128))(a1, v6);
  }
  return result;
}

void sub_1C62072CC(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 32 * a2;
      if (v3 != v5)
      {
        do
        {
          v6 = v3 - 32;
          v7 = (void **)(v3 - 24);
          sub_1C51EA488(&v7);
          v3 = v6;
        }
        while (v6 != v5);
      }
      a1[1] = v5;
    }
  }
  else
  {
    sub_1C51F08D0(a1, a2 - v4);
  }
}

uint64_t *sub_1C6207360(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      *(_QWORD *)(v6 - 32) = *(_QWORD *)(v2 + v5 - 32);
      *(_QWORD *)(v6 - 24) = 0;
      *(_QWORD *)(v6 - 16) = 0;
      *(_QWORD *)(v6 - 8) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(_QWORD *)(v6 - 8) = *(_QWORD *)(v2 + v5 - 8);
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v8 = *result;
  *result = v4;
  a2[1] = v8;
  v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void sub_1C62073F0(void **a1)
{
  char *v1;
  char *v3;
  void *v4;
  char *v5;
  void **v6;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = v3 - 32;
        v6 = (void **)(v3 - 24);
        sub_1C51EA488(&v6);
        v3 = v5;
      }
      while (v5 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1C6207468(uint64_t *a1, _DWORD *a2)
{
  sub_1C6133C1C(a1, (uint64_t)"srcinst", a2, 1);
  sub_1C6133C1C(a1, (uint64_t)"srcop", a2 + 1, 1);
  sub_1C6133C1C(a1, (uint64_t)"dstinst", a2 + 2, 1);
  sub_1C6133C1C(a1, (uint64_t)"dstop", a2 + 3, 1);
  return sub_1C6133C1C(a1, (uint64_t)"subreg", a2 + 4, 1);
}

uint64_t sub_1C6207518(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  char v5;
  uint64_t v6;

  v6 = 0;
  v5 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, _QWORD, _QWORD, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, "machineFunctionInfo", 0, 0, &v5, &v6);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1);
    if (*a2)
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*a2 + 16))(*a2, a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 112))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v6);
  }
  return result;
}

void sub_1C62075BC(uint64_t *a1, _DWORD *a2, uint64_t a3)
{
  _BOOL8 v6;
  char v7;
  uint64_t v8;

  if ((*(unsigned int (**)(uint64_t *))(*a1 + 16))(a1))
    v6 = sub_1C62076C4((uint64_t)a2, a3);
  else
    v6 = 0;
  v8 = 0;
  v7 = 0;
  if ((*(unsigned int (**)(uint64_t *, const char *, _QWORD, _BOOL8, char *, uint64_t *))(*a1 + 120))(a1, "jumpTable", 0, v6, &v7, &v8))
  {
    (*(void (**)(uint64_t *))(*a1 + 104))(a1);
    sub_1C62077C4(a1, (uint64_t)a2);
    (*(void (**)(uint64_t *))(*a1 + 112))(a1);
    (*(void (**)(uint64_t *, uint64_t))(*a1 + 128))(a1, v8);
  }
  else if (v7)
  {
    *a2 = *(_DWORD *)a3;
    if (a2 != (_DWORD *)a3)
      sub_1C51F11D8((uint64_t)(a2 + 2), *(__int128 **)(a3 + 8), *(__int128 **)(a3 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a3 + 16) - *(_QWORD *)(a3 + 8)) >> 4));
  }
}

BOOL sub_1C62076C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL8 result;

  if (*(_DWORD *)a1 != *(_DWORD *)a2)
    return 0;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a2 + 8);
  if (v3 - v2 != *(_QWORD *)(a2 + 16) - v4)
    return 0;
  if (v2 == v3)
    return 1;
  do
  {
    result = sub_1C6207744(v2, v4);
    if (!result)
      break;
    v2 += 48;
    v4 += 48;
  }
  while (v2 != v3);
  return result;
}

BOOL sub_1C6207744(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  _BOOL8 result;

  if (*(_DWORD *)a1 != *(_DWORD *)a2)
    return 0;
  v2 = *(unsigned __int8 **)(a1 + 24);
  v3 = *(unsigned __int8 **)(a1 + 32);
  v4 = *(unsigned __int8 **)(a2 + 24);
  if (v3 - v2 != *(_QWORD *)(a2 + 32) - (_QWORD)v4)
    return 0;
  if (v2 == v3)
    return 1;
  do
  {
    result = sub_1C49C7600(v2, v4);
    if (!result)
      break;
    v2 += 40;
    v4 += 40;
  }
  while (v2 != v3);
  return result;
}

void sub_1C62077C4(uint64_t *a1, uint64_t a2)
{
  __int128 *v4[3];
  __int128 **v5;

  sub_1C6207818((uint64_t)a1, (_DWORD *)a2);
  memset(v4, 0, sizeof(v4));
  sub_1C51F0C78(a1, (uint64_t *)(a2 + 8), v4);
  v5 = v4;
  sub_1C51E9F38((void ***)&v5);
}

uint64_t sub_1C6207818(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  char v5;
  uint64_t v6;

  v6 = 0;
  v5 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, _QWORD, char *, uint64_t *))(*(_QWORD *)a1 + 120))(a1, "kind", 1, 0, &v5, &v6);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
    sub_1C62078B4(a1, a2);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 128))(a1, v6);
  }
  return result;
}

uint64_t sub_1C62078B4(uint64_t a1, _DWORD *a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t result;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2)
    v5 = 0;
  else
    v5 = v4;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "block-address", v5))
    *a2 = 0;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 1)
    v7 = v6;
  else
    v7 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "gp-rel64-block-address", v7))
  {
    *a2 = 1;
  }
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 2)
    v9 = v8;
  else
    v9 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "gp-rel32-block-address", v9))
  {
    *a2 = 2;
  }
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 3)
    v11 = v10;
  else
    v11 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "label-difference32", v11))
  {
    *a2 = 3;
  }
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 4)
    v13 = v12;
  else
    v13 = 0;
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "inline", v13))
    *a2 = 4;
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (*a2 == 5)
    v15 = v14;
  else
    v15 = 0;
  result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 168))(a1, "custom32", v15);
  if ((_DWORD)result)
    *a2 = 5;
  return result;
}

void sub_1C6207A4C(uint64_t *a1, uint64_t a2)
{
  std::string *v4[3];
  std::string **v5;

  sub_1C6205E1C(a1, (unsigned int *)a2);
  memset(v4, 0, sizeof(v4));
  sub_1C51F0EA0(a1, (int64x2_t *)(a2 + 24), v4);
  v5 = v4;
  sub_1C51E9EC0((void ***)&v5);
}

void sub_1C6207AA0(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1C51F1034(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 48 * a2;
    if (v3 != v7)
    {
      do
      {
        v8 = v3 - 48;
        v9 = (void **)(v3 - 24);
        sub_1C51E9EC0(&v9);
        v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

uint64_t *sub_1C6207B40(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *result;
  v3 = result[1];
  v4 = a2[1];
  if (v3 == *result)
  {
    v5 = a2[1];
  }
  else
  {
    do
    {
      v5 = v4 - 48;
      v6 = *(_QWORD *)(v3 - 32);
      *(_OWORD *)(v4 - 48) = *(_OWORD *)(v3 - 48);
      *(_QWORD *)(v4 - 32) = v6;
      *(_QWORD *)(v4 - 24) = 0;
      *(_QWORD *)(v4 - 16) = 0;
      *(_QWORD *)(v4 - 8) = 0;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(_QWORD *)(v4 - 8) = *(_QWORD *)(v3 - 8);
      *(_QWORD *)(v3 - 24) = 0;
      *(_QWORD *)(v3 - 16) = 0;
      *(_QWORD *)(v3 - 8) = 0;
      v3 -= 48;
      v4 -= 48;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  v7 = *result;
  *result = v5;
  a2[1] = v7;
  v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void sub_1C6207BD8(void **a1)
{
  char *v1;
  char *v3;
  void *v4;
  char *v5;
  void **v6;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = v3 - 48;
        v6 = (void **)(v3 - 24);
        sub_1C51E9EC0(&v6);
        v3 = v5;
      }
      while (v5 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__n128 sub_1C6207C50(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 v6;
  __n128 result;
  double v8;
  char v9;
  uint64_t v10;

  if ((*(unsigned int (**)(uint64_t *))(*a1 + 16))(a1))
    v6 = sub_1C49C7600((unsigned __int8 *)a2, (unsigned __int8 *)a3);
  else
    v6 = 0;
  v10 = 0;
  v9 = 0;
  if ((*(unsigned int (**)(uint64_t *, const char *, _QWORD, _BOOL8, char *, uint64_t *))(*a1 + 120))(a1, "body", 0, v6, &v9, &v10))
  {
    v8 = sub_1C51F1458(a1, a2);
    (*(void (**)(uint64_t *, uint64_t, double))(*a1 + 128))(a1, v10, v8);
  }
  else if (v9)
  {
    std::string::operator=((std::string *)a2, (const std::string *)a3);
    result = *(__n128 *)(a3 + 24);
    *(__n128 *)(a2 + 24) = result;
  }
  return result;
}

uint64_t sub_1C6207D1C(uint64_t a1, std::string **a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if ((std::string **)a1 != a2)
      sub_1C51EEEA8((void **)a1, *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    sub_1C51EF120((_QWORD *)a1, (uint64_t)*a2, (uint64_t)a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t llvm::obfuscateModule(llvm *this, llvm::Module *a2, const llvm::TargetMachine *a3)
{
  uint64_t v5;
  uint64_t v6;
  char v7;
  BOOL v8;
  unsigned __int8 *v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  llvm *v15;
  llvm::raw_ostream *v16;
  llvm::raw_ostream *v17;
  const char *v18;
  size_t v19;
  llvm::raw_ostream *v20;
  _BYTE v22[96];
  int v23;
  const std::error_category *v24;
  _QWORD v25[4];
  _QWORD v26[32];

  v26[31] = *MEMORY[0x1E0C80C00];
  sub_1C6207FE0((uint64_t)v26, "__hidden#", 9uLL, "_", 1uLL, (uint64_t)"__ir_hidden#", 12);
  v25[0] = 0;
  v25[1] = 0;
  v25[2] = 0x800000000;
  v5 = qword_1ED7FD400;
  v6 = unk_1ED7FD408;
  while (v5 != v6)
  {
    v7 = *(_BYTE *)(v5 + 23);
    v8 = v7 < 0;
    if (v7 >= 0)
      v9 = (unsigned __int8 *)v5;
    else
      v9 = *(unsigned __int8 **)v5;
    v10 = v7 & 0x7F;
    if (v8)
      v11 = *(_QWORD *)(v5 + 8);
    else
      v11 = v10;
    sub_1C4F024D8((llvm::StringMapImpl *)v25, v9, v11);
    v5 += 24;
  }
  llvm::obfuscateModule((uint64_t)this, (uint64_t)a2, (uint64_t)v26, (uint64_t)v25);
  v12 = qword_1ED7FD4E0;
  if (qword_1ED7FD4E8 >= 0)
    v12 = HIBYTE(qword_1ED7FD4E8) & 0x7F;
  if (v12)
  {
    v23 = 0;
    v24 = std::system_category();
    if (qword_1ED7FD4E8 >= 0)
      v13 = HIBYTE(qword_1ED7FD4E8) & 0x7F;
    else
      v13 = qword_1ED7FD4E0;
    if (qword_1ED7FD4E8 >= 0)
      v14 = &qword_1ED7FD4D8;
    else
      v14 = (uint64_t *)qword_1ED7FD4D8;
    v15 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v22, v14, v13, (uint64_t)&v23, 0);
    if (v23)
    {
      v16 = (llvm::raw_ostream *)llvm::errs(v15);
      v17 = sub_1C4816AD8(v16, "could not open obfuscation symbol map: ");
      if (qword_1ED7FD4E8 >= 0)
        v18 = (const char *)&qword_1ED7FD4D8;
      else
        v18 = (const char *)qword_1ED7FD4D8;
      if (qword_1ED7FD4E8 >= 0)
        v19 = HIBYTE(qword_1ED7FD4E8) & 0x7F;
      else
        v19 = qword_1ED7FD4E0;
      v20 = llvm::raw_ostream::write(v17, v18, v19);
      sub_1C4816AD8(v20, "\n");
    }
    else
    {
      (*(void (**)(_QWORD *, _BYTE *))(v26[0] + 16))(v26, v22);
      llvm::raw_fd_ostream::close((llvm::raw_fd_ostream *)v22);
    }
    llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v22);
  }
  sub_1C4F02264((uint64_t)v25);
  sub_1C6208174((uint64_t)v26);
  return 0;
}

void llvm::initializeObfuscateModulePass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FD378);
  if (v2 != -1)
  {
    v5[0] = sub_1C51F6AA4;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FD378, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C6207FE0(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  char *v18;
  const char *v19;

  v14 = (_QWORD *)sub_1C62080D8(a1);
  *v14 = &unk_1E81A19D0;
  v15 = (uint64_t)(v14 + 1);
  v16 = (char *)sub_1C484358C((uint64_t)(v14 + 1), (a3 + 1), 0);
  v17 = v16;
  v16[a3] = 0;
  if (a3)
    memmove(v16, a2, a3);
  *(_QWORD *)(a1 + 168) = v17;
  *(_QWORD *)(a1 + 176) = strlen(v17);
  v18 = (char *)sub_1C484358C(v15, (a5 + 1), 0);
  v19 = v18;
  v18[a5] = 0;
  if (a5)
    memmove(v18, a4, a5);
  *(_QWORD *)(a1 + 184) = v19;
  *(_QWORD *)(a1 + 192) = strlen(v19);
  *(_QWORD *)(a1 + 200) = a6;
  *(_QWORD *)(a1 + 208) = a7;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  return a1;
}

uint64_t sub_1C62080D8(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &unk_1E8148190;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  v2 = a1 + 8;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 24) = a1 + 40;
  *(_DWORD *)(a1 + 36) = 4;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = a1 + 88;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 96) = 1;
  llvm::StringMapImpl::StringMapImpl(a1 + 104, 64, 24);
  *(_QWORD *)(a1 + 128) = v2;
  llvm::StringMapImpl::StringMapImpl(a1 + 136, 32, 24);
  *(_QWORD *)(a1 + 160) = v2;
  return a1;
}

uint64_t sub_1C6208174(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &unk_1E81A19D0;
  v2 = *(void **)(a1 + 224);
  if (v2)
  {
    *(_QWORD *)(a1 + 232) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = &unk_1E8148190;
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 104));
  sub_1C4926AE8(a1 + 8);
  return a1;
}

_QWORD *sub_1C62081DC(uint64_t a1, unint64_t a2)
{
  _QWORD *result;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  result = (_QWORD *)sub_1C51F72B0(a1, a2);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_QWORD *)a1 + 96 * v4;
  *(_QWORD *)v5 = *result;
  *(_OWORD *)(v5 + 16) = xmmword_1C64638C0;
  *(_QWORD *)(v5 + 8) = v5 + 32;
  v6 = v5 + 8;
  if (result[2])
  {
    result = (_QWORD *)sub_1C4FE6ED8(v6, (uint64_t)(result + 1));
    v4 = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v4 + 1;
  return result;
}

void sub_1C6208248(uint64_t a1, unint64_t a2)
{
  void *v3;
  int v4;
  unint64_t v5;

  v5 = 0;
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 96, &v5);
  sub_1C62082B4((uint64_t *)a1, (uint64_t)v3);
  v4 = v5;
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1C62082B4(uint64_t *a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    v4 = *a1 + 96 * v2;
    v5 = a2 + 32;
    v6 = *a1 + 8;
    do
    {
      v7 = v6 - 8;
      *(_QWORD *)(v5 - 32) = *(_QWORD *)(v6 - 8);
      *(_QWORD *)(v5 - 24) = v5;
      *(_OWORD *)(v5 - 16) = xmmword_1C64638C0;
      if (*(_QWORD *)(v6 + 8))
        sub_1C4FE6ED8(v5 - 24, v6);
      v5 += 96;
      v6 += 96;
    }
    while (v7 + 96 != v4);
    v8 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v8)
    {
      v9 = *a1;
      v10 = 96 * v8;
      do
      {
        v11 = *(void **)(v9 + v10 - 88);
        if ((void *)(v9 + v10 - 64) != v11)
          free(v11);
        v10 -= 96;
      }
      while (v10);
    }
  }
}

char **sub_1C6208380(char **a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v2 = *a1;
  v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    v4 = 96 * v3;
    do
    {
      v5 = *(char **)&v2[v4 - 88];
      if (&v2[v4 - 64] != v5)
        free(v5);
      v4 -= 96;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2))
    free(v2);
  return a1;
}

void sub_1C62083F4(_WORD *a1, _WORD *a2, __int128 *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7FD380, 1, 0);
  qword_1ED7FD400 = 0;
  unk_1ED7FD408 = 0;
  qword_1ED7FD410 = 0;
  unk_1ED7FD418 = 0;
  qword_1ED7FD380 = (uint64_t)&unk_1E81409D8;
  qword_1ED7FD420 = 0;
  unk_1ED7FD428 = 0;
  qword_1ED7FD430 = (uint64_t)&unk_1E819E970;
  qword_1ED7FD438 = (uint64_t)&unk_1E81415E0;
  qword_1ED7FD450 = (uint64_t)&qword_1ED7FD438;
  llvm::cl::Option::setArgStr(v6, "obfuscate-preserve", 0x12uLL);
  word_1ED7FD38A = word_1ED7FD38A & 0xFFF8 | *a1 & 7;
  word_1ED7FD38A = (8 * (*a2 & 3)) | word_1ED7FD38A & 0xFFE7;
  xmmword_1ED7FD3A0 = *a3;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FD380);
}

double sub_1C62084BC()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  result = 0.0;
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_DWORD *)(v0 + 20) = 8;
  return result;
}

uint64_t sub_1C62084F4(uint64_t result)
{
  if (result)
  {
    sub_1C4F02264(result);
    JUMPOUT(0x1CAA32FC0);
  }
  return result;
}

void llvm::initializeOptimizePHIsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FD540);
  if (v2 != -1)
  {
    v5[0] = sub_1C51F89C8;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FD540, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C6208584@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, std::future<void> *a4@<X8>)
{
  _QWORD *v7;
  _QWORD *v8;
  void (**v9)(_QWORD *);
  void (**v10)(void);
  int v11;
  uint64_t result;
  uint64_t (**v13)(void);
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;
  _QWORD v17[3];
  _QWORD *v18;
  _QWORD v19[3];
  _QWORD *v20;
  std::future<void> v21[2];

  v21[1] = *(std::future<void> *)MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)a2[3];
  if (v7)
  {
    if (v7 == a2)
    {
      v18 = v17;
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v17);
    }
    else
    {
      v18 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v7 + 16))(v7);
    }
  }
  else
  {
    v18 = 0;
  }
  sub_1C6208780(v17, (uint64_t)v19);
  v8 = v18;
  if (v18 == v17)
  {
    v9 = (void (**)(_QWORD *))(v17[0] + 32);
    v8 = v17;
LABEL_5:
    (*v9)(v8);
    goto LABEL_6;
  }
  if (v18)
  {
    v9 = (void (**)(_QWORD *))(*v18 + 40);
    goto LABEL_5;
  }
LABEL_6:
  std::mutex::lock((std::mutex *)(a1 + 248));
  if (v20)
  {
    if (v20 == v19)
    {
      v15 = v14;
      (*(void (**)(_QWORD *, _QWORD *))(v19[0] + 24))(v19, v14);
    }
    else
    {
      v15 = v20;
      v20 = 0;
    }
  }
  else
  {
    v15 = 0;
  }
  v16 = a3;
  sub_1C620887C((_QWORD *)(a1 + 200), (uint64_t)v14);
  if (v15 == v14)
  {
    v10 = (void (**)(void))(v14[0] + 32);
  }
  else
  {
    if (!v15)
      goto LABEL_12;
    v10 = (void (**)(void))(*v15 + 40);
  }
  (*v10)();
LABEL_12:
  v11 = *(_DWORD *)(a1 + 408) + *(_DWORD *)(a1 + 240);
  std::mutex::unlock((std::mutex *)(a1 + 248));
  std::condition_variable::notify_one((std::condition_variable *)(a1 + 312));
  llvm::ThreadPool::grow((llvm::ThreadPool *)a1, v11);
  a4->__state_ = (std::__assoc_sub_state *)v21[0];
  v21[0].__state_ = 0;
  std::future<void>::~future(v21);
  result = (uint64_t)v20;
  if (v20 == v19)
  {
    v13 = (uint64_t (**)(void))(v19[0] + 32);
  }
  else
  {
    if (!v20)
      return result;
    v13 = (uint64_t (**)(void))(*v20 + 40);
  }
  return (*v13)();
}

void sub_1C6208780(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  std::promise<void> *v4;
  std::promise<void> *v5;
  _QWORD *v6;
  std::future<void> v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = (std::promise<void> *)operator new(0x20uLL);
  v4[2].__state_ = 0;
  v4->__state_ = (std::__assoc_sub_state *)&unk_1E81482A0;
  v4[1].__state_ = 0;
  v5 = std::promise<void>::promise(v4 + 3);
  std::promise<void>::get_future(v5);
  *(_QWORD *)&v8 = v4 + 3;
  *((_QWORD *)&v8 + 1) = v4;
  v6 = (_QWORD *)a1[3];
  if (v6)
  {
    if (v6 == a1)
    {
      v10 = &v9;
      (*(void (**)(_QWORD *))(*a1 + 24))(a1);
    }
    else
    {
      v10 = (uint64_t *)(*(uint64_t (**)(_QWORD *))(*v6 + 16))(v6);
    }
  }
  else
  {
    v10 = 0;
  }
  sub_1C51F9A54(a2, &v8, &v7);
  sub_1C6208B50((uint64_t)&v8);
  std::future<void>::~future(&v7);
}

uint64_t sub_1C620887C(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;

  v4 = a1[1];
  v5 = a1[2];
  v6 = 102 * ((v5 - v4) >> 3) - 1;
  if (v5 == v4)
    v6 = 0;
  if (v6 == a1[5] + a1[4])
  {
    sub_1C51F9C3C((uint64_t)a1);
    v4 = a1[1];
    v5 = a1[2];
  }
  if (v5 == v4)
  {
    v8 = 0;
  }
  else
  {
    v7 = a1[4] + a1[5];
    v8 = *(_QWORD *)(v4 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  }
  v9 = *(_QWORD *)(a2 + 24);
  if (v9)
  {
    if (v9 == a2)
    {
      *(_QWORD *)(v8 + 24) = v8;
      (*(void (**)(_QWORD, unint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), v8);
      v4 = a1[1];
      v5 = a1[2];
    }
    else
    {
      *(_QWORD *)(v8 + 24) = v9;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(_QWORD *)(v8 + 24) = 0;
  }
  *(_QWORD *)(v8 + 32) = *(_QWORD *)(a2 + 32);
  v10 = a1[4];
  v11 = a1[5] + 1;
  a1[5] = v11;
  v12 = v10 + v11;
  v13 = (_QWORD *)(v4 + 8 * (v12 / 0x66));
  v14 = *v13 + 40 * (v12 % 0x66);
  if (v5 == v4)
    v15 = 0;
  else
    v15 = v14;
  if (v15 == *v13)
    v15 = *(v13 - 1) + 4080;
  return v15 - 40;
}

void sub_1C62089C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E81482A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1C62089DC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E81482A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1CAA32FC0);
}

void sub_1C6208A10()
{
  JUMPOUT(0x1CAA32EF4);
}

_QWORD *sub_1C6208A1C(_QWORD *a1)
{
  *a1 = &off_1E81482D8;
  sub_1C6208B50((uint64_t)(a1 + 1));
  return a1;
}

void sub_1C6208A4C(_QWORD *a1)
{
  *a1 = &off_1E81482D8;
  sub_1C6208B50((uint64_t)(a1 + 1));
  JUMPOUT(0x1CAA32FC0);
}

_QWORD *sub_1C6208A8C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)(a1 + 8);
  v2 = operator new(0x38uLL);
  *v2 = &off_1E81482D8;
  sub_1C51F9BB0(v2 + 1, v1);
  return v2;
}

_QWORD *sub_1C6208ACC(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E81482D8;
  return sub_1C51F9BB0(a2 + 1, (_QWORD *)(a1 + 8));
}

uint64_t sub_1C6208AE8(uint64_t a1)
{
  return sub_1C6208B50(a1 + 8);
}

void sub_1C6208AF0(void *a1)
{
  sub_1C6208B50((uint64_t)a1 + 8);
  operator delete(a1);
}

void sub_1C6208B18(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    std::promise<void>::set_value(*(std::promise<void> **)(a1 + 8));
  }
  else
  {
    sub_1C485C2F0();
    sub_1C6208B50(v3);
  }
}

uint64_t sub_1C6208B50(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(a1 + 40);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  return a1;
}

void llvm::initializePeepholeOptimizerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FD548);
  if (v2 != -1)
  {
    v5[0] = sub_1C51FA2B0;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FD548, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C6208C3C(_WORD *a1, int **a2, __int128 *a3)
{
  uint64_t v6;

  v6 = sub_1C47AD050((uint64_t)&qword_1ED7FD850, 0, 0);
  dword_1ED7FD8D0 = 0;
  qword_1ED7FD8D8 = (uint64_t)&off_1E7F952A8;
  *(_QWORD *)&dword_1ED7FD8E0 = 0;
  qword_1ED7FD850 = (uint64_t)&unk_1E819E3B0;
  qword_1ED7FD8E8 = (uint64_t)&unk_1E819E2C0;
  qword_1ED7FD8F0 = (uint64_t)&off_1E7F95260;
  qword_1ED7FD908 = (uint64_t)&qword_1ED7FD8F0;
  llvm::cl::Option::setArgStr(v6, "rewrite-phi-limit", 0x11uLL);
  word_1ED7FD85A = (32 * (*a1 & 3)) | word_1ED7FD85A & 0xFF9F;
  dword_1ED7FD8D0 = **a2;
  byte_1ED7FD8E4 = 1;
  dword_1ED7FD8E0 = dword_1ED7FD8D0;
  xmmword_1ED7FD870 = *a3;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1ED7FD850);
}

void llvm::initializePHIEliminationPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FD9D0);
  if (v2 != -1)
  {
    v5[0] = sub_1C51FEE68;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FD9D0, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C6208D7C(uint64_t **a1, unint64_t a2)
{
  unint64_t v2;

  v2 = ((char *)a1[1] - (char *)*a1) >> 5;
  if (a2 <= v2)
  {
    if (a2 < v2)
      sub_1C5202020(a1, &(*a1)[4 * a2]);
  }
  else
  {
    sub_1C5201E78(a1, a2 - v2);
  }
}

BOOL sub_1C6208DAC(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v5;
  unint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  unsigned int *i;
  unsigned int v10;

  v5 = (_QWORD *)(a1 + 248);
  v6 = a2 & 0x7FFFFFFF;
  if (v6 >= *(unsigned int *)(a1 + 256))
    sub_1C61E5C60((uint64_t *)(a1 + 248), v6 + 1, a1 + 264);
  result = sub_1C511F3EC(*v5 + 56 * v6, a3);
  if (result)
  {
    v8 = *(unsigned int *)(a3 + 40);
    if ((_DWORD)v8)
    {
      for (i = *(unsigned int **)(a3 + 32); ; i += 8)
      {
        v10 = *i;
        if (!*i && ((v10 >> 26) & ~HIBYTE(v10) & 1) != 0 && i[1] == a2)
          break;
        if (!--v8)
          return result;
      }
      *i = v10 & 0xFBFFFFFF;
    }
  }
  return result;
}

_QWORD *sub_1C6208E5C(uint64_t a1, unsigned int a2, llvm::MachineInstr *this, int a4)
{
  _QWORD *result;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  llvm::MachineInstr *v14;

  result = (_QWORD *)llvm::MachineInstr::addRegisterKilled(this, a2, *(_QWORD *)(a1 + 376), a4);
  if ((_DWORD)result)
  {
    v8 = a2 & 0x7FFFFFFF;
    if (v8 >= *(unsigned int *)(a1 + 256))
      sub_1C61E5C60((uint64_t *)(a1 + 248), v8 + 1, a1 + 264);
    v9 = *(_QWORD *)(a1 + 248);
    v14 = this;
    v10 = v9 + 56 * v8;
    v11 = *(_QWORD **)(v10 + 40);
    v12 = *(_QWORD *)(v10 + 48);
    v13 = (_QWORD *)(v10 + 40);
    if ((unint64_t)v11 >= v12)
    {
      result = sub_1C4DFEA3C((void **)(v9 + 56 * v8 + 32), &v14);
    }
    else
    {
      *v11 = this;
      result = v11 + 1;
    }
    *v13 = result;
  }
  return result;
}

_QWORD *sub_1C6208F08(uint64_t a1, unsigned int a2, llvm::MachineInstr *this, int a4)
{
  _QWORD *result;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  llvm::MachineInstr *v14;

  result = (_QWORD *)llvm::MachineInstr::addRegisterDead(this, a2, *(_QWORD *)(a1 + 376), a4);
  if ((_DWORD)result)
  {
    v8 = a2 & 0x7FFFFFFF;
    if (v8 >= *(unsigned int *)(a1 + 256))
      sub_1C61E5C60((uint64_t *)(a1 + 248), v8 + 1, a1 + 264);
    v9 = *(_QWORD *)(a1 + 248);
    v14 = this;
    v10 = v9 + 56 * v8;
    v11 = *(_QWORD **)(v10 + 40);
    v12 = *(_QWORD *)(v10 + 48);
    v13 = (_QWORD *)(v10 + 40);
    if ((unint64_t)v11 >= v12)
    {
      result = sub_1C4DFEA3C((void **)(v9 + 56 * v8 + 32), &v14);
    }
    else
    {
      *v11 = this;
      result = v11 + 1;
    }
    *v13 = result;
  }
  return result;
}

BOOL sub_1C6208FB4(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v5;
  unint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  _DWORD *i;

  v5 = (_QWORD *)(a1 + 248);
  v6 = a2 & 0x7FFFFFFF;
  if (v6 >= *(unsigned int *)(a1 + 256))
    sub_1C61E5C60((uint64_t *)(a1 + 248), v6 + 1, a1 + 264);
  result = sub_1C511F3EC(*v5 + 56 * v6, a3);
  if (result)
  {
    v8 = *(unsigned int *)(a3 + 40);
    if ((_DWORD)v8)
    {
      for (i = *(_DWORD **)(a3 + 32); (*i & 0x10000FF) != 0x1000000 || i[1] != a2; i += 8)
      {
        if (!--v8)
          return result;
      }
      *i &= ~0x4000000u;
    }
  }
  return result;
}

uint64_t sub_1C6209068(uint64_t a1, uint64_t a2, int *a3, _OWORD *a4)
{
  uint64_t result;
  _DWORD *v9;
  char v10;
  uint64_t v11;
  _DWORD *v12;

  v12 = 0;
  result = sub_1C61D0CF8(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), *a3, &v12);
  v9 = v12;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    result = (uint64_t)sub_1C61D0D94(a2, a3, v12);
    v9 = (_DWORD *)result;
    *(_DWORD *)result = *a3;
    *(_OWORD *)(result + 8) = *a4;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

void llvm::initializePostRAHazardRecognizerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FDC18);
  if (v2 != -1)
  {
    v5[0] = sub_1C5202ABC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FDC18, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializePostRASchedulerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FDC20);
  if (v2 != -1)
  {
    v5[0] = sub_1C5202E48;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FDC20, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void sub_1C62091D0(__int128 *a1, const char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1ED7FDE68, "break-anti-dependencies", 0x17uLL);
  xmmword_1ED7FDE88 = *a1;
  sub_1C49C7D74(a2, (uint64_t)&qword_1ED7FDE68);
  word_1ED7FDE72 = (32 * (*a3 & 3)) | word_1ED7FDE72 & 0xFF9F;
}

void llvm::initializePreISelIntrinsicLoweringLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FDF50);
  if (v2 != -1)
  {
    v5[0] = sub_1C520474C;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FDF50, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createPreISelIntrinsicLoweringPass(llvm *this)
{
  uint64_t result;

  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = &unk_1EF8F2F30;
  *(_DWORD *)(result + 24) = 4;
  *(_QWORD *)result = &off_1E8148848;
  return result;
}

void llvm::initializeProcessImplicitDefsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FDF58);
  if (v2 != -1)
  {
    v5[0] = sub_1C5205514;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FDF58, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

void llvm::initializePEIPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FDF60);
  if (v2 != -1)
  {
    v5[0] = sub_1C5205BA8;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FDF60, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t llvm::createPrologEpilogInserterPass(llvm *this)
{
  uint64_t v1;

  v1 = operator new();
  return sub_1C5205C4C(v1);
}

uint64_t sub_1C62093E0(uint64_t a1, uint64_t a2)
{
  int8x16_t v3;
  int8x16_t v5;

  llvm::DIExpression::getFragmentInfo(*(uint64_t **)(a1 + 24), *(uint64_t **)(a1 + 32), &v5);
  v3 = v5;
  llvm::DIExpression::getFragmentInfo(*(uint64_t **)(a2 + 24), *(uint64_t **)(a2 + 32), &v5);
  if (v3.i64[1] + v3.i64[0] <= (unint64_t)v5.i64[1])
    return 0xFFFFFFFFLL;
  else
    return v5.i64[1] + v5.i64[0] <= (unint64_t)v3.i64[1];
}

_QWORD *sub_1C6209448(_DWORD *a1, uint64_t *a2)
{
  char v4;
  _QWORD *v5;
  _QWORD *v7;

  v7 = 0;
  v4 = sub_1C62094B8((uint64_t)a1, *a2, &v7);
  v5 = v7;
  if ((v4 & 1) == 0)
  {
    v5 = sub_1C620956C(a1, a2, v7);
    *v5 = *a2;
    v5[1] = v5 + 3;
    v5[2] = 0x400000000;
  }
  return v5;
}

uint64_t sub_1C62094B8(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  _QWORD *v10;
  int v11;
  BOOL v12;
  unsigned int v13;

  v3 = a1 + 8;
  if ((*(_BYTE *)a1 & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      v7 = 0;
      result = 0;
      goto LABEL_7;
    }
    v3 = *(_QWORD *)(a1 + 8);
  }
  v5 = v4 - 1;
  v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v7 = (_QWORD *)(v3 + 56 * v6);
  v8 = *v7;
  if (*v7 == a2)
  {
    result = 1;
  }
  else
  {
    v10 = 0;
    v11 = 1;
    result = 1;
    while (v8 != -4096)
    {
      if (v10)
        v12 = 0;
      else
        v12 = v8 == -8192;
      if (v12)
        v10 = v7;
      v13 = v6 + v11++;
      v6 = v13 & v5;
      v7 = (_QWORD *)(v3 + 56 * (v13 & v5));
      v8 = *v7;
      if (*v7 == a2)
        goto LABEL_7;
    }
    result = 0;
    if (v10)
      v7 = v10;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_QWORD *sub_1C620956C(_DWORD *a1, uint64_t *a2, _QWORD *a3)
{
  int v5;
  unsigned int v6;
  _QWORD *v8;

  v5 = *a1 >> 1;
  if ((*a1 & 1) != 0)
    v6 = 4;
  else
    v6 = a1[4];
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1C520AB24((uint64_t)a1, v6);
  v8 = 0;
  sub_1C62094B8((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096)
    --a1[1];
  return a3;
}

void sub_1C6209628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int v6;
  unsigned int v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  void *v13;
  _QWORD *v14;

  v4 = a2;
  v6 = *(_DWORD *)a1;
  *(_QWORD *)a1 = *(_DWORD *)a1 & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (_QWORD *)(a1 + 8);
    v9 = (_QWORD *)(a1 + 232);
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 16);
    if (!v7)
      goto LABEL_6;
    v8 = *(_QWORD **)(a1 + 8);
    v9 = &v8[7 * v7];
  }
  do
  {
    *v8 = -4096;
    v8 += 7;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      v10 = *(_QWORD *)v4;
      if ((*(_QWORD *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v14 = 0;
        sub_1C62094B8(a1, v10, &v14);
        v11 = v14;
        *v14 = *(_QWORD *)v4;
        v11[2] = 0x400000000;
        v11[1] = v11 + 3;
        v12 = (uint64_t)(v11 + 1);
        if (*(_DWORD *)(v4 + 16))
          sub_1C49EECC0(v12, (const void **)(v4 + 8));
        *(_DWORD *)a1 += 2;
        v13 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v13)
          free(v13);
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1C6209730(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 56))
    return 0;
  else
    return a1 + 16;
}

uint64_t sub_1C6209748(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 32) == *(_QWORD *)(a1 + 80))
    return 0;
  else
    return a1 + 40;
}

void llvm::PseudoSourceValue::~PseudoSourceValue(llvm::PseudoSourceValue *this)
{
  JUMPOUT(0x1CAA32FC0);
}

llvm::raw_ostream *llvm::PseudoSourceValue::printCustom(llvm::PseudoSourceValue *this, llvm::raw_ostream *a2)
{
  uint64_t v2;
  llvm::raw_ostream *v5;

  v2 = *((unsigned int *)this + 2);
  if (v2 <= 6)
    return sub_1C4816AD8(a2, off_1E8148BA8[v2]);
  v5 = sub_1C4816AD8(a2, "TargetCustom");
  return llvm::raw_ostream::operator<<(v5, *((unsigned int *)this + 2));
}

BOOL llvm::FixedStackPseudoSourceValue::isAliased(llvm::FixedStackPseudoSourceValue *this, const llvm::MachineFrameInfo *a2)
{
  return !a2
      || *(_BYTE *)(*((_QWORD *)a2 + 1) + 40 * (*((_DWORD *)a2 + 8) + *((_DWORD *)this + 4)) + 33) != 0;
}

BOOL llvm::FixedStackPseudoSourceValue::mayAlias(llvm::FixedStackPseudoSourceValue *this, const llvm::MachineFrameInfo *a2)
{
  return !a2
      || *(_BYTE *)(*((_QWORD *)a2 + 1) + 40 * (*((_DWORD *)a2 + 8) + *((_DWORD *)this + 4)) + 18) == 0;
}

llvm::raw_ostream *llvm::FixedStackPseudoSourceValue::printCustom(llvm::FixedStackPseudoSourceValue *this, llvm::raw_ostream *a2)
{
  llvm::raw_ostream *v3;

  v3 = sub_1C4816AD8(a2, "FixedStack");
  return llvm::raw_ostream::operator<<(v3, *((int *)this + 4));
}

uint64_t llvm::PseudoSourceValueManager::getConstantPool(llvm::PseudoSourceValueManager *this)
{
  return (uint64_t)this + 56;
}

uint64_t llvm::PseudoSourceValueManager::getJumpTable(llvm::PseudoSourceValueManager *this)
{
  return (uint64_t)this + 40;
}

void sub_1C6209880(uint64_t a1)
{
  _QWORD v3[2];
  uint64_t v4;
  uint64_t v5;

  sub_1C4E42548(v3, (_QWORD *)(a1 + 8));
  v5 = *(_QWORD *)(a1 + 32);
  sub_1C62099F0(v5, v4);
  if (v4 != -8192 && v4 != -4096 && v4 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(v3);
}

int32x2_t *sub_1C62098F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t *v5;
  int32x2_t *result;
  unint64_t v7;
  double v8;
  _QWORD v9[3];
  uint64_t v10;
  int32x2_t *v11;
  uint64_t (**v12)(llvm::CallbackVH *__hidden);
  _QWORD v13[2];
  uint64_t v14;
  int32x2_t *v15;

  sub_1C4E42548(v13, (_QWORD *)(a1 + 8));
  v4 = *(_QWORD *)(a1 + 32);
  v12 = &off_1E8148CF0;
  v15 = (int32x2_t *)v4;
  v9[0] = 0;
  if (sub_1C6179BF0(*(_QWORD *)v4, *(_DWORD *)(v4 + 16), v14, v9))
    v5 = (unint64_t *)v9[0];
  else
    v5 = (unint64_t *)(*(_QWORD *)v4 + 48 * *(unsigned int *)(v4 + 16));
  result = v15;
  if ((unint64_t *)(*(_QWORD *)v15 + 48 * v15[2].u32[0]) != v5)
  {
    v7 = v5[5];
    v5[5] = 0;
    sub_1C6209ABC(result, v5);
    v10 = a2;
    v11 = (int32x2_t *)v7;
    v8 = sub_1C6209B6C((uint64_t)v9, (uint64_t)v15, &v10);
    result = v11;
    if (v11)
      result = (int32x2_t *)(*(uint64_t (**)(int32x2_t *, double))(*(_QWORD *)v11 + 16))(v11, v8);
  }
  if (v14 != -8192 && v14 != -4096)
  {
    if (v14)
      return (int32x2_t *)llvm::ValueHandleBase::RemoveFromUseList(v13);
  }
  return result;
}

int32x2_t sub_1C62099F0(uint64_t a1, uint64_t a2)
{
  int32x2_t result;
  uint64_t (**v4)(llvm::CallbackVH *__hidden);
  uint64_t (*v5)(llvm::CallbackVH *__hidden);
  uint64_t v6;
  uint64_t (**v7)(llvm::CallbackVH *__hidden);
  uint64_t v8[2];
  uint64_t v9;
  uint64_t (*v10)(llvm::CallbackVH *__hidden);

  v7 = 0;
  if (sub_1C6179BF0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    v4 = v7;
    v5 = v7[5];
    v7[5] = 0;
    if (v5)
      (*(void (**)(uint64_t (*)(llvm::CallbackVH *__hidden)))(*(_QWORD *)v5 + 16))(v5);
    v8[1] = 0;
    v9 = -8192;
    v7 = &off_1E8148CF0;
    v8[0] = 2;
    v10 = 0;
    sub_1C4D98DE0((unint64_t *)v4 + 1, v8);
    v6 = v9;
    v4[4] = v10;
    if (v6 != -8192 && v6 != -4096)
    {
      if (v6)
        llvm::ValueHandleBase::RemoveFromUseList(v8);
    }
    result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

int32x2_t sub_1C6209ABC(int32x2_t *a1, unint64_t *a2)
{
  unint64_t v4;
  uint64_t v5;
  int32x2_t result;
  uint64_t v8[2];
  uint64_t v9;
  unint64_t v10;

  v4 = a2[5];
  a2[5] = 0;
  if (v4)
    (*(void (**)(unint64_t))(*(_QWORD *)v4 + 16))(v4);
  v8[1] = 0;
  v9 = -8192;
  v8[0] = 2;
  v10 = 0;
  sub_1C4D98DE0(a2 + 1, v8);
  v5 = v9;
  a2[4] = v10;
  if (v5 != -8192 && v5 != -4096 && v5 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(v8);
  result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

double sub_1C6209B6C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  double result;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15;
  uint64_t (**v16)(llvm::CallbackVH *__hidden);
  unint64_t v17;
  _QWORD v18[3];
  unint64_t v19;
  __int128 v20;
  char v21;

  v6 = *a3;
  v7 = 2;
  v13[0] = 2;
  v13[1] = 0;
  v14 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v13);
    v7 = v13[0];
    v6 = v14;
  }
  v15 = a2;
  v17 = v7 & 6;
  v18[0] = 0;
  v18[1] = v6;
  v9 = a2;
  if (v6 != -8192)
  {
    v10 = v6 == -4096 || v6 == 0;
    v9 = a2;
    if (!v10)
    {
      v18[0] = *(_QWORD *)(v7 & 0xFFFFFFFFFFFFFFF8);
      *(_QWORD *)(v7 & 0xFFFFFFFFFFFFFFF8) = &v17;
      v17 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if (v18[0])
        *(_QWORD *)v18[0] = *(_QWORD *)v18[0] & 7 | (unint64_t)v18;
      v9 = v15;
    }
  }
  v16 = &off_1E8148CF0;
  v11 = a3[1];
  a3[1] = 0;
  v18[2] = v9;
  v19 = v11;
  sub_1C6209CB4((uint64_t)&v20, a2, (uint64_t *)&v16, &v19);
  sub_1C6209F38(&v16);
  if (v14 != -8192 && v14 != -4096 && v14)
    llvm::ValueHandleBase::RemoveFromUseList(v13);
  result = *(double *)&v20;
  *(_OWORD *)a1 = v20;
  *(_BYTE *)(a1 + 16) = v21;
  return result;
}

unint64_t sub_1C6209CB4(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  unint64_t result;
  unint64_t *v9;
  char v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t *v13;

  v13 = 0;
  result = sub_1C6179BF0(*(_QWORD *)a2, *(_DWORD *)(a2 + 16), a3[3], &v13);
  v9 = v13;
  if ((result & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    v9 = (unint64_t *)sub_1C6209D6C(a2, (uint64_t)a3, (uint64_t)v13);
    result = sub_1C4D98DE0(v9 + 1, a3 + 1);
    v9[4] = a3[4];
    v12 = *a4;
    *a4 = 0;
    v9[5] = v12;
    v10 = 1;
  }
  v11 = *(_QWORD *)a2 + 48 * *(unsigned int *)(a2 + 16);
  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v11;
  *(_BYTE *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1C6209D6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  unsigned int v6;
  uint64_t v8;

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1C520CDF0(a1, v6);
  v8 = 0;
  sub_1C6179BF0(*(_QWORD *)a1, *(_DWORD *)(a1 + 16), *(_QWORD *)(a2 + 24), &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(_QWORD *)(a3 + 24) != -4096)
    --*(_DWORD *)(a1 + 12);
  return a3;
}

_QWORD *sub_1C6209E1C(_QWORD *result, uint64_t *a2, uint64_t *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v5 = result;
  result[1] = 0;
  v6 = *((unsigned int *)result + 4);
  if ((_DWORD)v6)
  {
    v7 = 48 * v6;
    v8 = (_QWORD *)(*result + 16);
    do
    {
      *v8 = 0;
      v8[1] = -4096;
      *(v8 - 2) = &off_1E8148CF0;
      *(v8 - 1) = 2;
      v8[2] = 0;
      v8 += 6;
      v7 -= 48;
    }
    while (v7);
  }
  while (a2 != a3)
  {
    v9 = a2[3];
    if ((v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v14 = 0;
      sub_1C6179BF0(*v5, *((_DWORD *)v5 + 4), v9, &v14);
      v12 = v14;
      sub_1C4D98DE0((unint64_t *)(v14 + 8), a2 + 1);
      *(_QWORD *)(v12 + 32) = a2[4];
      v13 = a2[5];
      a2[5] = 0;
      *(_QWORD *)(v12 + 40) = v13;
      ++*((_DWORD *)v5 + 2);
      result = (_QWORD *)a2[5];
      a2[5] = 0;
      if (result)
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 16))(result);
    }
    v10 = a2[3];
    if (v10 != -8192 && v10 != -4096 && v10 != 0)
      result = llvm::ValueHandleBase::RemoveFromUseList(a2 + 1);
    a2 += 6;
  }
  return result;
}

_QWORD *sub_1C6209F38(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1[5];
  a1[5] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  v3 = a1[3];
  if (v3 != -8192 && v3 != -4096 && v3 != 0)
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 1);
  return a1;
}

_DWORD *sub_1C6209F90(_DWORD *result)
{
  uint64_t v1;
  _DWORD *v2;
  uint64_t v3;

  if (*((_QWORD *)result + 1))
  {
    v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if ((_DWORD)v1)
      {
        v2 = *(_DWORD **)result;
        v3 = 16 * v1;
        do
        {
          *v2 = -1;
          v2 += 4;
          v3 -= 16;
        }
        while (v3);
      }
      *((_QWORD *)result + 1) = 0;
    }
    else
    {
      return sub_1C4AB1258(result);
    }
  }
  return result;
}

uint64_t llvm::createBasicRegisterAllocator(llvm *this)
{
  uint64_t v1;
  void (**v2)(void);
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = operator new();
  v4[0] = &off_1E7FB3428;
  v4[1] = sub_1C52293D8;
  v5 = v4;
  sub_1C52293E0(v1, v4);
  if (v5 == v4)
  {
    v2 = (void (**)(void))(v4[0] + 32);
    goto LABEL_4;
  }
  if (v5)
  {
    v2 = (void (**)(void))(*v5 + 40);
LABEL_4:
    (*v2)();
  }
  return v1;
}

void llvm::initializeRABasicPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED7FE128);
  if (v2 != -1)
  {
    v5[0] = sub_1C52292FC;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED7FE128, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

uint64_t sub_1C620A114(uint64_t a1, char *__s, const char *a3, uint64_t a4)
{
  size_t v8;
  size_t v9;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = __s;
  if (__s)
    v8 = strlen(__s);
  else
    v8 = 0;
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 24) = a3;
  if (a3)
    v9 = strlen(a3);
  else
    v9 = 0;
  *(_QWORD *)(a1 + 32) = v9;
  *(_QWORD *)(a1 + 40) = a4;
  *(_QWORD *)a1 = llvm::RegisterRegAllocBase<llvm::RegisterRegAlloc>::Registry;
  llvm::RegisterRegAllocBase<llvm::RegisterRegAlloc>::Registry = (_UNKNOWN *)a1;
  if (off_1ED7EAEB0)
    (*(void (**)(void *, char *, size_t, uint64_t, const char *))(*(_QWORD *)off_1ED7EAEB0 + 24))(off_1ED7EAEB0, __s, v8, a4, a3);
  return a1;
}

uint64_t sub_1C620A1C8(uint64_t a1, uint64_t a2)
{
  double v4;
  uint64_t v5;

  *(_QWORD *)a1 = &unk_1E8148E10;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 40) = 0;
  v4 = llvm::RegisterClassInfo::RegisterClassInfo((llvm::RegisterClassInfo *)(a1 + 48));
  v5 = *(_QWORD *)(a2 + 24);
  if (v5)
  {
    if (v5 == a2)
    {
      *(_QWORD *)(a1 + 312) = a1 + 288;
      (*(void (**)(_QWORD, double))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), v4);
    }
    else
    {
      *(_QWORD *)(a1 + 312) = (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)v5 + 16))(v5, v4);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 312) = 0;
  }
  *(_QWORD *)(a1 + 320) = a1 + 352;
  *(_QWORD *)(a1 + 328) = a1 + 352;
  *(_QWORD *)(a1 + 336) = 32;
  *(_DWORD *)(a1 + 344) = 0;
  return a1;
}

_QWORD *sub_1C620A270(_QWORD *a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &unk_1E8148E10;
  v2 = (void *)a1[41];
  if (v2 != (void *)a1[40])
    free(v2);
  v3 = (_QWORD *)a1[39];
  if (v3 == a1 + 36)
  {
    v4 = 4;
    v3 = a1 + 36;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  sub_1C61D92E0(a1 + 6);
  return a1;
}

void llvm::initializeRegAllocEvictionAdvisorAnalysisPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2;
  llvm *v3;
  _QWORD *v4;
  _QWORD v5[2];

  v3 = this;
  v2 = atomic_load(&qword_1ED82FCE8);
  if (v2 != -1)
  {
    v5[0] = sub_1C522AA40;
    v5[1] = &v3;
    v4 = v5;
    std::__call_once(&qword_1ED82FCE8, &v4, (void (__cdecl *)(void *))sub_1C4776838);
  }
}

double llvm::callDefaultCtor<llvm::RegAllocEvictionAdvisorAnalysis>()
{
  BOOL v0;
  uint64_t v1;
  double result;

  v0 = dword_1ED7FE1B0 != 0;
  v1 = operator new();
  *(_QWORD *)(v1 + 8) = 0;
  *(_QWORD *)(v1 + 16) = &llvm::RegAllocEvictionAdvisorAnalysis::ID;
  *(_QWORD *)&result = 4;
  *(_QWORD *)(v1 + 24) = 4;
  *(_QWORD *)v1 = &off_1E8149230;
  *(_BYTE *)(v1 + 32) = v0;
  return result;
}

char *llvm::RegAllocEvictionAdvisorAnalysis::getPassName(llvm::RegAllocEvictionAdvisorAnalysis *this)
{
  return off_1E8149318[*((int *)this + 7)];
}

void sub_1C620A3E0(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 160) = 1;
}

_QWORD *sub_1C620A3F8(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  *a1 = off_1E8149138;
  v2 = a1 + 71;
  v3 = (_QWORD *)a1[74];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
LABEL_3:
    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_4;
  }
  if (v3)
  {
    v4 = 5;
    goto LABEL_3;
  }
LABEL_4:
  a1[19] = &off_1E81491A0;
  v5 = (_QWORD *)a1[21];
  if (v5 != a1 + 23)
    free(v5);
  return sub_1C47A80D0(a1);
}

_QWORD *sub_1C620A478(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E81491A0;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

uint64_t sub_1C620A4B8(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int v12;

  v12 = 0;
  v8 = sub_1C6159B48(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v12);
  if ((v8 & 1) != 0)
    return v8;
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1C485C2F0();
  return sub_1C620A530(v11);
}

