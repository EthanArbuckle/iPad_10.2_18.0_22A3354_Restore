uint64_t processEntryThreadProc()
{
  uint64_t v0;
  uint64_t *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  char *v13;
  void *v14;
  void *v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  _QWORD *v27;
  void *v28;
  const char *v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  __int16 v43;
  int v44;
  const char *v45;
  FILE *v46;
  uint64_t v47;
  uint64_t v48;
  int AAEntryType;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  void (*v54)(_QWORD, _BYTE *);
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  __int16 v58;
  int v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  mode_t st_mode;
  uint64_t v65;
  uint64_t v66;
  int FileProtectionClass;
  int v68;
  uint64_t v69;
  __int128 v70;
  uint64_t v71;
  char v72;
  int v73;
  int v74;
  unsigned __int8 *FreePtr;
  size_t FreeSize;
  int v77;
  unsigned __int8 *v78;
  ssize_t v79;
  ssize_t v80;
  char v81;
  BOOL v82;
  ssize_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  __int16 v87;
  const char *v88;
  int *v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  ssize_t v94;
  size_t v95;
  ssize_t v96;
  size_t v97;
  char *v98;
  uint64_t DataSize;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  ssize_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  void *v110;
  size_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t DataPtr;
  int v119;
  _acl *file;
  int v121;
  const unsigned __int8 *qualifier;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  int v140;
  uint64_t v141;
  const void *v142;
  size_t v143;
  int v144;
  uint64_t v145;
  uint64_t v146;
  FILE *v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  __int16 v152;
  const char *v153;
  char *v154;
  uint64_t v155;
  uint64_t v156;
  char *v157;
  _BYTE *v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  size_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  size_t v174;
  const void *v175;
  size_t v176;
  FILE *v177;
  uint64_t v178;
  int *v180;
  uint64_t v181;
  uint64_t v182;
  const char *v183;
  __int16 v184;
  char *v185;
  char v186;
  ssize_t v187;
  uint64_t v188;
  int64_t v189;
  size_t v190;
  size_t v191;
  char *name;
  int namea;
  char *nameb;
  char *namec;
  char *__ptr;
  _acl *__ptra;
  void *__ptrb;
  uint64_t v199;
  size_t size;
  size_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  size_t v206;
  pthread_mutex_t *v207;
  void **v208;
  char *v209;
  char *string;
  void *v211;
  void *v212;
  passwd *v213;
  passwd v214;
  int id_type[2];
  acl_flagset_t flagset_p;
  acl_permset_mask_t mask_p;
  acl_tag_t tag_type_p;
  acl_entry_t entry_p;
  CC_SHA1_CTX c;
  stat v221;
  _BYTE v222[112];
  __int128 v223;
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  char path[2048];
  char v235[1024];
  __int128 v236[512];
  uint64_t v237;

  v0 = MEMORY[0x24BDAC7A8]();
  v237 = *MEMORY[0x24BDAC8D0];
  v1 = *(uint64_t **)v0;
  v2 = *(_DWORD *)(*(_QWORD *)v0 + 16);
  if (v2 >= 3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%d] Entry processing thread starting\n", *(_DWORD *)(v0 + 8));
  memset(&v221, 0, sizeof(v221));
  saveThreadErrorContext(v236);
  v3 = sysconf(71);
  v4 = sysconf(70);
  if (v3 <= v4)
    v5 = v4;
  else
    v5 = v3;
  if (v5 <= 4096)
    v6 = 4096;
  else
    v6 = v5;
  v7 = *(_QWORD *)(*v1 + 40);
  v8 = *(_QWORD *)(*v1 + 48);
  bzero(v235, 0x400uLL);
  bzero(path, 0x800uLL);
  v9 = v1[131];
  __memcpy_chk();
  path[v9] = 47;
  v209 = &path[v9 + 1];
  v12 = MemBufferCreate(0x40000uLL);
  if (!v12)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 244, 12, 0, "alloc writer buffer", v10, v11, (char)v185);
    ++*(_QWORD *)(v0 + 32);
  }
  v13 = (char *)malloc(v6);
  if (v13)
  {
    if (v7)
      goto LABEL_13;
LABEL_19:
    v14 = 0;
    if (v8)
      goto LABEL_15;
    goto LABEL_20;
  }
  v19 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 246, 12, *v19, "malloc", v20, v21, (char)v185);
  v6 = 0;
  ++*(_QWORD *)(v0 + 32);
  if (!v7)
    goto LABEL_19;
LABEL_13:
  v14 = calloc(v7, 0x408uLL);
  if (v14)
  {
    if (v8)
    {
LABEL_15:
      v15 = malloc(v8);
      if (!v15)
      {
        v16 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 255, 12, *v16, "malloc", v17, v18, (char)v185);
        v15 = 0;
        v8 = 0;
        ++*(_QWORD *)(v0 + 32);
      }
      v211 = v15;
      v206 = v8;
      bzero(v15, v8);
      goto LABEL_21;
    }
  }
  else
  {
    v180 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 250, 12, *v180, "malloc", v181, v182, (char)v185);
    v7 = 0;
    ++*(_QWORD *)(v0 + 32);
    if (v8)
      goto LABEL_15;
  }
LABEL_20:
  v206 = 0;
  v211 = 0;
LABEL_21:
  v212 = v14;
  v22 = *(_DWORD *)(v0 + 8);
  string = v13;
  if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 143)))
  {
    v26 = 0;
    goto LABEL_23;
  }
  v207 = (pthread_mutex_t *)(v1 + 143);
  v201 = 0;
  v26 = 0;
  v202 = 0;
  v199 = v0 + 160;
  size = 0;
  v29 = "processEntryThreadProc";
  v205 = v2;
  v208 = v12;
  while (1)
  {
    v30 = *((unsigned int *)v1 + 282);
    v31 = *((_DWORD *)v1 + 283);
    v32 = v30;
    if (v30 < v31)
    {
      *(_DWORD *)(v1[142] + 4 * v30) = v22;
      v32 = *((_DWORD *)v1 + 282);
    }
    *((_DWORD *)v1 + 282) = v32 + 1;
    if (!v32)
    {
      if (pthread_cond_broadcast((pthread_cond_t *)(v1 + 151)))
        break;
    }
    if (pthread_mutex_unlock(v207))
    {
      v183 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      v184 = 124;
      goto LABEL_244;
    }
    if (v30 >= v31)
    {
      v183 = "SharedArrayPush: stack is full\n";
      v184 = 125;
      goto LABEL_244;
    }
    v2 = v205;
    v12 = v208;
    if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 48)))
      goto LABEL_233;
    while (1)
    {
      v36 = *(_DWORD *)(v0 + 40);
      if (v36 > 0)
        break;
      if (pthread_cond_wait((pthread_cond_t *)(v0 + 112), (pthread_mutex_t *)(v0 + 48)))
        goto LABEL_233;
    }
    *(_DWORD *)(v0 + 40) = v36 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v0 + 48)))
    {
LABEL_233:
      v28 = v212;
      v27 = (_QWORD *)(v0 + 32);
      goto LABEL_234;
    }
    v37 = *(_QWORD *)(v0 + 24);
    if (v37 < 0)
    {
      v28 = v212;
      goto LABEL_235;
    }
    v204 = v1[134];
    v38 = ArchiveTreeNodePath(v1[132], v37, (uint64_t)v209, 2047 - v1[131]);
    v203 = v37;
    if (v38 < 0)
    {
      v41 = v29;
      v42 = v29;
      v43 = 276;
      v44 = 0;
      v45 = "full entry path is too long";
      goto LABEL_47;
    }
    if (v205 < 3)
    {
      if (v205 == 2)
      {
        v46 = (FILE *)*MEMORY[0x24BDAC8D8];
        if (v38)
          fprintf(v46, "%s\n");
        else
          fwrite(".\n", 2uLL, 1uLL, v46);
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%d] processing entry %s\n");
    }
    *(_DWORD *)(v204 + 280 * v37 + 192) = *(_DWORD *)(v0 + 8);
    if (lstat(path, &v221))
    {
      v44 = *__error();
      v185 = path;
      v41 = v29;
      v42 = v29;
      v43 = 289;
      v45 = "%s";
      goto LABEL_47;
    }
    __ptr = v26;
    AAEntryType = getAAEntryType(v221.st_mode);
    v52 = AAEntryType;
    v53 = *v1;
    v54 = *(void (**)(_QWORD, _BYTE *))(*v1 + 64);
    if (v54)
    {
      *(_DWORD *)&v222[12] = 0;
      *(_QWORD *)v222 = v209;
      *(_DWORD *)&v222[8] = AAEntryType;
      *(_QWORD *)&v222[16] = v212;
      *(_QWORD *)&v222[24] = v7;
      *(_QWORD *)&v222[32] = 0;
      *(_QWORD *)&v222[40] = v211;
      *(_OWORD *)&v222[48] = v206;
      v54(*(_QWORD *)(v53 + 72), v222);
      v201 = *(_QWORD *)&v222[56];
      v202 = *(_QWORD *)&v222[32];
    }
    v55 = v203;
    *(_DWORD *)(v204 + 280 * v203) = v52;
    if (!v52)
    {
      LOBYTE(v185) = v221.st_mode;
      v41 = v29;
      v57 = v29;
      v58 = 318;
      v59 = 0;
      v60 = "file type is not supported (st_mode=0%o): %s";
      goto LABEL_57;
    }
    v56 = v204 + 280 * v203;
    *(_QWORD *)(v56 + 80) = v221.st_ino;
    *(_WORD *)(v56 + 72) = v221.st_nlink;
    name = (char *)v56;
    if (v52 == 70)
    {
      *(_QWORD *)(v204 + 280 * v203 + 96) = v221.st_size;
    }
    else
    {
      if ((v52 & 0xFFFFFFFE) != 0x42)
      {
        v82 = v52 == 76;
        v55 = v203;
        v61 = v204;
        if (v82)
        {
          v83 = readlink(path, v235, 0x3FFuLL);
          if (v83 < 0)
          {
            v144 = *__error();
            v41 = v29;
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v29, 328, 12, v144, "%s", v145, v146, (char)path);
            goto LABEL_185;
          }
          if (!v83)
          {
            v185 = path;
            v41 = v29;
            v86 = (uint64_t)v29;
            v87 = 329;
            v88 = "readlink returned an empty string: %s";
LABEL_184:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", v86, v87, 12, 0, v88, v84, v85, (char)v185);
LABEL_185:
            v12 = v208;
            goto LABEL_58;
          }
          v235[v83] = 0;
          v61 = v204;
          if (BlobBufferStore(v199, v235, v83 + 1, (_QWORD *)(v204 + 280 * v203 + 200)))
          {
            v41 = v29;
            v86 = (uint64_t)v29;
            v87 = 333;
            v88 = "storing link";
            goto LABEL_184;
          }
        }
        goto LABEL_62;
      }
      v55 = v203;
      *(_DWORD *)(v204 + 280 * v203 + 88) = v221.st_rdev;
    }
    v61 = v204;
LABEL_62:
    v62 = v61 + 280 * v55;
    v63 = *(_QWORD *)&v221.st_uid;
    st_mode = v221.st_mode;
    *(_OWORD *)(v62 + 24) = 0u;
    v65 = v62 + 24;
    *(_QWORD *)(v65 + 36) = v63;
    *(_DWORD *)(v65 - 20) = st_mode & 0xFFF;
    *(_OWORD *)(v65 + 16) = 0u;
    *(_DWORD *)(v65 + 44) = v221.st_flags;
    *(timespec *)(v65 - 16) = v221.st_mtimespec;
    *(_QWORD *)&c.h2 = 0;
    *(_QWORD *)&c.h4 = 0;
    memset(v222, 0, 64);
    c.h0 = 5;
    c.h1 = 8704;
    v66 = v55;
    if (!getattrlist(path, &c, v222, 0x40uLL, 1u) && *(_DWORD *)v222 == 36)
    {
      *(_OWORD *)v65 = *(_OWORD *)&v222[4];
      *(_OWORD *)(v204 + 280 * v55 + 40) = *(_OWORD *)&v222[20];
    }
    FileProtectionClass = getFileProtectionClass(path);
    if ((FileProtectionClass - 1) >= 6)
      v68 = 0;
    else
      v68 = FileProtectionClass + 64;
    v69 = v204 + 280 * v55;
    *(_QWORD *)&v70 = -1;
    *((_QWORD *)&v70 + 1) = -1;
    *(_OWORD *)(v69 + 104) = v70;
    v71 = v69 + 104;
    *(_DWORD *)(v71 - 48) = v68;
    *(_OWORD *)(v71 + 16) = v70;
    if (*(_DWORD *)name != 70)
      goto LABEL_103;
    *(_QWORD *)&v222[8] = 0;
    *(_QWORD *)v222 = 0;
    if (!fsctl(path, 0x40104A0EuLL, v222, 0) && *(_QWORD *)v222 == 2)
      *(_QWORD *)v71 = *(_QWORD *)&v222[8];
    if (!v208)
      goto LABEL_103;
    if (*(_DWORD *)name != 70)
      goto LABEL_103;
    v72 = *((_BYTE *)v1 + 1080);
    if ((v72 & 7) == 0)
      goto LABEL_103;
    v214.pw_name = 0;
    v214.pw_passwd = 0;
    memset(&c, 0, sizeof(c));
    memset(v222, 0, 104);
    if ((v72 & 1) != 0)
    {
      CC_CKSUM_Init((uint64_t)&v214);
      v72 = *((_BYTE *)v1 + 1080);
    }
    if ((v72 & 2) != 0)
    {
      CC_SHA1_Deprecated_Init(&c);
      v72 = *((_BYTE *)v1 + 1080);
    }
    v12 = v208;
    if ((v72 & 4) != 0)
      CC_SHA256_Init((CC_SHA256_CTX *)v222);
    v73 = open(path, 0);
    if (v73 < 0)
    {
      v59 = *__error();
      v185 = path;
      v41 = v29;
      v57 = v29;
      v58 = 413;
      goto LABEL_195;
    }
    v74 = v73;
    MemBufferClear(v208);
    FreePtr = (unsigned __int8 *)MemBufferGetFreePtr((uint64_t)v208);
    FreeSize = MemBufferGetFreeSize(v208);
    namea = v74;
    v77 = v74;
    v78 = FreePtr;
    v190 = FreeSize;
    v79 = read(v77, FreePtr, FreeSize);
    if (v79 < 0)
    {
LABEL_101:
      v89 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v29, 421, 12, *v89, "%s", v90, v91, (char)path);
      v66 = v203;
      v92 = namea;
      goto LABEL_102;
    }
    v80 = v79;
    while (1)
    {
      v81 = *((_BYTE *)v1 + 1080);
      if (!v80)
        break;
      if ((v1[135] & 1) != 0)
      {
        CC_CKSUM_Update((uint64_t)&v214, v78, v80);
        v81 = *((_BYTE *)v1 + 1080);
        if ((v81 & 2) != 0)
        {
LABEL_92:
          CC_SHA1_Deprecated_Update(&c, v78, v80);
          if ((v1[135] & 4) == 0)
            goto LABEL_89;
LABEL_88:
          CC_SHA256_Update((CC_SHA256_CTX *)v222, v78, v80);
          goto LABEL_89;
        }
      }
      else if ((v1[135] & 2) != 0)
      {
        goto LABEL_92;
      }
      if ((v81 & 4) != 0)
        goto LABEL_88;
LABEL_89:
      v80 = read(namea, v78, v190);
      if (v80 < 0)
        goto LABEL_101;
    }
    v66 = v203;
    if ((v1[135] & 1) != 0)
    {
      CC_CKSUM_Final((unsigned int *)(v204 + 280 * v203 + 136), (uint64_t)&v214);
      v81 = *((_BYTE *)v1 + 1080);
    }
    v92 = namea;
    if ((v81 & 2) != 0)
    {
      CC_SHA1_Deprecated_Final((unsigned __int8 *)(v204 + 280 * v203 + 140), &c);
      v81 = *((_BYTE *)v1 + 1080);
    }
    if ((v81 & 4) != 0)
      CC_SHA256_Final((unsigned __int8 *)(v204 + 280 * v203 + 160), (CC_SHA256_CTX *)v222);
LABEL_102:
    close(v92);
LABEL_103:
    if ((*(_BYTE *)(*v1 + 33) & 4) != 0)
    {
      v12 = v208;
      MemBufferClear(v208);
      v94 = listxattr(path, 0, 0, 1);
      if (v94 >= 1)
      {
        v95 = size;
        if (v94 <= size)
        {
          v26 = __ptr;
        }
        else
        {
          size = v94;
          v26 = (char *)reallocf(__ptr, v94);
          if (!v26)
          {
            v44 = *__error();
            v41 = v29;
            v42 = v29;
            v43 = 455;
            v45 = "malloc";
            goto LABEL_47;
          }
          v95 = size;
        }
        size = v95;
        v96 = listxattr(path, v26, v95, 1);
        __ptr = v26;
        if (v96 >= 1)
        {
          v97 = 0;
          v187 = v96;
          do
          {
            v98 = &__ptr[v97];
            if (__ptr[v97])
            {
              ++v97;
              v12 = v208;
            }
            else
            {
              v191 = v97;
              nameb = v26;
              *(_QWORD *)v222 = 0;
              DataSize = MemBufferGetDataSize((uint64_t)v208);
              if (MemBufferFillFromBufferWithCapacityIncrease((unint64_t *)v208, 4uLL, v222) < 0)
              {
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 479, 12, 0, "inserting XAT xsize: %s", v100, v101, (char)path);
                v12 = v208;
                goto LABEL_58;
              }
              v189 = v98 - v26;
              v102 = MemBufferFillFromBufferWithCapacityIncrease((unint64_t *)v208, v98 - v26 + 1, v26);
              v12 = v208;
              if (v102 < 0)
              {
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 480, 12, 0, "inserting XAT xname: %s", v103, v104, (char)path);
                goto LABEL_58;
              }
              v188 = DataSize;
              v105 = getxattr(path, v26, 0, 0, 0, 1);
              if (v105 < 0)
              {
                v59 = *__error();
                v185 = path;
                v41 = "processEntryThreadProc";
                v57 = "processEntryThreadProc";
                v58 = 488;
LABEL_195:
                v60 = "%s";
LABEL_57:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v57, v58, 12, v59, v60, v50, v51, (char)v185);
                goto LABEL_58;
              }
              v106 = v105;
              v107 = MemBufferGetDataSize((uint64_t)v208);
              if ((MemBufferIncreaseCapacity((uint64_t)v208, v107 + v106) & 0x8000000000000000) != 0)
              {
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 492, 12, 0, "increasing XAT buffer capacity: %s", v108, v109, (char)path);
                goto LABEL_58;
              }
              v110 = (void *)MemBufferGetFreePtr((uint64_t)v208);
              v111 = MemBufferGetFreeSize(v208);
              if (getxattr(path, nameb, v110, v111, 0, 1) < 0)
              {
                v59 = *__error();
                v41 = "processEntryThreadProc";
                v57 = "processEntryThreadProc";
                v58 = 500;
                v60 = "getxattr";
                goto LABEL_57;
              }
              if (MemBufferIncreaseSize((unint64_t *)v208, v106, v112, v113, v114, v115, v116, v117) < 0)
              {
                v41 = "processEntryThreadProc";
                v57 = "processEntryThreadProc";
                v58 = 501;
                v59 = 0;
                v60 = "invalid size increase";
                goto LABEL_57;
              }
              *(_QWORD *)v222 = v189 + v106 + 5;
              if (*(_DWORD *)&v222[4])
              {
                v186 = v106;
                v41 = "processEntryThreadProc";
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 505, 12, 0, "XAT value is too long to be stored in YAA archive (%zd B): %s", v50, v51, v186);
LABEL_58:
                v26 = __ptr;
LABEL_48:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v41, 680, 12, 0, "processing failed for entry %zd\n", v47, v48, *(_QWORD *)(v0 + 24));
                ++*(_QWORD *)(v0 + 32);
                *(_DWORD *)(v204 + 280 * v203 + 196) = 1;
                v29 = v41;
                goto LABEL_49;
              }
              DataPtr = MemBufferGetDataPtr((uint64_t)v208);
              *(_DWORD *)(DataPtr + v188) = *(_DWORD *)v222;
              v97 = v191 + 1;
              v26 = &__ptr[v191 + 1];
              v66 = v203;
              v96 = v187;
            }
          }
          while (v97 != v96);
        }
      }
      v93 = v202;
      if (MemBufferIsEmpty((uint64_t)v12))
      {
        v26 = __ptr;
      }
      else
      {
        v141 = v66;
        v142 = (const void *)MemBufferGetDataPtr((uint64_t)v12);
        v143 = MemBufferGetDataSize((uint64_t)v12);
        if (BlobBufferStore(v199, v142, v143, (_QWORD *)(v204 + 280 * v141 + 216)))
        {
          v41 = "processEntryThreadProc";
          v57 = "processEntryThreadProc";
          v58 = 517;
          v59 = 0;
          v60 = "storing XAT";
          goto LABEL_57;
        }
        v26 = __ptr;
        if (v205 >= 3)
        {
          v147 = (FILE *)*MEMORY[0x24BDAC8D8];
          v148 = MemBufferGetDataSize((uint64_t)v12);
          fprintf(v147, "XAT blob [%zu] stored for %s\n", v148, path);
        }
        v66 = v203;
      }
    }
    else
    {
      v12 = v208;
      v26 = __ptr;
      v93 = v202;
    }
    if ((*(_BYTE *)(*v1 + 33) & 8) == 0)
      goto LABEL_208;
    v119 = v221.st_mode & 0xF000;
    if (v119 != 0x8000 && v119 != 0x4000)
      goto LABEL_208;
    MemBufferClear(v12);
    file = acl_get_file(path, ACL_TYPE_EXTENDED);
    if (!file)
      goto LABEL_207;
    entry_p = 0;
    v232 = 0u;
    v233 = 0u;
    v230 = 0u;
    v231 = 0u;
    v228 = 0u;
    v229 = 0u;
    v226 = 0u;
    v227 = 0u;
    v224 = 0u;
    v225 = 0u;
    v223 = 0u;
    memset(v222, 0, sizeof(v222));
    __ptra = file;
    if (acl_get_entry(file, 0, &entry_p))
      goto LABEL_206;
    v121 = 1;
    while (2)
    {
      tag_type_p = ACL_UNDEFINED_TAG;
      flagset_p = 0;
      mask_p = 0;
      *(_QWORD *)id_type = 0;
      memset(&c, 0, 72);
      memset(v222, 0, sizeof(v222));
      v223 = 0u;
      v224 = 0u;
      v225 = 0u;
      v226 = 0u;
      v227 = 0u;
      v228 = 0u;
      v229 = 0u;
      v230 = 0u;
      v231 = 0u;
      v232 = 0u;
      v233 = 0u;
      if (acl_get_tag_type(entry_p, &tag_type_p))
      {
        v149 = *__error();
        v152 = 551;
        v153 = "acl_get_tag_type";
LABEL_204:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", v152, 12, v149, v153, v150, v151, (char)v185);
        v154 = 0;
        goto LABEL_205;
      }
      if (tag_type_p - 1 >= 2)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Warning: ACL tag type is not ALLOW/DENY (ignoring entry): %d\n", tag_type_p);
LABEL_160:
        if (acl_get_entry(__ptra, v121++, &entry_p))
          goto LABEL_206;
        continue;
      }
      break;
    }
    *(_DWORD *)v222 = tag_type_p;
    if (acl_get_flagset_np(entry_p, &flagset_p))
    {
      v149 = *__error();
      v152 = 558;
      v153 = "acl_get_flagset_np";
      goto LABEL_204;
    }
    if (acl_get_flag_np(flagset_p, ACL_FLAG_NO_INHERIT))
      *(_QWORD *)&v222[16] |= 0x20000uLL;
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_INHERITED))
      *(_QWORD *)&v222[16] |= 0x10uLL;
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_FILE_INHERIT))
      *(_QWORD *)&v222[16] |= 0x20uLL;
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_DIRECTORY_INHERIT))
      *(_QWORD *)&v222[16] |= 0x40uLL;
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_LIMIT_INHERIT))
      *(_QWORD *)&v222[16] |= 0x80uLL;
    if (acl_get_flag_np(flagset_p, ACL_ENTRY_ONLY_INHERIT))
      *(_QWORD *)&v222[16] |= 0x100uLL;
    if (acl_get_permset_mask_np(entry_p, &mask_p))
    {
      v149 = *__error();
      v152 = 569;
      v153 = "acl_get_permset_mask_np";
      goto LABEL_204;
    }
    *(_QWORD *)&v222[8] = mask_p & 0x103FFE;
    qualifier = (const unsigned __int8 *)acl_get_qualifier(entry_p);
    if (!qualifier)
    {
      v149 = *__error();
      v152 = 574;
      v153 = "acl_get_qualifier";
      goto LABEL_204;
    }
    namec = (char *)qualifier;
    if (!*(_DWORD *)&v222[24])
    {
      if (mbr_uuid_to_id(qualifier, (id_t *)&id_type[1], id_type))
        goto LABEL_150;
      if (id_type[0] == 1)
      {
        memset(&v214, 0, 32);
        v213 = 0;
        if (!getgrgid_r(id_type[1], (group *)&v214, string, v6, (group **)&v213)
          && v213
          && v214.pw_name
          && strlen(v214.pw_name) <= 0xFF)
        {
          v140 = 2;
LABEL_174:
          *(_DWORD *)&v222[24] = v140;
          __strlcpy_chk();
        }
      }
      else if (!id_type[0])
      {
        memset(&v214, 0, sizeof(v214));
        v213 = 0;
        if (!getpwuid_r(id_type[1], &v214, string, v6, &v213) && v213 && v214.pw_name && strlen(v214.pw_name) <= 0xFF)
        {
          v140 = 1;
          goto LABEL_174;
        }
      }
LABEL_150:
      if (!*(_DWORD *)&v222[24])
      {
        if (!mbr_uuid_to_sid((const unsigned __int8 *)namec, (nt_sid_t *)&c)
          && !mbr_sid_to_string((const nt_sid_t *)&c, string)
          && strlen(string) <= 0xFF)
        {
          *(_DWORD *)&v222[24] = 3;
          __strlcpy_chk();
        }
        if (!*(_DWORD *)&v222[24])
        {
          *(_DWORD *)&v222[24] = 4;
          uuid_unparse_upper((const unsigned __int8 *)namec, &v222[28]);
          if (!*(_DWORD *)&v222[24])
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 616, 12, 0, "resolving ACE qualifier: %s", v123, v124, (char)path);
            goto LABEL_231;
          }
        }
      }
    }
    v125 = MemBufferGetFreePtr((uint64_t)v12);
    v126 = MemBufferGetFreeSize(v12);
    v132 = yaa_encodeACE(v125, v126, (uint64_t)v222, v127, v128, v129, v130, v131);
    if ((v132 & 0x8000000000000000) == 0)
    {
      MemBufferIncreaseSize((unint64_t *)v12, v132, v133, v134, v135, v136, v137, v138);
      acl_free(namec);
      v66 = v203;
      goto LABEL_160;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 620, 12, 0, "encoding ACE", v137, v138, (char)v185);
LABEL_231:
    v66 = v203;
    v154 = namec;
LABEL_205:
    acl_free(v154);
LABEL_206:
    acl_free(__ptra);
    v93 = v202;
LABEL_207:
    if (!MemBufferIsEmpty((uint64_t)v12))
    {
      __ptrb = (void *)MemBufferGetDataPtr((uint64_t)v12);
      v174 = MemBufferGetDataSize((uint64_t)v12);
      if (!BlobBufferStore(v199, __ptrb, v174, (_QWORD *)(v204 + 280 * v66 + 232)))
      {
        if (v205 >= 3)
        {
          v177 = (FILE *)*MEMORY[0x24BDAC8D8];
          v178 = MemBufferGetDataSize((uint64_t)v12);
          fprintf(v177, "ACL blob [%zu] stored for %s\n", v178, path);
        }
        goto LABEL_208;
      }
      v41 = "processEntryThreadProc";
      v42 = "processEntryThreadProc";
      v43 = 637;
      v44 = 0;
      v45 = "storing ACL";
LABEL_47:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)v42, v43, 12, v44, v45, v39, v40, (char)v185);
      goto LABEL_48;
    }
LABEL_208:
    if (!v93)
    {
      v202 = 0;
      goto LABEL_220;
    }
    MemBufferClear(v12);
    v155 = 0;
    v156 = (uint64_t)v212;
    v157 = v26;
    do
    {
      if (*(_DWORD *)(v156 + 4) == 2)
        v155 += *(_QWORD *)(v156 + 8);
      v12 = v208;
      v158 = (_BYTE *)MemBufferGetFreePtr((uint64_t)v208);
      v159 = MemBufferGetFreeSize(v208);
      v165 = yaa_encodeHeaderField(v158, v159, v156, v160, v161, v162, v163, v164);
      if ((v165 & 0x8000000000000000) != 0)
      {
        v41 = "processEntryThreadProc";
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 653, 12, 0, "extra header field is too large for processing thread buffer", v170, v171, (char)v185);
        v2 = v205;
        v26 = v157;
        goto LABEL_48;
      }
      MemBufferIncreaseSize((unint64_t *)v208, v165, v166, v167, v168, v169, v170, v171);
      v156 += 1032;
      --v93;
    }
    while (v93);
    v26 = v157;
    if (v201 != v155)
    {
      v41 = "processEntryThreadProc";
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"processEntryThreadProc", 658, 12, 0, "extra header data size doesn't match expected value", v172, v173, (char)v185);
      v2 = v205;
      v12 = v208;
      goto LABEL_48;
    }
    v12 = v208;
    v2 = v205;
    if (!MemBufferIsEmpty((uint64_t)v208))
    {
      v175 = (const void *)MemBufferGetDataPtr((uint64_t)v208);
      v176 = MemBufferGetDataSize((uint64_t)v208);
      if (BlobBufferStore(v199, v175, v176, (_QWORD *)(v204 + 280 * v203 + 248)))
      {
        v41 = "processEntryThreadProc";
        v42 = "processEntryThreadProc";
        v43 = 663;
        v44 = 0;
        v45 = "storing encoded extra fields";
        goto LABEL_47;
      }
    }
    if (v201)
    {
      if (!BlobBufferStore(v199, v211, v201, (_QWORD *)(v204 + 280 * v203 + 264)))
        goto LABEL_220;
      v41 = "processEntryThreadProc";
      v42 = "processEntryThreadProc";
      v43 = 668;
      v44 = 0;
      v45 = "storing extra fields data";
      goto LABEL_47;
    }
    v201 = 0;
LABEL_220:
    v29 = "processEntryThreadProc";
LABEL_49:
    v22 = *(_DWORD *)(v0 + 8);
    if (pthread_mutex_lock(v207))
    {
LABEL_23:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", 117, 0, "SharedArrayPush: pthread_mutex_lock failed\n", v23, v24, v25, (char)v185);
      goto LABEL_24;
    }
  }
  v183 = "SharedArrayPush: pthread_cond_broadcast failed\n";
  v184 = 122;
LABEL_244:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v184, 0, v183, v33, v34, v35, (char)v185);
  v2 = v205;
  v12 = v208;
LABEL_24:
  v27 = (_QWORD *)(v0 + 32);
  v28 = v212;
LABEL_234:
  ++*v27;
LABEL_235:
  MemBufferDestroy(v12);
  free(string);
  free(v28);
  free(v211);
  free(v26);
  if (v2 >= 3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%d] terminating\n", *(_DWORD *)(v0 + 8));
  restoreThreadErrorContext(v236);
  return 0;
}

uint64_t *resolveSameThreadProc()
{
  uint64_t *v0;
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  BOOL v38;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  __int16 v48;
  char v50;
  _QWORD *v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t *v55;
  uint64_t v56;
  _BYTE v57[2048];
  _BYTE v58[2048];
  uint64_t v59;

  v0 = (uint64_t *)MEMORY[0x24BDAC7A8]();
  v59 = *MEMORY[0x24BDAC8D0];
  v1 = *v0;
  bzero(v58, 0x800uLL);
  bzero(v57, 0x800uLL);
  v2 = *(_QWORD *)(v1 + 1272);
  if (v2)
  {
    v3 = 0;
    v4 = v1 + 20;
    v5 = (unint64_t *)(v1 + 1328);
    v6 = v0 + 5;
    v7 = v0 + 4;
    while (1)
    {
      v8 = *(_QWORD *)(v1 + 1288);
      v9 = HIDWORD(*(_QWORD *)(v8 + 16 * v3));
      if (v9 >= v0[2])
      {
        if (v9 >= v0[3])
          return v0;
        v10 = *(_QWORD *)(v1 + 1072);
        v11 = *(_QWORD *)(v8 + 16 * v3 + 8);
        v12 = v10 + 280 * v11;
        v14 = *(_QWORD *)(v12 + 128);
        v13 = (unint64_t *)(v12 + 128);
        v15 = v3 + 1;
        if (v14 == -1 && v15 < v2)
        {
          v17 = *(_QWORD *)(v1 + 1288);
          if (*(_QWORD *)(v17 + 16 * v15) == *(_QWORD *)(v17 + 16 * v3))
            break;
        }
      }
LABEL_10:
      if (++v3 >= v2)
        return v0;
    }
    v18 = v10 + 280 * v11;
    v19 = v18 + 140;
    v20 = (_QWORD *)(v18 + 160);
    while (1)
    {
      v21 = *(_QWORD *)(v1 + 1072);
      v22 = *(_QWORD *)(v17 + 16 * v15 + 8);
      if (*(_QWORD *)(v21 + 280 * v22 + 112) != -1)
        goto LABEL_51;
      if (*(_QWORD *)(v21 + 280 * v22 + 120) != -1)
        goto LABEL_51;
      v23 = v21 + 280 * v22;
      v25 = *(_QWORD *)(v23 + 128);
      v24 = (unint64_t *)(v23 + 128);
      if (v25 != -1)
        goto LABEL_51;
      if ((*(_BYTE *)(v1 + 1080) & 2) != 0)
      {
        v26 = v21 + 280 * v22;
        v27 = *(_QWORD *)(v26 + 140);
        v28 = *(_QWORD *)(v26 + 148);
        v29 = *(unsigned int *)(v26 + 156);
        v30 = *(_QWORD *)v19 == v27 && *(_QWORD *)(v19 + 8) == v28;
        if (!v30 || *(_DWORD *)(v19 + 16) != v29)
          goto LABEL_51;
      }
      if ((*(_BYTE *)(v1 + 1080) & 4) != 0)
      {
        v32 = (_QWORD *)(v21 + 280 * v22);
        v33 = v32[20];
        v34 = v32[21];
        v36 = v32[22];
        v35 = v32[23];
        v37 = *v20 == v33 && v20[1] == v34;
        v38 = v37 && v20[2] == v36;
        if (!v38 || v20[3] != v35)
          goto LABEL_51;
      }
      v51 = v20;
      v52 = v19;
      v53 = v7;
      v54 = v6;
      v55 = v5;
      v56 = v4;
      if (ArchiveTreeNodePath(*(_QWORD *)(v1 + 1056), *(_DWORD *)(v17 + 16 * v3 + 8), (uint64_t)v58, 0x800uLL) < 0)
        break;
      if (ArchiveTreeNodePath(*(_QWORD *)(v1 + 1056), *(_DWORD *)(*(_QWORD *)(v1 + 1288) + 16 * v15 + 8), (uint64_t)v57, 0x800uLL) < 0)
      {
        v48 = 726;
        goto LABEL_48;
      }
      v42 = areFilesEqual2();
      if (v42 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"resolveSameThreadProc", 729, 12, 0, "File comparison failed: %s vs %s", v43, v44, (char)v58);
        goto LABEL_49;
      }
      v5 = v55;
      v4 = v56;
      v7 = v53;
      v6 = v54;
      v20 = v51;
      v19 = v52;
      if (!v42)
        goto LABEL_51;
      v45 = *v13;
      if (*v13 == -1)
      {
        do
          v45 = __ldaxr(v55);
        while (__stlxr(v45 + 1, v55));
        *v13 = v45;
      }
      *v24 = v45;
      v46 = *(_QWORD *)(v21 + 280 * v22 + 96);
      v47 = v54;
LABEL_50:
      *v47 += v46;
LABEL_51:
      ++v15;
      v2 = *(_QWORD *)(v1 + 1272);
      if (v15 < v2)
      {
        v17 = *(_QWORD *)(v1 + 1288);
        if (*(_QWORD *)(v17 + 16 * v15) == *(_QWORD *)(v17 + 16 * v3))
          continue;
      }
      goto LABEL_10;
    }
    v48 = 725;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"resolveSameThreadProc", v48, 12, 0, "entry path too long", v40, v41, v50);
LABEL_49:
    v7 = v53;
    v6 = v54;
    v47 = v53;
    v46 = 1;
    v5 = v55;
    v4 = v56;
    v20 = v51;
    v19 = v52;
    goto LABEL_50;
  }
  return v0;
}

uint64_t ParallelArchiveWriteDirContents()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int DefaultNThreads;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  int v17;
  unsigned int *v18;
  uint64_t v19;
  size_t i;
  char *v21;
  int v22;
  size_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  char v29;
  void *v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  _opaque_pthread_t *v35;
  void *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  _opaque_pthread_t *v40;
  uint64_t result;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  size_t v48;
  uint64_t v49;
  _DWORD *v50;
  uint64_t v51;
  unint64_t j;
  const void **v53;
  size_t v54;
  size_t v55;
  _QWORD *v56;
  _QWORD *v57;
  size_t v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  size_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  _QWORD *v76;
  size_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  const char *v82;
  __int16 v83;
  int v84;
  size_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  uint64_t v95;
  char *v96;
  pthread_mutex_t *v97;
  char *v98;
  int v99;
  const char *v100;
  __int16 v101;
  FILE **v102;
  double v103;
  uint64_t v104;
  size_t v105;
  uint64_t v106;
  size_t v107;
  uint64_t v108;
  size_t v109;
  size_t v110;
  char *v111;
  char *v112;
  uint64_t v113;
  char *v114;
  size_t v115;
  uint64_t v116;
  size_t v117;
  uint64_t *v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  _QWORD *v126;
  uint64_t v127;
  unint64_t v128;
  unint64_t v129;
  size_t v130;
  uint64_t v131;
  size_t v132;
  size_t v133;
  char *v134;
  char *v135;
  uint64_t v136;
  char *v137;
  size_t v138;
  size_t v139;
  _QWORD *v140;
  char *v141;
  _QWORD *v142;
  uint64_t v143;
  _QWORD *v144;
  char *v145;
  unint64_t v146;
  unint64_t *v147;
  unint64_t v148;
  size_t v149;
  uint64_t v150;
  size_t v151;
  size_t v152;
  char *v153;
  char *v154;
  uint64_t v155;
  char *v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  unint64_t v160;
  int v161;
  char *v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  unint64_t v166;
  uint64_t v167;
  unint64_t v168;
  char *v169;
  char *v170;
  _opaque_pthread_t *v171;
  uint64_t v172;
  uint64_t v173;
  char *v174;
  size_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  _QWORD *v179;
  uint64_t v180;
  FILE **v181;
  FILE *v182;
  unint64_t v183;
  uint64_t v184;
  FILE *v185;
  unint64_t v186;
  uint64_t v187;
  FILE *v188;
  unint64_t v189;
  uint64_t v190;
  _BYTE *v191;
  uint64_t *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t *v195;
  _DWORD *v196;
  int v197;
  unint64_t v198;
  unint64_t v199;
  int v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t *v209;
  uint64_t *v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t *v213;
  uint64_t *v214;
  uint64_t v215;
  uint64_t v216;
  int v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  size_t v221;
  size_t v222;
  unint64_t v223;
  uint64_t v224;
  int v225;
  uint64_t *v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t *v229;
  uint64_t v230;
  uint64_t v231;
  int v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  unint64_t v236;
  uint64_t v237;
  unint64_t v238;
  uint64_t v239;
  unint64_t v240;
  uint64_t v241;
  uint64_t *v242;
  size_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  unint64_t v249;
  int v250;
  int v251;
  unint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  unint64_t v263;
  BOOL v264;
  int v265;
  int *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  int *v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  unint64_t v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  const char *v278;
  __int16 v279;
  int v280;
  const char *v281;
  __int16 v282;
  char v283;
  char v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  _DWORD *v289;
  uint64_t v290;
  int v291;
  void *v292;
  _DWORD *v293;
  unint64_t v294;
  uint64_t *v295;
  uint64_t v296;
  char v297[2048];
  _QWORD __key[256];
  uint64_t v299;
  uint64_t v300;
  int v301;
  char v302[1028];
  size_t v303;
  unsigned int *v304;
  size_t v305;
  void *v306;
  char v307;
  _BYTE v308[16];
  uint64_t v309;
  size_t __count;
  void *v311;
  int v312;
  int v313;
  void *v314;
  pthread_mutex_t v315;
  pthread_cond_t v316;
  unsigned int v317;
  void *v318;
  size_t __nel;
  size_t v320;
  void *__ptr;
  uint64_t v322;
  uint64_t v323;
  unint64_t v324;
  unint64_t v325;
  unint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = v0;
  v330 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(v0, v1, v4, v5, v6, v7, v8, v9, v283);
  DefaultNThreads = *(_DWORD *)(v2 + 4);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v11 = *(_DWORD *)v2;
  v12 = *(_QWORD *)(v3 + 40);
  bzero(&v301, 0x540uLL);
  v299 = v2;
  v300 = v3;
  v301 = *(_DWORD *)v3;
  if (!realpath_DARWIN_EXTSN(*(const char **)(v2 + 16), v302))
  {
    v17 = *__error();
    v15 = "invalid inDir";
    v16 = 825;
    goto LABEL_26;
  }
  v303 = strlen(v302);
  if (v303 - 1015 <= 0xFFFFFFFFFFFFFBFELL)
  {
    v15 = "invalid inDir length";
    v16 = 827;
    goto LABEL_25;
  }
  v18 = ArchiveTreeCreateFromDirectory(v302, *(const __CFArray **)(v2 + 24), *(_QWORD *)(v2 + 56), *(_QWORD *)(v2 + 72), DefaultNThreads, v11);
  v304 = v18;
  if (!v18)
  {
    v15 = "building archive tree";
    v16 = 831;
    goto LABEL_25;
  }
  v305 = ArchiveTreeSize(v18);
  v306 = calloc(v305, 0x118uLL);
  if (!v306)
  {
    v17 = *__error();
    v15 = "malloc";
    v16 = 836;
    goto LABEL_26;
  }
  if (!v305)
    goto LABEL_411;
  v19 = 0;
  for (i = 0; i < v305; ++i)
  {
    v21 = (char *)v306 + v19;
    *((_QWORD *)v21 + 34) = 0;
    *((_OWORD *)v21 + 15) = 0uLL;
    *((_OWORD *)v21 + 16) = 0uLL;
    *((_OWORD *)v21 + 13) = 0uLL;
    *((_OWORD *)v21 + 14) = 0uLL;
    *((_OWORD *)v21 + 11) = 0uLL;
    *((_OWORD *)v21 + 12) = 0uLL;
    *((_OWORD *)v21 + 9) = 0uLL;
    *((_OWORD *)v21 + 10) = 0uLL;
    *((_OWORD *)v21 + 7) = 0uLL;
    *((_OWORD *)v21 + 8) = 0uLL;
    *((_OWORD *)v21 + 5) = 0uLL;
    *((_OWORD *)v21 + 6) = 0uLL;
    *((_OWORD *)v21 + 3) = 0uLL;
    *((_OWORD *)v21 + 4) = 0uLL;
    *((_OWORD *)v21 + 1) = 0uLL;
    *((_OWORD *)v21 + 2) = 0uLL;
    *(_OWORD *)v21 = 0uLL;
    *((_DWORD *)v21 + 48) = -1;
    v19 += 280;
  }
  if (!v305)
    goto LABEL_411;
  v22 = v307 & 0xFE | (*(_DWORD *)(v299 + 32) >> 12) & 1;
  v307 = v307 & 0xFE | ((*(_DWORD *)(v299 + 32) & 0x1000) != 0);
  v307 = v22 & 0xFD | (2 * ((*(_DWORD *)(v299 + 32) & 0x2000) != 0));
  v307 = v307 & 0xFB | (*(_DWORD *)(v299 + 32) >> 12) & 4;
  if (v305 >= DefaultNThreads)
    v23 = DefaultNThreads;
  else
    v23 = v305;
  LODWORD(__count) = v23;
  v312 = 0;
  v313 = v23;
  v314 = calloc(v23, 4uLL);
  if (!v314)
  {
    v27 = "SharedArrayInit: malloc failed\n";
    v28 = 55;
    goto LABEL_24;
  }
  if (pthread_mutex_init(&v315, 0))
  {
    v27 = "SharedArrayInit: pthread_mutex_init failed\n";
    v28 = 56;
LABEL_24:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v28, 0, v27, v24, v25, v26, v284);
    v15 = "init available_threads";
    v16 = 850;
    goto LABEL_25;
  }
  if (pthread_cond_init(&v316, 0))
  {
    v27 = "SharedArrayInit: pthread_cond_init failed\n";
    v28 = 57;
    goto LABEL_24;
  }
  v311 = calloc(__count, 0xC8uLL);
  if (!v311)
  {
    v17 = *__error();
    v15 = "malloc";
    v16 = 852;
    goto LABEL_26;
  }
  v296 = v12;
  if ((_DWORD)__count)
  {
    v43 = 0;
    v44 = 0;
    do
    {
      v45 = (char *)v311;
      v46 = (char *)v311 + v43;
      *(_QWORD *)v46 = &v299;
      *((_DWORD *)v46 + 2) = v44;
      *((_QWORD *)v46 + 3) = -1;
      *((_DWORD *)v46 + 10) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v46 + 48), 0)
        || pthread_cond_init((pthread_cond_t *)(v46 + 112), 0))
      {
        v82 = "init entry_ready";
        v83 = 860;
        goto LABEL_119;
      }
      if (createThread((pthread_t *)&v45[v43 + 16], (uint64_t)processEntryThreadProc, (uint64_t)v46, 0))
      {
        v84 = *__error();
        v82 = "createThread";
        v83 = 863;
        goto LABEL_138;
      }
      ++v44;
      v47 = __count;
      v43 += 200;
    }
    while (v44 < __count);
  }
  else
  {
    v47 = 0;
  }
  v48 = v305;
  if (v305 + v47)
  {
    v85 = 0;
    v12 = v296;
    while (!pthread_mutex_lock(&v315))
    {
      while (1)
      {
        v89 = v312;
        if (v312)
          break;
        if (pthread_cond_wait(&v316, &v315))
        {
          v100 = "SharedArrayPop: pthread_cond_wait failed\n";
          v101 = 94;
          goto LABEL_135;
        }
      }
      --v312;
      v90 = *((_DWORD *)v314 + (v89 - 1));
      if (pthread_mutex_unlock(&v315))
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v91, v92, v93, v284);
        v12 = v296;
        goto LABEL_136;
      }
      v94 = (char *)v311;
      if (v85 >= v305)
        v95 = -1;
      else
        v95 = v85;
      v96 = (char *)v311 + 200 * v90;
      *((_QWORD *)v96 + 3) = v95;
      v97 = (pthread_mutex_t *)(v96 + 48);
      if (pthread_mutex_lock((pthread_mutex_t *)(v96 + 48))
        || (v98 = &v94[200 * v90], v99 = *((_DWORD *)v98 + 10), *((_DWORD *)v98 + 10) = v99 + 1, !v99)
        && pthread_cond_broadcast((pthread_cond_t *)&v94[200 * v90 + 112])
        || pthread_mutex_unlock(v97))
      {
        v82 = "starting task";
        v83 = 879;
LABEL_119:
        v84 = 0;
LABEL_138:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v83, 12, v84, v82, v13, v14, v284);
        v29 = 1;
LABEL_139:
        v12 = v296;
        goto LABEL_28;
      }
      ++v85;
      v48 = v305;
      v47 = __count;
      v12 = v296;
      if (v85 >= v305 + __count)
        goto LABEL_63;
    }
    v100 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v101 = 91;
LABEL_135:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v101, 0, v100, v86, v87, v88, v284);
LABEL_136:
    v15 = "waiting for an available worker";
    v16 = 871;
LABEL_25:
    v17 = 0;
    goto LABEL_26;
  }
LABEL_63:
  v12 = v296;
  if (v48)
  {
    v49 = 0;
    v50 = (char *)v306 + 196;
    do
    {
      if (*v50)
        ++v49;
      v50 += 70;
      --v48;
    }
    while (v48);
    if (v49)
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 887, 12, "%zu failed entries reported", v42, v13, v14, v49);
      v47 = __count;
    }
  }
  if (v47)
  {
    v51 = 0;
    for (j = 0; j < v47; ++j)
    {
      v53 = (const void **)((char *)v311 + v51);
      v54 = *(_QWORD *)((char *)v311 + v51 + 168);
      if (v54)
      {
        if (BlobBufferStore((uint64_t)v308, v53[22], v54, v53 + 23))
        {
          v15 = "moving thread data to main state";
          v16 = 897;
          goto LABEL_25;
        }
        BlobBufferFree((uint64_t)(v53 + 20));
        v47 = __count;
      }
      v51 += 200;
    }
  }
  v55 = v305;
  if (v305)
  {
    v56 = v311;
    v57 = (char *)v306 + 272;
    v58 = v305;
    while (1)
    {
      v59 = *((_DWORD *)v57 - 20);
      if (v59 == -1)
        break;
      v60 = v56[25 * v59 + 23];
      if (*(v57 - 6))
        *(v57 - 7) += v60;
      if (*(v57 - 4))
        *(v57 - 5) += v60;
      if (*(v57 - 8))
        *(v57 - 9) += v60;
      if (*(v57 - 2))
        *(v57 - 3) += v60;
      if (*v57)
        *(v57 - 1) += v60;
      v57 += 35;
      if (!--v58)
      {
        v61 = v322;
        v62 = v323;
        v63 = (char *)v306 + 104;
        v64 = v55;
        do
        {
          if (*((_DWORD *)v63 - 26) == 70)
          {
            if (*((unsigned __int16 *)v63 - 16) >= 2u)
              v322 = ++v61;
            if (*v63 != -1)
              v323 = ++v62;
          }
          v63 += 35;
          --v64;
        }
        while (v64);
        goto LABEL_97;
      }
    }
    v15 = "invalid thread_id stored in entry";
    v16 = 907;
    goto LABEL_25;
  }
LABEL_97:
  if (v301 >= 1)
  {
    if (v55)
    {
      v65 = 0;
      v66 = 0;
      v67 = 0;
      v68 = 0;
      v69 = 0;
      v70 = 0;
      v71 = 0;
      v72 = 0;
      v73 = 0;
      v74 = 0;
      v75 = 0;
      v76 = (char *)v306 + 240;
      v77 = v55;
      do
      {
        v78 = *((_DWORD *)v76 - 60);
        switch(v78)
        {
          case 'B':
            ++v71;
            break;
          case 'C':
            ++v70;
            break;
          case 'D':
            ++v66;
            break;
          case 'E':
          case 'G':
          case 'H':
          case 'I':
          case 'J':
          case 'K':
          case 'M':
          case 'N':
          case 'O':
            break;
          case 'F':
            ++v65;
            v75 += *(v76 - 18);
            break;
          case 'L':
            ++v67;
            break;
          case 'P':
            ++v68;
            break;
          default:
            if (v78 == 83)
              ++v69;
            break;
        }
        v79 = *(v76 - 2);
        v80 = *v76;
        v81 = *((_DWORD *)v76 - 11);
        v76 += 35;
        if (v79)
          ++v72;
        if (v80)
          ++v73;
        if (v81)
          ++v74;
        --v77;
      }
      while (v77);
    }
    else
    {
      v75 = 0;
      v74 = 0;
      v73 = 0;
      v72 = 0;
      v71 = 0;
      v70 = 0;
      v69 = 0;
      v68 = 0;
      v67 = 0;
      v66 = 0;
      v65 = 0;
    }
    v285 = v66;
    v286 = v67;
    v287 = v69;
    v288 = v70;
    v290 = v71;
    v292 = v68;
    v294 = v75;
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu entries selected\n", v55);
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu regular files\n", v65);
    v102 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu directories\n", v285);
    fprintf(*v102, "%12zu symbolic links\n", v286);
    if (v287)
      fprintf(*v102, "%12zu sockets\n", v287);
    if (v288)
      fprintf(*v102, "%12zu character special entries\n", v288);
    if (v290)
      fprintf(*v102, "%12zu block special entries\n", v290);
    if (v292)
      fprintf(*v102, "%12zu FIFO\n", (size_t)v292);
    if (v72)
      fprintf(*v102, "%12zu entries with XAT blob\n", v72);
    if (v73)
      fprintf(*v102, "%12zu entries with ACL blob\n", v73);
    v103 = 0.0009765625;
    if (v294 >> 20)
    {
      v103 = 0.000000953674316;
      LODWORD(v104) = 77;
    }
    else
    {
      LODWORD(v104) = 75;
    }
    if (v294 >> 30)
    {
      v103 = 9.31322575e-10;
      v104 = 71;
    }
    else
    {
      v104 = v104;
    }
    fprintf(*v102, "%12llu bytes in regular files (%.2f %cB)\n", v294, v103 * (double)v294, v104);
    if (v74)
    {
      fprintf(*v102, "%12zu entries reported an error\n", v74);
      if (v301 >= 2)
      {
        if (v305)
        {
          v105 = 0;
          v106 = 196;
          do
          {
            if (*(_DWORD *)((char *)v306 + v106)
              && (ArchiveTreeNodePath((uint64_t)v304, v105, (uint64_t)__key, 0x400uLL) & 0x8000000000000000) == 0)
            {
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "- %s\n", (const char *)__key);
            }
            ++v105;
            v106 += 280;
          }
          while (v105 < v305);
        }
      }
    }
  }
  if (v322)
  {
    __nel = 0;
    v107 = v305;
    if (v305)
    {
      v108 = 0;
      v109 = 0;
      v110 = 0;
      while (1)
      {
        v111 = (char *)v306;
        if (*(_DWORD *)((char *)v306 + v108) == 70 && *(unsigned __int16 *)((char *)v306 + v108 + 72) >= 2u)
        {
          v112 = (char *)__ptr;
          if (v109 >= v320)
          {
            v113 = v320 + (v320 >> 1);
            if (!v320)
              v113 = 64;
            v320 = v113;
            v112 = (char *)reallocf(__ptr, 16 * v113);
            __ptr = v112;
            if (!v112)
            {
              v17 = *__error();
              v15 = "malloc";
              v16 = 1007;
LABEL_26:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v16, 12, v17, v15, v13, v14, v284);
              goto LABEL_27;
            }
            v109 = __nel;
            v107 = v305;
          }
          v114 = &v112[16 * v109];
          *((_QWORD *)v114 + 1) = v110;
          *(_QWORD *)v114 = *(_QWORD *)&v111[v108 + 80];
          __nel = ++v109;
        }
        ++v110;
        v108 += 280;
        if (v110 >= v107)
          goto LABEL_183;
      }
    }
    v109 = 0;
LABEL_183:
    qsort(__ptr, v109, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
    v115 = __nel;
    if (__nel)
    {
      v116 = 0;
      do
      {
        v117 = v116 + 1;
        if (v116 + 1 >= v115)
        {
          v122 = 1;
        }
        else
        {
          v118 = (uint64_t *)((char *)__ptr + 16 * v116);
          v121 = *v118;
          v119 = v118 + 2;
          v120 = v121;
          v122 = 1;
          while (1)
          {
            v123 = *v119;
            v119 += 2;
            if (v120 != v123)
              break;
            ++v122;
            if (!(v116 - v115 + v122))
            {
              v122 = v115 - v116;
              goto LABEL_192;
            }
          }
          v115 = v116 + v122;
LABEL_192:
          v117 = v115;
          if (!v122)
            goto LABEL_197;
        }
        v124 = 0;
        v125 = (16 * v116) | 8;
        do
        {
          v126 = v306;
          v127 = *(_QWORD *)((char *)__ptr + v125);
          v128 = atomic_load(&v324);
          v126[35 * v127 + 14] = v128;
          if (v124)
            v327 += v126[35 * v127 + 12];
          ++v124;
          v125 += 16;
        }
        while (v122 != v124);
        do
LABEL_197:
          v129 = __ldaxr(&v324);
        while (__stlxr(v129 + 1, &v324));
        v115 = __nel;
        v116 = v117;
      }
      while (v117 < __nel);
    }
  }
  if (v323)
  {
    __nel = 0;
    v130 = v305;
    if (v305)
    {
      v131 = 0;
      v132 = 0;
      v133 = 0;
      do
      {
        v134 = (char *)v306;
        if (*(_DWORD *)((char *)v306 + v131) == 70)
        {
          v135 = (char *)__ptr;
          if (v132 >= v320)
          {
            v136 = v320 + (v320 >> 1);
            if (!v320)
              v136 = 64;
            v320 = v136;
            v135 = (char *)reallocf(__ptr, 16 * v136);
            __ptr = v135;
            if (!v135)
            {
              v17 = *__error();
              v15 = "malloc";
              v16 = 1051;
              goto LABEL_26;
            }
            v132 = __nel;
            v130 = v305;
          }
          v137 = &v135[16 * v132];
          *((_QWORD *)v137 + 1) = v133;
          *(_QWORD *)v137 = *(_QWORD *)&v134[v131 + 104];
          __nel = ++v132;
        }
        ++v133;
        v131 += 280;
      }
      while (v133 < v130);
    }
    else
    {
      v132 = 0;
    }
    qsort(__ptr, v132, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
    v138 = v305;
    if (v305)
    {
      v139 = 0;
      do
      {
        v140 = v306;
        if (*((_DWORD *)v306 + 70 * v139) == 70)
        {
          v141 = (char *)v306 + 280 * v139;
          v143 = *((_QWORD *)v141 + 13);
          v142 = v141 + 104;
          if (v143 != -1)
          {
            __key[1] = 0;
            __key[0] = 0;
            __key[0] = *v142;
            v144 = bsearch(__key, __ptr, __nel, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
            if (v144)
            {
              v145 = (char *)v306 + 280 * v144[1];
              v148 = *((_QWORD *)v145 + 15);
              v147 = (unint64_t *)(v145 + 120);
              v146 = v148;
              v328 += *(v147 - 3);
              if (v148 == -1)
              {
                do
                  v146 = __ldaxr(&v325);
                while (__stlxr(v146 + 1, &v325));
                *v147 = v146;
              }
              v140[35 * v139 + 15] = v146;
            }
            v138 = v305;
          }
        }
        ++v139;
      }
      while (v139 < v138);
    }
  }
  if ((v307 & 6) != 0)
  {
    __nel = 0;
    v149 = v305;
    if (v305)
    {
      v150 = 0;
      v151 = 0;
      v152 = 0;
      while (1)
      {
        v153 = (char *)v306;
        if (*(_DWORD *)((char *)v306 + v150) == 70)
        {
          v154 = (char *)__ptr;
          if (v151 >= v320)
          {
            v155 = 64;
            if (v320)
              v155 = v320 + (v320 >> 1);
            v320 = v155;
            v154 = (char *)reallocf(__ptr, 16 * v155);
            __ptr = v154;
            if (!v154)
            {
              v17 = *__error();
              v15 = "malloc";
              v16 = 1103;
              goto LABEL_26;
            }
            v151 = __nel;
          }
          v156 = &v154[16 * v151];
          *((_QWORD *)v156 + 1) = v152;
          if ((v307 & 2) != 0)
            v157 = 140;
          else
            v157 = 160;
          *(_QWORD *)v156 = *(_QWORD *)&v153[v150 + v157];
          v151 = ++__nel;
          v149 = v305;
        }
        ++v152;
        v150 += 280;
        if (v152 >= v149)
          goto LABEL_239;
      }
    }
    v151 = 0;
LABEL_239:
    qsort(__ptr, v151, 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpINOEntry);
    v317 = DefaultNThreads;
    if ((0x100000000uLL / DefaultNThreads * DefaultNThreads) >> 32)
      v158 = 0x100000000uLL / DefaultNThreads;
    else
      v158 = 0x100000000uLL / DefaultNThreads + 1;
    v318 = calloc(DefaultNThreads, 0x30uLL);
    if (!v318)
    {
      v17 = *__error();
      v15 = "malloc";
      v16 = 1118;
      goto LABEL_26;
    }
    if (v317)
    {
      v159 = 0;
      v160 = 0;
      v161 = 1;
      do
      {
        v162 = (char *)v318 + v159;
        *(_QWORD *)v162 = &v299;
        v163 = v158 * v160++;
        *((_QWORD *)v162 + 2) = v163;
        *((_QWORD *)v162 + 3) = v158 * v160;
        if ((createThread((pthread_t *)v162 + 1, (uint64_t)resolveSameThreadProc, (uint64_t)v162, 0) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1126, 12, 0, "creating resolve thread", v164, v165, v284);
          v161 = 0;
        }
        v166 = v317;
        v159 += 48;
      }
      while (v160 < v317);
      if (v317)
      {
        v167 = 0;
        v168 = 0;
        do
        {
          v169 = (char *)v318;
          v170 = (char *)v318 + v167;
          v171 = *(_opaque_pthread_t **)((char *)v318 + v167 + 8);
          if (v171)
          {
            if ((joinThread(v171) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1133, 12, 0, "joining resolve thread", v172, v173, v284);
              v161 = 0;
            }
            *((_QWORD *)v170 + 1) = 0;
            v174 = &v169[v167];
            if (*((_QWORD *)v174 + 4))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1135, 12, 0, "Thread reported an error", v172, v173, v284);
              v161 = 0;
            }
            v329 += *((_QWORD *)v174 + 5);
            v166 = v317;
          }
          ++v168;
          v167 += 48;
        }
        while (v168 < v166);
      }
      v12 = v296;
      if (!v161)
      {
LABEL_27:
        v29 = 1;
        goto LABEL_28;
      }
    }
  }
  if (v301 >= 1)
  {
    v175 = v305;
    if (v305)
    {
      v176 = 0;
      v177 = 0;
      v178 = 0;
      v179 = (char *)v306 + 128;
      do
      {
        if (*(v179 - 2) != -1)
          ++v178;
        if (*(v179 - 1) != -1)
          ++v177;
        if (*v179 != -1)
          ++v176;
        v179 += 35;
        --v175;
      }
      while (v175);
    }
    else
    {
      v178 = 0;
      v177 = 0;
      v176 = 0;
    }
    v180 = atomic_load(&v324);
    v181 = (FILE **)MEMORY[0x24BDAC8D8];
    if (v180 > 0)
    {
      v182 = (FILE *)*MEMORY[0x24BDAC8D8];
      v183 = atomic_load(&v324);
      fprintf(v182, "%12llu hard link clusters\n", v183);
      fprintf(*v181, "%12llu hard link entries\n", v178);
      fprintf(*v181, "%12llu redundant bytes in hard links\n", v327);
    }
    v184 = atomic_load(&v325);
    if (v184 >= 1)
    {
      v185 = *v181;
      v186 = atomic_load(&v325);
      fprintf(v185, "%12llu clone clusters\n", v186);
      fprintf(*v181, "%12llu clone entries\n", v177);
      fprintf(*v181, "%12llu redundant bytes in clones\n", v328);
    }
    v187 = atomic_load(&v326);
    if (v187 >= 1)
    {
      v188 = *v181;
      v189 = atomic_load(&v326);
      fprintf(v188, "%12llu same data clusters\n", v189);
      fprintf(*v181, "%12llu same data entries\n", v176);
      fprintf(*v181, "%12llu redundant bytes in same data files\n", v329);
    }
  }
  if (!v305)
  {
LABEL_411:
    v29 = 0;
    goto LABEL_28;
  }
  v190 = 0;
  v293 = (_DWORD *)(v3 + 64);
  v191 = (_BYTE *)(v3 + 70);
  while (1)
  {
    v192 = (uint64_t *)v306;
    if (ArchiveTreeNodePath((uint64_t)v304, v190, (uint64_t)__key, 0x800uLL) < 0)
    {
      v82 = "entry path too long";
      v83 = 1179;
      goto LABEL_119;
    }
    v195 = &v192[35 * v190];
    v197 = *((_DWORD *)v195 + 49);
    v196 = (_DWORD *)v195 + 49;
    if (v197)
    {
      if ((sendFailureEntry(&v299, v190, 1uLL) & 0x80000000) != 0)
      {
        v82 = "sending failure info";
        v83 = 1184;
        goto LABEL_119;
      }
      goto LABEL_409;
    }
    v198 = *(_QWORD *)(v3 + 56);
    if (v198 >= 0xFFFF)
      v198 = 0xFFFFLL;
    v295 = &v192[35 * v190];
    if (*(_DWORD *)v295 == 70)
      v291 = (*(unsigned __int8 *)(v2 + 33) >> 1) & 1;
    else
      v291 = 0;
    if (v198 <= 5)
    {
      v82 = "encode header field";
      v83 = 1197;
      goto LABEL_119;
    }
    *(_WORD *)(v3 + 68) = 30840;
    *v293 = 825246017;
    if (*(_DWORD *)(v3 + 32))
      *v293 = 826360153;
    v289 = v196;
    v199 = v198 - 6;
    v200 = *(_DWORD *)(v2 + 32);
    if ((v200 & 1) != 0)
    {
      v201 = yaa_encodeKeyValue_uint(v191, v199, "TYP", *(unsigned int *)v295);
      if (v201 < 0)
      {
        v82 = "encode TYP field";
        v83 = 1205;
        goto LABEL_119;
      }
      v191 += v201;
      v199 -= v201;
      v200 = *(_DWORD *)(v2 + 32);
    }
    if ((v200 & 2) != 0)
    {
      v202 = yaa_encodeKeyValue_uint(v191, v199, "UID", HIDWORD(v192[35 * v190 + 7]));
      if (v202 < 0)
      {
        v82 = "encode UID field";
        v83 = 1210;
        goto LABEL_119;
      }
      v191 += v202;
      v199 -= v202;
      v200 = *(_DWORD *)(v2 + 32);
    }
    if ((v200 & 4) != 0)
    {
      v203 = yaa_encodeKeyValue_uint(v191, v199, "GID", LODWORD(v192[35 * v190 + 8]));
      if (v203 < 0)
      {
        v82 = "encode GID field";
        v83 = 1215;
        goto LABEL_119;
      }
      v191 += v203;
      v199 -= v203;
      v200 = *(_DWORD *)(v2 + 32);
    }
    if ((v200 & 8) != 0)
    {
      v204 = yaa_encodeKeyValue_uint(v191, v199, "FLG", HIDWORD(v192[35 * v190 + 8]));
      if (v204 < 0)
      {
        v82 = "encode FLG field";
        v83 = 1220;
        goto LABEL_119;
      }
      v191 += v204;
      v199 -= v204;
      v200 = *(_DWORD *)(v2 + 32);
    }
    if ((v200 & 0x10) != 0)
    {
      v205 = yaa_encodeKeyValue_uint(v191, v199, "MOD", HIDWORD(v192[35 * v190]));
      if (v205 < 0)
      {
        v82 = "encode MOD field";
        v83 = 1225;
        goto LABEL_119;
      }
      v191 += v205;
      v199 -= v205;
      v206 = LODWORD(v192[35 * v190 + 7]);
      if ((_DWORD)v206)
      {
        v207 = yaa_encodeKeyValue_uint(v191, v199, "PRC", v206);
        if (v207 < 0)
        {
          v82 = "encode PRC field";
          v83 = 1229;
          goto LABEL_119;
        }
        v191 += v207;
        v199 -= v207;
      }
    }
    if ((*(_BYTE *)(v2 + 33) & 1) != 0)
    {
      v208 = yaa_encodeKeyValue_timespec((uint64_t)v191, v199, "MTM", &v192[35 * v190 + 1]);
      if (v208 < 0)
      {
        v82 = "encode MTM field";
        v83 = 1235;
        goto LABEL_119;
      }
      v191 += v208;
      v199 -= v208;
      v209 = &v192[35 * v190];
      v211 = v209[3];
      v210 = v209 + 3;
      if (v211)
      {
        v212 = yaa_encodeKeyValue_timespec((uint64_t)v191, v199, "CTM", v210);
        if (v212 < 0)
        {
          v82 = "encode CTM field";
          v83 = 1239;
          goto LABEL_119;
        }
        v191 += v212;
        v199 -= v212;
      }
      v213 = &v192[35 * v190];
      v215 = v213[5];
      v214 = v213 + 5;
      if (v215)
      {
        v216 = yaa_encodeKeyValue_timespec((uint64_t)v191, v199, "BTM", v214);
        if (v216 < 0)
        {
          v82 = "encode BTM field";
          v83 = 1244;
          goto LABEL_119;
        }
        v191 += v216;
        v199 -= v216;
      }
    }
    v217 = *(_DWORD *)(v2 + 32);
    if ((v217 & 0x40) != 0)
    {
      v218 = yaa_encodeKeyValue_uint(v191, v199, "INO", v192[35 * v190 + 10]);
      if (v218 < 0)
      {
        v82 = "encode INO field";
        v83 = 1250;
        goto LABEL_119;
      }
      v191 += v218;
      v199 -= v218;
      v217 = *(_DWORD *)(v2 + 32);
    }
    if ((v217 & 0x80) != 0 && *(_DWORD *)v295 == 70)
    {
      v219 = yaa_encodeKeyValue_uint(v191, v199, "SIZ", v192[35 * v190 + 12]);
      if (v219 < 0)
      {
        v82 = "encode SIZ field";
        v83 = 1255;
        goto LABEL_119;
      }
      v191 += v219;
      v199 -= v219;
      v217 = *(_DWORD *)(v2 + 32);
    }
    if ((v217 & 0x20) != 0 && (*(_DWORD *)v295 & 0xFFFFFFFE) == 0x42)
    {
      v220 = yaa_encodeKeyValue_uint(v191, v199, "DEV", SLODWORD(v192[35 * v190 + 11]));
      if (v220 < 0)
      {
        v82 = "encode DEV field";
        v83 = 1260;
        goto LABEL_119;
      }
      v191 += v220;
      v199 -= v220;
      v217 = *(_DWORD *)(v2 + 32);
    }
    if ((v217 & 0x8000) != 0)
    {
      v221 = yaa_encodeKeyValue_path((uint64_t)v191, v199, "PAT", (char *)__key);
      if ((v221 & 0x8000000000000000) != 0)
      {
        v82 = "encode PAT field";
        v83 = 1265;
        goto LABEL_119;
      }
      v191 += v221;
      v199 -= v221;
      v217 = *(_DWORD *)(v2 + 32);
    }
    if ((v217 & 0x10000) != 0 && v192[35 * v190 + 26])
    {
      v222 = yaa_encodeKeyValue_path((uint64_t)v191, v199, "LNK", (char *)(v309 + v192[35 * v190 + 25]));
      if ((v222 & 0x8000000000000000) != 0)
      {
        v82 = "encode LNK field";
        v83 = 1270;
        goto LABEL_119;
      }
      v191 += v222;
      v199 -= v222;
    }
    if (v291)
    {
      v223 = v192[35 * v190 + 12];
      v224 = yaa_encodeKeyValue_blob((uint64_t)v191, v199, "DAT", v223);
      if (v224 < 0)
      {
        v82 = "encode DAT field";
        v83 = 1276;
        goto LABEL_119;
      }
      v191 += v224;
      v199 -= v224;
    }
    else
    {
      v223 = 0;
    }
    v225 = *(_DWORD *)(v2 + 32);
    if ((v225 & 0x400) != 0)
    {
      v226 = &v192[35 * v190];
      v227 = v226[28];
      if (v227)
      {
        v228 = yaa_encodeKeyValue_blob((uint64_t)v191, v199, "XAT", v226[28]);
        if (v228 < 0)
        {
          v82 = "encode XAT field";
          v83 = 1282;
          goto LABEL_119;
        }
        v223 += v227;
        v191 += v228;
        v199 -= v228;
        v225 = *(_DWORD *)(v2 + 32);
      }
    }
    if ((v225 & 0x800) != 0)
    {
      v229 = &v192[35 * v190];
      v230 = v229[30];
      if (v230)
      {
        v231 = yaa_encodeKeyValue_blob((uint64_t)v191, v199, "ACL", v229[30]);
        if (v231 < 0)
        {
          v82 = "encode ACL field";
          v83 = 1288;
          goto LABEL_119;
        }
        v223 += v230;
        v191 += v231;
        v199 -= v231;
        v225 = *(_DWORD *)(v2 + 32);
      }
    }
    v232 = *(_DWORD *)v295;
    if ((v225 & 0x1000) != 0 && v232 == 70)
    {
      v233 = yaa_encodeKeyValue_cksum((uint64_t)v191, v199, "CKS", &v192[35 * v190 + 17]);
      if (v233 < 0)
      {
        v82 = "encode CKS field";
        v83 = 1293;
        goto LABEL_119;
      }
      v191 += v233;
      v199 -= v233;
      v225 = *(_DWORD *)(v2 + 32);
      v232 = *(_DWORD *)v295;
    }
    if ((v225 & 0x2000) != 0 && v232 == 70)
    {
      v234 = yaa_encodeKeyValue_sha1((uint64_t)v191, v199, "SH1", (uint64_t)&v192[35 * v190 + 17] + 4);
      if (v234 < 0)
      {
        v82 = "encode SH1 field";
        v83 = 1298;
        goto LABEL_119;
      }
      v191 += v234;
      v199 -= v234;
      v225 = *(_DWORD *)(v2 + 32);
      v232 = *(_DWORD *)v295;
    }
    if ((v225 & 0x4000) != 0)
    {
      if (v232 != 70)
        goto LABEL_368;
      v235 = yaa_encodeKeyValue_sha256((uint64_t)v191, v199, "SH2", &v192[35 * v190 + 20]);
      if (v235 < 0)
      {
        v82 = "encode SH2 field";
        v83 = 1303;
        goto LABEL_119;
      }
      v191 += v235;
      v199 -= v235;
      v232 = *(_DWORD *)v295;
    }
    if (v232 == 70)
    {
      v236 = v192[35 * v190 + 14];
      if (v236 == -1)
        goto LABEL_362;
      v237 = yaa_encodeKeyValue_uint(v191, v199, "HLC", v236);
      if (v237 < 0)
      {
        v82 = "encode HLC field";
        v83 = 1309;
        goto LABEL_119;
      }
      v191 += v237;
      v199 -= v237;
      if (*(_DWORD *)v295 == 70)
      {
LABEL_362:
        v238 = v192[35 * v190 + 15];
        if (v238 == -1)
          goto LABEL_365;
        v239 = yaa_encodeKeyValue_uint(v191, v199, "CLC", v238);
        if (v239 < 0)
        {
          v82 = "encode CLC field";
          v83 = 1315;
          goto LABEL_119;
        }
        v191 += v239;
        v199 -= v239;
        if (*(_DWORD *)v295 == 70)
        {
LABEL_365:
          v240 = v192[35 * v190 + 16];
          if (v240 != -1)
          {
            v241 = yaa_encodeKeyValue_uint(v191, v199, "SLC", v240);
            if (v241 < 0)
            {
              v82 = "encode SLC field";
              v83 = 1321;
              goto LABEL_119;
            }
            v191 += v241;
            v199 -= v241;
          }
        }
      }
    }
LABEL_368:
    v242 = &v192[35 * v190];
    v243 = v242[32];
    if (v243)
    {
      if (v199 < v243)
      {
        v82 = "copy header extra fields";
        v83 = 1327;
        goto LABEL_119;
      }
      v223 += v192[35 * v190 + 34];
      memcpy(v191, (const void *)(v309 + v242[31]), v243);
      v191 += v243;
    }
    *(_WORD *)(v3 + 68) = (_WORD)v191 - (_WORD)v293;
    if (*(_DWORD *)(v3 + 32))
      *v293 = 826360153;
    if ((yaa_writeRawEntryHeader(v3, (uint64_t)v293, v191 - (_BYTE *)v293, v223, v193, v194, v13, v14) & 0x80000000) != 0)
      break;
    if (v291)
    {
      if (concatPath(v297, 0x800uLL, v302, (const char *)__key))
      {
        v281 = "full path too long";
        v282 = 1348;
        goto LABEL_441;
      }
      v249 = v192[35 * v190 + 12];
      if (v249)
      {
        v250 = open(v297, 0);
        if (v250 < 0)
        {
          v266 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1354, 12, "open failed (%d): %s", v267, v268, v269, *v266);
          v265 = 1;
          *v289 = 1;
LABEL_393:
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1391, 12, "truncated data: %s", v246, v247, v248, (char)v297);
          *v289 = 1;
          bzero(v293, *(_QWORD *)(v3 + 56));
          while (1)
          {
            v274 = *(_QWORD *)(v3 + 56) >= v249 ? v249 : *(_QWORD *)(v3 + 56);
            if (ParallelArchiveWriteEntryData(v300, (uint64_t)v293, v274, v244, v245, v246, v247, v248))
              break;
            v249 -= v274;
            if (!v249)
              goto LABEL_399;
          }
          v284 = v274;
          v278 = "write DAT 0x00, w=%zu: %s";
          v279 = 1397;
LABEL_419:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v279, 12, 0, v278, v247, v248, v284);
LABEL_420:
          v280 = 99;
          goto LABEL_442;
        }
        v251 = v250;
        while (1)
        {
          v252 = read(v251, v293, *(_QWORD *)(v3 + 56));
          if ((v252 & 0x8000000000000000) != 0)
          {
            v270 = __error();
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1377, 12, "read failed (%d): %s", v271, v272, v273, *v270);
            v265 = 1;
            *v289 = 1;
            goto LABEL_392;
          }
          v258 = v252;
          if (!v252)
          {
            v265 = 1;
            goto LABEL_392;
          }
          v259 = v252 >= v249 ? v249 : v252;
          if (ParallelArchiveWriteEntryData(v300, (uint64_t)v293, v259, v253, v254, v255, v256, v257))
            break;
          v263 = v249 - v259;
          v264 = v258 > v249;
          v249 = v263;
          if (v264)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1384, 12, "extra data: %s", v260, v261, v262, (char)v297);
            v265 = 1;
            *v289 = 1;
            v249 = v263;
            goto LABEL_392;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", 1381, 12, 0, "write DAT, w=%zu: %s", v261, v262, v259);
        v265 = 0;
LABEL_392:
        close(v251);
        if (v249)
          goto LABEL_393;
LABEL_399:
        if (!v265)
          goto LABEL_420;
      }
    }
    v275 = v192[35 * v190 + 28];
    if (v275
      && ParallelArchiveWriteEntryData(v300, v309 + v192[35 * v190 + 27], v275, v244, v245, v246, v247, v248))
    {
      v278 = "write entry XAT";
      v279 = 1407;
      goto LABEL_419;
    }
    v276 = v192[35 * v190 + 30];
    if (v276
      && ParallelArchiveWriteEntryData(v300, v309 + v192[35 * v190 + 29], v276, v244, v245, v246, v247, v248))
    {
      v278 = "write entry ACL";
      v279 = 1413;
      goto LABEL_419;
    }
    v277 = v192[35 * v190 + 34];
    if (v277
      && ParallelArchiveWriteEntryData(v300, v309 + v192[35 * v190 + 33], v277, v244, v245, v246, v247, v248))
    {
      v278 = "write extra fields data";
      v279 = 1419;
      goto LABEL_419;
    }
    if (*v289 && (sendFailureEntry(&v299, v190, 2uLL) & 0x80000000) != 0)
    {
      v281 = "sending failure info";
      v282 = 1425;
      goto LABEL_441;
    }
    v12 = v296;
    v191 = (_BYTE *)(v3 + 70);
LABEL_409:
    v29 = 0;
    if (++v190 >= v305)
      goto LABEL_28;
  }
  v281 = "writing raw header";
  v282 = 1340;
LABEL_441:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"ParallelArchiveWriteDirContents", v282, 12, 0, v281, v247, v248, v284);
  v280 = 4;
LABEL_442:
  v29 = 1;
  if (v280 == 99)
    goto LABEL_139;
  v12 = v296;
LABEL_28:
  BlobBufferFree((uint64_t)v308);
  ArchiveTreeDestroy((uint64_t)v304);
  free(v306);
  v30 = v311;
  if (v311 && (_DWORD)__count)
  {
    v31 = 0;
    v32 = 0;
    do
    {
      v33 = (char *)v311;
      v34 = (char *)v311 + v31;
      v35 = *(_opaque_pthread_t **)((char *)v311 + v31 + 16);
      if (v35)
        joinThread(v35);
      BlobBufferFree((uint64_t)(v34 + 160));
      if (!pthread_mutex_destroy((pthread_mutex_t *)(v34 + 48)))
        pthread_cond_destroy((pthread_cond_t *)&v33[v31 + 112]);
      ++v32;
      v31 += 200;
    }
    while (v32 < __count);
    v30 = v311;
  }
  free(v30);
  if (!pthread_mutex_destroy(&v315) && !pthread_cond_destroy(&v316))
    free(v314);
  v36 = v318;
  if (v318)
  {
    v37 = v317;
    if (v317)
    {
      v38 = 0;
      v39 = 8;
      do
      {
        v40 = *(_opaque_pthread_t **)((char *)v318 + v39);
        if (v40)
        {
          joinThread(v40);
          v37 = v317;
        }
        ++v38;
        v39 += 48;
      }
      while (v38 < v37);
      v36 = v318;
    }
  }
  free(v36);
  free(__ptr);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) != 0)
    return (int)result;
  if ((v29 & 1) != 0)
    return -1;
  return *(_QWORD *)(v3 + 40) - v12;
}

uint64_t cmpINOEntry(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a2 < *a1;
}

uint64_t sendFailureEntry(_QWORD *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  const char *v10;
  __int16 v11;
  _DWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  size_t v17;
  _BYTE *v18;
  unint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v27;
  char __s[2048];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v6 = a1[1];
  if (ArchiveTreeNodePath(a1[132], a2, (uint64_t)__s, 0x800uLL) < 0)
  {
    v10 = "entry path too long";
    v11 = 766;
  }
  else
  {
    v9 = *(_QWORD *)(v6 + 56);
    if (v9 >= 0xFFFF)
      v9 = 0xFFFFLL;
    if (v9 > 5)
    {
      v12 = (_DWORD *)(v6 + 64);
      *(_WORD *)(v6 + 68) = 30840;
      *(_DWORD *)(v6 + 64) = 825246017;
      if (*(_DWORD *)(v6 + 32))
      {
        *(_WORD *)(v6 + 68) = 30840;
        *v12 = 826360153;
      }
      v13 = v9 - 6;
      v14 = yaa_encodeKeyValue_uint((_BYTE *)(v6 + 70), v9 - 6, "TYP", 0x4DuLL);
      if (v14 < 0)
      {
        v10 = "encode TYP field";
        v11 = 783;
      }
      else
      {
        v15 = v6 + 70 + v14;
        v16 = v13 - v14;
        v17 = yaa_encodeKeyValue_path(v15, v16, "PAT", __s);
        if ((v17 & 0x8000000000000000) != 0)
        {
          v10 = "encode PAT field";
          v11 = 787;
        }
        else
        {
          v18 = (_BYTE *)(v15 + v17);
          v19 = v16 - v17;
          v20 = yaa_encodeKeyValue_uint(v18, v19, "ERR", a3);
          if (v20 < 0)
          {
            v10 = "encode ERR field";
            v11 = 791;
          }
          else
          {
            v21 = &v18[v20];
            v22 = yaa_encodeKeyValue_uint(&v18[v20], v19 - v20, "EYP", *(unsigned int *)(a1[134] + 280 * a2));
            if (v22 < 0)
            {
              v10 = "encode EYP field";
              v11 = 795;
            }
            else
            {
              v25 = &v21[v22] - (_BYTE *)v12;
              *(_WORD *)(v6 + 68) = v25;
              if ((yaa_writeRawEntryHeader(v6, v6 + 64, v25, 0, v23, v24, v7, v8) & 0x80000000) == 0)
                return 0;
              v10 = "writing raw header";
              v11 = 802;
            }
          }
        }
      }
    }
    else
    {
      v10 = "encode header field";
      v11 = 775;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/WriteDirContents.c", (uint64_t)"sendFailureEntry", v11, 12, 0, v10, v7, v8, v27);
  return 0xFFFFFFFFLL;
}

_QWORD *aaInSituStreamOpen(_QWORD *a1, uint64_t a2, int a3, int a4, int a5)
{
  _QWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  void *v17;
  __int128 v18;
  int v19;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;

  v10 = calloc(1uLL, 0x68uLL);
  v11 = calloc(1uLL, 0x140uLL);
  v14 = (uint64_t)v11;
  if (!v10 || !v11)
  {
    v23 = "aaCalloc";
    v24 = 336;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"aaInSituStreamOpen", v24, 140, 0, v23, v12, v13, v33);
    free(v10);
    InSituStreamClose(v14, v25, v26, v27, v28, v29, v30, v31);
    return 0;
  }
  *(_QWORD *)v11 = a1;
  v11[78] = a5;
  v15 = (unint64_t)(a2 + 0x3FFF) >> 14;
  v11[72] = v15;
  LODWORD(v15) = v15 + ((a3 + 0x3FFF) >> 14) + ((int)v15 >> 2);
  v11[79] = a4;
  v16 = (v15 + 256);
  *(_DWORD *)(v14 + 292) = v16;
  if ((int)v15 + 256 < 0)
  {
    *__error() = 12;
    *(_QWORD *)(v14 + 8) = 0;
    goto LABEL_14;
  }
  v17 = calloc(v16, 0xDuLL);
  *(_QWORD *)(v14 + 8) = v17;
  if (!v17)
  {
LABEL_14:
    v23 = "aaCalloc";
    v24 = 347;
    goto LABEL_16;
  }
  *(_QWORD *)&v18 = -1;
  *((_QWORD *)&v18 + 1) = -1;
  *(_OWORD *)(v14 + 240) = v18;
  *(_OWORD *)(v14 + 256) = v18;
  *(_OWORD *)(v14 + 208) = v18;
  *(_OWORD *)(v14 + 224) = v18;
  *(_OWORD *)(v14 + 176) = v18;
  *(_OWORD *)(v14 + 192) = v18;
  *(_OWORD *)(v14 + 144) = v18;
  *(_OWORD *)(v14 + 160) = v18;
  *(_OWORD *)(v14 + 112) = v18;
  *(_OWORD *)(v14 + 128) = v18;
  *(_OWORD *)(v14 + 80) = v18;
  *(_OWORD *)(v14 + 96) = v18;
  *(_OWORD *)(v14 + 48) = v18;
  *(_OWORD *)(v14 + 64) = v18;
  *(_OWORD *)(v14 + 16) = v18;
  *(_OWORD *)(v14 + 32) = v18;
  v19 = *(_DWORD *)(v14 + 292);
  if (v19 >= 1)
  {
    v20 = 0;
    for (i = 0; i < v19; ++i)
    {
      v22 = *(_QWORD *)(v14 + 8) + v20;
      *(_DWORD *)(v22 + 1) = i;
      *(_QWORD *)(v22 + 5) = 0xFFFFFFFF00000000;
      if (i < *(int *)(v14 + 288))
      {
        free_page(v14, i);
        v19 = *(_DWORD *)(v14 + 292);
      }
      v20 += 13;
    }
  }
  if ((AAByteStreamTruncate(a1) & 0x80000000) != 0)
  {
    v23 = "AAByteStreamTruncate";
    v24 = 362;
    goto LABEL_16;
  }
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)InSituStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)InSituStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)InSituStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)InSituStreamClose);
  v10[8] = InSituTruncate;
  v10[11] = InSituStreamSimulate;
  return v10;
}

uint64_t free_page(uint64_t result, int a2)
{
  uint64_t v3;
  uint64_t i;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;

  v3 = result;
  for (i = *(_QWORD *)(result + 8); ; a2 = *(_DWORD *)(i + 13 * a2 + 1))
  {
    v5 = (_BYTE *)(i + 13 * a2);
    v6 = *v5;
    if (v6 != 2)
      break;
  }
  if (v6 == 1)
  {
    *v5 = 0;
    *(_DWORD *)(i + 13 * a2 + 5) = 0;
  }
  ++*(_DWORD *)(result + 296);
  v7 = i + 13 * a2;
  v9 = *(_DWORD *)(v7 + 9);
  v8 = (_DWORD *)(v7 + 9);
  if (v9 < 0)
  {
    v10 = *(_DWORD *)(result + 276);
    *(_DWORD *)(result + 276) = v10 - 1;
    if (v10 >= 2)
    {
      v11 = *(_DWORD *)(result + 272);
    }
    else
    {
      *(_DWORD *)(result + 276) = 32;
      result = rand();
      v11 = result & 0x3F;
      *(_DWORD *)(v3 + 272) = v11;
    }
    v12 = v3 + 4 * v11;
    *v8 = *(_DWORD *)(v12 + 16);
    *(_DWORD *)(v12 + 16) = a2;
  }
  return result;
}

uint64_t InSituStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (result)
  {
    v8 = result;
    v9 = *(unsigned int *)(result + 292);
    if ((int)v9 < 1)
      goto LABEL_7;
    v10 = 0;
    v11 = (int *)(*(_QWORD *)(result + 8) + 5);
    do
    {
      v12 = *v11;
      v11 = (int *)((char *)v11 + 13);
      v10 += v12;
      --v9;
    }
    while (v9);
    if (v10)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 298, 140, 0, "%i dangling reads", a7, a8, v10);
      v13 = 0;
    }
    else
    {
LABEL_7:
      v13 = 1;
    }
    v14 = *(_DWORD *)(v8 + 288);
    v15 = *(_DWORD *)(v8 + 308);
    if (*(_DWORD *)(v8 + 300) + v14 != *(_DWORD *)(v8 + 296) + v15)
    {
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 301, 140, "file + excess != written + free", a6, a7, a8, v18);
      v14 = *(_DWORD *)(v8 + 288);
      v15 = *(_DWORD *)(v8 + 308);
    }
    if (v14 < v15)
      pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 302, 140, "file < written", a6, a7, a8, v18);
    if (*(_DWORD *)(v8 + 316))
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "InSituStream: pages: %i file, %i written, %i remapped, %i free, %i excess (%iK)\n", *(_DWORD *)(v8 + 288), *(_DWORD *)(v8 + 308), *(_DWORD *)(v8 + 304), *(_DWORD *)(v8 + 296), *(_DWORD *)(v8 + 300), 16 * *(_DWORD *)(v8 + 300));
    free(*(void **)(v8 + 8));
    if (*(_DWORD *)(v8 + 312) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamClose", 319, 140, 0, "AAByteStreamClose", v16, v17, v18);
      v13 = 0;
    }
    free((void *)v8);
    if (v13)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t InSituStreamPRead(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v24;

  if (!a3)
    return 0;
  v11 = 0;
  while (1)
  {
    v12 = a1[1];
    v13 = (v11 + a4) & 0x3FFF;
    v14 = a3 - v11 >= 0x4000 - v13 ? 0x4000 - v13 : a3 - v11;
    if (!*(_DWORD *)(v12 + 13 * (int)((v11 + a4) >> 14) + 5))
      break;
    v15 = *a1;
    if (!*(_QWORD *)(*a1 + 32))
      goto LABEL_19;
    if (v14)
    {
      v16 = 0;
      v17 = v13 | ((uint64_t)*(int *)(v12 + 13 * (int)((uint64_t)(v11 + a4) >> 14) + 1) << 14);
      v18 = a2 + v11;
      v19 = v14;
      while (1)
      {
        v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v15 + 32))(*(_QWORD *)v15, v18, v19, v17);
        if (v20 < 0)
          break;
        if (v20)
        {
          v18 += v20;
          v16 += v20;
          v17 += v20;
          v19 -= v20;
          if (v19)
            continue;
        }
        goto LABEL_15;
      }
      v16 = v20;
LABEL_15:
      if (v14 != v16)
      {
LABEL_19:
        v21 = "aaByteStreamPReadExpected";
        v22 = 238;
        goto LABEL_21;
      }
    }
    v11 += v14;
    if (v11 >= a3)
      return v11;
  }
  v21 = "data not locked";
  v22 = 235;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPRead", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

uint64_t InSituStreamPWrite(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v24;

  if (!a3)
    return 0;
  v11 = 0;
  while (1)
  {
    v12 = v11 + a4;
    v13 = (v11 + a4) >> 14;
    v14 = (_BYTE *)(a1[1] + 13 * (int)v13);
    if (a3 - v11 >= 0x4000 - ((v11 + a4) & 0x3FFF))
      v15 = 0x4000 - ((v11 + a4) & 0x3FFF);
    else
      v15 = a3 - v11;
    if (*v14 == 2)
      goto LABEL_9;
    if ((remap_page(a1, v13) & 0x80000000) != 0)
      break;
    *v14 = 2;
    --*((_DWORD *)a1 + 74);
    ++*((_DWORD *)a1 + 77);
LABEL_9:
    v16 = *a1;
    if (!*(_QWORD *)(*a1 + 40))
      goto LABEL_20;
    if (v15)
    {
      v17 = 0;
      v18 = a2 + v11;
      v19 = v15;
      while (1)
      {
        v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v16 + 40))(*(_QWORD *)v16, v18, v19, v12);
        if (v20 < 1)
          break;
        v18 += v20;
        v17 += v20;
        v12 += v20;
        v19 -= v20;
        if (!v19)
          goto LABEL_16;
      }
      v17 = v20;
LABEL_16:
      if (v15 != v17)
      {
LABEL_20:
        v21 = "aaByteStreamPWriteExpected";
        v22 = 268;
        goto LABEL_22;
      }
    }
    v11 += v15;
    if (v11 >= a3)
      return v11;
  }
  v21 = "remap_page";
  v22 = 261;
LABEL_22:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamPWrite", v22, 140, 0, v21, a7, a8, v24);
  return -1;
}

void InSituStreamCancel(AAByteStream *a1)
{
  AAByteStreamCancel(*a1);
}

uint64_t InSituTruncate(_QWORD **a1)
{
  return AAByteStreamTruncate(*a1);
}

uint64_t InSituStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  int64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  const char *v23;
  __int16 v24;
  char v26;

  v8 = a5;
  v9 = a4;
  if (a2 == 3)
  {
    v11 = *(_QWORD *)a1;
    if (!*(_QWORD *)(*(_QWORD *)a1 + 32))
      return -1;
    if (!a4)
      return 0;
    v13 = 0;
    while (1)
    {
      v14 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, unint64_t))(v11 + 32))(*(_QWORD *)v11, a3, v9, v8);
      if (v14 < 0)
        break;
      if (v14)
      {
        a3 += v14;
        v13 += v14;
        v8 += v14;
        v9 -= v14;
        if (v9)
          continue;
      }
      return v13;
    }
    return v14;
  }
  if (a4 < 1)
    return v9;
  if (a2 > 1)
  {
    v23 = "not implemented";
    v24 = 197;
    goto LABEL_24;
  }
  v16 = a5 + a4;
  while (1)
  {
    v17 = *(_QWORD *)(a1 + 8) + 13 * (int)(v8 >> 14);
    v20 = *(_DWORD *)(v17 + 5);
    v18 = (int *)(v17 + 5);
    v19 = v20;
    if (!a2)
      break;
    if (v19 <= 0)
    {
      v23 = "data not locked";
      v24 = 209;
      goto LABEL_24;
    }
    v21 = v19 - 1;
    *v18 = v21;
    if (!v21)
      free_page(a1, v8 >> 14);
LABEL_18:
    v8 = (v8 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if ((uint64_t)v8 >= v16)
      return v9;
  }
  *v18 = v19 + 1;
  if (v19)
    goto LABEL_18;
  v22 = *(_DWORD *)(a1 + 296);
  *(_DWORD *)(a1 + 296) = v22 - 1;
  if (v22)
    goto LABEL_18;
  v23 = "no free pages";
  v24 = 204;
LABEL_24:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"InSituStreamSimulate", v24, 140, 0, v23, a7, a8, v26);
  return -1;
}

uint64_t remap_page(_DWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  int v5;
  uint64_t result;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  int v17;
  unsigned int *v18;
  unsigned int v19;
  int v20;
  BOOL v21;
  int v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char v42;

  v2 = *((_QWORD *)a1 + 1);
  v3 = v2 + 13 * a2;
  v5 = *(_DWORD *)(v3 + 5);
  v4 = (_DWORD *)(v3 + 5);
  if (v5)
  {
    if (*(_BYTE *)(v2 + 13 * a2) == 1)
    {
      result = remap_page(a1, *(unsigned int *)(v2 + 13 * a2 + 1));
      *v4 = 0;
      return result;
    }
    v11 = (char *)malloc(0x4000uLL);
    v14 = v11;
    if (v11)
    {
      v15 = a1[74];
      if (v15 <= 0)
      {
        v26 = a1[72];
        v27 = a1[75];
        a1[75] = v27 + 1;
        v19 = v27 + v26;
        if (v27 + v26 >= a1[73])
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"allocate_page", 97, 140, 0, "too many excess pages", v12, v13, v42);
        }
        else if ((v19 & 0x80000000) == 0)
        {
LABEL_20:
          v28 = *(_QWORD *)a1;
          if (*(_QWORD *)(*(_QWORD *)a1 + 32))
          {
            v29 = 0;
            v30 = (unsigned int *)(v2 + 13 * a2 + 1);
            v31 = (uint64_t)(int)*v30 << 14;
            v32 = 0x4000;
            v33 = v11;
            while (1)
            {
              v34 = (*(uint64_t (**)(_QWORD, char *, uint64_t, uint64_t))(v28 + 32))(*(_QWORD *)v28, v33, v32, v31);
              if (v34 < 0)
                break;
              if (v34)
              {
                v33 += v34;
                v29 += v34;
                v31 += v34;
                v32 -= v34;
                if (v32)
                  continue;
              }
              if (v29 != 0x4000)
                break;
              v35 = *(_QWORD *)a1;
              if (*(_QWORD *)(*(_QWORD *)a1 + 40))
              {
                v36 = 0;
                v37 = (unint64_t)v19 << 14;
                v38 = 0x4000;
                v39 = v14;
                while (1)
                {
                  v40 = (*(uint64_t (**)(_QWORD, char *, uint64_t, unint64_t))(v35 + 40))(*(_QWORD *)v35, v39, v38, v37);
                  if (v40 < 1)
                    break;
                  v39 += v40;
                  v36 += v40;
                  v37 += v40;
                  v38 -= v40;
                  if (!v38)
                  {
                    if (v36 != 0x4000)
                      break;
                    v10 = 0;
                    *v30 = v19;
                    v41 = *((_QWORD *)a1 + 1) + 13 * v19;
                    *(_BYTE *)v41 = 1;
                    *(_DWORD *)(v41 + 1) = a2;
                    *(_DWORD *)(v41 + 5) = 0x7FFFFFFF;
                    ++a1[76];
                    ++a1[74];
                    goto LABEL_35;
                  }
                }
              }
              v24 = "aaByteStreamPWriteExpected";
              v25 = 158;
              goto LABEL_34;
            }
          }
          v24 = "aaByteStreamPReadExpected";
          v25 = 157;
          goto LABEL_34;
        }
      }
      else
      {
        v16 = a1[70];
        a1[74] = v15 - 1;
        v17 = a1[73];
        if (v17)
        {
          v18 = &a1[(v16 & 0x3F) + 4];
          do
          {
            v19 = *v18;
            if ((*v18 & 0x80000000) != 0
              || (v20 = a1[71], v21 = __OFSUB__(v20, 1), --v20, a1[71] = v20, (v20 < 0) ^ v21 | (v20 == 0)))
            {
              a1[71] = 32;
              v22 = a1[70] + 1;
              a1[70] = v22;
              v18 = &a1[(v22 & 0x3F) + 4];
            }
            else
            {
              v23 = v2 + 13 * v19;
              *v18 = *(_DWORD *)(v23 + 9);
              *(_DWORD *)(v23 + 9) = -1;
              if (!*(_DWORD *)(v23 + 5) && !*(_BYTE *)(v2 + 13 * v19))
                goto LABEL_20;
            }
            --v17;
          }
          while (v17);
        }
      }
      v24 = "allocate_page";
      v25 = 153;
    }
    else
    {
      v24 = "aaMalloc";
      v25 = 149;
    }
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/InSituStream.c", (uint64_t)"remap_page", v25, 140, 0, v24, v12, v13, v42);
    v10 = 0xFFFFFFFFLL;
LABEL_35:
    free(v14);
    return v10;
  }
  return 0;
}

_QWORD *AATempStreamOpen(unint64_t a1)
{
  return AATempStreamOpenWithDirectory(a1, 0);
}

_QWORD *AATempStreamOpenWithDirectory(unint64_t a1, const char *a2)
{
  _QWORD *v4;
  char *v5;
  char *v6;
  size_t v7;
  size_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  void *v15;
  uint64_t v16;
  char v18;

  v4 = calloc(1uLL, 0x68uLL);
  v5 = (char *)malloc(0x88uLL);
  v6 = v5;
  if (v5 && (memset_s(v5, 0x88uLL, 0, 0x88uLL), v4))
  {
    if (a2)
    {
      v7 = strlen(a2);
      v8 = v7 + 1;
      if (v7 + 1 < 0x2000000001)
      {
        v15 = malloc(v7 + 1);
        v9 = v15;
        if (v15)
          memcpy(v15, a2, v8);
      }
      else
      {
        v9 = 0;
        *__error() = 12;
      }
    }
    else
    {
      v9 = 0;
    }
    *((_QWORD *)v6 + 13) = v9;
    v16 = a1 >> 20;
    if (a1 == -1)
      v16 = -1;
    *((_QWORD *)v6 + 1) = 0x100000;
    *((_QWORD *)v6 + 2) = v16;
    if ((pthread_mutex_init((pthread_mutex_t *)(v6 + 40), 0) & 0x80000000) == 0)
    {
      *v4 = v6;
      v4[1] = tempStreamClose;
      v4[6] = tempStreamSeek;
      v4[7] = tempStreamCancel;
      v4[2] = tempStreamRead;
      v4[3] = tempStreamWrite;
      v4[4] = tempStreamPRead;
      v4[5] = tempStreamPWrite;
      v4[8] = tempStreamTruncate;
      return v4;
    }
    v10 = *__error();
    v13 = "mutex init";
    v14 = 326;
  }
  else
  {
    v10 = *__error();
    v13 = "malloc";
    v14 = 320;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"AATempStreamOpenWithDirectory", v14, 50, v10, v13, v11, v12, v18);
  free(v6);
  free(v4);
  return 0;
}

uint64_t tempStreamClose(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  void *v3;
  unint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = atomic_load((unsigned int *)(result + 128));
    AAByteStreamClose(*(AAByteStream *)(result + 112));
    v3 = *(void **)(v1 + 32);
    if (v3)
    {
      if (*(_QWORD *)(v1 + 24))
      {
        v4 = 0;
        do
          free(*(void **)(*(_QWORD *)(v1 + 32) + 8 * v4++));
        while (v4 < *(_QWORD *)(v1 + 24));
        v3 = *(void **)(v1 + 32);
      }
      free(v3);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
    free(*(void **)(v1 + 104));
    free((void *)v1);
    if (v2)
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  return result;
}

uint64_t tempStreamCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 128);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

ssize_t tempStreamRead(uint64_t a1, void *a2, size_t a3)
{
  unint64_t *v5;
  off_t v6;

  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  if (*(_QWORD *)(a1 + 112))
    return AAByteStreamRead(*(AAByteStream *)(a1 + 112), a2, a3);
  v5 = (unint64_t *)(a1 + 120);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return tempStreamPRead(a1, (char *)a2, a3, v6);
}

ssize_t tempStreamPRead(uint64_t a1, char *buf, size_t a3, off_t offset)
{
  unsigned int *v4;
  uint64_t v6;
  unint64_t v8;
  char *v9;
  AAByteStream_impl *v11;
  int64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  BOOL v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  char v29;

  v4 = (unsigned int *)(a1 + 128);
  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  v8 = offset;
  v9 = buf;
  v11 = *(AAByteStream_impl **)(a1 + 112);
  if (!v11)
  {
    if (((offset | a3) & 0x8000000000000000) == 0)
    {
      v12 = offset + a3;
      if (!__OFADD__(offset, a3))
      {
        if (*(_QWORD *)a1 <= offset)
          return 0;
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
        {
          v21 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPRead", 120, 50, *v21, "mutex lock", v22, v23, v29);
          v6 = -1;
          while (!__ldaxr(v4))
          {
            if (!__stlxr(1u, v4))
              return v6;
          }
        }
        else
        {
          if (v12 >= *(_QWORD *)a1)
            v13 = *(_QWORD *)a1;
          else
            v13 = v12;
          if (v13 <= v8)
          {
            v6 = 0;
          }
          else
          {
            v6 = 0;
            v14 = *(_QWORD *)(a1 + 8);
            v15 = v8 / v14;
            v16 = v8 / v14 * v14;
            v17 = v16 + v14;
            do
            {
              if (v17 >= v13)
                v18 = v13;
              else
                v18 = v17;
              memcpy(v9, (const void *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v15) + v8 - v16), v18 - v8);
              v9 += v18 - v8;
              v6 += v18 - v8;
              ++v15;
              v19 = *(_QWORD *)(a1 + 8);
              v16 += v19;
              v8 = v18;
              v20 = v13 > v17;
              v17 += v19;
            }
            while (v20);
          }
          if ((pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) & 0x80000000) == 0)
            return v6;
          v25 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPRead", 148, 50, *v25, "mutex unlock", v26, v27, (char)v4);
          v6 = -1;
          while (!__ldaxr(v4))
          {
            if (!__stlxr(1u, v4))
              return v6;
          }
        }
        __clrex();
      }
    }
    return -1;
  }
  return AAByteStreamPRead(v11, buf, a3, offset);
}

off_t tempStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;

  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  if (!*(_QWORD *)(a1 + 112))
  {
    if (a3)
    {
      if (a3 == 1)
      {
        v5 = (unint64_t *)(a1 + 120);
        do
        {
          v6 = __ldaxr(v5);
          v7 = v6 + a2;
        }
        while (__stlxr(v7, v5));
        return v7;
      }
      if (a3 != 2)
        return -1;
      a2 += *(_QWORD *)a1;
    }
    atomic_store(a2, (unint64_t *)(a1 + 120));
    return a2;
  }
  return AAByteStreamSeek(*(AAByteStream *)(a1 + 112), a2, a3);
}

ssize_t tempStreamWrite(uint64_t a1, void *a2, size_t a3)
{
  unint64_t *v5;
  unint64_t v6;

  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  if (*(_QWORD *)(a1 + 112))
    return AAByteStreamWrite(*(AAByteStream *)(a1 + 112), a2, a3);
  v5 = (unint64_t *)(a1 + 120);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return tempStreamPWrite(a1, (char *)a2, a3, v6);
}

ssize_t tempStreamPWrite(uint64_t a1, char *buf, size_t nbyte, unint64_t offset)
{
  unsigned int *v4;
  uint64_t v6;
  unint64_t v8;
  char *v10;
  AAByteStream_impl *v12;
  int64_t v13;
  pthread_mutex_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  AAByteStream_impl *v24;
  ssize_t v25;
  int v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  const char *v31;
  __int16 v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  int *v41;
  uint64_t v42;
  uint64_t v43;
  char v45;
  unint64_t v46;

  v4 = (unsigned int *)(a1 + 128);
  if (atomic_load((unsigned int *)(a1 + 128)))
    return -1;
  v8 = offset;
  v10 = buf;
  v12 = *(AAByteStream_impl **)(a1 + 112);
  if (!v12)
  {
    if (((offset | nbyte) & 0x8000000000000000) != 0)
      return -1;
    v13 = offset + nbyte;
    if (__OFADD__(offset, nbyte))
      return -1;
    v14 = (pthread_mutex_t *)(a1 + 40);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
    {
      v27 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", 164, 50, *v27, "mutex lock", v28, v29, v45);
      v6 = -1;
      while (!__ldaxr(v4))
      {
        if (!__stlxr(1u, v4))
          return v6;
      }
LABEL_42:
      __clrex();
      return -1;
    }
    if (v13 <= *(_QWORD *)a1)
      v21 = *(_QWORD *)a1;
    else
      v21 = v8 + nbyte;
    if ((resizeStream(a1, v21, v15, v16, v17, v18, v19, v20) & 0x80000000) != 0)
    {
      v31 = "resizing stream";
      v32 = 170;
    }
    else
    {
      v24 = *(AAByteStream_impl **)(a1 + 112);
      if (!v24)
      {
        v45 = a1 + 40;
        if (v13 <= v8)
        {
          v6 = 0;
        }
        else
        {
          v6 = 0;
          v33 = *(_QWORD *)(a1 + 8);
          v34 = v8 / v33;
          v35 = v8 / v33 * v33;
          v36 = v35 + v33;
          v46 = v13;
          do
          {
            if (v36 >= v13)
              v37 = v46;
            else
              v37 = v36;
            memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v34) + v8 - v35), v10, v37 - v8);
            v10 += v37 - v8;
            v6 += v37 - v8;
            ++v34;
            v38 = *(_QWORD *)(a1 + 8);
            v35 += v38;
            v8 = v37;
            v13 = v46;
            v39 = v46 > v36;
            v36 += v38;
          }
          while (v39);
        }
        v26 = 0;
        v40 = *(_QWORD *)a1;
        if (v13 > *(_QWORD *)a1)
          v40 = v13;
        *(_QWORD *)a1 = v40;
        v14 = (pthread_mutex_t *)(a1 + 40);
        goto LABEL_34;
      }
      v25 = AAByteStreamPWrite(v24, v10, nbyte, v8);
      if ((v25 & 0x8000000000000000) == 0)
      {
        v6 = v25;
        v26 = 0;
LABEL_34:
        if (pthread_mutex_unlock(v14) < 0)
        {
          v41 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", 209, 50, *v41, "mutex unlock", v42, v43, v45);
        }
        else if (!v26)
        {
          return v6;
        }
        v6 = -1;
        while (!__ldaxr(v4))
        {
          if (!__stlxr(1u, v4))
            return v6;
        }
        goto LABEL_42;
      }
      v31 = "temp file write";
      v32 = 176;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamPWrite", v32, 50, 0, v31, v22, v23, v45);
    v6 = 0;
    v26 = 1;
    goto LABEL_34;
  }
  return AAByteStreamPWrite(v12, buf, nbyte, offset);
}

uint64_t tempStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t result;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  char v31;

  v8 = (unsigned int *)(a1 + 128);
  if (atomic_load((unsigned int *)(a1 + 128)))
    return 0xFFFFFFFFLL;
  v13 = *(_QWORD **)(a1 + 112);
  if (v13)
    return AAByteStreamTruncate(v13);
  if (a2 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 271, 50, 0, "invalid length", a7, a8, v31);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    v23 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 272, 50, *v23, "mutex lock", v24, v25, v31);
    result = 0xFFFFFFFFLL;
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
        return result;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  if ((resizeStream(a1, a2, v14, v15, v16, v17, v18, v19) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 274, 50, 0, "resize stream", v20, v21, v31);
    v22 = 0;
  }
  else
  {
    v22 = 1;
  }
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40)) < 0)
  {
    v27 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"tempStreamTruncate", 276, 50, *v27, "mutex lock", v28, v29, v31);
    while (!__ldaxr(v8))
    {
      if (!__stlxr(1u, v8))
      {
        v22 = 0;
        goto LABEL_22;
      }
    }
    v22 = 0;
    __clrex();
  }
LABEL_22:
  if (v22)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t resizeStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  AAByteStream_impl *v29;
  off_t v30;
  off_t v31;
  unint64_t v32;
  void *v33;
  char *v34;
  uint64_t v35;
  rsize_t v36;
  void *v37;
  void *v38;
  const char *v40;
  __int16 v41;
  char v42;

  if (*(_QWORD *)(a1 + 112))
  {
    v8 = "invalid state";
    v9 = 64;
LABEL_3:
    v10 = 0;
LABEL_4:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"resizeStream", v9, 50, v10, v8, a7, a8, v42);
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)a1 >= a2)
    goto LABEL_51;
  v14 = *(_QWORD *)(a1 + 8);
  if (__OFADD__(a2, v14))
  {
    v42 = a2;
    v8 = "new size out of range: %zu";
    v9 = 70;
    goto LABEL_3;
  }
  v15 = (a2 + v14 - 1) / v14;
  if (v15 <= *(_QWORD *)(a1 + 16))
  {
    v32 = *(_QWORD *)(a1 + 24);
    while (v32 < v15)
    {
      if (v32)
        v32 *= 2;
      else
        v32 = 32;
    }
    if (8 * v32 >= 0x2000000001)
    {
      *__error() = 12;
LABEL_55:
      *(_QWORD *)(a1 + 32) = 0;
      v10 = *__error();
      v8 = "malloc";
      v9 = 89;
      goto LABEL_4;
    }
    v33 = *(void **)(a1 + 32);
    v34 = (char *)realloc(v33, 8 * v32);
    if (!v34)
    {
      free(v33);
      goto LABEL_55;
    }
    *(_QWORD *)(a1 + 32) = v34;
    memset_s(&v34[8 * *(_QWORD *)(a1 + 24)], 8 * (v32 - *(_QWORD *)(a1 + 24)), 0, 8 * (v32 - *(_QWORD *)(a1 + 24)));
    *(_QWORD *)(a1 + 24) = v32;
    v35 = v15 - 1;
    while (v35 != -1 && !*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v35))
    {
      v36 = *(_QWORD *)(a1 + 8);
      if (v36 < 0x2000000001)
      {
        v38 = malloc(*(_QWORD *)(a1 + 8));
        v37 = v38;
        if (v38)
          memset_s(v38, v36, 0, v36);
      }
      else
      {
        v37 = 0;
        *__error() = 12;
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v35) = v37;
      if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v35--))
      {
        v10 = *__error();
        v8 = "malloc";
        v9 = 99;
        goto LABEL_4;
      }
    }
LABEL_51:
    result = 0;
    *(_QWORD *)a1 = a2;
    return result;
  }
  v16 = AATempFileStreamOpenWithDirectory(*(const char **)(a1 + 104));
  *(_QWORD *)(a1 + 112) = v16;
  if (!v16)
  {
    v40 = "AATempFileStreamOpen";
    v41 = 36;
LABEL_57:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AATempStream.c", (uint64_t)"offloadToFile", v41, 50, 0, v40, v17, v18, v42);
    v8 = "offload to file";
    v9 = 76;
    goto LABEL_3;
  }
  v19 = (_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 24))
  {
    v20 = 0;
    v21 = 0;
    while (*(_QWORD *)a1 > v21)
    {
      if (*(_QWORD *)(a1 + 8) >= *(_QWORD *)a1 - v21)
        v22 = *(_QWORD *)a1 - v21;
      else
        v22 = *(_QWORD *)(a1 + 8);
      v23 = *(_QWORD *)(a1 + 112);
      if (*(_QWORD *)(v23 + 24))
      {
        v24 = 0;
        if (v22)
        {
          v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v20);
          v26 = v22;
          while (1)
          {
            v27 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v23 + 24))(*(_QWORD *)v23, v25, v26);
            if (v27 < 1)
              break;
            v25 += v27;
            v24 += v27;
            v26 -= v27;
            if (!v26)
              goto LABEL_26;
          }
          v24 = v27;
        }
      }
      else
      {
        v24 = -1;
      }
LABEL_26:
      if (v24 != v22)
      {
        v40 = "writing data to temp file";
        v41 = 43;
        goto LABEL_57;
      }
      v21 += v22;
      if ((unint64_t)++v20 >= *v19)
      {
        if (!*v19)
          goto LABEL_31;
        break;
      }
    }
    v28 = 0;
    do
      free(*(void **)(*(_QWORD *)(a1 + 32) + 8 * v28++));
    while (v28 < *(_QWORD *)(a1 + 24));
  }
LABEL_31:
  free(*(void **)(a1 + 32));
  *v19 = 0;
  *(_QWORD *)(a1 + 32) = 0;
  if ((AAByteStreamTruncate(*(_QWORD **)(a1 + 112)) & 0x80000000) != 0)
  {
    v8 = "truncate temp file";
    v9 = 78;
    goto LABEL_3;
  }
  v29 = *(AAByteStream_impl **)(a1 + 112);
  v30 = atomic_load((unint64_t *)(a1 + 120));
  v31 = AAByteStreamSeek(v29, v30, 0);
  result = 0;
  if (v31 < 0)
  {
    v8 = "seek temp file";
    v9 = 80;
    goto LABEL_3;
  }
  return result;
}

uint64_t yaa_encodeKeyValue_marker(_BYTE *a1, unint64_t a2, char *a3)
{
  if (a2 < 4)
    return -1;
  *a1 = __toupper(*a3);
  a1[1] = __toupper(a3[1]);
  a1[2] = __toupper(a3[2]);
  a1[3] = __toupper(42);
  return 4;
}

uint64_t yaa_encodeKeyValue_uint(_BYTE *a1, unint64_t a2, char *a3, unint64_t a4)
{
  if (a4 <= 0xFF)
  {
    if (a2 >= 5)
    {
      *a1 = __toupper(*a3);
      a1[1] = __toupper(a3[1]);
      a1[2] = __toupper(a3[2]);
      a1[3] = __toupper(49);
      a1[4] = a4;
      return 5;
    }
    return -1;
  }
  if (!(a4 >> 16))
  {
    if (a2 >= 6)
    {
      *a1 = __toupper(*a3);
      a1[1] = __toupper(a3[1]);
      a1[2] = __toupper(a3[2]);
      a1[3] = __toupper(50);
      *((_WORD *)a1 + 2) = a4;
      return 6;
    }
    return -1;
  }
  if (!HIDWORD(a4))
  {
    if (a2 >= 8)
    {
      *a1 = __toupper(*a3);
      a1[1] = __toupper(a3[1]);
      a1[2] = __toupper(a3[2]);
      a1[3] = __toupper(52);
      *((_DWORD *)a1 + 1) = a4;
      return 8;
    }
    return -1;
  }
  if (a2 < 0xC)
    return -1;
  *a1 = __toupper(*a3);
  a1[1] = __toupper(a3[1]);
  a1[2] = __toupper(a3[2]);
  a1[3] = __toupper(56);
  *(_QWORD *)(a1 + 4) = a4;
  return 12;
}

uint64_t yaa_encodeKeyValue_blob(uint64_t a1, unint64_t a2, char *a3, unint64_t a4)
{
  if (!(a4 >> 16))
  {
    if (a2 >= 6)
    {
      *(_BYTE *)a1 = __toupper(*a3);
      *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
      *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
      *(_BYTE *)(a1 + 3) = __toupper(65);
      *(_WORD *)(a1 + 4) = a4;
      return 6;
    }
    return -1;
  }
  if (!HIDWORD(a4))
  {
    if (a2 >= 8)
    {
      *(_BYTE *)a1 = __toupper(*a3);
      *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
      *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
      *(_BYTE *)(a1 + 3) = __toupper(66);
      *(_DWORD *)(a1 + 4) = a4;
      return 8;
    }
    return -1;
  }
  if (a2 < 0xC)
    return -1;
  *(_BYTE *)a1 = __toupper(*a3);
  *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
  *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
  *(_BYTE *)(a1 + 3) = __toupper(67);
  *(_QWORD *)(a1 + 4) = a4;
  return 12;
}

uint64_t yaa_encodeKeyValue_cksum(uint64_t a1, unint64_t a2, char *a3, _DWORD *a4)
{
  if (a2 < 8)
    return -1;
  *(_BYTE *)a1 = __toupper(*a3);
  *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
  *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
  *(_BYTE *)(a1 + 3) = __toupper(70);
  *(_DWORD *)(a1 + 4) = *a4;
  return 8;
}

uint64_t yaa_encodeKeyValue_sha1(uint64_t a1, unint64_t a2, char *a3, uint64_t a4)
{
  int v8;

  if (a2 < 0x18)
    return -1;
  *(_BYTE *)a1 = __toupper(*a3);
  *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
  *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
  *(_BYTE *)(a1 + 3) = __toupper(71);
  v8 = *(_DWORD *)(a4 + 16);
  *(_OWORD *)(a1 + 4) = *(_OWORD *)a4;
  *(_DWORD *)(a1 + 20) = v8;
  return 24;
}

uint64_t yaa_encodeKeyValue_sha256(uint64_t a1, unint64_t a2, char *a3, _OWORD *a4)
{
  __int128 v8;

  if (a2 < 0x24)
    return -1;
  *(_BYTE *)a1 = __toupper(*a3);
  *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
  *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
  *(_BYTE *)(a1 + 3) = __toupper(72);
  v8 = a4[1];
  *(_OWORD *)(a1 + 4) = *a4;
  *(_OWORD *)(a1 + 20) = v8;
  return 36;
}

size_t yaa_encodeKeyValue_path(uint64_t a1, unint64_t a2, char *a3, char *__s)
{
  size_t v8;
  size_t result;

  v8 = strlen(__s);
  result = -1;
  if (!(v8 >> 16) && v8 + 6 <= a2)
  {
    *(_BYTE *)a1 = __toupper(*a3);
    *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
    *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
    *(_BYTE *)(a1 + 3) = __toupper(80);
    *(_WORD *)(a1 + 4) = v8;
    memcpy((void *)(a1 + 6), __s, v8);
    return v8 + 6;
  }
  return result;
}

uint64_t yaa_encodeKeyValue_timespec(uint64_t a1, unint64_t a2, char *a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t v7;

  v6 = *a4;
  v7 = a4[1];
  if ((unint64_t)(v7 - 1000000000) < 0xFFFFFFFFC4653601)
  {
    if (a2 >= 0xC)
    {
      *(_BYTE *)a1 = __toupper(*a3);
      *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
      *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
      *(_BYTE *)(a1 + 3) = __toupper(83);
      *(_QWORD *)(a1 + 4) = v6;
      return 12;
    }
    return -1;
  }
  if (a2 < 0x10)
    return -1;
  *(_BYTE *)a1 = __toupper(*a3);
  *(_BYTE *)(a1 + 1) = __toupper(a3[1]);
  *(_BYTE *)(a1 + 2) = __toupper(a3[2]);
  *(_BYTE *)(a1 + 3) = __toupper(84);
  *(_QWORD *)(a1 + 4) = v6;
  *(_DWORD *)(a1 + 12) = v7;
  return 16;
}

size_t yaa_encodeHeaderField(_BYTE *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t result;
  char vars0;

  switch(*(_DWORD *)(a3 + 4))
  {
    case 1:
      result = yaa_encodeKeyValue_uint(a1, a2, (char *)a3, *(_QWORD *)(a3 + 8));
      break;
    case 2:
      result = yaa_encodeKeyValue_blob((uint64_t)a1, a2, (char *)a3, *(_QWORD *)(a3 + 8));
      break;
    case 3:
      result = yaa_encodeKeyValue_timespec((uint64_t)a1, a2, (char *)a3, (uint64_t *)(a3 + 8));
      break;
    case 4:
      result = yaa_encodeKeyValue_cksum((uint64_t)a1, a2, (char *)a3, (_DWORD *)(a3 + 8));
      break;
    case 5:
      result = yaa_encodeKeyValue_sha1((uint64_t)a1, a2, (char *)a3, a3 + 8);
      break;
    case 6:
      result = yaa_encodeKeyValue_sha256((uint64_t)a1, a2, (char *)a3, (_OWORD *)(a3 + 8));
      break;
    case 7:
      result = yaa_encodeKeyValue_path((uint64_t)a1, a2, (char *)a3, (char *)(a3 + 8));
      break;
    case 8:
      result = yaa_encodeKeyValue_marker(a1, a2, (char *)a3);
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_encodeHeaderField", 190, 10, 0, "invalid valueType in field", a7, a8, vars0);
      result = -1;
      break;
  }
  return result;
}

uint64_t yaa_encodeHeader(uint64_t a1, unint64_t a2, int *a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  const char *v9;
  __int16 v10;
  unsigned int v12;
  BOOL v13;
  int v14;
  unint64_t v16;
  uint64_t v18;
  int v20;
  uint64_t v21;
  int v22;
  size_t v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  size_t v41;
  uint64_t result;
  char v43;

  if (a2 >= 0xFFFF)
    v8 = 0xFFFFLL;
  else
    v8 = a2;
  if ((*(_BYTE *)a3 & 1) == 0)
  {
    v9 = "invalid header, TYP must be set";
    v10 = 204;
LABEL_6:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_encodeHeader", v10, 10, 0, v9, a7, a8, v43);
    return -1;
  }
  v12 = a3[1] - 66;
  v13 = v12 > 0x11;
  v14 = (1 << v12) & 0x24C57;
  if (v13 || v14 == 0)
  {
    v9 = "invalid entryType";
    v10 = 217;
    goto LABEL_6;
  }
  v16 = v8 - 6;
  if (v8 < 6)
    return -1;
  v18 = a4;
  *(_WORD *)(a1 + 4) = 30840;
  *(_DWORD *)a1 = 825246017;
  v20 = *a3;
  if ((*a3 & 1) != 0)
  {
    if (v16 < 5)
      return -1;
    v22 = a3[1];
    *(_BYTE *)(a1 + 6) = __toupper(84);
    *(_BYTE *)(a1 + 7) = __toupper(89);
    *(_BYTE *)(a1 + 8) = __toupper(80);
    *(_BYTE *)(a1 + 9) = __toupper(49);
    *(_BYTE *)(a1 + 10) = v22;
    v21 = a1 + 11;
    v16 = v8 - 11;
    v20 = *a3;
    if ((*a3 & 0x8000) == 0)
    {
LABEL_14:
      if ((v20 & 0x10000) == 0)
        goto LABEL_15;
      goto LABEL_26;
    }
  }
  else
  {
    v21 = a1 + 6;
    if ((v20 & 0x8000) == 0)
      goto LABEL_14;
  }
  v23 = yaa_encodeKeyValue_path(v21, v16, "PAT", (char *)a3 + 144);
  if ((v23 & 0x8000000000000000) != 0)
    return -1;
  v21 += v23;
  v16 -= v23;
  v20 = *a3;
  if ((*a3 & 0x10000) == 0)
  {
LABEL_15:
    if ((v20 & 2) == 0)
      goto LABEL_16;
    goto LABEL_28;
  }
LABEL_26:
  v24 = yaa_encodeKeyValue_path(v21, v16, "LNK", (char *)a3 + 1168);
  if ((v24 & 0x8000000000000000) != 0)
    return -1;
  v21 += v24;
  v16 -= v24;
  v20 = *a3;
  if ((*a3 & 2) == 0)
  {
LABEL_16:
    if ((v20 & 4) == 0)
      goto LABEL_17;
    goto LABEL_30;
  }
LABEL_28:
  v25 = yaa_encodeKeyValue_uint((_BYTE *)v21, v16, "UID", a3[2]);
  if (v25 < 0)
    return -1;
  v21 += v25;
  v16 -= v25;
  v20 = *a3;
  if ((*a3 & 4) == 0)
  {
LABEL_17:
    if ((v20 & 0x10) == 0)
      goto LABEL_18;
    goto LABEL_32;
  }
LABEL_30:
  v26 = yaa_encodeKeyValue_uint((_BYTE *)v21, v16, "GID", a3[3]);
  if (v26 < 0)
    return -1;
  v21 += v26;
  v16 -= v26;
  v20 = *a3;
  if ((*a3 & 0x10) == 0)
  {
LABEL_18:
    if ((v20 & 0x20) == 0)
      goto LABEL_19;
    goto LABEL_35;
  }
LABEL_32:
  v27 = v16 >= 6;
  v16 -= 6;
  if (!v27)
    return -1;
  v28 = a3[5];
  *(_BYTE *)v21 = __toupper(77);
  *(_BYTE *)(v21 + 1) = __toupper(79);
  *(_BYTE *)(v21 + 2) = __toupper(68);
  *(_BYTE *)(v21 + 3) = __toupper(50);
  *(_WORD *)(v21 + 4) = v28;
  v21 += 6;
  v20 = *a3;
  if ((*a3 & 0x20) == 0)
  {
LABEL_19:
    if ((v20 & 0x40) == 0)
      goto LABEL_20;
LABEL_37:
    v30 = yaa_encodeKeyValue_uint((_BYTE *)v21, v16, "INO", *((_QWORD *)a3 + 4));
    if (v30 < 0)
      return -1;
    v21 += v30;
    v16 -= v30;
    v20 = *a3;
    if ((*a3 & 0x80) == 0)
      goto LABEL_41;
    goto LABEL_39;
  }
LABEL_35:
  v29 = yaa_encodeKeyValue_uint((_BYTE *)v21, v16, "DEV", a3[6]);
  if (v29 < 0)
    return -1;
  v21 += v29;
  v16 -= v29;
  v20 = *a3;
  if ((*a3 & 0x40) != 0)
    goto LABEL_37;
LABEL_20:
  if ((v20 & 0x80) != 0)
  {
LABEL_39:
    v31 = yaa_encodeKeyValue_uint((_BYTE *)v21, v16, "SIZ", *((_QWORD *)a3 + 5));
    if (v31 < 0)
      return -1;
    v21 += v31;
    v16 -= v31;
    v20 = *a3;
  }
LABEL_41:
  if ((v20 & 8) != 0)
  {
    v32 = yaa_encodeKeyValue_uint((_BYTE *)v21, v16, "FLG", a3[4]);
    if (v32 < 0)
      return -1;
    v21 += v32;
    v16 -= v32;
    v20 = *a3;
  }
  if ((v20 & 0x100) != 0)
  {
    v33 = yaa_encodeKeyValue_timespec(v21, v16, "MTM", (uint64_t *)a3 + 6);
    if (v33 < 0)
      return -1;
    v21 += v33;
    v16 -= v33;
    v20 = *a3;
  }
  if ((v20 & 0x1000) != 0)
  {
    v34 = yaa_encodeKeyValue_cksum(v21, v16, "CKS", a3 + 22);
    if (v34 < 0)
      return -1;
    v21 += v34;
    v16 -= v34;
    v20 = *a3;
  }
  if ((v20 & 0x2000) != 0)
  {
    v35 = yaa_encodeKeyValue_sha1(v21, v16, "SH1", (uint64_t)(a3 + 23));
    if (v35 < 0)
      return -1;
    v21 += v35;
    v16 -= v35;
    v20 = *a3;
  }
  if ((v20 & 0x4000) != 0)
  {
    v36 = yaa_encodeKeyValue_sha256(v21, v16, "SH2", (_OWORD *)a3 + 7);
    if (v36 < 0)
      return -1;
    v21 += v36;
    v16 -= v36;
    v20 = *a3;
  }
  if ((v20 & 0x200) != 0)
  {
    v37 = yaa_encodeKeyValue_blob(v21, v16, "DAT", *((_QWORD *)a3 + 8));
    if (v37 < 0)
      return -1;
    v21 += v37;
    v16 -= v37;
    v20 = *a3;
  }
  if ((v20 & 0x400) != 0)
  {
    v38 = yaa_encodeKeyValue_blob(v21, v16, "XAT", *((_QWORD *)a3 + 9));
    if (v38 < 0)
      return -1;
    v21 += v38;
    v16 -= v38;
    v20 = *a3;
  }
  if ((v20 & 0x800) != 0)
  {
    v39 = yaa_encodeKeyValue_blob(v21, v16, "ACL", *((_QWORD *)a3 + 10));
    if (v39 < 0)
      return -1;
    v21 += v39;
    v16 -= v39;
  }
  if (!v18 || !a5)
  {
LABEL_70:
    result = v21 - a1;
    *(_WORD *)(a1 + 4) = v21 - a1;
    return result;
  }
  v40 = 0;
  while (1)
  {
    v41 = yaa_encodeHeaderField((_BYTE *)v21, v16, v18, a4, a5, a6, a7, a8);
    if ((v41 & 0x8000000000000000) != 0)
      return -1;
    v21 += v41;
    v16 -= v41;
    ++v40;
    v18 += 1032;
    if (v40 >= a5)
      goto LABEL_70;
  }
}

uint64_t yaa_encodeACE(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v10;
  size_t v13;
  size_t v14;
  uint64_t result;
  const char *v16;
  __int16 v17;
  char v18;

  v8 = *(_DWORD *)a3 - 1;
  if (v8 >= 4)
  {
    v16 = "invalid ACE type";
    v17 = 281;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_encodeACE", v17, 10, 0, v16, a7, a8, v18);
    return -1;
  }
  v10 = *(_DWORD *)(a3 + 24) - 1;
  if (v10 >= 4)
  {
    v16 = "invalid ACE qualifier type";
    v17 = 298;
    goto LABEL_8;
  }
  v13 = strlen((const char *)(a3 + 28));
  v14 = v13 + 22;
  result = -1;
  if (v13 + 22 <= a2 && !HIDWORD(v14))
  {
    *(_DWORD *)a1 = v14;
    *(_BYTE *)(a1 + 4) = 0x4C554441u >> (8 * v8);
    *(_QWORD *)(a1 + 5) = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a1 + 13) = *(_QWORD *)(a3 + 8);
    *(_BYTE *)(a1 + 21) = 0x69736775u >> (8 * v10);
    memcpy((void *)(a1 + 22), (const void *)(a3 + 28), v13);
    return v14;
  }
  return result;
}

uint64_t yaa_decodeHeaderField(uint64_t a1, uint64_t a2, unint64_t a3)
{
  size_t v6;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  int v15;
  __int128 v16;
  __int128 v17;
  size_t v18;
  char v19;

  bzero((void *)a1, 0x408uLL);
  if (a3 < 4)
    return -1;
  for (i = 0; i != 3; ++i)
    *(_BYTE *)(a1 + i) = __toupper(*(unsigned __int8 *)(a2 + i));
  switch(*(_BYTE *)(a2 + 3))
  {
    case 'A':
      if (a3 < 6)
        return -1;
      v11 = 2;
LABEL_35:
      *(_DWORD *)(a1 + 4) = v11;
      *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 4);
      return 6;
    case 'B':
      if (a3 < 8)
        return -1;
      v14 = 2;
      goto LABEL_38;
    case 'C':
      if (a3 < 0xC)
        return -1;
      v15 = 2;
LABEL_41:
      *(_DWORD *)(a1 + 4) = v15;
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 4);
      return 12;
    case 'D':
    case 'E':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'Q':
    case 'R':
LABEL_14:
      v12 = "invalid fields storage type";
      v13 = 404;
      goto LABEL_15;
    case 'F':
      if (a3 < 8)
        return -1;
      v14 = 4;
LABEL_38:
      *(_DWORD *)(a1 + 4) = v14;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 4);
      return 8;
    case 'G':
      if (a3 < 0x18)
        return -1;
      *(_DWORD *)(a1 + 4) = 5;
      v16 = *(_OWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 20);
      *(_OWORD *)(a1 + 8) = v16;
      return 24;
    case 'H':
      if (a3 < 0x24)
        return -1;
      *(_DWORD *)(a1 + 4) = 6;
      v17 = *(_OWORD *)(a2 + 4);
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 20);
      *(_OWORD *)(a1 + 8) = v17;
      return 36;
    case 'P':
      if (a3 < 6)
        return -1;
      v18 = *(unsigned __int16 *)(a2 + 4);
      if (v18 >= 0x3FF)
      {
        v12 = "path too long in header";
        v13 = 396;
LABEL_15:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeaderField", v13, 10, 0, v12, v9, v10, v19);
        return -1;
      }
      v6 = v18 + 6;
      if (v18 + 6 > a3)
        return -1;
      *(_DWORD *)(a1 + 4) = 7;
      memcpy((void *)(a1 + 8), (const void *)(a2 + 6), v18);
      break;
    case 'S':
      if (a3 < 0xC)
        return -1;
      *(_DWORD *)(a1 + 4) = 3;
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 4);
      *(_QWORD *)(a1 + 16) = 0;
      return 12;
    case 'T':
      if (a3 < 0x10)
        return -1;
      *(_DWORD *)(a1 + 4) = 3;
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 12);
      return 16;
    default:
      switch(*(_BYTE *)(a2 + 3))
      {
        case '1':
          if (a3 < 5)
            return -1;
          *(_DWORD *)(a1 + 4) = 1;
          *(_BYTE *)(a1 + 8) = *(_BYTE *)(a2 + 4);
          return 5;
        case '2':
          if (a3 < 6)
            return -1;
          v11 = 1;
          goto LABEL_35;
        case '3':
        case '5':
        case '6':
        case '7':
          goto LABEL_14;
        case '4':
          if (a3 < 8)
            return -1;
          v14 = 1;
          goto LABEL_38;
        case '8':
          if (a3 < 0xC)
            return -1;
          v15 = 1;
          goto LABEL_41;
        default:
          if (*(_BYTE *)(a2 + 3) != 42)
            goto LABEL_14;
          *(_DWORD *)(a1 + 4) = 8;
          return 4;
      }
  }
  return v6;
}

uint64_t yaa_decodeHeader(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  unint64_t v12;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  __int128 v22;
  int v23;
  unint64_t v24;
  const char *v25;
  __int16 v26;
  _OWORD *v27;
  unint64_t v28;
  _OWORD __src[65];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  bzero(a1, 0x890uLL);
  if (a3 < 6 || *(_DWORD *)a2 != 826360153 && *(_DWORD *)a2 != 825246017)
    return -1;
  v12 = *(unsigned __int16 *)(a2 + 4);
  if (v12 < 6 || v12 > a3)
    return -1;
  v15 = a2 + 6;
  v16 = v12 - 6;
  if (v12 != 6)
  {
    v28 = 0;
    memset(__src, 0, 512);
    while (1)
    {
      v17 = yaa_decodeHeaderField((uint64_t)__src, v15, v16);
      if (v17 < 0)
        return -1;
      v20 = v17;
      v21 = __src[0] & 0xDFDFDF;
      if ((__src[0] & 0xDFDFDF) <= 0x4D544C)
      {
        if ((__src[0] & 0xDFDFDF) > 0x444F4C)
        {
          if ((__src[0] & 0xDFDFDF) > 0x4B4E4B)
          {
            if (v21 == 4935244)
            {
              if (DWORD1(__src[0]) != 7)
              {
                v27 = __src;
                v25 = "invalid type for default field %s";
                v26 = 459;
LABEL_100:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", v26, 10, 0, v25, v18, v19, (char)v27);
                return -1;
              }
              *a1 |= 0x10000u;
              strlcpy((char *)a1 + 1168, (const char *)__src + 8, 0x400uLL);
            }
            else
            {
              if (v21 != 4997953)
              {
LABEL_73:
                v24 = v28;
                if (a4 && v28 < a5)
                {
                  memcpy((void *)(a4 + 1032 * v28), __src, 0x408uLL);
                  v24 = v28;
                }
                v28 = v24 + 1;
                goto LABEL_77;
              }
              if (DWORD1(__src[0]) != 2)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 473, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
                return -1;
              }
              *a1 |= 0x800u;
              *((_QWORD *)a1 + 10) = *((_QWORD *)&__src[0] + 1);
            }
          }
          else if (v21 == 4476749)
          {
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 463, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x10u;
            a1[5] = DWORD2(__src[0]);
          }
          else
          {
            if (v21 != 4672582)
              goto LABEL_73;
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 462, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 8u;
            a1[4] = DWORD2(__src[0]);
          }
        }
        else if ((__src[0] & 0xDFDFDF) > 0x444946)
        {
          if (v21 == 4475207)
          {
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 461, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 4u;
            a1[3] = DWORD2(__src[0]);
          }
          else
          {
            if (v21 != 4475221)
              goto LABEL_73;
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 460, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 2u;
            a1[2] = DWORD2(__src[0]);
          }
        }
        else if (v21 == 1132627)
        {
          if (DWORD1(__src[0]) != 5)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 469, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x2000u;
          *(_OWORD *)(a1 + 23) = *(_OWORD *)((char *)__src + 8);
          a1[27] = DWORD2(__src[1]);
        }
        else
        {
          if (v21 != 1198163)
            goto LABEL_73;
          if (DWORD1(__src[0]) != 6)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 470, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x4000u;
          v22 = *(_OWORD *)((char *)&__src[1] + 8);
          *((_OWORD *)a1 + 7) = *(_OWORD *)((char *)__src + 8);
          *((_OWORD *)a1 + 8) = v22;
        }
      }
      else if ((__src[0] & 0xDFDFDF) <= 0x544143)
      {
        if ((__src[0] & 0xDFDFDF) > 0x505953)
        {
          if (v21 == 5265748)
          {
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 440, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            v23 = DWORD2(__src[0]);
            if ((unint64_t)(*((_QWORD *)&__src[0] + 1) - 66) > 0x11
              || ((1 << (BYTE8(__src[0]) - 66)) & 0x24C57) == 0)
            {
              v25 = "invalid entryType";
              v26 = 455;
              goto LABEL_100;
            }
            *a1 |= 1u;
            a1[1] = v23;
          }
          else
          {
            if (v21 != 5458755)
              goto LABEL_73;
            if (DWORD1(__src[0]) != 4)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 468, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x1000u;
            a1[22] = DWORD2(__src[0]);
          }
        }
        else if (v21 == 5067853)
        {
          if (DWORD1(__src[0]) != 3)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 467, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x100u;
          *((_OWORD *)a1 + 3) = *(_OWORD *)((char *)__src + 8);
        }
        else
        {
          if (v21 != 5197385)
            goto LABEL_73;
          if (DWORD1(__src[0]) != 1)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 465, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x40u;
          *((_QWORD *)a1 + 4) = *((_QWORD *)&__src[0] + 1);
        }
      }
      else if ((__src[0] & 0xDFDFDF) <= 0x544157)
      {
        if (v21 == 5521732)
        {
          if (DWORD1(__src[0]) != 2)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 471, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x200u;
          *((_QWORD *)a1 + 8) = *((_QWORD *)&__src[0] + 1);
        }
        else
        {
          if (v21 != 5521744)
            goto LABEL_73;
          if (DWORD1(__src[0]) != 7)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 458, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
            return -1;
          }
          *a1 |= 0x8000u;
          __strlcpy_chk();
        }
      }
      else
      {
        switch(v21)
        {
          case 5521752:
            if (DWORD1(__src[0]) != 2)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 472, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x400u;
            *((_QWORD *)a1 + 9) = *((_QWORD *)&__src[0] + 1);
            break;
          case 5653828:
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 464, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x20u;
            a1[6] = DWORD2(__src[0]);
            break;
          case 5917011:
            if (DWORD1(__src[0]) != 1)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeader", 466, 10, 0, "invalid type for default field %s", v18, v19, (char)__src);
              return -1;
            }
            *a1 |= 0x80u;
            *((_QWORD *)a1 + 5) = *((_QWORD *)&__src[0] + 1);
            break;
          default:
            goto LABEL_73;
        }
      }
LABEL_77:
      v15 += v20;
      v16 -= v20;
      if (!v16)
        goto LABEL_80;
    }
  }
  v28 = 0;
LABEL_80:
  if (a6)
    *a6 = v28;
  return v15 - a2;
}

unint64_t yaa_decodeHeaderInfo(uint64_t a1, unint64_t a2, _QWORD *a3, _QWORD *a4)
{
  unint64_t result;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;

  if (a2 < 6)
    return -1;
  if (*(_DWORD *)a1 != 826360153 && *(_DWORD *)a1 != 825246017)
    return -1;
  result = *(unsigned __int16 *)(a1 + 4);
  if (result < 6 || result > a2)
    return -1;
  v7 = result - 6;
  if (result != 6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (int *)(a1 + 6);
    while (1)
    {
      if (v7 < 4)
        return -1;
      v11 = *((unsigned __int8 *)v10 + 3);
      v19 = *v10;
      switch(*((_BYTE *)v10 + 3))
      {
        case 'A':
          if (v7 < 6)
            return -1;
          v12 = *((unsigned __int16 *)v10 + 2);
          v13 = __CFADD__(v8, v12);
          v8 += v12;
          if (v13)
            return -1;
LABEL_20:
          v14 = 6;
          break;
        case 'B':
          if (v7 < 8)
            return -1;
          v15 = v10[1];
          v13 = __CFADD__(v8, v15);
          v8 += v15;
          if (v13)
            return -1;
          goto LABEL_25;
        case 'C':
          if (v7 < 0xC)
            return -1;
          v16 = *(_QWORD *)(v10 + 1);
          v13 = __CFADD__(v8, v16);
          v8 += v16;
          if (v13)
            return -1;
          goto LABEL_28;
        case 'D':
        case 'E':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'Q':
        case 'R':
LABEL_62:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeHeaderInfo", 558, 10, 0, "invalid storage type in YAA header: 0x%02x, key=%s", 4935243, 4476749, v11);
          return -1;
        case 'F':
LABEL_25:
          v14 = 8;
          break;
        case 'G':
          v14 = 24;
          break;
        case 'H':
          v14 = 36;
          break;
        case 'P':
          if (v7 < 6)
            return -1;
          v14 = *((unsigned __int16 *)v10 + 2) + 6;
          break;
        case 'S':
LABEL_28:
          v14 = 12;
          break;
        case 'T':
          v14 = 16;
          break;
        default:
          v14 = 5;
          switch(*((_BYTE *)v10 + 3))
          {
            case '1':
              goto LABEL_34;
            case '2':
              goto LABEL_20;
            case '3':
            case '5':
            case '6':
            case '7':
              goto LABEL_62;
            case '4':
              goto LABEL_25;
            case '8':
              goto LABEL_28;
            default:
              if (v11 != 42)
                goto LABEL_62;
              v14 = 4;
              break;
          }
          break;
      }
LABEL_34:
      if (v7 < v14)
        return -1;
      v17 = v19 & 0xDFDFDF;
      if ((v19 & 0xDFDFDFu) > 0x4F4E48)
      {
        if ((v19 & 0xDFDFDFu) > 0x544143)
        {
          if ((v17 - 5521732) <= 0x14 && ((1 << (v17 - 68)) & 0x101001) != 0 || v17 == 5653828)
            goto LABEL_56;
          v18 = 5917011;
          goto LABEL_55;
        }
        if (v17 != 5197385 && v17 != 5265748)
        {
          v18 = 5458755;
          goto LABEL_55;
        }
      }
      else if ((v19 & 0xDFDFDFu) > 0x444F4C)
      {
        if ((v19 & 0xDFDFDFu) > 0x4B4E4B)
        {
          if (v17 != 4935244)
          {
            v18 = 5067853;
LABEL_55:
            if (v17 != v18 && v17 != 4997953)
              ++v9;
          }
        }
        else if (v17 != 4476749)
        {
          v18 = 4672582;
          goto LABEL_55;
        }
      }
      else if ((v19 & 0xDFDFDFu) > 0x444946)
      {
        if (v17 != 4475207)
        {
          v18 = 4475221;
          goto LABEL_55;
        }
      }
      else if (v17 != 1132627)
      {
        v18 = 1198163;
        goto LABEL_55;
      }
LABEL_56:
      v10 = (int *)((char *)v10 + v14);
      v7 -= v14;
      if (!v7)
        goto LABEL_61;
    }
  }
  v9 = 0;
  v8 = 0;
LABEL_61:
  *a3 = v9;
  *a4 = v8;
  return result;
}

uint64_t yaa_decodeACE(unsigned int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  unint64_t v10;
  __darwin_ct_rune_t v12;
  __darwin_ct_rune_t v14;
  __darwin_ct_rune_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  char v23;

  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if (a2 <= 3)
  {
    v8 = "invalid ACL blob";
    v9 = 610;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACE", v9, 10, 0, v8, a7, a8, v23);
    return -1;
  }
  v10 = *a1;
  if (v10 > a2)
  {
    v8 = "invalid ACL blob";
    v9 = 612;
    goto LABEL_7;
  }
  v12 = *((char *)a1 + 4);
  *(_QWORD *)(a3 + 16) = *(_QWORD *)((char *)a1 + 5);
  *(_QWORD *)(a3 + 8) = *(_QWORD *)((char *)a1 + 13);
  if (v10 - 22 >= 0x101)
  {
    v8 = "unsupported qualifier length";
    v9 = 622;
    goto LABEL_7;
  }
  v14 = *((char *)a1 + 21);
  memcpy((void *)(a3 + 28), (char *)a1 + 22, v10 - 22);
  v15 = __toupper(v12);
  if (v15 > 75)
  {
    if (v15 == 76)
    {
      v18 = 4;
      goto LABEL_19;
    }
    if (v15 == 85)
    {
      v18 = 3;
      goto LABEL_19;
    }
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACE", 632, 10, 0, "invalid ACE type in ACL blob: %c", v16, v17, v12);
    return -1;
  }
  if (v15 == 65)
  {
    v18 = 1;
    goto LABEL_19;
  }
  if (v15 != 68)
    goto LABEL_21;
  v18 = 2;
LABEL_19:
  *(_DWORD *)a3 = v18;
  HIDWORD(v21) = __toupper(v14) - 71;
  LODWORD(v21) = HIDWORD(v21);
  switch((v21 >> 1))
  {
    case 0u:
      v22 = 2;
      break;
    case 1u:
      v22 = 4;
      break;
    case 6u:
      v22 = 3;
      break;
    case 7u:
      v22 = 1;
      break;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACE", 642, 10, 0, "invalid ACE qualifier type in ACL blob: %c", v19, v20, v14);
      return -1;
  }
  *(_DWORD *)(a3 + 24) = v22;
  return v10;
}

unint64_t yaa_decodeACL(uint64_t a1, unint64_t *a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  void *v11;
  unsigned int *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int v19;
  char v21;

  v10 = *a2;
  v11 = *a3;
  if (a4)
  {
    v12 = (unsigned int *)a5;
    v13 = a4;
    v14 = 0;
    v15 = 0;
    while (1)
    {
      if (v15 >= v10)
      {
        if (v10)
          v10 += v10 >> 1;
        else
          v10 = 8;
        v11 = reallocf(v11, 288 * v10);
        if (!v11)
          break;
      }
      v16 = yaa_decodeACE(v12, v13, (uint64_t)v11 + v14, a4, a5, a6, a7, a8);
      if (v16 < 0)
      {
        v17 = "decoding ACE";
        v18 = 670;
        v19 = 0;
        goto LABEL_14;
      }
      ++v15;
      v12 = (unsigned int *)((char *)v12 + v16);
      v14 += 288;
      v13 -= v16;
      if (!v13)
        goto LABEL_15;
    }
    v19 = *__error();
    v17 = "malloc";
    v18 = 665;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_decodeACL", v18, 10, v19, v17, a7, a8, v21);
    v15 = -1;
  }
  else
  {
    v15 = 0;
  }
LABEL_15:
  *a2 = v10;
  *a3 = v11;
  return v15;
}

uint64_t yaa_setEntryAttributes(char *a1, int *a2, uint64_t a3, int a4)
{
  int v8;
  unsigned int v9;
  int v10;
  __int128 v11;
  _OWORD *v12;
  uid_t v13;
  gid_t v14;
  int v15;
  uint64_t FileAPFSInternalFlags;
  int *v17;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int *v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  __uint32_t v47;
  int *v48;
  int *v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int *v56;
  int *v57;
  uint64_t v58;
  uint64_t v59;
  int *v60;
  int *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  __uint32_t v65;
  int *v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  stat v70;
  _QWORD v71[3];
  _OWORD v72[8];
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  v71[1] = 0;
  v71[2] = 0;
  v71[0] = 5;
  memset(v72, 0, sizeof(v72));
  if (a3 && (*(_WORD *)a3 & 1) != 0)
  {
    v72[0] = *(_OWORD *)(a3 + 8);
    v8 = 512;
    HIDWORD(v71[0]) = 512;
    v9 = 16;
  }
  else
  {
    v8 = 0;
    v9 = 0;
  }
  v10 = *a2;
  if ((*a2 & 0x100) != 0)
  {
    v11 = *((_OWORD *)a2 + 3);
    v12 = (_OWORD *)((char *)v72 + v9);
    *v12 = v11;
    v12[1] = v11;
    v9 |= 0x20u;
    v8 |= 0x1400u;
    HIDWORD(v71[0]) = v8;
  }
  if (a3 && (*(_WORD *)a3 & 2) != 0)
  {
    *(_OWORD *)((char *)v72 + v9) = *(_OWORD *)(a3 + 24);
    v9 += 16;
    HIDWORD(v71[0]) = v8 | 0x2000;
  }
  if ((v10 & 2) != 0)
  {
    v13 = a2[2];
    if ((v10 & 4) != 0)
      goto LABEL_12;
  }
  else
  {
    v13 = -1;
    if ((v10 & 4) != 0)
    {
LABEL_12:
      v14 = a2[3];
      goto LABEL_15;
    }
  }
  v14 = -1;
LABEL_15:
  memset(&v70, 0, sizeof(v70));
  if (lstat(a1, &v70) < 0)
  {
    v17 = __error();
    if (a4 && *v17 == 13)
      return 0;
    v24 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 751, 10, v24, "%s", v25, v26, (char)a1);
    return 0xFFFFFFFFLL;
  }
  v15 = v70.st_mode & 0xF000;
  if (v15 == 0x8000 || v15 == 0x4000)
    FileAPFSInternalFlags = getFileAPFSInternalFlags();
  else
    FileAPFSInternalFlags = 0;
  v19 = a2[1] - 68;
  if (v19 > 8 || ((1 << v19) & 0x115) == 0)
  {
    if ((*a2 & 2) != 0 && v13 != v70.st_uid || (v22 = 1, (*a2 & 4) != 0) && v14 != v70.st_gid)
    {
      if (!lchown(a1, v13, v14) || (v30 = __error(), a4) && *v30 == 1)
      {
        v22 = 1;
      }
      else
      {
        v52 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 814, 10, *v52, "%s", v53, v54, (char)a1);
        v22 = 0;
      }
    }
    if ((*(_BYTE *)a2 & 0x10) != 0)
    {
      v55 = a2[5] & 0xFFF;
      if (v55 != (v70.st_mode & 0xFFF))
      {
        if (lchmod(a1, v55))
        {
          v56 = __error();
          if (!a4 || *v56 != 1)
          {
            v57 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 819, 10, *v57, "%s", v58, v59, (char)a1);
            v22 = 0;
          }
        }
      }
    }
    if (HIDWORD(v71[0]))
    {
      if (setattrlist(a1, v71, v72, v9, 1u))
      {
        v60 = __error();
        if (!a4 || *v60 != 1)
        {
          v61 = __error();
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 835, 10, "setattrlist error %d: %s", v62, v63, v64, *v61);
        }
      }
    }
    if ((*(_BYTE *)a2 & 8) != 0)
    {
      v65 = a2[4] & 0xFFFFFFDF | (32 * ((v70.st_flags >> 5) & 1));
      if (v70.st_flags != v65)
      {
        if (lchflags(a1, v65))
        {
          v66 = __error();
          if (!a4 || *v66 != 1)
          {
            v67 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 849, 10, *v67, "%s", v68, v69, (char)a1);
            v22 = 0;
          }
        }
      }
    }
    goto LABEL_69;
  }
  v20 = open(a1, 0x200000);
  if ((v20 & 0x80000000) != 0)
  {
    v27 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 770, 10, v27, "%s", v28, v29, (char)a1);
    return 0xFFFFFFFFLL;
  }
  v21 = v20;
  if ((*a2 & 2) != 0 && v13 != v70.st_uid || (v22 = 1, (*a2 & 4) != 0) && v14 != v70.st_gid)
  {
    if (!fchown(v20, v13, v14) || (v23 = __error(), a4) && *v23 == 1)
    {
      v22 = 1;
    }
    else
    {
      v31 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 774, 10, *v31, "%s", v32, v33, (char)a1);
      v22 = 0;
    }
  }
  if ((*(_BYTE *)a2 & 0x10) != 0)
  {
    v34 = a2[5] & 0xFFF;
    if (v34 != (v70.st_mode & 0xFFF))
    {
      if (fchmod(v21, v34))
      {
        v35 = __error();
        if (!a4 || *v35 != 1)
        {
          v36 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 778, 10, *v36, "%s", v37, v38, (char)a1);
          v22 = 0;
        }
      }
    }
  }
  if (HIDWORD(v71[0]))
  {
    if (fsetattrlist(v21, v71, v72, v9, 1u))
    {
      v39 = __error();
      if (!a4 || *v39 != 1)
      {
        v40 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 783, 10, *v40, "%s", v41, v42, (char)a1);
        v22 = 0;
      }
    }
  }
  if (a3)
  {
    if ((*(_WORD *)a3 & 0x100) != 0)
    {
      v43 = *(_QWORD *)(a3 + 80);
      if (FileAPFSInternalFlags != v43 && (setFileAPFSInternalFlagsFD(v21, v43) & 0x80000000) != 0)
      {
        v44 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 794, 10, *v44, "%s", v45, v46, (char)a1);
        v22 = 0;
      }
    }
  }
  if ((*(_BYTE *)a2 & 8) != 0)
  {
    v47 = a2[4] & 0xFFFFFFDF | (32 * ((v70.st_flags >> 5) & 1));
    if (v70.st_flags != v47)
    {
      if (fchflags(v21, v47))
      {
        v48 = __error();
        if (!a4 || *v48 != 1)
        {
          v49 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryAttributes", 803, 10, *v49, "%s", v50, v51, (char)a1);
          v22 = 0;
        }
      }
    }
  }
  close(v21);
LABEL_69:
  if (v22)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t yaa_setEntryXAT(char *path, uint64_t a2, int a3, unint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  int v13;
  unint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  const void *v19;
  int *v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  char v26;

  if ((*(_BYTE *)(a2 + 1) & 4) == 0)
    return 0;
  v9 = a4;
  if (*(_QWORD *)(a2 + 72) != a4)
  {
    v24 = "XAT blob size mismatch";
    v25 = 863;
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryXAT", v25, 10, 0, v24, a7, a8, v26);
    return 0xFFFFFFFFLL;
  }
  if (a4)
  {
    v13 = 1;
    while (1)
    {
      v14 = *a5;
      if (v9 < v14)
      {
        v24 = "invalid XAT entry size";
        v25 = 871;
        goto LABEL_32;
      }
      if (v14 < 5)
        break;
      v15 = a5;
      v16 = 0;
      a5 = (unsigned int *)((char *)a5 + v14);
      v17 = (const char *)(v15 + 1);
      while (v17[v16])
      {
        v18 = &v17[++v16];
        if (&v17[v16] >= (const char *)a5)
          goto LABEL_13;
      }
      v18 = &v17[v16];
LABEL_13:
      if (!v16 || v18 == (const char *)a5)
        goto LABEL_31;
      if (a5 == (unsigned int *)(v18 + 1))
        v19 = 0;
      else
        v19 = v18 + 1;
      if (setxattr(path, v17, v19, (char *)a5 - (v18 + 1), 0, 1) < 0)
      {
        v20 = __error();
        if (!a3 || *v20 != 1)
        {
          v21 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryXAT", 891, 10, *v21, "setxattr: %s", v22, v23, (char)path);
          v13 = 0;
        }
      }
      v9 -= v14;
      if (!v9)
        goto LABEL_26;
    }
    LOBYTE(v16) = 0;
LABEL_31:
    v26 = v16;
    v24 = "invalid XAT entry key %zu";
    v25 = 878;
    goto LABEL_32;
  }
  v13 = 1;
LABEL_26:
  if (v13)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t yaa_setEntryACL(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  acl_tag_t v19;
  int v20;
  _BOOL4 v21;
  int v22;
  int v23;
  uint64_t v24;
  int v26;
  const char *v27;
  __int16 v28;
  uint64_t v29;
  passwd *v30;
  passwd v31;
  acl_flagset_t flagset_p;
  acl_entry_t entry_p;
  acl_t acl_p;
  stat v35;
  uuid_t uu;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a2 + 1) & 8) == 0)
    return 0;
  memset(&v35, 0, sizeof(v35));
  if (!lstat(a1, &v35) && (v35.st_mode & 0xF000) == 0xA000)
    return 0;
  if (!a4)
    return 0;
  v8 = 0;
  v9 = (_DWORD *)a5;
  v10 = a4;
  do
  {
    if ((*v9 - 1) < 2)
      ++v8;
    v9 += 72;
    --v10;
  }
  while (v10);
  if (!v8)
    return 0;
  acl_p = 0;
  v11 = sysconf(71);
  v12 = sysconf(70);
  if (v11 <= v12)
    v13 = v12;
  else
    v13 = v11;
  if (v13 <= 4096)
    v14 = 4096;
  else
    v14 = v13;
  v15 = (char *)malloc(v14);
  if (!v15)
  {
    v26 = *__error();
    v27 = "malloc";
    v28 = 943;
    goto LABEL_50;
  }
  acl_p = acl_init(v8);
  if (!acl_p)
  {
    v26 = *__error();
    v27 = "acl_init";
    v28 = 946;
    goto LABEL_50;
  }
  v18 = (const char *)(a5 + 28);
  while (1)
  {
    flagset_p = 0;
    entry_p = 0;
    memset(uu, 0, sizeof(uu));
    v19 = *((_DWORD *)v18 - 7);
    if (v19 - 1 <= 1)
      break;
LABEL_42:
    v18 += 288;
    if (!--a4)
    {
      if (acl_set_file(a1, ACL_TYPE_EXTENDED, acl_p))
      {
        v26 = *__error();
        LOBYTE(v29) = (_BYTE)a1;
        v27 = "acl_set_file: %s";
        v28 = 1022;
        goto LABEL_50;
      }
      v24 = 0;
      goto LABEL_51;
    }
  }
  if ((*(_QWORD *)(v18 - 12) & 0xFFFFFFFFFFFDFE0FLL) != 0)
  {
    v29 = *(_QWORD *)(v18 - 12);
    v27 = "invalid ACE flags: 0x%016llx";
    v28 = 973;
    goto LABEL_65;
  }
  if ((*(_QWORD *)(v18 - 20) & 0xFFFFFFFFFFEFC001) != 0)
  {
    v29 = *(_QWORD *)(v18 - 20);
    v27 = "invalid ACE perms: 0x%016llx";
    v28 = 974;
    goto LABEL_65;
  }
  switch(*((_DWORD *)v18 - 1))
  {
    case 1:
      memset(&v31, 0, sizeof(v31));
      v30 = 0;
      v20 = getpwnam_r(v18, &v31, v15, v14, &v30);
      v21 = 0;
      if (v20 || !v30)
        goto LABEL_35;
      v22 = mbr_uid_to_uuid(v31.pw_uid, uu);
      goto LABEL_34;
    case 2:
      memset(&v31, 0, 32);
      v30 = 0;
      v23 = getgrnam_r(v18, (group *)&v31, v15, v14, (group **)&v30);
      v21 = 0;
      if (v23 || !v30)
        goto LABEL_35;
      v22 = mbr_gid_to_uuid(v31.pw_uid, uu);
      goto LABEL_34;
    case 3:
      memset(&v31, 0, sizeof(v31));
      if (mbr_string_to_sid(v18, (nt_sid_t *)&v31))
      {
        v21 = 0;
      }
      else
      {
        v22 = mbr_sid_to_uuid((const nt_sid_t *)&v31, uu);
LABEL_34:
        v21 = v22 == 0;
      }
LABEL_35:
      if (v21)
      {
LABEL_36:
        if (acl_create_entry(&acl_p, &entry_p))
        {
          v26 = *__error();
          v27 = "acl_create_entry";
          v28 = 1013;
          goto LABEL_50;
        }
        if (acl_set_tag_type(entry_p, v19))
        {
          v26 = *__error();
          v27 = "acl_set_tag_type";
          v28 = 1014;
          goto LABEL_50;
        }
        if (acl_set_permset_mask_np(entry_p, *(_QWORD *)(v18 - 20)))
        {
          v26 = *__error();
          v27 = "acl_set_permset_mask_np";
          v28 = 1015;
          goto LABEL_50;
        }
        if (acl_get_flagset_np(entry_p, &flagset_p))
        {
          v26 = *__error();
          v27 = "acl_get_flagset_np";
          v28 = 1016;
          goto LABEL_50;
        }
        if (acl_add_flag_np(flagset_p, *((acl_flag_t *)v18 - 3)))
        {
          v26 = *__error();
          v27 = "acl_add_flag_np";
          v28 = 1017;
          goto LABEL_50;
        }
        if (acl_set_qualifier(entry_p, uu))
        {
          v26 = *__error();
          v27 = "acl_set_qualifier";
          v28 = 1018;
          goto LABEL_50;
        }
        goto LABEL_42;
      }
LABEL_57:
      LODWORD(v29) = *((_DWORD *)v18 - 1);
      v27 = "could not resolve qualifier (type %d): %s";
      v28 = 1010;
LABEL_65:
      v26 = 0;
LABEL_50:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/YAACommon.c", (uint64_t)"yaa_setEntryACL", v28, 10, v26, v27, v16, v17, v29);
      v24 = 0xFFFFFFFFLL;
LABEL_51:
      if (acl_p)
        acl_free(acl_p);
      free(v15);
      return v24;
    case 4:
      if (uuid_parse(v18, uu))
        goto LABEL_57;
      goto LABEL_36;
    default:
      LODWORD(v29) = *((_DWORD *)v18 - 1);
      v27 = "invalid qualifier type: %d";
      v28 = 1007;
      goto LABEL_65;
  }
}

uint64_t ParallelArchiveGetPayloadSize(int *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int v4;
  uint64_t v5;
  _QWORD *v6;

  v4 = *a1;
  if ((*a1 & 0x800) != 0)
  {
    v5 = *((_QWORD *)a1 + 10);
    if ((v4 & 0x200) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v5 = 0;
  if ((v4 & 0x200) != 0)
LABEL_5:
    v5 += *((_QWORD *)a1 + 8);
LABEL_6:
  if ((v4 & 0x400) != 0)
  {
    v5 += *((_QWORD *)a1 + 9);
    if (!a3)
      goto LABEL_14;
  }
  else if (!a3)
  {
    goto LABEL_14;
  }
  v6 = (_QWORD *)(a2 + 8);
  do
  {
    if (*((_DWORD *)v6 - 1) == 2)
      v5 += *v6;
    v6 += 129;
    --a3;
  }
  while (a3);
LABEL_14:
  *a4 = v5;
  return 0;
}

char *fileSessionCreate(const char *a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  char v11;
  stat v12;

  memset(&v12, 0, sizeof(v12));
  v2 = (char *)calloc(1uLL, 0x800uLL);
  if (!v2)
  {
    v5 = *__error();
    v9 = "malloc";
    v8 = 140;
    goto LABEL_7;
  }
  if (!realpath_DARWIN_EXTSN(a1, v2))
  {
    v5 = *__error();
    v11 = (char)a1;
    v9 = "%s";
    v8 = 143;
    goto LABEL_7;
  }
  if (lstat(v2, &v12))
  {
    v5 = *__error();
    v8 = 146;
    v9 = v2;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionCreate", v8, 40, v5, v9, v6, v7, v11);
    goto LABEL_8;
  }
  if ((v12.st_mode & 0xF000) == 0x4000)
  {
    __strlcpy_chk();
    __strlcat_chk();
    return v2;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionCreate", 147, 40, 0, "Not a directory: %s", v3, v4, (char)v2);
LABEL_8:
  free(v2);
  return 0;
}

uint64_t fileSessionDestroy(void *a1)
{
  free(a1);
  return 0;
}

void *fileRequestOpenForWriting(uint64_t a1, uint64_t a2)
{
  char *v4;
  void *v5;
  const char *v6;
  int v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  v4 = (char *)calloc(1uLL, 0x498uLL);
  v5 = v4;
  if (!v4)
  {
    v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForWriting", 173, 40, *v12, "malloc", v13, v14, v16);
LABEL_6:
    free(v5);
    return 0;
  }
  *((_DWORD *)v4 + 2) = 1;
  *(_QWORD *)v4 = a1;
  *((_DWORD *)v4 + 264) = -1;
  *((_QWORD *)v4 + 2) = 0;
  *((_QWORD *)v4 + 3) = a2;
  CC_SHA256_Init((CC_SHA256_CTX *)(v4 + 1064));
  v6 = (const char *)(a1 + 1024);
  __strlcpy_chk();
  v7 = mkstemp((char *)v5 + 32);
  *((_DWORD *)v5 + 264) = v7;
  if (v7 < 0)
  {
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForWriting", 184, 40, *v8, v6, v9, v10, v16);
    v11 = *((_DWORD *)v5 + 264);
    if ((v11 & 0x80000000) == 0)
      close(v11);
    goto LABEL_6;
  }
  return v5;
}

size_t fileRequestWrite(uint64_t a1, const void *a2, size_t __nbyte, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  ssize_t v8;
  ssize_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;

  if (*(_DWORD *)(a1 + 1060))
    return -1;
  if (!*(_DWORD *)(a1 + 8))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 200, 40, 0, "Invalid request type", a7, a8, v20);
    return -1;
  }
  if (*(_QWORD *)(a1 + 24) < __nbyte)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 203, 40, 0, "Exceeding write limit %llu: nbyte=%llu", a7, a8, *(_QWORD *)(a1 + 24));
LABEL_15:
    *(_DWORD *)(a1 + 1060) = 1;
    return -1;
  }
  v13 = write(*(_DWORD *)(a1 + 1056), a2, __nbyte);
  v8 = v13;
  if (v13 < 0)
  {
    v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 207, 40, *v17, "write", v18, v19, v20);
    return v8;
  }
  if (v13 != __nbyte)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestWrite", 208, 40, 0, "truncated write: %zd/%zu", v14, v15, v13);
    goto LABEL_15;
  }
  CC_SHA256_Update((CC_SHA256_CTX *)(a1 + 1064), a2, __nbyte);
  v16 = *(_QWORD *)(a1 + 24);
  if (v16 != -1)
    *(_QWORD *)(a1 + 24) = v16 - __nbyte;
  return __nbyte;
}

uint64_t fileRequestCloseAndGetKey(char *a1, _OWORD *a2, unint64_t a3, _QWORD *a4)
{
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  int v14;
  size_t v15;
  int v16;
  int v17;
  int v18;
  void *v19;
  ssize_t v20;
  ssize_t v21;
  ssize_t v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  const char *v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  int v40;
  __int128 v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  stat v48;
  unsigned __int8 md[16];
  __int128 v50;
  char __s[1024];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0;
  v8 = *(const char **)a1;
  bzero(__s, 0x400uLL);
  *(_OWORD *)md = 0u;
  v50 = 0u;
  if (*((_DWORD *)a1 + 265))
    goto LABEL_41;
  if (!*((_DWORD *)a1 + 2))
  {
    v12 = "Invalid request type";
    v13 = 229;
LABEL_40:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", v13, 40, 0, v12, v9, v10, v46);
    goto LABEL_41;
  }
  if (a3 <= 0x1F)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", 230, 40, 0, "Key capacity is too low, %d bytes needed", v9, v10, 32);
    goto LABEL_41;
  }
  if ((unint64_t)(*((_QWORD *)a1 + 3) + 1) >= 2)
  {
    v46 = *((_QWORD *)a1 + 3);
    v12 = "Missing write limit %llu";
    v13 = 233;
    goto LABEL_40;
  }
  v14 = *((_DWORD *)a1 + 264);
  if ((v14 & 0x80000000) == 0)
  {
    close(v14);
    *((_DWORD *)a1 + 264) = -1;
  }
  CC_SHA256_Final(md, (CC_SHA256_CTX *)(a1 + 1064));
  while (1)
  {
    pathFromKey(__s, v8, md);
    v15 = strlen(__s);
    makePath(__s, v15);
    memset(&v48, 0, sizeof(v48));
    if (!stat(__s, &v48))
      goto LABEL_34;
    v16 = open(a1 + 32, 0);
    if (v16 < 0)
    {
      v28 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"renameIfNotExist", 90, 40, *v28, "%s", v29, v30, (_BYTE)a1 + 32);
    }
    else
    {
      LOBYTE(v47) = 0x80;
      v17 = open(__s, 2561);
      if (v17 == -17)
        goto LABEL_34;
      v18 = v17;
      if (v17 < 0)
      {
        v31 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"renameIfNotExist", 94, 40, *v31, "%s", v32, v33, (char)__s);
        close(v16);
        v16 = v18;
      }
      else
      {
        v19 = malloc(0x10000uLL);
        if (v19)
        {
          while (1)
          {
            v20 = read(v16, v19, 0x10000uLL);
            v21 = v20;
            if (!v20)
              goto LABEL_29;
            if (v20 < 0)
              break;
            v22 = write(v18, v19, v20);
            if (v22 < 0)
            {
              v26 = *__error();
              v47 = __s;
              v25 = 110;
              goto LABEL_27;
            }
            if (v22 != v21)
            {
              v25 = 111;
              v26 = 0;
              v27 = "truncated write";
              goto LABEL_28;
            }
          }
          v26 = *__error();
          LOBYTE(v47) = (_BYTE)a1 + 32;
          v25 = 107;
LABEL_27:
          v27 = "%s";
          goto LABEL_28;
        }
        v26 = *__error();
        v25 = 101;
        v27 = "malloc";
LABEL_28:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"renameIfNotExist", v25, 40, v26, v27, v23, v24, (char)v47);
        LODWORD(v21) = 1;
LABEL_29:
        free(v19);
        close(v18);
        close(v16);
        v34 = (_DWORD)v21 ? __s : a1 + 32;
        unlink(v34);
        v16 = (int)((_DWORD)v21 << 31) >> 31;
      }
    }
    if (v16 != -17)
      break;
LABEL_34:
    if ((int)areFilesEqual(a1 + 32, __s) > 0)
      goto LABEL_47;
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", 262, 40, "SHA256 hash collision: %s", v35, v36, v37, (char)__s);
    v38 = 31;
    do
    {
      if (v38 == -1)
        break;
      v39 = ++md[v38--];
    }
    while ((v39 & 0x100) != 0);
  }
  if (!v16)
  {
LABEL_47:
    v11 = 0;
    v42 = v50;
    *a2 = *(_OWORD *)md;
    a2[1] = v42;
    *a4 = 32;
    goto LABEL_42;
  }
  v43 = *__error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestCloseAndGetKey", 252, 40, v43, "%s", v44, v45, (char)__s);
LABEL_41:
  v11 = 0xFFFFFFFFLL;
LABEL_42:
  v40 = *((_DWORD *)a1 + 264);
  if ((v40 & 0x80000000) == 0)
    close(v40);
  unlink(a1 + 32);
  free(a1);
  return v11;
}

char **fileRequestOpenForReading(const char *a1, unsigned __int8 *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  char **v12;
  char **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  char v21;
  char v22[1024];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  bzero(v22, 0x400uLL);
  if (a3 != 32)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForReading", 288, 40, 0, "invalid key size: %zu", v10, v11, a3);
    v13 = 0;
    goto LABEL_7;
  }
  pathFromKey(v22, a1, a2);
  v12 = (char **)calloc(1uLL, 0x498uLL);
  v13 = v12;
  if (!v12)
  {
    v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForReading", 295, 40, *v17, "malloc", v18, v19, v21);
    goto LABEL_7;
  }
  *v12 = (char *)a1;
  v14 = IFileStreamCreateWithFilename(v22, a4, a5);
  v13[146] = (char *)v14;
  if (!v14)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestOpenForReading", 300, 40, 0, "creating file stream: %s", v15, v16, (char)v22);
    IFileStreamDestroy(v13[146]);
LABEL_7:
    free(v13);
    return 0;
  }
  return v13;
}

uint64_t fileRequestRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!*(_DWORD *)(a1 + 8))
    return IFileStreamRead(*(_QWORD *)(a1 + 1168), a2, a3, a4, a5, a6, a7, a8);
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestRead", 315, 40, 0, "Invalid request type", a7, a8, vars0);
  return -1;
}

uint64_t fileRequestPRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Pos;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;

  if (*(_DWORD *)(a1 + 8))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestPRead", 322, 40, 0, "Invalid request type", a7, a8, v32);
    return -1;
  }
  else
  {
    Pos = IFileStreamGetPos(*(_QWORD *)(a1 + 1168));
    IFileStreamSetPos(*(_QWORD *)(a1 + 1168), a4, v14, v15, v16, v17, v18, v19);
    v25 = IFileStreamRead(*(_QWORD *)(a1 + 1168), a2, a3, v20, v21, v22, v23, v24);
    IFileStreamSetPos(*(_QWORD *)(a1 + 1168), Pos, v26, v27, v28, v29, v30, v31);
    return v25;
  }
}

uint64_t fileRequestClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  char v9;

  if (result)
  {
    v8 = (void *)result;
    if (*(_DWORD *)(result + 8))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileRequestClose", 334, 40, 0, "Invalid request type", a7, a8, v9);
      return 0xFFFFFFFFLL;
    }
    else
    {
      IFileStreamDestroy(*(char **)(result + 1168));
      free(v8);
      return 0;
    }
  }
  return result;
}

uint64_t fileSessionClone(const char *a1, const char *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char v15[1024];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  bzero(v15, 0x400uLL);
  if (a4 == 32)
  {
    pathFromKey(v15, a1, a3);
    v10 = clonefile(v15, a2, 0);
    result = 0;
    if ((v10 & 0x80000000) == 0)
      return result;
    v12 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionClone", 354, 40, v12, "cloning %s to %s", v13, v14, (char)v15);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabasePlugins/ArchiveDatabaseFilePlugin.c", (uint64_t)"fileSessionClone", 347, 40, 0, "invalid key size: %zu", v8, v9, a4);
  }
  return 0xFFFFFFFFLL;
}

uint64_t pathFromKey(char *a1, const char *a2, unsigned __int8 *a3)
{
  _OWORD v6[4];
  char v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  serializeHexString((uint64_t)v6, 0x20u, a3);
  return snprintf(a1, 0x400uLL, "%s/%c%c%c/%s", a2, SLOBYTE(v6[0]), SBYTE1(v6[0]), SBYTE2(v6[0]), (const char *)v6);
}

_OWORD *ParallelArchiveWriterCreate(_OWORD *a1)
{
  _OWORD *v2;
  _OWORD *v3;
  __int128 v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  v2 = calloc(1uLL, 0x100040uLL);
  v3 = v2;
  if (v2)
  {
    v4 = a1[1];
    *v2 = *a1;
    v2[1] = v4;
    *((_QWORD *)v2 + 7) = 0x100000;
    *((_DWORD *)v2 + 8) = 0;
  }
  else
  {
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriterCreate", 15, 22, *v5, "malloc", v6, v7, v9);
  }
  return v3;
}

_OWORD *ParallelArchiveWriterCreateLegacy(_OWORD *a1)
{
  _OWORD *result;

  result = ParallelArchiveWriterCreate(a1);
  if (result)
    *((_DWORD *)result + 8) = 1;
  return result;
}

uint64_t ParallelArchiveWriterDestroy(_QWORD *a1)
{
  uint64_t v1;

  if (!a1)
    return 0;
  v1 = a1[5];
  free(a1);
  return v1;
}

uint64_t yaa_writeRawEntryHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_QWORD *)(a1 + 48))
  {
    v15 = *(_QWORD *)(a1 + 48);
    v8 = "truncated entry payload: %llu B missing";
    v9 = 46;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"yaa_writeRawEntryHeader", v9, 22, 0, v8, a7, a8, v15);
    return 0xFFFFFFFFLL;
  }
  v13 = (*(uint64_t (**)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 24));
  if (v13 < 0)
  {
    v8 = "writing header";
    v9 = 50;
    goto LABEL_3;
  }
  v14 = v13;
  result = 0;
  *(_QWORD *)(a1 + 40) += v14;
  *(_QWORD *)(a1 + 48) = a4;
  return result;
}

uint64_t ParallelArchiveWriteEntryHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  unsigned int v25;
  uint64_t result;
  _QWORD *v27;
  char v28;
  char v29;

  v8 = a4;
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v28);
  if (*(_QWORD *)(a1 + 48))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryHeader", 68, 22, 0, "truncated entry payload: %llu B missing", v13, v14, *(_QWORD *)(a1 + 48));
LABEL_20:
    v25 = -1;
    goto LABEL_21;
  }
  if (v8)
  {
    v15 = (_BYTE *)a3;
    v16 = v8;
    while (*v15 && v15[1] && v15[2] && !v15[3])
    {
      v15 += 1032;
      if (!--v16)
        goto LABEL_10;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryHeader", 76, 22, 0, "invalid extra field key: %s", v13, v14, (char)v15);
    goto LABEL_20;
  }
LABEL_10:
  v17 = yaa_encodeHeader(a1 + 64, *(_QWORD *)(a1 + 56), (int *)a2, a3, v8, v12, v13, v14);
  if (v17 < 0)
  {
    v23 = "generating entry header";
    v24 = 81;
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryHeader", v24, 22, 0, v23, v18, v19, v29);
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 32))
    *(_DWORD *)(a1 + 64) = 826360153;
  v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 24), a1 + 64, v17);
  if (v20 < 0)
  {
    v23 = "writing header";
    v24 = 88;
    goto LABEL_19;
  }
  *(_QWORD *)(a1 + 40) += v20;
  v21 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 & 0x200) != 0)
    v22 = *(_QWORD *)(a2 + 64);
  else
    v22 = 0;
  if ((v21 & 0x400) != 0)
  {
    v22 += *(_QWORD *)(a2 + 72);
    if ((v21 & 0x800) == 0)
    {
LABEL_27:
      if (!v8)
        goto LABEL_35;
LABEL_31:
      v27 = (_QWORD *)(a3 + 8);
      do
      {
        if (*((_DWORD *)v27 - 1) == 2)
          v22 += *v27;
        v27 += 129;
        --v8;
      }
      while (v8);
      goto LABEL_35;
    }
  }
  else if ((v21 & 0x800) == 0)
  {
    goto LABEL_27;
  }
  v22 += *(_QWORD *)(a2 + 80);
  if (v8)
    goto LABEL_31;
LABEL_35:
  v25 = 0;
  *(_QWORD *)(a1 + 48) = v22;
LABEL_21:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v25;
  else
    return result;
}

uint64_t ParallelArchiveWriteEntryData(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  char v19;
  char v20;

  if (!a3)
    return 0;
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v19);
  if (*(_QWORD *)(a1 + 48) >= a3)
  {
    v14 = (*(uint64_t (**)(_QWORD, uint64_t, unint64_t))(a1 + 8))(*(_QWORD *)(a1 + 24), a2, a3);
    if ((v14 & 0x8000000000000000) == 0 && v14 == a3)
    {
      v17 = 0;
      v18 = *(_QWORD *)(a1 + 48) - a3;
      *(_QWORD *)(a1 + 40) += a3;
      *(_QWORD *)(a1 + 48) = v18;
      goto LABEL_10;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryData", 133, 22, 0, "writing data", v15, v16, v20);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Write.c", (uint64_t)"ParallelArchiveWriteEntryData", 129, 22, 0, "Payload too large: %zu B received / %llu B expected", v11, v12, a3);
  }
  v17 = -1;
LABEL_10:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v17;
  else
    return result;
}

uint64_t BlobBufferStore(uint64_t a1, const void *a2, size_t a3, _QWORD *a4)
{
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;

  if (!a3)
    return 0xFFFFFFFFLL;
  v8 = *(_QWORD *)(a1 + 8) + a3;
  if ((BlobBufferIncreaseCapacity(a1, v8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferStore", 19, 6, 0, "BlobBufferStore", v9, v10, v12);
    return 0xFFFFFFFFLL;
  }
  else
  {
    if (a2)
      memcpy((void *)(*(_QWORD *)(a1 + 16) + *(_QWORD *)(a1 + 8)), a2, a3);
    if (a4)
    {
      *a4 = *(_QWORD *)(a1 + 8);
      a4[1] = a3;
    }
    result = 0;
    *(_QWORD *)(a1 + 8) = v8;
  }
  return result;
}

uint64_t BlobBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  size_t v2;
  uint64_t v4;
  void *v5;
  uint64_t result;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v2 = *(_QWORD *)a1;
  if (*(_QWORD *)a1 >= a2)
    return 0;
  do
  {
    v4 = v2 + (v2 >> 1);
    if (__CFADD__(v2, v2 >> 1))
      v4 = -1;
    if (v2)
      v2 = v4;
    else
      v2 = 0x10000;
  }
  while (v2 < a2);
  v5 = reallocf(*(void **)(a1 + 16), v2);
  *(_QWORD *)(a1 + 16) = v5;
  if (v5)
  {
    result = 0;
    *(_QWORD *)a1 = v2;
  }
  else
  {
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/BlobBuffer.c", (uint64_t)"BlobBufferIncreaseCapacity", 58, 6, *v7, "malloc", v8, v9, v10);
    return 0xFFFFFFFFLL;
  }
  return result;
}

void BlobBufferFree(uint64_t a1)
{
  free(*(void **)(a1 + 16));
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
}

size_t PCompressLZ4Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZ4Decode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZ4);
  if (!result)
    return -1;
  return result;
}

uint64_t BXDiffWithCache(unint64_t a1, const char **a2, uint64_t a3, const char *a4, _DWORD *a5, int a6, uint64_t a7, _QWORD *a8, _QWORD *a9, unint64_t *a10)
{
  unint64_t v15;
  uint64_t v16;
  unint64_t st_size;
  unint64_t v18;
  const char **v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  char v24;
  unint64_t v25;
  BOOL v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  _BYTE *v35;
  unsigned __int8 *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  char *v46;
  __int128 *v47;
  __int128 *v48;
  int v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  _BYTE *v54;
  char **v55;
  uint64_t v56;
  _BYTE *v57;
  unint64_t *v58;
  unint64_t v59;
  const char *v60;
  __int16 v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  size_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  int v82;
  void **v83;
  uint64_t *v85;
  uint64_t v86;
  unint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  _BYTE *v90;
  _QWORD *v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t CompressedSize;
  unint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  const char *v101;
  unint64_t *v102;
  uint64_t v103;
  const char *v104;
  __int16 v105;
  uint64_t v106;
  unint64_t *v107;
  unint64_t *v108;
  unint64_t *v109;
  unint64_t *v110;
  unint64_t v111;
  int v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  _BYTE *v121;
  unint64_t v122;
  char v123;
  uint64_t v124;
  uint64_t v125;
  _QWORD *v126;
  unint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  _QWORD *v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t *v142;
  unint64_t *v143;
  unint64_t v144;
  unint64_t *v145;
  unint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t *v149;
  unint64_t v150;
  unint64_t *v151;
  unint64_t *v152;
  unint64_t v153;
  unint64_t *v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t *v158;
  unint64_t v159;
  char v160;
  unint64_t v161;
  char v162;
  unint64_t *v163;
  _BOOL4 v164;
  const char **v165;
  uint64_t v166;
  int v167;
  _DWORD *v168;
  _QWORD *v169;
  uint64_t v170;
  const char *v171;
  const char *v172;
  int v174;
  unint64_t v176;
  stat v177;
  _QWORD v178[2];
  int v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  void *v184[2];
  __int128 v185;
  void *v186[2];
  _OWORD v187[3];
  __int128 v188;
  _OWORD v189[2];
  _BYTE v190[4];
  _BYTE v191[76];
  _QWORD v192[100];

  v15 = a1;
  v192[98] = *MEMORY[0x24BDAC8D0];
  v174 = *(_DWORD *)(a7 + 4);
  v16 = a1 - 1;
  memset(&v177, 0, sizeof(v177));
  bzero(v190, 0x360uLL);
  memset(v189, 0, sizeof(v189));
  v188 = 0u;
  memset(v187, 0, sizeof(v187));
  v185 = 0u;
  *(_OWORD *)v186 = 0u;
  v183 = 0u;
  *(_OWORD *)v184 = 0u;
  v181 = 0u;
  v182 = 0u;
  v180 = 0u;
  *a8 = 0;
  *a9 = 0;
  if (!v15)
  {
    v165 = a2;
    v167 = a6;
    v168 = a5;
    v169 = a8;
    v171 = a4;
    v164 = 0;
LABEL_12:
    v22 = 0;
    v25 = 0;
    v23 = -1;
    do
    {
      if (v15)
      {
        v26 = 0;
        v27 = 0;
        v28 = a3;
        while (v27 >= v25 && v16 != v27 || sha1cmp(a3 + 20 * v25, v28))
        {
          v26 = ++v27 >= v15;
          v28 += 20;
          if (v15 == v27)
          {
            v29 = 1;
            v23 = v25;
            goto LABEL_22;
          }
        }
        v29 = 0;
      }
      else
      {
        v26 = 1;
        v23 = v25;
        v29 = 1;
      }
LABEL_22:
      *(_DWORD *)&v190[96 * v25] = v29;
      v22 += v26;
      ++v25;
    }
    while (v25 != v16);
    v30 = 0;
    a8 = v169;
    a4 = v171;
    goto LABEL_24;
  }
  st_size = 0;
  v18 = v15;
  v19 = a2;
  do
  {
    if (lstat(*v19, &v177) || (v177.st_mode & 0xF000) != 0x8000)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 59, 91, 0, "Invalid file: %s", v20, v21, (char)*v19);
      v22 = 0;
      v23 = -1;
      v24 = 1;
      goto LABEL_79;
    }
    if (v177.st_size > st_size)
      st_size = v177.st_size;
    ++v19;
    --v18;
  }
  while (v18);
  v164 = st_size > 0xA00000;
  v168 = a5;
  v167 = a6;
  v165 = a2;
  if (v16)
  {
    v169 = a8;
    v171 = a4;
    goto LABEL_12;
  }
  v22 = 0;
  v23 = -1;
  v30 = 1;
LABEL_24:
  if (bxdiff5Alloc(v22, (uint64_t *)a7, (uint64_t)&v180))
  {
    v33 = "bxdiff5Alloc";
    v34 = 79;
    goto LABEL_26;
  }
  v178[0] = 0;
  v178[1] = 0;
  v179 = 0;
  v162 = v30;
  if ((v30 & 1) == 0)
  {
    v35 = v191;
    v36 = (unsigned __int8 *)a3;
    v37 = v16;
    do
    {
      if (*((_DWORD *)v35 - 1))
      {
        patchCacheKeyFromSHA1(v36, (uint64_t)v35);
        sha1xor((uint64_t)v178, (uint64_t)v36);
      }
      v35 += 96;
      v36 += 20;
      --v37;
    }
    while (v37);
  }
  patchCacheKeyFromSHA1((unsigned __int8 *)v178, (uint64_t)v187 + 4);
  patchCacheKeyFromSHA1((unsigned __int8 *)(a3 + 20 * v16), (unint64_t)&v190[96 * v16] | 4);
  if (v174 > 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%zu/%zu unique inputs: %s\n", v22, v16, a4);
  if (v168)
  {
    v43 = a10 + 3;
    if (v22 == 1)
      v43 = a10;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 + 1, v43));
    v45 = (unint64_t)&v190[96 * v23];
    if (v22 == 1)
      v46 = (char *)(v45 | 4);
    else
      v46 = (char *)v187 + 4;
    v47 = (__int128 *)(v45 + 48);
    if (v22 == 1)
      v48 = v47;
    else
      v48 = &v188;
    v49 = patchCacheLookup(v168, (uint64_t)v46, (unint64_t)&v190[96 * v16] | 4, (uint64_t)v48, v167, 0x11E1A300uLL, v41, v42);
    if (v49 < 0)
    {
      v52 = a10 + 8;
      do
        v53 = __ldaxr(v52);
      while (__stlxr(v53 + 1, v52));
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 118, 91, "cache lookup failed (ignored): %s", v40, v41, v42, (char)a4);
    }
    else if (v49)
    {
      if (v22 == 1)
      {
        v50 = a10 + 1;
        do
          v51 = __ldaxr(v50);
        while (__stlxr(v51 + 1, v50));
        if (v174 >= 2)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Loaded 1:1 patch from cache: %s\n", a4);
        v24 = 0;
        goto LABEL_77;
      }
      v65 = a10 + 4;
      do
        v66 = __ldaxr(v65);
      while (__stlxr(v66 + 1, v65));
      if (v174 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Loaded combo patch from cache: %s\n");
      goto LABEL_71;
    }
    if (v174 >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "No patch in cache: %s\n", a4);
  }
  v170 = v23;
  v54 = &v190[96 * v16];
  v56 = *((_QWORD *)v54 + 10);
  v55 = (char **)(v54 + 80);
  if (!v56)
  {
    v62 = v165[v16];
    if ((loadFileContents(v62, v55, &v192[12 * v16 + 1], 0) & 0x80000000) != 0)
    {
      v160 = (char)v62;
      v60 = "loadFileContents: %s";
      v61 = 150;
      goto LABEL_74;
    }
    if (v174 >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Loaded output file: %s\n", v62);
  }
  v161 = (unint64_t)&v190[96 * v16] | 4;
  v57 = &v190[96 * v16];
  v59 = *((_QWORD *)v57 + 11);
  v58 = (unint64_t *)(v57 + 88);
  if (bxdiff5SetOut((uint64_t)&v180, (uint64_t)*v55, v59, v38, v39, v40, v41, v42))
  {
    v60 = "bxdiff5SetOut";
    v61 = 154;
    goto LABEL_74;
  }
  if (sha1cmp((uint64_t)&v183, a3 + 20 * v16))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 156, 91, 0, "SHA1 inconsistency (patching): %s", v63, v64, (char)v165[v16]);
    goto LABEL_75;
  }
  v172 = a4;
  CompressedSize = ParallelCompressionGetCompressedSize((uint64_t)*v55, *v58, 1);
  if ((v162 & 1) == 0)
  {
    v98 = 0;
    v99 = 0;
    v100 = v192;
    while (1)
    {
      if (*((_DWORD *)v100 - 20))
      {
        if (!*v100)
        {
          v101 = v165[v99];
          if ((loadFileContents(v101, (char **)v100, v100 + 1, 0) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 169, 91, 0, "loadFileContents: %s", v41, v42, (char)v101);
            goto LABEL_194;
          }
          if (v174 >= 2)
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Loaded input file %zu: %s\n", v99, v101);
        }
        if (bxdiff5SetIn(&v180, v98, *v100, v100[1], v95, v96, v41, v42))
        {
          v104 = "bxdiff5SetIn";
          v105 = 173;
LABEL_193:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", v105, 91, 0, v104, v41, v42, v160);
LABEL_194:
          v24 = 1;
LABEL_195:
          v23 = v170;
          a4 = v172;
          if (v22)
            goto LABEL_77;
          goto LABEL_79;
        }
        if (sha1cmp(*((_QWORD *)&v181 + 1) + 80 * v98 + 16, a3))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 175, 91, 0, "SHA1 inconsistency (patching): %s", v41, v42, (char)v165[v99]);
          goto LABEL_194;
        }
        ++v98;
      }
      v100 += 12;
      ++v99;
      a3 += 20;
      if (v16 == v99)
        goto LABEL_118;
    }
  }
  v98 = 0;
LABEL_118:
  if (v98 != v22)
  {
    v104 = "inconsistent N";
    v105 = 178;
    goto LABEL_193;
  }
  v23 = v170;
  if (v174 >= 2)
    bxdiff5Dump((uint64_t)&v180, (FILE *)*MEMORY[0x24BDAC8D8]);
  if (v22 < 2)
  {
    if (bxdiff5CreateInControls((uint64_t)&v180, 0, v164, 0, v95, v96, v41, v42))
    {
      v33 = "bxdiff5CreateInControls";
      v34 = 294;
      goto LABEL_26;
    }
    if (bxdiff5CreateInPatch((uint64_t)&v180, 0))
    {
      v33 = "bxdiff5CreateInPatch";
      v34 = 295;
      goto LABEL_26;
    }
    v138 = *((_QWORD *)&v181 + 1);
    v139 = &v190[96 * v170];
    v140 = CompressedSize;
    v141 = (uint64_t)(v139 + 6);
    v139[9] = *(_QWORD *)(*((_QWORD *)&v181 + 1) + 64);
    v139[7] = *(_QWORD *)(v138 + 72);
    v139[8] = v140;
    v142 = a10;
    v143 = a10 + 6;
    *(_QWORD *)(v138 + 64) = 0;
    *(_QWORD *)(v138 + 72) = 0;
    do
      v144 = __ldaxr(v143);
    while (__stlxr(v144 + 1, v143));
    if (v174 >= 2)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Created 1:1 patch: %s\n", a4);
      v142 = a10;
    }
    if (*(_DWORD *)&v191[96 * v170 + 48])
    {
      v145 = v142 + 2;
      do
        v146 = __ldaxr(v145);
      while (__stlxr(v146 + 1, v145));
      if (v168
        && patchCacheUpdate(v168, (unint64_t)&v190[96 * v170] | 4, v161, v141, v134, v135, v31, v32))
      {
        v149 = a10 + 9;
        do
          v150 = __ldaxr(v149);
        while (__stlxr(v150 + 1, v149));
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 311, 91, 0, "cache update failed (ignored): %s", v147, v148, (char)a4);
      }
      if (v174 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Updated 1:1 patch to cache: %s\n");
    }
LABEL_71:
    v24 = 0;
    if (v22)
      goto LABEL_77;
    goto LABEL_79;
  }
  v166 = CompressedSize;
  v102 = a10;
  if ((v162 & 1) != 0)
  {
    v103 = 0;
LABEL_169:
    a4 = v172;
    if (v103 != v22)
    {
      v60 = "inconsistent N";
      v61 = 262;
      goto LABEL_74;
    }
    v23 = v170;
    if (bxdiff5CreateComboControls((uint64_t)&v180, v103, v93, v94, v95, v96, v41, v42))
    {
      v33 = "bxdiff5CreateComboControls";
      v34 = 265;
      goto LABEL_26;
    }
    if (bxdiff5CreateComboPatch((uint64_t)&v180, v129, v130, v131, v132, v133, v31, v32))
    {
      v33 = "bxdiff5CreateComboPatch";
      v34 = 266;
LABEL_26:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", v34, 91, 0, v33, v31, v32, v160);
      v24 = 1;
      if (v22)
        goto LABEL_77;
      goto LABEL_79;
    }
    v151 = a10;
    v152 = a10 + 7;
    do
      v153 = __ldaxr(v152);
    while (__stlxr(v153 + 1, v152));
    if (v174 >= 2)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Created combo patch: %s\n", v172);
      v151 = a10;
    }
    *(_QWORD *)&v189[0] = v166;
    *((void **)&v189[0] + 1) = v186[0];
    *((void **)&v188 + 1) = v186[1];
    v186[0] = 0;
    v186[1] = 0;
    if (DWORD1(v188))
    {
      v154 = v151 + 5;
      do
        v155 = __ldaxr(v154);
      while (__stlxr(v155 + 1, v154));
      if (v168 && patchCacheUpdate(v168, (uint64_t)v187 + 4, v161, (uint64_t)&v188, v136, v137, v31, v32))
      {
        v158 = a10 + 9;
        do
          v159 = __ldaxr(v158);
        while (__stlxr(v159 + 1, v158));
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 284, 91, 0, "cache update failed (ignored): %s", v156, v157, (char)v172);
      }
      if (v174 >= 2)
      {
        a4 = v172;
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Updated combo patch to cache: %s\n", v172);
        v24 = 0;
        goto LABEL_76;
      }
      v24 = 0;
      goto LABEL_195;
    }
    goto LABEL_71;
  }
  v103 = 0;
  v106 = 0;
  v107 = a10 + 1;
  v163 = a10 + 8;
  v108 = a10 + 6;
  v109 = a10 + 2;
  v110 = a10 + 9;
  while (1)
  {
    if (!*(_DWORD *)&v190[96 * v106])
      goto LABEL_168;
    v176 = v103;
    do
      v111 = __ldaxr(v102);
    while (__stlxr(v111 + 1, v102));
    a4 = v172;
    if (!v168)
      goto LABEL_147;
    v112 = patchCacheLookup(v168, (unint64_t)&v190[96 * v106] | 4, v161, (uint64_t)&v191[96 * v106 + 44], v167, 0x11E1A300uLL, v41, v42);
    if (v112 < 0)
    {
      do
        v119 = __ldaxr(v163);
      while (__stlxr(v119 + 1, v163));
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 199, 91, 0, "cache lookup failed (ignored): %s", v41, v42, (char)v172);
LABEL_147:
      if (v174 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "No 1:1 patch %zu in cache: %s\n", v106, v172);
      goto LABEL_149;
    }
    if (!v112)
      goto LABEL_147;
    do
      v113 = __ldaxr(v107);
    while (__stlxr(v113 + 1, v107));
    if (v174 >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Loaded 1:1 patch %zu from cache: %s\n", v106, v172);
    v93 = *(_QWORD *)&v191[96 * v106 + 68];
    if (v93)
      break;
LABEL_149:
    v120 = v176;
    if (!*(_QWORD *)(*((_QWORD *)&v181 + 1) + 80 * v176 + 40))
    {
      if (bxdiff5CreateInControls((uint64_t)&v180, v176, v164, 0, v95, v96, v41, v42))
      {
        v60 = "bxdiff5CreateInControls";
        v61 = 232;
        goto LABEL_74;
      }
      v120 = v176;
      if (v174 >= 2)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Created 1:1 controls %zu: %s\n", v106, v172);
        v120 = v176;
      }
    }
    v121 = &v190[96 * v106];
    if (*((_DWORD *)v121 + 13))
    {
      if (bxdiff5CreateInPatch((uint64_t)&v180, v120))
      {
        v104 = "bxdiff5CreateInPatch";
        v105 = 239;
        goto LABEL_193;
      }
      v94 = (uint64_t)(v121 + 48);
      do
        v122 = __ldaxr(v108);
      while (__stlxr(v122 + 1, v108));
      v123 = (char)v172;
      if (v174 >= 2)
      {
        v124 = v94;
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Created 1:1 patch %zu: %s\n", v106, v172);
        v94 = v124;
        v123 = (char)v172;
      }
      v125 = *((_QWORD *)&v181 + 1) + 80 * v176;
      v126 = &v190[96 * v106];
      v126[9] = *(_QWORD *)(v125 + 64);
      v126[7] = *(_QWORD *)(v125 + 72);
      v126[8] = v166;
      *(_QWORD *)(v125 + 64) = 0;
      *(_QWORD *)(v125 + 72) = 0;
      do
        v127 = __ldaxr(v109);
      while (__stlxr(v127 + 1, v109));
      if (v168
        && patchCacheUpdate(v168, (unint64_t)&v190[96 * v106] | 4, v161, v94, v95, v96, v41, v42))
      {
        do
          v128 = __ldaxr(v110);
        while (__stlxr(v128 + 1, v110));
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 254, 91, 0, "cache update failed (ignored): %s", v41, v42, v123);
      }
      v120 = v176;
      if (v174 >= 2)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Updated 1:1 patch %zu to cache: %s\n", v106, v172);
        v120 = v176;
      }
    }
    v103 = v120 + 1;
    v102 = a10;
LABEL_168:
    if (++v106 == v16)
      goto LABEL_169;
  }
  if (bxdiff5SetInPatch((uint64_t)&v180, v176, v93, *(_QWORD *)&v191[96 * v106 + 52], v95, v96, v41, v42))
  {
    v60 = "bxdiff5SetInPatch";
    v61 = 213;
    goto LABEL_74;
  }
  if (!bxdiff5ReadInControlsFromInPatch((uint64_t)&v180, v176, v114, v115, v116, v117, v41, v42))
  {
    if (v174 >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Loaded 1:1 controls from patch %zu: %s\n", v106, v172);
    v118 = *((_QWORD *)&v181 + 1) + 80 * v176;
    *(_QWORD *)(v118 + 64) = 0;
    *(_QWORD *)(v118 + 72) = 0;
    goto LABEL_149;
  }
  v60 = "bxdiff5ReadInControlsFromInPatch";
  v61 = 216;
LABEL_74:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", v61, 91, 0, v60, v41, v42, v160);
LABEL_75:
  v24 = 1;
LABEL_76:
  v23 = v170;
  if (v22)
  {
LABEL_77:
    v67 = 0;
    v68 = *((_QWORD *)&v181 + 1);
    v69 = v22;
    do
    {
      v70 = v68 + v67;
      *(_QWORD *)v70 = 0;
      free(*(void **)(v70 + 40));
      v71 = *((_QWORD *)&v181 + 1) + v67;
      *(_QWORD *)(v71 + 40) = 0;
      free(*(void **)(v71 + 64));
      v68 = *((_QWORD *)&v181 + 1);
      *(_QWORD *)(*((_QWORD *)&v181 + 1) + v67 + 64) = 0;
      v67 += 80;
      --v69;
    }
    while (v69);
  }
LABEL_79:
  *(_QWORD *)&v182 = 0;
  free(v184[1]);
  v184[1] = 0;
  free(v186[0]);
  v186[0] = 0;
  if (bxdiff5Free((uint64_t)&v180, v72, v73, v74, v75, v76, v77, v78))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 330, 91, 0, "bxdiff5Free", v79, v80, v160);
    goto LABEL_82;
  }
  if ((v24 & 1) != 0)
  {
LABEL_82:
    unlink(a4);
    v81 = 0;
    v82 = 0;
    if (v15)
      goto LABEL_83;
  }
  else
  {
    v85 = (uint64_t *)&v191[96 * v23 + 68];
    if (v22 != 1)
      v85 = (uint64_t *)v189 + 1;
    v86 = *v85;
    if (*v85)
    {
      v87 = (unint64_t *)&v191[96 * v23 + 52];
      if (v22 != 1)
        v87 = (unint64_t *)&v188 + 1;
      if (storeFileContents(a4, v86, *v87))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffWithCache.c", (uint64_t)"BXDiffWithCache", 340, 91, 0, "writing patch to disk", v88, v89, v160);
        v82 = 0;
      }
      else
      {
        v82 = 1;
      }
      if (v174 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Stored patch: %s\n", a4);
      v81 = 1;
    }
    else
    {
      v81 = 0;
      v82 = 1;
    }
    v90 = &v190[96 * v23];
    v91 = v90 + 56;
    if (v22 != 1)
      v91 = (_QWORD *)&v188 + 1;
    *a8 = *v91;
    v92 = v90 + 64;
    if (v22 != 1)
      v92 = v189;
    *a9 = *v92;
    if (v15)
    {
LABEL_83:
      v83 = (void **)v192;
      do
      {
        free(*v83);
        free(*(v83 - 1));
        v83 += 12;
        --v15;
      }
      while (v15);
    }
  }
  if (v82)
    return v81;
  else
    return 0xFFFFFFFFLL;
}

size_t pc_log_error(uint64_t a1, uint64_t a2, __int16 a3, int a4, int a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  _WORD *v13;
  char *v14;
  size_t v15;
  char __str[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  bzero(__str, 0x400uLL);
  v13 = (_WORD *)(((a3 & 0x3FFF) << 10) | (a4 << 24) | a5 & 0x3FF | 0x80000000);
  if (a5 >= 1)
  {
    v14 = strerror(a5);
    snprintf(__str, 0x400uLL, "%s: ", v14);
  }
  v15 = strlen(__str);
  vsnprintf(&__str[v15], 1024 - v15, a6, &a9);
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    pc_log_error_cold_1((uint64_t)__str, (int)v13);
  return ParallelCompressionUpdateError(v13, (size_t)__str);
}

uint64_t pc_log_warning(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12;
  size_t v13;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  char *v18;
  char __s[1024];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x400uLL);
  v12 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
  v13 = strlen(__s);
  vsnprintf(&__s[v13], 1024 - v13, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    v16 = v12;
    v17 = 2080;
    v18 = __s;
    _os_log_impl(&dword_2063DA000, MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO, "[0x%08x](warning) %s", buf, 0x12u);
  }
  return ParallelCompressionUpdateWarning(v12, __s);
}

void pc_log_info(uint64_t a1, uint64_t a2, __int16 a3, int a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v12;
  uint8_t buf[4];
  unsigned int v14;
  __int16 v15;
  char *v16;
  char __s[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x400uLL);
  v12 = strlen(__s);
  vsnprintf(&__s[v12], 1024 - v12, a5, &a9);
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109378;
    v14 = ((a3 & 0x3FFF) << 10) | (a4 << 24) | 0x80000000;
    v15 = 2080;
    v16 = __s;
    _os_log_impl(&dword_2063DA000, MEMORY[0x24BDACB70], OS_LOG_TYPE_INFO, "[0x%08x] %s", buf, 0x12u);
  }
}

uint64_t pc_info(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v10;
  FILE **v11;
  time_t v13;
  char __s[16];
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v13 = 0;
  *(_OWORD *)__s = 0u;
  v15 = 0u;
  time(&v13);
  ctime_r(&v13, __s);
  v10 = strlen(__s);
  if (v10)
    __s[v10 - 1] = 0;
  v11 = (FILE **)MEMORY[0x24BDAC8D8];
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%s] ", __s);
  return vfprintf(*v11, a1, &a9);
}

_BYTE *filePatchCacheOpen(const char *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  __int16 v7;
  _BYTE *v8;
  const char *v10;
  size_t v11;
  size_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char *v29;
  stat v30;
  char __s[1024];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (strncmp(a1, "file:", 5uLL))
  {
    LOBYTE(v29) = (_BYTE)a1;
    v6 = "invalid cache url: %s";
    v7 = 178;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheOpen", v7, 9, 0, v6, v4, v5, (char)v29);
    return 0;
  }
  bzero(__s, 0x400uLL);
  v10 = a1 + 5;
  if (!realpath_DARWIN_EXTSN(v10, __s))
  {
    LOBYTE(v29) = (_BYTE)v10;
    v6 = "invalid cache directory: %s";
    v7 = 182;
    goto LABEL_3;
  }
  v11 = strlen(__s);
  if (v11 - 927 <= 0xFFFFFFFFFFFFFBFELL)
  {
    v29 = __s;
    v6 = "File patch cache dir name is too long: %s";
    v7 = 186;
    goto LABEL_3;
  }
  v12 = v11;
  memset(&v30, 0, sizeof(v30));
  if (stat(__s, &v30))
  {
    v13 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheOpen", 188, 9, v13, "%s", v14, v15, (char)__s);
    return 0;
  }
  if ((v30.st_mode & 0xF000) != 0x4000)
  {
    v29 = __s;
    v6 = "File patch cache path is not a directory: %s";
    v7 = 189;
    goto LABEL_3;
  }
  v16 = malloc(0x418uLL);
  v8 = v16;
  if (v16)
  {
    bzero(v16, 0x418uLL);
    __memcpy_chk();
    do
    {
      v24 = v12;
      if (!v12)
        break;
      --v12;
    }
    while (v8[v24 + 3] == 47);
    v8[v24 + 4] = 0;
    *((_QWORD *)v8 + 129) = v24;
    *((_DWORD *)v8 + 260) = a2;
    if (a2 >= 1)
      pc_info("Opening file patch cache in directory: %s\n", v17, v18, v19, v20, v21, v22, v23, (_BYTE)v8 + 4);
  }
  else
  {
    v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheOpen", 193, 9, *v25, "malloc", v26, v27, v28);
  }
  return v8;
}

uint64_t filePatchCacheClose(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a1[260] >= 1)
    pc_info("Closing file patch cache in directory: %s\n", a2, a3, a4, a5, a6, a7, a8, (_BYTE)a1 + 4);
  free(a1);
  return 0;
}

uint64_t filePatchCacheLookup(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, unint64_t *a5, int a6, unint64_t a7)
{
  uint64_t v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  int FileContents;
  unint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  time_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  int v33;
  int v34;
  ssize_t v35;
  std::error_code *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  std::error_code *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  char v50;
  _QWORD __buf[2];
  std::__fs::filesystem::path __from;
  std::__fs::filesystem::path __to;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  *a4 = 0;
  *a5 = 0;
  bzero(&__to, 0x400uLL);
  v14 = *(_QWORD *)(a1 + 1032);
  __memcpy_chk();
  v15 = (char *)&__to + v14;
  *(_OWORD *)(v15 + 5) = *(_OWORD *)a3;
  *(_OWORD *)(v15 + 21) = *(_OWORD *)(a3 + 16);
  v16 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v15 + 46) = *(_OWORD *)a2;
  *v15 = 47;
  *(_WORD *)(v15 + 1) = *(_WORD *)a3;
  v15[3] = *(_BYTE *)(a3 + 2);
  v15[4] = 47;
  *(_QWORD *)(v15 + 37) = *(_QWORD *)(a3 + 32);
  v15[45] = 47;
  *(_OWORD *)(v15 + 62) = v16;
  v17 = v14 + 86;
  *(_QWORD *)(v15 + 78) = *(_QWORD *)(a2 + 32);
  __to.__pn_.__r_.__value_.__s.__data_[v17] = 0;
  FileContents = loadFileContentsEx((const char *)&__to, a4, a5);
  if (FileContents < 0)
    return 0xFFFFFFFFLL;
  if (!a6)
  {
    v31 = (_QWORD *)*a4;
    if (*a4 && *v31 == 0x5F44414F4C594150)
      return 1;
    free(v31);
    v32 = 0;
    *a4 = 0;
    *a5 = 0;
    return v32;
  }
  if (!FileContents)
    makePath((const char *)&__to, v17);
  v19 = 0;
  v20 = 10000000;
  while (1)
  {
    v21 = (_QWORD *)*a4;
    if (!*a4)
      break;
    if (*v21 == 0x5F44414F4C594150)
      return 1;
    if (*v21 != 0x5F474E49444E4550)
      break;
    v22 = time(0);
    v23 = v21[1];
    free((void *)*a4);
    *a4 = 0;
    *a5 = 0;
    if (v19 >= a7 || 1000000 * (v22 - v23) >= a7)
    {
      if (*(int *)(a1 + 1040) < 1)
      {
        v21 = 0;
      }
      else
      {
        pc_info("Cache miss after PENDING timeout: %s\n", v24, v25, v26, v27, v28, v29, v30, (char)&__to);
        v21 = (_QWORD *)*a4;
      }
      break;
    }
    if (*(int *)(a1 + 1040) >= 1 && v19 >= v20)
    {
      pc_info("Waiting for PENDING patch (%llu s): %s\n", v24, v25, v26, v27, v28, v29, v30, v19 / 0xF4240);
      v20 *= 2;
    }
    v19 += 500000;
    usleep(0x7A120u);
    if ((loadFileContentsEx((const char *)&__to, a4, a5) & 0x80000000) != 0)
      return 0xFFFFFFFFLL;
  }
  free(v21);
  *a4 = 0;
  *a5 = 0;
  bzero(&__from, 0x400uLL);
  __buf[0] = 0x5F474E49444E4550;
  __buf[1] = time(0);
  v33 = openEntryTemp(a1, (__int128 *)a2, (__int16 *)a3, (char *)&__from);
  if (v33 < 0)
    return 0xFFFFFFFFLL;
  v34 = v33;
  v35 = write(v33, __buf, 0x10uLL);
  close(v34);
  if (v35 == 16)
  {
    rename(&__from, &__to, v36);
    if (!v40)
      return 0;
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 151, 9, "Moving %s to %s (1st attempt)", v37, v38, v39, (char)&__from);
    rename(&__from, &__to, v41);
    if (!v45)
      return 0;
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 153, 9, "Moving %s to %s (2nd attempt)", v42, v43, v44, (char)&__from);
    v32 = 0;
  }
  else
  {
    v47 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheLookup", 331, 9, *v47, "writing PENDING in cache entry failed", v48, v49, v50);
    v32 = 0xFFFFFFFFLL;
  }
  unlink((const char *)&__from);
  return v32;
}

uint64_t loadFileContentsEx(const char *a1, _QWORD *a2, unint64_t *a3)
{
  int v5;
  int v6;
  unint64_t st_size;
  char *v8;
  uint64_t v9;
  unint64_t v11;
  ssize_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  timeval v19;
  stat v20;
  timeval v21;
  timeval v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  memset(&v20, 0, sizeof(v20));
  v5 = open(a1, 0);
  if (v5 < 0)
  {
    v8 = 0;
    v9 = 0;
    goto LABEL_8;
  }
  v6 = v5;
  if (fstat(v5, &v20) || (st_size = v20.st_size, v20.st_size < 8))
  {
    v8 = 0;
  }
  else
  {
    v8 = (char *)malloc(v20.st_size);
    if (!v8)
    {
      v13 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"loadFileContentsEx", 51, 9, *v13, "malloc", v14, v15, v19.tv_sec);
      v9 = 0xFFFFFFFFLL;
      goto LABEL_6;
    }
    v11 = 0;
    while (st_size > v11)
    {
      v12 = read(v6, &v8[v11], st_size - v11);
      v11 += v12 & ~(v12 >> 63);
      if (v12 <= 0)
        goto LABEL_5;
    }
    v19 = (timeval)0;
    if (!gettimeofday(&v19, 0))
    {
      v21 = v19;
      v22 = v19;
      futimes(v6, &v21);
      close(v6);
      v9 = 1;
      goto LABEL_9;
    }
    v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"loadFileContentsEx", 66, 9, *v16, "gettimeofday", v17, v18, v19.tv_sec);
  }
LABEL_5:
  v9 = 0;
LABEL_6:
  close(v6);
LABEL_8:
  free(v8);
  v8 = 0;
  st_size = 0;
LABEL_9:
  *a2 = v8;
  *a3 = st_size;
  return v9;
}

uint64_t openEntryTemp(uint64_t a1, __int128 *a2, __int16 *a3, char *__dst)
{
  uint64_t v8;
  char *v9;
  __int16 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  char *v16;
  int v17;
  int v18;
  useconds_t v19;
  uint64_t result;
  size_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;

  memcpy(__dst, (const void *)(a1 + 4), *(_QWORD *)(a1 + 1032));
  v8 = *(_QWORD *)(a1 + 1032);
  v9 = &__dst[v8];
  *v9 = 47;
  v10 = *a3;
  v9[3] = *((_BYTE *)a3 + 2);
  *(_WORD *)(v9 + 1) = v10;
  v9[4] = 47;
  v11 = *((_QWORD *)a3 + 4);
  v12 = *((_OWORD *)a3 + 1);
  *(_OWORD *)(v9 + 5) = *(_OWORD *)a3;
  *(_OWORD *)(v9 + 21) = v12;
  *(_QWORD *)(v9 + 37) = v11;
  v9[45] = 47;
  v14 = *a2;
  v13 = a2[1];
  v15 = *((_QWORD *)a2 + 4);
  v9[86] = 0;
  v16 = &__dst[v8 + 86];
  *((_QWORD *)v16 - 1) = v15;
  *(_OWORD *)(v16 - 40) = v14;
  *(_OWORD *)(v16 - 24) = v13;
  LODWORD(a3) = getpid();
  LODWORD(a3) = (_DWORD)a3 + time(0);
  v17 = 0;
  v18 = (_DWORD)a3 + pthread_self();
  v19 = 250000;
  while (1)
  {
    v18 = 1103515245 * v18 + 12345;
    snprintf(v16, 938 - v8, ".%08x", v18);
    result = open(__dst, 2561, 384);
    if ((result & 0x80000000) == 0)
      break;
    if (*__error() != 17)
    {
      if (v17 == 10)
      {
        v22 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"openEntryTemp", 129, 9, *v22, "Retry limit reached: %s", v23, v24, (char)__dst);
        return 0xFFFFFFFFLL;
      }
      usleep(v19);
      v19 *= 2;
      ++v17;
      v21 = strlen(__dst);
      statPath(__dst, v21);
    }
  }
  return result;
}

uint64_t filePatchCacheUpdate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v10;
  char *v11;
  __int128 v12;
  int v13;
  int v14;
  unint64_t v15;
  ssize_t v16;
  uint64_t v17;
  uint64_t v18;
  std::error_code *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  std::error_code *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  std::__fs::filesystem::path __from;
  std::__fs::filesystem::path __to;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  bzero(&__to, 0x400uLL);
  bzero(&__from, 0x400uLL);
  v10 = *(_QWORD *)(a1 + 1032);
  __memcpy_chk();
  v11 = (char *)&__to + v10;
  *(_OWORD *)(v11 + 5) = *(_OWORD *)a3;
  *(_OWORD *)(v11 + 21) = *(_OWORD *)(a3 + 16);
  v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v11 + 46) = *(_OWORD *)a2;
  *v11 = 47;
  *(_WORD *)(v11 + 1) = *(_WORD *)a3;
  v11[3] = *(_BYTE *)(a3 + 2);
  v11[4] = 47;
  *(_QWORD *)(v11 + 37) = *(_QWORD *)(a3 + 32);
  v11[45] = 47;
  *(_OWORD *)(v11 + 62) = v12;
  *(_QWORD *)(v11 + 78) = *(_QWORD *)(a2 + 32);
  v11[86] = 0;
  v13 = openEntryTemp(a1, (__int128 *)a2, (__int16 *)a3, (char *)&__from);
  if (v13 < 0)
    return 0xFFFFFFFFLL;
  v14 = v13;
  if (a5)
  {
    v15 = 0;
    while (1)
    {
      v16 = write(v14, (const void *)(a4 + v15), a5 - v15);
      if (v16 < 0)
      {
        v30 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheUpdate", 369, 9, v30, "%s", v31, v32, (char)&__from);
        goto LABEL_14;
      }
      if (!v16)
        break;
      v15 += v16;
      if (v15 >= a5)
        goto LABEL_7;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"filePatchCacheUpdate", 370, 9, 0, "write error: %s", v17, v18, (char)&__from);
LABEL_14:
    close(v14);
    v29 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_7:
    close(v14);
    rename(&__from, &__to, v19);
    if (v23)
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 151, 9, "Moving %s to %s (1st attempt)", v20, v21, v22, (char)&__from);
      rename(&__from, &__to, v24);
      if (v28)
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/FilePatchCache.c", (uint64_t)"installFile", 153, 9, "Moving %s to %s (2nd attempt)", v25, v26, v27, (char)&__from);
        unlink((const char *)&__from);
      }
    }
    v29 = 0;
  }
  unlink((const char *)&__from);
  return v29;
}

AAByteStream_impl *aaForkOutputStreamOpen(uint64_t a1, _QWORD *a2)
{
  AAByteStream_impl *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t i;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  char v38;

  v4 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  v5 = calloc(1uLL, 0x20050uLL);
  v8 = v5;
  if (!v4 || !v5)
  {
    v17 = *__error();
    v18 = "malloc";
    v19 = 405;
LABEL_13:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", v19, 136, v17, v18, v6, v7, v38);
    goto LABEL_14;
  }
  if (!*(_QWORD *)(a1 + 40) || !*(_QWORD *)(a1 + 32))
  {
    v18 = "stream not compatible\n";
    v19 = 406;
    v17 = 0;
    goto LABEL_13;
  }
  v9 = v5 + 16385;
  AACustomByteStreamSetData(v4, v5);
  AACustomByteStreamSetWriteProc(v4, (AAByteStreamWriteProc)ForkOutputStreamWrite);
  AACustomByteStreamSetPWriteProc(v4, (AAByteStreamPWriteProc)ForkOutputStreamPWrite);
  AACustomByteStreamSetCancelProc(v4, (AAByteStreamCancelProc)ForkOutputStreamCancel);
  AACustomByteStreamSetCloseProc(v4, (AAByteStreamCloseProc)ForkOutputStreamClose);
  *v9 = a1;
  v8[16386] = a2;
  if (a2[258])
    v10 = a2[270] + 1;
  else
    v10 = a2[270];
  v8[16390] = v10;
  if (is_mul_ok(v10, 0x30uLL) && 48 * v10 < 0x2000000001)
  {
    v16 = calloc(v10, 0x30uLL);
  }
  else
  {
    v13 = __error();
    v16 = 0;
    *v13 = 12;
  }
  v8[16389] = v16;
  *(_OWORD *)(v8 + 16391) = 0u;
  *((_DWORD *)v8 + 32786) = 0;
  if (!v16)
  {
    v17 = *__error();
    v18 = "aaCalloc";
    v19 = 423;
    goto LABEL_13;
  }
  v28 = 0;
  v29 = a2[270];
  v30 = a2[258];
  v31 = 1;
  v32 = v16;
  while (1)
  {
    if (v29)
    {
      v33 = (_QWORD *)a2[268];
      for (i = v29; i; --i)
      {
        v35 = v33[51];
        if ((v31 & 1) != 0)
        {
          if ((v35 & 1) != 0)
          {
            *v32 = v33;
            v32[1] = v28;
            v36 = (_QWORD *)v33[48];
            v37 = v33[49];
            v32[2] = 0;
            v32[3] = v37;
            v32[4] = *v36;
LABEL_26:
            v32[5] = v33[5];
            v28 += v37;
            v8[16392] = v28;
            v32 += 6;
          }
        }
        else if ((v35 & 2) != 0)
        {
          v32[1] = v28;
          v32[2] = 0;
          v37 = v33[4];
          v32[3] = v37;
          goto LABEL_26;
        }
        v33 += 55;
      }
    }
    if ((v31 & 1) == 0)
      break;
    v31 = 0;
    v14 = v28;
    v15 = v28;
    if (v30)
    {
      v31 = 0;
      v32[1] = v28;
      v32[2] = 0;
      v32[3] = v30;
      v32[5] = 0;
      v14 = v30 + v28;
      v32 += 6;
      v15 = v28;
      v28 = v14;
      v8[16392] = v14;
    }
  }
  a2[257] = v15;
  a2[259] = v14;
  if (v32 == &v16[6 * v8[16390]])
  {
    a2[260] = v28;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"aaForkOutputStreamOpen", 477, 136, 0, "bad variant", v11, v12, v38);
    a2[260] = v8[16392];
LABEL_14:
    free(v4);
    ForkOutputStreamClose((void **)v8, v20, v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return v4;
}

uint64_t ForkOutputStreamWrite(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD **v8;
  const char *v9;
  __int16 v10;
  unint64_t v11;
  const uint8_t *v13;
  unint64_t v14;
  _QWORD *v15;
  size_t *v16;
  size_t v17;
  size_t *v18;
  unint64_t v19;
  size_t v20;
  size_t *v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  size_t v32;
  _DWORD *v33;
  size_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  size_t v39;
  size_t v40;
  size_t *v41;
  size_t *v42;
  _QWORD *v43;
  uint64_t v44;
  size_t v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _DWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  __int16 v77;
  const char *v78;
  BOOL v79;
  size_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint8_t *v84;
  size_t v85;
  uint64_t v86;
  BOOL v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  size_t v92;
  _DWORD *v93;
  uint64_t v94;
  uint64_t v95;
  _DWORD *v96;
  _DWORD *v97;
  int *v98;
  int v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _DWORD *v104;
  size_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t *v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  uint64_t v115;
  _QWORD *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  _QWORD *v121;
  _DWORD *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint8_t *v130;
  unint64_t v131;
  uint64_t v132;
  const char *v133;
  __int16 v134;
  int *v135;
  uint64_t v136;
  uint64_t v137;
  char v138;
  void *__dst;
  size_t *v140;
  unint64_t v141;
  unint64_t v142;
  uint64_t *v144;
  unint64_t v145;
  _QWORD *v147;
  size_t *v148;
  _QWORD *v149;
  size_t v150;
  uint8_t *dst_buffer;
  size_t *v152;
  _QWORD *v153;
  uint64_t *v154;
  _QWORD *v155;
  unint64_t v156;
  uint64_t *v157;

  v8 = (_QWORD **)(a1 + 32770);
  if (a1[32786])
  {
    v9 = "bad write mode";
    v10 = 198;
    goto LABEL_3;
  }
  v11 = a3;
  if (!a3)
    return v11;
  v13 = (const uint8_t *)a1;
  v14 = 0;
  dst_buffer = (uint8_t *)a1 + 65537;
  __dst = (char *)a1 + 65538;
  v155 = a1 + 32770;
  while (1)
  {
    v15 = v8[6];
    if (v15 == v8[5])
    {
      v9 = "segment out of range";
      v10 = 202;
      goto LABEL_3;
    }
    v153 = v8[4];
    v16 = &v153[6 * (_QWORD)v15];
    v18 = v16 + 2;
    v17 = v16[2];
    v19 = v11 - v14;
    v21 = v16 + 3;
    v20 = v16[3];
    if (v11 - v14 >= 0x10000 - (unint64_t)(unsigned __int16)v17)
      v19 = 0x10000 - (unsigned __int16)v17;
    if (v20 - v17 >= v19)
      v22 = v19;
    else
      v22 = v20 - v17;
    memcpy((void *)&v13[(unsigned __int16)v17], (const void *)(a2 + v14), v22);
    v23 = v22 + *v18;
    v152 = v16 + 2;
    *v18 = v23;
    v149 = v16 + 3;
    v24 = *v21;
    if (v23 == *v21)
      v8[6] = (_QWORD *)((char *)v8[6] + 1);
    v25 = (unsigned __int16)v23;
    if ((_WORD)v23)
    {
      if (v23 < v24)
        goto LABEL_134;
    }
    else
    {
      v25 = 0x10000;
    }
    v150 = v22;
    v26 = (_QWORD *)*v16;
    if (!*v16)
    {
      v30 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        v31 = 0;
        v32 = v23 - v25 + v153[6 * (_QWORD)v15 + 5];
        v33 = a1;
        v34 = v25;
        while (1)
        {
          v35 = (*(uint64_t (**)(_QWORD, _DWORD *, size_t, size_t))(v30 + 40))(*(_QWORD *)v30, v33, v34, v32);
          if (v35 < 1)
            break;
          v33 = (_DWORD *)((char *)v33 + v35);
          v31 += v35;
          v32 += v35;
          v34 -= v35;
          if (!v34)
            goto LABEL_85;
        }
        v31 = v35;
      }
      else
      {
        v31 = -1;
      }
LABEL_85:
      v87 = v25 == v31;
      v8 = (_QWORD **)v155;
      v13 = (const uint8_t *)a1;
      v22 = v150;
      if (!v87)
      {
        v9 = "aaByteStreamPWriteExpected";
        v10 = 230;
        goto LABEL_3;
      }
      goto LABEL_134;
    }
    v27 = v26[7];
    v145 = v14;
    v148 = &v153[6 * (_QWORD)v15];
    if ((unint64_t)v8[3] < v27)
    {
      v8[3] = (_QWORD *)v27;
      if (24 * v27 >= 0x2000000001)
      {
        *__error() = 12;
      }
      else
      {
        v28 = v8[2];
        v29 = realloc(v28, 24 * v27);
        if (v29)
        {
          v8[2] = v29;
          v23 = *v152;
          goto LABEL_30;
        }
        free(v28);
      }
      v8[2] = 0;
      v9 = "aaReallocf";
      v10 = 240;
      goto LABEL_3;
    }
    v29 = v8[2];
LABEL_30:
    v36 = (v23 - 1) >> 16;
    v37 = v26[48] + 12 * v36;
    v156 = v36;
    v38 = &v29[3 * v36];
    v39 = compression_encode_buffer(dst_buffer, 0x10000uLL, v13, v25, 0, (compression_algorithm)LODWORD(v8[1][*((unsigned __int8 *)v26 + 432)]));
    if (v39 - 1 >= v25)
      v40 = v25 + 1;
    else
      v40 = v39;
    v38[1] = v40;
    v41 = v38 + 1;
    v144 = v38;
    v38[2] = v40;
    v42 = v38 + 2;
    v43 = &v153[6 * (_QWORD)v15];
    v44 = v43[4];
    v157 = v43 + 4;
    v45 = *(_QWORD *)v37 + *(unsigned int *)(v37 + 8);
    v46 = v40;
    if (v44 + v40 < v45)
    {
      v46 = v45 - v44;
      *v42 = v45 - v44;
    }
    if (v46 == v25 + 1)
    {
      *v41 = v25 + 1;
      *dst_buffer = BYTE4(v8[1][*((unsigned __int8 *)v26 + 432)]);
      memcpy(__dst, a1, v25);
      v40 = *v41;
      v46 = *v42;
    }
    bzero(&dst_buffer[v40], v46 - v40);
    v47 = v26[50];
    v48 = *v157;
    v49 = v47 - *v157;
    v50 = *v42 - v49;
    v147 = v15;
    if (*v42 > v49)
      break;
LABEL_76:
    *v144 = v48;
    v80 = *v42;
    v81 = (uint64_t)*v8;
    if ((*v8)[5])
    {
      if (!v80)
        goto LABEL_89;
      v82 = 0;
      v83 = v153[6 * (_QWORD)v15 + 5] + v48;
      v84 = dst_buffer;
      v85 = *v42;
      while (1)
      {
        v86 = (*(uint64_t (**)(_QWORD, uint8_t *, size_t, uint64_t))(v81 + 40))(*(_QWORD *)v81, v84, v85, v83);
        if (v86 < 1)
          break;
        v84 += v86;
        v82 += v86;
        v83 += v86;
        v85 -= v86;
        if (!v85)
          goto LABEL_88;
      }
      v82 = v86;
    }
    else
    {
      v82 = -1;
    }
LABEL_88:
    v8 = (_QWORD **)v155;
    v15 = v147;
    v16 = v148;
    if (v80 != v82)
    {
      v9 = "aaByteStreamPWriteExpected";
      v10 = 287;
      goto LABEL_3;
    }
LABEL_89:
    *v157 += v80;
    v22 = v150;
    v13 = (const uint8_t *)a1;
    v14 = v145;
    if (*v152 == *v149)
    {
      v88 = (_QWORD *)*v16;
      v89 = *(_QWORD *)(*v16 + 408);
      v90 = *(_QWORD *)(*v16 + 56);
      v91 = 2 * v90;
      if ((v89 & 4) == 0)
        v91 = v90 + 1;
      v92 = 4 * v91;
      if ((unint64_t)(4 * v91) >= 0x2000000001)
      {
        *__error() = 12;
LABEL_148:
        v135 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", 81, 136, *v135, "aaMalloc", v136, v137, v138);
        v96 = 0;
        goto LABEL_142;
      }
      v93 = malloc(v92);
      if (!v93)
        goto LABEL_148;
      v96 = v93;
      if ((v89 & 4) != 0)
      {
        v107 = (uint64_t)*v8;
        if ((*v8)[5])
        {
          v108 = 0;
          v109 = &v153[6 * (_QWORD)v147 + 5];
          v110 = v88 + 41;
          v111 = *v109 + v88[50] - 50;
          v112 = 50;
          while (1)
          {
            v113 = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t))(v107 + 40))(*(_QWORD *)v107, v110, v112, v111);
            if (v113 < 1)
              break;
            v110 = (_QWORD *)((char *)v110 + v113);
            v108 += v113;
            v111 += v113;
            v112 -= v113;
            if (!v112)
            {
              if (v108 != 50)
                break;
              v114 = (_QWORD *)*v155;
              if (*(_QWORD *)(*v155 + 40))
              {
                v115 = 0;
                v116 = v88 + 8;
                v117 = *v109;
                v118 = 264;
                while (1)
                {
                  v119 = ((uint64_t (*)(_QWORD, _QWORD *, uint64_t, uint64_t))v114[5])(*v114, v116, v118, v117);
                  if (v119 < 1)
                    break;
                  v116 = (_QWORD *)((char *)v116 + v119);
                  v115 += v119;
                  v117 += v119;
                  v118 -= v119;
                  if (!v118)
                  {
                    if (v115 != 264)
                      break;
                    v120 = v88[7];
                    v8 = (_QWORD **)v155;
                    if (v120)
                    {
                      v121 = (_QWORD *)(v155[2] + 16);
                      v122 = v96 + 1;
                      do
                      {
                        *(v122 - 1) = *((_DWORD *)v121 - 4) - 260;
                        v123 = *v121;
                        v121 += 3;
                        *v122 = v123;
                        v122 += 2;
                        --v120;
                      }
                      while (v120);
                    }
                    v101 = *v109 + 264;
                    v14 = v145;
                    goto LABEL_99;
                  }
                }
              }
              v133 = "aaByteStreamPWriteExpected";
              v134 = 94;
              goto LABEL_141;
            }
          }
        }
        v133 = "aaByteStreamPWriteExpected";
        v134 = 89;
LABEL_141:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_write_index", v134, 136, 0, v133, v94, v95, v138);
LABEL_142:
        free(v96);
        v9 = "fork_write_index";
        v10 = 294;
        goto LABEL_3;
      }
      if (v90)
      {
        v97 = v93 + 1;
        v98 = (int *)(v8[2] + 2);
        do
        {
          v99 = *(v98 - 4);
          *(v97 - 1) = v99;
          v100 = *v98;
          v98 += 6;
          *v97++ = v100 + v99;
          --v90;
        }
        while (v90);
      }
      v101 = v153[6 * (_QWORD)v15 + 5];
      v14 = v145;
LABEL_99:
      v102 = (uint64_t)*v8;
      if (!(*v8)[5])
        goto LABEL_149;
      if (v92)
      {
        v103 = 0;
        v104 = v96;
        v105 = v92;
        while (1)
        {
          v106 = (*(uint64_t (**)(_QWORD, _DWORD *, size_t, uint64_t))(v102 + 40))(*(_QWORD *)v102, v104, v105, v101);
          if (v106 < 1)
            break;
          v104 = (_DWORD *)((char *)v104 + v106);
          v103 += v106;
          v101 += v106;
          v105 -= v106;
          if (!v105)
            goto LABEL_120;
        }
        v103 = v106;
LABEL_120:
        v87 = v92 == v103;
        v8 = (_QWORD **)v155;
        v14 = v145;
        if (!v87)
        {
LABEL_149:
          v133 = "aaByteStreamPWriteExpected";
          v134 = 117;
          goto LABEL_141;
        }
      }
      v124 = v88[4];
      v125 = v88[50];
      v126 = v124 - v125;
      if (v124 != v125)
      {
        if (v126 >= 0x1000)
        {
          v133 = "too much padding";
          v134 = 123;
          goto LABEL_141;
        }
        bzero(dst_buffer, v124 - v125);
        v127 = (uint64_t)*v8;
        if (!(*v8)[5])
          goto LABEL_150;
        if (v126)
        {
          v128 = 0;
          v129 = v153[6 * (_QWORD)v147 + 5] + v88[50];
          v130 = dst_buffer;
          v131 = v126;
          while (1)
          {
            v132 = (*(uint64_t (**)(_QWORD, uint8_t *, unint64_t, uint64_t))(v127 + 40))(*(_QWORD *)v127, v130, v131, v129);
            if (v132 < 1)
              break;
            v130 += v132;
            v128 += v132;
            v129 += v132;
            v131 -= v132;
            if (!v131)
              goto LABEL_131;
          }
          v128 = v132;
LABEL_131:
          v87 = v126 == v128;
          v8 = (_QWORD **)v155;
          v14 = v145;
          if (!v87)
          {
LABEL_150:
            v133 = "aaByteStreamPWriteExpected";
            v134 = 126;
            goto LABEL_141;
          }
        }
      }
      free(v96);
      v11 = a3;
      v13 = (const uint8_t *)a1;
      v22 = v150;
    }
LABEL_134:
    v14 += v22;
    if (v14 >= v11)
      return v11;
  }
  v51 = (_DWORD)v153 + 48 * (_DWORD)v15 + 40;
  v154 = &v153[6 * (_QWORD)v15 + 5];
  v52 = v156;
  v140 = v42;
  do
  {
    if (!v52)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", 142, 136, 0, "realignment failed", a7, a8, v138);
      goto LABEL_139;
    }
    v53 = v8[2];
    v54 = &v53[3 * v52 - 3];
    v57 = v54[2];
    v55 = v54 + 2;
    v56 = v57;
    v58 = *(v55 - 1);
    v59 = v57 - v58;
    v60 = v50 - (v57 - v58);
    if (v50 > v57 - v58)
    {
      *v55 = v58;
      --v52;
      goto LABEL_73;
    }
    *v55 = v56 - v50;
    v48 = v53[3 * v52 - 3] + v56 - v50;
    *v157 = v48;
    if (v52 >= v156)
      goto LABEL_76;
    v141 = v59;
    v142 = v50;
    while (1)
    {
      v61 = &v8[2][3 * v52];
      v62 = *v154;
      v63 = v61[1];
      v64 = *v61 + *v154;
      v65 = (uint64_t)*v8;
      if ((*v8)[11])
      {
        if (v63 != aaByteStreamSimulate(*v8))
        {
          v77 = 173;
          v78 = "aaByteStreamSimulate";
          goto LABEL_72;
        }
        goto LABEL_59;
      }
      if (*(_QWORD *)(v65 + 32))
      {
        if (!v63)
        {
          if (!*(_QWORD *)(v65 + 40))
            goto LABEL_70;
          goto LABEL_68;
        }
        v66 = 0;
        v67 = a1;
        v68 = v61[1];
        while (1)
        {
          v69 = (*(uint64_t (**)(_QWORD, _DWORD *, uint64_t, uint64_t))(v65 + 32))(*(_QWORD *)v65, v67, v68, v64);
          if (v69 < 0)
            break;
          if (v69)
          {
            v67 = (_DWORD *)((char *)v67 + v69);
            v66 += v69;
            v64 += v69;
            v68 -= v69;
            if (v68)
              continue;
          }
          goto LABEL_58;
        }
        v66 = v69;
      }
      else
      {
        v66 = -1;
      }
LABEL_58:
      v8 = (_QWORD **)v155;
      if (v63 != v66)
        break;
LABEL_59:
      v70 = (uint64_t)*v8;
      if ((*v8)[5])
      {
        if (!v63)
          goto LABEL_68;
        v71 = 0;
        v72 = v62 + v48;
        v73 = a1;
        v74 = v63;
        while (1)
        {
          v75 = (*(uint64_t (**)(_QWORD, _DWORD *, uint64_t, uint64_t))(v70 + 40))(*(_QWORD *)v70, v73, v74, v72);
          if (v75 < 1)
            break;
          v73 = (_DWORD *)((char *)v73 + v75);
          v71 += v75;
          v72 += v75;
          v74 -= v75;
          if (!v74)
            goto LABEL_67;
        }
        v71 = v75;
      }
      else
      {
        v71 = -1;
      }
LABEL_67:
      v8 = (_QWORD **)v155;
      if (v63 != v71)
      {
LABEL_70:
        v77 = 180;
        v78 = "aaByteStreamPWriteExpected";
        goto LABEL_72;
      }
LABEL_68:
      v76 = *v157;
      *v61 = *v157;
      v48 = v76 + v63;
      *v157 = v76 + v63;
      if (++v52 == v156)
        goto LABEL_75;
    }
    v77 = 176;
    v78 = "aaByteStreamPReadExpected";
LABEL_72:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"fork_realign", v77, 136, 0, v78, a7, a8, v138);
    v51 = -1;
    v50 = v142;
    v11 = a3;
    v60 = v142;
    v15 = v147;
    v16 = v148;
    v42 = v140;
    v59 = v141;
LABEL_73:
    v79 = v50 > v59;
    v50 = v60;
  }
  while (v79);
  if ((v51 & 0x80000000) == 0)
  {
LABEL_75:
    v48 = *v157;
    v11 = a3;
    v15 = v147;
    v16 = v148;
    v42 = v140;
    goto LABEL_76;
  }
LABEL_139:
  v9 = "realign_fork";
  v10 = 279;
LABEL_3:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamWrite", v10, 136, 0, v9, a7, a8, v138);
  return -1;
}

uint64_t ForkOutputStreamPWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v31;
  const char *v32;
  __int16 v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;

  v8 = a4;
  v9 = (uint64_t *)(a1 + 131080);
  if (*(_DWORD *)(a1 + 131144))
  {
LABEL_2:
    v10 = 0;
    if (a3)
    {
      v41 = a3;
      while (1)
      {
        if (v9[7] <= v8)
        {
LABEL_35:
          v32 = "no segment found";
          v33 = 340;
          goto LABEL_48;
        }
        v11 = v9[4];
        v12 = v9[5];
        if (v12 < 2)
        {
          if (!v11)
            goto LABEL_35;
          v13 = 0;
        }
        else
        {
          v13 = 0;
          do
          {
            if (*(_QWORD *)(v11 + 48 * ((v13 + v12) >> 1) + 8) > v8)
              v12 = (v13 + v12) >> 1;
            else
              v13 = (v13 + v12) >> 1;
          }
          while (v13 + 1 < v12);
        }
        if (*(_QWORD *)(v11 + 48 * v13))
        {
          v32 = "compressed fork";
          v33 = 341;
          goto LABEL_48;
        }
        v14 = (_QWORD *)(v11 + 48 * v13);
        v15 = v8 - v14[1];
        v16 = v14[3];
        if (a3 - v10 >= v16 - v15)
          v17 = v16 - v15;
        else
          v17 = a3 - v10;
        v18 = v17 + v14[2];
        v14[2] = v18;
        if (v18 > v16)
        {
          v32 = "too much data";
          v33 = 349;
          goto LABEL_48;
        }
        v19 = *v9;
        if (*(_QWORD *)(*v9 + 40))
        {
          if (!v17)
            goto LABEL_28;
          v20 = 0;
          v21 = a2 + v10;
          v22 = *(_QWORD *)(v11 + 48 * v13 + 40) + v15;
          v23 = v17;
          while (1)
          {
            v24 = (*(uint64_t (**)(_QWORD, unint64_t, unint64_t, unint64_t))(v19 + 40))(*(_QWORD *)v19, v21, v23, v22);
            if (v24 < 1)
              break;
            v21 += v24;
            v20 += v24;
            v22 += v24;
            v23 -= v24;
            if (!v23)
              goto LABEL_27;
          }
          v20 = v24;
        }
        else
        {
          v20 = -1;
        }
LABEL_27:
        a3 = v41;
        if (v17 != v20)
        {
          v32 = "aaByteStreamPWriteExpected";
          v33 = 353;
          goto LABEL_48;
        }
LABEL_28:
        v8 += v17;
        v10 += v17;
        if (v10 >= a3)
          return v10;
      }
    }
    return v10;
  }
  v25 = a1;
  v26 = *(_QWORD *)(a1 + 131112);
  v27 = *(_QWORD *)(a1 + 131128);
  v28 = (_QWORD *)(v26 + 48 * v27);
  v29 = v28[2];
  if (v29 + v28[1] == a4)
    return ForkOutputStreamWrite((_DWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  v31 = (unsigned __int16)v28[2];
  if (!(unsigned __int16)v28[2])
    goto LABEL_46;
  if (*v28)
  {
    v32 = "pending compressed fork";
    v33 = 323;
    goto LABEL_48;
  }
  v34 = *v9;
  if (*(_QWORD *)(*v9 + 40))
  {
    v35 = a3;
    v36 = 0;
    v37 = (v29 & 0xFFFFFFFFFFFF0000) + *(_QWORD *)(v26 + 48 * v27 + 40);
    v38 = (unsigned __int16)v28[2];
    while (1)
    {
      v39 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, unint64_t))(v34 + 40))(*(_QWORD *)v34, v25, v38, v37);
      if (v39 < 1)
        break;
      v25 += v39;
      v36 += v39;
      v37 += v39;
      v38 -= v39;
      if (!v38)
        goto LABEL_45;
    }
    v36 = v39;
LABEL_45:
    a3 = v35;
    if (v31 == v36)
    {
LABEL_46:
      *((_DWORD *)v9 + 16) = 1;
      goto LABEL_2;
    }
  }
  v32 = "aaByteStreamPWriteExpected";
  v33 = 325;
LABEL_48:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamPWrite", v33, 136, 0, v32, a7, a8, a2);
  return -1;
}

void ForkOutputStreamCancel(uint64_t a1)
{
  AAByteStreamCancel(*(AAByteStream *)(a1 + 131080));
}

uint64_t ForkOutputStreamClose(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void **v9;
  _QWORD *v10;
  char *v11;
  _QWORD *v12;
  int v13;
  char v15;

  if (a1)
  {
    v9 = a1 + 16387;
    v10 = a1[16389];
    if (v10)
    {
      v11 = (char *)v9[3];
      if (v11)
      {
        v12 = v10 + 3;
        while (*(v12 - 1) == *v12)
        {
          v12 += 6;
          if (!--v11)
            goto LABEL_7;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageOutputStream.c", (uint64_t)"ForkOutputStreamClose", 382, 136, 0, "data missing", a7, a8, v15);
        v13 = 0;
        v10 = v9[2];
      }
      else
      {
LABEL_7:
        v13 = 1;
      }
      free(v10);
    }
    else
    {
      v13 = 1;
    }
    free(*v9);
    free(a1);
  }
  else
  {
    v13 = 1;
  }
  if (v13)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t DirectoryPatch()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int DefaultNThreads;
  int v9;
  void **v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  const float *v14;
  int8x16_t v15;
  off_t st_size;
  const char *v17;
  __int16 v18;
  int v19;
  char *v20;
  unsigned int v21;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  FILE **v25;
  int v26;
  const char *v27;
  const char *v28;
  const char *v29;
  const char *v30;
  const char *v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  __int16 v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  const char *v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  int *v57;
  stat v58;
  int v59;
  char v60[1024];
  char v61[1024];
  char v62[1024];
  int8x16_t v63;
  __int128 v64;
  int v65;
  int v66;
  void **v67;
  void **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD v72[7];

  v0 = MEMORY[0x24BDAC7A8]();
  v72[4] = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(v0, v1, v2, v3, v4, v5, v6, v7, v49);
  DefaultNThreads = *(_DWORD *)(v0 + 48);
  v9 = *(_DWORD *)(v0 + 52);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  memset(&v58, 0, sizeof(v58));
  memset(v72, 0, 28);
  v57 = 0;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v52 = 0u;
  bzero(&v59, 0x1510uLL);
  v59 = v9;
  v10 = MemBufferCreate(0x40000uLL);
  v67 = v10;
  v11 = MemBufferCreate(0x100000uLL);
  v68 = v11;
  v14 = (const float *)(v0 + 24);
  v15 = (int8x16_t)vld1q_dup_f32(v14);
  v63 = vandq_s8(v15, (int8x16_t)xmmword_20643ED30);
  v64 = *(_OWORD *)(v0 + 28);
  v65 = *(_DWORD *)(v0 + 44);
  v66 = 0;
  if (!v10 || !v11)
  {
    v17 = "allocation";
    v18 = 332;
    goto LABEL_25;
  }
  if (*(_QWORD *)v0)
  {
    if (!realpath_DARWIN_EXTSN(*(const char **)v0, v60))
    {
      v19 = *__error();
      v17 = *(const char **)v0;
      v18 = 339;
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"DirectoryPatch", v18, 25, v19, v17, v12, v13, (char)v50);
      v20 = 0;
LABEL_28:
      v21 = -1;
      goto LABEL_29;
    }
    if (stat(*(const char **)v0, &v58) || (v58.st_mode & 0xF000) != 0x4000)
    {
      v50 = *(const char **)v0;
      v17 = "inPath is not a directory: %s";
      v18 = 340;
      goto LABEL_25;
    }
  }
  if (stat(*(const char **)(v0 + 8), &v58))
    mkdir(*(const char **)(v0 + 8), 0x1EDu);
  if (!realpath_DARWIN_EXTSN(*(const char **)(v0 + 8), v61))
  {
    v19 = *__error();
    v17 = *(const char **)(v0 + 8);
    v18 = 350;
    goto LABEL_27;
  }
  if (stat(*(const char **)(v0 + 8), &v58) || (v58.st_mode & 0xF000) != 0x4000)
  {
    v50 = *(const char **)(v0 + 8);
    v17 = "outPath is not a directory: %s";
    v18 = 351;
    goto LABEL_25;
  }
  if (*(_QWORD *)v0 && !strcmp(v60, v61))
  {
    v17 = "inPath == outPath is not supported";
    v18 = 354;
    goto LABEL_25;
  }
  if (!realpath_DARWIN_EXTSN(*(const char **)(v0 + 16), v62))
  {
    v19 = *__error();
    v17 = *(const char **)(v0 + 16);
    v18 = 357;
    goto LABEL_27;
  }
  if (stat(*(const char **)(v0 + 16), &v58) || (v58.st_mode & 0xF000) != 0x8000)
  {
    v50 = *(const char **)(v0 + 16);
    v17 = "patchFilename is not a regular file: %s";
    v18 = 358;
    goto LABEL_25;
  }
  st_size = v58.st_size;
  if (loadFileSegment(v62, v72, 0x1CuLL, 0))
  {
    v17 = "read patch header";
    v18 = 362;
LABEL_25:
    v19 = 0;
    goto LABEL_27;
  }
  if (v72[0] != 0x3031464649444944)
  {
    v17 = "invalid patch header";
    v18 = 365;
    goto LABEL_25;
  }
  v23 = *(_QWORD *)((char *)&v72[2] + 4);
  v24 = *(_QWORD *)((char *)&v72[1] + 4) + 28 + *(_QWORD *)((char *)&v72[2] + 4);
  if (st_size != *(_QWORD *)((char *)&v72[1] + 4) + 28 && st_size != v24)
  {
    v17 = "invalid patch size";
    v18 = 368;
    goto LABEL_25;
  }
  if (*(_QWORD *)((char *)&v72[2] + 4) && st_size != v24 && (*(_BYTE *)(v0 + 24) & 2) == 0)
  {
    v17 = "patch has been truncated, can't expand archive payload";
    v18 = 369;
    goto LABEL_25;
  }
  v51 = *(_QWORD *)((char *)&v72[1] + 4) + 28 + *(_QWORD *)((char *)&v72[2] + 4);
  if (v9 >= 1)
  {
    v25 = (FILE **)MEMORY[0x24BDAC8D8];
    fwrite("DirectoryPatch:\n", 0x10uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    if (*(_QWORD *)v0)
      fprintf(*v25, "  input directory: %s\n", v60);
    fprintf(*v25, "  output directory: %s\n", v61);
    fprintf(*v25, "  patch file: %s\n", v62);
    fprintf(*v25, "  worker threads: %d\n", DefaultNThreads);
    v26 = *(_DWORD *)(v0 + 24);
    if (v26)
    {
      if ((v26 & 1) != 0)
        v27 = "yes";
      else
        v27 = "no";
      fprintf(*v25, "  skip diff payload: %s\n", v27);
      if ((*(_DWORD *)(v0 + 24) & 2) != 0)
        v28 = "yes";
      else
        v28 = "no";
      fprintf(*v25, "  skip archive payload: %s\n", v28);
      if ((*(_DWORD *)(v0 + 24) & 4) != 0)
        v29 = "yes";
      else
        v29 = "no";
      fprintf(*v25, "  truncate archive payload: %s\n", v29);
      if ((*(_DWORD *)(v0 + 24) & 0x200) != 0)
        v30 = "yes";
      else
        v30 = "no";
      fprintf(*v25, "  skip attributes: %s\n", v30);
      v26 = *(_DWORD *)(v0 + 24);
      if ((v26 & 0x10000) != 0)
      {
        fwrite("  MSU mode: yes\n", 0x10uLL, 1uLL, *v25);
        v26 = *(_DWORD *)(v0 + 24);
      }
      if ((v26 & 0x200) != 0)
        goto LABEL_71;
    }
    if ((v26 & 0x100) != 0)
      v31 = "yes";
    else
      v31 = "no";
    fprintf(*v25, "  ignore EPERM: %s\n", v31);
    v32 = *(_BYTE *)(v0 + 28);
    if ((v32 & 1) != 0)
    {
      fprintf(*v25, "  override UID: %u\n", *(_DWORD *)(v0 + 32));
      v32 = *(_BYTE *)(v0 + 28);
      if ((v32 & 2) == 0)
      {
LABEL_68:
        if ((v32 & 8) == 0)
          goto LABEL_69;
        goto LABEL_79;
      }
    }
    else if ((*(_BYTE *)(v0 + 28) & 2) == 0)
    {
      goto LABEL_68;
    }
    fprintf(*v25, "  override GID: %u\n", *(_DWORD *)(v0 + 36));
    v32 = *(_BYTE *)(v0 + 28);
    if ((v32 & 8) == 0)
    {
LABEL_69:
      if ((v32 & 4) == 0)
      {
LABEL_71:
        fprintf(*v25, "%12llu diff payload size\n", *(_QWORD *)((char *)&v72[1] + 4));
        fprintf(*v25, "%12llu archive payload size\n", *(_QWORD *)((char *)&v72[2] + 4));
        v23 = *(_QWORD *)((char *)&v72[2] + 4);
        goto LABEL_72;
      }
LABEL_70:
      fprintf(*v25, "  override mode for directories: 0%o\n", *(_DWORD *)(v0 + 40));
      goto LABEL_71;
    }
LABEL_79:
    fprintf(*v25, "  override mode for regular files: 0%o\n", *(_DWORD *)(v0 + 44));
    if ((*(_BYTE *)(v0 + 28) & 4) == 0)
      goto LABEL_71;
    goto LABEL_70;
  }
LABEL_72:
  v52 = 0u;
  v53 = 0u;
  DWORD1(v52) = DefaultNThreads;
  v57 = &v59;
  *(_QWORD *)&v54 = directoryPatchBegin;
  *((_QWORD *)&v54 + 1) = directoryPatchBlob;
  *(_QWORD *)&v55 = directoryPatchPayload;
  *((_QWORD *)&v55 + 1) = directoryPatchPadding;
  *(_QWORD *)&v56 = directoryPatchEnd;
  *((_QWORD *)&v56 + 1) = directoryPatchPadding;
  if (v23 && (*(_BYTE *)(v0 + 24) & 2) == 0)
  {
    v33 = IFileStreamCreateWithFilename(v62, *(_QWORD *)((char *)&v72[1] + 4) + 28, v23);
    v20 = (char *)v33;
    if (!v33)
    {
      v41 = "create archive payload stream";
      v42 = 418;
      goto LABEL_94;
    }
    v69 = 0;
    *((_QWORD *)&v53 + 1) = v33;
    *((_QWORD *)&v52 + 1) = IFileStreamRead;
    if (ParallelArchiveRead((uint64_t)&v52, v34, v35, v36, v37, v38, v39, v40))
    {
      v41 = "read archive payload";
      v42 = 423;
LABEL_94:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"DirectoryPatch", v42, 25, 0, v41, v39, v40, (char)v50);
      goto LABEL_28;
    }
    IFileStreamDestroy(v20);
    if (v70)
    {
      LOBYTE(v50) = v70;
      v17 = "DirectoryPatch: %llu errors after processing the archive payload";
      v18 = 432;
      goto LABEL_25;
    }
  }
  if (st_size == v51 && (*(_BYTE *)(v0 + 24) & 4) != 0 && truncate(v62, *(_QWORD *)((char *)&v72[1] + 4) + 28))
  {
    v19 = *__error();
    v18 = 441;
    v17 = v62;
    goto LABEL_27;
  }
  if (*(_QWORD *)((char *)&v72[1] + 4) && (*(_BYTE *)(v0 + 24) & 1) == 0)
  {
    v43 = IFileStreamCreateWithFilename(v62, 0x1CuLL, *(_QWORD *)((char *)&v72[1] + 4));
    v20 = (char *)v43;
    if (!v43)
    {
      v41 = "create diff payload stream";
      v42 = 448;
      goto LABEL_94;
    }
    v69 = 28;
    *((_QWORD *)&v53 + 1) = v43;
    *((_QWORD *)&v52 + 1) = IFileStreamRead;
    if (ParallelArchiveRead((uint64_t)&v52, v44, v45, v46, v47, v48, v39, v40))
    {
      v41 = "read diff payload";
      v42 = 453;
      goto LABEL_94;
    }
    IFileStreamDestroy(v20);
    if (v70)
    {
      LOBYTE(v50) = v70;
      v17 = "DirectoryPatch: %llu errors after processing the diff payload";
      v18 = 462;
      goto LABEL_25;
    }
  }
  if (v9 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12lld entries processed\n", v71);
  v20 = 0;
  v21 = 0;
LABEL_29:
  IFileStreamDestroy(v20);
  MemBufferDestroy(v67);
  MemBufferDestroy(v68);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v21;
  else
    return result;
}

void directoryPatchBegin()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  const char *v13;
  __int16 v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  unsigned int v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  char v44;
  stat v45;
  char v46[2048];
  char v47[2048];
  char v48[2048];
  uint64_t v49;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = v0;
  v49 = *MEMORY[0x24BDAC8D0];
  bzero(v48, 0x800uLL);
  bzero(v47, 0x800uLL);
  *(_QWORD *)(v9 + 5328) += v2;
  v12 = (int *)(v9 + 5336);
  *(_OWORD *)(v9 + 5336) = 0u;
  *(_OWORD *)(v9 + 5352) = 0u;
  if (*(_QWORD *)(v9 + 5376))
    goto LABEL_9;
  if ((*(_DWORD *)v8 & 1) == 0)
    goto LABEL_7;
  if (*(_DWORD *)(v8 + 4) == 77)
  {
LABEL_9:
    *(_DWORD *)(v9 + 5340) = 1;
    return;
  }
  if ((~*(_DWORD *)v8 & 0x8001) != 0)
  {
LABEL_7:
    v13 = "invalid archive entry, PAT/TYP missing";
    v14 = 78;
    goto LABEL_8;
  }
  if (*(_QWORD *)(v9 + 5368))
  {
    v13 = "output file stream was not closed";
    v14 = 79;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", v14, 25, 0, v13, v10, v11, v44);
    ++*(_QWORD *)(v9 + 5376);
    goto LABEL_9;
  }
  memset(&v45, 0, sizeof(v45));
  if (concatPath(v48, 0x800uLL, (char *)(v9 + 1028), (const char *)(v8 + 144)))
  {
    v13 = "create output path";
    v14 = 82;
    goto LABEL_8;
  }
  ++*(_QWORD *)(v9 + 5384);
  memcpy((void *)(v9 + 3136), (const void *)v8, 0x890uLL);
  if (*(int *)v9 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", (const char *)(v8 + 144));
  v15 = strlen(v48);
  makePath(v48, v15);
  if (!lstat(v48, &v45) && (v45.st_mode & 0xF000) != 0x4000)
    unlink(v48);
  v18 = *(_DWORD *)(v8 + 4);
  switch(v18)
  {
    case 'D':
      if (lstat(v48, &v45))
      {
        if (mkdir(v48, 0x1EDu))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 107, 25, 0, "mkdir %s", v21, v22, (char)v48);
          goto LABEL_63;
        }
      }
      else if ((v45.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 112, 25, 0, "entry expected to be a directory: %s", v19, v20, (char)v48);
        goto LABEL_63;
      }
      return;
    case 'F':
      v23 = *(_DWORD *)(v9 + 3076);
      if (v23)
        v24 = 2;
      else
        v24 = 1;
      *(_DWORD *)(v9 + 5336) = v24;
      if ((*(_BYTE *)(v8 + 1) & 2) != 0)
      {
        v29 = 4;
LABEL_47:
        *v12 = v29;
        goto LABEL_48;
      }
      if (v4)
      {
        while ((*v6 & 0xDFDFDF) != 0x505842)
        {
          v6 += 258;
          if (!--v4)
            goto LABEL_30;
        }
        v29 = 3;
        goto LABEL_47;
      }
LABEL_30:
      if (!v23)
      {
        bzero(v46, 0x800uLL);
        if (concatPath(v46, 0x800uLL, (char *)(v9 + 4), (const char *)(v8 + 144)))
        {
          v27 = "create input path";
          v28 = 141;
          goto LABEL_62;
        }
        if (link(v46, v48))
        {
          v29 = 2;
          goto LABEL_47;
        }
      }
LABEL_48:
      v34 = 64;
      if ((*(_DWORD *)v8 & 0x200) == 0)
        v34 = 40;
      v35 = *(_QWORD *)(v8 + v34);
      if ((*(_DWORD *)v8 & 8) != 0)
        v36 = 4 * (statIsCompressed(*(_DWORD *)(v8 + 16)) != 0);
      else
        v36 = 0;
      if ((*v12 - 2) <= 2)
      {
        v37 = *(_DWORD *)(v9 + 3084) ? v36 | 0x2B : v36;
        v38 = OArchiveFileStreamCreate(v48, v35, v37, -1, *(_DWORD *)(v9 + 3112));
        *(_QWORD *)(v9 + 5368) = v38;
        if (!v38)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 160, 25, 0, "create output stream", v39, v40, v44);
          ++*(_QWORD *)(v9 + 5376);
        }
        if (*v12 == 2)
        {
          bzero(v46, 0x800uLL);
          if (concatPath(v46, 0x800uLL, (char *)(v9 + 4), (const char *)(v8 + 144)))
          {
            v27 = "create input path";
            v28 = 167;
            goto LABEL_62;
          }
          v41 = IFileStreamCreateWithFilename(v46, 0, -1);
          if (!v41)
          {
            v27 = "create input stream";
            v28 = 169;
            goto LABEL_62;
          }
          v42 = (char *)v41;
          v43 = MemBufferTransmit(*(unint64_t **)(v9 + 3120), v35, (size_t (*)(int, void *, size_t))IFileStreamRead, v41, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OArchiveFileStreamWrite, *(_QWORD *)(v9 + 5368), v25, v26);
          IFileStreamDestroy(v42);
          if (v43 != v35)
          {
            v27 = "copy preserved";
            v28 = 172;
            goto LABEL_62;
          }
        }
      }
      return;
    case 'H':
      if ((*(_BYTE *)(v8 + 2) & 1) == 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 122, 25, 0, "missing LNK field: %s", v16, v17, v8 - 112);
        goto LABEL_63;
      }
      if (concatPath(v47, 0x800uLL, (char *)(v9 + 1028), (const char *)(v8 + 1168)))
      {
        v27 = "create output link path";
        v28 = 123;
LABEL_62:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", v28, 25, 0, v27, v25, v26, v44);
        goto LABEL_63;
      }
      if (link(v47, v48))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 124, 25, 0, "hlink %s -> %s", v32, v33, (char)v48);
        goto LABEL_63;
      }
      return;
    case 'L':
      if ((*(_BYTE *)(v8 + 2) & 1) == 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 117, 25, 0, "missing LNK field: %s", v16, v17, v8 - 112);
        goto LABEL_63;
      }
      if (symlink((const char *)(v8 + 1168), v48))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 118, 25, 0, "slink %s -> %s", v30, v31, (char)v48);
        goto LABEL_63;
      }
      return;
    default:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchBegin", 179, 25, 0, "unsupported entry type '%c'", v16, v17, v18);
LABEL_63:
      ++*(_QWORD *)(v9 + 5376);
      return;
  }
}

unsigned int *directoryPatchEnd(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t NWritten;
  unint64_t DataSize;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  unsigned int v27;
  unsigned int *v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  _OWORD v32[3];
  uint64_t v33;
  uint64_t v34;
  int v35;
  char v36[2048];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (result[1335])
    return result;
  v8 = result;
  if (result[1334] == 3)
  {
    bzero(v36, 0x800uLL);
    if (concatPath(v36, 0x800uLL, (char *)v8 + 4, (const char *)v8 + 3280))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 196, 25, 0, "create input path", v9, v10, v31);
      ++*((_QWORD *)v8 + 672);
    }
    v11 = MappedBufferCreateWithFilename((const char *)v8 + 2052, *((_QWORD *)v8 + 669), *((_QWORD *)v8 + 670));
    if (v11)
    {
      v12 = v11;
      NWritten = OMemStreamGetNWritten((uint64_t)v11);
      DataSize = MappedBufferGetDataSize((uint64_t)v12);
      LODWORD(NWritten) = BXPatch5FileWithFlags(v36, NWritten, DataSize, (uint64_t (*)(uint64_t, void *, uint64_t))OArchiveFileStreamWrite, *((_QWORD *)v8 + 671), 0);
      MappedBufferDestroy(v12);
      if (!(_DWORD)NWritten)
        goto LABEL_10;
    }
    else
    {
      MappedBufferDestroy(0);
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 205, 25, 0, "patching file %s", a7, a8, (_BYTE)v8 - 48);
    ++*((_QWORD *)v8 + 672);
  }
LABEL_10:
  result = (unsigned int *)*((_QWORD *)v8 + 671);
  if (result)
  {
    result = (unsigned int *)OArchiveFileStreamDestroy(result, a2, a3, a4, a5, a6, a7, a8);
    *((_QWORD *)v8 + 671) = 0;
  }
  if ((*((_BYTE *)v8 + 3137) & 0x20) != 0)
  {
    v15 = v8[1334];
    if (v15 <= 4 && ((1 << v15) & 0x16) != 0)
    {
      bzero(v36, 0x800uLL);
      v33 = 0;
      v34 = 0;
      v35 = 0;
      if (concatPath(v36, 0x800uLL, (char *)v8 + 1028, (const char *)v8 + 3280))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 223, 25, 0, "create output path", v16, v17, v31);
        ++*((_QWORD *)v8 + 672);
      }
      result = (unsigned int *)getFileSHA1Digest(v36, (uint64_t)&v33);
      if ((_DWORD)result)
      {
        result = (unsigned int *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 224, 25, 0, "hashing output file", v18, v19, v31);
        ++*((_QWORD *)v8 + 672);
      }
      if (v33 != *(_QWORD *)(v8 + 807) || v34 != *(_QWORD *)(v8 + 809) || v35 != (unint64_t)v8[811])
      {
        memset(v32, 0, 41);
        sha1ToString((uint64_t)v32, (uint64_t)&v33);
        result = (unsigned int *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 229, 25, 0, "invalid output file SHA1 digest %s: %s", v22, v23, v8 - 48);
        ++*((_QWORD *)v8 + 672);
      }
    }
  }
  if (!v8[772])
  {
    bzero(v36, 0x800uLL);
    if (concatPath(v36, 0x800uLL, (char *)v8 + 1028, (const char *)v8 + 3280))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 238, 25, 0, "create output path", v24, v25, v31);
      ++*((_QWORD *)v8 + 672);
    }
    v26 = *((_BYTE *)v8 + 3092);
    if ((v26 & 1) != 0)
    {
      v8[784] |= 2u;
      v8[786] = v8[774];
    }
    if ((v26 & 2) != 0)
    {
      v8[784] |= 4u;
      v8[787] = v8[775];
    }
    v27 = v8[785];
    if (v27 == 68)
    {
      if ((v26 & 4) == 0)
        goto LABEL_41;
      v8[784] |= 0x10u;
      v28 = v8 + 776;
    }
    else
    {
      if (v27 != 70 || (v26 & 8) == 0)
        goto LABEL_41;
      v8[784] |= 0x10u;
      v28 = v8 + 777;
    }
    v8[789] = *v28;
LABEL_41:
    result = (unsigned int *)yaa_setEntryAttributes(v36, (int *)v8 + 784, 0, v8[770]);
    if ((_DWORD)result)
    {
      result = (unsigned int *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchEnd", 253, 25, 0, "set output attributes", v29, v30, v31);
      ++*((_QWORD *)v8 + 672);
    }
  }
  return result;
}

uint64_t directoryPatchBlob(uint64_t result, _DWORD *a2)
{
  int v2;

  if (!*(_DWORD *)(result + 5340))
  {
    *(_QWORD *)(result + 5344) = 0;
    v2 = *a2 & 0xDFDFDF;
    if (v2 == 5265474)
    {
      *(_DWORD *)(result + 5348) = 1;
      *(_QWORD *)(result + 5352) = *(_QWORD *)(result + 5328);
    }
    else if (v2 == 5521732)
    {
      *(_DWORD *)(result + 5344) = 1;
    }
  }
  return result;
}

size_t directoryPatchPayload(size_t result, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  char v12;

  *(_QWORD *)(result + 5328) += a3;
  if (!*(_DWORD *)(result + 5340))
  {
    v8 = result;
    if (*(_DWORD *)(result + 5344))
    {
      result = OArchiveFileStreamWrite(*(_QWORD *)(result + 5368), a2, a3, a4, a5, a6, a7, a8);
      if ((result & 0x8000000000000000) == 0)
        return result;
      result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/DirectoryPatch.c", (uint64_t)"directoryPatchPayload", 283, 25, 0, "write DAT blob", v9, v10, v12);
      v11 = (_QWORD *)(v8 + 5376);
      a3 = 1;
    }
    else
    {
      if (!*(_DWORD *)(result + 5348))
        return result;
      v11 = (_QWORD *)(result + 5360);
    }
    *v11 += a3;
  }
  return result;
}

uint64_t directoryPatchPadding(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 5328) += a3;
  return result;
}

uint64_t ECC65537GetParity(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  int8x16_t v5;
  int8x8_t v6;
  int8x16_t v7;
  int8x16_t v8;
  uint32x4_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int32x4_t v13;
  uint64_t v14;
  __int32 v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int32x4_t v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int16x8_t v25;
  int8x16_t v26;
  int8x8_t v27;
  int8x8_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  _OWORD v44[4];
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  if (a1 > 0x1FFE0)
    return 0xFFFFFFFFLL;
  v4 = (a1 & 1) + a1;
  if (v4)
  {
    v5 = 0uLL;
    v6 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_20643ED90))));
    v7 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_20643EDA0), (int16x8_t)vceqzq_s32((int32x4_t)qword_20643EDB0)));
    v8.i64[0] = 0xFFFF0000FFFFLL;
    v8.i64[1] = 0xFFFF0000FFFFLL;
    v9.i64[0] = 0x1000000010000;
    v9.i64[1] = 0x1000000010000;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    v11 = 0uLL;
    v12 = 0uLL;
    v13 = 0uLL;
    do
    {
      v14 = v4 - 2;
      if (v4 <= a1)
        v15 = *(unsigned __int16 *)(a2 + v14);
      else
        v15 = *(unsigned __int8 *)(a2 + v14);
      v16 = (int32x4_t)vextq_s8(v12, (int8x16_t)v13, 0xCuLL);
      v17 = (int32x4_t)vextq_s8(v11, v12, 0xCuLL);
      v18 = (int32x4_t)vextq_s8(qword_20643EDB0, v5, 0xCuLL);
      v19 = vdupq_laneq_s32(v13, 3);
      v18.i32[0] = v15;
      v20 = (int32x4_t)vextq_s8(v5, v11, 0xCuLL);
      v21 = vmulq_laneq_s32((int32x4_t)xmmword_20643EDA0, v13, 3);
      v22 = vmulq_laneq_s32((int32x4_t)qword_20643EDB0, v13, 3);
      v23 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v13, 3);
      v24 = vmulq_laneq_s32(unk_20643ED90, v13, 3);
      v25 = (int16x8_t)vceqzq_s32(v19);
      v26 = (int8x16_t)vuzp1q_s16(v25, v25);
      v27 = vmovn_s16((int16x8_t)vmvnq_s8(v26));
      v28 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v23), (int16x8_t)vceqzq_s32(v24)));
      v29 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v21), (int16x8_t)vceqzq_s32(v22));
      v30 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v22, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v22, 0x10uLL));
      v31 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v21, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v21, 0x10uLL));
      v32 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v24, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v24, 0x10uLL));
      v33 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v23, v8), (int32x4_t)vshrq_n_u32((uint32x4_t)v23, 0x10uLL));
      *(int8x8_t *)v26.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v7, v26), v29));
      v34 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v30, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v30)), (int8x16_t)vqsubq_u32((uint32x4_t)v30, v9)));
      v35 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v31, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v31)), (int8x16_t)vqsubq_u32((uint32x4_t)v31, v9)));
      *(int8x8_t *)v26.i8 = vand_s8(vand_s8(v6, v28), v27);
      v36 = (int8x16_t)vsubq_s32(v18, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v33, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v33)), (int8x16_t)vqsubq_u32((uint32x4_t)v33, v9))));
      v37 = (int8x16_t)vsubq_s32(v20, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v26.i8, (int8x8_t)0xB4200003C1CLL)), 0x1FuLL)), v10, vorrq_s8(vandq_s8(v32, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v32)), (int8x16_t)vqsubq_u32((uint32x4_t)v32, v9))));
      v38 = (int8x16_t)vsubq_s32(v17, v35);
      v39 = (int8x16_t)vsubq_s32(v16, v34);
      v13 = (int32x4_t)vorrq_s8(vandq_s8(v39, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v39)), (int8x16_t)vqsubq_u32((uint32x4_t)v39, v9));
      v12 = vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v9));
      v11 = vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v9));
      v5 = vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v9, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v9));
      v4 = v14;
    }
    while ((_DWORD)v14);
  }
  else
  {
    v5 = 0uLL;
    v11 = 0uLL;
    v12 = 0uLL;
    v13 = 0uLL;
  }
  v40 = 0;
  v41 = 0;
  v44[0] = v5;
  v44[1] = v11;
  v44[2] = v12;
  v44[3] = v13;
  do
  {
    v42 = *((_DWORD *)v44 + v40);
    if (v42)
      v43 = 65537 - v42;
    else
      v43 = 0;
    v41 |= (1 << v40) & (v43 << 15 >> 31);
    *(_WORD *)(a3 + 2 * v40++) = v43;
  }
  while (v40 != 16);
  result = 0;
  *(_WORD *)(a3 + 32) = v41;
  return result;
}

uint64_t ECC65537CheckAndFix(unsigned int a1, uint64_t a2, uint16x8_t *a3, _DWORD *a4)
{
  int8x16_t v7;
  unsigned int v8;
  int8x16_t v9;
  int8x8_t v10;
  int8x16_t v11;
  int8x16_t v12;
  uint32x4_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int32x4_t v17;
  unsigned int v18;
  uint64_t v19;
  __int32 v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int16x8_t v30;
  int8x16_t v31;
  int8x8_t v32;
  int8x8_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  uint64_t v45;
  int32x4_t v46;
  int8x16_t v47;
  int32x4_t v48;
  uint32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int8x16_t v52;
  uint16x8_t v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t *v56;
  int32x4_t v57;
  int32x4_t v58;
  int8x16_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int *v62;
  int *v63;
  uint64_t v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;
  __int128 v71;
  __int128 v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  int v77;
  int v78;
  unsigned int v79;
  int v80;
  int *v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  int v94;
  _DWORD *v95;
  int8x8_t v96;
  uint64_t v97;
  int v98;
  int v99;
  uint64_t v100;
  BOOL v101;
  int v102;
  int v103;
  unsigned int v104;
  int v105;
  unsigned int v106;
  uint64_t v107;
  int v108;
  int *v109;
  uint64_t v110;
  uint64_t v111;
  char v113;
  int *v114;
  _DWORD *v115;
  unsigned int v116;
  _OWORD v117[4];
  uint64_t v118;

  v118 = *MEMORY[0x24BDAC8D0];
  v7 = 0uLL;
  v8 = (a1 & 1) + a1;
  if (v8)
  {
    v9 = 0uLL;
    v10 = vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)ECC65537_G), (int16x8_t)vceqzq_s32(unk_20643ED90))));
    v11 = vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)xmmword_20643EDA0), (int16x8_t)vceqzq_s32((int32x4_t)qword_20643EDB0)));
    v12.i64[0] = 0xFFFF0000FFFFLL;
    v12.i64[1] = 0xFFFF0000FFFFLL;
    v13.i64[0] = 0x1000000010000;
    v13.i64[1] = 0x1000000010000;
    v14.i64[0] = 0x100000001;
    v14.i64[1] = 0x100000001;
    v15 = 0uLL;
    v16 = 0uLL;
    v17 = 0uLL;
    v18 = (a1 & 1) + a1;
    do
    {
      v19 = v18 - 2;
      if (v18 <= a1)
        v20 = *(unsigned __int16 *)(a2 + v19);
      else
        v20 = *(unsigned __int8 *)(a2 + v19);
      v21 = (int32x4_t)vextq_s8(v16, (int8x16_t)v17, 0xCuLL);
      v22 = (int32x4_t)vextq_s8(v15, v16, 0xCuLL);
      v23 = (int32x4_t)vextq_s8((int8x16_t)0, v9, 0xCuLL);
      v24 = vdupq_laneq_s32(v17, 3);
      v23.i32[0] = v20;
      v25 = (int32x4_t)vextq_s8(v9, v15, 0xCuLL);
      v26 = vmulq_laneq_s32((int32x4_t)xmmword_20643EDA0, v17, 3);
      v27 = vmulq_laneq_s32((int32x4_t)qword_20643EDB0, v17, 3);
      v28 = vmulq_laneq_s32((int32x4_t)ECC65537_G, v17, 3);
      v29 = vmulq_laneq_s32(unk_20643ED90, v17, 3);
      v30 = (int16x8_t)vceqzq_s32(v24);
      v31 = (int8x16_t)vuzp1q_s16(v30, v30);
      v32 = vmovn_s16((int16x8_t)vmvnq_s8(v31));
      v33 = vmovn_s16(vuzp1q_s16((int16x8_t)vceqzq_s32(v28), (int16x8_t)vceqzq_s32(v29)));
      v34 = (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32(v26), (int16x8_t)vceqzq_s32(v27));
      v35 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v27, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v27, 0x10uLL));
      v36 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v26, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v26, 0x10uLL));
      v37 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v29, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL));
      v38 = (int8x16_t)vsubq_s32((int32x4_t)vandq_s8((int8x16_t)v28, v12), (int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x10uLL));
      *(int8x8_t *)v31.i8 = vmovn_s16((int16x8_t)vandq_s8(vbicq_s8(v11, v31), v34));
      v39 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v35, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v35)), (int8x16_t)vqsubq_u32((uint32x4_t)v35, v13)));
      v40 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v36, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v36)), (int8x16_t)vqsubq_u32((uint32x4_t)v36, v13)));
      *(int8x8_t *)v31.i8 = vand_s8(vand_s8(v10, v33), v32);
      v41 = (int8x16_t)vsubq_s32(v23, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip1_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v38, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v38)), (int8x16_t)vqsubq_u32((uint32x4_t)v38, v13))));
      v42 = (int8x16_t)vsubq_s32(v25, (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vzip2_s8(*(int8x8_t *)v31.i8, 0)), 0x1FuLL)), v14, vorrq_s8(vandq_s8(v37, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v37)), (int8x16_t)vqsubq_u32((uint32x4_t)v37, v13))));
      v43 = (int8x16_t)vsubq_s32(v22, v40);
      v44 = (int8x16_t)vsubq_s32(v21, v39);
      v17 = (int32x4_t)vorrq_s8(vandq_s8(v44, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v44)), (int8x16_t)vqsubq_u32((uint32x4_t)v44, v13));
      v16 = vorrq_s8(vandq_s8(v43, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v43)), (int8x16_t)vqsubq_u32((uint32x4_t)v43, v13));
      v15 = vorrq_s8(vandq_s8(v42, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v42)), (int8x16_t)vqsubq_u32((uint32x4_t)v42, v13));
      v9 = vorrq_s8(vandq_s8(v41, (int8x16_t)vcgtq_u32(v13, (uint32x4_t)v41)), (int8x16_t)vqsubq_u32((uint32x4_t)v41, v13));
      v18 = v19;
    }
    while ((_DWORD)v19);
  }
  else
  {
    v9 = 0uLL;
    v15 = 0uLL;
    v16 = 0uLL;
    v17 = 0uLL;
  }
  v45 = 0;
  v117[0] = v9;
  v117[1] = v15;
  v117[2] = v16;
  v117[3] = v17;
  v46 = (int32x4_t)xmmword_20643ED50;
  v47 = (int8x16_t)vdupq_n_s32(a3[2].u16[0]);
  v48 = (int32x4_t)xmmword_20643ED60;
  v49.i64[0] = 0x100000001;
  v49.i64[1] = 0x100000001;
  v50.i64[0] = 0x1000000010000;
  v50.i64[1] = 0x1000000010000;
  v51.i64[0] = 0x800000008;
  v51.i64[1] = 0x800000008;
  v52 = 0uLL;
  do
  {
    v53 = *a3++;
    v54 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v53.i8);
    v55 = (int8x16_t)vmovl_high_u16(v53);
    v56 = (int8x16_t *)&v117[v45];
    v57 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v46), v47)), v55, (int8x16_t)(*(_OWORD *)&v55 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45 + 1]);
    v58 = vaddq_s32((int32x4_t)vbslq_s8((int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v49, (uint32x4_t)v48), v47)), v54, (int8x16_t)(*(_OWORD *)&v54 | __PAIR128__(0x1000000010000, 0x1000000010000))), (int32x4_t)v117[v45]);
    v59 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v57, v50), (uint32x4_t)v57);
    v60 = (int8x16_t)vminq_u32((uint32x4_t)vaddq_s32(v58, v50), (uint32x4_t)v58);
    *v56 = v60;
    v56[1] = v59;
    v52 = vorrq_s8(v59, v52);
    v7 = vorrq_s8(v60, v7);
    v48 = vaddq_s32(v48, v51);
    v46 = vaddq_s32(v46, v51);
    v45 += 2;
  }
  while (v45 != 4);
  v61 = vorrq_s8(v7, v52);
  if (vorr_s8(*(int8x8_t *)v61.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v61, v61, 8uLL)))
  {
    v62 = (int *)calloc(1uLL, 0x4C0uLL);
    if (v62)
    {
      v63 = v62;
      v64 = 0;
      v65 = v8 >> 1;
      v66 = 1;
      do
      {
        v63[v64] = ecc65537PolyEval(16, (uint64_t)v117, v66);
        v67 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        if (v67 + 65537 >= v67)
          v66 = (unsigned __int16)(3 * v66) - ((3 * v66) >> 16);
        else
          v66 = v67 + 65537;
        ++v64;
      }
      while (v64 != 16);
      v115 = a4;
      v68 = 0;
      v69 = 48;
      do
      {
        v70 = &v63[v69];
        v71 = *(_OWORD *)&v63[v68];
        v72 = *(_OWORD *)&v63[v68 + 4];
        v70[8] = v63[v68 + 8];
        *(_OWORD *)v70 = v71;
        *((_OWORD *)v70 + 1) = v72;
        v69 += 16;
        ++v68;
      }
      while (v68 != 8);
      v73 = ecc65537Triangulate(8, 9, (uint64_t)(v63 + 48));
      if (v73 >= 1)
      {
        v74 = v73;
        if ((ecc65537Solve(v73, v63 + 48, (uint64_t)(v63 + 16)) & 0x80000000) == 0)
        {
          v114 = v63 + 48;
          v75 = v74;
          v76 = 0;
          v77 = 0;
          v116 = v75;
          v78 = v75 + 1;
          v79 = v65 + 16;
          v80 = 1;
          do
          {
            if (!ecc65537PolyEval(v78, (uint64_t)(v63 + 16), v80) && v77 <= 7)
            {
              v81 = &v63[v77++];
              v81[32] = v76;
            }
            v82 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            if (v82 + 65537 >= v82)
              v80 = (unsigned __int16)(3 * v80) - ((3 * v80) >> 16);
            else
              v80 = v82 + 65537;
            ++v76;
          }
          while (v79 != v76);
          if (v77 == v116)
          {
            v83 = 0;
            v84 = v116;
            do
            {
              v85 = 0;
              v86 = (16 * v83);
              do
              {
                v87 = v63[v85 + 32] * v83;
                if (v87)
                {
                  v88 = 3;
                  if (v87 < 0)
                  {
                    v88 = ecc65537Inv(3);
                    v87 = -v87;
                  }
                  v89 = (unsigned __int16)v87;
                  v90 = 1;
                  while (1)
                  {
                    if ((v89 & 1) != 0)
                    {
                      if (v88 && v90 && !(v90 * v88))
                      {
                        v90 = 1;
                      }
                      else
                      {
                        v90 = (unsigned __int16)(v90 * v88) - ((v90 * v88) >> 16);
                        if (v90 + 65537 < v90)
                          v90 += 65537;
                      }
                    }
                    if (v89 < 2)
                      break;
                    v89 >>= 1;
                    v91 = v88 * v88;
                    if (v88)
                    {
                      v88 = 1;
                      if (!v91)
                        continue;
                    }
                    v92 = (unsigned __int16)v91 - HIWORD(v91);
                    if (v92 + 65537 >= v92)
                      v88 = v92;
                    else
                      v88 = v92 + 65537;
                  }
                }
                else
                {
                  v90 = 1;
                }
                v63[v85 + 48 + v86] = v90;
                ++v85;
              }
              while (v85 != v116);
              v93 = v63[v83];
              if (v93)
                v94 = 65537 - v93;
              else
                v94 = 0;
              v63[(int)(v86 + v116) + 48] = v94;
              ++v83;
            }
            while (v83 != v116);
            if (ecc65537Triangulate(v116, v78, (uint64_t)v114) == v116)
            {
              v95 = v63 + 40;
              if ((ecc65537Solve(v116, v114, (uint64_t)(v63 + 40)) & 0x80000000) == 0)
              {
                v97 = 0;
                v98 = 0;
                while (1)
                {
                  v99 = *(v95 - 8);
                  if (a1 > 2 * v99)
                  {
                    v100 = (2 * v99);
                    v101 = (int)v100 + 2 <= a1 || a1 - (_DWORD)v100 == 2;
                    v102 = v101;
                    if (v101)
                      v103 = *(unsigned __int16 *)(a2 + v100);
                    else
                      v103 = *(unsigned __int8 *)(a2 + v100);
                    v104 = v103 - *v95;
                    if (v104 + 65537 < v104)
                      v104 += 65537;
                    if (HIWORD(v104))
                      goto LABEL_85;
                    v105 = v104 ^ v103;
                    v96.i32[0] = v105;
                    v96 = vcnt_s8(v96);
                    v96.i16[0] = vaddlv_u8((uint8x8_t)v96);
                    v98 += v96.i32[0];
                    if ((_BYTE)v105)
                      v106 = v97 + 1;
                    else
                      v106 = v97;
                    if ((v105 & 0xFF00) != 0)
                      v97 = v106 + 1;
                    else
                      v97 = v106;
                    if (v102)
                      *(_WORD *)(a2 + v100) = v104;
                    else
                      *(_BYTE *)(a2 + v100) = v104;
                  }
                  ++v95;
                  v107 = v97;
                  if (!--v84)
                    goto LABEL_86;
                }
              }
            }
          }
        }
      }
      v98 = 0;
      LODWORD(v97) = 0;
LABEL_85:
      v107 = 0xFFFFFFFFLL;
LABEL_86:
      free(v63);
      if (v115 && (v107 & 0x80000000) == 0)
      {
        v108 = v115[1] + v97;
        *v115 += v98;
        v115[1] = v108;
      }
    }
    else
    {
      v109 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection_ECC65537.c", (uint64_t)"ECC65537CheckAndFix", 423, 63, *v109, "malloc", v110, v111, v113);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    return 0;
  }
  return v107;
}

uint64_t ecc65537PolyEval(int a1, uint64_t a2, int a3)
{
  uint64_t result;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;

  if (a1 < 1)
    return 0;
  LODWORD(result) = 0;
  v5 = a1 + 1;
  do
  {
    if (a3 && (_DWORD)result && !((_DWORD)result * a3))
    {
      v6 = 1;
    }
    else
    {
      v6 = (unsigned __int16)(result * a3) - ((result * a3) >> 16);
      if (v6 + 65537 < v6)
        v6 += 65537;
    }
    v7 = v6 + *(_DWORD *)(a2 + 4 * (v5 - 2));
    if (v7 - 65537 >= v7)
      result = v7;
    else
      result = v7 - 65537;
    --v5;
  }
  while (v5 > 1);
  return result;
}

uint64_t ecc65537Triangulate(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int *v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  _WORD *v24;
  int v25;
  int *v26;
  BOOL v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  BOOL v33;
  int v34;
  unsigned int v35;

  if ((int)a1 < 1)
    return 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  LODWORD(v6) = 0;
  v7 = 16;
  v8 = 1;
  while (1)
  {
    if (v5 >= a2)
    {
      LODWORD(v11) = v6;
    }
    else
    {
      v9 = v5 + v3;
LABEL_5:
      v10 = v9;
      v11 = v4;
      while (!*(_DWORD *)(a3 + 4 * (int)v10))
      {
        ++v11;
        v10 += 16;
        if (a1 == v11)
        {
          ++v5;
          ++v9;
          if (v5 != a2)
            goto LABEL_5;
          return v4;
        }
      }
    }
    v6 = v4;
    if (v5 == a2)
      return v6;
    if (v4 == v11 || a2 <= 0)
    {
      v12 = 16 * v4;
    }
    else
    {
      v12 = 16 * v4;
      v13 = (int *)(a3 + 64 * (_DWORD)v11);
      v14 = a2;
      v15 = v3;
      do
      {
        v16 = *v13;
        *v13++ = *(_DWORD *)(a3 + 4 * v15);
        *(_DWORD *)(a3 + 4 * v15++) = v16;
        --v14;
      }
      while (v14);
    }
    if (++v4 < (unint64_t)a1)
    {
      v17 = *(_DWORD *)(a3 + 4 * (v12 + v5));
      v18 = v5 + 1;
      v19 = (int *)(a3 + 4 * (v12 + v18));
      v20 = v7;
      v21 = v8;
      do
      {
        v22 = v5 + 16 * v21;
        v23 = *(_DWORD *)(a3 + 4 * v22);
        if (v23)
        {
          *(_DWORD *)(a3 + 4 * v22) = 0;
          if ((int)v18 < a2)
          {
            v24 = (_WORD *)(a3 + 4 * (v18 + v20));
            v25 = a2 - 1 - v5;
            v26 = v19;
            do
            {
              if (v17 && (*(_DWORD *)v24 ? (v27 = *(_DWORD *)v24 * v17 == 0) : (v27 = 0), v27))
              {
                v28 = 1;
              }
              else
              {
                v28 = (unsigned __int16)(*v24 * v17) - ((*(_DWORD *)v24 * v17) >> 16);
                if (v28 + 65537 < v28)
                  v28 += 65537;
              }
              v30 = *v26++;
              v29 = v30;
              v31 = v30 * v23;
              v32 = (unsigned __int16)(v30 * v23) - ((v30 * v23) >> 16);
              if (v32 + 65537 < v32)
                v32 += 65537;
              if (v29)
                v33 = v31 == 0;
              else
                v33 = 0;
              if (v33)
                v34 = 1;
              else
                v34 = v32;
              v35 = v28 - v34;
              if (v35 + 65537 < v35)
                v35 += 65537;
              *(_DWORD *)v24 = v35;
              v24 += 2;
              --v25;
            }
            while (v25);
          }
        }
        ++v21;
        v20 += 16;
      }
      while (v21 != a1);
    }
    ++v8;
    v3 += 16;
    v7 += 16;
    if (v4 == a1)
      return a1;
  }
}

uint64_t ecc65537Solve(int a1, int *a2, uint64_t a3)
{
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  BOOL v15;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  BOOL v21;
  unsigned int v22;
  int v23;
  uint64_t v24;

  if (!a1)
    return 0;
  if (a1 <= 0)
  {
    v24 = 0;
    *(_DWORD *)(a3 + 4 * a1) = 1;
  }
  else
  {
    v5 = a1;
    v6 = a2;
    do
    {
      v7 = *v6;
      v6 += 17;
      if (!v7)
        return 0xFFFFFFFFLL;
      --v5;
    }
    while (v5);
    *(_DWORD *)(a3 + 4 * a1) = 1;
    v8 = a1;
    v9 = 16 * a1 - 16;
    v10 = a1;
    do
    {
      if (v10 <= v8)
      {
        v11 = 0;
        v12 = v8;
        do
        {
          v13 = *(_DWORD *)(a3 + 4 * v12);
          v14 = a2[v9 + v12];
          if (v13)
            v15 = v14 == 0;
          else
            v15 = 1;
          if (!v15 && v14 * v13 == 0)
          {
            v17 = 1;
          }
          else
          {
            v17 = (unsigned __int16)(v14 * v13) - ((v14 * v13) >> 16);
            if (v17 + 65537 < v17)
              v17 += 65537;
          }
          v18 = v17 + v11;
          if (v18 - 65537 >= v18)
            v11 = v18;
          else
            v11 = v18 - 65537;
          v19 = v12-- <= v10;
        }
        while (!v19);
      }
      else
      {
        v11 = 0;
      }
      v20 = ecc65537Inv(a2[17 * v10 - 17]);
      if (v11 && (v20 ? (v21 = v20 * v11 == 0) : (v21 = 0), v21))
      {
        v22 = 1;
      }
      else
      {
        v22 = (unsigned __int16)(v20 * v11) - ((v20 * v11) >> 16);
        if (v22 + 65537 < v22)
          v22 += 65537;
      }
      if (65537 - v22 >= -v22)
        v23 = -v22;
      else
        v23 = 65537 - v22;
      *(_DWORD *)(a3 + 4 * (v10 - 1)) = v23;
      v9 -= 16;
      v19 = v10-- <= 1;
    }
    while (!v19);
    return 0;
  }
  return v24;
}

uint64_t ecc65537Inv(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;

  if ((_DWORD)a1 == 1)
  {
    LODWORD(v1) = 1;
  }
  else
  {
    v2 = 0;
    v3 = 1;
    v4 = 65537;
    do
    {
      if (a1 <= v4)
      {
        v5 = -1;
        do
        {
          v6 = (_DWORD)a1 << (v5 + 2);
          ++v5;
        }
        while (v6 <= v4);
        v4 = (v4 - ((_DWORD)a1 << v5));
        v2 = (v2 - ((_DWORD)v3 << v5));
      }
      v1 = v2;
      v7 = v4;
      v2 = v3;
      v3 = v1;
      v4 = a1;
      a1 = v7;
    }
    while ((_DWORD)v7 != 1);
  }
  v8 = v1
     + 65537
     * (((v1 & ~((int)v1 >> 31)) - ((_DWORD)v1 + (v1 >> 31))) / 0x10001
      + (v1 >> 31));
  if (v8 <= 0x10000)
    v9 = 0x10000;
  else
    v9 = v1
       + 65537
       * (((v1 & ~((int)v1 >> 31)) - ((_DWORD)v1 + (v1 >> 31))) / 0x10001
        + (v1 >> 31));
  return v9 % 0x10001 - v9 + v8;
}

_QWORD *PagedFileCreate(const char *a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t st_size;
  off_t v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  size_t v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unsigned int v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  char v55;
  char v56;
  stat v57;

  memset(&v57, 0, sizeof(v57));
  if (stat(a1, &v57))
  {
    v10 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", 320, 21, v10, "%s", v11, v12, (char)a1);
    return 0;
  }
  st_size = v57.st_size;
  if (v57.st_size <= a2)
    v14 = a2;
  else
    v14 = v57.st_size;
  v15 = v14 + 4095;
  if (v15 >= 0xFFFFFFEF000)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", 324, 21, 0, "File is too large to be patched in place", v8, v9, v55);
    return 0;
  }
  v18 = (v15 >> 12) + 16;
  if ((a3 >> 12) <= 1)
    v19 = 1;
  else
    v19 = a3 >> 12;
  v20 = v19 + v18;
  v21 = (v19 << 12) + 4096 + 4 * v19 + 16 * (v18 & 0x3FFFFFFF) + 8 * v20 + 8 * v20 + 216;
  v22 = malloc(v21);
  v16 = v22;
  if (!v22)
  {
    v29 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", 339, 21, *v29, "malloc", v30, v31, v55);
    return v16;
  }
  bzero(v22, v21);
  if (a4 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Opening paged file %s, %u pages in file, %u pages in cache, %u pages total, memory usage: %zu B\n", a1, v18, v19, v19 + v18, v21);
  *(_DWORD *)v16 = -1;
  v16[1] = st_size;
  v16[2] = a2;
  *((_DWORD *)v16 + 32) = a4;
  *((_DWORD *)v16 + 6) = v18;
  *((_DWORD *)v16 + 7) = v19;
  *((_DWORD *)v16 + 8) = v20;
  v23 = open(a1, 2);
  *(_DWORD *)v16 = v23;
  if (v23 < 0)
  {
    v26 = *__error();
    v56 = (char)a1;
    v27 = "%s";
    v28 = 357;
    goto LABEL_23;
  }
  v56 = 1;
  if (fcntl(v23, 48))
    fwrite("Warning: couldn't set F_NOCACHE on paged file\n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  if (ftruncate(*(_DWORD *)v16, v18 << 12))
  {
    v26 = *__error();
    v56 = (char)a1;
    v27 = "%s";
    v28 = 365;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileCreate", v28, 21, v26, v27, v24, v25, v56);
    if ((*(_DWORD *)v16 & 0x80000000) == 0)
      close(*(_DWORD *)v16);
    free(v16);
    return 0;
  }
  v32 = (char *)(v16 + 24);
  v33 = *((unsigned int *)v16 + 6);
  v34 = *((unsigned int *)v16 + 7);
  v35 = (uint64_t)v16 + 4 * v33 + 192;
  v36 = v35 + 4 * v33;
  v37 = v36 + 4 * v33;
  v16[14] = v36;
  v16[15] = v37;
  v38 = v37 + 4 * v33;
  v16[7] = v38;
  v16[8] = v35;
  v39 = *((unsigned int *)v16 + 8);
  v40 = v38 + 4 * v39;
  v41 = v40 + 4 * v39;
  v16[5] = v41;
  v16[6] = v16 + 24;
  v42 = v41 + 8 * v39;
  v16[9] = v40;
  v16[10] = v42;
  v43 = v42 + 4096;
  v44 = v42 + 4096 + ((_DWORD)v34 << 12);
  v16[11] = v43;
  v16[12] = v44;
  if (v44 + 4 * v34 > (unint64_t)v16 + v21)
  {
    v27 = "in memory allocation for PagedFile";
    v28 = 378;
    v26 = 0;
    goto LABEL_23;
  }
  if ((_DWORD)v39)
  {
    v45 = 0;
    do
    {
      *(_QWORD *)(v38 + 8 * v39) = 0;
      *(_DWORD *)(v38 + 4 * v45) = -1;
      *(_DWORD *)(v38 + 4 * v39) = -1;
      ++v45;
      ++v39;
    }
    while (v45 < *((unsigned int *)v16 + 8));
    v46 = *((_DWORD *)v16 + 6);
  }
  else
  {
    v46 = v33;
  }
  if (v46)
  {
    v47 = 0;
    v48 = &v32[4 * v33];
    v49 = &v32[12 * v33];
    v50 = &v32[8 * v33];
    do
    {
      *(_DWORD *)&v32[4 * v47] = -1;
      *(_DWORD *)&v48[4 * v47] = -1;
      *(_DWORD *)&v50[4 * v47] = -1;
      *(_DWORD *)&v49[4 * v47++] = -1;
    }
    while (v47 < v46);
    v51 = 0;
    v52 = 0;
    v53 = st_size;
    do
    {
      if (v51 >= st_size)
        break;
      v54 = v53 - 4096;
      if (v53 >= 0x1000)
        v53 = 4096;
      *(_QWORD *)(v41 + 8 * v52) = v53;
      *(_DWORD *)(v38 + 4 * v52) = v52;
      *(_DWORD *)&v32[4 * v52] = v52;
      ++v52;
      v51 += 4096;
      v53 = v54;
    }
    while (v52 < v46);
  }
  return v16;
}

uint64_t PagedFileDestroy(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int i;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;
  char v21;

  if (result)
  {
    v8 = result;
    for (i = *(_DWORD *)(result + 24); ; ++i)
    {
      if (i >= *(_DWORD *)(v8 + 32))
      {
        v10 = 1;
        goto LABEL_8;
      }
      if (storeCachePos(v8, i, a3, a4, a5, a6, a7, a8))
        break;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"flushCache", 243, 21, 0, "flushing cache pos", a7, a8, v19);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDestroy", 423, 21, 0, "flush cache", v11, v12, v20);
    v10 = 0;
LABEL_8:
    if ((*(_DWORD *)v8 & 0x80000000) == 0)
    {
      if (ftruncate(*(_DWORD *)v8, *(_QWORD *)(v8 + 16)))
      {
        v13 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDestroy", 427, 21, *v13, "Final truncate", v14, v15, v19);
        v10 = 0;
      }
      if (fcntl(*(_DWORD *)v8, 51, 0) == -1)
      {
        v16 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDestroy", 432, 21, *v16, "Final FULLSYNC", v17, v18, v21);
        v10 = 0;
      }
      close(*(_DWORD *)v8);
    }
    if (*(int *)(v8 + 128) >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Closing paged file, input size: %llu B, output size: %llu B, bytes read: %llu B, bytes written: %llu B\n", *(_QWORD *)(v8 + 8), *(_QWORD *)(v8 + 16), *(_QWORD *)(v8 + 136), *(_QWORD *)(v8 + 144));
    free((void *)v8);
    if (v10)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t PagedFileDump(uint64_t a1, const char *a2)
{
  FILE **v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  __int16 v19;
  const char *v20;
  char v22;

  v3 = (FILE **)MEMORY[0x24BDAC8D8];
  v4 = "current PagedFile state";
  if (a2)
    v4 = a2;
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "*** %s\n", v4);
  LODWORD(v7) = *(_DWORD *)(a1 + 32);
  if (!(_DWORD)v7)
  {
    v14 = 0;
    v13 = 0;
    v12 = 0;
    v11 = 0;
    v10 = 0;
    v9 = 0;
    goto LABEL_29;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  do
  {
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v8);
    if (!v15)
    {
      if (v8 < *(unsigned int *)(a1 + 24))
        ++v13;
      else
        ++v14;
    }
    v16 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * v8);
    if ((_DWORD)v16 != -1)
    {
      ++v9;
      v11 += v15;
      if (v8 != *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v16))
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", 472, 21, 0, "invalid reverse index for IN", v5, v6, v22);
    }
    v17 = *(unsigned int *)(*(_QWORD *)(a1 + 72) + 4 * v8);
    if ((_DWORD)v17 != -1)
    {
      ++v10;
      v12 += v15;
      if (v8 != *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v17))
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", 480, 21, 0, "invalid reverse index for OUT", v5, v6, v22);
    }
    if (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v8) != -1 && *(_DWORD *)(*(_QWORD *)(a1 + 72) + 4 * v8) != -1)
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", 483, 21, 0, "inconsistency in inPage/outPage indices", v5, v6, v22);
    v18 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v8);
    if (v15)
    {
      if (v18 == -1 && *(_DWORD *)(*(_QWORD *)(a1 + 72) + 4 * v8) == -1)
      {
        v19 = 485;
        v20 = "inconsistency in nRefs != 0";
LABEL_25:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileDump", v19, 21, 0, v20, v5, v6, v22);
      }
    }
    else if (v18 != -1 || *(_DWORD *)(*(_QWORD *)(a1 + 72) + 4 * v8) != -1)
    {
      v19 = 486;
      v20 = "inconsistency in nRefs == 0";
      goto LABEL_25;
    }
    ++v8;
    v7 = *(unsigned int *)(a1 + 32);
  }
  while (v8 < v7);
  v3 = (FILE **)MEMORY[0x24BDAC8D8];
LABEL_29:
  fprintf(*v3, "  %u total pages\n", v7);
  fprintf(*v3, "  %u free pages in file\n", v13);
  fprintf(*v3, "  %u free pages in cache\n", v14);
  fprintf(*v3, "  %u input pages stored, %llu bytes referenced\n", v9, v11);
  return fprintf(*v3, "  %u output pages stored, %llu bytes referenced\n", v10, v12);
}

uint64_t PagedFileRetainIn(_QWORD *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char vars0;

  if (!a3)
    return 0;
  v8 = a1[6];
  while (1)
  {
    v9 = *(unsigned int *)(v8 + 4 * (a2 >> 12));
    if ((_DWORD)v9 == -1)
      break;
    v10 = a1[15];
    *(_DWORD *)(a1[14] + 4 * (a2 >> 12)) = v9;
    v11 = 4096 - (a2 & 0xFFF);
    *(_DWORD *)(v10 + 4 * v9) = a2 >> 12;
    if (v11 >= a3)
      v11 = a3;
    *(_QWORD *)(a1[5] + 8 * v9) += v11;
    a2 += v11;
    a3 -= v11;
    if (!a3)
      return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileRetainIn", 503, 21, 0, "input page is not stored", a7, a8, vars0);
  return 0xFFFFFFFFLL;
}

uint64_t PagedFileReleaseIn(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v11;
  FILE **v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char v18;

  if (!a3)
    return 0;
  v8 = a3;
  v11 = *(_QWORD *)(a1 + 48);
  v12 = (FILE **)MEMORY[0x24BDAC8D8];
  while (1)
  {
    v13 = 4096 - (a2 & 0xFFF) >= v8 ? v8 : 4096 - (a2 & 0xFFF);
    v14 = *(unsigned int *)(v11 + 4 * (a2 >> 12));
    if ((_DWORD)v14 == -1)
      break;
    v15 = *(_QWORD *)(a1 + 40);
    v16 = *(_QWORD *)(v15 + 8 * v14) - v13;
    *(_QWORD *)(v15 + 8 * v14) = v16;
    if (!v16)
    {
      if (*(int *)(a1 + 128) >= 3)
      {
        fprintf(*v12, "PagedFile: input page %u removed from storage\n", a2 >> 12);
        v11 = *(_QWORD *)(a1 + 48);
      }
      *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v14) = -1;
      *(_DWORD *)(v11 + 4 * (a2 >> 12)) = -1;
    }
    a2 += v13;
    v8 -= v13;
    if (!v8)
      return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileReleaseIn", 525, 21, 0, "input page is not stored", a7, a8, v18);
  return 0xFFFFFFFFLL;
}

uint64_t PagedFileRetainOut(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v11;
  FILE **v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int FreeCachePos;
  unsigned int v17;
  char v19;

  if (!a3)
    return 0;
  v8 = a3;
  v9 = a2;
  v11 = *(_QWORD *)(a1 + 64);
  v12 = (FILE **)MEMORY[0x24BDAC8D8];
  while (1)
  {
    v13 = v9 >> 12;
    if (4096 - (v9 & 0xFFF) >= v8)
      v14 = v8;
    else
      v14 = 4096 - (v9 & 0xFFF);
    v15 = *(unsigned int *)(v11 + 4 * v13);
    if ((_DWORD)v15 != -1)
      goto LABEL_11;
    FreeCachePos = getFreeCachePos(a1, a2, a3, a4, a5, a6, a7, a8);
    if (FreeCachePos == -1)
      break;
    v17 = FreeCachePos;
    if (*(int *)(a1 + 128) >= 3)
      fprintf(*v12, "PagedFile: assigning cache[%u] to new output page %u\n", FreeCachePos, v9 >> 12);
    v15 = v17;
    v11 = *(_QWORD *)(a1 + 64);
    *(_DWORD *)(*(_QWORD *)(a1 + 72) + 4 * v17) = v13;
    *(_DWORD *)(v11 + 4 * (v9 >> 12)) = v17;
LABEL_11:
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v15) += v14;
    v9 += v14;
    v8 -= v14;
    if (!v8)
      return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileRetainOut", 555, 21, 0, "no storage available for output page", a7, a8, v19);
  return 0xFFFFFFFFLL;
}

uint64_t getFreeCachePos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  char v17;

  v8 = *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(a1 + 32);
  if (v8 >= v9)
  {
LABEL_13:
    v14 = "no cache";
    v15 = 231;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"getFreeCachePos", v15, 21, 0, v14, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v11 = 0;
    v12 = v8 - v9;
    v13 = 0xFFFFFFFFLL;
    do
    {
      if (!*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v8 + 8 * v11))
        return (v8 + v11);
      if ((_DWORD)v13 == -1
        || *(_DWORD *)(*(_QWORD *)(a1 + 96) + 4 * v11) < *(_DWORD *)(*(_QWORD *)(a1 + 96)
                                                                   + 4 * (v13 - v8)))
      {
        v13 = (v8 + v11);
      }
      ++v11;
    }
    while (v12 + v11);
    if ((_DWORD)v13 == -1)
      goto LABEL_13;
    if (*(int *)(a1 + 128) >= 3)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "PagedFile: storing oldest cache[%u] to file\n", v13);
    if (storeCachePos(a1, v13, a3, a4, a5, a6, a7, a8))
    {
      v14 = "flushing cache pos";
      v15 = 235;
      goto LABEL_14;
    }
  }
  return v13;
}

uint64_t PagedFileReleaseAllIn(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return PagedFileReleaseIn(a1, 0, *(_QWORD *)(a1 + 8), a4, a5, a6, a7, a8);
}

BOOL PagedFileHasNoIn(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  BOOL v3;

  v1 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      if (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v2) != -1 && *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v2))
        break;
      v3 = ++v2 >= v1;
    }
    while (v1 != v2);
  }
  else
  {
    return 1;
  }
  return v3;
}

BOOL PagedFileHasAllOut(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = 0;
    while (1)
    {
      if (*(_DWORD *)(*(_QWORD *)(a1 + 72) + 4 * v3) != -1)
      {
        v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v3);
        v4 += v5;
        if (v3 < (v1 >> 12) && v5 != 4096)
          break;
      }
      if (v2 == ++v3)
        return v4 == v1;
    }
    return 0;
  }
  else
  {
    v4 = 0;
    return v4 == v1;
  }
}

uint64_t PagedFileReadAndReleaseIn(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  unint64_t v9;
  unint64_t v12;
  size_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t FreeCachePos;
  uint64_t v18;
  BOOL v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v31;
  __int16 v32;
  char v33;

  if (!a3)
    return 0;
  v8 = (char *)a4;
  v9 = a3;
  while (1)
  {
    v12 = a2 >> 12;
    if (4096 - (a2 & 0xFFF) >= v9)
      v13 = v9;
    else
      v13 = 4096 - (a2 & 0xFFF);
    v14 = *(_DWORD *)(a1 + 24);
    if (v14 <= v12)
    {
      v31 = "invalid input PAGE";
      v32 = 252;
      goto LABEL_27;
    }
    v15 = *(unsigned int *)(*(_QWORD *)(a1 + 48) + 4 * v12);
    if ((_DWORD)v15 == -1)
    {
      v31 = "input page is not stored";
      v32 = 254;
      goto LABEL_27;
    }
    v16 = (a2 >> 12);
    if (v15 >= v14)
    {
      v18 = 0xFFFFFFFFLL;
    }
    else
    {
      FreeCachePos = getFreeCachePos(a1, v15, a3, a4, a5, a6, a7, a8);
      if ((_DWORD)FreeCachePos == -1)
      {
        v31 = "could not get a free pos from cache";
        v32 = 261;
        goto LABEL_27;
      }
      v18 = FreeCachePos;
      LODWORD(v15) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v16);
      v14 = *(_DWORD *)(a1 + 24);
    }
    if (v15 < v14)
      break;
LABEL_15:
    v19 = v15 >= v14;
    v20 = v15 - v14;
    if (!v19 || v15 >= *(_DWORD *)(a1 + 32))
    {
      v31 = "could not move input page in cache";
      v32 = 273;
      goto LABEL_27;
    }
    v21 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v21 + 1;
    *(_DWORD *)(*(_QWORD *)(a1 + 96) + 4 * v20) = v21;
    v22 = cacheData(a1, v15, v18, a4, a5, a6, a7, a8);
    if (!v22)
      goto LABEL_28;
    memcpy(v8, (const void *)(v22 + (a2 & 0xFFF)), v13);
    PagedFileReleaseIn(a1, a2, v13, v25, v26, v27, v28, v29);
    a2 += v13;
    v8 += v13;
    v9 -= v13;
    if (!v9)
      return 0;
  }
  if (!movePage(a1, v15, v18, a4, a5, a6, a7, a8))
  {
    LODWORD(v15) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v16);
    v14 = *(_DWORD *)(a1 + 24);
    goto LABEL_15;
  }
  v31 = "moving page from disk to cache";
  v32 = 268;
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"inputPageData", v32, 21, 0, v31, a7, a8, v33);
LABEL_28:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileReadAndReleaseIn", 615, 21, 0, "unable to load input page", v23, v24, v33);
  return 0xFFFFFFFFLL;
}

uint64_t PagedFileRetainAndWriteOut(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  unint64_t v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t FreeCachePos;
  uint64_t v23;
  BOOL v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  const char *v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  char v33;

  if (!a3)
    return 0;
  v8 = (char *)a4;
  v9 = a3;
  while (1)
  {
    if (4096 - (a2 & 0xFFF) >= v9)
      v12 = v9;
    else
      v12 = 4096 - (a2 & 0xFFF);
    if (PagedFileRetainOut(a1, a2, v12, a4, a5, a6, a7, a8))
    {
      v31 = "retain output chunk";
      v32 = 639;
      goto LABEL_31;
    }
    v19 = *(_DWORD *)(a1 + 24);
    if (v19 <= (a2 >> 12))
    {
      v29 = "invalid output PAGE";
      v30 = 286;
      goto LABEL_29;
    }
    v20 = *(unsigned int *)(*(_QWORD *)(a1 + 64) + 4 * (a2 >> 12));
    if ((_DWORD)v20 == -1)
    {
      v29 = "output page is not stored";
      v30 = 288;
      goto LABEL_29;
    }
    v21 = (a2 >> 12);
    if (v20 >= v19)
    {
      v23 = 0xFFFFFFFFLL;
    }
    else
    {
      FreeCachePos = getFreeCachePos(a1, v20, v13, v14, v15, v16, v17, v18);
      if ((_DWORD)FreeCachePos == -1)
      {
        v29 = "could not get a free pos from cache";
        v30 = 294;
        goto LABEL_29;
      }
      v23 = FreeCachePos;
      LODWORD(v20) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v21);
      v19 = *(_DWORD *)(a1 + 24);
    }
    if (v20 < v19)
      break;
LABEL_16:
    v24 = v20 >= v19;
    v25 = v20 - v19;
    if (!v24 || v20 >= *(_DWORD *)(a1 + 32))
    {
      v29 = "could not move output page in cache";
      v30 = 305;
      goto LABEL_29;
    }
    v26 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v26 + 1;
    *(_DWORD *)(*(_QWORD *)(a1 + 96) + 4 * v25) = v26;
    v27 = cacheData(a1, v20, v23, v14, v15, v16, v17, v18);
    if (!v27)
      goto LABEL_30;
    memcpy((void *)(v27 + (a2 & 0xFFF)), v8, v12);
    a2 += v12;
    v8 += v12;
    v9 -= v12;
    if (!v9)
      return 0;
  }
  if (!movePage(a1, v20, v23, v14, v15, v16, v17, v18))
  {
    LODWORD(v20) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v21);
    v19 = *(_DWORD *)(a1 + 24);
    goto LABEL_16;
  }
  v29 = "moving page from disk to cache";
  v30 = 301;
LABEL_29:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"outputPageData", v30, 21, 0, v29, v17, v18, v33);
LABEL_30:
  v31 = "unable to load output page";
  v32 = 643;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"PagedFileRetainAndWriteOut", v32, 21, 0, v31, v17, v18, v33);
  return 0xFFFFFFFFLL;
}

uint64_t storeCachePos(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;

  v8 = *(unsigned int *)(a1 + 24);
  if (v8 > a2 || *(_DWORD *)(a1 + 32) <= a2)
  {
    v18 = "invalid cache POS";
    v19 = 165;
    goto LABEL_9;
  }
  v11 = *(_QWORD *)(a1 + 40);
  v12 = *(_QWORD *)(v11 + 8 * a2);
  if (!v12)
    return 0;
  v13 = *(_QWORD *)(a1 + 56);
  v14 = *(unsigned int *)(v13 + 4 * a2);
  if ((_DWORD)v14 == -1)
  {
    v20 = *(unsigned int *)(*(_QWORD *)(a1 + 72) + 4 * a2);
    if ((_DWORD)v20 != -1)
    {
      if (*(_QWORD *)(v11 + 8 * v20))
      {
        v21 = -(int)v8;
        v22 = v8 - 1;
        do
        {
          if (v22 == -1)
            goto LABEL_18;
          v23 = *(_QWORD *)(v11 + 8 * v22);
          ++v21;
          --v22;
        }
        while (v23);
        if (v21 == 1)
        {
LABEL_18:
          v18 = "no free pages in file";
          v19 = 208;
          goto LABEL_9;
        }
        v28 = -v21;
        if (*(int *)(a1 + 128) >= 3)
          fwrite("PagedFile: vacating file pos\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
        if (movePage(a1, v20, v28, a4, a5, a6, a7, a8))
        {
          v18 = "vacating page in file";
          v19 = 210;
          goto LABEL_9;
        }
      }
      if (*(int *)(a1 + 128) >= 3)
        fwrite("PagedFile: storing cached output page to file\n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      result = movePage(a1, a2, v20, a4, a5, a6, a7, a8);
      if ((_DWORD)result)
      {
        v18 = "moving output page from cache to disk";
        v19 = 213;
        goto LABEL_9;
      }
      return result;
    }
    v18 = "nRefs inconsistency";
    v19 = 215;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"storeCachePos", v19, 21, 0, v18, a7, a8, v29);
    return 0xFFFFFFFFLL;
  }
  v15 = *(unsigned int *)(*(_QWORD *)(a1 + 112) + 4 * v14);
  if ((_DWORD)v15 == -1)
  {
    v18 = "cached input page does not have a file position";
    v19 = 175;
    goto LABEL_9;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * v15) == (_DWORD)v14)
  {
    result = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v14) = v15;
    *(_QWORD *)(v11 + 8 * v15) = v12;
    *(_DWORD *)(v13 + 4 * v15) = v14;
    v17 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)(v17 + 4 * v15) = -1;
    *(_QWORD *)(v11 + 8 * a2) = 0;
    *(_DWORD *)(v13 + 4 * a2) = -1;
    *(_DWORD *)(v17 + 4 * a2) = -1;
    return result;
  }
  v24 = -(int)v8;
  v25 = v8 - 1;
  do
  {
    if (v25 == -1)
      goto LABEL_24;
    v26 = *(_QWORD *)(v11 + 8 * v25);
    ++v24;
    --v25;
  }
  while (v26);
  if (v24 == 1)
  {
LABEL_24:
    v18 = "no free pages in file";
    v19 = 196;
    goto LABEL_9;
  }
  v27 = -v24;
  if (*(int *)(a1 + 128) >= 3)
    fwrite("PagedFile: storing cached input page to file\n", 0x2DuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  result = movePage(a1, a2, v27, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    v18 = "moving input page from cache to disk";
    v19 = 198;
    goto LABEL_9;
  }
  return result;
}

uint64_t movePage(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  const char *v10;
  __int16 v11;
  uint64_t v14;
  unsigned int v15;
  uint64_t result;
  unsigned int v17;
  uint64_t v19;
  int v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;

  v8 = *(_DWORD *)(a1 + 32);
  if (v8 <= a2 || v8 <= a3)
  {
    v10 = "invalid SRC/DST";
    v11 = 77;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"movePage", v11, 21, 0, v10, a7, a8, v39);
    return 0xFFFFFFFFLL;
  }
  v14 = *(_QWORD *)(a1 + 40);
  if (!*(_QWORD *)(v14 + 8 * a2))
  {
    v10 = "SRC is empty";
    v11 = 78;
    goto LABEL_10;
  }
  v15 = a3;
  if (*(_QWORD *)(v14 + 8 * a3))
  {
    v10 = "DST is not empty";
    v11 = 79;
    goto LABEL_10;
  }
  v17 = *(_DWORD *)(a1 + 24);
  if (v17 > a2 && v17 > a3)
  {
    v22 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * a2);
    if ((_DWORD)v22 != -1)
      *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * v22) = a3;
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * a3) = v22;
    if (*(int *)(a1 + 128) >= 3)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "PagedFile: moving page from file[%u] to file[%u]\n", a2, a3);
    if (pread(*(_DWORD *)a1, *(void **)(a1 + 80), 0x1000uLL, a2 << 12) != 4096)
    {
      v10 = "reading page";
      v11 = 93;
      goto LABEL_10;
    }
    if (pwrite(*(_DWORD *)a1, *(const void **)(a1 + 80), 0x1000uLL, v15 << 12) != 4096)
    {
      v10 = "writing page";
      v11 = 94;
      goto LABEL_10;
    }
    *(int64x2_t *)(a1 + 136) = vaddq_s64(*(int64x2_t *)(a1 + 136), vdupq_n_s64(0x1000uLL));
  }
  else if (v17 > a2 || v17 <= a3)
  {
    if (v17 <= a2 || v17 > a3)
    {
      if (*(int *)(a1 + 128) >= 3)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "PagedFile: moving page from cache[%u] to cache[%u]\n", a2, a3);
      v26 = (void *)cacheData(a1, v15, a3, a4, a5, a6, a7, a8);
      v33 = (const void *)cacheData(a1, a2, v27, v28, v29, v30, v31, v32);
      memcpy(v26, v33, 0x1000uLL);
    }
    else
    {
      v23 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * a2);
      if ((_DWORD)v23 != -1)
        *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * v23) = a2;
      *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * a2) = v23;
      if (*(int *)(a1 + 128) >= 3)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "PagedFile: moving page from file[%u] to cache[%u]\n", a2, a3);
      v24 = *(_DWORD *)a1;
      v25 = (void *)cacheData(a1, v15, a3, a4, a5, a6, a7, a8);
      if (pread(v24, v25, 0x1000uLL, a2 << 12) != 4096)
      {
        v10 = "reading page";
        v11 = 121;
        goto LABEL_10;
      }
      *(_QWORD *)(a1 + 136) += 4096;
    }
  }
  else
  {
    v19 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * a2);
    if ((_DWORD)v19 != -1)
      *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * v19) = a3;
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * a3) = v19;
    if (*(int *)(a1 + 128) >= 3)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "PagedFile: moving page from cache[%u] to file[%u]\n", a2, a3);
    v20 = *(_DWORD *)a1;
    v21 = (const void *)cacheData(a1, a2, a3, a4, a5, a6, a7, a8);
    if (pwrite(v20, v21, 0x1000uLL, v15 << 12) != 4096)
    {
      v10 = "writing page";
      v11 = 108;
      goto LABEL_10;
    }
    *(_QWORD *)(a1 + 144) += 4096;
  }
  v34 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v34 + 8 * v15) = *(_QWORD *)(v34 + 8 * a2);
  *(_QWORD *)(v34 + 8 * a2) = 0;
  v35 = *(_QWORD *)(a1 + 56);
  v36 = *(unsigned int *)(v35 + 4 * a2);
  *(_DWORD *)(v35 + 4 * v15) = v36;
  *(_DWORD *)(v35 + 4 * a2) = -1;
  if ((_DWORD)v36 != -1)
    *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v36) = v15;
  v37 = *(_QWORD *)(a1 + 72);
  v38 = *(unsigned int *)(v37 + 4 * a2);
  *(_DWORD *)(v37 + 4 * v15) = v38;
  *(_DWORD *)(v37 + 4 * a2) = -1;
  result = 0;
  if ((_DWORD)v38 != -1)
    *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v38) = v15;
  return result;
}

uint64_t cacheData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  char vars0;

  v8 = *(_DWORD *)(a1 + 24);
  v9 = a2 >= v8;
  v10 = a2 - v8;
  if (v9 && *(_DWORD *)(a1 + 32) > a2)
    return *(_QWORD *)(a1 + 88) + (v10 << 12);
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/PagedFile.c", (uint64_t)"cacheData", 66, 21, 0, "invalid cache pos", a7, a8, vars0);
  return 0;
}

_WORD *enterThreadErrorContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey;
  _WORD *result;
  _WORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;

  ErrorContextKey = getErrorContextKey();
  result = pthread_getspecific(ErrorContextKey);
  if (result)
  {
    ++result[2];
  }
  else
  {
    v11 = calloc(1uLL, 0x2000uLL);
    if (v11)
    {
      v11[2] = 1;
      *((_DWORD *)v11 + 18) = 531890176;
      return (_WORD *)setThreadErrorContext(v11, v12, v13, v14, v15, v16, v17, v18, a9);
    }
    else
    {
      v19 = __error();
      return (_WORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThreadErrorContext", 76, 5, *v19, "malloc", v20, v21, a9);
    }
  }
  return result;
}

size_t setThreadErrorContext(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  pthread_key_t ErrorContextKey;
  size_t result;
  int *v12;
  uint64_t v13;
  uint64_t v14;

  ErrorContextKey = getErrorContextKey();
  result = pthread_setspecific(ErrorContextKey, a1);
  if ((_DWORD)result)
  {
    v12 = __error();
    return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"setThreadErrorContext", 65, 5, *v12, "pthread_setspecific", v13, v14, a9);
  }
  return result;
}

uint64_t leaveThreadErrorContext(__CFError **a1, const __CFString **a2, int a3)
{
  pthread_key_t ErrorContextKey;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned __int16 v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  char *v21;
  char *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int16 *v25;
  unsigned int v26;
  unsigned int v27;
  size_t v29;
  char *v30;
  const __CFAllocator *v31;
  CFStringRef v32;
  CFStringRef v33;
  __CFError *v34;
  unint64_t v35;
  size_t v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  CFIndex v41;
  char *v42;
  char *v43;
  const void *v44;
  CFIndex v45;
  char *v46;
  char *v47;
  char v49;
  void *userInfoKeys[128];
  void *userInfoValues[2];

  userInfoValues[1] = *(void **)MEMORY[0x24BDAC8D0];
  ErrorContextKey = getErrorContextKey();
  v7 = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (v7)
  {
    v15 = v7;
    v16 = v7[2] - 1;
    v7[2] = v16;
    if (!v16)
    {
      v18 = v7[36];
      v17 = *(unsigned int *)v7;
      if (!v7[36] && (v17 & 0x80000000) == 0)
      {
        if (!v7[3] || !a2 && !a3)
          goto LABEL_46;
        bzero(userInfoKeys, 0x400uLL);
        v35 = 0;
        do
        {
          v36 = strlen((const char *)userInfoKeys);
          if (v36 + 20 > 0x3FF)
            break;
          if (v36)
            snprintf((char *)userInfoKeys + v36, 1024 - v36, ",0x%08x");
          else
            snprintf((char *)userInfoKeys, 0x400uLL, "Warnings:0x%08x");
          ++v35;
        }
        while (v35 < v15[3]);
        v37 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], (const char *)userInfoKeys, 0x600u);
        if (!v37)
          goto LABEL_46;
        v38 = v37;
        if (a2)
        {
          *a2 = v37;
          goto LABEL_46;
        }
        v45 = CFStringGetLength(v37) + 1;
        v46 = (char *)calloc(1uLL, v45);
        if (v46)
        {
          v47 = v46;
          CFStringGetCString(v38, v46, v45, 0x600u);
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", v47);
          free(v47);
        }
        v44 = v38;
LABEL_45:
        CFRelease(v44);
        goto LABEL_46;
      }
      if (!a1 && !a3)
        goto LABEL_46;
      v19 = v18 + 32;
      v20 = (char *)calloc(v18 + 32, 1uLL);
      if (!v20)
        goto LABEL_46;
      v21 = v20;
      v22 = v20;
      if ((v17 & 0x80000000) != 0)
      {
        snprintf(v20, v19, "Error 0x%08x\n", v17);
        v22 = &v21[strlen(v21)];
      }
      v23 = v15[36];
      if (v15[36])
      {
        v24 = 0;
        do
        {
          v25 = (unsigned __int16 *)((char *)v15 + v24 + 76);
          v26 = *v25;
          v27 = v26 + v24;
          if (v26 < 4 || v27 > v23)
            break;
          v29 = v26 - 3;
          memcpy(v22, v25 + 1, v29);
          v30 = &v22[v29];
          *v30 = 10;
          v22 = v30 + 1;
          v24 = (unsigned __int16)v27;
          v23 = v15[36];
        }
        while (v23 > (unsigned __int16)v27);
      }
      if (v22 > v21)
        *(v22 - 1) = 0;
      v31 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      v32 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], v21, 0x600u);
      if (!v32)
      {
        free(v21);
        goto LABEL_46;
      }
      v33 = v32;
      userInfoKeys[0] = *(void **)MEMORY[0x24BDBD3A0];
      userInfoValues[0] = (void *)v32;
      v34 = CFErrorCreateWithUserInfoKeysAndValues(v31, CFSTR("com.apple.ParallelCompression"), 1, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 1);
      CFRelease(v33);
      free(v21);
      if (v34)
      {
        if (!a1)
        {
          v39 = CFErrorCopyDescription(v34);
          if (v39)
          {
            v40 = v39;
            v41 = CFStringGetLength(v39) + 1;
            v42 = (char *)calloc(1uLL, v41);
            if (v42)
            {
              v43 = v42;
              CFStringGetCString(v40, v42, v41, 0x600u);
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", v43);
              free(v43);
            }
            CFRelease(v40);
          }
          v44 = v34;
          goto LABEL_45;
        }
        *a1 = v34;
      }
LABEL_46:
      setThreadErrorContext(0, v8, v9, v10, v11, v12, v13, v14, v49);
      free(v15);
      return v17;
    }
  }
  return 0;
}

size_t appendThreadErrorContextString(size_t result)
{
  const void *v1;
  size_t v2;
  pthread_key_t ErrorContextKey;
  size_t v4;
  __int16 v5;
  uint64_t v6;
  size_t v7;
  size_t v8;

  if (result)
  {
    v1 = (const void *)result;
    result = strlen((const char *)result);
    if (result - 8193 >= 0xFFFFFFFFFFFFE000)
    {
      v2 = result;
      ErrorContextKey = getErrorContextKey();
      result = (size_t)pthread_getspecific(ErrorContextKey);
      if (result)
      {
        v4 = result;
        v5 = v2 + 3;
        v6 = *(unsigned __int16 *)(result + 72);
        if (v6 + (unsigned __int16)(v2 + 3) <= *(unsigned __int16 *)(result + 74))
        {
          v7 = result + v6;
          *(_WORD *)(v7 + 76) = v5;
          v8 = v7 + 78;
          result = (size_t)memcpy((void *)(v7 + 78), v1, v2);
          *(_BYTE *)(v8 + v2) = 0;
          *(_WORD *)(v4 + 72) += v5;
        }
      }
    }
  }
  return result;
}

_WORD *updateThreadErrorContextErrorCode(_WORD *result)
{
  int v1;
  pthread_key_t ErrorContextKey;

  if ((result & 0x80000000) != 0)
  {
    v1 = (int)result;
    ErrorContextKey = getErrorContextKey();
    result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*(_DWORD *)result & 0x80000000) == 0)
      {
        *(_DWORD *)result = v1;
        result[3] = 0;
      }
    }
  }
  return result;
}

_DWORD *updateThreadErrorContextWarningCode(_DWORD *result)
{
  int v1;
  pthread_key_t ErrorContextKey;
  uint64_t v3;

  if ((result & 0x80000000) != 0)
  {
    v1 = (int)result;
    ErrorContextKey = getErrorContextKey();
    result = pthread_getspecific(ErrorContextKey);
    if (result)
    {
      if ((*result & 0x80000000) == 0)
      {
        v3 = *((unsigned __int16 *)result + 3);
        if (v3 <= 0xF)
        {
          result[v3 + 2] = v1;
          *((_WORD *)result + 3) = v3 + 1;
        }
      }
    }
  }
  return result;
}

unsigned __int16 *saveThreadErrorContext(void *a1)
{
  pthread_key_t ErrorContextKey;
  unsigned __int16 *result;
  unsigned __int16 *v4;
  uint64_t v5;
  size_t v6;

  ErrorContextKey = getErrorContextKey();
  result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    v4 = result;
    bzero(a1, 0x2000uLL);
    v5 = v4[36];
    if (v5 <= 0x1FB4)
      v6 = v5 + 76;
    else
      v6 = 0;
    return (unsigned __int16 *)memcpy(a1, v4, v6);
  }
  return result;
}

unsigned __int16 *restoreThreadErrorContext(__int128 *a1)
{
  pthread_key_t ErrorContextKey;
  unsigned __int16 *result;
  __int128 v4;
  __int128 v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[28];

  ErrorContextKey = getErrorContextKey();
  result = (unsigned __int16 *)pthread_getspecific(ErrorContextKey);
  if (result)
  {
    v4 = a1[1];
    v13 = *a1;
    v14 = v4;
    v5 = a1[3];
    v15 = a1[2];
    *(_OWORD *)v16 = v5;
    *(_OWORD *)&v16[12] = *(__int128 *)((char *)a1 + 60);
    if ((v13 & 0x80000000) == 0)
    {
      v6 = WORD3(v13);
      if ((*(_DWORD *)result & 0x80000000) != 0 && WORD3(v13) <= 0xFu)
      {
        v6 = WORD3(v13) + 1;
        *((_DWORD *)&v13 + WORD3(v13) + 2) = *(_DWORD *)result;
      }
      v7 = result[3];
      if (result[3] && v6 <= 0xF)
      {
        v8 = 0;
        do
        {
          v9 = *(_DWORD *)&result[2 * v8 + 4];
          if (v8 >= v6 || *((_DWORD *)&v13 + v8 + 2) != v9)
          {
            v10 = v6++;
            *((_DWORD *)&v13 + v10 + 2) = v9;
          }
          ++v8;
        }
        while (v8 < v7 && v6 < 0x10);
      }
      WORD3(v13) = v6;
    }
    v11 = *(_OWORD *)v16;
    *((_OWORD *)result + 2) = v15;
    *((_OWORD *)result + 3) = v11;
    *(_OWORD *)(result + 30) = *(_OWORD *)&v16[12];
    v12 = v14;
    *(_OWORD *)result = v13;
    *((_OWORD *)result + 1) = v12;
    if (*(unsigned __int16 *)&v16[24] <= 0x1FB4uLL)
      return (unsigned __int16 *)memcpy(result + 38, (char *)a1 + 76, *(unsigned __int16 *)&v16[24]);
  }
  return result;
}

uint64_t createThread(pthread_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  _QWORD *v8;
  _QWORD *v9;
  pthread_attr_t *v10;
  pthread_attr_t *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  const void *v26;
  uint64_t v28;
  _opaque_pthread_t *v29;
  uint64_t qos_class_np;
  uint64_t v31;
  dispatch_block_t v32;
  int *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[5];
  int __relative_priority[2];

  *(_QWORD *)__relative_priority = 0;
  v8 = calloc(1uLL, 0x2000uLL);
  if (!v8)
  {
    v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 552, 5, *v19, "malloc", v20, v21, v36[0]);
    return -*__error();
  }
  v9 = v8;
  v10 = (pthread_attr_t *)calloc(1uLL, 0x40uLL);
  if (!v10)
  {
    v22 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 555, 5, *v22, "malloc", v23, v24, v36[0]);
    v25 = __error();
    v13 = -*v25;
    if (!*v25)
      return v13;
    goto LABEL_10;
  }
  v11 = v10;
  v12 = pthread_attr_init(v10);
  if ((_DWORD)v12)
  {
    v13 = v12;
    v14 = *__error();
    v17 = "pthread_attr_init";
    v18 = 558;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", v18, 5, v14, v17, v15, v16, v36[0]);
    goto LABEL_6;
  }
  if (a4)
  {
    v28 = pthread_attr_setstacksize(v11, a4);
    if ((_DWORD)v28)
    {
      v13 = v28;
      v14 = *__error();
      v17 = "pthread_attr_setstacksize";
      v18 = 564;
      goto LABEL_5;
    }
  }
  v29 = pthread_self();
  qos_class_np = pthread_get_qos_class_np(v29, (qos_class_t *)&__relative_priority[1], __relative_priority);
  if ((_DWORD)qos_class_np)
  {
    v13 = qos_class_np;
    v14 = *__error();
    v17 = "pthread_get_qos_class_np";
    v18 = 570;
    goto LABEL_5;
  }
  v31 = pthread_attr_set_qos_class_np(v11, (qos_class_t)__relative_priority[1], __relative_priority[0]);
  if ((_DWORD)v31)
  {
    v13 = v31;
    v14 = *__error();
    v17 = "pthread_attr_set_qos_class_np";
    v18 = 572;
    goto LABEL_5;
  }
  v36[0] = MEMORY[0x24BDAC760];
  v36[1] = 0x40000000;
  v36[2] = __createThread_block_invoke;
  v36[3] = &__block_descriptor_tmp;
  v36[4] = v9;
  v32 = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v36);
  v9[2] = v32;
  if (v32)
  {
    *v9 = a2;
    v9[1] = a3;
    *((_DWORD *)v9 + 7) = 1;
    *((_DWORD *)v9 + 24) = 530317312;
    v13 = pthread_create(a1, v11, (void *(__cdecl *)(void *))threadWrapperProc, v9);
    if ((_DWORD)v13)
    {
      v14 = *__error();
      v17 = "pthread_create";
      v18 = 591;
      goto LABEL_5;
    }
  }
  else
  {
    v33 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"createThread", 578, 5, *v33, "dispatch_block_create", v34, v35, v36[0]);
    v13 = -*__error();
  }
LABEL_6:
  pthread_attr_destroy(v11);
  free(v11);
  if (!(_DWORD)v13)
    return v13;
LABEL_10:
  v26 = (const void *)v9[2];
  if (v26)
    _Block_release(v26);
  free(v9);
  return v13;
}

uint64_t __createThread_block_invoke(uint64_t a1)
{
  return (**(uint64_t (***)(_QWORD))(a1 + 32))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
}

uint64_t threadWrapperProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v17;
  char v18;

  setThreadErrorContext((const void *)(a1 + 24), a2, a3, a4, a5, a6, a7, a8, v17);
  (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
  setThreadErrorContext(0, v9, v10, v11, v12, v13, v14, v15, v18);
  return a1;
}

uint64_t joinThread(_opaque_pthread_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  pthread_key_t ErrorContextKey;
  _DWORD *v10;
  _DWORD *v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  _WORD *v16;
  unsigned __int16 v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  const void *v24;
  char v26;
  void *v27;

  v27 = 0;
  v1 = pthread_join(a1, &v27);
  if ((_DWORD)v1)
  {
    v4 = v1;
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 623, 5, *v5, "pthread_join", v6, v7, v26);
    v8 = 0;
    goto LABEL_26;
  }
  v8 = v27;
  if (*((_WORD *)v27 + 14) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", (uint64_t)"joinThread", 627, 5, 0, "expected ref_count=1 for terminating thread", v2, v3, v26);
    v4 = 0xFFFFFFFFLL;
    goto LABEL_26;
  }
  ErrorContextKey = getErrorContextKey();
  v10 = pthread_getspecific(ErrorContextKey);
  if (!v10)
    goto LABEL_25;
  v11 = v10;
  v12 = *v10;
  if ((*v10 & 0x80000000) == 0)
  {
    v13 = v8[6];
    if (v13 < 0)
    {
      *v10 = v13;
      v12 = v13;
    }
  }
  v14 = *((unsigned __int16 *)v8 + 48);
  if (!*((_WORD *)v8 + 48))
  {
LABEL_15:
    if (v12)
    {
      v4 = 0;
      *((_WORD *)v11 + 3) = 0;
      goto LABEL_26;
    }
    if (*((_WORD *)v8 + 15))
    {
      v19 = 0;
      v20 = *((unsigned __int16 *)v11 + 3);
      LODWORD(v21) = 16 - v20;
      if (v20 <= 0x10)
        v21 = v21;
      else
        v21 = 0;
      v22 = (uint64_t)&v11[v20 + 2];
      v23 = v20 + 1;
      do
      {
        if (v21 == v19)
          break;
        *(_DWORD *)(v22 + 4 * v19) = v8[v19 + 8];
        *((_WORD *)v11 + 3) = v23 + v19++;
      }
      while (v19 < *((unsigned __int16 *)v8 + 15));
    }
LABEL_25:
    v4 = 0;
    goto LABEL_26;
  }
  v15 = 0;
  while (1)
  {
    v16 = (_WORD *)((char *)v8 + v15 + 100);
    v4 = (unsigned __int16)*v16;
    if (!*v16)
      break;
    v17 = v15 + v4;
    if (v15 + v4 > v14)
      goto LABEL_25;
    v18 = *((unsigned __int16 *)v11 + 36);
    if ((int)v18 + (int)v4 <= *((unsigned __int16 *)v11 + 37))
    {
      memcpy((char *)v11 + v18 + 76, v16, (unsigned __int16)*v16);
      *((_WORD *)v11 + 36) += v4;
      v15 = v17;
      v14 = *((unsigned __int16 *)v8 + 48);
      if (v14 > v17)
        continue;
    }
    v12 = *v11;
    goto LABEL_15;
  }
LABEL_26:
  v24 = (const void *)*((_QWORD *)v8 + 2);
  if (v24)
    _Block_release(v24);
  free(v8);
  return v4;
}

size_t ParallelCompressionUpdateError(_WORD *a1, size_t a2)
{
  updateThreadErrorContextErrorCode(a1);
  return appendThreadErrorContextString(a2);
}

uint64_t getErrorContextKey()
{
  int *v0;

  if (pthread_once(&getErrorContextKey_errorContextOnce, (void (*)(void))createErrorContextKey))
  {
    v0 = __error();
    pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "getErrorContextKey", 53, 5, *v0, "pthread_once");
  }
  return gErrorContextKey;
}

uint64_t createErrorContextKey()
{
  uint64_t result;
  int *v1;

  result = pthread_key_create((pthread_key_t *)&gErrorContextKey, 0);
  if ((_DWORD)result)
  {
    v1 = __error();
    return pc_log_error("/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Threads.c", "createErrorContextKey", 42, 5, *v1, "pthread_key_create");
  }
  return result;
}

size_t PCompressLZMA6Encode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZMADecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZMA);
  if (!result)
    return -1;
  return result;
}

uint64_t PCompressZLIB5Encode(uint64_t a1, unint64_t a2, const uint8_t *a3, size_t a4)
{
  BOOL v4;
  size_t v5;
  size_t v7;

  v4 = a2 >= 2;
  v5 = a2 - 2;
  if (!v4)
    return -1;
  *(_WORD *)a1 = 24184;
  v7 = compression_encode_buffer((uint8_t *)(a1 + 2), v5, a3, a4, 0, COMPRESSION_ZLIB);
  if (v7)
    return v7 + 2;
  else
    return -1;
}

size_t PCompressZLIBDecode(uint8_t *a1, size_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4;
  size_t v5;
  size_t result;

  v4 = a4 >= 2;
  v5 = a4 - 2;
  if (!v4)
    return -1;
  result = compression_decode_buffer(a1, a2, (const uint8_t *)(a3 + 2), v5, 0, COMPRESSION_ZLIB);
  if (!result)
    return -1;
  return result;
}

uint64_t load_variants(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  const char **v6;
  FILE **v7;
  const char **v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  BOOL v20;
  const char *v22;
  __int16 v23;
  char v25;

  v4 = 0;
  v5 = 0;
  v6 = (const char **)(a2 + 16);
  v7 = (FILE **)MEMORY[0x24BDAC8D8];
  while (1)
  {
    v8 = v6;
    if (v4)
      v8 = (const char **)(*(_QWORD *)(a2 + 8) + 8 * v4 - 8);
    v9 = rawimg_create_with_path(*v8);
    *(_QWORD *)(a1 + 8 * v4) = v9;
    if (!v9)
    {
      v22 = "rawimg_create_with_file";
      v23 = 37;
      goto LABEL_26;
    }
    if ((rawimg_get_digests((uint64_t)v9, *(_DWORD *)(a2 + 36), 0, 0) & 0x80000000) != 0)
      break;
    v12 = *(uint64_t **)(a1 + 8 * v4);
    if (v4 < 2)
    {
LABEL_19:
      *(_QWORD *)(a1 + 8 * v5++) = v12;
    }
    else
    {
      v13 = 1;
      while (1)
      {
        v14 = *(_QWORD **)(a1 + 8 * v13);
        v15 = v14[261];
        v16 = v14[262];
        v17 = v14[263];
        v18 = v14[264];
        v19 = v12[261] == v15 && v12[262] == v16;
        v20 = v19 && v12[263] == v17;
        if (v20 && v12[264] == v18)
          break;
        if (v4 == ++v13)
          goto LABEL_19;
      }
      rawimg_destroy(v12);
      if (*(_DWORD *)(a2 + 40))
        fprintf(*v7, "ImageDiff: Removed non-unique input variant <%s>.\n", *(const char **)(*(_QWORD *)(a1 + 8 * v4) + 2048));
    }
    if (++v4 > *(_QWORD *)a2)
      return v5;
  }
  v22 = "rawimg_get_digests";
  v23 = 38;
LABEL_26:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"load_variants", v23, 134, 0, v22, v10, v11, v25);
  return 0;
}

uint64_t patch_write_controls(AAByteStream_impl *a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  off_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  AAFlagSet v12;
  AAByteStream v13;
  uint64_t v14;
  uint64_t v15;
  AAByteStream_impl *v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  char v33;

  v8 = AAByteStreamSeek(a1, 0, 1);
  *(_QWORD *)(a3 + 38) = v8;
  if (v8 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 331, 134, 0, "AAByteStreamSeek", v9, v10, v33);
    v20 = 0;
    v16 = 0;
  }
  else
  {
    v11 = *(unsigned int *)(a4 + 40);
    if (v11 <= 3)
      v12 = v11 << 62;
    else
      v12 = 0xC000000000000000;
    v13 = AACompressionOutputStreamOpen(a1, 0x306u, 0x100000uLL, v12, *(_DWORD *)(a4 + 36));
    v16 = v13;
    if (v13)
    {
      v17 = a2[2];
      if (v17 < 2)
      {
        v21 = a2[3];
        v18 = (uint64_t *)(v21 + 56);
        v19 = (uint64_t *)(v21 + 40);
      }
      else
      {
        v18 = (uint64_t *)(a2 + 11);
        v19 = (uint64_t *)(a2 + 9);
      }
      v22 = *v18;
      *(_QWORD *)(a3 + 18) = v22;
      v20 = *v19;
      if (*((_QWORD *)v13 + 3))
      {
        v23 = 8 * v17 + 16;
        v24 = v23 * v22;
        if (!(v23 * v22))
          goto LABEL_19;
        v25 = 0;
        v26 = *v19;
        v27 = v23 * v22;
        while (1)
        {
          v28 = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))v16 + 3))(*(_QWORD *)v16, v26, v27);
          if (v28 < 1)
            break;
          v26 += v28;
          v25 += v28;
          v27 -= v28;
          if (!v27)
            goto LABEL_18;
        }
        v25 = v28;
LABEL_18:
        if (v24 == v25)
        {
LABEL_19:
          v29 = 0;
          goto LABEL_22;
        }
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 350, 134, 0, "aaByteStreamWriteExpected", v14, v15, v33);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 335, 134, 0, "AACompressionOutputStreamOpen", v14, v15, v33);
      v20 = 0;
    }
  }
  v29 = 1;
LABEL_22:
  if (AAByteStreamClose(v16) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_controls", 353, 134, 0, "AAByteStreamClose", v30, v31, v33);
  }
  else if (!v29)
  {
    return v20;
  }
  return 0;
}

uint64_t RawImageDiff(uint64_t a1)
{
  FILE **v2;
  unint64_t v3;
  unint64_t v4;
  const char *v5;
  const char *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  unint64_t variants;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void **v22;
  unint64_t v23;
  char *v24;
  char *v25;
  _DWORD *v26;
  AAByteStream v27;
  uint64_t v28;
  uint64_t v29;
  AAByteStream_impl *v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  AAByteStream_impl *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  AAByteStream v49;
  uint64_t v50;
  uint64_t v51;
  AAByteStream_impl *v52;
  uint64_t **v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  AAByteStream_impl *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  AAByteStream_impl *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  size_t v67;
  void *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  BOOL v90;
  BOOL v91;
  BOOL v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  int64x2_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  const char *v105;
  __int16 v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  __int16 v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  unint64_t v119;
  unint64_t v120;
  int v122;
  char *v123;
  uint64_t v124;
  int v125;
  AAByteStream_impl *v126;
  uint64_t v127;
  uint64_t v128;
  AAByteStream_impl *v129;
  uint64_t v130;
  AAFlagSet v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  AAByteStream_impl *v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  off_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  AAByteStream v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t **v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int *v157;
  uint64_t v158;
  uint64_t v159;
  __int16 v160;
  const char *v161;
  AAByteStream_impl *v162;
  int v163;
  uint64_t v164;
  AAByteStream v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t **v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  _BYTE *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  unint64_t v183;
  uint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  BOOL v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  uint64_t v192;
  uint64_t v193;
  _BYTE *v194;
  uint64_t v195;
  uint64_t v196;
  unint64_t v197;
  _BYTE *v198;
  uint64_t v199;
  unint64_t v200;
  uint64_t v201;
  unint64_t v202;
  _BYTE *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unint64_t v209;
  uint64_t v210;
  uint64_t v211;
  char *v212;
  unint64_t v213;
  uint64_t v214;
  uint64_t v215;
  _BYTE *v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  unint64_t v220;
  int *v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  __int16 v227;
  const char *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  off_t v243;
  uint64_t v244;
  uint64_t v245;
  const char *v246;
  int *v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  uint64_t v251;
  const char *v252;
  __int16 v253;
  const char *v254;
  __int16 v255;
  const char *v256;
  __int16 v257;
  const char *v258;
  __int16 v259;
  const char *v260;
  __int16 v261;
  int v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  const char *v269;
  __int16 v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  unint64_t v274;
  uint64_t v275;
  int *v276;
  uint64_t v277;
  uint64_t v278;
  int v279;
  uint64_t v280;
  uint64_t v281;
  char v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t *v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  uint64_t v292;
  unint64_t v293;
  uint64_t v294;
  uint64_t v295;
  unint64_t v296;
  unint64_t v297;
  uint64_t v298;
  off_t *v299;
  uint64_t v300;
  AAByteStream_impl *s;
  AAByteStream_impl *v302;
  int64x2_t v303;
  AAByteStream_impl *v304;
  int v305;
  AAByteStream_impl *v306;
  AAByteStream v307;
  AAByteStream_impl *v308;
  unint64_t v309;
  uint64_t v310;
  AAByteStream_impl *v311;
  _BYTE *v312;
  _BYTE *v313;
  _BYTE *v314;
  AAByteStream v315;
  AAByteStream_impl *v316;
  unint64_t v317;
  uint64_t *v318;
  __int128 v319;
  __int128 v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  uint64_t v326;

  v326 = *MEMORY[0x24BDAC8D0];
  v324 = 0u;
  v325 = 0u;
  v322 = 0u;
  v323 = 0u;
  v320 = 0u;
  v321 = 0u;
  v319 = 0u;
  if (!*(_DWORD *)(a1 + 36))
    *(_DWORD *)(a1 + 36) = getDefaultNThreads();
  if (*(_DWORD *)(a1 + 40))
  {
    v2 = (FILE **)MEMORY[0x24BDAC8D8];
    fwrite("ImageDiff\n", 0xAuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    v3 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
    {
      v4 = 0;
      do
      {
        v5 = *(const char **)(*(_QWORD *)(a1 + 8) + 8 * v4);
        if (v5)
        {
          fprintf(*v2, "  Input %zu: %s\n", v4, v5);
          v3 = *(_QWORD *)a1;
        }
        ++v4;
      }
      while (v4 < v3);
    }
    if (*(_QWORD *)(a1 + 16))
      fprintf(*v2, "  Output: %s\n", *(const char **)(a1 + 16));
    if (*(_QWORD *)(a1 + 24))
      fprintf(*v2, "  Patch: %s\n", *(const char **)(a1 + 24));
    if ((*(_DWORD *)(a1 + 32) & 1) != 0)
      v6 = "yes";
    else
      v6 = "no";
    fprintf(*v2, "  In-place: %s\n", v6);
  }
  v7 = *(_QWORD *)a1 + 1;
  if (v7 > 0x400000000)
  {
    *__error() = 12;
LABEL_95:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", 592, 134, 0, "aaCalloc", v8, v9, v282);
    v104 = 0xFFFFFFFFLL;
    goto LABEL_117;
  }
  v10 = (uint64_t *)calloc(v7, 8uLL);
  if (!v10)
    goto LABEL_95;
  v11 = v10;
  variants = load_variants((uint64_t)v10, a1);
  if (!variants)
  {
    v105 = "load_variants";
    v106 = 596;
    goto LABEL_113;
  }
  *(_QWORD *)a1 = variants - 1;
  if ((rawimg_set_fork_types((uint64_t)v11, variants, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    v105 = "rawimg_set_fork_types";
    v106 = 600;
    goto LABEL_113;
  }
  v19 = *(_QWORD *)a1;
  if ((*(_QWORD *)a1 & 0x80000000) == 0)
  {
    v20 = *(_QWORD *)a1;
    do
    {
      rawimg_show(v11[v20], v20 == 0, *(_DWORD *)(a1 + 40));
      --v20;
    }
    while (v20 != -1);
    v19 = *(_QWORD *)a1;
  }
  v21 = *v11;
  v22 = (void **)(*(_QWORD *)(*v11 + 2120) / 0x64uLL + 0x2000000);
  v319 = 0u;
  v320 = 0u;
  v321 = 0u;
  v322 = 0u;
  v323 = 0u;
  v324 = 0u;
  v325 = 0u;
  *(int32x2_t *)((char *)&v319 + 4) = vrev64_s32(*(int32x2_t *)(a1 + 36));
  *(_QWORD *)&v320 = v19;
  if (v19 <= 1)
    v23 = 1;
  else
    v23 = v19;
  if (!is_mul_ok(v23, 0x50uLL) || 80 * v23 >= 0x2000000001)
  {
    *__error() = 12;
    *((_QWORD *)&v320 + 1) = 0;
    goto LABEL_99;
  }
  v24 = (char *)calloc(v23, 0x50uLL);
  *((_QWORD *)&v320 + 1) = v24;
  if (!v24)
  {
LABEL_99:
    v107 = *__error();
    v110 = 205;
LABEL_100:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v110, 134, v107, "aaCalloc", v108, v109, v282);
    v45 = 0;
    v37 = 0;
    v30 = 0;
LABEL_101:
    v63 = 0;
    v59 = 0;
    v52 = 0;
    goto LABEL_102;
  }
  v25 = v24;
  if (v19)
  {
    v26 = v24 + 36;
    do
    {
      *v26 = 1;
      v26 += 20;
      --v19;
    }
    while (v19);
  }
  if (!*(_QWORD *)a1)
  {
    v250 = calloc(1uLL, 0x18uLL);
    *((_QWORD *)v25 + 5) = v250;
    if (v250)
    {
      v45 = 0;
      v30 = 0;
      v63 = 0;
      v59 = 0;
      v52 = 0;
      v251 = *(_QWORD *)(v21 + 2080);
      if (v251 < 0)
        v251 = 0x8000000000000000 - v251;
      v250[1] = v251;
      v111 = 1;
      *((_QWORD *)v25 + 7) = 1;
      v37 = 0;
      goto LABEL_103;
    }
    v107 = *__error();
    v110 = 213;
    goto LABEL_100;
  }
  v27 = AAFileStreamOpenWithPath(*(const char **)(v21 + 2048), 0, 0);
  v30 = v27;
  if (!v27)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 223, 134, 0, "AAFileStreamOpenWithPath", v28, v29, v282);
    v45 = 0;
    v37 = 0;
    goto LABEL_101;
  }
  v31 = aaSegmentStreamOpen(v27, (_QWORD *)v21);
  v37 = (AAByteStream_impl *)v31;
  if (!v31)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 225, 134, 0, "aaSegmentStreamOpen", v35, v36, v282);
    v45 = 0;
    goto LABEL_101;
  }
  v45 = aaForkInputStreamOpen(v31, v21, 0, v32, v33, v34, v35, v36);
  if (!v45)
  {
    v252 = "aaForkInputStreamOpen";
    v253 = 227;
LABEL_290:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v253, 134, 0, v252, v43, v44, v282);
    goto LABEL_101;
  }
  v46 = 0;
  v303 = vdupq_n_s64(0x8000000000000000);
  v311 = v37;
  v315 = (AAByteStream)v22;
  while (1)
  {
    if (v46 >= (unint64_t)v320)
    {
      if ((unint64_t)v320 < 2)
      {
        v63 = 0;
        v59 = 0;
        v52 = 0;
        v111 = 1;
      }
      else
      {
        if (bxdiff5CreateComboControls((uint64_t)&v319, v38, v39, v40, v41, v42, v43, v44))
        {
          v252 = "bxdiff5CreateComboControls";
          v253 = 270;
          goto LABEL_290;
        }
        if ((controls_combo_enforce_copy_fork_boundary(*v11, &v319, v265, v266, v267, v268, v43, v44) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 272, 134, 0, "controls_combo_enforce_copy_fork_boundary", v280, v281, v282);
          v63 = 0;
          v59 = 0;
          v52 = 0;
          v111 = 0;
        }
        else
        {
          if (*(_DWORD *)(a1 + 40))
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImageDiff: Constructed %zd combo controls.\n", *((size_t *)&v324 + 1));
          v63 = 0;
          v59 = 0;
          v52 = 0;
          v111 = 1;
        }
        v37 = v311;
      }
      goto LABEL_103;
    }
    v22 = (void **)v30;
    v317 = v46;
    v47 = v46 + 1;
    v48 = v11[v46 + 1];
    v49 = AAFileStreamOpenWithPath(*(const char **)(v48 + 2048), 0, 0);
    v52 = v49;
    if (!v49)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 236, 134, 0, "AAFileStreamOpenWithPath", v50, v51, v282);
      v63 = 0;
      v59 = 0;
LABEL_318:
      v111 = 0;
      v30 = (AAByteStream_impl *)v22;
      LODWORD(v22) = (_DWORD)v315;
      goto LABEL_103;
    }
    v53 = aaSegmentStreamOpen(v49, (_QWORD *)v48);
    v59 = (AAByteStream_impl *)v53;
    if (!v53)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 238, 134, 0, "aaSegmentStreamOpen", v57, v58, v282);
      v63 = 0;
      goto LABEL_318;
    }
    v309 = v47;
    v60 = aaForkInputStreamOpen(v53, v48, 0, v54, v55, v56, v57, v58);
    v63 = (AAByteStream_impl *)v60;
    if (!v60)
    {
      v269 = "aaForkInputStreamOpen";
      v270 = 240;
LABEL_317:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v270, 134, 0, v269, v61, v62, v282);
      goto LABEL_318;
    }
    v313 = (_BYTE *)v48;
    if ((GetLargeFileControlsWithStreams((uint64_t)v60, *(_QWORD *)(v48 + 2072), (unint64_t)v45, *(_QWORD *)(v21 + 2072), (void **)(*((_QWORD *)&v320 + 1) + 80 * v317 + 40), (uint64_t *)(*((_QWORD *)&v320 + 1) + 80 * v317 + 56), (uint64_t *)&v319) & 0x80000000) != 0)
    {
      v269 = "GetLargeFileControlsWithStreams";
      v270 = 246;
      goto LABEL_317;
    }
    v64 = *(_QWORD *)(v21 + 2160);
    v30 = (AAByteStream_impl *)v22;
    v22 = (void **)v315;
    if (v64)
    {
      v65 = *((_QWORD *)&v320 + 1) + 80 * v317;
      v307 = (AAByteStream)(v65 + 56);
      v66 = *(_QWORD *)(v65 + 56);
      if (!v66)
      {
        v256 = "empty controls";
        v257 = 124;
LABEL_293:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", v257, 134, 0, v256, v61, v62, v282);
        goto LABEL_294;
      }
      if ((*(_BYTE *)(v21 + 2128) & 0x10) == 0 || (v313[2128] & 0x10) == 0)
      {
        v256 = "no digests found";
        v257 = 126;
        goto LABEL_293;
      }
      v22 = (void **)(v65 + 40);
      v67 = 24 * (v66 + v64);
      if (v67 >= 0x2000000001)
      {
        *__error() = 12;
        goto LABEL_332;
      }
      v305 = *(_DWORD *)(a1 + 40);
      v68 = *v22;
      v69 = (uint64_t *)realloc(*v22, v67);
      if (!v69)
      {
        free(v68);
        v37 = v311;
LABEL_332:
        *v22 = 0;
        v276 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_append_copy_forks", 130, 134, *v276, "aaReallocf", v277, v278, v282);
        LODWORD(v22) = (_DWORD)v315;
LABEL_294:
        v258 = "controls_append_copy_forks";
        v259 = 250;
LABEL_295:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", v259, 134, 0, v258, v99, v100, v282);
        goto LABEL_102;
      }
      *v22 = v69;
      v70 = *(_QWORD *)v307;
      if (*(_QWORD *)v307)
      {
        v71 = 0;
        v72 = v69 + 2;
        v73 = *(_QWORD *)v307;
        v22 = (void **)v315;
        v37 = v311;
        do
        {
          v74 = *(v72 - 2);
          if (v74 < 0)
            v74 = 0x8000000000000000 - v74;
          v76 = *v72;
          v72 += 3;
          v75 = v76;
          v77 = 0x8000000000000000 - v76;
          if (v76 < 0)
            v75 = v77;
          v71 += v74 + v75;
          --v73;
        }
        while (v73);
      }
      else
      {
        v71 = 0;
        v22 = (void **)v315;
        v37 = v311;
      }
      v78 = *(_QWORD *)(v21 + 2160);
      if (v78)
      {
        v79 = 0;
        v80 = *(_QWORD *)(v21 + 2144);
        v81 = (char *)(v69 - 1);
        do
        {
          v82 = v80 + 440 * v79;
          if ((*(_BYTE *)(v82 + 408) & 2) != 0)
          {
            v83 = *((_QWORD *)v313 + 270);
            if (!v83)
              goto LABEL_292;
            v84 = *((_QWORD *)v313 + 268);
            v85 = (_QWORD *)(v80 + 440 * v79);
            v86 = v85 + 49;
            v87 = v85 + 50;
            v88 = v85 + 4;
            while (1)
            {
              if ((*(_BYTE *)(v84 + 408) & 2) != 0 && *(_QWORD *)(v84 + 392) == *v86 && *(_QWORD *)(v84 + 400) == *v87)
              {
                v89 = *(_QWORD *)(v84 + 32);
                if (v89 == *v88)
                {
                  v61 = *(_QWORD *)(v82 + 8);
                  v62 = *(_QWORD *)(v84 + 16);
                  v90 = *(_QWORD *)v84 == *(_QWORD *)v82 && *(_QWORD *)(v84 + 8) == v61;
                  v91 = v90 && v62 == *(_QWORD *)(v82 + 16);
                  v22 = (void **)v315;
                  v92 = v91 && *(_QWORD *)(v84 + 24) == *(_QWORD *)(v82 + 24);
                  v37 = v311;
                  if (v92)
                    break;
                }
              }
              v84 += 440;
              if (!--v83)
                goto LABEL_292;
            }
            v93 = *(_QWORD *)(v84 + 48);
            if (v93 < 0)
            {
LABEL_292:
              v256 = "copy fork not found";
              v257 = 161;
              goto LABEL_293;
            }
            v94 = 3 * v70++;
            *(_QWORD *)v307 = v70;
            v95 = (char *)&v69[v94];
            v96 = 8 * v94;
            *((_QWORD *)v95 + 1) = 0;
            *((_QWORD *)v95 + 2) = 0;
            v97 = *(_QWORD *)&v81[8 * v94];
            if (v97 < 0)
              v97 = 0x8000000000000000 - v97;
            v98.i64[0] = v97 + v93 - v71;
            v98.i64[1] = v89;
            *(int8x16_t *)&v81[v96] = vbslq_s8((int8x16_t)vcltzq_s64(v98), (int8x16_t)vsubq_s64(v303, v98), (int8x16_t)v98);
            v71 = v93 + v89;
            v78 = *(_QWORD *)(v21 + 2160);
          }
          ++v79;
        }
        while (v79 < v78);
      }
      if (v305 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImageDiff: Processed copy forks: %zd controls\n", v70);
    }
    if ((*(_BYTE *)(a1 + 32) & 1) != 0
      && (rawimg_force_in_place((_QWORD *)(*((_QWORD *)&v320 + 1) + 80 * v317 + 40), (unint64_t *)(*((_QWORD *)&v320 + 1) + 80 * v317 + 56), v313, v21, (uint64_t)v22, *(_DWORD *)(a1 + 40)) & 0x80000000) != 0)
    {
      v258 = "rawimg_force_in_place";
      v259 = 258;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v63) < 0)
    {
      v258 = "AAByteStreamClose";
      v259 = 262;
      goto LABEL_295;
    }
    if (AAByteStreamClose(v59) < 0)
      break;
    v103 = AAByteStreamClose(v52);
    v46 = v309;
    if (v103 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 264, 134, 0, "AAByteStreamClose", v43, v44, v282);
      v63 = 0;
      v59 = 0;
      goto LABEL_102;
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 263, 134, 0, "AAByteStreamClose", v101, v102, v282);
  v63 = 0;
LABEL_102:
  v111 = 0;
LABEL_103:
  if (AAByteStreamClose((AAByteStream)v45) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 280, 134, 0, "AAByteStreamClose", v112, v113, v282);
    v111 = 0;
  }
  if (AAByteStreamClose(v37) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 281, 134, 0, "AAByteStreamClose", v114, v115, v282);
    if ((AAByteStreamClose(v30) & 0x80000000) == 0)
      goto LABEL_112;
LABEL_111:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_create_with_variants", 282, 134, 0, "AAByteStreamClose", v116, v117, v282);
    goto LABEL_112;
  }
  if (AAByteStreamClose(v30) < 0)
    goto LABEL_111;
  if (!v111)
  {
LABEL_112:
    AAByteStreamClose(v63);
    AAByteStreamClose(v59);
    AAByteStreamClose(v52);
    BXDiff5Data_free((uint64_t)&v319);
    v105 = "controls_create_with_variants";
    v106 = 612;
    goto LABEL_113;
  }
  v118 = (int)v22;
  v119 = 8 * *(_QWORD *)a1 + 62;
  if (v119 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_281;
  }
  v122 = *(_DWORD *)(a1 + 32);
  v123 = (char *)calloc(1uLL, 8 * *(_QWORD *)a1 + 62);
  if (!v123)
  {
LABEL_281:
    v247 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 515, 134, *v247, "aaCalloc", v248, v249, v282);
    v124 = 0;
    v129 = 0;
LABEL_303:
    v262 = 1;
    goto LABEL_304;
  }
  v124 = (uint64_t)v123;
  *(_QWORD *)v123 = 0x3031464649444952;
  *((_WORD *)v123 + 4) = *(_WORD *)a1 + 1;
  *(_QWORD *)(v123 + 10) = v122 & 1;
  if ((v122 & 1) != 0)
    v125 = v118;
  else
    v125 = 0;
  *(_DWORD *)(v123 + 26) = v125;
  *(_QWORD *)(v123 + 30) = v119;
  v126 = AAFileStreamOpenWithPath(*(const char **)(a1 + 24), 1537, 0x1A4u);
  v129 = v126;
  if (!v126)
  {
    v254 = "AAFileStreamOpenWithPath";
    v255 = 526;
LABEL_302:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", v255, 134, 0, v254, v127, v128, v282);
    goto LABEL_303;
  }
  if (AAByteStreamSeek(v126, v119, 0) < 0)
  {
    v254 = "AAByteStreamSeek";
    v255 = 527;
    goto LABEL_302;
  }
  v130 = *(unsigned int *)(a1 + 40);
  if (v130 <= 3)
    v131 = v130 << 62;
  else
    v131 = 0xC000000000000000;
  v137 = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v131, *(_DWORD *)(a1 + 36));
  if (!v137)
  {
    v260 = "AACompressionOutputStreamOpen";
    v261 = 305;
    goto LABEL_299;
  }
  v138 = 0;
  do
  {
    if ((rawimg_save_to_stream(v137, v11[v138], v138 == 0, v132, v133, v134, v135, v136) & 0x80000000) != 0)
    {
      v260 = "rawimg_save_to_stream";
      v261 = 311;
LABEL_299:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", v261, 134, 0, v260, v135, v136, v282);
      if ((AAByteStreamClose(v137) & 0x80000000) == 0)
      {
LABEL_301:
        v254 = "patch_write_metadata";
        v255 = 530;
        goto LABEL_302;
      }
LABEL_300:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_metadata", 315, 134, 0, "AAByteStreamClose", v127, v128, v282);
      goto LABEL_301;
    }
    ++v138;
  }
  while (v138 <= *(_QWORD *)a1);
  if (AAByteStreamClose(v137) < 0)
    goto LABEL_300;
  v139 = patch_write_controls(v129, (unint64_t *)&v319, v124, a1);
  if (!v139)
  {
    v254 = "patch_write_controls";
    v255 = 534;
    goto LABEL_302;
  }
  v292 = v139;
  v140 = 0;
  do
  {
    v141 = v11[v140];
    v300 = *v11;
    v142 = AAByteStreamSeek(v129, 0, 1);
    v299 = (off_t *)(v124 + 46 + 8 * v140);
    *v299 = v142;
    v310 = v140;
    if (v142 < 0)
    {
      v160 = 383;
      v161 = "AAByteStreamSeek";
LABEL_147:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v160, 134, 0, v161, v143, v144, v282);
      v312 = 0;
      v314 = 0;
      v318 = 0;
      v302 = 0;
      v304 = 0;
      v316 = 0;
      v306 = 0;
      v308 = 0;
      goto LABEL_148;
    }
    LODWORD(v145) = *(_DWORD *)(a1 + 40);
    if (v145 >= 3)
      v145 = 3;
    else
      v145 = v145;
    s = AACompressionOutputStreamOpen(v129, 0x306u, 0x100000uLL, v145 << 62, *(_DWORD *)(a1 + 36));
    if (!s)
    {
      v160 = 387;
      v161 = "AACompressionOutputStreamOpen";
      goto LABEL_147;
    }
    if (v140)
    {
      v146 = AAFileStreamOpenWithPath(*(const char **)(v141 + 2048), 0, 0);
      if (!v146)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 394, 134, 0, "AAFileStreamOpenWithPath", v147, v148, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        v306 = 0;
        v308 = 0;
        goto LABEL_254;
      }
      v308 = v146;
      v149 = aaSegmentStreamOpen(v146, (_QWORD *)v141);
      if (!v149)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 396, 134, 0, "aaSegmentStreamOpen", v153, v154, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        v306 = 0;
        goto LABEL_254;
      }
      v306 = (AAByteStream_impl *)v149;
      v316 = (AAByteStream_impl *)aaForkInputStreamOpen(v149, v141, 0, v150, v151, v152, v153, v154);
      if (!v316)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 398, 134, 0, "aaForkInputStreamOpen", v155, v156, v282);
        v312 = 0;
        v314 = 0;
        v318 = 0;
        v302 = 0;
        v304 = 0;
        v316 = 0;
        goto LABEL_254;
      }
      v312 = malloc(0x10000uLL);
      if (!v312)
      {
        v157 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 400, 134, *v157, "aaMalloc", v158, v159, v282);
        v312 = 0;
        v314 = 0;
        goto LABEL_235;
      }
    }
    else
    {
      v312 = 0;
      v316 = 0;
      v306 = 0;
      v308 = 0;
    }
    v164 = v300;
    v165 = AAFileStreamOpenWithPath(*(const char **)(v300 + 2048), 0, 0);
    if (!v165)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 405, 134, 0, "AAFileStreamOpenWithPath", v166, v167, v282);
      v314 = 0;
LABEL_235:
      v318 = 0;
      v302 = 0;
      v304 = 0;
LABEL_254:
      v163 = 0;
      v162 = s;
      goto LABEL_255;
    }
    v304 = v165;
    v168 = aaSegmentStreamOpen(v165, (_QWORD *)v300);
    if (!v168)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 407, 134, 0, "aaSegmentStreamOpen", v172, v173, v282);
      v314 = 0;
      v318 = 0;
      v302 = 0;
      goto LABEL_254;
    }
    v302 = (AAByteStream_impl *)v168;
    v318 = aaForkInputStreamOpen(v168, v300, 0, v169, v170, v171, v172, v173);
    if (!v318)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 409, 134, 0, "aaForkInputStreamOpen", v174, v175, v282);
      v314 = 0;
      v318 = 0;
      goto LABEL_254;
    }
    v176 = malloc(0x10000uLL);
    if (!v176)
    {
      v221 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 411, 134, *v221, "aaMalloc", v222, v223, v282);
      v314 = 0;
      goto LABEL_254;
    }
    v314 = v176;
    v179 = v292;
    if (*(_QWORD *)(v124 + 18))
    {
      v180 = 0;
      v181 = 0;
      v182 = 0;
      v183 = 0;
      v283 = v140 + 1;
      while (1)
      {
        v289 = v183;
        v288 = (unint64_t *)(v179 + 8 * (v183 + v183 * *(unsigned __int16 *)(v124 + 8)));
        v184 = v288[1];
        v185 = 0x8000000000000000 - *v288;
        if ((*v288 & 0x8000000000000000) == 0)
          v185 = *v288;
        v186 = 0x8000000000000000 - v184;
        if (v184 >= 0)
          v186 = v288[1];
        if (v140)
        {
          v286 = v186;
          v187 = *(_QWORD *)(v164 + 2072);
          if (v181 < v187 && v185 + v181 > v187)
          {
            v227 = 427;
            goto LABEL_246;
          }
          v188 = v181 >= v187;
          if (v181 >= v187)
            v189 = v185 + v181;
          else
            v189 = v181;
          if (v181 >= v187)
            v190 = v185;
          else
            v190 = 0;
          v293 = v189;
          v295 = v190 + v180;
          v284 = v182;
          if (!v188 && v185)
          {
            v191 = v185;
            v290 = v185;
            while (1)
            {
              v291 = v191;
              if (v191 >= 0x10000)
                v192 = 0x10000;
              else
                v192 = v191;
              if (!*((_QWORD *)v316 + 4))
                goto LABEL_248;
              v193 = 0;
              v194 = v312;
              v195 = v295;
              v297 = v192;
              while (1)
              {
                v196 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t, uint64_t))v316 + 4))(*(_QWORD *)v316, v194, v192, v195);
                if (v196 < 0)
                  break;
                if (v196)
                {
                  v194 += v196;
                  v193 += v196;
                  v195 += v196;
                  v192 -= v196;
                  if (v192)
                    continue;
                }
                goto LABEL_183;
              }
              v193 = v196;
LABEL_183:
              v197 = v297;
              if (v297 != v193)
              {
LABEL_248:
                v227 = 442;
                goto LABEL_251;
              }
              v198 = v314;
              if (!v318[4])
                goto LABEL_250;
              v199 = 0;
              v200 = v293;
              while (1)
              {
                v201 = ((uint64_t (*)(uint64_t, _BYTE *, unint64_t, unint64_t))v318[4])(*v318, v198, v197, v200);
                if (v201 < 0)
                  break;
                if (v201)
                {
                  v198 += v201;
                  v199 += v201;
                  v200 += v201;
                  v197 -= v201;
                  if (v197)
                    continue;
                }
                goto LABEL_191;
              }
              v199 = v201;
LABEL_191:
              v202 = v297;
              v203 = v314;
              if (v297 != v199)
              {
LABEL_250:
                v227 = 443;
                goto LABEL_251;
              }
              v204 = 0;
              v205 = v297 <= 1 ? 1 : v297;
              do
              {
                v314[v204] -= v312[v204];
                ++v204;
              }
              while (v205 != v204);
              if (!*((_QWORD *)s + 3))
                break;
              v206 = 0;
              while (1)
              {
                v207 = (*((uint64_t (**)(_QWORD, _BYTE *, unint64_t))s + 3))(*(_QWORD *)s, v203, v202);
                if (v207 < 1)
                  break;
                v203 += v207;
                v206 += v207;
                v202 -= v207;
                if (!v202)
                  goto LABEL_202;
              }
              v206 = v207;
LABEL_202:
              v176 = v314;
              if (v297 != v206)
                break;
              v295 += v297;
              v293 += v297;
              v191 = v291 - v297;
              v185 = v290;
              if (v291 == v297)
                goto LABEL_204;
            }
            v227 = 447;
            v228 = "aaByteStreamWriteExpected";
            goto LABEL_253;
          }
LABEL_204:
          v182 = v284;
          v208 = v288[v283];
          if (v208 < 0)
            v208 = 0x8000000000000000 - v208;
          v180 = v208 + v295;
          v181 = v293 + v286;
          v164 = v300;
        }
        else
        {
          v181 += v185;
          if (v186)
          {
            v294 = v180;
            v285 = v182;
            v287 = v186;
            v209 = v186;
            while (1)
            {
              v210 = v209 >= 0x10000 ? 0x10000 : v209;
              if (!v318[4])
                break;
              v211 = 0;
              v212 = v176;
              v296 = v181;
              v298 = v210;
              v213 = v181;
              while (1)
              {
                v214 = ((uint64_t (*)(uint64_t, char *, uint64_t, unint64_t))v318[4])(*v318, v212, v210, v213);
                if (v214 < 0)
                  break;
                if (v214)
                {
                  v212 += v214;
                  v211 += v214;
                  v213 += v214;
                  v210 -= v214;
                  if (v210)
                    continue;
                }
                goto LABEL_219;
              }
              v211 = v214;
LABEL_219:
              v215 = v298;
              v216 = v314;
              if (v298 != v211)
                break;
              v217 = v209;
              v162 = s;
              if (!*((_QWORD *)s + 3))
                goto LABEL_249;
              v218 = 0;
              while (1)
              {
                v219 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t))s + 3))(*(_QWORD *)s, v216, v215);
                if (v219 < 1)
                  break;
                v216 += v219;
                v218 += v219;
                v215 -= v219;
                if (!v215)
                  goto LABEL_226;
              }
              v218 = v219;
LABEL_226:
              v176 = v314;
              if (v298 != v218)
              {
LABEL_249:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 467, 134, 0, "aaByteStreamWriteExpected", v177, v178, v282);
                goto LABEL_149;
              }
              v181 = v298 + v296;
              v209 = v217 - v298;
              if (v217 == v298)
              {
                v182 = v285;
                v185 = v287;
                v140 = v310;
                v164 = v300;
                v220 = v289;
                v180 = v294;
                goto LABEL_231;
              }
            }
            v227 = 466;
LABEL_251:
            v228 = "aaByteStreamPReadExpected";
            goto LABEL_253;
          }
          v185 = 0;
        }
        v220 = v289;
LABEL_231:
        v182 += v185;
        v183 = v220 + 1;
        v179 = v292;
        if (v183 >= *(_QWORD *)(v124 + 18))
          goto LABEL_242;
      }
    }
    v182 = 0;
    v181 = 0;
LABEL_242:
    if (v181 != *(_QWORD *)(v164 + 2080))
    {
      v227 = 472;
LABEL_246:
      v228 = "bad controls";
LABEL_253:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", v227, 134, 0, v228, v177, v178, v282);
      goto LABEL_254;
    }
    v224 = v182;
    if (AAByteStreamClose(s) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 475, 134, 0, "AAByteStreamClose", v225, v226, v282);
      v163 = 0;
    }
    else
    {
      v163 = 1;
    }
    v243 = AAByteStreamSeek(v129, 0, 1);
    v299[1] = v243;
    if ((v243 & 0x8000000000000000) == 0)
    {
      if (*(int *)(a1 + 40) >= 2)
      {
        v246 = "Diff";
        if (!v310)
          v246 = "Literal";
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s stream: %llu bytes -> %llu bytes\n", v246, v224, v243 - *v299);
      }
      v162 = 0;
      goto LABEL_255;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 480, 134, 0, "AAByteStreamSeek", v244, v245, v282);
LABEL_148:
    v162 = 0;
LABEL_149:
    v163 = 0;
LABEL_255:
    if (AAByteStreamClose(v162) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 489, 134, 0, "AAByteStreamClose", v229, v230, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v316) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 490, 134, 0, "AAByteStreamClose", v231, v232, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v306) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 491, 134, 0, "AAByteStreamClose", v233, v234, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v308) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 492, 134, 0, "AAByteStreamClose", v235, v236, v282);
      v163 = 0;
    }
    if (AAByteStreamClose((AAByteStream)v318) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 493, 134, 0, "AAByteStreamClose", v237, v238, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v302) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 494, 134, 0, "AAByteStreamClose", v239, v240, v282);
      v163 = 0;
    }
    if (AAByteStreamClose(v304) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write_stream", 495, 134, 0, "AAByteStreamClose", v241, v242, v282);
      v163 = 0;
    }
    free(v312);
    free(v314);
    if (!v163)
    {
      v254 = "patch_write_stream";
      v255 = 539;
      goto LABEL_302;
    }
    v140 = v310 + 1;
  }
  while ((unint64_t)(v310 + 1) <= *(_QWORD *)a1);
  if (!*((_QWORD *)v129 + 5))
    goto LABEL_341;
  v271 = 0;
  v272 = 0;
  v273 = v124;
  v274 = v119;
  while (1)
  {
    v275 = (*((uint64_t (**)(_QWORD, uint64_t, unint64_t, uint64_t))v129 + 5))(*(_QWORD *)v129, v273, v274, v272);
    if (v275 < 1)
      break;
    v273 += v275;
    v271 += v275;
    v272 += v275;
    v274 -= v275;
    if (!v274)
      goto LABEL_335;
  }
  v271 = v275;
LABEL_335:
  if (v119 != v271)
  {
LABEL_341:
    v254 = "aaByteStreamPWriteExpected";
    v255 = 543;
    goto LABEL_302;
  }
  v279 = *(_DWORD *)(a1 + 40);
  if (v279 > 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  Metadata: %llu bytes\n  Controls: %llu bytes\n", *(_QWORD *)(v124 + 38) - *(_QWORD *)(v124 + 30), *(_QWORD *)(v124 + 46) - *(_QWORD *)(v124 + 38));
    v279 = *(_DWORD *)(a1 + 40);
  }
  if (v279 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu final patch size\n", *(_QWORD *)(v124 + 8 * *(unsigned __int16 *)(v124 + 8) + 46));
  v262 = 0;
LABEL_304:
  if (AAByteStreamClose(v129) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"patch_write", 562, 134, 0, "AAByteStreamClose", v263, v264, v282);
    free((void *)v124);
  }
  else
  {
    free((void *)v124);
    if (!v262)
    {
      v104 = 0;
      goto LABEL_114;
    }
  }
  v105 = "patch_write";
  v106 = 615;
LABEL_113:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"RawImageDiff", v106, 134, 0, v105, v17, v18, v282);
  v104 = 0xFFFFFFFFLL;
LABEL_114:
  v120 = 0;
  do
    rawimg_destroy((uint64_t *)v11[v120++]);
  while (v120 <= *(_QWORD *)a1);
  free(v11);
LABEL_117:
  BXDiff5Data_free((uint64_t)&v319);
  return v104;
}

double BXDiff5Data_free(uint64_t a1)
{
  void *v2;
  unint64_t v3;
  uint64_t v4;
  double result;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v3 = 0;
      v4 = 40;
      do
      {
        free(*(void **)(*(_QWORD *)(a1 + 24) + v4));
        ++v3;
        v4 += 80;
      }
      while (v3 < *(_QWORD *)(a1 + 16));
      v2 = *(void **)(a1 + 24);
    }
    free(v2);
  }
  free(*(void **)(a1 + 72));
  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t controls_combo_enforce_copy_fork_boundary(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t *v27;
  unint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  const char *v32;
  __int16 v33;
  char v34;
  uint64_t v35;
  unint64_t v36;

  v8 = a1;
  v9 = a2[11];
  if (v9)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v36 = a2[2];
    v14 = v36 + 2;
    v15 = 8 * (v36 + 2);
    if (v36 == 0 || v36 >= 0xFFFFFFFFFFFFFFFELL)
      v14 = 2;
    v35 = 8 * v14 - 8;
    v16 = -1;
    while (1)
    {
      v17 = (char *)a2[9];
      v18 = *(_QWORD *)&v17[v11];
      if (v18 >= 0)
        v19 = *(_QWORD *)&v17[v11];
      else
        v19 = 0x8000000000000000 - v18;
      v20 = *(_QWORD *)(v8 + 2072);
      v21 = v19 + v13;
      v22 = v20 - v13;
      if (v20 > v13 && v21 > v20)
      {
        v25 = v9 + 1;
        a2[11] = v25;
        if (v15 * v25 >= 0x2000000001)
        {
          *__error() = 12;
          goto LABEL_32;
        }
        v26 = (char *)realloc(v17, v15 * v25);
        if (!v26)
        {
          free(v17);
LABEL_32:
          a2[9] = 0;
          v32 = "aaReallocf";
          v33 = 88;
LABEL_33:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiff.c", (uint64_t)"controls_combo_enforce_copy_fork_boundary", v33, 134, 0, v32, a7, a8, v34);
          return 0xFFFFFFFFLL;
        }
        a2[9] = v26;
        v27 = (uint64_t *)&v26[v11];
        v28 = (unint64_t *)&v26[v11 + v15];
        memmove(v28, &v26[v11], v15 * (v16 + a2[11]));
        v29 = 0x8000000000000000 - v22;
        if (v22 >= 0)
          v29 = v22;
        *v27 = v29;
        if (v36 <= 0xFFFFFFFFFFFFFFFDLL)
          bzero(v27 + 1, v35);
        v30 = v19 - v22;
        if ((uint64_t)(v19 - v22) < 0)
          v30 = 0x8000000000000000 - (v19 - v22);
        *v28 = v30;
        v9 = a2[11];
        v13 = v20;
        v8 = a1;
      }
      else
      {
        v24 = *(_QWORD *)&v17[v11 + 8];
        if (v24 < 0)
          v24 = 0x8000000000000000 - v24;
        v13 = v21 + v24;
      }
      ++v12;
      v11 += v15;
      --v16;
      if (v12 >= v9)
        goto LABEL_27;
    }
  }
  v13 = 0;
LABEL_27:
  if (v13 != *(_QWORD *)(v8 + 2080))
  {
    v32 = "SIZE MISMATCH";
    v33 = 108;
    goto LABEL_33;
  }
  return 0;
}

char *SharedBufferCreate(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  _QWORD *i;
  char v39;

  if (a1 - 0x100000000 > 0xFFFFFFFF00000000)
  {
    v9 = getpagesize();
    if (v9 <= 0x197)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 252, 73, 0, "Incompatible page size", v10, v11, v39);
      return 0;
    }
    v14 = v9;
    if (a1 >> 2 < v9)
      v15 = 1;
    else
      v15 = (a1 >> 2) / v9;
    v16 = v15 * v9;
    v17 = (unsigned int *)valloc(v9 + 4 * v16);
    v12 = v17;
    if (!v17)
    {
      v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 262, 73, *v24, "malloc", v25, v26, v39);
      return (char *)v12;
    }
    *((_QWORD *)v17 + 50) = 0;
    *((_OWORD *)v17 + 23) = 0u;
    *((_OWORD *)v17 + 24) = 0u;
    *((_OWORD *)v17 + 21) = 0u;
    *((_OWORD *)v17 + 22) = 0u;
    *((_OWORD *)v17 + 19) = 0u;
    *((_OWORD *)v17 + 20) = 0u;
    *((_OWORD *)v17 + 17) = 0u;
    *((_OWORD *)v17 + 18) = 0u;
    *((_OWORD *)v17 + 15) = 0u;
    *((_OWORD *)v17 + 16) = 0u;
    *((_OWORD *)v17 + 13) = 0u;
    *((_OWORD *)v17 + 14) = 0u;
    *((_OWORD *)v17 + 11) = 0u;
    *((_OWORD *)v17 + 12) = 0u;
    *((_OWORD *)v17 + 9) = 0u;
    *((_OWORD *)v17 + 10) = 0u;
    *((_OWORD *)v17 + 7) = 0u;
    *((_OWORD *)v17 + 8) = 0u;
    *((_OWORD *)v17 + 5) = 0u;
    *((_OWORD *)v17 + 6) = 0u;
    *((_OWORD *)v17 + 3) = 0u;
    *((_OWORD *)v17 + 4) = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    *((_OWORD *)v17 + 2) = 0u;
    *(_OWORD *)v17 = 0u;
    *((_QWORD *)v17 + 48) = -1;
    atomic_store(2u, v17 + 101);
    *(_QWORD *)v17 = 0x600000000;
    v18 = calloc(6uLL, 4uLL);
    *((_QWORD *)v12 + 1) = v18;
    if (v18)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v12 + 4), 0))
      {
        v22 = "SharedArrayInit: pthread_mutex_init failed\n";
        v23 = 56;
      }
      else
      {
        if (!pthread_cond_init((pthread_cond_t *)(v12 + 20), 0))
        {
          *((_QWORD *)v12 + 16) = 0x600000000;
          v31 = calloc(6uLL, 4uLL);
          *((_QWORD *)v12 + 17) = v31;
          if (v31)
          {
            if (pthread_mutex_init((pthread_mutex_t *)(v12 + 36), 0))
            {
              v35 = "SharedArrayInit: pthread_mutex_init failed\n";
              v36 = 56;
            }
            else
            {
              if (!pthread_cond_init((pthread_cond_t *)(v12 + 52), 0))
              {
                v37 = 0;
                for (i = v12 + 68; ; i += 4)
                {
                  *i = 0;
                  i[1] = 0;
                  *(i - 2) = (char *)v12 + v14;
                  *(i - 1) = v16;
                  if ((SharedArrayPush(v12 + 32, v37) & 0x80000000) != 0)
                    break;
                  ++v37;
                  v14 += v16;
                  if (v37 == 4)
                    return (char *)v12;
                }
                v29 = "SharedArrayPush";
                v30 = 283;
                goto LABEL_19;
              }
              v35 = "SharedArrayInit: pthread_cond_init failed\n";
              v36 = 57;
            }
          }
          else
          {
            v35 = "SharedArrayInit: malloc failed\n";
            v36 = 55;
          }
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v36, 0, v35, v32, v33, v34, v39);
          v29 = "SharedArrayInit";
          v30 = 270;
LABEL_19:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", v30, 73, 0, v29, v27, v28, v39);
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 4))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 20)))
          {
            free(*((void **)v12 + 1));
          }
          if (!pthread_mutex_destroy((pthread_mutex_t *)(v12 + 36))
            && !pthread_cond_destroy((pthread_cond_t *)(v12 + 52)))
          {
            free(*((void **)v12 + 17));
          }
          free(v12);
          return 0;
        }
        v22 = "SharedArrayInit: pthread_cond_init failed\n";
        v23 = 57;
      }
    }
    else
    {
      v22 = "SharedArrayInit: malloc failed\n";
      v23 = 55;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v23, 0, v22, v19, v20, v21, v39);
    v29 = "SharedArrayInit";
    v30 = 269;
    goto LABEL_19;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferCreate", 247, 73, 0, "SharedBuffer invalid capacity: %zu", a7, a8, a1);
  return 0;
}

uint64_t SharedArrayPush(unsigned int *a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  char v14;

  v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v9 = 117;
  }
  else
  {
    v10 = *a1;
    v11 = a1[1];
    v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((_QWORD *)a1 + 1) + 4 * v10) = a2;
      v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v9 = 124;
      }
      else
      {
        if (v10 < v11)
          return 0;
        v8 = "SharedArrayPush: stack is full\n";
        v9 = 125;
      }
    }
    else
    {
      v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      v9 = 122;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

void SharedBufferDestroy(uint64_t a1)
{
  if (a1)
  {
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 80)))
      free(*(void **)(a1 + 8));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 144)) && !pthread_cond_destroy((pthread_cond_t *)(a1 + 208)))
      free(*(void **)(a1 + 136));
    free((void *)a1);
  }
}

uint64_t SharedBufferFillFromStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v11;
  __int16 v12;
  unint64_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  size_t v29;
  uint64_t *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  const char *v42;
  __int16 v43;
  char v45;

  if (a2)
  {
    if (!atomic_load((unsigned int *)(a1 + 400)))
    {
      if (atomic_load((unsigned int *)(a1 + 392)))
      {
        v11 = "write after EOF";
        v12 = 365;
LABEL_26:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferFillFromStream", v12, 73, 0, v11, a7, a8, v45);
      }
      else
      {
        v14 = a2;
        v15 = 0;
        v16 = a1 + 256;
        while (1)
        {
          v17 = *(unsigned int *)(a1 + 384);
          if (v17 <= 3)
          {
            v22 = *(_QWORD *)(v16 + 32 * v17 + 24);
          }
          else
          {
            if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 144)))
            {
              v42 = "SharedArrayPop: pthread_mutex_lock failed\n";
              v43 = 91;
LABEL_25:
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v43, 0, v42, v18, v19, v20, v45);
              v11 = "SharedArrayPop";
              v12 = 378;
              goto LABEL_26;
            }
            while (1)
            {
              v21 = *(_DWORD *)(a1 + 128);
              if (v21)
                break;
              if (pthread_cond_wait((pthread_cond_t *)(a1 + 208), (pthread_mutex_t *)(a1 + 144)))
              {
                v42 = "SharedArrayPop: pthread_cond_wait failed\n";
                v43 = 94;
                goto LABEL_25;
              }
            }
            v23 = v21 - 1;
            *(_DWORD *)(a1 + 128) = v23;
            v17 = *(unsigned int *)(*(_QWORD *)(a1 + 136) + 4 * v23);
            if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144)))
            {
              v42 = "SharedArrayPop: pthread_mutex_unlock failed\n";
              v43 = 98;
              goto LABEL_25;
            }
            if (v17 > 3)
              goto LABEL_27;
            v22 = 0;
            *(_DWORD *)(a1 + 384) = v17;
            v28 = v16 + 32 * v17;
            *(_QWORD *)(v28 + 16) = 0;
            *(_QWORD *)(v28 + 24) = 0;
          }
          v29 = v16;
          v30 = (uint64_t *)(v16 + 32 * v17);
          v32 = v30 + 1;
          v31 = v30[1];
          v35 = *v30;
          v34 = v30 + 3;
          v33 = v35;
          v36 = v31 - v22;
          if (v36 >= v14)
            v37 = v14;
          else
            v37 = v36;
          v38 = a3(a4, v33 + v22, v37);
          if (v38 < 0)
          {
            v11 = "stream read";
            v12 = 393;
            goto LABEL_26;
          }
          v39 = v38;
          if (!v38)
            break;
          v40 = *v34 + v38;
          *v34 = v40;
          v41 = v40 == *v32;
          v16 = v29;
          if (v41 && (currentWriteBufferFull((unsigned int *)a1) & 0x80000000) != 0)
            goto LABEL_27;
          v15 += v39;
          v14 -= v39;
          if (!v14)
            goto LABEL_32;
        }
        if ((sendEOF((unsigned int *)a1) & 0x80000000) == 0)
        {
LABEL_32:
          if ((currentWriteBufferFull((unsigned int *)a1) & 0x80000000) == 0)
            return v15;
        }
      }
LABEL_27:
      SharedBufferAbort(a1, v24, v25, v26, v27, v18, v19, v20, v45);
    }
  }
  return -1;
}

uint64_t sendEOF(unsigned int *a1)
{
  unsigned int *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  char v7;

  v2 = a1 + 98;
  do
  {
    if (__ldaxr(v2))
    {
      result = 0;
      __clrex();
      return result;
    }
  }
  while (__stlxr(1u, v2));
  if ((currentWriteBufferFull(a1) & 0x80000000) == 0)
  {
    if ((SharedArrayEnqueue(a1, -2) & 0x80000000) == 0)
      return 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"sendEOF", 351, 73, 0, "SharedArrayEnqueue", v4, v5, v7);
  }
  return 0xFFFFFFFFLL;
}

uint64_t currentWriteBufferFull(unsigned int *a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  char vars0;

  v1 = a1[96];
  a1[96] = -1;
  if (v1 > 3 || (SharedArrayEnqueue(a1, v1) & 0x80000000) == 0)
    return 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"currentWriteBufferFull", 324, 73, 0, "SharedArrayEnqueue", v2, v3, vars0);
  return 0xFFFFFFFFLL;
}

size_t SharedBufferAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unsigned int *v9;
  unsigned int *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (result)
  {
    v9 = (unsigned int *)result;
    v10 = (unsigned int *)(result + 400);
    do
    {
      if (__ldaxr(v10))
      {
        __clrex();
        return result;
      }
    }
    while (__stlxr(1u, v10));
    if ((SharedArrayPush((unsigned int *)(result + 128), -1) & 0x80000000) != 0)
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 500, 73, 0, "SharedArrayPush", v12, v13, v16);
    result = SharedArrayEnqueue(v9, -1);
    if ((result & 0x80000000) != 0)
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)"SharedBufferAbort", 501, 73, 0, "SharedArrayPush", v14, v15, a9);
  }
  return result;
}

uint64_t SharedBufferFlushToStream(size_t a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  uint64_t v6;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  const char *v35;
  __int16 v36;
  const char *v37;
  const char *v38;
  __int16 v39;
  char v41;
  unsigned int *v42;
  unsigned int *v43;
  size_t v44;

  if (!a2)
    return -1;
  if (atomic_load((unsigned int *)(a1 + 400)))
    return -1;
  if (atomic_load((unsigned int *)(a1 + 396)))
    return 0;
  v11 = a2;
  v6 = 0;
  v44 = a1 + 256;
  v42 = (unsigned int *)(a1 + 396);
  v43 = (unsigned int *)(a1 + 128);
  while (1)
  {
    v12 = *(unsigned int *)(a1 + 388);
    if (v12 < 4)
      goto LABEL_17;
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 16)))
    {
      v35 = "SharedArrayPop: pthread_mutex_lock failed\n";
      v36 = 91;
      goto LABEL_26;
    }
    while (!*(_DWORD *)a1)
    {
      if (pthread_cond_wait((pthread_cond_t *)(a1 + 80), (pthread_mutex_t *)(a1 + 16)))
      {
        v35 = "SharedArrayPop: pthread_cond_wait failed\n";
        v36 = 94;
        goto LABEL_26;
      }
    }
    v16 = *(_DWORD *)a1 - 1;
    *(_DWORD *)a1 = v16;
    v12 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v16);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16)))
    {
      v35 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      v36 = 98;
LABEL_26:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v36, 0, v35, v13, v14, v15, v41);
      v37 = "SharedBufferFlushToStream";
      v38 = "SharedArrayDequeue";
      v39 = 448;
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedBuffer.c", (uint64_t)v37, v39, 73, 0, v38, v30, v31, v41);
LABEL_28:
      SharedBufferAbort(a1, v17, v18, v19, v20, v13, v14, v15, v41);
      return -1;
    }
    if (v12 == 4294967294)
      break;
    if (v12 > 3)
      goto LABEL_28;
    *(_DWORD *)(a1 + 388) = v12;
LABEL_17:
    v21 = v44 + 32 * v12;
    v23 = (_QWORD *)(v21 + 24);
    v22 = *(_QWORD *)(v21 + 24);
    v26 = *(_QWORD *)(v21 + 16);
    v25 = (_QWORD *)(v21 + 16);
    v24 = v26;
    v27 = v22 - v26;
    if (v27 >= v11)
      v28 = v11;
    else
      v28 = v27;
    v29 = a3(a4, *(_QWORD *)(v44 + 32 * v12) + v24, v28);
    if (v29 <= 0)
    {
      v37 = "SharedBufferFlushToStream";
      v38 = "stream write";
      v39 = 469;
      goto LABEL_27;
    }
    v32 = v29;
    v33 = *v25 + v29;
    *v25 = v33;
    if (v33 == *v23)
    {
      v34 = *(_DWORD *)(a1 + 388);
      *(_DWORD *)(a1 + 388) = -1;
      if (v34 <= 3 && (SharedArrayPush(v43, v34) & 0x80000000) != 0)
      {
        v37 = "currentReadBufferEmpty";
        v38 = "SharedArrayPush";
        v39 = 337;
        goto LABEL_27;
      }
    }
    v6 += v32;
    v11 -= v32;
    if (!v11)
      return v6;
  }
  while (!__ldaxr(v42))
  {
    if (!__stlxr(1u, v42))
      return v6;
  }
  __clrex();
  return v6;
}

uint64_t SharedArrayEnqueue(unsigned int *a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  char v14;

  v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v9 = 157;
  }
  else
  {
    v10 = *a1;
    v11 = a1[1];
    if (v10 >= v11)
    {
      v12 = *a1;
    }
    else
    {
      if ((_DWORD)v10)
        memmove((void *)(*((_QWORD *)a1 + 1) + 4), *((const void **)a1 + 1), 4 * v10);
      **((_DWORD **)a1 + 1) = a2;
      v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v9 = 168;
      }
      else
      {
        if (v10 < v11)
          return 0;
        v8 = "SharedArrayPush: stack is full\n";
        v9 = 169;
      }
    }
    else
    {
      v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      v9 = 166;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayEnqueue", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

uint64_t SharedBufferWrite(unsigned int *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;

  if (atomic_load(a1 + 100))
    return -1;
  if (!a3)
    return (int)sendEOF(a1);
  v10 = a2;
  return SharedBufferFillFromStream((size_t)a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferReadFromBufferProc, (uint64_t)&v10, a5, a6, a7, a8);
}

size_t SharedBufferReadFromBufferProc(const void **a1, void *__dst, size_t a3)
{
  memcpy(__dst, *a1, a3);
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t SharedBufferRead(size_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;

  if (atomic_load((unsigned int *)(a1 + 400)))
    return -1;
  v5 = a2;
  return SharedBufferFlushToStream(a1, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t))SharedBufferWriteToBufferProc, (uint64_t)&v5);
}

size_t SharedBufferWriteToBufferProc(void **a1, const void *a2, size_t a3)
{
  memcpy(*a1, a2, a3);
  *a1 = (char *)*a1 + a3;
  return a3;
}

uint64_t ParallelArchiveRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t Magic;
  unint64_t MagicSize;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v22;
  unint64_t v23;
  FILE *v24;
  char *DecoderDescription;
  int DefaultNThreads;
  const char *v27;
  __int16 v28;
  int v29;
  const char *v30;
  __int16 v31;
  unint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  void **v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  void **v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t result;
  unsigned int v50;
  char v51;
  char v52;
  _QWORD v53[2];
  _OWORD v54[2];
  _QWORD v55[6];
  _BYTE v56[8];
  uint64_t v57;
  void *v58;
  void *v59;
  void *v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  int v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v51);
  bzero(v56, 0x928uLL);
  v57 = 0x20000;
  v9 = malloc(0x20000uLL);
  v10 = *(_QWORD *)(a1 + 80);
  v58 = v9;
  v64 = v10;
  v11 = *(_OWORD *)(a1 + 48);
  v61 = *(_OWORD *)(a1 + 32);
  v62 = v11;
  v63 = *(_OWORD *)(a1 + 64);
  v12 = IMagicStreamCreate(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), 12);
  v13 = v12;
  if (!v12)
    goto LABEL_59;
  Magic = IMagicStreamGetMagic((uint64_t)v12);
  MagicSize = IMagicStreamGetMagicSize((uint64_t)v13);
  if (v9)
  {
    if (MagicSize < 0xC)
    {
      if (MagicSize < 6)
      {
        if (MagicSize < 4)
        {
          if (!MagicSize)
          {
LABEL_54:
            v39 = 1;
            goto LABEL_55;
          }
          goto LABEL_43;
        }
LABEL_32:
        if (*(_DWORD *)Magic == 826360153 || *(_DWORD *)Magic == 825246017)
        {
LABEL_34:
          if (*(int *)a1 >= 2)
            fwrite("Raw cpio/yaa archive payload\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
          v34 = (unint64_t *)MemBufferCreate(0x100000uLL);
          if (!v34)
            goto LABEL_59;
          v37 = (void **)v34;
          v38 = MemBufferTransmit(v34, 0xFFFFFFFFFFFFFFFFLL, (size_t (*)(int, void *, size_t))IMagicStreamRead, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t, uint64_t))readProcessData, (uint64_t)v56, v35, v36);
          MemBufferDestroy(v37);
          if ((v38 & 0x8000000000000000) == 0)
          {
            if (*(int *)a1 >= 1)
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12lld raw archive\n");
            goto LABEL_54;
          }
          v27 = "MemBufferTransmit";
          v28 = 550;
          goto LABEL_41;
        }
LABEL_43:
        v40 = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMagicStreamRead, (uint64_t)IMagicStreamAbort, (uint64_t)v13, 0x100000uLL);
        if (!v40)
        {
          v30 = "Could not identify payload format";
          v31 = 580;
LABEL_57:
          v29 = 0;
          goto LABEL_58;
        }
        v41 = v40;
        if (*(int *)a1 >= 2)
          fwrite("Compressed archive payload (gzip, bzip2, xz)\n", 0x2DuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
        v42 = (unint64_t *)MemBufferCreate(0x100000uLL);
        if (!v42)
          goto LABEL_59;
        v45 = (void **)v42;
        v46 = MemBufferTransmit(v42, 0xFFFFFFFFFFFFFFFFLL, (size_t (*)(int, void *, size_t))ILowMemoryDecoderStreamRead, v41, (uint64_t (*)(uint64_t, uint64_t, uint64_t))readProcessData, (uint64_t)v56, v43, v44);
        MemBufferDestroy(v45);
        if (v46 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveRead", 570, 7, 0, "MemBufferTransmit", v47, v48, v52);
          v39 = 0;
        }
        else
        {
          if (*(int *)a1 >= 1)
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12lld raw archive size\n", v46);
          v39 = 1;
        }
        ILowMemoryDecoderStreamDestroy(v41);
LABEL_55:
        if (!v65)
          goto LABEL_60;
        v52 = v65;
        v30 = "Errors in archive: %u";
        v31 = 585;
        goto LABEL_57;
      }
    }
    else if (*(_WORD *)Magic == 25200 && *(_BYTE *)(Magic + 2) == 122)
    {
      if (*(int *)a1 >= 1)
      {
        v22 = 0;
        v23 = *(_QWORD *)(Magic + 4);
        while (PCompressGetDecoderKey(v22) != *(unsigned __int8 *)(Magic + 3))
        {
          if (++v22 == 7)
          {
            v22 = -1;
            break;
          }
        }
        v24 = (FILE *)*MEMORY[0x24BDAC8D8];
        DecoderDescription = PCompressGetDecoderDescription(v22);
        fprintf(v24, "Input archive compression: %s %llum\n", DecoderDescription, bswap64(v23) >> 20);
      }
      v55[1] = 0;
      v55[4] = 0;
      memset(v54, 0, sizeof(v54));
      v53[0] = 0;
      v53[1] = 0;
      v55[0] = IMagicStreamRead;
      v55[2] = v13;
      v55[3] = readProcessData;
      v55[5] = v56;
      DWORD1(v54[0]) = 1;
      DefaultNThreads = *(_DWORD *)(a1 + 4);
      if (!DefaultNThreads)
        DefaultNThreads = getDefaultNThreads();
      DWORD2(v54[0]) = DefaultNThreads;
      if (!PCompressFilter((unsigned int *)v54, (uint64_t)v55, v53, v16, v17, v18, v19, v20))
      {
        if (*(int *)a1 >= 1)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu compressed archive size\n%12llu raw archive size\n%12.3f compression ratio\n");
        goto LABEL_54;
      }
      v27 = "PCompressFilter";
      v28 = 530;
LABEL_41:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveRead", v28, 7, 0, v27, v19, v20, v52);
      v39 = 0;
      goto LABEL_55;
    }
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 12592)
      goto LABEL_34;
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 14128)
      goto LABEL_34;
    goto LABEL_32;
  }
  v29 = *__error();
  v30 = "malloc";
  v31 = 500;
LABEL_58:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveRead", v31, 7, v29, v30, v19, v20, v52);
LABEL_59:
  v39 = 0;
LABEL_60:
  IMagicStreamDestroy(v13);
  free(v58);
  free(v59);
  free(v60);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v39)
    v50 = 0;
  else
    v50 = -1;
  if ((int)result >= 0)
    return v50;
  else
    return result;
}

size_t readProcessData(uint64_t a1, char *__src, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v10;
  int *v11;
  char *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  size_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  void (*v28)(_QWORD);
  int v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  int v59;
  char v60;
  char *v61;
  uint64_t v62;
  unint64_t v63;
  int v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  char v69;
  int OLDEntryType;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  BOOL v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  char *v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  void *v83;
  void *v84;
  int v85;
  unint64_t v86;
  char *v87;
  uint64_t v88;
  unint64_t v89;
  char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  char *v96;
  char *v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  char *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  size_t v107;
  size_t *v108;
  size_t v109;
  size_t v110;
  void (*v111)(_QWORD, char *, size_t);
  size_t v112;
  uint64_t v113;
  void (*v114)(_QWORD);
  char *v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  char *v119;
  char *v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  char *v131;
  char *v132;
  size_t v133;
  void (*v134)(_QWORD, int *, _QWORD, _QWORD, _QWORD, _QWORD);
  size_t v135;
  uint64_t v136;
  void (*v137)(uint64_t);
  uint64_t v138;
  const char *v139;
  const char *v140;
  __int16 v141;
  void (*v142)(_QWORD, char *, size_t);
  int v144;
  unint64_t v145;
  FILE **v146;
  char v147;
  char *v149;
  size_t v150;
  unint64_t *v151;
  uint64_t v152;
  unint64_t v153;

  v10 = (unint64_t *)(a1 + 2256);
  v150 = a3;
  v151 = (unint64_t *)(a1 + 2232);
  v11 = (int *)(a1 + 32);
  v12 = (char *)(a1 + 176);
  while (2)
  {
    switch(*(_DWORD *)a1)
    {
      case 0:
        *(_QWORD *)(a1 + 2232) = 0;
        *v10 = 0;
        v10[1] = 0;
        v13 = *(_QWORD *)(a1 + 16);
        if (v13 <= 7)
        {
          v113 = 8;
          goto LABEL_182;
        }
        v14 = 0;
        v15 = 0;
        v16 = *(_QWORD *)(a1 + 24);
        do
        {
          v17 = v15;
          v15 = *(_BYTE *)(v16 + v14++) & 7 | (8 * v15);
        }
        while (v14 != 8);
        if (*(_BYTE *)v16 == 16)
        {
          if (v13 > 0x1D)
          {
            v18 = bswap32(*(unsigned __int16 *)(v16 + 22)) >> 16;
            if (v18 >= 0x400)
            {
              v139 = "readProcessData";
              v140 = "invalid nameSize";
              v141 = 165;
              goto LABEL_220;
            }
            v19 = v18 + 30;
            if (*(unsigned __int8 *)(v16 + 1) - 3 <= 1)
            {
              v20 = bswap64(*(_QWORD *)(v16 + 2));
              if (v20 >= 0x400)
              {
                v139 = "readProcessData";
                v140 = "invalid linkSize";
                v141 = 169;
                goto LABEL_220;
              }
              v19 += v20;
            }
            v21 = v19 > v13;
            v22 = v19 - v13;
            if (v21)
              goto LABEL_183;
            setAAHeaderFromHeader_v10(v11, v16);
            if ((*((_BYTE *)v11 + 1) & 2) == 0)
              goto LABEL_168;
            v23 = *(_QWORD *)(a1 + 96);
            v24 = *(_QWORD *)(a1 + 2256);
            v25 = *(_QWORD *)(a1 + 2248);
            if (v24 >= v25)
            {
              *(_QWORD *)(a1 + 2248) = v25 + 16;
              v26 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v25 + 16));
              *(_QWORD *)(a1 + 2272) = v26;
              if (!v26)
                goto LABEL_202;
              v24 = *v10;
            }
            else
            {
              v26 = *(char **)(a1 + 2272);
            }
            v87 = &v26[16 * v24];
            *(_QWORD *)v87 = 0;
            *((_QWORD *)v87 + 1) = 0;
            __strlcpy_chk();
            *((_QWORD *)v87 + 1) = v23;
            goto LABEL_130;
          }
          v113 = 30;
LABEL_182:
          v22 = v113 - v13;
          goto LABEL_183;
        }
        v30 = ((8 * v17) >> 6) & 0x3FFFF;
        if (v30 == 29121)
        {
          if (v13 <= 0x6D)
          {
            v113 = 110;
            goto LABEL_182;
          }
          v57 = 0;
          v58 = 0;
          do
          {
            v59 = *(char *)(v16 + 94 + v57);
            v58 *= 16;
            v60 = v59 - 48;
            if ((v59 - 48) <= 0x36)
            {
              if (((1 << v60) & 0x3FF) != 0)
              {
                v58 = v58 + *(char *)(v16 + 94 + v57) - 48;
              }
              else if (((1 << v60) & 0x7E0000) != 0)
              {
                v58 = v58 + *(char *)(v16 + 94 + v57) - 55;
              }
              else if (((1 << v60) & 0x7E000000000000) != 0)
              {
                v58 = v58 + *(char *)(v16 + 94 + v57) - 87;
              }
            }
            ++v57;
          }
          while (v57 != 8);
          v61 = __src;
          v62 = 0;
          v63 = 0;
          do
          {
            v64 = *(char *)(v16 + 54 + v62);
            v63 *= 16;
            v65 = v64 - 48;
            if ((v64 - 48) <= 0x36)
            {
              if (((1 << v65) & 0x3FF) != 0)
              {
                v63 = v63 + *(char *)(v16 + 54 + v62) - 48;
              }
              else if (((1 << v65) & 0x7E0000) != 0)
              {
                v63 = v63 + *(char *)(v16 + 54 + v62) - 55;
              }
              else if (((1 << v65) & 0x7E000000000000) != 0)
              {
                v63 = v63 + *(char *)(v16 + 54 + v62) - 87;
              }
            }
            ++v62;
          }
          while (v62 != 8);
          v66 = 0;
          v67 = 0;
          do
          {
            v68 = *(char *)(v16 + 14 + v66);
            v67 *= 16;
            v69 = v68 - 48;
            if ((v68 - 48) <= 0x36)
            {
              if (((1 << v69) & 0x3FF) != 0)
              {
                v67 = v67 + *(char *)(v16 + 14 + v66) - 48;
              }
              else if (((1 << v69) & 0x7E0000) != 0)
              {
                v67 = v67 + *(char *)(v16 + 14 + v66) - 55;
              }
              else if (((1 << v69) & 0x7E000000000000) != 0)
              {
                v67 = v67 + *(char *)(v16 + 14 + v66) - 87;
              }
            }
            ++v66;
          }
          while (v66 != 8);
          OLDEntryType = getOLDEntryType(v67);
          if (v58 >= 0x400)
          {
            v139 = "readProcessData";
            v140 = "invalid nameSize";
            v141 = 225;
            goto LABEL_220;
          }
          v71 = v58 + 110;
          if ((OLDEntryType - 3) <= 1)
          {
            if (v63 >= 0x400)
            {
              v139 = "readProcessData";
              v140 = "invalid linkSize";
              v141 = 229;
              goto LABEL_220;
            }
            v71 += v63;
          }
          v72 = *(_QWORD *)(a1 + 16);
          v22 = v71 - v72;
          if (v71 > v72)
          {
            __src = v61;
            goto LABEL_183;
          }
          v73 = *(_QWORD *)(a1 + 24);
          if (OLDEntryType
            || v63
            || v58 != 11
            || (*(_QWORD *)(v73 + 110) == 0x2152454C49415254
              ? (v74 = *(_QWORD *)(v73 + 113) == 0x21212152454C49)
              : (v74 = 0),
                !v74))
          {
            setAAHeaderFromHeader_NEWC(v11, v73);
            v75 = (v71 + 3) & 0xFFFFFFFFFFFFFFFCLL;
            v76 = v75 - v71;
            __src = v61;
            if (v75 != v71)
            {
              v77 = *(_QWORD *)(a1 + 2256);
              v78 = *(_QWORD *)(a1 + 2248);
              if (v77 >= v78)
              {
                *(_QWORD *)(a1 + 2248) = v78 + 16;
                v79 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v78 + 16));
                *(_QWORD *)(a1 + 2272) = v79;
                if (!v79)
                  goto LABEL_202;
                v77 = *v10;
              }
              else
              {
                v79 = *(char **)(a1 + 2272);
              }
              v92 = &v79[16 * v77];
              *(_QWORD *)v92 = 0;
              *((_QWORD *)v92 + 1) = 0;
              __strlcpy_chk();
              *((_QWORD *)v92 + 1) = v76;
              ++*v10;
            }
            if ((*((_BYTE *)v11 + 1) & 2) != 0)
            {
              v93 = *(_QWORD *)(a1 + 96);
              v94 = *(_QWORD *)(a1 + 2256);
              v95 = *(_QWORD *)(a1 + 2248);
              if (v94 >= v95)
              {
                *(_QWORD *)(a1 + 2248) = v95 + 16;
                v96 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v95 + 16));
                *(_QWORD *)(a1 + 2272) = v96;
                if (!v96)
                  goto LABEL_202;
                v94 = *v10;
              }
              else
              {
                v96 = *(char **)(a1 + 2272);
              }
              v97 = &v96[16 * v94];
              *(_QWORD *)v97 = 0;
              *((_QWORD *)v97 + 1) = 0;
              __strlcpy_chk();
              *((_QWORD *)v97 + 1) = v93;
              ++*v10;
            }
            v98 = *(_QWORD *)(a1 + 96);
            v99 = (v98 + 3) & 0xFFFFFFFFFFFFFFFCLL;
            v53 = v99 - v98;
            if (v99 == v98)
              goto LABEL_168;
            v100 = *(_QWORD *)(a1 + 2256);
            v101 = *(_QWORD *)(a1 + 2248);
            if (v100 >= v101)
            {
              *(_QWORD *)(a1 + 2248) = v101 + 16;
              v102 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v101 + 16));
              *(_QWORD *)(a1 + 2272) = v102;
              if (!v102)
                goto LABEL_202;
              v100 = *v10;
            }
            else
            {
              v102 = *(char **)(a1 + 2272);
            }
            v91 = &v102[16 * v100];
            *(_QWORD *)v91 = 0;
            *((_QWORD *)v91 + 1) = 0;
LABEL_129:
            __strlcpy_chk();
            *((_QWORD *)v91 + 1) = v53;
LABEL_130:
            ++*v10;
            goto LABEL_168;
          }
          v137 = *(void (**)(uint64_t))(a1 + 2320);
          __src = v61;
          if (v137)
          {
            v138 = *(_QWORD *)(a1 + 2328);
            goto LABEL_196;
          }
LABEL_197:
          v22 = 0;
          *(_QWORD *)(a1 + 16) = 0;
          *(_DWORD *)a1 = 3;
LABEL_183:
          if (!v150)
            return a3;
          if (v22)
          {
            if (v22 >= v150)
              v135 = v150;
            else
              v135 = v22;
            v136 = *(_QWORD *)(a1 + 16);
            if (v136 + v135 > *(_QWORD *)(a1 + 8))
            {
              v139 = "readProcessData";
              v140 = "internal header buffer is too small";
              v141 = 452;
              goto LABEL_220;
            }
            memcpy((void *)(*(_QWORD *)(a1 + 24) + v136), __src, v135);
            *(_QWORD *)(a1 + 16) += v135;
            __src += v135;
            v150 -= v135;
          }
          continue;
        }
        if (v30 == 29127)
        {
          if (v13 <= 0x4B)
          {
            v113 = 76;
            goto LABEL_182;
          }
          v31 = 0;
          v32 = 0;
          do
          {
            v33 = *(_BYTE *)(v16 + 57 + v31++) & 7 | (8 * v32);
            v32 = v33;
          }
          while (v31 != 8);
          v34 = 0;
          v35 = 0;
          do
          {
            v36 = *(_BYTE *)(v16 + 64 + v34++) & 7 | (8 * v35);
            v35 = v36;
          }
          while (v34 != 4);
          v37 = 0;
          v38 = 0;
          do
          {
            v39 = *(_BYTE *)(v16 + 68 + v37++) & 7 | (8 * v38);
            v38 = v39;
          }
          while (v37 != 8);
          v40 = 0;
          v41 = 0;
          v42 = v36 << 24;
          do
          {
            v43 = *(_BYTE *)(v16 + 16 + v40++) & 7 | (8 * v41);
            v41 = v43;
          }
          while (v40 != 8);
          v44 = v33 & 0x3FFFF;
          v45 = getOLDEntryType(v43);
          if (v44 >= 0x400)
          {
            v139 = "readProcessData";
            v140 = "invalid nameSize";
            v141 = 191;
            goto LABEL_220;
          }
          v46 = v39 + (v42 & 0x1FF000000);
          v47 = v44 + 76;
          if ((v45 - 3) <= 1)
          {
            if (v46 >= 0x400)
            {
              v139 = "readProcessData";
              v140 = "invalid linkSize";
              v141 = 195;
              goto LABEL_220;
            }
            v47 += v46;
          }
          v48 = *(_QWORD *)(a1 + 16);
          v22 = v47 - v48;
          if (v47 > v48)
            goto LABEL_183;
          v49 = *(_QWORD *)(a1 + 24);
          if (v45)
            v50 = 0;
          else
            v50 = v46 == 0;
          if (v50
            && v44 == 11
            && *(_QWORD *)(v49 + 76) == 0x2152454C49415254
            && *(_QWORD *)(v49 + 79) == 0x21212152454C49)
          {
            v137 = *(void (**)(uint64_t))(a1 + 2320);
            if (v137)
            {
              v138 = *(_QWORD *)(a1 + 2328);
LABEL_196:
              v137(v138);
              goto LABEL_197;
            }
            goto LABEL_197;
          }
          setAAHeaderFromHeader_ODC(v11, v49);
          if ((*((_BYTE *)v11 + 1) & 2) != 0)
          {
            v53 = *(_QWORD *)(a1 + 96);
            v54 = *(_QWORD *)(a1 + 2256);
            v55 = *(_QWORD *)(a1 + 2248);
            if (v54 >= v55)
            {
              *(_QWORD *)(a1 + 2248) = v55 + 16;
              v56 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v55 + 16));
              *(_QWORD *)(a1 + 2272) = v56;
              if (!v56)
                goto LABEL_202;
              v54 = *v10;
            }
            else
            {
              v56 = *(char **)(a1 + 2272);
            }
            v91 = &v56[16 * v54];
            *(_QWORD *)v91 = 0;
            *((_QWORD *)v91 + 1) = 0;
            goto LABEL_129;
          }
LABEL_168:
          if ((*v11 & 1) == 0)
          {
            v139 = "readProcessData";
            v140 = "Invalid entry, no TYP field";
            v141 = 309;
            goto LABEL_220;
          }
          if ((*v11 & 0x8000) != 0 && *(_DWORD *)(a1 + 36) != 77)
          {
            v133 = strlen(v12);
            if (!pathIsValid(v12, v133))
            {
              v139 = "readProcessData";
              v140 = "Invalid entry path";
              v141 = 315;
              goto LABEL_220;
            }
          }
          v134 = *(void (**)(_QWORD, int *, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 2280);
          if (v134)
            v134(*(_QWORD *)(a1 + 2328), v11, *(_QWORD *)(a1 + 2240), *(_QWORD *)(a1 + 2232), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 16));
          *(_QWORD *)(a1 + 16) = 0;
          v29 = 1;
LABEL_175:
          *(_DWORD *)a1 = v29;
          continue;
        }
        if (*(_DWORD *)v16 == 826360153 || *(_DWORD *)v16 == 825246017)
        {
          v80 = *(unsigned __int16 *)(v16 + 4);
          v22 = v80 - v13;
          if (v80 > v13)
            goto LABEL_183;
          v152 = 0;
          v153 = 0;
          if ((yaa_decodeHeaderInfo(v16, v13, &v153, &v152) & 0x8000000000000000) != 0)
          {
            v139 = "readProcessData";
            v140 = "invalid YAA header";
            v141 = 268;
            goto LABEL_220;
          }
          v81 = *(_QWORD *)(a1 + 2224);
          v82 = v153;
          v83 = *(void **)(a1 + 2240);
          if (v81 < v153)
          {
            *(_QWORD *)(a1 + 2224) = v153;
            v84 = reallocf(v83, 1032 * v82);
            *(_QWORD *)(a1 + 2240) = v84;
            if (!v84)
            {
              v144 = *__error();
              v139 = "readProcessData";
              v140 = "malloc";
              v141 = 275;
              goto LABEL_221;
            }
            v83 = v84;
            v81 = *(_QWORD *)(a1 + 2224);
          }
          if (yaa_decodeHeader(v11, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 16), (uint64_t)v83, v81, v151) != v80)
          {
            v139 = "readProcessData";
            v140 = "invalid YAA header";
            v141 = 280;
            goto LABEL_220;
          }
          *v10 = 0;
          v10[1] = 0;
          v85 = *v11;
          if ((*v11 & 0x200) != 0)
          {
            v88 = *(_QWORD *)(a1 + 96);
            if (*(_QWORD *)(a1 + 2248))
            {
              v89 = 0;
              v90 = *(char **)(a1 + 2272);
            }
            else
            {
              *(_QWORD *)(a1 + 2248) = 16;
              v90 = (char *)reallocf(*(void **)(a1 + 2272), 0x100uLL);
              *(_QWORD *)(a1 + 2272) = v90;
              if (!v90)
                goto LABEL_202;
              v89 = *v10;
            }
            v115 = &v90[16 * v89];
            *(_QWORD *)v115 = 0;
            *((_QWORD *)v115 + 1) = 0;
            __strlcpy_chk();
            *((_QWORD *)v115 + 1) = v88;
            v86 = *v10 + 1;
            *v10 = v86;
            v85 = *v11;
            if ((*v11 & 0x400) == 0)
              goto LABEL_151;
          }
          else
          {
            v86 = 0;
            if ((v85 & 0x400) == 0)
            {
LABEL_151:
              v149 = v12;
              if ((v85 & 0x800) != 0)
              {
                v121 = *(_QWORD *)(a1 + 112);
                v122 = *(_QWORD *)(a1 + 2248);
                if (v86 >= v122)
                {
                  *(_QWORD *)(a1 + 2248) = v122 + 16;
                  v123 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v122 + 16));
                  *(_QWORD *)(a1 + 2272) = v123;
                  if (!v123)
                  {
LABEL_202:
                    v144 = *__error();
                    v139 = "addBlob";
                    v140 = "malloc";
                    v141 = 111;
                    goto LABEL_221;
                  }
                  v120 = __src;
                  v86 = *v10;
                }
                else
                {
                  v120 = __src;
                  v123 = *(char **)(a1 + 2272);
                }
                v124 = &v123[16 * v86];
                *(_QWORD *)v124 = 0;
                *((_QWORD *)v124 + 1) = 0;
                __strlcpy_chk();
                *((_QWORD *)v124 + 1) = v121;
                v86 = *v10 + 1;
                *v10 = v86;
              }
              else
              {
                v120 = __src;
              }
              v125 = *v151;
              if (*v151)
              {
                v126 = 0;
                v127 = 0;
                do
                {
                  v128 = *(_QWORD *)(a1 + 2240) + v126;
                  if (*(_DWORD *)(v128 + 4) == 2)
                  {
                    v129 = *(_QWORD *)(v128 + 8);
                    v130 = *(_QWORD *)(a1 + 2248);
                    if (v86 >= v130)
                    {
                      *(_QWORD *)(a1 + 2248) = v130 + 16;
                      v131 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v130 + 16));
                      *(_QWORD *)(a1 + 2272) = v131;
                      if (!v131)
                        goto LABEL_202;
                      v86 = *v10;
                    }
                    else
                    {
                      v131 = *(char **)(a1 + 2272);
                    }
                    v132 = &v131[16 * v86];
                    *(_QWORD *)v132 = 0;
                    *((_QWORD *)v132 + 1) = 0;
                    __strlcpy_chk();
                    *((_QWORD *)v132 + 1) = v129;
                    v86 = *v10 + 1;
                    *v10 = v86;
                    v125 = *v151;
                  }
                  ++v127;
                  v126 += 1032;
                }
                while (v127 < v125);
              }
              __src = v120;
              v12 = v149;
              goto LABEL_168;
            }
          }
          v116 = *(_QWORD *)(a1 + 104);
          v117 = *(_QWORD *)(a1 + 2248);
          if (v86 >= v117)
          {
            *(_QWORD *)(a1 + 2248) = v117 + 16;
            v118 = (char *)reallocf(*(void **)(a1 + 2272), 16 * (v117 + 16));
            *(_QWORD *)(a1 + 2272) = v118;
            if (!v118)
              goto LABEL_202;
            v86 = *v10;
          }
          else
          {
            v118 = *(char **)(a1 + 2272);
          }
          v119 = &v118[16 * v86];
          *(_QWORD *)v119 = 0;
          *((_QWORD *)v119 + 1) = 0;
          __strlcpy_chk();
          *((_QWORD *)v119 + 1) = v116;
          v86 = *v10 + 1;
          *v10 = v86;
          v85 = *v11;
          goto LABEL_151;
        }
        v145 = 0;
        ++*(_DWORD *)(a1 + 2336);
        v146 = (FILE **)MEMORY[0x24BDAC8D8];
        do
        {
          if (*(char *)(*(_QWORD *)(a1 + 24) + v145) > 31)
            fputc(*(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + v145), *v146);
          else
            fprintf(*v146, "<%02x>", *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + v145));
          ++v145;
        }
        while (v145 < *(_QWORD *)(a1 + 16));
        fputc(10, *v146);
        v139 = "readProcessData";
        v140 = "Invalid header";
        v141 = 305;
LABEL_220:
        v144 = 0;
LABEL_221:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)v139, v141, 7, v144, v140, a7, a8, v147);
        return -1;
      case 1:
        v27 = *(_QWORD *)(a1 + 2264);
        if (v27 != *(_QWORD *)(a1 + 2256))
        {
          if (*(_BYTE *)(*(_QWORD *)(a1 + 2272) + 16 * v27))
          {
            v28 = *(void (**)(_QWORD))(a1 + 2288);
            if (v28)
              v28(*(_QWORD *)(a1 + 2328));
          }
          v29 = 2;
          goto LABEL_175;
        }
        v114 = *(void (**)(_QWORD))(a1 + 2312);
        if (v114)
          v114(*(_QWORD *)(a1 + 2328));
        v22 = 0;
        *(_DWORD *)a1 = 0;
        goto LABEL_183;
      case 2:
        v103 = *(_QWORD *)(a1 + 2272);
        v104 = *(_QWORD *)(a1 + 2264);
        v105 = v103 + 16 * v104;
        v106 = 16 * v104;
        v109 = *(_QWORD *)(v105 + 8);
        v108 = (size_t *)(v105 + 8);
        v107 = v109;
        if (v150 >= v109)
          v110 = v107;
        else
          v110 = v150;
        if (*(_BYTE *)(v103 + v106))
        {
          v111 = *(void (**)(_QWORD, char *, size_t))(a1 + 2296);
          if (!v111)
            goto LABEL_137;
LABEL_136:
          v111(*(_QWORD *)(a1 + 2328), __src, v110);
          v107 = *v108;
          goto LABEL_137;
        }
        v111 = *(void (**)(_QWORD, char *, size_t))(a1 + 2304);
        if (v111)
          goto LABEL_136;
LABEL_137:
        v150 -= v110;
        __src += v110;
        v112 = v107 - v110;
        *v108 = v112;
        if (!v112)
        {
          ++*(_QWORD *)(a1 + 2264);
          *(_DWORD *)a1 = 1;
          continue;
        }
        v22 = 0;
        goto LABEL_183;
      case 3:
        v142 = *(void (**)(_QWORD, char *, size_t))(a1 + 2320);
        if (v142)
          v142(*(_QWORD *)(a1 + 2328), __src, v150);
        return a3;
      default:
        v139 = "readProcessData";
        v140 = "invalid state";
        v141 = 436;
        goto LABEL_220;
    }
  }
}

uint64_t ParallelArchiveReadMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t Magic;
  unint64_t MagicSize;
  uint64_t result;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, uint64_t, unint64_t);
  uint64_t v24;
  uint64_t v25;
  uint64_t DataPtr;
  unint64_t DataSize;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  size_t v34;
  char *v35;
  unint64_t v36;
  unint64_t v37;
  size_t v38;
  const void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  __int16 v47;
  unsigned int v48;
  size_t v49;
  uint64_t v50;

  if (!a1)
    return 0xFFFFFFFFLL;
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v49);
  v9 = (unint64_t *)MemBufferCreate(0x10000uLL);
  if (!v9)
  {
    v17 = 0;
    v11 = 0;
LABEL_50:
    v18 = 0;
    goto LABEL_51;
  }
  v10 = IMagicStreamCreate(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), 8);
  v11 = v10;
  if (!v10)
  {
LABEL_46:
    v17 = 0;
    goto LABEL_50;
  }
  Magic = IMagicStreamGetMagic((uint64_t)v10);
  MagicSize = IMagicStreamGetMagicSize((uint64_t)v11);
  if (!MagicSize)
  {
    v17 = 0;
    goto LABEL_19;
  }
  if (MagicSize < 6)
  {
    if (MagicSize < 4)
    {
LABEL_23:
      v19 = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMagicStreamRead, (uint64_t)IMagicStreamAbort, (uint64_t)v11, 0x10000uLL);
      if (v19)
      {
        v22 = v19;
        v23 = (uint64_t (*)(uint64_t, uint64_t, unint64_t))ILowMemoryDecoderStreamRead;
        v17 = v19;
        goto LABEL_28;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveReadMetadata", 642, 7, 0, "Could not identify payload format", v20, v21, v49);
      goto LABEL_46;
    }
  }
  else
  {
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 12592)
      goto LABEL_25;
    if (*(_DWORD *)Magic == 925906736 && *(_WORD *)(Magic + 4) == 14128)
      goto LABEL_25;
  }
  if (*(_DWORD *)Magic != 826360153 && *(_DWORD *)Magic != 825246017)
    goto LABEL_23;
LABEL_25:
  if (*(int *)a1 >= 2)
    fwrite("Raw cpio/yaa archive payload\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  v17 = 0;
  v23 = (uint64_t (*)(uint64_t, uint64_t, unint64_t))IMagicStreamRead;
  v22 = (uint64_t)v11;
LABEL_28:
  if (MemBufferFillFromIStream(v9, 0x10000uLL, v23, v22) < 0)
  {
    v46 = "Reading entry";
    v47 = 649;
LABEL_49:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Read.c", (uint64_t)"ParallelArchiveReadMetadata", v47, 7, 0, v46, v24, v25, v49);
    goto LABEL_50;
  }
  DataPtr = MemBufferGetDataPtr((uint64_t)v9);
  DataSize = MemBufferGetDataSize((uint64_t)v9);
  v49 = 0;
  v50 = 0;
  v28 = yaa_decodeHeaderInfo(DataPtr, DataSize, &v50, &v49);
  if ((v28 & 0x8000000000000000) != 0)
  {
    v46 = "Parsing YAA header";
    v47 = 660;
    goto LABEL_49;
  }
  v29 = v28;
  *(_QWORD *)(a1 + 2240) = v50;
  *(_QWORD *)(a1 + 2264) = v49;
  if (yaa_decodeHeader((_DWORD *)(a1 + 32), DataPtr, v28, *(_QWORD *)(a1 + 2224), *(_QWORD *)(a1 + 2232), (unint64_t *)(a1 + 2240)) < 0)
  {
    v46 = "Decoding YAA header";
    v47 = 665;
    goto LABEL_49;
  }
  MemBufferDecreaseSize((uint64_t)v9, v29, v30, v31, v32, v33, v24, v25);
  if (v49 >= *(_QWORD *)(a1 + 2256))
    v34 = *(_QWORD *)(a1 + 2256);
  else
    v34 = v49;
  if (v34)
  {
    v35 = *(char **)(a1 + 2248);
    while (1)
    {
      v36 = MemBufferGetDataSize((uint64_t)v9);
      if (v34 > v36 && MemBufferFillFromIStream(v9, v34 - v36, v23, v22) < 0)
        break;
      v37 = MemBufferGetDataSize((uint64_t)v9);
      if (v37 >= v34)
        v38 = v34;
      else
        v38 = v37;
      v39 = (const void *)MemBufferGetDataPtr((uint64_t)v9);
      memcpy(v35, v39, v38);
      MemBufferDecreaseSize((uint64_t)v9, v38, v40, v41, v42, v43, v44, v45);
      v35 += v38;
      v34 -= v38;
      if (!v34)
        goto LABEL_19;
    }
    v46 = "Reading entry";
    v47 = 678;
    goto LABEL_49;
  }
LABEL_19:
  v18 = 1;
LABEL_51:
  ILowMemoryDecoderStreamDestroy(v17);
  IMagicStreamDestroy(v11);
  MemBufferDestroy((void **)v9);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v18)
    v48 = 0;
  else
    v48 = -1;
  if ((int)result >= 0)
    return v48;
  else
    return result;
}

void *reallocToFit(void *a1, size_t __size)
{
  void *v4;
  void *v5;

  if (__size >= 0x1000)
  {
    v4 = malloc(__size);
    if (v4)
    {
      v5 = v4;
      memcpy(v4, a1, __size);
      free(a1);
      return v5;
    }
  }
  return a1;
}

uint64_t getInstalledMemorySize()
{
  uint64_t v0;
  uint64_t v1;

  v0 = sysconf(200);
  v1 = sysconf(29);
  if (v1 <= 0 || v0 <= 0)
    return 0;
  else
    return v1 * v0;
}

double getRealTime()
{
  timeval v1;

  v1.tv_sec = 0;
  *(_QWORD *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return (double)v1.tv_sec + (double)v1.tv_usec * 0.000001;
}

uint64_t getDefaultNThreads()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  size_t v4;
  unsigned int v5;

  v5 = 0;
  v4 = 4;
  if (!sysctlbyname("hw.physicalcpu", &v5, &v4, 0, 0))
    return v5;
  v0 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getDefaultNThreads", 107, 3, *v0, "sysctlbyname", v1, v2, v4);
  return 1;
}

uint64_t sha1ToString(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  _BYTE *v3;
  unint64_t v4;

  v2 = 0;
  v3 = (_BYTE *)(result + 1);
  do
  {
    v4 = *(unsigned __int8 *)(a2 + v2);
    *(v3 - 1) = serializeHexString_digit[v4 >> 4];
    *v3 = serializeHexString_digit[v4 & 0xF];
    v3 += 2;
    ++v2;
  }
  while (v2 != 20);
  *(_BYTE *)(result + 40) = 0;
  return result;
}

uint64_t serializeHexString(uint64_t result, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t v3;
  unsigned int v4;

  if (a2)
  {
    v3 = 0;
    do
    {
      v4 = *a3++;
      *(_BYTE *)(result + v3) = serializeHexString_digit[(unint64_t)v4 >> 4];
      *(_BYTE *)(result + (v3 + 1)) = serializeHexString_digit[v4 & 0xF];
      v3 += 2;
    }
    while (2 * a2 != v3);
  }
  *(_BYTE *)(result + 2 * a2) = 0;
  return result;
}

uint64_t sha1cmp(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = bswap64(*(_QWORD *)a1);
  v3 = bswap64(*(_QWORD *)a2);
  if (v2 == v3)
  {
    v2 = bswap64(*(_QWORD *)(a1 + 8));
    v3 = bswap64(*(_QWORD *)(a2 + 8));
    if (v2 == v3)
    {
      v2 = bswap32(*(_DWORD *)(a1 + 16));
      v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3)
        return 0;
    }
  }
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  return 1;
}

uint64_t sha1xor(uint64_t result, uint64_t a2)
{
  uint64_t i;

  for (i = 0; i != 20; ++i)
    *(_BYTE *)(result + i) ^= *(_BYTE *)(a2 + i);
  return result;
}

const char *makePath(const char *result, unint64_t a2)
{
  const char *v3;
  unint64_t v4;
  int v5;
  stat v6;

  v3 = result;
  memset(&v6, 0, sizeof(v6));
  if (a2)
  {
    v4 = a2;
    do
    {
      if (v3[v4] == 47)
      {
        v3[v4] = 0;
        result = (const char *)stat(v3, &v6);
        if (!(_DWORD)result)
          break;
      }
      --v4;
    }
    while (v4);
  }
  else
  {
    v4 = 0;
  }
  if (v4 < a2)
  {
    v5 = 1;
    do
    {
      if (!v3[v4])
      {
        if (!v5)
          result = (const char *)mkdir(v3, 0x1EDu);
        v5 = 0;
        v3[v4] = 47;
      }
      ++v4;
    }
    while (a2 != v4);
  }
  return result;
}

const char *statPath(const char *result, uint64_t a2)
{
  uint64_t v2;
  const char *v3;
  stat v4;

  if (a2)
  {
    v2 = a2;
    v3 = result;
    memset(&v4, 0, sizeof(v4));
    do
    {
      if (v3[v2] == 47)
      {
        v3[v2] = 0;
        result = (const char *)stat(v3, &v4);
        v3[v2] = 47;
      }
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t concatPath(char *a1, unint64_t a2, char *__s, const char *a4)
{
  size_t v8;
  size_t v9;
  uint64_t result;
  size_t v11;

  v8 = strlen(__s);
  v9 = strlen(a4);
  if (v8 + v9 + 2 > a2)
    return 0xFFFFFFFFLL;
  v11 = v9;
  if (a1 != __s)
    memcpy(a1, __s, v8);
  if (v11)
  {
    if (!v8 || a1[v8 - 1] != 47)
      a1[v8++] = 47;
    memcpy(&a1[v8], a4, v11);
    v8 += v11;
  }
  result = 0;
  a1[v8] = 0;
  return result;
}

uint64_t concatExtractPath(char *a1, size_t a2, char *__s, const char *a4)
{
  size_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int64_t v13;
  const char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  size_t v20;
  char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  stat v29;

  v8 = strlen(__s);
  v9 = strlen(a4);
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 278, 3, 0, "invalid dir: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  v12 = v9;
  if (v8 + v9 + 1 >= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 279, 3, 0, "dir/path too long: %s", v10, v11, (char)__s);
    return 0xFFFFFFFFLL;
  }
  strlcpy(a1, __s, a2);
  if (!v12)
    return 0;
  v13 = 0;
  memset(&v29, 0, sizeof(v29));
  while (1)
  {
    v14 = &a4[v13];
    v15 = strchr((char *)&a4[v13], 47);
    v18 = v15 - a4;
    if (v15)
      v19 = v15 - a4;
    else
      v19 = v12;
    v20 = v19 - v13;
    if (v19 == v13)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 297, 3, 0, "invalid path: %s", v16, v17, (char)a4);
      return 0xFFFFFFFFLL;
    }
    v21 = v15;
    if (v20 != 2)
    {
      if (v20 == 1 && *v14 == 46)
        goto LABEL_29;
      goto LABEL_15;
    }
    if (*v14 == 46 && a4[v13 + 1] == 46)
      break;
LABEL_15:
    v22 = lstat(a1, &v29);
    if (v13)
    {
      if (v22)
      {
        if (mkdir(a1, 0x1EDu) && (lstat(a1, &v29) || (v29.st_mode & 0xF000) != 0x4000))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 326, 3, 0, "a parent of path is not a directory: %s", v25, v26, (char)a4);
          return 0xFFFFFFFFLL;
        }
      }
      else if ((v29.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 316, 3, 0, "a parent of path is not a directory: %s", v23, v24, (char)a4);
        return 0xFFFFFFFFLL;
      }
    }
    else if (v22 || (v27 = v29.st_mode & 0xF000, v27 != 0x4000) && v27 != 40960)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 311, 3, 0, "dir doesn't exist, or is invalid: %s", v23, v24, (char)__s);
      return 0xFFFFFFFFLL;
    }
    if (a1[v8 - 1] != 47)
      a1[v8++] = 47;
    memcpy(&a1[v8], &a4[v13], v20);
    v8 += v20;
    a1[v8] = 0;
LABEL_29:
    if (v21)
    {
      v13 = v18 + 1;
      if (v18 + 1 < v12)
        continue;
    }
    return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"concatExtractPath", 304, 3, 0, "invalid path: %s", v16, v17, (char)a4);
  return 0xFFFFFFFFLL;
}

BOOL pathIsValid(_BYTE *a1, size_t __n)
{
  _BOOL8 result;
  void *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if (!__n)
    return 1;
  if (__n > 0x3FF)
    return 0;
  v5 = memchr(a1, 0, __n);
  result = 0;
  if (v5)
    return result;
  if (*a1 == 47)
    return 0;
  v6 = 0;
  do
  {
    v7 = &a1[v6];
    v8 = memchr(&a1[v6], 47, __n - v6);
    if (!v8)
      break;
    v9 = v8 - a1;
    v10 = v8 - a1 - v6;
    if (v8 - a1 == v6)
      return 0;
    if (v6 && v10 == 1)
    {
      v11 = *v7;
      goto LABEL_13;
    }
    if (v10 == 2 && *v7 == 46)
    {
      v11 = a1[v6 + 1];
LABEL_13:
      if (v11 == 46)
        return 0;
    }
    v6 = v9 + 1;
  }
  while (v9 + 1 < __n);
  return v6 != __n;
}

uint64_t getTempDir(char *a1, size_t a2)
{
  const char *v4;
  size_t v6;
  size_t v7;

  if (!a2)
    return 0xFFFFFFFFLL;
  v4 = (const char *)confstr(65537, a1, a2);
  if (!v4)
  {
    if (issetugid())
    {
      v4 = 0;
    }
    else
    {
      v4 = getenv("TMPDIR");
      if (v4)
        v4 = (const char *)strlcpy(a1, v4, a2);
    }
  }
  if ((unint64_t)v4 >= a2)
    return 0xFFFFFFFFLL;
  v6 = strlen(a1);
  do
  {
    v7 = v6;
    if (!v6)
      break;
    --v6;
  }
  while (a1[v7 - 1] == 47);
  a1[v7] = 0;
  if (v7)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t loadFileContents(const char *a1, char **a2, off_t *a3, uint64_t a4)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  off_t st_size;
  uint64_t result;
  int v14;
  int v15;
  char *v16;
  unint64_t v17;
  size_t v18;
  ssize_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  stat v31;

  memset(&v31, 0, sizeof(v31));
  if (lstat(a1, &v31))
  {
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", 475, 3, *v8, "%s", v9, v10, (char)a1);
    v11 = 0;
    goto LABEL_3;
  }
  st_size = v31.st_size;
  if (v31.st_size)
  {
    v11 = (char *)malloc(v31.st_size + a4);
    if (v11)
    {
      v14 = open(a1, 0);
      if ((v14 & 0x80000000) == 0)
      {
        v15 = v14;
        v16 = v11;
        v17 = st_size;
        while (1)
        {
          if (v17 >= 0x40000000)
            v18 = 0x40000000;
          else
            v18 = v17;
          v19 = read(v15, v16, v18);
          if (v19 < 0)
          {
            v27 = *__error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", 499, 3, v27, "%s", v28, v29, (char)a1);
            goto LABEL_23;
          }
          if (v19 != v18)
            break;
          v16 += v18;
          v17 -= v18;
          if (!v17)
          {
            close(v15);
            goto LABEL_17;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", 500, 3, 0, "reading contents: %s", v20, v21, (char)a1);
LABEL_23:
        close(v15);
        goto LABEL_3;
      }
      v22 = *__error();
      v30 = (char)a1;
      v25 = "%s";
      v26 = 486;
    }
    else
    {
      v22 = *__error();
      v25 = "malloc";
      v26 = 482;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileContents", v26, 3, v22, v25, v23, v24, v30);
LABEL_3:
    free(v11);
    v11 = 0;
    st_size = 0;
    result = 0xFFFFFFFFLL;
    goto LABEL_4;
  }
  v11 = 0;
LABEL_17:
  result = 0;
LABEL_4:
  *a2 = v11;
  *a3 = st_size;
  return result;
}

uint64_t loadFileSegment(const char *a1, void *a2, size_t a3, off_t a4)
{
  char v7;
  int v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  int v15;
  char v17;

  v7 = (char)a1;
  v8 = open(a1, 0);
  if (v8 < 0)
  {
    v15 = *__error();
    v17 = v7;
    v13 = "%s";
    v14 = 521;
    goto LABEL_7;
  }
  v9 = v8;
  v10 = pread(v8, a2, a3, a4);
  close(v9);
  if ((v10 & 0x8000000000000000) != 0)
  {
    v15 = *__error();
    v17 = v7;
    v13 = "%s";
    v14 = 524;
    goto LABEL_7;
  }
  if (v10 < a3)
  {
    v13 = "truncated read";
    v14 = 525;
    v15 = 0;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"loadFileSegment", v14, 3, v15, v13, v11, v12, v17);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t storeFileContents(const char *a1, uint64_t a2, unint64_t a3)
{
  char v5;
  int v6;
  int v7;
  unint64_t v8;
  size_t v9;
  ssize_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  v5 = (char)a1;
  v6 = open(a1, 1537, 420);
  if (v6 < 0)
  {
    v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 535, 3, *v14, "%s", v15, v16, v5);
    v13 = 0;
  }
  else
  {
    v7 = v6;
    if (a3)
    {
      v8 = 0;
      while (1)
      {
        if (a3 - v8 >= 0x10000000)
          v9 = 0x10000000;
        else
          v9 = a3 - v8;
        v10 = write(v7, (const void *)(a2 + v8), v9);
        if (v10 < 0)
        {
          v17 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 544, 3, v17, "%s", v18, v19, v5);
          goto LABEL_14;
        }
        if (!v10)
          break;
        v8 += v10;
        if (v8 >= a3)
          goto LABEL_10;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"storeFileContents", 545, 3, 0, "write error: %s", v11, v12, v5);
LABEL_14:
      v13 = 0;
    }
    else
    {
LABEL_10:
      v13 = 1;
    }
    close(v7);
  }
  if (v13)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t copyFileSegment(const char *a1, unint64_t a2, unint64_t a3, const char *a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char v21;

  v10 = (unint64_t *)MemBufferCreate(0x100000uLL);
  if (v10)
  {
    v13 = (char *)IFileStreamCreateWithFilename(a1, a2, a3);
    if (v13)
    {
      v16 = OFileStreamCreateWithFilename(a4, a3);
      if (v16)
      {
        if ((MemBufferTransmit(v10, a3, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t, uint64_t))OFileStreamWrite, (uint64_t)v16, v14, v15) & 0x8000000000000000) == 0)
        {
          v19 = 0;
          goto LABEL_11;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 569, 3, 0, "copy failed: %s to %s", v17, v18, (char)a1);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 566, 3, 0, "opening file: %s", v14, v15, (char)a4);
      }
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 565, 3, 0, "opening file: %s", v11, v12, (char)a1);
      v16 = 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"copyFileSegment", 564, 3, 0, "mem buffer creation", v8, v9, v21);
    v16 = 0;
    v13 = 0;
  }
  v19 = 1;
LABEL_11:
  IFileStreamDestroy(v13);
  OFileStreamDestroy(v16);
  MemBufferDestroy((void **)v10);
  if (v19)
    unlink(a4);
  return (v19 << 31 >> 31);
}

uint64_t statIsCompressed(unsigned int a1)
{
  if ((a1 & 0x40000000) != 0)
    return 0;
  else
    return (a1 >> 5) & 1;
}

uint64_t getFileAPFSInternalFlags()
{
  return 0;
}

uint64_t areFilesEqual(const char *a1, const char *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  int v14;
  int v15;
  int v16;
  int v17;
  void *v18;
  ssize_t v19;
  size_t v20;
  ssize_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  stat v38;
  stat v39;

  memset(&v39, 0, sizeof(v39));
  memset(&v38, 0, sizeof(v38));
  if (stat(a1, &v39))
  {
    v4 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 708, 3, v4, "%s", v5, v6, (char)a1);
LABEL_5:
    v10 = 0;
    v11 = 0;
    v12 = 0xFFFFFFFFLL;
    goto LABEL_6;
  }
  if (stat(a2, &v38))
  {
    v7 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 709, 3, v7, "%s", v8, v9, (char)a2);
    goto LABEL_5;
  }
  if ((v39.st_mode & 0xF000) != 0x8000 || (v38.st_mode & 0xF000) != 0x8000 || v39.st_size != v38.st_size)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    goto LABEL_6;
  }
  v14 = open(a1, 0);
  if (v14 < 0)
  {
    v22 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 714, 3, v22, "%s", v23, v24, (char)a1);
    goto LABEL_5;
  }
  v15 = v14;
  v16 = open(a2, 0);
  if (v16 < 0)
  {
    v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 716, 3, *v25, "%s", v26, v27, (char)a2);
    close(v15);
    goto LABEL_5;
  }
  v17 = v16;
  v11 = malloc(0x40000uLL);
  v18 = malloc(0x40000uLL);
  v10 = v18;
  if (!v11 || !v18)
  {
    v28 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 719, 3, *v28, "malloc", v29, v30, v37);
    close(v15);
    v12 = 0xFFFFFFFFLL;
    goto LABEL_29;
  }
  while (1)
  {
    v19 = read(v15, v11, 0x40000uLL);
    if (v19 < 0)
    {
      v31 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 723, 3, v31, "%s read", v32, v33, (char)a1);
LABEL_26:
      v12 = 0xFFFFFFFFLL;
      goto LABEL_28;
    }
    v20 = v19;
    v21 = read(v17, v10, 0x40000uLL);
    if (v21 < 0)
    {
      v34 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"areFilesEqual", 725, 3, v34, "%s read", v35, v36, (char)a2);
      goto LABEL_26;
    }
    if (v20 != v21)
      goto LABEL_19;
    if (!v20)
      break;
    if (memcmp(v11, v10, v20))
    {
LABEL_19:
      v12 = 0;
      goto LABEL_28;
    }
  }
  v12 = 1;
LABEL_28:
  close(v15);
  if ((v17 & 0x80000000) == 0)
LABEL_29:
    close(v17);
LABEL_6:
  free(v11);
  free(v10);
  return v12;
}

uint64_t areFilesEqual2()
{
  char *v0;
  const char *v1;
  const char *v2;
  char *v3;
  const char *v4;
  char v6[2048];
  char v7[2048];
  uint64_t v8;

  v0 = (char *)MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = v0;
  v8 = *MEMORY[0x24BDAC8D0];
  if (concatPath(v7, 0x800uLL, v0, v4) || concatPath(v6, 0x800uLL, v3, v2))
    return 0xFFFFFFFFLL;
  else
    return areFilesEqual(v7, v6);
}

uint64_t getFilesystemBlockSize(const char *a1)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  statfs v6;
  uint64_t v7;

  v1 = (char)a1;
  v7 = *MEMORY[0x24BDAC8D0];
  memset(&v6, 0, 512);
  if ((statfs(a1, &v6) & 0x80000000) == 0)
    return v6.f_bsize;
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFilesystemBlockSize", 752, 3, "statfs failed: %s\n", v2, v3, v4, v1);
  return 4096;
}

uint64_t getFileDiskUsage(const char *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  off_t st_size;
  int v7;
  uint64_t v10;
  off_t v11;
  stat v12;

  memset(&v12, 0, sizeof(v12));
  if (lstat(a1, &v12))
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDiskUsage", 765, 3, "stat failed: %s\n", v2, v3, v4, (char)a1);
    return -1;
  }
  else
  {
    if (v12.st_blocks << 9 >= (unint64_t)v12.st_size || v12.st_blocks << 9 == 0)
      st_size = v12.st_size;
    else
      st_size = v12.st_blocks << 9;
    if ((v12.st_mode & 0xF000) == 0x8000)
    {
      v10 = 0;
      v11 = 0;
      v7 = ParallelCompressionAFSCGetMetadata(a1, &v11, (unsigned int *)&v10 + 1, &v10);
      if (HIDWORD(v10) != -1 && v7 == 0)
        return v10;
    }
  }
  return st_size;
}

uint64_t setFileAPFSInternalFlagsFD(uint64_t a1, uint64_t a2)
{
  if (a2)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t getFileProtectionClass(const char *a1)
{
  int v1;
  _QWORD v4[3];
  _OWORD v5[4];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v4[1] = 0;
  v4[2] = 0;
  memset(v5, 0, sizeof(v5));
  v4[0] = 0x4000000000000005;
  v1 = getattrlist(a1, v4, v5, 0x40uLL, 1u);
  if (LODWORD(v5[0]) == 8 && v1 == 0)
    return DWORD1(v5[0]);
  else
    return 0xFFFFFFFFLL;
}

uint64_t clearEntryXAT(const char *a1)
{
  ssize_t v2;
  size_t v3;
  char *v4;
  ssize_t v5;
  ssize_t v6;
  uint64_t v7;
  const char *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  char v22;

  v2 = listxattr(a1, 0, 0, 1);
  if (v2 < 0)
  {
    v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"clearEntryXAT", 912, 3, *v9, "listxattr failed: %s", v10, v11, (char)a1);
    v4 = 0;
    goto LABEL_20;
  }
  v3 = v2;
  if (!v2)
  {
    v4 = 0;
LABEL_15:
    v12 = 0;
    goto LABEL_21;
  }
  v4 = (char *)malloc(v2);
  if (!v4)
  {
    v13 = *__error();
    v16 = "malloc";
    v17 = 918;
    goto LABEL_19;
  }
  v5 = listxattr(a1, v4, v3, 1);
  if (v5 < 0)
  {
    v18 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"clearEntryXAT", 927, 3, v18, "listxattr failed: %s", v19, v20, (char)a1);
    goto LABEL_20;
  }
  v6 = v5;
  if (!v5)
    goto LABEL_15;
  v7 = 0;
  v8 = v4;
  while (v4[v7])
  {
    ++v7;
LABEL_11:
    if (v7 == v6)
      goto LABEL_15;
  }
  if ((removexattr(a1, v8, 1) & 0x80000000) == 0)
  {
    v8 = &v4[++v7];
    goto LABEL_11;
  }
  v13 = *__error();
  v22 = (char)v8;
  v16 = "removexattr failed for name=%s: %s";
  v17 = 941;
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"clearEntryXAT", v17, 3, v13, v16, v14, v15, v22);
LABEL_20:
  v12 = 0xFFFFFFFFLL;
LABEL_21:
  free(v4);
  return v12;
}

uint64_t getBufferSHA1Digest(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  unint64_t v6;
  CC_LONG v7;
  unint64_t v8;
  CC_LONG v9;
  CC_SHA1_CTX v11;

  memset(&v11, 0, sizeof(v11));
  CC_SHA1_Init(&v11);
  if (a2)
  {
    v6 = 0;
    v7 = a2;
    do
    {
      v8 = v6 + 0x100000;
      if (v6 + 0x100000 <= a2)
        v9 = 0x100000;
      else
        v9 = v7;
      CC_SHA1_Update(&v11, (const void *)(a1 + v6), v9);
      v7 -= 0x100000;
      v6 = v8;
    }
    while (v8 < a2);
  }
  CC_SHA1_Final(a3, &v11);
  return 0;
}

uint64_t getFileDigests(char *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int *a4)
{
  char v7;
  int v9;
  int v10;
  void *v11;
  void *v12;
  ssize_t v13;
  ssize_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  _QWORD v26[2];
  CC_SHA256_CTX v27;
  CC_SHA1_CTX c;

  v7 = (char)a1;
  if (!a2 && !a3 && !a4)
    return 0;
  memset(&c, 0, sizeof(c));
  memset(&v27, 0, sizeof(v27));
  v26[0] = 0;
  v26[1] = 0;
  v9 = open(a1, 0);
  if (v9 < 0)
  {
    v19 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDigests", 983, 3, *v19, "%s", v20, v21, v7);
    v18 = 0;
  }
  else
  {
    v10 = v9;
    v11 = valloc(0x100000uLL);
    if (v11)
    {
      v12 = v11;
      if (a2)
        CC_SHA1_Init(&c);
      if (a3)
        CC_SHA256_Init(&v27);
      if (a4)
        CC_CKSUM_Init((uint64_t)v26);
      v13 = read(v10, v12, 0x100000uLL);
      if (v13 < 0)
      {
LABEL_23:
        v15 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDigests", 997, 3, *v15, "read", v16, v17, v25);
        v18 = 0;
      }
      else
      {
        v14 = v13;
        while (v14)
        {
          if (a2)
            CC_SHA1_Update(&c, v12, v14);
          if (a3)
            CC_SHA256_Update(&v27, v12, v14);
          if (a4)
            CC_CKSUM_Update((uint64_t)v26, (unsigned __int8 *)v12, v14);
          v14 = read(v10, v12, 0x100000uLL);
          if (v14 < 0)
            goto LABEL_23;
        }
        if (a2)
          CC_SHA1_Final(a2, &c);
        if (a3)
          CC_SHA256_Final(a3, &v27);
        if (a4)
          CC_CKSUM_Final(a4, (uint64_t)v26);
        v18 = 1;
      }
      free(v12);
    }
    else
    {
      v22 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileDigests", 987, 3, *v22, "malloc", v23, v24, v25);
      v18 = 0;
    }
    close(v10);
  }
  if (v18)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t getFileSHA1Digest(const char *a1, uint64_t a2)
{
  return getFileSegmentSHA1Digest(a1, 0, 0xFFFFFFFFFFFFFFFFLL, a2);
}

uint64_t getFileSegmentSHA1Digest(const char *a1, off_t a2, unint64_t a3, uint64_t a4)
{
  char v7;
  int v8;
  int v9;
  uint64_t FileSegmentSHA1DigestFD;
  int *v12;
  uint64_t v13;
  uint64_t v14;

  v7 = (char)a1;
  v8 = open(a1, 0);
  if (v8 < 0)
  {
    v12 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1Digest", 1025, 3, *v12, "%s", v13, v14, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v9 = v8;
    FileSegmentSHA1DigestFD = getFileSegmentSHA1DigestFD(v8, a2, a3, a4);
    close(v9);
    return FileSegmentSHA1DigestFD;
  }
}

uint64_t getFileSegmentSHA1DigestFD(int a1, off_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v24;
  CC_SHA1_CTX c;

  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 16) = 0;
  v24 = 1;
  if (fcntl(a1, 48))
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1044, 3, "Warning: couldn't set F_NOCACHE\n", v8, v9, v10, 1);
  memset(&c, 0, sizeof(c));
  v11 = valloc(0x100000uLL);
  if (!v11)
  {
    v18 = *__error();
    v21 = "malloc";
    v22 = 1049;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", v22, 3, v18, v21, v19, v20, v24);
LABEL_16:
    v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  CC_SHA1_Init(&c);
  if (a3)
  {
    while (1)
    {
      if (a3 >= 0x100000)
        v12 = 0x100000;
      else
        v12 = a3;
      v13 = pread(a1, v11, v12, a2);
      if ((v13 & 0x8000000000000000) != 0)
      {
        v18 = *__error();
        v21 = "read";
        v22 = 1059;
        goto LABEL_15;
      }
      v16 = v13;
      if (!v13)
        goto LABEL_12;
      if (v13 > v12)
        break;
      CC_SHA1_Update(&c, v11, v13);
      a2 += v16;
      a3 -= v16;
      if (!a3)
        goto LABEL_12;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"getFileSegmentSHA1DigestFD", 1062, 3, 0, "error: read more bytes than requested: %zd (requested %zu)", v14, v15, v13);
    goto LABEL_16;
  }
LABEL_12:
  CC_SHA1_Final((unsigned __int8 *)a4, &c);
  v17 = 0;
LABEL_17:
  free(v11);
  return v17;
}

uint64_t enumerateTree(_QWORD *a1, char *__s)
{
  size_t v3;
  size_t v5;
  uint64_t v6;
  char v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v3 = strlen(__s);
  if (v3 - 1024 < 0xFFFFFFFFFFFFFBFFLL)
    return 0xFFFFFFFFLL;
  v5 = v3;
  bzero(v7, 0x400uLL);
  __memcpy_chk();
  do
  {
    v6 = v5;
    if (!v5)
      break;
    --v5;
  }
  while (v7[v6 - 1] == 47);
  v7[v6] = 0;
  return enumerateTree_rec(a1, v7, v6);
}

uint64_t removeFile(const char *a1)
{
  stat v3;

  memset(&v3, 0, sizeof(v3));
  if (lstat(a1, &v3))
    return 0;
  if ((v3.st_mode & 0xF000) == 0x4000)
    return 0xFFFFFFFFLL;
  if ((v3.st_flags & 0x20002) != 0)
    lchflags(a1, v3.st_flags & 0xFFFDFFFD);
  return unlink(a1);
}

uint64_t enumerateTree_rec(_QWORD *a1, const char *a2, uint64_t a3)
{
  const char *v6;
  DIR *v7;
  uint64_t (*v8)(_QWORD, const char *);
  uint64_t v9;
  char *v10;
  char *v11;
  size_t d_namlen;
  unint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int d_type;
  int (*v19)(_QWORD, const char *);
  _BOOL4 v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int (*v29)(_QWORD, const char *);
  char v30;
  stat v31;
  dirent *v32;
  dirent v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (a3)
    v6 = a2;
  else
    v6 = "/";
  v7 = opendir(v6);
  if (v7)
  {
    memset(&v33, 0, 512);
    v32 = 0;
    v8 = (uint64_t (*)(_QWORD, const char *))a1[1];
    if (v8 && (v8(*a1, a2) & 0x80000000) != 0)
    {
LABEL_35:
      v28 = 0;
    }
    else
    {
      v9 = a3 + 1;
      v10 = (char *)&a2[a3];
      v11 = (char *)&a2[a3 + 1];
      while (1)
      {
        if (readdir_r(v7, &v33, &v32))
        {
          v25 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1143, 3, *v25, "readdir_r", v26, v27, v30);
          goto LABEL_35;
        }
        if (!v32)
          break;
        d_namlen = v33.d_namlen;
        if ((v33.d_namlen != 1 || v33.d_name[0] != 46)
          && (v33.d_namlen != 2 || v33.d_name[0] != 46 || v33.d_name[1] != 46))
        {
          v13 = v9 + v33.d_namlen;
          if (v13 > 0x3FF)
            goto LABEL_35;
          *v10 = 47;
          memcpy(v11, v33.d_name, d_namlen);
          a2[v13] = 0;
          memset(&v31, 0, sizeof(v31));
          v14 = lstat(a2, &v31);
          if (v14)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1170, 3, "lstat after readdir failed (errno=%d): %s", v15, v16, v17, v14);
          }
          else if ((v31.st_flags & 0x40000000) != 0)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1175, 3, "skip dataless: %s", v15, v16, v17, (char)a2);
          }
          else
          {
            d_type = v33.d_type;
            if (!v33.d_type)
            {
              if ((v31.st_mode & 0xF000) == 0x4000)
              {
                d_type = 4;
                v33.d_type = 4;
              }
              else
              {
                d_type = 0;
              }
            }
            v19 = (int (*)(_QWORD, const char *))a1[3];
            if (v19)
            {
              v20 = v19(*a1, a2) >= 0;
              d_type = v33.d_type;
            }
            else
            {
              v20 = 1;
            }
            if (d_type == 4 && (int)enumerateTree_rec(a1, a2, v13) < 0)
              v20 = 0;
            *v10 = 0;
            if (!v20)
              goto LABEL_35;
          }
        }
      }
      v28 = 1;
    }
    closedir(v7);
    v29 = (int (*)(_QWORD, const char *))a1[2];
    if (v29 && v29(*a1, a2) < 0)
      v28 = 0;
    if (v28)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
    v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"enumerateTree_rec", 1126, 3, *v21, "%s", v22, v23, (char)a2);
    return 0xFFFFFFFFLL;
  }
}

uint64_t removeTree(char *__s)
{
  _QWORD v2[4];

  v2[0] = 0;
  v2[1] = 0;
  v2[2] = removeLeaveDirProc;
  v2[3] = removeEntryProc;
  return enumerateTree(v2, __s);
}

uint64_t removeEntryProc(int a1, char *a2)
{
  __int16 v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  stat v8;

  memset(&v8, 0, sizeof(v8));
  if (lstat(a2, &v8))
  {
    v3 = 1247;
LABEL_3:
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeEntryProc", v3, 3, *v4, "%s", v5, v6, (char)a2);
    return 0xFFFFFFFFLL;
  }
  if ((v8.st_mode & 0xF000) == 0x4000)
    return 0;
  result = unlink(a2);
  if ((_DWORD)result)
  {
    v3 = 1250;
    goto LABEL_3;
  }
  return result;
}

uint64_t removeLeaveDirProc(int a1, char *a2)
{
  char v2;
  uint64_t result;
  int *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (char)a2;
  result = rmdir(a2);
  if ((_DWORD)result)
  {
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/Utils.c", (uint64_t)"removeLeaveDirProc", 1258, 3, *v4, "%s", v5, v6, v2);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t statIsDataless(unsigned int a1)
{
  return (a1 >> 30) & 1;
}

uint64_t ParallelArchiveExtractSubtree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  FILE *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t result;
  FILE **v25;
  char v26;
  char v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  size_t (*v31)(uint64_t, const void *, uint64_t, uint64_t);
  __int128 v32;
  __int128 v33;
  size_t (*v34)(size_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char);
  int *v35;
  int v36;
  uint64_t v37;
  char v38[1024];
  size_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v26);
  bzero(&v36, 0x430uLL);
  v10 = *(const char **)(a2 + 16);
  strncpy(v38, v10, 0x400uLL);
  v39 = strlen(v10);
  v37 = a1;
  v18 = *(_DWORD *)a2;
  v36 = *(_DWORD *)a2;
  v19 = *(_DWORD *)(a2 + 8) & 1;
  v40 = v19;
  if (v39)
  {
    if (v18 >= 1)
    {
      v20 = (FILE *)*MEMORY[0x24BDAC8D8];
      if (v19)
        fprintf(v20, "Extracting all entries not in subtree: %s\n");
      else
        fprintf(v20, "Extracting subtree: %s\n");
    }
    v32 = 0u;
    v33 = 0u;
    v28 = *(_QWORD *)a2;
    v21 = *(_QWORD *)(a2 + 40);
    v29 = *(_OWORD *)(a2 + 24);
    v35 = &v36;
    v30 = v21;
    v31 = extractSubtreeBegin;
    *((_QWORD *)&v32 + 1) = extractSubtreeData;
    *(_QWORD *)&v33 = extractSubtreeData;
    v34 = extractSubtreeData;
    if ((ParallelArchiveRead((uint64_t)&v28, v11, v12, v13, v14, v15, v16, v17) & 0x80000000) == 0)
    {
      result = leaveThreadErrorContext(0, 0, 0);
      if ((result & 0x80000000) == 0)
      {
        if (*(int *)a2 >= 1)
        {
          v25 = (FILE **)MEMORY[0x24BDAC8D8];
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu entries in input archive\n", v41);
          fprintf(*v25, "%12llu entries in subtree\n", v42);
        }
        return 0;
      }
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"ParallelArchiveExtractSubtree", 116, 69, 0, "reading archive", v22, v23, v27);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"ParallelArchiveExtractSubtree", 95, 69, 0, "Invalid path length for subtree: %s\n", v16, v17, (char)v10);
  }
  result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0)
    return 0xFFFFFFFFLL;
  return result;
}

size_t extractSubtreeBegin(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  size_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  size_t v16;
  int v17;
  BOOL v18;
  char v19;
  _DWORD __dst[548];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a1 + 1052) = 0;
  ++*(_QWORD *)(a1 + 1056);
  result = (size_t)memcpy(__dst, a2, sizeof(__dst));
  if (__dst[1] == 77)
  {
    *(_DWORD *)(a1 + 1052) = 1;
  }
  else
  {
    if ((__dst[0] & 0x8000) == 0)
      return result;
    v15 = *(_QWORD *)(a1 + 1040);
    result = strlen((const char *)&__dst[36]);
    v16 = result;
    if (result < v15 || (result = memcmp(&__dst[36], (const void *)(a1 + 16), v15), (_DWORD)result))
    {
      v17 = 0;
    }
    else
    {
      if (*((_BYTE *)&__dst[36] + v15))
        v18 = *((_BYTE *)&__dst[36] + v15) == 47;
      else
        v18 = 1;
      v17 = v18;
    }
    *(_DWORD *)(a1 + 1052) = v17;
    if (*(_DWORD *)(a1 + 1048))
    {
      *(_DWORD *)(a1 + 1052) = v17 ^ 1;
      if ((v17 & 1) != 0)
        return result;
    }
    else
    {
      if (!v17)
        return result;
      if (v16 == v15)
        LOBYTE(__dst[36]) = 0;
      else
        strncpy((char *)&__dst[36], (const char *)a2 + v15 + 145, 0x400uLL);
    }
  }
  ++*(_QWORD *)(a1 + 1064);
  if (*(int *)a1 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", (const char *)&__dst[36]);
  result = ParallelArchiveWriteEntryHeader(*(_QWORD *)(a1 + 8), (uint64_t)__dst, a3, a4, v9, v10, v11, v12);
  if ((result & 0x80000000) != 0)
  {
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"extractSubtreeBegin", 70, 69, 0, "writing entry header", v13, v14, v19);
    *(_DWORD *)(a1 + 1052) = 0;
  }
  return result;
}

size_t extractSubtreeData(size_t result, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v10;

  if (*(_DWORD *)(result + 1052))
  {
    result = ParallelArchiveWriteEntryData(*(_QWORD *)(result + 8), a2, a3, a4, a5, a6, a7, a8);
    if ((result & 0x80000000) != 0)
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractSubtree.c", (uint64_t)"extractSubtreeData", 77, 69, 0, "writing entry data", v9, v10, a9);
  }
  return result;
}

uint64_t io_hint_static_content(unsigned int **a1)
{
  int FD;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  char v8;

  FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    v6 = "file not open";
    v7 = 63;
  }
  else
  {
    v8 = 1;
    if (fcntl(FD, 68) != -1)
      return 0;
    v6 = "static content hint failed";
    v7 = 64;
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_hint_static_content", v7, 137, v6, v2, v3, v4, v8);
  return 0xFFFFFFFFLL;
}

uint64_t io_preallocate(unsigned int **a1, unint64_t a2)
{
  int FD;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;
  char v22;
  _QWORD v23[3];
  uint64_t v24;
  stat v25;

  getRealTime();
  FD = aaFileStreamGetFD(a1);
  memset(&v25, 0, sizeof(v25));
  if (FD < 0)
  {
    v15 = "file not open";
    v16 = 84;
LABEL_12:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", v16, 137, v15, v5, v6, v7, v21);
    LOBYTE(v10) = 0;
    goto LABEL_13;
  }
  v8 = FD;
  if (fstat(FD, &v25) || v25.st_size)
  {
    v15 = "file not empty";
    v16 = 85;
    goto LABEL_12;
  }
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 88, 137, "preallocating %llu B", v5, v6, v7, a2);
  if (!a2)
  {
    v14 = 0;
    LOBYTE(v10) = 0;
    goto LABEL_14;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    v23[0] = 0x300000002;
    v23[1] = 0;
    v23[2] = a2 - v10;
    v24 = 0;
    if (fcntl(v8, 42, v23) == -1 || v24 <= 0)
      break;
    v10 += v24;
    ++v9;
    if (v10 >= a2)
    {
      v14 = 0;
      goto LABEL_14;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 99, 137, "preallocation failed", v11, v12, v13, v22);
LABEL_13:
  v14 = 0xFFFFFFFFLL;
LABEL_14:
  getRealTime();
  pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_preallocate", 110, 137, "preallocation %llu/%llu B took %0.2f seconds (# of calls=%i)", v17, v18, v19, v10);
  return v14;
}

uint64_t io_set_nocache(unsigned int **a1)
{
  int FD;
  uint64_t v2;
  uint64_t v3;
  const char *v5;
  __int16 v6;
  int v7;
  char v8;

  FD = aaFileStreamGetFD(a1);
  if (FD < 0)
  {
    v5 = "aaFileStreamGetFD";
    v6 = 126;
    v7 = 0;
  }
  else
  {
    v8 = 1;
    if (fcntl(FD, 48) != -1)
      return 0;
    v7 = *__error();
    v5 = "fcntl";
    v6 = 127;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"io_set_nocache", v6, 137, v7, v5, v2, v3, v8);
  return 0xFFFFFFFFLL;
}

uint64_t **aaSegmentStreamOpen(_QWORD *a1, _QWORD *a2)
{
  uint64_t **v3;
  uint64_t **v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  __int16 v38;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  char v44;

  v3 = (uint64_t **)SegmentStreamCreate(a1, (uint64_t)a2);
  v4 = v3;
  if (v3)
  {
    v5 = *v3;
    v12 = pc_array_indirect_sort(a2[267], compare_extents_by_position);
    if (v12)
    {
      v13 = 0;
      v14 = 0;
      v15 = a2[269];
      do
      {
        if (v13 >= v15)
        {
          v17 = 0;
          v16 = a2 + 265;
        }
        else
        {
          v16 = (unint64_t *)v12[v13];
          v17 = v16[1];
        }
        v18 = *v16;
        v19 = *v16 >= v14;
        v20 = *v16 - v14;
        if (v20 != 0 && v19)
        {
          v40 = v5[397];
          v41 = v20;
          v42 = v14;
          v43 = 0;
          v44 = 0;
          v5[397] = v40 + v20;
          v21 = pc_array_append(v5[395], &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v21;
          if (!v21)
          {
            v37 = "segment_add";
            v38 = 476;
            goto LABEL_28;
          }
          v15 = a2[269];
        }
        v14 = v18 + v17;
        ++v13;
      }
      while (v13 <= v15);
      v22 = v5[397];
      a2[258] = v22;
      v23 = a2[270];
      if (v23)
      {
        v24 = 0;
        while (1)
        {
          v25 = a2[267];
          v26 = a2[268] + 440 * v24;
          *(_QWORD *)(v26 + 32) = 0;
          v27 = (_QWORD *)(v26 + 32);
          v27[1] = v5[397];
          if (v27[49])
            break;
LABEL_19:
          if (++v24 >= v23)
          {
            v22 = v5[397];
            goto LABEL_21;
          }
        }
        v28 = 0;
        v29 = (_QWORD *)v5[395];
        v30 = (uint64_t *)(v25 + 16 * v27[48] + 8);
        while (1)
        {
          v32 = *(v30 - 1);
          v31 = *v30;
          v40 = v5[397];
          v41 = v31;
          v42 = v32;
          v43 = 0;
          v44 = 0;
          v5[397] = v40 + v31;
          v29 = pc_array_append((uint64_t)v29, &v40, v6, v7, v8, v9, v10, v11);
          v5[395] = (uint64_t)v29;
          if (!v29)
            break;
          v33 = *v30;
          v30 += 2;
          *v27 += v33;
          if ((unint64_t)++v28 >= v27[49])
          {
            v23 = a2[270];
            goto LABEL_19;
          }
        }
        v37 = "segment_add";
        v38 = 500;
      }
      else
      {
LABEL_21:
        v5[396] = *(_QWORD *)(v5[395] - 64);
        if (v22 == a2[265])
        {
          free(v12);
          return v4;
        }
        v37 = "bad image";
        v38 = 507;
      }
    }
    else
    {
      v37 = "pc_array_indirect_sort";
      v38 = 465;
    }
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", v38, 137, 0, v37, v10, v11, v40);
  }
  else
  {
    v34 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaSegmentStreamOpen", 457, 137, *v34, "aaSegmentStreamOpen", v35, v36, v40);
    v12 = 0;
    v5 = 0;
  }
  free(v12);
  free(v4);
  SegmentStreamClose((uint64_t)v5);
  return 0;
}

_QWORD *SegmentStreamCreate(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  int v9;
  const char *v10;
  __int16 v11;
  char v13;

  v4 = calloc(1uLL, 0x68uLL);
  v5 = calloc(1uLL, 0xC78uLL);
  v8 = v5;
  if (!v4 || !v5)
  {
    v9 = *__error();
    v10 = "malloc";
    v11 = 416;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamCreate", v11, 137, v9, v10, v6, v7, v13);
    free(v4);
    SegmentStreamClose((uint64_t)v8);
    return 0;
  }
  if (!a1[4] || !a1[5])
  {
    v10 = "stream not compatible";
    v11 = 417;
    v9 = 0;
    goto LABEL_9;
  }
  *v5 = a1;
  v5[1] = a2;
  v5[395] = pc_array_init(29);
  AACustomByteStreamSetData((AAByteStream)v4, v8);
  AACustomByteStreamSetPReadProc((AAByteStream)v4, (AAByteStreamPReadProc)SegmentStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v4, (AAByteStreamPWriteProc)SegmentStreamPWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v4, (AAByteStreamCancelProc)SegmentStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v4, (AAByteStreamCloseProc)SegmentStreamClose);
  if (a1[11])
    v4[11] = SegmentStreamSimulate;
  return v4;
}

uint64_t SegmentStreamClose(uint64_t a1)
{
  uint64_t i;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 3152))
    {
      for (i = 16; i != 3088; i += 24)
        free(*(void **)(a1 + i));
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 3088));
    }
    pc_array_free(*(_QWORD *)(a1 + 3160));
    free((void *)a1);
  }
  return 0;
}

uint64_t *aaForkInputStreamOpen(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  _QWORD *v10;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  int v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  char *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  _QWORD *v52;
  uint64_t v53;
  unint64_t v54;
  _QWORD *v55;
  const char *v56;
  __int16 v57;
  char v58;
  uint64_t *v59;
  int v60;
  _QWORD *v61;
  char v62;
  char v63;
  char v64;
  uint64_t v65;
  uint64_t __src;
  __int128 v67;
  int v68;
  char v69;

  if ((*(_BYTE *)(a2 + 2128) & 8) == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 538, 137, 0, "no chunk info", a7, a8, v58);
    v8 = 0;
LABEL_13:
    v13 = 0;
    goto LABEL_16;
  }
  v10 = (_QWORD *)a2;
  v12 = SegmentStreamCreate(a1, a2);
  v8 = v12;
  if (!v12)
  {
    v26 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", 542, 137, *v26, "SegmentStreamCreate", v27, v28, v58);
    goto LABEL_13;
  }
  v13 = *v12;
  if (a1[11])
    *(_DWORD *)(v13 + 3184) = 1;
  v14 = 0;
  *(_QWORD *)(v13 + 3152) = 1;
  do
  {
    v15 = malloc(0x10000uLL);
    v16 = v13 + v14;
    *(_QWORD *)(v16 + 16) = v15;
    *(_QWORD *)(v16 + 24) = -1;
    if (!v15)
    {
      v25 = *__error();
      v23 = "malloc";
      v24 = 554;
      goto LABEL_15;
    }
    v14 += 24;
  }
  while (v14 != 3072);
  if (pthread_mutex_init((pthread_mutex_t *)(v13 + 3088), 0))
  {
    v23 = "MutexInit";
    v24 = 556;
    goto LABEL_11;
  }
  v59 = v8;
  v63 = 0;
  v61 = v10;
  v62 = 1;
  v60 = a3;
  while (!v10[270])
  {
LABEL_36:
    v8 = v59;
    if ((v62 & 1) == 0)
    {
      *(_QWORD *)(v13 + 3168) = *(_QWORD *)(*(_QWORD *)(v13 + 3160) - 64);
      v10[260] = *(_QWORD *)(v13 + 3176);
      return v8;
    }
    v53 = *(_QWORD *)(v13 + 3176);
    v10[257] = v53;
    v54 = v10[258];
    if (v54)
    {
      __src = v53;
      v67 = v54;
      v68 = 0;
      v69 = 0;
      *(_QWORD *)(v13 + 3176) = v54 + v53;
      v55 = pc_array_append(*(_QWORD *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(_QWORD *)(v13 + 3160) = v55;
      if (!v55)
      {
        v23 = "segment_add";
        v24 = 607;
LABEL_11:
        v25 = 0;
LABEL_15:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v24, 137, v25, v23, v21, v22, v58);
        goto LABEL_16;
      }
      v53 = *(_QWORD *)(v13 + 3176);
    }
    v62 = 0;
    v10[259] = v53;
    v63 = 1;
  }
  v30 = 0;
  while (1)
  {
    v65 = v10[268];
    if (a3)
      LOBYTE(v31) = 1;
    else
      v31 = *(_QWORD *)(v10[268] + 440 * v30 + 408);
    v64 = v31;
    if (!(v63 & 1 | ((v31 & 1) == 0)))
      break;
LABEL_33:
    if (!(v62 & 1 | ((v64 & 2) == 0)))
    {
      v49 = *(_QWORD *)(v13 + 3176);
      v50 = v65 + 440 * v30;
      *(_QWORD *)(v50 + 48) = v49;
      v51 = *(_OWORD *)(v50 + 32);
      __src = v49;
      v67 = v51;
      v68 = 0;
      v69 = 0;
      *(_QWORD *)(v13 + 3176) = v51 + v49;
      v52 = pc_array_append(*(_QWORD *)(v13 + 3160), &__src, v17, v18, v19, v20, v21, v22);
      *(_QWORD *)(v13 + 3160) = v52;
      if (!v52)
      {
        v56 = "segment_add";
        v57 = 597;
        goto LABEL_42;
      }
    }
LABEL_35:
    ++v30;
    v10 = v61;
    a3 = v60;
    if (v30 >= v61[270])
      goto LABEL_36;
  }
  v32 = v65 + 440 * v30;
  if (!*(_QWORD *)(v32 + 384))
  {
    v56 = "no chunks found";
    v57 = 572;
    goto LABEL_42;
  }
  v33 = v65 + 440 * v30;
  v35 = *(_QWORD *)(v33 + 56);
  v34 = (unint64_t *)(v33 + 56);
  *(v34 - 1) = *(_QWORD *)(v13 + 3176);
  if (!v35)
    goto LABEL_35;
  v36 = 0;
  v37 = 0;
  v38 = (_QWORD *)(v32 + 384);
  v39 = v65 + 440 * v30;
  v40 = *(_QWORD *)(v39 + 392);
  v41 = (_QWORD *)(v39 + 40);
  v42 = (char *)(v39 + 432);
  v43 = *(_QWORD **)(v13 + 3160);
  while (1)
  {
    v44 = *v38 + v36;
    v45 = v40 >= 0x10000 ? 0x10000 : v40;
    v46 = *(_QWORD *)v44 + *v41;
    v47 = *(_DWORD *)(v44 + 8);
    v48 = *v42;
    __src = *(_QWORD *)(v13 + 3176);
    *(_QWORD *)&v67 = v45;
    *((_QWORD *)&v67 + 1) = v46;
    v68 = v47;
    v69 = v48;
    *(_QWORD *)(v13 + 3176) = __src + v45;
    v43 = pc_array_append((uint64_t)v43, &__src, v17, v18, v19, v20, v21, v22);
    *(_QWORD *)(v13 + 3160) = v43;
    if (!v43)
      break;
    v40 -= v45;
    ++v37;
    v36 += 12;
    if (v37 >= *v34)
      goto LABEL_33;
  }
  v56 = "segment_add";
  v57 = 584;
LABEL_42:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaForkInputStreamOpen", v57, 137, 0, v56, v21, v22, v58);
  v8 = v59;
LABEL_16:
  free(v8);
  SegmentStreamClose(v13);
  return 0;
}

AAByteStream_impl *aaIntervalInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AAByteStream_impl *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  __int16 v12;
  int v13;
  char v15;

  v6 = (AAByteStream_impl *)calloc(1uLL, 0x68uLL);
  v7 = calloc(1uLL, 0x20uLL);
  v10 = v7;
  if (v6 && v7)
  {
    if (a3 >= a2)
    {
      *v7 = a1;
      v7[1] = a2;
      v7[2] = a3 - a2;
      v7[3] = 0;
      AACustomByteStreamSetData(v6, v7);
      AACustomByteStreamSetReadProc(v6, (AAByteStreamReadProc)IntervalStreamRead);
      AACustomByteStreamSetPReadProc(v6, (AAByteStreamPReadProc)IntervalStreamPRead);
      AACustomByteStreamSetSeekProc(v6, (AAByteStreamSeekProc)IntervalStreamSeek);
      AACustomByteStreamSetCancelProc(v6, (AAByteStreamCancelProc)IntervalStreamCancel);
      AACustomByteStreamSetCloseProc(v6, (AAByteStreamCloseProc)IntervalStreamClose);
      return v6;
    }
    v11 = "bad interval";
    v12 = 703;
    v13 = 0;
  }
  else
  {
    v13 = *__error();
    v11 = "malloc";
    v12 = 702;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"aaIntervalInputStreamOpen", v12, 137, v13, v11, v8, v9, v15);
  free(v6);
  free(v10);
  return 0;
}

ssize_t IntervalStreamRead(uint64_t a1, void *a2, size_t a3)
{
  return IntervalStreamPRead(a1, a2, a3, *(_QWORD *)(a1 + 24));
}

ssize_t IntervalStreamPRead(uint64_t a1, void *a2, size_t a3, int64_t a4)
{
  int64_t v5;
  ssize_t result;

  if (!a3)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 == a4)
    return 0;
  if (v5 < a4)
    return -1;
  if ((uint64_t)(a4 + a3) > v5)
    a3 = v5 - a4;
  result = AAByteStreamPRead(*(AAByteStream *)a1, a2, a3, *(_QWORD *)(a1 + 8) + a4);
  if (result < 0)
    return -1;
  *(_QWORD *)(a1 + 24) += result;
  return result;
}

uint64_t IntervalStreamSeek(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v3;

  if (a3)
  {
    v3 = (_QWORD *)(a1 + 24);
    if (a3 != 1)
    {
      if (a3 != 2)
        return -1;
      v3 = (_QWORD *)(a1 + 16);
    }
    a2 += *v3;
  }
  if ((a2 & 0x8000000000000000) == 0 && a2 <= *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 24) = a2;
    return a2;
  }
  return -1;
}

void IntervalStreamCancel(AAByteStream *a1)
{
  AAByteStreamCancel(*a1);
}

uint64_t IntervalStreamClose(void *a1)
{
  free(a1);
  return 0;
}

uint64_t SegmentStreamPRead(_QWORD **a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v5;
  unint64_t v7;
  pthread_mutex_t *v8;
  _QWORD **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD **v39;
  uint64_t *v40;
  uint8_t *v41;
  uint64_t v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint8_t *v49;
  uint64_t v50;
  BOOL v51;
  size_t v52;
  uint8_t *v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  size_t v58;
  uint64_t v59;
  const char *v60;
  __int16 v61;
  int v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  char v68;
  uint64_t v69;
  uint64_t *v70;
  _QWORD *v71;
  void **v72;
  unint64_t *v73;
  uint8_t *src_buffer;
  pthread_mutex_t *v75;
  size_t __n;
  size_t __na;
  unint64_t v80;
  uint64_t v81;
  _QWORD *v82;

  if (!a3)
    return 0;
  v5 = a3;
  v7 = 0;
  v8 = (pthread_mutex_t *)(a1 + 386);
  v9 = a1 + 2;
  v73 = (unint64_t *)(a1 + 4);
  v75 = (pthread_mutex_t *)(a1 + 386);
  while (1)
  {
    v10 = segment_find(a1, a4);
    if (!v10)
    {
      v63 = "no segment found";
      v64 = 321;
      goto LABEL_74;
    }
    v13 = v10;
    v14 = a4 - *(_QWORD *)v10;
    if (v5 - v7 >= *(_QWORD *)(v10 + 8) - v14)
      v15 = *(_QWORD *)(v10 + 8) - v14;
    else
      v15 = v5 - v7;
    if (!*(_DWORD *)(v10 + 24))
    {
      v22 = (uint64_t)*a1;
      if ((*a1)[4])
      {
        if (!v15)
          goto LABEL_41;
        v23 = 0;
        v24 = a2 + v7;
        v25 = v15;
        v26 = *(_QWORD *)(v10 + 16) + a4 - *(_QWORD *)v10;
        __n = v25;
        while (1)
        {
          v27 = (*(uint64_t (**)(_QWORD, uint64_t, size_t, unint64_t))(v22 + 32))(*(_QWORD *)v22, v24, v25, v26);
          if (v27 < 0)
            break;
          if (v27)
          {
            v24 += v27;
            v23 += v27;
            v26 += v27;
            v25 -= v27;
            if (v25)
              continue;
          }
          goto LABEL_39;
        }
        v23 = v27;
      }
      else
      {
        __n = v15;
        v23 = -1;
      }
LABEL_39:
      v15 = __n;
      v51 = __n == v23;
      v8 = v75;
      v5 = a3;
      if (!v51)
      {
        v63 = "aaSegmentStreamProcess";
        v64 = 337;
        goto LABEL_74;
      }
LABEL_41:
      if (*((_DWORD *)a1 + 796) && v15 != aaByteStreamSimulate(*a1))
      {
        v63 = "aaByteStreamSimulate";
        v64 = 340;
        goto LABEL_74;
      }
      goto LABEL_57;
    }
    v81 = *(unsigned __int8 *)(v10 + 28);
    v82 = a1[1];
    if (pthread_mutex_lock(v8))
    {
      v60 = "MutexLock";
      v61 = 169;
LABEL_62:
      v62 = 0;
      goto LABEL_68;
    }
    v18 = *(_QWORD *)(v13 + 16);
    v19 = ((unint64_t)(0x317E428CA9 * v18) >> 32) & 0x7F;
    v20 = &v9[3 * v19];
    if (v20[1] != v18)
      break;
    v21 = (uint64_t)a1[394] + 1;
    a1[394] = (_QWORD *)v21;
    v9[3 * v19 + 2] = (_QWORD *)v21;
LABEL_26:
    memcpy((void *)(a2 + v7), (const void *)(*v20 + v14), v15);
    v41 = 0;
LABEL_53:
    if (pthread_mutex_unlock(v8))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", 208, 137, 0, "MutexUnlock", v56, v57, v68);
      goto LABEL_73;
    }
    free(v41);
    if (*((_DWORD *)a1 + 796))
    {
      v58 = v15;
      v59 = *(unsigned int *)(v13 + 24);
      v51 = aaByteStreamSimulate(*a1) == v59;
      v15 = v58;
      if (!v51)
      {
        v63 = "aaByteStreamSimulate";
        v64 = 333;
        goto LABEL_74;
      }
    }
LABEL_57:
    a4 += v15;
    v7 += v15;
    if (v7 >= v5)
      return v7;
  }
  v28 = 0;
  v29 = 0;
  v30 = v73;
  while (*(v30 - 1) != v18)
  {
    v31 = *v30;
    v30 += 3;
    if (v31 < (unint64_t)v9[3 * v29 + 2])
      v29 = v28;
    if (++v28 == 128)
      goto LABEL_25;
  }
  v29 = v28;
LABEL_25:
  v32 = (_QWORD *)v20[2];
  v33 = *(_OWORD *)v20;
  v34 = &v9[3 * v29];
  v35 = v34[2];
  *(_OWORD *)v20 = *(_OWORD *)v34;
  v20[2] = v35;
  *(_OWORD *)v34 = v33;
  v34[2] = v32;
  v36 = v20[1];
  v37 = *(_QWORD *)(v13 + 16);
  v38 = (uint64_t)a1[394] + 1;
  a1[394] = (_QWORD *)v38;
  v39 = &v9[3 * v19];
  v39[2] = (_QWORD *)v38;
  v40 = (uint64_t *)(v39 + 2);
  if (v36 == v37)
    goto LABEL_26;
  v70 = v40;
  v71 = v20 + 1;
  v72 = (void **)v20;
  if (pthread_mutex_unlock(v8))
  {
    v60 = "MutexUnlock";
    v61 = 175;
    goto LABEL_62;
  }
  v42 = *(unsigned int *)(v13 + 24);
  v43 = *(_QWORD *)(v13 + 8) + v42;
  if (v43 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_67:
    v62 = *__error();
    v60 = "aaMalloc";
    v61 = 179;
LABEL_68:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v61, 137, v62, v60, v16, v17, v68);
    v41 = 0;
    goto LABEL_73;
  }
  src_buffer = (uint8_t *)malloc(v43);
  if (!src_buffer)
    goto LABEL_67;
  v46 = (uint64_t)*a1;
  if ((*a1)[4])
  {
    __na = v15;
    v80 = v14;
    v69 = v42;
    v47 = 0;
    if ((_DWORD)v42)
    {
      v48 = *(_QWORD *)(v13 + 16);
      v49 = src_buffer;
      while (1)
      {
        v50 = (*(uint64_t (**)(_QWORD, uint8_t *, uint64_t, uint64_t))(v46 + 32))(*(_QWORD *)v46, v49, v42, v48);
        if (v50 < 0)
          break;
        if (v50)
        {
          v49 += v50;
          v47 += v50;
          v48 += v50;
          v42 -= v50;
          if (v42)
            continue;
        }
        goto LABEL_45;
      }
      v47 = v50;
    }
LABEL_45:
    v51 = v47 == v69;
    v8 = v75;
    v5 = a3;
    if (v51)
    {
      v52 = *(_QWORD *)(v13 + 8);
      if (*src_buffer == BYTE4(v82[v81]))
      {
        if (v52 + 1 != *(_DWORD *)(v13 + 24))
        {
          v65 = "chunk error";
          v66 = 189;
          goto LABEL_72;
        }
        v53 = src_buffer + 1;
      }
      else
      {
        v54 = *(unsigned int *)(v13 + 24);
        v53 = &src_buffer[v54];
        if (compression_decode_buffer(&src_buffer[v54], v52, src_buffer, v54, 0, (compression_algorithm)LODWORD(v82[v81])) != *(_QWORD *)(v13 + 8))
        {
          v65 = "compression_decode_buffer";
          v66 = 195;
          goto LABEL_72;
        }
      }
      memcpy((void *)(a2 + v7), &v53[v80], __na);
      if (pthread_mutex_lock(v75))
      {
        v65 = "MutexLock";
        v66 = 202;
        goto LABEL_72;
      }
      memcpy(*v72, v53, *(_QWORD *)(v13 + 8));
      *v71 = *(_QWORD *)(v13 + 16);
      v55 = (uint64_t)a1[394] + 1;
      a1[394] = (_QWORD *)v55;
      *v70 = v55;
      v15 = __na;
      v41 = src_buffer;
      goto LABEL_53;
    }
  }
  v65 = "aaByteStreamPReadExpected";
  v66 = 183;
LABEL_72:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"segment_decode_to_buffer", v66, 137, 0, v65, v44, v45, v68);
  v41 = src_buffer;
LABEL_73:
  free(v41);
  v63 = "segment_decode_to_buffer";
  v64 = 330;
LABEL_74:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPRead", v64, 137, 0, v63, v11, v12, v68);
  return -1;
}

uint64_t SegmentStreamPWrite(_QWORD *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  char v22;

  if (!a3)
    return 0;
  v7 = 0;
  while (1)
  {
    v8 = segment_find(a1, a4);
    if (!v8)
    {
      v19 = "no segment found";
      v20 = 363;
      goto LABEL_23;
    }
    v11 = a4 - *(_QWORD *)v8;
    if (a3 - v7 >= *(_QWORD *)(v8 + 8) - v11)
      v12 = *(_QWORD *)(v8 + 8) - v11;
    else
      v12 = a3 - v7;
    if (*(_DWORD *)(v8 + 24))
    {
      v19 = "compressed content";
      v20 = 370;
      goto LABEL_23;
    }
    v13 = *a1;
    if (!*(_QWORD *)(*a1 + 40))
    {
      v14 = -1;
      goto LABEL_16;
    }
    if (v12)
      break;
LABEL_17:
    a4 += v12;
    v7 += v12;
    if (v7 >= a3)
      return v7;
  }
  v14 = 0;
  v15 = a2 + v7;
  v16 = *(_QWORD *)(v8 + 16) + v11;
  v17 = v12;
  while (1)
  {
    v18 = (*(uint64_t (**)(_QWORD, uint64_t, unint64_t, unint64_t))(v13 + 40))(*(_QWORD *)v13, v15, v17, v16);
    if (v18 < 1)
      break;
    v15 += v18;
    v14 += v18;
    v16 += v18;
    v17 -= v18;
    if (!v17)
      goto LABEL_16;
  }
  v14 = v18;
LABEL_16:
  if (v12 == v14)
    goto LABEL_17;
  v19 = "aaByteStreamPWriteExpected";
  v20 = 374;
LABEL_23:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamPWrite", v20, 137, 0, v19, v9, v10, v22);
  return -1;
}

void SegmentStreamCancel(AAByteStream *a1)
{
  AAByteStreamCancel(*a1);
}

uint64_t SegmentStreamSimulate(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  const char *v14;
  __int16 v15;
  char v17;

  v8 = 0;
  while (a4 > v8)
  {
    v9 = segment_find(a1, a5);
    if (!v9)
    {
      v14 = "no segment found";
      v15 = 276;
      goto LABEL_12;
    }
    v12 = *(_QWORD *)(v9 + 8) - (a5 - *(_QWORD *)v9);
    if (a4 - v8 < v12)
      v12 = a4 - v8;
    a5 += v12;
    v8 += v12;
    if (*(_DWORD *)(v9 + 24))
      v13 = *(unsigned int *)(v9 + 24);
    else
      v13 = v12;
    if (v13 != aaByteStreamSimulate((_QWORD *)*a1))
    {
      v14 = "aaByteStreamSimulate";
      v15 = 303;
LABEL_12:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageStreams.c", (uint64_t)"SegmentStreamSimulate", v15, 137, 0, v14, v10, v11, v17);
      return -1;
    }
  }
  return v8;
}

uint64_t segment_find(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;

  if (a1[397] <= a2)
    return 0;
  v2 = a1[396];
  v3 = a1[395];
  if (v2 < 2)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      if (*(_QWORD *)(v3 + 29 * ((v2 + v4) >> 1)) > a2)
        v2 = (v2 + v4) >> 1;
      else
        v4 = (v2 + v4) >> 1;
    }
    while (v4 + 1 < v2);
  }
  return v3 + 29 * v4;
}

uint64_t createSearchThread(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  void *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;

  v4 = *(_QWORD *)(a1 + 152);
  v5 = v4 + 2368 * a2;
  bzero((void *)v5, 0x940uLL);
  *(_QWORD *)(v5 + 16) = a1;
  *(_DWORD *)(v5 + 8) = a2;
  *(_DWORD *)(v5 + 24) = 0;
  if (pthread_mutex_init((pthread_mutex_t *)(v5 + 32), 0)
    || pthread_cond_init((pthread_cond_t *)(v4 + 2368 * a2 + 96), 0))
  {
    return 0xFFFFFFFFLL;
  }
  v7 = v4 + 2368 * a2;
  *(_QWORD *)(v7 + 2336) = 0x1000000;
  v8 = malloc(0x1000000uLL);
  *(_QWORD *)(v7 + 2360) = v8;
  if (!v8)
  {
    v9 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"createSearchThread", 142, 23, *v9, "malloc", v10, v11, v12);
    return 0xFFFFFFFFLL;
  }
  if (createThread((pthread_t *)v5, (uint64_t)searchThreadMain, v5, 0))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t searchThreadMain(uint64_t a1)
{
  uint64_t v2;
  int Count;
  _QWORD *v4;
  _QWORD *v5;
  CFIndex i;
  const __CFString *ValueAtIndex;
  uint64_t v8;
  uint64_t v9;
  const char *CStringPtr;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  size_t v14;
  char *v15;
  BOOL v16;
  char *v17;
  pthread_mutex_t *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  pthread_cond_t *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  int v31;
  uint64_t v32;
  _BYTE *v33;
  uint64_t j;
  uint64_t v35;
  char *v36;
  unint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  unint64_t v44;
  uint64_t v45;
  void (*v46)(_QWORD, _QWORD *);
  char v47;
  pthread_cond_t *v48;
  pthread_mutex_t *v49;
  pthread_cond_t *v50;
  pthread_mutex_t *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD v55[6];

  v2 = *(_QWORD *)(a1 + 16);
  v54 = *(_QWORD *)(*(_QWORD *)v2 + 16);
  Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)v2 + 64));
  v4 = calloc(Count, 8uLL);
  v5 = calloc(Count, 8uLL);
  v52 = Count;
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(*(_QWORD *)v2 + 64), i);
      if (ValueAtIndex)
      {
        CStringPtr = CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
        if (CStringPtr)
        {
          v13 = CStringPtr;
          v14 = strlen(CStringPtr);
          v4[i] = v14;
          v15 = strdup(v13);
          v5[i] = v15;
          if (*(_DWORD *)(*(_QWORD *)v2 + 24))
            v16 = v14 == 0;
          else
            v16 = 1;
          if (!v16)
          {
            v17 = v15;
            do
            {
              *v17 = __tolower(*v17);
              ++v17;
              --v14;
            }
            while (v14);
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"searchThreadMain", 65, 23, 0, "CFStringGetCStringPtr returned 0", v11, v12, v47);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"searchThreadMain", 63, 23, 0, "CFArrayGetValueAtIndex(%d) returned 0", v8, v9, i);
      }
    }
  }
  v18 = (pthread_mutex_t *)(v2 + 32);
  v19 = *(_DWORD *)(a1 + 8);
  if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 32)))
  {
LABEL_16:
    v23 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v24 = 117;
  }
  else
  {
    v26 = (pthread_cond_t *)(v2 + 96);
    v50 = (pthread_cond_t *)(a1 + 96);
    v51 = (pthread_mutex_t *)(a1 + 32);
    v27 = a1 + 288;
    v53 = a1;
    while (1)
    {
      v28 = *(unsigned int *)(v2 + 16);
      v29 = *(_DWORD *)(v2 + 20);
      v30 = v28;
      if (v28 < v29)
      {
        *(_DWORD *)(*(_QWORD *)(v2 + 24) + 4 * v28) = v19;
        v30 = *(_DWORD *)(v2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v30 + 1;
      if (!v30)
      {
        if (pthread_cond_broadcast(v26))
          break;
      }
      if (pthread_mutex_unlock(v18))
      {
        v23 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v24 = 124;
        goto LABEL_17;
      }
      if (v28 >= v29)
      {
        v23 = "SharedArrayPush: stack is full\n";
        v24 = 125;
        goto LABEL_17;
      }
      if (pthread_mutex_lock(v51))
        goto LABEL_18;
      while (1)
      {
        v31 = *(_DWORD *)(v53 + 24);
        if (v31 > 0)
          break;
        if (pthread_cond_wait(v50, v51))
          goto LABEL_18;
      }
      *(_DWORD *)(v53 + 24) = v31 - 1;
      if (pthread_mutex_unlock(v51))
        goto LABEL_18;
      v32 = *(_QWORD *)(v53 + 2344);
      if (!v32)
      {
        free(v4);
        free(v5);
        return 0;
      }
      v48 = v26;
      v49 = v18;
      if (*(_DWORD *)(*(_QWORD *)v2 + 24))
      {
        v33 = *(_BYTE **)(v53 + 2360);
        do
        {
          *v33 = __tolower(*v33);
          ++v33;
          --v32;
        }
        while (v32);
      }
      if (v52 >= 1)
      {
        for (j = 0; j != v52; ++j)
        {
          if (v4[j] >= 2uLL)
          {
            v35 = *(_QWORD *)(v53 + 2344);
            if (v35 >= 1)
            {
              v36 = *(char **)(v53 + 2360);
              v37 = (unint64_t)&v36[*(_QWORD *)(v53 + 2352)];
              v38 = (unint64_t)&v36[v35];
              v39 = v36;
              do
              {
                v40 = (char *)memmem(v39, v38 - (_QWORD)v39, (const void *)v5[j], v4[j]);
                if (!v40)
                  break;
                v41 = v40;
                v42 = &v40[-v54];
                if (&v40[-v54] < v36)
                  v42 = v36;
                v55[2] = v42;
                v43 = &v40[v4[j]];
                v44 = (unint64_t)&v43[v54];
                if ((unint64_t)&v43[v54] > v38)
                  v44 = v38;
                v55[3] = v44;
                v55[4] = v40;
                v55[5] = v43;
                v45 = (uint64_t)&v40[-v37];
                if ((unint64_t)v40 < v37)
                  v45 = -1;
                v55[0] = v27;
                v55[1] = v45;
                v46 = *(void (**)(_QWORD, _QWORD *))(*(_QWORD *)v2 + 48);
                if (v46)
                  v46(*(_QWORD *)(*(_QWORD *)v2 + 56), v55);
                v39 = v41 + 1;
              }
              while ((unint64_t)(v41 + 1) < v38);
            }
          }
        }
      }
      v19 = *(_DWORD *)(v53 + 8);
      v18 = v49;
      v26 = v48;
      if (pthread_mutex_lock(v49))
        goto LABEL_16;
    }
    v23 = "SharedArrayPush: pthread_cond_broadcast failed\n";
    v24 = 122;
  }
LABEL_17:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v24, 0, v23, v20, v21, v22, v47);
LABEL_18:
  *(_DWORD *)(v2 + 8) = 0;
  return 0;
}

uint64_t joinSearchThread(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  _opaque_pthread_t *v3;

  v2 = *(_QWORD *)(a1 + 152);
  v3 = *(_opaque_pthread_t **)(v2 + 2368 * a2);
  if (!v3)
    return 0xFFFFFFFFLL;
  joinThread(v3);
  if (pthread_mutex_destroy((pthread_mutex_t *)(v2 + 2368 * a2 + 32))
    || pthread_cond_destroy((pthread_cond_t *)(v2 + 2368 * a2 + 96)))
  {
    return 0xFFFFFFFFLL;
  }
  free(*(void **)(v2 + 2368 * a2 + 2360));
  return 0;
}

uint64_t appendPayload(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v6;
  size_t v7;
  char *v8;
  uint64_t result;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;

  v6 = *(_QWORD *)(a1 + 2344);
  v7 = v6 + a3;
  if (v6 + a3 <= *(_QWORD *)(a1 + 2336))
  {
    v8 = *(char **)(a1 + 2360);
    goto LABEL_5;
  }
  *(_QWORD *)(a1 + 2336) = v7;
  v8 = (char *)reallocf(*(void **)(a1 + 2360), v7);
  *(_QWORD *)(a1 + 2360) = v8;
  if (v8)
  {
    v6 = *(_QWORD *)(a1 + 2344);
LABEL_5:
    memcpy(&v8[v6], a2, a3);
    result = 0;
    *(_QWORD *)(a1 + 2344) += a3;
    return result;
  }
  v10 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"appendPayload", 176, 23, *v10, "reallocf", v11, v12, v13);
  *(_QWORD *)(a1 + 2336) = 0;
  return 0xFFFFFFFFLL;
}

uint64_t ParallelArchiveSearch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int i;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int16 v27;
  const char *v28;
  int v29;
  unsigned int v30;
  char *v31;
  char *v32;
  pthread_mutex_t *v33;
  char *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int j;
  uint64_t result;
  unsigned int v41;
  unsigned int v42;
  int DefaultNThreads;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t *v50;
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _QWORD v57[7];
  unsigned int v58;
  int v59;
  char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v45);
  v52 = 0u;
  *(_OWORD *)v53 = 0u;
  memset(v57, 0, sizeof(v57));
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  LODWORD(v52) = 1;
  v51 = a1;
  v58 = *(_DWORD *)(a1 + 8);
  v59 = -1;
  v60 = (char *)calloc(v58, 0x940uLL);
  if (v60)
  {
    DWORD2(v52) = 0;
    HIDWORD(v52) = v58;
    v53[0] = calloc(v58, 4uLL);
    if (!v53[0])
    {
      v12 = "SharedArrayInit: malloc failed\n";
      v13 = 55;
      goto LABEL_10;
    }
    if (pthread_mutex_init((pthread_mutex_t *)&v53[1], 0))
    {
      v12 = "SharedArrayInit: pthread_mutex_init failed\n";
      v13 = 56;
LABEL_10:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v13, 0, v12, v9, v10, v11, v45);
      goto LABEL_11;
    }
    if (pthread_cond_init((pthread_cond_t *)&v57[1], 0))
    {
      v12 = "SharedArrayInit: pthread_cond_init failed\n";
      v13 = 57;
      goto LABEL_10;
    }
    if (v58)
    {
      v42 = 0;
      while (!createSearchThread((uint64_t)&v51, v42))
      {
        if (++v42 >= v58)
          goto LABEL_49;
      }
      goto LABEL_11;
    }
LABEL_49:
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    DefaultNThreads = *(_DWORD *)(a1 + 4);
    if (!DefaultNThreads)
      DefaultNThreads = getDefaultNThreads();
    DWORD1(v45) = DefaultNThreads;
    v44 = *(_QWORD *)(a1 + 40);
    *((_QWORD *)&v45 + 1) = *(_QWORD *)(a1 + 32);
    *((_QWORD *)&v46 + 1) = v44;
    *(_QWORD *)&v47 = searchBeginProc;
    *(_QWORD *)&v48 = searchPayloadProc;
    *((_QWORD *)&v48 + 1) = 0;
    *(_QWORD *)&v49 = searchEndProc;
    v50 = &v51;
    if (!ParallelArchiveRead((uint64_t)&v45, v19, v20, v21, v22, v9, v10, v11))
      goto LABEL_12;
    v17 = "Search failed";
    v18 = 273;
    v14 = 0;
  }
  else
  {
    v14 = *__error();
    v17 = "calloc";
    v18 = 252;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Search.c", (uint64_t)"ParallelArchiveSearch", v18, 23, v14, v17, v15, v16, v45);
LABEL_11:
  LODWORD(v52) = 0;
LABEL_12:
  if (!v58)
    goto LABEL_35;
  for (i = 0; i < v58; ++i)
  {
    if (pthread_mutex_lock((pthread_mutex_t *)&v53[1]))
    {
      v27 = 91;
      v28 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_19:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v27, 0, v28, v24, v25, v26, v45);
      v30 = -1;
      goto LABEL_20;
    }
    while (1)
    {
      v29 = DWORD2(v52);
      if (DWORD2(v52))
        break;
      if (pthread_cond_wait((pthread_cond_t *)&v57[1], (pthread_mutex_t *)&v53[1]))
      {
        v27 = 94;
        v28 = "SharedArrayPop: pthread_cond_wait failed\n";
        goto LABEL_19;
      }
    }
    --DWORD2(v52);
    v30 = *((_DWORD *)v53[0] + (v29 - 1));
    if (pthread_mutex_unlock((pthread_mutex_t *)&v53[1]))
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v36, v37, v38, v45);
LABEL_20:
      LODWORD(v52) = 0;
    }
    v31 = v60;
    v32 = &v60[2368 * v30];
    *((_QWORD *)v32 + 293) = 0;
    v33 = (pthread_mutex_t *)(v32 + 32);
    if (pthread_mutex_lock((pthread_mutex_t *)(v32 + 32))
      || (v34 = &v31[2368 * v30], v35 = *((_DWORD *)v34 + 6), *((_DWORD *)v34 + 6) = v35 + 1, !v35)
      && pthread_cond_broadcast((pthread_cond_t *)&v31[2368 * v30 + 96])
      || pthread_mutex_unlock(v33))
    {
      LODWORD(v52) = 0;
    }
  }
  if (v58)
  {
    for (j = 0; j < v58; ++j)
    {
      if (joinSearchThread((uint64_t)&v51, j))
        LODWORD(v52) = 0;
    }
  }
LABEL_35:
  if (pthread_mutex_destroy((pthread_mutex_t *)&v53[1]) || pthread_cond_destroy((pthread_cond_t *)&v57[1]))
    LODWORD(v52) = 0;
  else
    free(v53[0]);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((_DWORD)v52)
    v41 = 0;
  else
    v41 = -1;
  if ((int)result >= 0)
    return v41;
  else
    return result;
}

uint64_t searchBeginProc(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5, size_t a6)
{
  pthread_mutex_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  int v16;
  unsigned int v17;
  uint64_t result;
  unsigned int v19;
  _QWORD *v20;
  char v21;

  *(_DWORD *)(a1 + 148) = -1;
  v10 = (pthread_mutex_t *)(a1 + 32);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 32)))
  {
    v14 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v15 = 91;
LABEL_8:
    result = pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v15, 0, v14, v11, v12, v13, v21);
    *(_DWORD *)(a1 + 8) = 0;
    goto LABEL_9;
  }
  while (1)
  {
    v16 = *(_DWORD *)(a1 + 16);
    if (v16)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 96), v10))
    {
      v14 = "SharedArrayPop: pthread_cond_wait failed\n";
      v15 = 94;
      goto LABEL_8;
    }
  }
  v17 = v16 - 1;
  *(_DWORD *)(a1 + 16) = v17;
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v17);
  result = pthread_mutex_unlock(v10);
  if ((_DWORD)result)
  {
    v14 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    v15 = 98;
    goto LABEL_8;
  }
LABEL_9:
  v19 = *(_DWORD *)(a1 + 148);
  if (v19 != -1)
  {
    v20 = (_QWORD *)(*(_QWORD *)(a1 + 152) + 2368 * v19);
    memcpy(v20 + 18, a2, 0x890uLL);
    v20[293] = 0;
    v20[294] = a6;
    result = appendPayload((uint64_t)v20, a5, a6);
    if ((_DWORD)result)
      *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t searchPayloadProc(uint64_t result, const void *a2, size_t a3)
{
  unsigned int v3;
  uint64_t v4;

  v3 = *(_DWORD *)(result + 148);
  if (v3 != -1)
  {
    v4 = result;
    result = appendPayload(*(_QWORD *)(result + 152) + 2368 * v3, a2, a3);
    if ((_DWORD)result)
      *(_DWORD *)(v4 + 8) = 0;
  }
  return result;
}

uint64_t searchEndProc(uint64_t result)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v1 = *(_DWORD *)(result + 148);
  if (v1 != -1)
  {
    v2 = result;
    v3 = *(_QWORD *)(result + 152);
    if (**(int **)result >= 2)
    {
      v4 = v3 + 2368 * v1;
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Thread %d processing '%s', size=%zu, header=%zu, capacity=%zu\n", *(_DWORD *)(v4 + 8), (const char *)(v4 + 288), *(_QWORD *)(v4 + 2344), *(_QWORD *)(v4 + 2352), *(_QWORD *)(v4 + 2336));
    }
    result = pthread_mutex_lock((pthread_mutex_t *)(v3 + 2368 * v1 + 32));
    if ((_DWORD)result
      || (v5 = v3 + 2368 * v1, v6 = *(_DWORD *)(v5 + 24), *(_DWORD *)(v5 + 24) = v6 + 1, !v6)
      && (result = pthread_cond_broadcast((pthread_cond_t *)(v3 + 2368 * v1 + 96)), (_DWORD)result)
      || (result = pthread_mutex_unlock((pthread_mutex_t *)(v3 + 2368 * v1 + 32)), (_DWORD)result))
    {
      *(_DWORD *)(v2 + 8) = 0;
    }
  }
  return result;
}

uint64_t apfs_scan_diskimage(const char *a1, uint64_t (*a2)(__int128 *, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  AAByteStream_impl *v11;
  char *v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  const char *v28;
  const char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  FILE *v35;
  FILE *v36;
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  size_t v42;
  uint64_t v43;
  const char *v44;
  __int16 v45;
  int v46;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  __int16 v52;
  int v53;
  void **v54;
  const char *v55;
  __int16 v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  stat v60;
  char *__s1[2];
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  uint64_t __src;
  uint64_t v66;
  __int128 v67;
  int v68[4];
  char v69[1024];
  char __str[1024];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  memset(&v60, 0, sizeof(v60));
  if (snprintf(__str, 0x400uLL, "%s.json", a1) > 0)
  {
    if (!stat(__str, &v60) && (v60.st_mode & 0xF000) == 0x8000)
    {
      v11 = AAFileStreamOpenWithPath(__str, 0, 0);
      if (v11)
      {
        v12 = 0;
LABEL_6:
        v67 = 0u;
        *(_OWORD *)v68 = 0u;
        __src = 0;
        v66 = 0;
        v13 = (void **)AAJSONInputStreamOpen((uint64_t)v11);
        if (v13)
        {
          v20 = v13;
          v64 = 0;
          v62 = 0u;
          v63 = 0u;
          *(_OWORD *)__s1 = 0u;
          if ((AAJSONInputStreamRead((uint64_t)v13, (int *)__s1, v14, v15, v16, v17, v18, v19) & 0x80000000) == 0)
          {
            while (1)
            {
              v27 = v64;
              if (!(_DWORD)v64)
              {
                AAJSONInputStreamClose(v20);
                v46 = 1;
                goto LABEL_66;
              }
              if (LODWORD(__s1[0]) < 2)
                break;
              if (LODWORD(__s1[0]) == 2)
              {
                if ((_DWORD)v64 == 4)
                {
                  v68[1] = *(_QWORD *)(*(_QWORD *)&v68[2] - 64);
                  if ((a2(&v67, a4) & 0x80000000) != 0)
                  {
                    v55 = "add_fork";
                    v56 = 58;
                    goto LABEL_88;
                  }
                  pc_array_free(*(uint64_t *)&v68[2]);
                  *(_QWORD *)&v68[2] = 0;
                  v27 = v64;
                }
                if (v27 == 6)
                {
                  *(_QWORD *)&v68[2] = pc_array_append(*(uint64_t *)&v68[2], &__src, v21, v22, v23, v24, v25, v26);
                  if (!*(_QWORD *)&v68[2])
                  {
                    v55 = "pc_array_append";
                    v56 = 67;
                    goto LABEL_88;
                  }
                }
              }
              else if (LODWORD(__s1[0]) == 4)
              {
                if ((_DWORD)v64 == 7)
                {
                  v29 = __s1[1];
                  if (!strcmp(__s1[1], "offset"))
                  {
                    __src = *((_QWORD *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v29, "length"))
                    {
                      v55 = "bad map";
                      v56 = 83;
                      goto LABEL_88;
                    }
                    v66 = *((_QWORD *)&v62 + 1);
                  }
                }
                else if ((_DWORD)v64 == 5)
                {
                  v28 = __s1[1];
                  if (!strcmp(__s1[1], "compression"))
                  {
                    v68[0] = BYTE8(v62);
                  }
                  else if (!strcmp(v28, "uncompressed_size"))
                  {
                    *(_QWORD *)&v67 = *((_QWORD *)&v62 + 1);
                  }
                  else
                  {
                    if (strcmp(v28, "size"))
                    {
                      v55 = "bad map";
                      v56 = 77;
                      goto LABEL_88;
                    }
                    *((_QWORD *)&v67 + 1) = *((_QWORD *)&v62 + 1);
                  }
                }
              }
LABEL_38:
              v64 = 0;
              v62 = 0u;
              v63 = 0u;
              *(_OWORD *)__s1 = 0u;
              if ((AAJSONInputStreamRead((uint64_t)v20, (int *)__s1, v21, v22, v23, v24, v25, v26) & 0x80000000) != 0)
                goto LABEL_89;
            }
            switch((int)v64)
            {
              case 2:
                if (!strcmp(__s1[1], "volumes"))
                  goto LABEL_38;
                v55 = "bad map";
                v56 = 41;
                break;
              case 4:
                if (!strcmp(__s1[1], "files"))
                  goto LABEL_38;
                v55 = "bad map";
                v56 = 42;
                break;
              case 5:
                v67 = 0u;
                *(_OWORD *)v68 = 0u;
                *(_QWORD *)&v68[2] = pc_array_init(16);
                goto LABEL_38;
              case 6:
                if (!strcmp(__s1[1], "extents"))
                  goto LABEL_38;
                v55 = "bad map";
                v56 = 43;
                break;
              case 8:
                v55 = "bad map";
                v56 = 44;
                break;
              default:
                goto LABEL_38;
            }
LABEL_88:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", v56, 144, 0, v55, v25, v26, (char)v59);
          }
LABEL_89:
          v54 = v20;
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"parseAPFSJSON", 27, 144, 0, "AAJSONInputStreamOpen", v18, v19, (char)v59);
          v54 = 0;
        }
        AAJSONInputStreamClose(v54);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 181, 144, 0, "invalid image map JSON", v57, v58, (char)v59);
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 114, 144, 0, "AAFileStreamOpenWithPath", v9, v10, (char)v59);
        v12 = 0;
      }
      goto LABEL_65;
    }
    if (getenv("PC_APFS_DISKIMAGE_MAP") && (__strlcpy_chk(), !stat(__str, &v60)) && (v60.st_mode & 0xF000) == 0x8000
      || (v30 = getenv("MASTERING_TOOLCHAIN_DIR")) != 0
      && (snprintf(__str, 0x400uLL, "%s%s/%s", v30, "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000|| (snprintf(__str, 0x400uLL, "%s/%s", "/System/Library/Filesystems/apfs.fs/Contents/Resources", "apfs_diskimage_map"), !stat(__str, &v60))&& (v60.st_mode & 0xF000) == 0x8000)
    {
      v12 = (char *)malloc(0x40000uLL);
      if (v12)
      {
        v11 = (AAByteStream_impl *)AATempStreamOpen(0x800000uLL);
        if (v11)
        {
          snprintf(v69, 0x400uLL, "%s \"%s\"", __str, a1);
          v35 = popen(v69, "r");
          if (v35)
          {
            v36 = v35;
            while (1)
            {
              if (feof(v36))
              {
                pclose(v36);
                AAByteStreamSeek(v11, 0, 0);
                goto LABEL_6;
              }
              v37 = fread(v12, 1uLL, 0x40000uLL, v36);
              if (ferror(v36))
                break;
              if (*((_QWORD *)v11 + 3))
              {
                v40 = 0;
                if (v37)
                {
                  v41 = v12;
                  v42 = v37;
                  while (1)
                  {
                    v43 = (*((uint64_t (**)(_QWORD, char *, size_t))v11 + 3))(*(_QWORD *)v11, v41, v42);
                    if (v43 < 1)
                      break;
                    v41 += v43;
                    v40 += v43;
                    v42 -= v43;
                    if (!v42)
                      goto LABEL_62;
                  }
                  v40 = v43;
                }
              }
              else
              {
                v40 = -1;
              }
LABEL_62:
              if (v40 != v37)
              {
                v44 = "writing tool output";
                v45 = 172;
                goto LABEL_82;
              }
            }
            v44 = "reading from tool pipe";
            v45 = 170;
LABEL_82:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v45, 144, 0, v44, v38, v39, (char)v59);
            AAByteStreamClose(v11);
            pclose(v36);
            goto LABEL_70;
          }
          v53 = *__error();
          v59 = v69;
          v51 = "%s";
          v52 = 164;
        }
        else
        {
          v51 = "temp stream open";
          v52 = 159;
          v53 = 0;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", v52, 144, v53, v51, v33, v34, (char)v59);
LABEL_69:
        AAByteStreamClose(v11);
LABEL_70:
        v46 = 0;
        goto LABEL_71;
      }
      v48 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 156, 144, *v48, "malloc", v49, v50, (char)v59);
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 153, 144, 0, "could not locate the apfs diskimage map tool", v31, v32, (char)v59);
      v12 = 0;
    }
    v11 = 0;
    goto LABEL_69;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/APFS/APFS.c", (uint64_t)"apfs_scan_diskimage", 110, 144, 0, "snprintf", v7, v8, (char)v59);
  v12 = 0;
  v11 = 0;
LABEL_65:
  v46 = 0;
LABEL_66:
  AAByteStreamClose(v11);
LABEL_71:
  free(v12);
  if (v46)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t archiveTreeUpdateChilds(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  int *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int *v19;
  int v20;
  _DWORD *v21;
  int v22;
  int *v23;
  _DWORD *v24;
  int v25;
  const char *v27;
  __int16 v28;
  char v29;

  v8 = *a1;
  if (!(_DWORD)v8)
  {
LABEL_16:
    v13 = 0;
    return (v13 << 31 >> 31);
  }
  v9 = (_DWORD *)(*((_QWORD *)a1 + 1) + 48);
  v10 = *a1;
  do
  {
    *(_QWORD *)(v9 - 11) = -1;
    *v9 = -1;
    v9 += 14;
    --v10;
  }
  while (v10);
  v11 = 0;
  v12 = (int *)*((_QWORD *)a1 + 1);
  v13 = 1;
  v14 = v12;
  v15 = 0xFFFFFFFFLL;
  v16 = -1;
  while (1)
  {
    v18 = *v14;
    v14 += 14;
    v17 = v18;
    if (v18 == -1)
      break;
    v19 = &v12[14 * v17];
    v22 = v19[12];
    v21 = v19 + 12;
    v20 = v22;
    if (v22 == -1)
    {
      v23 = &v12[14 * v17];
      v25 = v23[1];
      v24 = v23 + 1;
      if (v25 != -1)
      {
        v27 = "node has a first child, but no last child";
        v28 = 1092;
        goto LABEL_20;
      }
      *v24 = v11;
    }
    else
    {
      v12[14 * v20 + 2] = v11;
    }
    *v21 = v11;
LABEL_15:
    v13 = ++v11 < v8;
    if (v8 == v11)
      goto LABEL_16;
  }
  if (v15 != 0xFFFFFFFFLL)
  {
    v12[14 * v15 + 2] = v11;
    v15 = v11;
    goto LABEL_15;
  }
  if (v16 == -1)
  {
    v15 = v11;
    v16 = v11;
    goto LABEL_15;
  }
  v27 = "tree has a first root, but no last root";
  v28 = 1080;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeUpdateChilds", v28, 34, 0, v27, a7, a8, v29);
  return (v13 << 31 >> 31);
}

unsigned int *ArchiveTreeCreateWithRootEntry()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  __int16 v10;
  char v12;

  v0 = (unsigned int *)archiveTreeCreate();
  v3 = v0;
  if (!v0)
  {
    v9 = "archive tree creation";
    v10 = 1134;
LABEL_6:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateWithRootEntry", v10, 34, 0, v9, v1, v2, v12);
    ArchiveTreeDestroy((uint64_t)v3);
    return 0;
  }
  if ((archiveTreeAppend(v0, -1, &unk_206434423, 0, -1, -1, 68) & 0x80000000) != 0)
  {
    v9 = "inserting root entry";
    v10 = 1137;
    goto LABEL_6;
  }
  archiveTreeUpdateChilds(v3, v4, v5, v6, v7, v8, v1, v2);
  return v3;
}

_QWORD *archiveTreeCreate()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  char v7;

  v2 = calloc(1uLL, 0x20uLL);
  if (v2)
  {
    v3 = StringTableCreate();
    v2[2] = v3;
    if (!v3)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeCreate", 109, 34, 0, "string table creation", v4, v5, v7);
      free(v2);
      return 0;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeCreate", 108, 34, 0, "malloc", v0, v1, v7);
  }
  return v2;
}

uint64_t archiveTreeAppend(unsigned int *a1, int a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t result;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  char v25;

  if (archiveTreeReserve((uint64_t)a1, *a1 + 1))
  {
    v18 = "increasing archive tree storage";
    v19 = 140;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeAppend", v19, 34, 0, v18, v16, v17, v25);
    return 0xFFFFFFFFLL;
  }
  v21 = *((_QWORD *)a1 + 1);
  v22 = *a1;
  v23 = v21 + 56 * *a1;
  *(_QWORD *)(v23 + 48) = 0;
  *(_OWORD *)(v23 + 16) = 0u;
  *(_OWORD *)(v23 + 32) = 0u;
  *(_OWORD *)v23 = 0u;
  if ((StringTableAppend(*((unsigned int **)a1 + 2), a3, a4, (_DWORD *)(v23 + 12), v14, v15, v16, v17) & 0x80000000) != 0)
  {
    v18 = "inserting tree node";
    v19 = 144;
    goto LABEL_3;
  }
  result = 0;
  *(_DWORD *)v23 = a2;
  v24 = v21 + 56 * v22;
  *(_DWORD *)(v24 + 16) = a7;
  *(_QWORD *)(v24 + 24) = a5;
  *(_QWORD *)(v24 + 32) = a6;
  ++*a1;
  return result;
}

void ArchiveTreeDestroy(uint64_t a1)
{
  if (a1)
  {
    free(*(void **)(a1 + 8));
    StringTableDestroy(*(void ***)(a1 + 16));
    MemBufferDestroy(*(void ***)(a1 + 24));
    free((void *)a1);
  }
}

unsigned int *ArchiveTreeCreateFromIndex(uint64_t a1, uint64_t a2, int (*a3)(uint64_t, _BYTE *, _QWORD), uint64_t a4, int a5, int a6)
{
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  int v28;
  size_t v30;
  _DWORD *v31;
  uint64_t v32;
  uint64_t v33;
  size_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  int v38;
  void *v39;
  void *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  __int128 *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _DWORD *v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  unsigned int *v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  unsigned int **v62;
  _BYTE v63[2048];
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v62 = 0;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v57 = 0u;
  v55 = 0;
  v56 = 0;
  v12 = (unsigned int *)archiveTreeCreate();
  v20 = v12;
  if (!v12)
  {
    v26 = "archive tree creation";
    v27 = 1164;
    goto LABEL_8;
  }
  *(_QWORD *)&v58 = 0;
  *((_QWORD *)&v59 + 1) = 0;
  v60 = 0u;
  v61 = 0u;
  *((_QWORD *)&v57 + 1) = a1;
  LODWORD(v57) = 0;
  DWORD1(v57) = a5;
  *((_QWORD *)&v58 + 1) = a2;
  *(_QWORD *)&v59 = archiveTreeFromIndexBeginProc;
  v62 = &v55;
  v55 = v12;
  v56 = 0x1FFFFFFFFLL;
  if (ParallelArchiveRead((uint64_t)&v57, v13, v14, v15, v16, v17, v18, v19) || !HIDWORD(v56))
  {
    v26 = "parsing index";
    v27 = 1178;
    goto LABEL_8;
  }
  if (archiveTreeSort(v20))
  {
    v26 = "sorting tree";
    v27 = 1181;
    goto LABEL_8;
  }
  if (a6 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12u entries in index\n", *v20);
  if (!a3)
  {
    v39 = 0;
LABEL_50:
    archiveTreeUpdateChilds(v20, v21, v22, v23, v24, v25, v18, v19);
    free(v39);
    return v20;
  }
  bzero(v63, 0x800uLL);
  v30 = *v20;
  if (!(_DWORD)v30)
  {
    v30 = 0;
LABEL_30:
    v40 = calloc(v30, 4uLL);
    if (!v40)
    {
      v28 = *__error();
      v26 = "malloc";
      v27 = 1216;
      goto LABEL_9;
    }
    v39 = v40;
    v41 = *v20;
    if ((_DWORD)v41)
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
      do
      {
        v45 = *((_QWORD *)v20 + 1);
        if ((*(_BYTE *)(v45 + v42 + 48) & 1) != 0)
        {
          *((_DWORD *)v40 + v43) = v44;
          if (v43 != v44)
          {
            v46 = v45 + 56 * v44;
            v47 = (__int128 *)(v45 + v42);
            v48 = *v47;
            v49 = v47[1];
            v50 = v47[2];
            *(_QWORD *)(v46 + 48) = *((_QWORD *)v47 + 6);
            *(_OWORD *)(v46 + 16) = v49;
            *(_OWORD *)(v46 + 32) = v50;
            *(_OWORD *)v46 = v48;
          }
          ++v44;
          v41 = *v20;
        }
        ++v43;
        v42 += 56;
      }
      while (v43 < v41);
      *v20 = v44;
      if (v44)
      {
        v51 = (_DWORD *)*((_QWORD *)v20 + 1);
        v52 = v44;
        do
        {
          v53 = *v51;
          if ((_DWORD)v53 != -1)
            LODWORD(v53) = *((_DWORD *)v40 + v53);
          *v51 = v53;
          v51 += 14;
          --v52;
        }
        while (v52);
      }
    }
    else
    {
      v44 = 0;
      *v20 = 0;
    }
    if (a6 > 0)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12u entries selected\n", v44);
    goto LABEL_50;
  }
  v31 = (_DWORD *)(*((_QWORD *)v20 + 1) + 48);
  v32 = *v20;
  do
  {
    *v31 = 0;
    v31 += 14;
    --v32;
  }
  while (v32);
  v33 = 0;
  v34 = 0;
  v35 = *((_QWORD *)v20 + 1);
  while (1)
  {
    v36 = *(_DWORD *)(v35 + v33);
    if (v36 != -1)
      break;
LABEL_21:
    if (ArchiveTreeNodePath((uint64_t)v20, v34, (uint64_t)v63, 0x800uLL) < 0)
    {
      v26 = "getting node path";
      v27 = 1209;
      goto LABEL_8;
    }
    if (a3(a4, v63, *(unsigned int *)(*((_QWORD *)v20 + 1) + v33 + 16)) <= 0)
      v38 = 2;
    else
      v38 = 3;
    v35 = *((_QWORD *)v20 + 1);
    *(_DWORD *)(v35 + v33 + 48) = v38;
    v30 = *v20;
LABEL_26:
    ++v34;
    v33 += 56;
    if (v34 >= v30)
      goto LABEL_30;
  }
  v37 = *(_DWORD *)(v35 + 56 * v36 + 48);
  if (v37)
  {
    *(_DWORD *)(v35 + v33 + 48) = v37;
    if ((v37 & 1) == 0)
      goto LABEL_26;
    goto LABEL_21;
  }
  v26 = "parent node was not processed first";
  v27 = 1202;
LABEL_8:
  v28 = 0;
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateFromIndex", v27, 34, v28, v26, v18, v19, v54);
  ArchiveTreeDestroy((uint64_t)v20);
  return 0;
}

size_t archiveTreeFromIndexBeginProc(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  char *v21;
  int v22;
  const char *v23;
  __int16 v24;
  int64_t v25;
  char *v26;
  unsigned int *v27;
  char *v28;
  char *v29;
  char *v30;
  int64_t v31;
  size_t v32;
  char v33;
  char *v34;
  uint64_t v35;
  int v36;
  char __dst[1024];
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a2 + 4) != 77)
  {
    v9 = result;
    if (!a4)
      goto LABEL_18;
    v10 = *(_QWORD *)result;
    v11 = (uint64_t *)(a3 + 8);
    v12 = -1;
    do
    {
      if ((*(_DWORD *)(v11 - 1) & 0xDFDFDF) == 0x584449 && *((_DWORD *)v11 - 1) == 1)
        v12 = *v11;
      v11 += 129;
      --a4;
    }
    while (a4);
    if (v12 == -1)
    {
LABEL_18:
      v33 = a2 - 112;
      v23 = "entry is missing IDX field: %s";
      v24 = 589;
    }
    else
    {
      v13 = *(_DWORD *)(result + 8);
      if (v13 != -1)
      {
        v14 = *(_QWORD *)(v10 + 8) + 56 * v13;
        v16 = *(_QWORD *)(v14 + 32);
        v15 = (unint64_t *)(v14 + 32);
        v17 = v12 - *(v15 - 1);
        if (v17 < v16)
          *v15 = v17;
      }
      strncpy(__dst, (const char *)(a2 + 144), 0x400uLL);
      v18 = strlen(__dst);
      v19 = v18;
      v36 = -1;
      if (v18)
      {
        v20 = 0;
        while (__dst[v18 + v20] != 47)
        {
          --v20;
          if (!(v18 + v20))
            goto LABEL_16;
        }
        v25 = v18 + v20;
        v26 = &__dst[v18 + v20];
        *v26 = 0;
        v21 = v26 + 1;
        if ((archiveTreeFindPath(v10, __dst, (unsigned int *)&v36) & 0x80000000) == 0)
        {
          v19 = ~v20;
          v22 = v36;
          if (v36 == -1)
          {
            v34 = v21;
            v35 = v10;
            v27 = *(unsigned int **)v9;
            v28 = __dst;
            while (1)
            {
              v29 = strchr(v28, 47);
              v30 = v29;
              v31 = v29 - v28;
              v32 = v29 ? v29 - v28 : v25;
              if ((archiveTreeAppend(v27, v22, v28, v32, -1, -1, 68) & 0x80000000) != 0)
                break;
              v27 = *(unsigned int **)v9;
              v22 = **(_DWORD **)v9 - 1;
              v36 = v22;
              if (v30)
              {
                v28 += v31 + 1;
                v25 -= v31 + 1;
                if (v25)
                  continue;
              }
              v21 = v34;
              v10 = v35;
              goto LABEL_31;
            }
            v23 = "inserting tree node";
            v24 = 640;
            goto LABEL_19;
          }
LABEL_31:
          result = archiveTreeAppend((unsigned int *)v10, v22, v21, v19, v12, -1, *(_DWORD *)(a2 + 4));
          if ((result & 0x80000000) == 0)
          {
            *(_DWORD *)(v9 + 8) = *(_DWORD *)v10 - 1;
            return result;
          }
          v23 = "inserting tree node";
          v24 = 650;
          goto LABEL_19;
        }
        v23 = "looking up parent path failed";
        v24 = 624;
      }
      else
      {
LABEL_16:
        if ((archiveTreeFindPath(v10, (const char *)&unk_206434423, (unsigned int *)&v36) & 0x80000000) == 0)
        {
          v21 = __dst;
          v22 = v36;
          goto LABEL_31;
        }
        v23 = "looking up parent path failed";
        v24 = 629;
      }
    }
LABEL_19:
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromIndexBeginProc", v24, 34, 0, v23, a7, a8, v33);
    *(_DWORD *)(v9 + 12) = 0;
  }
  return result;
}

uint64_t archiveTreeSort(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  size_t v6;
  size_t v7;
  uint64_t v8;
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  unint64_t v16;
  uint64_t v17;
  size_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  size_t v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v29;
  _BYTE v30[1024];
  _BYTE v31[1024];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (*a1)
  {
    if ((archiveTreeSortStringTable((unsigned int **)a1) & 0x80000000) != 0)
    {
      v9 = "sort string table";
      v10 = 510;
    }
    else
    {
      if ((archiveTreeUpdateDepth(a1) & 0x80000000) == 0)
      {
        v4 = (unsigned int *)calloc(*a1, 4uLL);
        v5 = v4;
        if (v4)
        {
          if (*a1)
          {
            v6 = 0;
            do
            {
              v4[v6] = v6;
              ++v6;
              v7 = *a1;
            }
            while (v6 < v7);
          }
          else
          {
            v7 = 0;
          }
          qsort_r(v4, v7, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))archiveTreeCompareNodesLexProc);
          v16 = *a1;
          if ((_DWORD)v16)
          {
            v17 = 0;
            v18 = 0;
            while (v17)
            {
              v19 = v5[v17 - 1];
              v20 = v5[v17];
              if (v19 != v20)
              {
                v21 = v5[v17];
                while (v21 != -1)
                {
                  if (v19 == -1)
                    break;
                  v22 = *((_QWORD *)a1 + 1);
                  if (*(_DWORD *)(v22 + 56 * v19 + 12) != *(_DWORD *)(v22 + 56 * v21 + 12))
                    break;
                  v19 = *(_DWORD *)(v22 + 56 * v19);
                  v21 = *(_DWORD *)(v22 + 56 * v21);
                  if (v19 == v21)
                    goto LABEL_24;
                }
                goto LABEL_26;
              }
LABEL_24:
              ArchiveTreeNodePath((uint64_t)a1, v20, (uint64_t)v31, 0x400uLL);
              ArchiveTreeNodePath((uint64_t)a1, v5[v17 - 1], (uint64_t)v30, 0x400uLL);
              *(_DWORD *)(*((_QWORD *)a1 + 1) + 56 * v5[v17] + 48) = v18 - 1;
              v16 = *a1;
LABEL_27:
              if (++v17 >= v16)
                goto LABEL_30;
            }
            v20 = *v5;
LABEL_26:
            *(_DWORD *)(*((_QWORD *)a1 + 1) + 56 * v20 + 48) = v18;
            v18 = (v18 + 1);
            goto LABEL_27;
          }
          v18 = 0;
LABEL_30:
          if ((archiveTreeRemapNodes(a1, v18) & 0x80000000) != 0)
          {
            v14 = "remapping nodes";
            v15 = 544;
          }
          else if ((archiveTreeUpdateDepth(a1) & 0x80000000) != 0)
          {
            v14 = "storing depth in AUX";
            v15 = 547;
          }
          else
          {
            if (*a1)
            {
              v23 = 0;
              do
              {
                v5[v23] = v23;
                ++v23;
                v24 = *a1;
              }
              while (v23 < v24);
            }
            else
            {
              v24 = 0;
            }
            qsort_r(v5, v24, 4uLL, a1, (int (__cdecl *)(void *, const void *, const void *))archiveTreeCompareNodesStrProc);
            v25 = *a1;
            if ((_DWORD)v25)
            {
              v26 = 0;
              v27 = *((_QWORD *)a1 + 1);
              do
              {
                *(_DWORD *)(v27 + 56 * v5[v26] + 48) = v26;
                ++v26;
              }
              while (v25 != v26);
            }
            if ((archiveTreeRemapNodes(a1, v18) & 0x80000000) == 0)
            {
              v8 = 0;
LABEL_48:
              free(v5);
              return v8;
            }
            v14 = "remapping nodes";
            v15 = 559;
          }
          v11 = 0;
        }
        else
        {
          v11 = *__error();
          v14 = "malloc";
          v15 = 517;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeSort", v15, 34, v11, v14, v12, v13, v29);
LABEL_47:
        v8 = 0xFFFFFFFFLL;
        goto LABEL_48;
      }
      v9 = "store AUX in depth";
      v10 = 513;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeSort", v10, 34, 0, v9, v2, v3, v29);
    v5 = 0;
    goto LABEL_47;
  }
  return 0;
}

uint64_t ArchiveTreeNodePath(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t result;

  if (a2 == -1 || *(_DWORD *)a1 <= a2)
  {
    result = 0;
LABEL_8:
    *(_BYTE *)(a3 + result) = 0;
    return result;
  }
  v8 = ArchiveTreeNodePath(a1, *(unsigned int *)(*(_QWORD *)(a1 + 8) + 56 * a2), a3);
  if ((v8 & 0x8000000000000000) == 0)
  {
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_QWORD *)(v9 + 32);
    v11 = *(_QWORD *)(v9 + 8) + 16 * *(unsigned int *)(*(_QWORD *)(a1 + 8) + 56 * a2 + 12);
    v12 = *(_QWORD *)v11;
    v13 = *(unsigned int *)(v11 + 8);
    if (v8)
    {
      v14 = v8 + 1;
      if (v8 + 1 + v13 < a4)
      {
        *(_BYTE *)(a3 + v8) = 47;
LABEL_11:
        memcpy((void *)(a3 + v14), (const void *)(v10 + v12), v13);
        result = v14 + v13;
        goto LABEL_8;
      }
    }
    else if (v13 < a4)
    {
      v14 = 0;
      goto LABEL_11;
    }
  }
  return -1;
}

unsigned int *ArchiveTreeCreateFromArchive(uint64_t a1, uint64_t a2, int a3)
{
  int DefaultNThreads;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _OWORD *v30;
  _OWORD v31[67];
  uint64_t v32;

  DefaultNThreads = a3;
  v32 = *MEMORY[0x24BDAC8D0];
  if (!a3)
    DefaultNThreads = getDefaultNThreads();
  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v25 = 0u;
  memset(v31, 0, 512);
  v6 = (unsigned int *)archiveTreeCreate();
  if (v6)
  {
    bzero((char *)v31 + 8, 0x428uLL);
    DWORD2(v31[0]) = 1;
    *(_QWORD *)&v31[0] = v6;
    *((_QWORD *)&v25 + 1) = a1;
    *(_QWORD *)&v26 = 0;
    LODWORD(v25) = 0;
    DWORD1(v25) = DefaultNThreads;
    *((_QWORD *)&v26 + 1) = a2;
    *(_QWORD *)&v27 = archiveTreeFromArchiveBeginProc;
    *((_QWORD *)&v27 + 1) = archiveTreeFromArchiveBlobProc;
    *(_QWORD *)&v28 = archiveTreeFromArchivePayloadProc;
    *((_QWORD *)&v28 + 1) = archiveTreeFromArchivePaddingProc;
    *(_QWORD *)&v29 = archiveTreeFromArchiveEndProc;
    *((_QWORD *)&v29 + 1) = archiveTreeFromArchivePaddingProc;
    v30 = v31;
    if (ParallelArchiveRead((uint64_t)&v25, v7, v8, v9, v10, v11, v12, v13) || !DWORD2(v31[0]))
    {
      v21 = "parsing archive";
      v22 = 1292;
    }
    else
    {
      if (!archiveTreeSort(v6))
      {
        archiveTreeUpdateChilds(v6, v16, v17, v18, v19, v20, v14, v15);
        return v6;
      }
      v21 = "sorting tree";
      v22 = 1295;
    }
    v23 = 0;
  }
  else
  {
    v23 = *__error();
    v21 = "archive tree creation";
    v22 = 1274;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateFromArchive", v22, 34, v23, v21, v14, v15, v25);
  ArchiveTreeDestroy((uint64_t)v6);
  return 0;
}

char *archiveTreeFromArchiveBeginProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  char *result;
  uint64_t v8;

  v6 = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(a1 + 48) = 0;
  result = (char *)(a1 + 48);
  v8 = *((_QWORD *)result - 4);
  *((_QWORD *)result - 4) = v8 + a6;
  *((_QWORD *)result - 3) = v8;
  *((_DWORD *)result - 2) = 0;
  *((_DWORD *)result - 1) = v6;
  if ((*(_BYTE *)(a2 + 1) & 0x80) != 0)
    return (char *)strlcpy(result, (const char *)(a2 + 144), 0x400uLL);
  return result;
}

size_t archiveTreeFromArchiveEndProc(size_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  size_t v4;
  char *v5;
  size_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  __int16 v11;
  char *v12;
  char *v13;
  const char *v14;
  size_t v15;
  int v16;
  char *v17;
  unsigned int *v18;
  int64_t v19;
  char v20;
  int v21;

  v1 = *(_QWORD *)(result + 24);
  v2 = *(_QWORD *)(result + 16) - v1;
  *(_QWORD *)(result + 32) = v2;
  v3 = *(_DWORD *)(result + 44);
  if (v3 != 77)
  {
    v4 = result;
    v5 = (char *)(result + 48);
    v6 = strlen((const char *)(result + 48));
    v7 = v6;
    v21 = -1;
    if (v6 >= 2)
    {
      if (*(_WORD *)v5 == 12078)
      {
        v5 = (char *)(v4 + 50);
        v7 = v6 - 2;
        if (v6 == 2)
          goto LABEL_9;
      }
LABEL_12:
      v12 = strrchr(v5, 47);
      if (v12)
      {
        v13 = v12;
        v14 = v12 + 1;
        if (v12 == v5)
          goto LABEL_17;
        *v12 = 0;
        if ((archiveTreeFindPath(*(_QWORD *)v4, v5, (unsigned int *)&v21) & 0x80000000) == 0)
        {
          *v13 = 47;
          goto LABEL_17;
        }
        v10 = "looking up parent node";
        v11 = 712;
      }
      else
      {
        v14 = v5;
        if ((archiveTreeFindPath(*(_QWORD *)v4, (const char *)&unk_206434423, (unsigned int *)&v21) & 0x80000000) == 0)
        {
LABEL_17:
          if (v21 == -1)
          {
            v16 = -1;
            while (1)
            {
              v17 = strchr(v5, 47);
              v18 = *(unsigned int **)v4;
              if (!v17)
                break;
              v19 = v17 - v5;
              result = archiveTreeAppend(v18, v16, v5, v17 - v5, -1, -1, 68);
              if ((result & 0x80000000) != 0)
              {
                v10 = "inserting tree node";
                v11 = 741;
                goto LABEL_30;
              }
              v5 += v19 + 1;
              v16 = **(_DWORD **)v4 - 1;
              v21 = v16;
              v7 -= v19 + 1;
              if (!v7)
                return result;
            }
            result = archiveTreeAppend(v18, v16, v5, v7, *(_QWORD *)(v4 + 24), *(_QWORD *)(v4 + 16) - *(_QWORD *)(v4 + 24), *(_DWORD *)(v4 + 44));
            if ((result & 0x80000000) == 0)
              return result;
            v10 = "inserting tree node";
            v11 = 748;
          }
          else
          {
            v15 = strlen(v14);
            result = archiveTreeAppend(*(unsigned int **)v4, v21, v14, v15, *(_QWORD *)(v4 + 24), *(_QWORD *)(v4 + 32), *(_DWORD *)(v4 + 44));
            if ((result & 0x80000000) == 0)
              return result;
            v10 = "inserting tree node";
            v11 = 725;
          }
          goto LABEL_30;
        }
        v10 = "looking up parent node";
        v11 = 719;
      }
LABEL_30:
      result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromArchiveEndProc", v11, 34, 0, v10, v8, v9, v20);
      *(_DWORD *)(v4 + 8) = 0;
      return result;
    }
    if (v6 == 1)
    {
      if (*(_BYTE *)(v4 + 48) != 46)
      {
        v7 = 1;
        goto LABEL_12;
      }
      v5 = (char *)(v4 + 49);
    }
LABEL_9:
    result = archiveTreeAppend(*(unsigned int **)v4, -1, v5, 0, v1, v2, v3);
    if ((result & 0x80000000) == 0)
      return result;
    v10 = "inserting root node";
    v11 = 698;
    goto LABEL_30;
  }
  return result;
}

_DWORD *archiveTreeFromArchiveBlobProc(_DWORD *result, _DWORD *a2, size_t a3)
{
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  char v8;

  v3 = result;
  if (!a3 || result[11] != 77 || (*a2 & 0xDFDFDF) != 0x464159)
  {
    v7 = result + 10;
    goto LABEL_8;
  }
  v4 = *(_QWORD *)(*(_QWORD *)result + 24);
  result[10] = v4 == 0;
  if (!v4)
  {
    result = MemBufferCreate(a3);
    *(_QWORD *)(*(_QWORD *)v3 + 24) = result;
    if (!result)
    {
      result = (_DWORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromArchiveBlobProc", 764, 34, 0, "allocating YAF buffer", v5, v6, v8);
      v7 = v3 + 2;
LABEL_8:
      *v7 = 0;
    }
  }
  return result;
}

unint64_t *archiveTreeFromArchivePayloadProc(unint64_t *result, const void *a2, size_t a3)
{
  unint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  char v7;

  result[2] += a3;
  if (*((_DWORD *)result + 10))
  {
    v4 = result;
    result = *(unint64_t **)(*result + 24);
    if (result)
    {
      result = (unint64_t *)MemBufferFillFromBuffer(result, a3, a2);
      if (result != (unint64_t *)a3)
      {
        result = (unint64_t *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFromArchivePayloadProc", 775, 34, 0, "collecting YAF buffer", v5, v6, v7);
        *((_DWORD *)v4 + 2) = 0;
      }
    }
  }
  return result;
}

uint64_t archiveTreeFromArchivePaddingProc(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 16) += a3;
  return result;
}

unsigned int *ArchiveTreeCreateFromDirectory(char *a1, const __CFArray *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int DefaultNThreads;
  unsigned int *v12;
  unsigned int *v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  const __CFString *ValueAtIndex;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  int v21;
  const char *v22;
  __int16 v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v32;
  stat v33;
  char v34[4];
  int v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  __int128 v42;
  __int128 v43;
  char buffer[1024];
  uint64_t v45;

  DefaultNThreads = a5;
  v45 = *MEMORY[0x24BDAC8D0];
  if (!a5)
    DefaultNThreads = getDefaultNThreads();
  v12 = (unsigned int *)archiveTreeCreate();
  v13 = v12;
  if (!v12)
  {
    v21 = *__error();
    v22 = "archive tree creation";
    v23 = 1323;
LABEL_31:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeCreateFromDirectory", v23, 34, v21, v22, v18, v19, (char)v32);
    ArchiveTreeDestroy((uint64_t)v13);
    return 0;
  }
  if (a2)
  {
    bzero(buffer, 0x400uLL);
    bzero(v34, 0x800uLL);
    Count = CFArrayGetCount(a2);
    if (Count)
    {
      v15 = Count;
      v16 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v16);
        if (!CFStringGetCString(ValueAtIndex, buffer, 1024, 0x8000100u))
        {
          v22 = "getting string from includePaths";
          v23 = 1341;
          goto LABEL_30;
        }
        if ((concatPath(v34, 0x800uLL, a1, buffer) & 0x80000000) != 0)
        {
          v22 = "building full path from includePaths";
          v23 = 1342;
          goto LABEL_30;
        }
        memset(&v33, 0, sizeof(v33));
        if (stat(v34, &v33) || (v33.st_mode & 0xF000) != 0x4000)
        {
          v32 = v34;
          v22 = "include path doesn't exist, or is not a directory: %s";
          v23 = 1346;
          goto LABEL_30;
        }
        v20 = strlen(buffer);
        if (archiveTreeAppend(v13, -1, buffer, v20, -1, -1, 68))
          break;
        if (v15 == ++v16)
          goto LABEL_17;
      }
      v22 = "ArchiveTree append";
      v23 = 1351;
      goto LABEL_30;
    }
  }
  else if (archiveTreeAppend(v12, -1, &unk_206434423, 0, -1, -1, 68))
  {
    v22 = "ArchiveTree append";
    v23 = 1330;
LABEL_30:
    v21 = 0;
    goto LABEL_31;
  }
LABEL_17:
  v24 = *v13;
  if (*v13)
  {
    v25 = 0;
    while (1)
    {
      v40 = v25;
      v41 = v24;
      v25 = v24;
      v42 = 0u;
      v43 = 0u;
      *(_DWORD *)v34 = a6;
      v35 = DefaultNThreads;
      v36 = a1;
      v37 = a3;
      v38 = a4;
      v39 = v13;
      if (expandDirRange((uint64_t)v34))
        break;
      v24 = *v13;
      if (v25 >= *v13)
        goto LABEL_21;
    }
    v22 = "expanding archive tree range";
    v23 = 1370;
    goto LABEL_30;
  }
LABEL_21:
  v42 = 0u;
  v43 = 0u;
  *(_DWORD *)v34 = a6;
  v35 = DefaultNThreads;
  v36 = a1;
  v37 = a3;
  v38 = a4;
  v39 = v13;
  v40 = 0;
  v41 = v24;
  LODWORD(v42) = 1;
  if (expandDirRange((uint64_t)v34))
  {
    v22 = "expanding archive tree range";
    v23 = 1390;
    goto LABEL_30;
  }
  if (archiveTreeSort(v13))
  {
    v22 = "sorting tree";
    v23 = 1394;
    goto LABEL_30;
  }
  archiveTreeUpdateChilds(v13, v26, v27, v28, v29, v30, v18, v19);
  if (a6 > 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12u entries in archive tree\n", *v13);
  return v13;
}

uint64_t expandDirRange(uint64_t a1)
{
  int v1;
  unsigned int v4;
  unsigned int v5;
  int v6;
  uint64_t *v7;
  size_t v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  char *v15;
  int v16;
  char *v17;
  size_t v18;
  int v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _QWORD *v23;
  int v24;
  size_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  _DWORD *v30;
  size_t v31;
  _opaque_pthread_t *v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;
  const char *v36;
  int v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int **v41;
  size_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  char v47;
  char *v48;

  v1 = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 40);
  if (!v1)
    return 0;
  if ((v1 + 999) < 0x3E8)
    v4 = 1;
  else
    v4 = (v1 + 999) / 0x3E8u;
  v6 = *(_DWORD *)a1;
  v5 = *(_DWORD *)(a1 + 4);
  *(_QWORD *)(a1 + 56) = 0;
  v7 = (uint64_t *)(a1 + 56);
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  if ((v1 + 999) / 0x3E8u <= v5)
    v8 = v4;
  else
    v8 = v5;
  v9 = (v1 + (int)v8 - 1) / v8;
  if (v6 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Running %u threads to expand %u nodes (%u per thread)\n", v8, v1, (v1 + (int)v8 - 1) / v8);
  if ((_DWORD)v8 == 1)
  {
    v10 = archiveTreeCreate();
    *v7 = (uint64_t)v10;
    if (v10)
    {
      expandDirRangeThreadProc();
      if (!*(_DWORD *)(a1 + 72))
      {
        v14 = 1000;
        v37 = 0;
        v13 = "expandDirRange";
        goto LABEL_40;
      }
      if (!archiveTreeAppendTree(*(unsigned int **)(a1 + 32), *(unsigned int **)(a1 + 56), 0))
      {
        v24 = 1;
        goto LABEL_49;
      }
      v13 = "append expandDirRange output to main tree";
      v14 = 1003;
    }
    else
    {
      v13 = "archive tree creation";
      v14 = 996;
    }
    v37 = 0;
LABEL_40:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", v14, 34, v37, v13, v11, v12, v47);
    v24 = 0;
    goto LABEL_49;
  }
  v15 = (char *)calloc(v8, 0x50uLL);
  if (!v15)
  {
    v37 = *__error();
    v13 = "malloc";
    v14 = 1009;
    goto LABEL_40;
  }
  v16 = *(_DWORD *)(a1 + 40);
  v48 = v15;
  v17 = v15 + 56;
  v18 = v8;
  do
  {
    if (v16 + v9 >= *(_DWORD *)(a1 + 44))
      v19 = *(_DWORD *)(a1 + 44);
    else
      v19 = v16 + v9;
    v20 = *(_OWORD *)(a1 + 48);
    v21 = *(_OWORD *)(a1 + 64);
    v22 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)(v17 - 24) = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(v17 - 56) = *(_OWORD *)a1;
    *(_OWORD *)(v17 + 8) = v21;
    *(_OWORD *)(v17 - 8) = v20;
    *(_OWORD *)(v17 - 40) = v22;
    *((_DWORD *)v17 - 4) = v16;
    *((_DWORD *)v17 - 3) = v19;
    v23 = archiveTreeCreate();
    *(_QWORD *)v17 = v23;
    if (!v23)
    {
      v38 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", 1022, 34, *v38, "malloc", v39, v40, v47);
      v24 = 0;
      v29 = (uint64_t *)v48;
      goto LABEL_45;
    }
    v17 += 80;
    v16 = v19;
    --v18;
  }
  while (v18);
  v24 = 1;
  v25 = v8;
  v26 = (uint64_t)v48;
  do
  {
    if (createThread((pthread_t *)(v26 + 64), (uint64_t)expandDirRangeThreadProc, v26, 0))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", 1030, 34, 0, "create expandDir thread", v27, v28, v47);
      v24 = 0;
    }
    v26 += 80;
    --v25;
  }
  while (v25);
  v29 = (uint64_t *)v48;
  v30 = v48 + 72;
  v31 = v8;
  do
  {
    v32 = (_opaque_pthread_t *)*((_QWORD *)v30 - 1);
    if (!v32)
      goto LABEL_33;
    if (joinThread(v32))
    {
      v35 = 1037;
      v36 = "join expandDir thread";
LABEL_31:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", v35, 34, 0, v36, v33, v34, v47);
      v24 = 0;
      goto LABEL_33;
    }
    if (!*v30)
    {
      v35 = 1038;
      v36 = "expandDirRange";
      goto LABEL_31;
    }
LABEL_33:
    v30 += 20;
    --v31;
  }
  while (v31);
  v41 = (unsigned int **)(v48 + 56);
  v42 = v8;
  do
  {
    if (archiveTreeAppendTree(*(unsigned int **)(a1 + 32), *v41, 0))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRange", 1044, 34, 0, "append expandDirRange output to main tree", v43, v44, v47);
      v24 = 0;
    }
    v41 += 10;
    --v42;
  }
  while (v42);
LABEL_45:
  v45 = v29 + 7;
  do
  {
    v46 = *v45;
    v45 += 10;
    ArchiveTreeDestroy(v46);
    --v8;
  }
  while (v8);
  free(v29);
LABEL_49:
  ArchiveTreeDestroy(*v7);
  *v7 = 0;
  if (v24)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t ArchiveTreeMergeAndDestroy(uint64_t a1, unsigned int *a2, int a3)
{
  unsigned int v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  BOOL v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  char *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  char *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  __int128 *v31;
  char *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  int v37;
  const char *v38;
  __int16 v39;
  void *v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  char v46;
  int v47;

  if (!a2)
    return 0;
  v6 = *(_DWORD *)a1;
  v7 = *a2;
  v8 = calloc((v7 + *(_DWORD *)a1), 0x38uLL);
  if (!v8)
  {
    v37 = *__error();
    v38 = "malloc";
    v39 = 1435;
    goto LABEL_38;
  }
  if ((_DWORD)v7)
  {
    v9 = (_DWORD *)(*((_QWORD *)a2 + 1) + 40);
    v10 = v7;
    do
    {
      *v9 = a3;
      v9 += 14;
      --v10;
    }
    while (v10);
  }
  if ((archiveTreeAppendTree((unsigned int *)a1, a2, 1) & 0x80000000) != 0)
  {
    v38 = "merging trees";
    v39 = 1441;
    goto LABEL_37;
  }
  if ((archiveTreeSortStringTable((unsigned int **)a1) & 0x80000000) != 0)
  {
    v38 = "sorting string table";
    v39 = 1444;
    goto LABEL_37;
  }
  if ((archiveTreeUpdateDepth((unsigned int *)a1) & 0x80000000) != 0)
  {
    v38 = "storing node depth in AUX";
    v39 = 1447;
    goto LABEL_37;
  }
  v47 = v7 + v6;
  v13 = 0;
  if (v6 | v7)
  {
    v14 = 0;
    v15 = 0;
    v16 = (_DWORD)v7 != 0;
    v17 = v6 != 0;
    while (1)
    {
      if (v16)
      {
        v18 = v14 + v6;
        if (!v17)
          goto LABEL_15;
        v19 = archiveTreeCompareNodesStrRec(a1, v15, v14 + v6, 0, 0);
        if ((v19 & 0x80000000) == 0)
          break;
      }
      v25 = *(_QWORD *)(a1 + 8) + 56 * v15;
      *(_DWORD *)(v25 + 48) = v13;
      v26 = (char *)&v8[14 * v13];
      v27 = *(_OWORD *)v25;
      v28 = *(_OWORD *)(v25 + 16);
      v29 = *(_OWORD *)(v25 + 32);
      *((_QWORD *)v26 + 6) = *(_QWORD *)(v25 + 48);
      *((_OWORD *)v26 + 1) = v28;
      *((_OWORD *)v26 + 2) = v29;
      *(_OWORD *)v26 = v27;
      ++v15;
LABEL_18:
      ++v13;
      v16 = v14 < v7;
      v17 = v15 < v6;
      if (v15 >= v6 && v14 >= v7)
        goto LABEL_25;
    }
    if (v19)
    {
LABEL_15:
      v20 = *(_QWORD *)(a1 + 8) + 56 * v18;
      *(_DWORD *)(v20 + 48) = v13;
      v21 = (char *)&v8[14 * v13];
      v22 = *(_OWORD *)v20;
      v23 = *(_OWORD *)(v20 + 16);
      v24 = *(_OWORD *)(v20 + 32);
      *((_QWORD *)v21 + 6) = *(_QWORD *)(v20 + 48);
      *((_OWORD *)v21 + 1) = v23;
      *((_OWORD *)v21 + 2) = v24;
      *(_OWORD *)v21 = v22;
    }
    else
    {
      v30 = *(_QWORD *)(a1 + 8);
      v31 = (__int128 *)(v30 + 56 * v15);
      *((_DWORD *)v31 + 12) = v13;
      *(_DWORD *)(v30 + 56 * v18 + 48) = v13;
      v32 = (char *)&v8[14 * v13];
      v33 = *v31;
      v34 = v31[1];
      v35 = v31[2];
      *((_QWORD *)v32 + 6) = *((_QWORD *)v31 + 6);
      *((_OWORD *)v32 + 1) = v34;
      *((_OWORD *)v32 + 2) = v35;
      *(_OWORD *)v32 = v33;
      ++v15;
    }
    ++v14;
    goto LABEL_18;
  }
LABEL_25:
  v40 = *(void **)(a1 + 8);
  if (!v47)
  {
LABEL_33:
    free(v40);
    v36 = 0;
    *(_QWORD *)(a1 + 8) = v8;
    *(_DWORD *)a1 = v13;
    *(_DWORD *)(a1 + 4) = v47;
    v8 = 0;
    goto LABEL_39;
  }
  v41 = v7 + v6;
  v42 = *(unsigned int **)(a1 + 8);
  while (1)
  {
    v43 = v42[12];
    if (v43 != -1)
      break;
LABEL_32:
    v42 += 14;
    if (!--v41)
      goto LABEL_33;
  }
  if (v43 < v13)
  {
    v44 = *v42;
    if (*v42 != -1)
      v44 = *((_DWORD *)v40 + 14 * v44 + 12);
    v8[14 * v43] = v44;
    goto LABEL_32;
  }
  v38 = "invalid new index";
  v39 = 1490;
LABEL_37:
  v37 = 0;
LABEL_38:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeMergeAndDestroy", v39, 34, v37, v38, v11, v12, v46);
  v36 = 0xFFFFFFFFLL;
LABEL_39:
  free(v8);
  ArchiveTreeDestroy((uint64_t)a2);
  return v36;
}

uint64_t archiveTreeAppendTree(unsigned int *a1, unsigned int *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t result;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  _DWORD *v16;
  char v17;
  int v18;

  if (!a2)
    return 0;
  if (!*a2)
    return 0;
  if (archiveTreeReserve((uint64_t)a1, *a1 + *a2))
  {
    v8 = "increasing archive tree storage";
    v9 = 164;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeAppendTree", v9, 34, 0, v8, v6, v7, v17);
    return 0xFFFFFFFFLL;
  }
  v18 = 0;
  if ((StringTableAppendTable(*((_QWORD *)a1 + 2), *((unsigned int **)a2 + 2), &v18) & 0x80000000) != 0)
  {
    v8 = "merging string tables";
    v9 = 168;
    goto LABEL_5;
  }
  memcpy((void *)(*((_QWORD *)a1 + 1) + 56 * *a1), *((const void **)a2 + 1), 56 * *a2);
  v11 = *a2;
  v12 = *a1;
  if (*a2)
  {
    v13 = *((_QWORD *)a1 + 1);
    v14 = *a2;
    v15 = *a1;
    do
    {
      v16 = (_DWORD *)(v13 + 56 * v15);
      v16[3] += v18;
      if (a3)
      {
        if (*v16 != -1)
          *v16 += v12;
      }
      ++v15;
      --v14;
    }
    while (v14);
  }
  result = 0;
  *a1 = v12 + v11;
  return result;
}

uint64_t archiveTreeSortStringTable(unsigned int **a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  _DWORD *v5;
  uint64_t v7;
  _DWORD *v8;
  char v9;
  void *v10;

  if (!*(_DWORD *)a1)
    return 0;
  v10 = 0;
  v4 = StringTableSort(a1[2], &v10);
  if (v4)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeSortStringTable", 397, 34, 0, "string table sorting", v2, v3, v9);
    v5 = v10;
  }
  else
  {
    v7 = *(unsigned int *)a1;
    v5 = v10;
    if ((_DWORD)v7)
    {
      v8 = a1[1] + 3;
      do
      {
        *v8 = v5[*v8];
        v8 += 14;
        --v7;
      }
      while (v7);
    }
  }
  free(v5);
  if (v4)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t archiveTreeUpdateDepth(unsigned int *a1)
{
  uint64_t v1;
  _DWORD *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v1 = *a1;
  if (!(_DWORD)v1)
    return 0;
  v3 = (_DWORD *)(*((_QWORD *)a1 + 1) + 44);
  do
  {
    *v3 = -1;
    v3 += 14;
    --v1;
  }
  while (v1);
  v4 = 0;
  while ((archiveTreeUpdateNodeDepth((uint64_t)a1, v4) & 0x80000000) == 0)
  {
    if (++v4 >= *a1)
      return 0;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeUpdateDepth", 218, 34, 0, "update node depth", v5, v6, v8);
  return 0xFFFFFFFFLL;
}

uint64_t ArchiveTreePrune(unsigned int *a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  int v15;
  unint64_t v16;
  unsigned int *v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t i;
  uint64_t v22;
  __int128 *v23;
  unint64_t v24;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t result;
  const char *v31;
  __int16 v32;
  char v33;

  if (!a2)
    return 0;
  if ((archiveTreeUpdateDepth(a1) & 0x80000000) != 0)
  {
    v31 = "updating depth field";
    v32 = 1520;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreePrune", v32, 34, 0, v31, v6, v7, v33);
    return 0xFFFFFFFFLL;
  }
  else
  {
    if (*a1)
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = -1;
      do
      {
        v12 = *((_QWORD *)a1 + 1);
        v13 = *(_DWORD *)(v12 + v8 + 44);
        if (v13 == a2)
        {
          if (v11 != -1)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreePrune", 1530, 34, 0, "invalid prune operation: more than one node at depth %u", v6, v7, a2);
            return 0xFFFFFFFFLL;
          }
          *(_DWORD *)(v12 + v8) = -1;
          if ((StringTableAppend(*((unsigned int **)a1 + 2), &unk_206434423, 0, (_DWORD *)(v12 + v8 + 12), v4, v5, v6, v7) & 0x80000000) != 0)
          {
            v31 = "inserting new root name string";
            v32 = 1536;
            goto LABEL_38;
          }
          v12 = *((_QWORD *)a1 + 1);
          v13 = *(_DWORD *)(v12 + v8 + 44);
          v11 = v9;
        }
        v14 = v13 >= a2;
        if (v13 < a2)
          v15 = -1;
        else
          v15 = v10;
        if (v14)
          ++v10;
        *(_DWORD *)(v12 + v8 + 48) = v15;
        ++v9;
        v16 = *a1;
        v8 += 56;
      }
      while (v9 < v16);
      if (*a1)
      {
        v17 = (unsigned int *)*((_QWORD *)a1 + 1);
        v18 = v17;
        v19 = *a1;
        do
        {
          if (v18[12] != -1 && *v18 != -1)
            *v18 = v17[14 * *v18 + 12];
          v18 += 14;
          --v19;
        }
        while (v19);
        v20 = 0;
        for (i = 0; i < v16; ++i)
        {
          v22 = *((_QWORD *)a1 + 1);
          v23 = (__int128 *)(v22 + v20);
          v24 = *(unsigned int *)(v22 + v20 + 48);
          if ((_DWORD)v24 != -1)
          {
            if (v24 >= v10 || i < v24)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreePackNodes", 424, 34, 0, "invalid new index", v6, v7, v33);
              v31 = "remapping tree nodes";
              v32 = 1543;
              goto LABEL_38;
            }
            if (i > v24)
            {
              v26 = v22 + 56 * v24;
              v27 = *v23;
              v28 = v23[1];
              v29 = v23[2];
              *(_QWORD *)(v26 + 48) = *((_QWORD *)v23 + 6);
              *(_OWORD *)(v26 + 16) = v28;
              *(_OWORD *)(v26 + 32) = v29;
              *(_OWORD *)v26 = v27;
              v16 = *a1;
            }
          }
          v20 += 56;
        }
      }
    }
    else
    {
      v10 = 0;
    }
    result = 0;
    *a1 = v10;
  }
  return result;
}

size_t ArchiveTreeInsert(uint64_t a1, char *__s)
{
  size_t result;
  size_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  char v17;

  if (__s)
    result = strlen(__s);
  else
    result = 0;
  do
  {
    if (!result)
      return result;
    v5 = result - 1;
    v6 = __s[--result];
  }
  while (v6 == 47);
  if ((archiveTreeUpdateDepth((unsigned int *)a1) & 0x80000000) != 0)
  {
    v10 = "updating tree depth";
    v11 = 1572;
    goto LABEL_12;
  }
  if (!*(_DWORD *)a1 || (v9 = *(_DWORD **)(a1 + 8), v9[11]) || *v9 != -1)
  {
    v10 = "invalid input for ArchiveTreeInsert";
    v11 = 1575;
    goto LABEL_12;
  }
  if ((archiveTreeAppend((unsigned int *)a1, -1, &unk_206434423, 0, -1, -1, 68) & 0x80000000) != 0)
  {
    v10 = "inserting root node";
    v11 = 1579;
    goto LABEL_12;
  }
  v14 = 0;
  v15 = 0;
  v16 = *(_DWORD *)a1 - 1;
  while (__s[v14] && __s[v14] != 47)
  {
    ++v14;
LABEL_26:
    if (v14 > v5 + 1)
    {
      archiveTreeSort((_DWORD *)a1);
      return 0;
    }
  }
  if (v14 == v15)
  {
LABEL_25:
    v15 = ++v14;
    goto LABEL_26;
  }
  if (v14 - 1 == v5)
  {
    if ((StringTableAppend(*(unsigned int **)(a1 + 16), &__s[v15], v14 - v15, (_DWORD *)(*(_QWORD *)(a1 + 8) + 12), v12, v13, v7, v8) & 0x80000000) != 0)
    {
      v10 = "inserting string";
      v11 = 1596;
      goto LABEL_12;
    }
    **(_DWORD **)(a1 + 8) = v16;
    goto LABEL_25;
  }
  if ((archiveTreeAppend((unsigned int *)a1, v16, &__s[v15], v14 - v15, -1, -1, 68) & 0x80000000) == 0)
  {
    v16 = *(_DWORD *)a1 - 1;
    goto LABEL_25;
  }
  v10 = "inserting new node";
  v11 = 1603;
LABEL_12:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"ArchiveTreeInsert", v11, 34, 0, v10, v7, v8, v17);
  return 0xFFFFFFFFLL;
}

unsigned int *ArchiveTreeSize(unsigned int *result)
{
  if (result)
    return (unsigned int *)*result;
  return result;
}

size_t ArchiveTreeYAF(size_t result, _BYTE *a2, unint64_t a3)
{
  size_t v3;
  const void *DataPtr;
  size_t DataSize;
  size_t v8;

  *a2 = 0;
  if (result)
  {
    v3 = result;
    result = *(_QWORD *)(result + 24);
    if (result)
    {
      DataPtr = (const void *)MemBufferGetDataPtr(result);
      DataSize = MemBufferGetDataSize(*(_QWORD *)(v3 + 24));
      if (DataSize + 1 <= a3)
      {
        v8 = DataSize;
        memcpy(a2, DataPtr, DataSize);
        a2[v8] = 0;
        return strlen(a2);
      }
      else
      {
        return -1;
      }
    }
  }
  return result;
}

uint64_t ArchiveTreeNodeEntryType(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2)
    return 0;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 56 * a2 + 16);
}

uint64_t ArchiveTreeNodeArchiveID(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2)
    return 0xFFFFFFFFLL;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 56 * a2 + 40);
}

uint64_t ArchiveTreeNodeSegment(uint64_t a1, unsigned int a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t result;

  if (*(_DWORD *)a1 <= a2)
    return 0xFFFFFFFFLL;
  if (a3)
    *a3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 56 * a2 + 24);
  result = 0;
  if (a4)
    *a4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 56 * a2 + 32);
  return result;
}

uint64_t archiveTreeReserve(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v4;
  void *v5;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2)
    return 0;
  v4 = v2 ? v2 + (v2 >> 1) : 256;
  if (v4 <= a2)
    v4 = a2;
  *(_DWORD *)(a1 + 4) = v4;
  v5 = reallocf(*(void **)(a1 + 8), 56 * v4);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
    return 0;
  v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeReserve", 122, 34, *v7, "malloc", v8, v9, v10);
  *(_QWORD *)a1 = 0;
  return 0xFFFFFFFFLL;
}

uint64_t archiveTreeFindPath(uint64_t a1, const char *a2, unsigned int *a3)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  __int16 v15;
  char v16;
  char __s1[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  bzero(__s1, 0x400uLL);
  if (!*(_DWORD *)a1)
    return 0;
  v6 = *(_DWORD *)a1 - 1;
  while (1)
  {
    if (ArchiveTreeNodePath(a1, v6, (uint64_t)__s1, 0x400uLL) < 0)
    {
      v15 = 243;
      goto LABEL_19;
    }
    v9 = strcmp(__s1, a2);
    if (!v9)
    {
      v12 = v6;
LABEL_21:
      if (a3)
        *a3 = v12;
      return 1;
    }
    if (v9 < 0)
      break;
    v6 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56 * v6);
    if (v6 == -1)
    {
      v6 = 0;
      break;
    }
  }
  v10 = *(_DWORD *)a1 - v6;
  if (v10 < 2)
    return 0;
  v11 = v10 >> 1;
  while (1)
  {
    v12 = v6 + v11;
    if (v6 + v11 < *(_DWORD *)a1)
      break;
    v11 >>= 1;
LABEL_16:
    if (!v11)
      return 0;
  }
  if ((ArchiveTreeNodePath(a1, v6 + v11, (uint64_t)__s1, 0x400uLL) & 0x8000000000000000) == 0)
  {
    v13 = strcmp(__s1, a2);
    if (!v13)
      goto LABEL_21;
    v11 >>= v13 > 0;
    if (v13 <= 0)
      v6 = v12;
    goto LABEL_16;
  }
  v15 = 262;
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeFindPath", v15, 34, 0, "invalid path", v7, v8, v16);
  return 0xFFFFFFFFLL;
}

uint64_t archiveTreeCompareNodesLexProc(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return archiveTreeCompareNodesLex(a1, *a2, *a3);
}

uint64_t archiveTreeRemapNodes(unsigned int *a1, size_t __count)
{
  unsigned int v2;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  char *v14;
  char *v15;
  _QWORD *v16;
  uint64_t v17;
  char *v18;
  _QWORD *v19;
  uint64_t v20;
  char *v21;
  _DWORD *v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t result;
  int v27;
  const char *v28;
  __int16 v29;
  char v30;
  char v31[1024];
  uint64_t v32;

  v2 = __count;
  v32 = *MEMORY[0x24BDAC8D0];
  v4 = __count;
  v5 = (char *)calloc(__count, 0x38uLL);
  v8 = v5;
  if (v5)
  {
    if (v2)
    {
      v9 = v5 + 12;
      do
      {
        *((_DWORD *)v9 - 3) = -1;
        *(_DWORD *)v9 = -1;
        *(_QWORD *)(v9 + 12) = -1;
        *(_QWORD *)(v9 + 20) = -1;
        v9 += 56;
        --v4;
      }
      while (v4);
    }
    v10 = *a1;
    if ((_DWORD)v10)
    {
      v11 = *((_QWORD *)a1 + 1);
      v12 = v11 + 24;
      do
      {
        v13 = *(_DWORD *)(v12 + 24);
        if (v13 > v2)
        {
          v28 = "invalid new node index";
          v29 = 458;
          v27 = 0;
          goto LABEL_25;
        }
        v14 = &v5[56 * v13];
        if (!*((_DWORD *)v14 + 4))
          *((_DWORD *)v14 + 4) = *(_DWORD *)(v12 - 8);
        v15 = &v5[56 * v13];
        v17 = *((_QWORD *)v15 + 3);
        v16 = v15 + 24;
        if (v17 == -1)
          *v16 = *(_QWORD *)v12;
        v18 = &v5[56 * v13];
        v20 = *((_QWORD *)v18 + 4);
        v19 = v18 + 32;
        if (v20 == -1)
          *v19 = *(_QWORD *)(v12 + 8);
        v21 = &v5[56 * v13];
        v23 = *((_DWORD *)v21 + 3);
        v22 = v21 + 12;
        if (v23 == -1)
          *v22 = *(_DWORD *)(v12 - 12);
        if (*(_DWORD *)v14 == -1)
        {
          v24 = *(_DWORD *)(v12 - 24);
          if (v24 != -1)
            *(_DWORD *)v14 = *(_DWORD *)(v11 + 56 * v24 + 48);
        }
        v12 += 56;
        --v10;
      }
      while (v10);
      v25 = 0;
      do
        ArchiveTreeNodePath((uint64_t)a1, v25++, (uint64_t)v31, 0x400uLL);
      while (v25 < *a1);
    }
    free(*((void **)a1 + 1));
    result = 0;
    *((_QWORD *)a1 + 1) = v8;
    *a1 = v2;
    a1[1] = v2;
  }
  else
  {
    v27 = *__error();
    v28 = "malloc";
    v29 = 443;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeRemapNodes", v29, 34, v27, v28, v6, v7, v30);
    free(v8);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t archiveTreeCompareNodesStrProc(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return archiveTreeCompareNodesStrRec(a1, *a2, *a3, 0, 0);
}

uint64_t archiveTreeCompareNodesLex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  _BOOL4 v15;
  char v16[1024];
  char v17[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a2 == (_DWORD)a3)
    return 0;
  if ((_DWORD)a2 == -1)
    return 0xFFFFFFFFLL;
  v4 = a3;
  if ((_DWORD)a3 == -1)
    return 1;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2;
  v8 = *(_DWORD *)(v6 + 56 * a2 + 44);
  v9 = (unsigned int *)(v6 + 56 * a3);
  v10 = v9[11];
  if (v8 <= v10)
  {
    if (v10 <= v8)
    {
      v11 = a3;
      ArchiveTreeNodePath(a1, a2, (uint64_t)v17, 0x400uLL);
      ArchiveTreeNodePath(a1, v4, (uint64_t)v16, 0x400uLL);
      if (!v8
        || (result = archiveTreeCompareNodesLex(a1, *(unsigned int *)(*(_QWORD *)(a1 + 8) + 56 * v7), *(unsigned int *)(*(_QWORD *)(a1 + 8) + 56 * v11)), !(_DWORD)result))
      {
        v12 = *(_QWORD *)(a1 + 8);
        v13 = *(_DWORD *)(v12 + 56 * v7 + 12);
        LODWORD(v12) = *(_DWORD *)(v12 + 56 * v11 + 12);
        v14 = v13 >= v12;
        v15 = v13 > v12;
        if (v14)
          return v15;
        else
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      LODWORD(result) = archiveTreeCompareNodesLex(a1, a2, *v9);
      if ((_DWORD)result)
        return result;
      else
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    LODWORD(result) = archiveTreeCompareNodesLex(a1, *(unsigned int *)(v6 + 56 * a2), a3);
    if (result <= 1)
      return 1;
    else
      return result;
  }
  return result;
}

uint64_t expandDirRangeThreadProc()
{
  uint64_t v0;
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  const char *v5;
  int (*v6)(uint64_t, char *, uint64_t);
  size_t v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  DIR *v15;
  DIR *v16;
  size_t v17;
  char *v18;
  char *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  size_t d_namlen;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t AAEntryType;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  __int16 v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  int v47;
  char v49;
  unsigned int *v50;
  char *v51;
  int v52;
  uint64_t v53;
  stat v54;
  dirent *v55;
  stat v56;
  char __s[1024];
  dirent v58;
  char v59[2048];
  uint64_t v60;

  v0 = MEMORY[0x24BDAC7A8]();
  v60 = *MEMORY[0x24BDAC8D0];
  bzero(__s, 0x400uLL);
  *(_DWORD *)(v0 + 72) = 1;
  v1 = *(_DWORD *)(v0 + 40);
  if (v1 >= *(_DWORD *)(v0 + 44))
    return v0;
LABEL_2:
  if (ArchiveTreeNodePath(*(_QWORD *)(v0 + 32), v1, (uint64_t)__s, 0x400uLL) < 0)
  {
    v38 = "path too long";
    v39 = 960;
    goto LABEL_68;
  }
  v4 = *(unsigned int **)(v0 + 56);
  v52 = *(_DWORD *)(v0 + 48);
  v5 = *(const char **)(v0 + 8);
  v6 = *(int (**)(uint64_t, char *, uint64_t))(v0 + 16);
  v53 = *(_QWORD *)(v0 + 24);
  v7 = strlen(v5);
  v8 = strlen(__s);
  __memcpy_chk();
  v59[v7] = 0;
  if (v8)
  {
    if (v7 + v8 - 2047 <= 0xFFFFFFFFFFFFF7FFLL)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 812, 34, 0, "path too long: %s/%s", v9, v10, (char)v5);
      goto LABEL_67;
    }
    v59[v7] = 47;
    memcpy(&v59[v7 + 1], __s, v8);
    v11 = v8 + v7 + 1;
    v59[v11] = 0;
  }
  else
  {
    v11 = v7;
  }
  memset(&v56, 0, sizeof(v56));
  if (lstat(v59, &v56) < 0)
  {
    v40 = *__error();
    v43 = "lstat %s";
    v44 = 822;
    goto LABEL_66;
  }
  if (statIsDataless(v56.st_flags))
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 828, 34, "skip dataless dir: %s", v12, v13, v14, (char)v59);
    goto LABEL_57;
  }
  v15 = opendir(v59);
  if (v15)
  {
    v16 = v15;
    v50 = v4;
    v17 = v11 + 1;
    v18 = &v59[v11];
    memset(&v58, 0, 512);
    v19 = &v59[v11 + 1];
    v51 = &v59[v7 + 1];
    v20 = 1;
    v55 = 0;
    while (1)
    {
      if (!v20)
        goto LABEL_64;
      if (readdir_r(v16, &v58, &v55))
      {
        if (*__error() == 11)
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 845, 34, "readdir on dataless directory: %s", v35, v36, v37, (char)v59);
LABEL_55:
          closedir(v16);
          goto LABEL_57;
        }
        v47 = *__error();
        v45 = "readdir_r";
        v46 = 846;
        goto LABEL_63;
      }
      if (!v55)
        goto LABEL_55;
      d_namlen = v58.d_namlen;
      if ((v58.d_namlen != 1 || v58.d_name[0] != 46)
        && (v58.d_namlen != 2 || v58.d_name[0] != 46 || v58.d_name[1] != 46))
      {
        if (v17 + v58.d_namlen >= 0x800)
        {
          v45 = "path too long";
          v46 = 865;
          v47 = 0;
LABEL_63:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", v46, 34, v47, v45, v21, v22, v49);
LABEL_64:
          closedir(v16);
          goto LABEL_67;
        }
        *v18 = 47;
        memcpy(v19, v58.d_name, d_namlen);
        v59[v17 + d_namlen] = 0;
        memset(&v54, 0, sizeof(v54));
        if (lstat(v59, &v54))
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 872, 34, "stat failed: %s", v24, v25, v26, (char)v59);
        }
        else
        {
          if ((v54.st_mode & 0xF000) == 0x4000 && v54.st_dev != v56.st_dev)
          {
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 877, 34, "skip mounted dir: %s", v24, v25, v26, (char)v59);
          }
          else
          {
            if (!statIsDataless(v54.st_flags))
            {
              v30 = 68;
              AAEntryType = 70;
              switch(v58.d_type)
              {
                case 0u:
                  AAEntryType = getAAEntryType(v54.st_mode);
                  if ((_DWORD)AAEntryType)
                    goto LABEL_41;
                  goto LABEL_29;
                case 1u:
                  AAEntryType = 80;
                  goto LABEL_41;
                case 2u:
                  AAEntryType = 67;
                  goto LABEL_41;
                case 4u:
                  goto LABEL_45;
                case 6u:
                  AAEntryType = 66;
                  goto LABEL_41;
                case 8u:
                  goto LABEL_41;
                case 0xAu:
                  AAEntryType = 76;
                  goto LABEL_41;
                case 0xCu:
                  AAEntryType = 83;
LABEL_41:
                  if (v52)
                  {
                    v30 = AAEntryType;
                  }
                  else
                  {
                    v30 = AAEntryType;
                    if ((_DWORD)AAEntryType != 68)
                      goto LABEL_33;
                  }
LABEL_45:
                  if (v52 == 1 && (_DWORD)v30 == 68 || v6 && v6(v53, v51, v30) < 1)
                    goto LABEL_33;
                  if (archiveTreeAppend(v50, v1, v58.d_name, d_namlen, -1, -1, v30))
                  {
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 920, 34, 0, "ArchiveTree append", v33, v34, v49);
LABEL_51:
                    v20 = 0;
                    v32 = 11;
                  }
                  else
                  {
                    v32 = 0;
                    *v18 = 0;
                    v20 = 1;
                  }
                  break;
                default:
LABEL_29:
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 910, 34, 0, "invalid entry type: %s", v28, v29, (char)v59);
                  goto LABEL_51;
              }
              goto LABEL_34;
            }
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", 888, 34, "skip dataless: %s", v27, v28, v29, (char)v59);
          }
          if (v6)
            v6(v53, v51, 0);
        }
      }
LABEL_33:
      v20 = 1;
      v32 = 10;
LABEL_34:
      if (v32 == 11)
      {
        closedir(v16);
        if (!v20)
          goto LABEL_67;
LABEL_57:
        if (++v1 >= *(_DWORD *)(v0 + 44))
          return v0;
        goto LABEL_2;
      }
    }
  }
  v40 = *__error();
  v43 = "opendir %s";
  v44 = 835;
LABEL_66:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDir", v44, 34, v40, v43, v41, v42, (char)v59);
LABEL_67:
  v38 = "expand directory";
  v39 = 961;
LABEL_68:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"expandDirRangeThreadProc", v39, 34, 0, v38, v2, v3, v49);
  *(_DWORD *)(v0 + 72) = 0;
  return v0;
}

uint64_t archiveTreeUpdateNodeDepth(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  int v6;
  uint64_t result;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  char v12;

  if (*(_DWORD *)a1 <= a2)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = v3 + 56 * a2;
  v6 = *(_DWORD *)(v4 + 44);
  v5 = (_DWORD *)(v4 + 44);
  if (v6 != -1)
    return 0;
  v9 = *(_DWORD *)(v3 + 56 * a2);
  if (v9 != -1)
  {
    if ((archiveTreeUpdateNodeDepth(a1, *(unsigned int *)(v3 + 56 * a2)) & 0x80000000) == 0)
    {
      result = 0;
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56 * a2 + 44) = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 56 * v9 + 44) + 1;
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveTree.c", (uint64_t)"archiveTreeUpdateNodeDepth", 198, 34, 0, "update parent depth", v10, v11, v12);
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8) + 16 * *(unsigned int *)(v3 + 56 * a2 + 12) + 8))
  {
    result = 0;
    *v5 = 1;
  }
  else
  {
    result = 0;
    *v5 = 0;
  }
  return result;
}

uint64_t archiveTreeCompareNodesStrRec(uint64_t a1, unsigned int a2, unsigned int a3, char a4, char a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  char v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  _BYTE *v22;
  _BYTE *v23;

  v7 = a3;
  v8 = a2;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_DWORD *)(v9 + 56 * a2 + 44);
  v11 = *(_DWORD *)(v9 + 56 * a3 + 44);
  if (v10 <= v11)
  {
    v12 = a4;
    if (v11 > v10)
    {
      do
      {
        LODWORD(v7) = *(_DWORD *)(v9 + 56 * v7);
        --v11;
      }
      while (v11 > v10);
      a5 = 47;
    }
    v11 = *(_DWORD *)(v9 + 56 * a2 + 44);
  }
  else
  {
    do
    {
      LODWORD(v8) = *(_DWORD *)(v9 + 56 * v8);
      --v10;
    }
    while (v10 > v11);
    v12 = 47;
  }
  if (v11 < 2
    || (result = archiveTreeCompareNodesStrRec(a1, *(unsigned int *)(v9 + 56 * v8), *(unsigned int *)(v9 + 56 * v7), 47, 47), !(_DWORD)result))
  {
    v14 = *(unsigned int *)(v9 + 56 * v8 + 12);
    v15 = *(_QWORD *)(a1 + 16);
    v16 = *(_QWORD *)(v15 + 8);
    v17 = *(unsigned int *)(v16 + 16 * v14 + 8);
    v18 = *(unsigned int *)(v9 + 56 * v7 + 12);
    v19 = *(unsigned int *)(v16 + 16 * v18 + 8);
    if ((_DWORD)v17 == (_DWORD)v19)
    {
      if (v14 < v18)
        v20 = -1;
      else
        v20 = 1;
      if ((_DWORD)v14 == (_DWORD)v18)
        return v12 - a5;
      else
        return v20;
    }
    else
    {
      v21 = *(_QWORD *)(v15 + 32);
      v22 = (_BYTE *)(v21 + *(_QWORD *)(v16 + 16 * v14));
      v23 = (_BYTE *)(v21 + *(_QWORD *)(v16 + 16 * v18));
      if (v17 >= v19)
      {
        v12 = v22[v19];
        v17 = *(unsigned int *)(v16 + 16 * v18 + 8);
      }
      else
      {
        a5 = v23[v17];
      }
      LODWORD(result) = memcmp(v22, v23, v17);
      if ((_DWORD)result)
        return result;
      else
        return (v12 - a5);
    }
  }
  return result;
}

uint64_t aaByteStreamSimulate(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = (uint64_t (*)(_QWORD))a1[11];
  if (v1)
    return v1(*a1);
  else
    return -1;
}

ssize_t AAByteStreamWrite(AAByteStream s, const void *buf, size_t nbyte)
{
  uint64_t (*v3)(_QWORD, const void *, size_t);

  v3 = (uint64_t (*)(_QWORD, const void *, size_t))*((_QWORD *)s + 3);
  if (v3)
    return v3(*(_QWORD *)s, buf, nbyte);
  else
    return -1;
}

uint64_t aaFileStreamGetFD(unsigned int **a1)
{
  uint64_t (*v1)(int *);

  v1 = (uint64_t (*)(int *))a1[1];
  if (v1 == aaFileStreamClose || (char *)v1 == (char *)aaTempFileStreamClose)
    return **a1;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aaFileStreamClose(int *a1)
{
  int v2;

  if (a1)
  {
    if (a1[1])
    {
      v2 = *a1;
      if ((v2 & 0x80000000) == 0)
        close(v2);
    }
    free(a1);
  }
  return 0;
}

uint64_t aaTempFileStreamClose(char *a1)
{
  int v2;

  if (a1)
  {
    v2 = *(_DWORD *)a1;
    if ((v2 & 0x80000000) == 0)
    {
      close(v2);
      unlink(a1 + 12);
    }
    free(a1);
  }
  return 0;
}

ssize_t AAByteStreamPWrite(AAByteStream s, const void *buf, size_t nbyte, off_t offset)
{
  uint64_t (*v4)(_QWORD, const void *, size_t, off_t);

  v4 = (uint64_t (*)(_QWORD, const void *, size_t, off_t))*((_QWORD *)s + 5);
  if (v4)
    return v4(*(_QWORD *)s, buf, nbyte, offset);
  else
    return -1;
}

ssize_t AAByteStreamRead(AAByteStream s, void *buf, size_t nbyte)
{
  uint64_t (*v3)(_QWORD, void *, size_t);

  v3 = (uint64_t (*)(_QWORD, void *, size_t))*((_QWORD *)s + 2);
  if (v3)
    return v3(*(_QWORD *)s, buf, nbyte);
  else
    return -1;
}

ssize_t AAByteStreamPRead(AAByteStream s, void *buf, size_t nbyte, off_t offset)
{
  uint64_t (*v4)(_QWORD, void *, size_t, off_t);

  v4 = (uint64_t (*)(_QWORD, void *, size_t, off_t))*((_QWORD *)s + 4);
  if (v4)
    return v4(*(_QWORD *)s, buf, nbyte, offset);
  else
    return -1;
}

off_t AAByteStreamSeek(AAByteStream s, off_t offset, int whence)
{
  uint64_t (*v3)(_QWORD, off_t, _QWORD);

  v3 = (uint64_t (*)(_QWORD, off_t, _QWORD))*((_QWORD *)s + 6);
  if (v3)
    return v3(*(_QWORD *)s, offset, *(_QWORD *)&whence);
  else
    return -1;
}

void AAByteStreamCancel(AAByteStream s)
{
  void (*v1)(_QWORD);

  v1 = (void (*)(_QWORD))*((_QWORD *)s + 7);
  if (v1)
    v1(*(_QWORD *)s);
}

int AAByteStreamClose(AAByteStream s)
{
  int v2;

  if (!s)
    return 0;
  if (*(_QWORD *)s)
    v2 = (*((uint64_t (**)(void))s + 1))();
  else
    v2 = 0;
  free(s);
  return v2;
}

uint64_t AAByteStreamFlush(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = (uint64_t (*)(_QWORD))a1[9];
  if (v1)
    return v1(*a1);
  else
    return 0xFFFFFFFFLL;
}

uint64_t AAByteStreamTruncate(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = (uint64_t (*)(_QWORD))a1[8];
  if (v1)
    return v1(*a1);
  else
    return 0xFFFFFFFFLL;
}

AAByteStream AAFileStreamOpenWithFD(int fd, int automatic_close)
{
  _QWORD *v4;
  _DWORD *v5;
  void *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v11;

  v4 = calloc(1uLL, 0x68uLL);
  v5 = malloc(0xCuLL);
  v6 = v5;
  if (v5 && v4)
  {
    *v5 = fd;
    v5[1] = automatic_close;
    v5[2] = 0;
    *v4 = v5;
    v4[1] = aaFileStreamClose;
    v4[2] = aaFileStreamRead;
    v4[3] = aaFileStreamWrite;
    v4[4] = aaFileStreamPRead;
    v4[5] = aaFileStreamPWrite;
    v4[6] = aaFileStreamSeek;
    v4[7] = aaFileStreamAbort;
    v4[8] = aaFileStreamTruncate;
    v4[9] = aaFileStreamFlush;
  }
  else
  {
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AAFileStreamOpenWithFD", 402, 17, *v7, "malloc", v8, v9, v11);
    free(v4);
    free(v6);
    return 0;
  }
  return (AAByteStream)v4;
}

uint64_t aaFileStreamRead(int *a1, void *a2, size_t a3)
{
  ssize_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a1[2])
    return -1;
  v3 = read(*a1, a2, a3);
  if (v3 < 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamRead", 92, 17, "aaFileStreamRead err=%zd buf=%p n=%zu", v4, v5, v6, v3);
  return v3;
}

uint64_t aaFileStreamWrite(int *a1, const void *a2, size_t a3)
{
  ssize_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a1[2])
    return -1;
  v3 = write(*a1, a2, a3);
  if (v3 < 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamWrite", 104, 17, "aaFileStreamWrite err=%zd buf=%p n=%zu", v4, v5, v6, v3);
  return v3;
}

uint64_t aaFileStreamPRead(int *a1, void *a2, size_t a3, off_t a4)
{
  ssize_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2])
    return -1;
  v4 = pread(*a1, a2, a3, a4);
  if (v4 < 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamPRead", 116, 17, "aaFileStreamPRead err=%zd buf=%p n=%zu off=%llu", v5, v6, v7, v4);
  return v4;
}

uint64_t aaFileStreamPWrite(int *a1, const void *a2, size_t a3, off_t a4)
{
  ssize_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2])
    return -1;
  v4 = pwrite(*a1, a2, a3, a4);
  if (v4 < 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamPWrite", 128, 17, "aaFileStreamPWrite err=%zd buf=%p n=%zu off=%llu", v5, v6, v7, v4);
  return v4;
}

uint64_t aaFileStreamAbort(uint64_t result)
{
  *(_DWORD *)(result + 8) = 1;
  return result;
}

off_t aaFileStreamSeek(int *a1, off_t a2, int a3)
{
  if (a1[2])
    return -1;
  else
    return lseek(*a1, a2, a3);
}

uint64_t aaFileStreamTruncate(int *a1, off_t a2)
{
  if (a1[2])
    return 0xFFFFFFFFLL;
  else
    return ftruncate(*a1, a2);
}

uint64_t aaFileStreamFlush(int *a1)
{
  uint64_t result;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char vars0;

  if (!a1[2])
  {
    result = fsync(*a1);
    if (!(_DWORD)result)
      return result;
    v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"aaFileStreamFlush", 151, 17, *v2, "fsync", v3, v4, vars0);
  }
  return 0xFFFFFFFFLL;
}

AAByteStream AAFileStreamOpenWithPath(const char *path, int open_flags, mode_t open_mode)
{
  char v3;
  int v4;
  int v5;
  AAByteStream result;
  int *v7;
  uint64_t v8;
  uint64_t v9;

  v3 = (char)path;
  v4 = open(path, open_flags, open_mode);
  if (v4 < 0)
  {
    v7 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AAFileStreamOpenWithPath", 428, 17, *v7, "open: %s", v8, v9, v3);
  }
  else
  {
    v5 = v4;
    result = AAFileStreamOpenWithFD(v4, 1);
    if (result)
      return result;
    close(v5);
  }
  return 0;
}

_QWORD *AATempFileStreamOpenWithDirectory(const char *a1)
{
  _QWORD *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  __int16 v8;
  int v9;
  int v10;
  char v12;
  stat v13;

  v2 = calloc(1uLL, 0x68uLL);
  v3 = (char *)malloc(0x40CuLL);
  v4 = v3;
  if (!v2 || !v3)
  {
    v9 = *__error();
    v7 = "malloc";
    v8 = 447;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAByteStream.c", (uint64_t)"AATempFileStreamOpenWithDirectory", v8, 17, v9, v7, v5, v6, v12);
    free(v2);
    free(v4);
    return 0;
  }
  memset_s(v3, 0x40CuLL, 0, 0x40CuLL);
  if (a1)
  {
    memset(&v13, 0, sizeof(v13));
    if (!realpath_DARWIN_EXTSN(a1, v4 + 12) || stat(v4 + 12, &v13) || (v13.st_mode & 0xF000) != 0x4000)
    {
      v12 = (char)a1;
      v7 = "invalid temp_dir: %s";
      v8 = 457;
LABEL_15:
      v9 = 0;
      goto LABEL_16;
    }
  }
  else if ((getTempDir(v4 + 12, 0x400uLL) & 0x80000000) != 0)
  {
    v7 = "get temp dir";
    v8 = 462;
    goto LABEL_15;
  }
  if ((unint64_t)__strlcat_chk() >= 0x400)
  {
    v12 = (_BYTE)v4 + 12;
    v7 = "Invalid temp dir path: %s";
    v8 = 464;
    goto LABEL_15;
  }
  v10 = mkostemp(v4 + 12, 0x1000000);
  *(_DWORD *)v4 = v10;
  if (v10 < 0)
  {
    v9 = *__error();
    v7 = "mkostemp";
    v8 = 466;
    goto LABEL_16;
  }
  *v2 = v4;
  v2[1] = aaTempFileStreamClose;
  v2[2] = aaFileStreamRead;
  v2[3] = aaFileStreamWrite;
  v2[4] = aaFileStreamPRead;
  v2[5] = aaFileStreamPWrite;
  v2[6] = aaFileStreamSeek;
  v2[7] = aaFileStreamAbort;
  v2[8] = aaFileStreamTruncate;
  v2[9] = aaFileStreamFlush;
  return v2;
}

AAByteStream AADecompressionInputStreamOpen(AAByteStream compressed_stream, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)aaSequentialDecompressionIStreamOpen((uint64_t)compressed_stream, n_threads);
}

void AACustomByteStreamSetData(AAByteStream s, void *data)
{
  *(_QWORD *)s = data;
}

void AACustomByteStreamSetCloseProc(AAByteStream s, AAByteStreamCloseProc proc)
{
  *((_QWORD *)s + 1) = proc;
}

void AACustomByteStreamSetReadProc(AAByteStream s, AAByteStreamReadProc proc)
{
  *((_QWORD *)s + 2) = proc;
}

void AACustomByteStreamSetPReadProc(AAByteStream s, AAByteStreamPReadProc proc)
{
  *((_QWORD *)s + 4) = proc;
}

void AACustomByteStreamSetWriteProc(AAByteStream s, AAByteStreamWriteProc proc)
{
  *((_QWORD *)s + 3) = proc;
}

void AACustomByteStreamSetPWriteProc(AAByteStream s, AAByteStreamPWriteProc proc)
{
  *((_QWORD *)s + 5) = proc;
}

void AACustomByteStreamSetSeekProc(AAByteStream s, AAByteStreamSeekProc proc)
{
  *((_QWORD *)s + 6) = proc;
}

void AACustomByteStreamSetCancelProc(AAByteStream s, AAByteStreamCancelProc proc)
{
  *((_QWORD *)s + 7) = proc;
}

size_t PCompressLZBITMAPEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZBITMAP);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZBITMAPDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZBITMAP);
  if (!result)
    return -1;
  return result;
}

size_t IZeroStreamRead(int a1, void *a2, size_t a3)
{
  bzero(a2, a3);
  return a3;
}

uint64_t ONullStreamWrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

_QWORD *OSHA1StreamCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  char v12;

  v6 = malloc(0x80uLL);
  v7 = v6;
  if (v6)
  {
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)v6);
    v7[13] = a1;
    v7[14] = a2;
    v7[15] = a3;
  }
  else
  {
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OSHA1StreamCreate", 76, 29, *v8, "malloc", v9, v10, v12);
  }
  return v7;
}

void OSHA1StreamDestroy(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  if (c)
  {
    CC_SHA1_Deprecated_Final(md, c);
    free(c);
  }
}

uint64_t OSHA1StreamWrite(CC_SHA1_CTX *c, const void *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t (*v7)(_QWORD, const void *, uint64_t);

  if (!c || c[1].h0)
    return -1;
  v4 = a3;
  CC_SHA1_Deprecated_Update(c, a2, a3);
  v7 = *(uint64_t (**)(_QWORD, const void *, uint64_t))&c[1].h2;
  if (!v7)
    return v4;
  return v7(*(_QWORD *)&c[1].Nh, a2, v4);
}

uint64_t OSHA1StreamAbort(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD);

  if (result)
  {
    v1 = result;
    v2 = *(uint64_t (**)(_QWORD))(result + 112);
    if (v2)
      result = v2(*(_QWORD *)(result + 120));
    *(_DWORD *)(v1 + 96) = 1;
  }
  return result;
}

uint64_t *IMagicStreamCreate(uint64_t (*a1)(uint64_t, uint64_t *, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  v8 = a4 + 48;
  v9 = (uint64_t *)malloc(a4 + 48);
  v10 = v9;
  if (v9)
  {
    bzero(v9, v8);
    v11 = a1(a3, v10 + 6, a4);
    if (v11 < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMagicStreamCreate", 138, 29, 0, "reading magic", v12, v13, v18);
      free(v10);
      return 0;
    }
    else
    {
      *v10 = v11;
      v10[1] = v11;
      v10[3] = (uint64_t)a1;
      v10[4] = a2;
      v10[5] = a3;
    }
  }
  else
  {
    v14 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMagicStreamCreate", 133, 29, *v14, "malloc", v15, v16, v18);
  }
  return v10;
}

uint64_t IMagicStreamGetMagic(uint64_t a1)
{
  return a1 + 48;
}

uint64_t IMagicStreamGetMagicSize(uint64_t a1)
{
  return *(_QWORD *)a1;
}

size_t IMagicStreamRead(uint64_t a1, char *__dst, size_t a3)
{
  size_t v4;
  size_t v8;
  uint64_t v9;

  if (!a1 || *(_DWORD *)(a1 + 16))
    return -1;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    if (v8 >= a3)
      v4 = a3;
    else
      v4 = *(_QWORD *)(a1 + 8);
    memcpy(__dst, (const void *)(a1 + *(_QWORD *)a1 - v8 + 48), v4);
    *(_QWORD *)(a1 + 8) -= v4;
    if (v8 < a3)
    {
      v9 = (*(uint64_t (**)(_QWORD, char *, size_t))(a1 + 24))(*(_QWORD *)(a1 + 40), &__dst[v4], a3 - v4);
      if (v9 < 0)
        return -1;
      else
        v4 += v9;
    }
    return v4;
  }
  return (*(uint64_t (**)(_QWORD, char *, size_t))(a1 + 24))(*(_QWORD *)(a1 + 40), __dst, a3);
}

uint64_t IMagicStreamAbort(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD);

  if (result)
  {
    v1 = result;
    v2 = *(uint64_t (**)(_QWORD))(result + 32);
    if (v2)
      result = v2(*(_QWORD *)(result + 40));
    *(_DWORD *)(v1 + 16) = 1;
  }
  return result;
}

uint64_t IFileStreamCreateWithFilename(const char *a1, unint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  int v14;
  int v16;
  char v17;

  v6 = (char *)malloc(0x70uLL);
  v7 = (uint64_t)v6;
  if (v6)
  {
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *((_QWORD *)v6 + 13) = 0;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    v8 = (pthread_mutex_t *)(v6 + 40);
    *(_QWORD *)v7 = 0x1FFFFFFFFLL;
    v9 = a2 + a3;
    if (__CFADD__(a2, a3))
      v9 = -1;
    *(_QWORD *)(v7 + 16) = a2;
    *(_QWORD *)(v7 + 24) = v9;
    if (pthread_mutex_init(v8, 0))
    {
      v12 = "pthread_mutex_init";
      v13 = 293;
    }
    else
    {
      v16 = open(a1, 0);
      *(_DWORD *)v7 = v16;
      if (v16 < 0)
      {
        v14 = *__error();
        v17 = (char)a1;
        v12 = "%s";
        v13 = 297;
        goto LABEL_9;
      }
      clampIfRegularFile(v7);
      if ((seekTo(v7, a2) & 0x80000000) == 0)
        return v7;
      v12 = "seek error";
      v13 = 303;
    }
    v14 = 0;
  }
  else
  {
    v14 = *__error();
    v12 = "malloc";
    v13 = 282;
  }
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamCreateWithFilename", v13, 29, v14, v12, v10, v11, v17);
  IFileStreamDestroy((char *)v7);
  return 0;
}

uint64_t clampIfRegularFile(uint64_t a1)
{
  uint64_t result;
  unint64_t st_size;
  stat v4;

  memset(&v4, 0, sizeof(v4));
  result = fstat(*(_DWORD *)a1, &v4);
  if (!(_DWORD)result && (v4.st_mode & 0xF000) == 0x8000)
  {
    st_size = v4.st_size;
    if (*(_QWORD *)(a1 + 16) > v4.st_size)
      *(_QWORD *)(a1 + 16) = v4.st_size;
    if (*(_QWORD *)(a1 + 24) > st_size)
      *(_QWORD *)(a1 + 24) = st_size;
  }
  return result;
}

uint64_t seekTo(uint64_t a1, unint64_t a2)
{
  off_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  const char *v9;
  __int16 v10;
  int v11;
  void *v12;
  void *i;
  size_t v14;
  ssize_t v15;
  char v16;

  if (*(_QWORD *)(a1 + 32) == a2)
    return 0;
  v4 = lseek(*(_DWORD *)a1, a2, 0);
  if ((v4 & 0x8000000000000000) == 0)
  {
    v7 = v4;
    *(_QWORD *)(a1 + 32) = v4;
LABEL_4:
    if (v7 == a2)
      return 0;
    v9 = "pos not reached";
    v10 = 261;
    goto LABEL_10;
  }
  if (*__error() != 32)
  {
    v11 = *__error();
    v9 = "lseek failed";
    v10 = 258;
    goto LABEL_12;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (v7 <= a2)
  {
    v12 = valloc(0x4000uLL);
    if (!v12)
    {
      v11 = *__error();
      v9 = "malloc";
      v10 = 244;
      goto LABEL_12;
    }
    for (i = v12; v7 < a2; *(_QWORD *)(a1 + 32) = v7)
    {
      if (v7 + 0x4000 <= a2)
        v14 = 0x4000;
      else
        v14 = a2 - v7;
      v15 = read(*(_DWORD *)a1, i, v14);
      v7 = *(_QWORD *)(a1 + 32);
      if (v15 < 1)
        break;
      v7 += v15;
    }
    free(i);
    goto LABEL_4;
  }
  v9 = "lseek failed and pos < s->pos";
  v10 = 240;
LABEL_10:
  v11 = 0;
LABEL_12:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"seekTo", v10, 29, v11, v9, v5, v6, v16);
  return 0xFFFFFFFFLL;
}

void IFileStreamDestroy(char *a1)
{
  int v2;

  if (a1)
  {
    if (*((_DWORD *)a1 + 1))
    {
      v2 = *(_DWORD *)a1;
      if ((v2 & 0x80000000) == 0)
        close(v2);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 40));
    free(a1);
  }
}

uint64_t IFileStreamRead(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  unint64_t v13;
  size_t v14;
  uint64_t v16;
  ssize_t v17;
  unint64_t *v18;
  unint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  char v25;

  if (*(_DWORD *)(a1 + 8))
    return -1;
  if (!a3)
    return 0;
  v10 = *(_QWORD *)(a1 + 32);
  if (v10 < *(_QWORD *)(a1 + 16))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 358, 29, 0, "pos out of range", a7, a8, v25);
    return -1;
  }
  if (~v10 < a3)
    v11 = ~v10;
  else
    v11 = a3;
  v12 = a3 + v10;
  if (__CFADD__(a3, v10))
    v12 = -1;
  v13 = *(_QWORD *)(a1 + 24);
  if (v12 <= v13)
    v14 = v11;
  else
    v14 = v13 - v10;
  if (v14)
  {
    v16 = 0;
    while (1)
    {
      v17 = read(*(_DWORD *)a1, a2, v14);
      if (v17 < 0)
        break;
      if (v17)
      {
        a2 += v17;
        v16 += v17;
        v14 -= v17;
        if (v14)
          continue;
      }
      v10 = *(_QWORD *)(a1 + 32);
      result = v16;
      goto LABEL_23;
    }
    v20 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamRead", 374, 29, *v20, "read", v21, v22, v25);
    *(_QWORD *)(a1 + 32) += v16;
    v23 = (unint64_t *)(a1 + 104);
    result = -1;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 + v16, v23));
  }
  else
  {
    result = 0;
LABEL_23:
    *(_QWORD *)(a1 + 32) = v10 + result;
    v18 = (unint64_t *)(a1 + 104);
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 + result, v18));
  }
  return result;
}

uint64_t IFileStreamSetPos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  const char *v12;
  __int16 v13;
  char v15;

  if (*(_DWORD *)(a1 + 8))
    return -1;
  v9 = *(_QWORD *)(a1 + 16);
  v10 = __CFADD__(v9, a2);
  v11 = v9 + a2;
  if (v10 || v11 > *(_QWORD *)(a1 + 24))
  {
    v12 = "invalid pos";
    v13 = 435;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IFileStreamSetPos", v13, 29, 0, v12, a7, a8, v15);
    return -1;
  }
  if ((seekTo(a1, v11) & 0x80000000) != 0)
  {
    v12 = "changing pos";
    v13 = 436;
    goto LABEL_5;
  }
  return *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 16);
}

uint64_t IFileStreamGetPos(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8))
    return -1;
  else
    return *(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 16);
}

int *OFileStreamCreateWithFilename(const char *a1, uint64_t a2)
{
  int *v4;
  int *v5;
  int v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v4 = (int *)malloc(0x20uLL);
  v5 = v4;
  if (v4)
  {
    *((_QWORD *)v4 + 2) = a2;
    *((_QWORD *)v4 + 3) = 0;
    v4[1] = 1;
    *((_QWORD *)v4 + 1) = 0;
    v6 = open(a1, 1537, 420);
    *v5 = v6;
    if (v6 < 0)
    {
      v7 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 490, 29, *v7, "%s", v8, v9, (char)a1);
      free(v5);
      return 0;
    }
  }
  else
  {
    v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFilename", 484, 29, *v10, "malloc", v11, v12, v14);
  }
  return v5;
}

_QWORD *OFileStreamCreateWithFD(int a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = malloc(0x20uLL);
  v5 = v4;
  if (v4)
  {
    v4[2] = a2;
    v4[3] = 0;
    *(_DWORD *)v4 = a1;
    *((_DWORD *)v4 + 1) = 0;
    v4[1] = 0;
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamCreateWithFD", 497, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

void OFileStreamDestroy(int *a1)
{
  int v2;

  if (a1)
  {
    if (a1[1])
    {
      v2 = *a1;
      if ((v2 & 0x80000000) == 0)
        close(v2);
    }
    free(a1);
  }
}

uint64_t OFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3)
{
  uint64_t v3;
  unint64_t v5;
  size_t v7;
  ssize_t v8;
  uint64_t v9;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  if (*(_DWORD *)(a1 + 8))
    return -1;
  if (*(_QWORD *)(a1 + 16) >= a3)
    v5 = a3;
  else
    v5 = *(_QWORD *)(a1 + 16);
  if (v5)
  {
    v3 = 0;
    while (1)
    {
      v7 = v5 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v5;
      v8 = write(*(_DWORD *)a1, __buf, v7);
      if (v8 < 0)
        break;
      if (v8)
      {
        v9 = *(_QWORD *)(a1 + 16);
        if (v9 != -1)
          *(_QWORD *)(a1 + 16) = v9 - v8;
        __buf += v8;
        v3 += v8;
        v5 -= v8;
        if (v5)
          continue;
      }
      goto LABEL_18;
    }
    v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamWrite", 538, 29, *v11, "write", v12, v13, v14);
    return -1;
  }
  v3 = 0;
LABEL_18:
  *(_QWORD *)(a1 + 24) += v3;
  return v3;
}

off_t OFileStreamSetPos(int *a1, off_t a2)
{
  off_t result;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  char vars0;

  if (a1[2])
    return -1;
  result = lseek(*a1, a2, 0);
  if (result < 0)
  {
    v3 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamSetPos", 558, 29, *v3, "lseek", v4, v5, vars0);
    return -1;
  }
  return result;
}

off_t OFileStreamGetPos(int *a1)
{
  off_t result;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  char vars0;

  if (a1[2])
    return -1;
  result = lseek(*a1, 0, 1);
  if (result < 0)
  {
    v2 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OFileStreamGetPos", 568, 29, *v2, "lseek", v3, v4, vars0);
    return -1;
  }
  return result;
}

uint64_t OFileStreamAbort(uint64_t result)
{
  if (result)
    *(_DWORD *)(result + 8) = 1;
  return result;
}

int *OArchiveFileStreamCreate(const char *a1, unint64_t a2, unsigned int a3, int a4, int a5)
{
  int *v10;
  int *v11;
  int v12;
  int v13;
  __int16 v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v48;
  int v49;
  unsigned int v50;
  char v51;

  v10 = (int *)malloc(0x60uLL);
  v11 = v10;
  if (v10)
  {
    *((_OWORD *)v10 + 4) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    if ((a3 & 0x100) == 0)
      unlink(a1);
    v11[1] = (a3 >> 4) & 1;
    *((_QWORD *)v11 + 2) = a2;
    if ((a3 & 1) != 0)
      v12 = 4;
    else
      v12 = a4;
    if (v12 < 1)
    {
      v13 = open(a1, 1537, 420);
      *v11 = v13;
      if (v13 < 0)
      {
        v14 = 648;
        goto LABEL_31;
      }
    }
    else
    {
      v13 = open_dprotected_np(a1, 1537, v12, 0, 420);
      *v11 = v13;
      if (v13 < 0)
      {
        v14 = 640;
LABEL_31:
        v37 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", v14, 29, *v37, "%s", v38, v39, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v40, v41, v42, v43, v44, v45, v46);
        goto LABEL_32;
      }
    }
    if ((a3 & 8) != 0 && fcntl(v13, 48, 1))
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 656, 29, "Warning: F_NOCACHE failed: %s\n", v18, v19, v20, (char)a1);
    if ((a3 & 2) != 0 && fcntl(v13, 68, 1) == -1)
    {
      v21 = __error();
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 665, 29, "Warning: F_SETSTATICCONTENT failed with error %d: %s\n", v22, v23, v24, *v21);
    }
    if (a2 && (a3 & 4) != 0 && a5 != -1)
    {
      if ((a3 & 0x80) != 0)
        v25 = 6;
      else
        v25 = 4;
      v26 = ParallelCompressionAFSCStreamOpen(v13, a2, a5, v25);
      *((_QWORD *)v11 + 3) = v26;
      if (!v26)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 677, 29, 0, "ParallelCompressionAFSCStreamOpen failed: %s", v27, v28, (char)a1);
        ParallelCompressionAFSCStreamClose(0, v29, v30, v31, v32, v33, v34, v35);
        close(v13);
LABEL_32:
        free(v11);
        return 0;
      }
    }
    else if ((a3 & 0x40) != 0)
    {
      v36 = fpathconf(v13, 27);
      if (v36 >= 1)
      {
        v11[10] = 1;
        if (v36 == 4096)
        {
          v11[18] = 4096;
        }
        else
        {
          v48 = 0x10000;
          if (v36 < 0x10000)
            v48 = v36;
          v49 = 1024;
          do
          {
            v50 = v49;
            v49 *= 2;
          }
          while (v50 < v48);
          v11[18] = v50;
        }
      }
    }
  }
  else
  {
    v15 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamCreate", 617, 29, *v15, "malloc", v16, v17, v51);
  }
  return v11;
}

uint64_t OArchiveFileStreamDestroy(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OArchiveFileStreamDestroyEx(a1, 0, 0, 0, a5, a6, a7, a8);
}

uint64_t OArchiveFileStreamDestroyEx(unsigned int *a1, uint64_t a2, _QWORD *a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  char v27;

  if (!a1)
    return 0xFFFFFFFFLL;
  v10 = a2;
  if (*((_QWORD *)a1 + 2))
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 863, 29, "OArchiveFileStream didn't receive enough data before being destroyed\n", a6, a7, a8, v27);
  ParallelCompressionAFSCStreamClose(*((_QWORD *)a1 + 3), a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if ((*a1 & 0x80000000) != 0)
  {
    v13 = 0;
    v19 = 0xFFFFFFFFLL;
    if (!a3)
      goto LABEL_21;
    goto LABEL_20;
  }
  if (*((_QWORD *)a1 + 7))
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = *((_QWORD *)a1 + 8);
    while (fcntl(*a1, 99, v15 + v12) != -1)
    {
      v15 = *((_QWORD *)a1 + 8);
      v13 += *(_QWORD *)(v15 + v12 + 16);
      ++v14;
      v12 += 24;
      if (v14 >= *((_QWORD *)a1 + 7))
        goto LABEL_15;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 875, 29, "F_PUNCHHOLE failed", v16, v17, v18, v27);
  }
  else
  {
    v13 = 0;
  }
LABEL_15:
  if (a1[1])
  {
    v27 = 0;
    if (fcntl(*a1, 51) == -1)
    {
      v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 883, 29, *v20, "Final FULLSYNC", v21, v22, 0);
    }
  }
  v19 = *a1;
  if (!v10)
  {
    if (close(*a1))
    {
      v24 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamDestroyEx", 890, 29, *v24, "close", v25, v26, v27);
    }
    v19 = 0xFFFFFFFFLL;
    *a1 = -1;
    if (!a3)
      goto LABEL_21;
    goto LABEL_20;
  }
  if (a3)
LABEL_20:
    *a3 = *((_QWORD *)a1 + 4) - v13;
LABEL_21:
  if (a4)
    *a4 = v13;
  free(*((void **)a1 + 8));
  free(a1);
  return v19;
}

uint64_t OArchiveFileStreamWrite(uint64_t a1, char *__buf, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  ssize_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v39;
  void *v40;
  unint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  unint64_t *v48;

  if (!a1 || *(_DWORD *)(a1 + 8))
    return -1;
  v11 = a3;
  if (a3)
  {
    v9 = 0;
    v48 = (unint64_t *)(a1 + 48);
    v13 = *(_QWORD *)(a1 + 16);
    while (v13)
    {
      if (v13 >= v11)
        v13 = v11;
      if (v13 >= 0x40000000)
        v14 = 0x40000000;
      else
        v14 = v13;
      v15 = *(_QWORD *)(a1 + 24);
      if (v15)
      {
        v16 = ParallelCompressionAFSCStreamWrite(v15, (uint64_t)__buf, v14, a4, a5, a6, a7, a8);
        v17 = v16;
        if (v16 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 955, 29, 0, "ParallelCompressionAFSCStreamWrite failed with status %d", a7, a8, v16);
          return -1;
        }
      }
      else
      {
        if ((*(_DWORD *)a1 & 0x80000000) != 0)
          return -1;
        v17 = write(*(_DWORD *)a1, __buf, v14);
        if (v17 < 0)
        {
          v44 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 960, 29, v44, "write", v45, v46, v47);
          return -1;
        }
      }
      if (*(_DWORD *)(a1 + 40))
      {
        v18 = 0;
        LODWORD(v19) = *(_DWORD *)(a1 + 72);
        v20 = *(_DWORD *)(a1 + 76);
        do
        {
          v21 = (v19 - v20);
          if (v18 + v21 <= v14)
            v22 = v21;
          else
            v22 = (v14 - v18);
          v23 = &__buf[v18];
          v24 = &__buf[v18 + v22];
          if (((unint64_t)&__buf[v18] & 7) != 0 && (_DWORD)v22)
          {
            v25 = &__buf[v18 + 1];
            while (!*v23)
            {
              if (++v23 < v24)
              {
                if ((unint64_t)(v25++ & 7))
                  continue;
              }
              goto LABEL_29;
            }
LABEL_35:
            v28 = 1;
          }
          else
          {
LABEL_29:
            while (v23 + 8 <= v24)
            {
              v27 = *(_QWORD *)v23;
              v23 += 8;
              if (v27)
                goto LABEL_35;
            }
            while (v23 < v24)
            {
              if (*v23)
                goto LABEL_35;
              ++v23;
            }
            v28 = 0;
          }
          v29 = *(_DWORD *)(a1 + 88) | v28;
          *(_DWORD *)(a1 + 88) = v29;
          v20 += v22;
          *(_DWORD *)(a1 + 76) = v20;
          if (v20 == (_DWORD)v19)
          {
            if (!v29)
            {
              v30 = *(_QWORD *)(a1 + 80);
              v31 = *(_QWORD *)(a1 + 56);
              if (v31
                && (v32 = *(_QWORD *)(a1 + 64) + 24 * v31,
                    v35 = *(_QWORD *)(v32 - 8),
                    v33 = (_QWORD *)(v32 - 8),
                    v34 = v35,
                    v35 + *(v33 - 1) == v30))
              {
                *v33 = v34 + v19;
              }
              else
              {
                v36 = *v48;
                if (v31 >= *v48)
                {
                  v37 = v36 + (v36 >> 1);
                  v38 = v36 == 0;
                  v39 = 32;
                  if (!v38)
                    v39 = v37;
                  *(_QWORD *)(a1 + 48) = v39;
                  v40 = reallocf(*(void **)(a1 + 64), 24 * v39);
                  *(_QWORD *)(a1 + 64) = v40;
                  if (!v40)
                  {
                    *v48 = 0;
                    v48[1] = 0;
                    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OArchiveFileStreamWrite", 994, 29, "malloc holes failed", a6, a7, a8, v47);
                  }
                }
                v41 = *(_QWORD *)(a1 + 56);
                if (v41 >= *(_QWORD *)(a1 + 48))
                {
                  LODWORD(v19) = *(_DWORD *)(a1 + 72);
                }
                else
                {
                  v42 = *(_QWORD *)(a1 + 64);
                  *(_QWORD *)(a1 + 56) = v41 + 1;
                  v43 = (_QWORD *)(v42 + 24 * v41);
                  *v43 = 0;
                  v43[1] = 0;
                  v43[1] = v30;
                  v43[2] = 0;
                  v19 = *(unsigned int *)(a1 + 72);
                  v43[2] = v19;
                }
              }
            }
            v20 = 0;
            *(_QWORD *)(a1 + 80) += v19;
            *(_DWORD *)(a1 + 76) = 0;
            *(_DWORD *)(a1 + 88) = 0;
          }
          v18 += v22;
        }
        while (v18 < v14);
      }
      __buf += v17;
      v9 += v17;
      v13 = *(_QWORD *)(a1 + 16) - v17;
      *(_QWORD *)(a1 + 16) = v13;
      v11 -= v17;
      if (!v11)
        break;
    }
  }
  else
  {
    v9 = 0;
  }
  *(_QWORD *)(a1 + 32) += v9;
  return v9;
}

_QWORD *OMemStreamCreate(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = malloc(0x20uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    v4[3] = 0;
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OMemStreamCreate", 1050, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

uint64_t OMemStreamGetNWritten(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t OMemStreamWrite(uint64_t a1, const void *a2, size_t a3)
{
  size_t v4;
  size_t v5;

  if (!a1 || *(_DWORD *)(a1 + 8))
    return -1;
  if (*(_QWORD *)(a1 + 16) >= a3)
    v4 = a3;
  else
    v4 = *(_QWORD *)(a1 + 16);
  memcpy(*(void **)a1, a2, v4);
  *(_QWORD *)a1 += v4;
  v5 = *(_QWORD *)(a1 + 24) + v4;
  *(_QWORD *)(a1 + 16) -= v4;
  *(_QWORD *)(a1 + 24) = v5;
  return v4;
}

_QWORD *IMemStreamCreate(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = malloc(0x20uLL);
  v5 = v4;
  if (v4)
  {
    *v4 = a1;
    v4[1] = 0;
    v4[2] = a2;
    v4[3] = 0;
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"IMemStreamCreate", 1112, 29, *v6, "malloc", v7, v8, v10);
  }
  return v5;
}

size_t IMemStreamRead(uint64_t a1, void *__dst, size_t a3)
{
  size_t v4;
  size_t v5;

  if (!a1 || *(_DWORD *)(a1 + 8))
    return -1;
  if (*(_QWORD *)(a1 + 16) >= a3)
    v4 = a3;
  else
    v4 = *(_QWORD *)(a1 + 16);
  memcpy(__dst, *(const void **)a1, v4);
  *(_QWORD *)a1 += v4;
  v5 = *(_QWORD *)(a1 + 24) + v4;
  *(_QWORD *)(a1 + 16) -= v4;
  *(_QWORD *)(a1 + 24) = v5;
  return v4;
}

uint64_t IMemStreamAbort(uint64_t result)
{
  if (result)
    *(_DWORD *)(result + 8) = 1;
  return result;
}

char *OBufferedStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4)
{
  char *v8;
  char *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v24;

  v8 = (char *)malloc(0x28uLL);
  v9 = v8;
  if (v8)
  {
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 8) = 0u;
    v10 = MemBufferCreate(a4);
    *(_QWORD *)v9 = v10;
    if (v10)
    {
      *((_QWORD *)v9 + 1) = a1;
      *((_QWORD *)v9 + 2) = a2;
      *((_QWORD *)v9 + 3) = a3;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1182, 29, 0, "creating internal buffer", v11, v12, v24);
      OBufferedStreamDestroy((void ***)v9, v16, v17, v18, v19, v20, v21, v22);
      return 0;
    }
  }
  else
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamCreate", 1176, 29, *v13, "malloc", v14, v15, v24);
  }
  return v9;
}

void OBufferedStreamDestroy(void ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], a5, a6, a7, a8);
    MemBufferDestroy(*a1);
    free(a1);
  }
}

uint64_t OBufferedStreamWrite(unint64_t **a1, char *a2, unint64_t a3)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t FreeSize;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (a1 && !*((_DWORD *)a1 + 8))
  {
    v6 = a3;
    if (!a3)
      return 0;
    v4 = 0;
    while (1)
    {
      FreeSize = MemBufferGetFreeSize(*a1);
      if (!FreeSize)
      {
        if (MemBufferFlushToOStream(*a1, 0xFFFFFFFFFFFFFFFFLL, (uint64_t (*)(uint64_t, uint64_t, unint64_t))a1[1], (uint64_t)a1[3], v9, v10, v11, v12) < 0)return -1;
        FreeSize = MemBufferGetFreeSize(*a1);
      }
      v13 = v6 >= FreeSize ? FreeSize : v6;
      if (MemBufferFillFromBuffer(*a1, v13, a2) < 0)
        break;
      a2 += v13;
      v4 += v13;
      v6 -= v13;
      if (!v6)
        return v4;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBasicStreams.c", (uint64_t)"OBufferedStreamWrite", 1221, 29, 0, "MemBufferFillFromBuffer failed", v14, v15, v16);
  }
  return -1;
}

uint64_t bxdiff5Alloc(size_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;

  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_QWORD *)(a3 + 16) = a1;
  v3 = *a2;
  *(_DWORD *)(a3 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)a3 = v3;
  if (a1)
    *(_QWORD *)(a3 + 24) = calloc(a1, 0x50uLL);
  return 0;
}

uint64_t bxdiff5Free(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t result;
  char v14;

  if (*(_QWORD *)(a1 + 16))
  {
    v9 = 0;
    v10 = 0;
    v11 = 1;
    do
    {
      v12 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v12 + v9))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 40, 54, 0, "in[%zu] is not NULL", a7, a8, v10);
        v11 = 0;
        v12 = *(_QWORD *)(a1 + 24);
      }
      if (*(_QWORD *)(v12 + v9 + 64))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 41, 54, 0, "inPatch[%zu] is not NULL", a7, a8, v10);
        v11 = 0;
        v12 = *(_QWORD *)(a1 + 24);
      }
      if (*(_QWORD *)(v12 + v9 + 40))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 42, 54, 0, "inControls[%zu] is not NULL", a7, a8, v10);
        v11 = 0;
      }
      ++v10;
      v9 += 80;
    }
    while (v10 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    v11 = 1;
  }
  if (*(_QWORD *)(a1 + 32))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 44, 54, 0, "out is not NULL", a7, a8, v14);
    v11 = 0;
  }
  if (*(_QWORD *)(a1 + 72))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 45, 54, 0, "comboControls is not NULL", a7, a8, v14);
    v11 = 0;
  }
  if (*(_QWORD *)(a1 + 96))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5Free", 46, 54, 0, "comboPatch is not NULL", a7, a8, v14);
    v11 = 0;
  }
  free(*(void **)(a1 + 24));
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  if (v11)
    result = 0;
  else
    result = 0xFFFFFFFFLL;
  *(_OWORD *)a1 = 0uLL;
  return result;
}

uint64_t bxdiff5Dump(uint64_t a1, FILE *a2)
{
  uint64_t v4;
  int *v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t j;
  unint64_t v20;
  unint64_t v21;

  if (*(_QWORD *)(a1 + 16))
  {
    v4 = 0;
    v5 = (int *)(*(_QWORD *)(a1 + 24) + 36);
    v6 = *(_QWORD *)(a1 + 16);
    do
    {
      v7 = *v5;
      v5 += 20;
      if (v7)
        ++v4;
      --v6;
    }
    while (v6);
  }
  else
  {
    v4 = 0;
  }
  fprintf(a2, "BXDiff5Data: n=%zu, nUnique=%zu\n", *(_QWORD *)(a1 + 16), v4);
  if (*(_QWORD *)(a1 + 16))
  {
    v8 = 0;
    v9 = 0;
    v10 = 16;
    do
    {
      fprintf(a2, "- input %zu\n", v9);
      v11 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v11 + 80 * v9))
      {
        fprintf(a2, "    in set, inSize=%zu, inSHA1=", *(_QWORD *)(v11 + 80 * v9 + 8));
        for (i = 0; i != 20; ++i)
          fprintf(a2, "%02x", *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + v10 + i));
        v13 = "unique";
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 24) + 80 * v9 + 36))
          v13 = "non unique";
        fprintf(a2, ", %s", v13);
        fputc(10, a2);
      }
      else
      {
        fwrite("    in is NULL\n", 0xFuLL, 1uLL, a2);
      }
      v14 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v14 + 80 * v9 + 40))
      {
        v15 = v14 + 80 * v9;
        v16 = 3 * *(_QWORD *)(v15 + 56);
        fprintf(a2, "    inControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(_QWORD *)(v15 + 56), *(_DWORD *)(v15 + 48), (v16 >> 17) & 0xFFFFFFFFFFFLL);
        v8 += 8 * v16;
      }
      else
      {
        fwrite("    inControls is NULL\n", 0x17uLL, 1uLL, a2);
      }
      v17 = *(_QWORD *)(a1 + 24);
      if (*(_QWORD *)(v17 + 80 * v9 + 64))
      {
        v18 = *(_QWORD *)(v17 + 80 * v9 + 72);
        fprintf(a2, "    inPatch set, inPatchSize=%zu (%zu MB)\n", v18, v18 >> 20);
        v8 += v18;
      }
      else
      {
        fwrite("    inPatch is NULL\n", 0x14uLL, 1uLL, a2);
      }
      ++v9;
      v10 += 80;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    v8 = 0;
  }
  fwrite("- output\n", 9uLL, 1uLL, a2);
  if (*(_QWORD *)(a1 + 32))
  {
    fprintf(a2, "    out set, outSize=%zu, outSHA1=", *(_QWORD *)(a1 + 40));
    for (j = 0; j != 20; ++j)
      fprintf(a2, "%02x", *(unsigned __int8 *)(a1 + 48 + j));
    fputc(10, a2);
  }
  else
  {
    fwrite("    out is NULL\n", 0x10uLL, 1uLL, a2);
  }
  if (*(_QWORD *)(a1 + 72))
  {
    v20 = (8 * v4 + 16) * *(_QWORD *)(a1 + 88);
    fprintf(a2, "    comboControls set, nControls=%zu, inPlace=%d (%zu MB)\n", *(_QWORD *)(a1 + 88), *(_DWORD *)(a1 + 80), v20 >> 20);
    v8 += v20;
  }
  else
  {
    fwrite("    comboControls is NULL\n", 0x1AuLL, 1uLL, a2);
  }
  if (*(_QWORD *)(a1 + 96))
  {
    v21 = *(_QWORD *)(a1 + 104);
    fprintf(a2, "    comboPatch set, comboPatchSize=%zu (%zu MB)\n", v21, v21 >> 20);
    v8 += v21;
  }
  else
  {
    fwrite("    comboPatch is NULL\n", 0x17uLL, 1uLL, a2);
  }
  fprintf(a2, "Total size %zu MB\n", v8 >> 20);
  return 0;
}

uint64_t bxdiff5SetIn(_QWORD *a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t result;
  char v19;

  if (a1[2] <= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", 122, 54, 0, "invalid I=%zu", a7, a8, a2);
    return 0xFFFFFFFFLL;
  }
  if (!a3 || !a4)
  {
    v16 = "invalid in,inSize";
    v17 = 123;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetIn", v17, 54, 0, v16, a7, a8, v19);
    return 0xFFFFFFFFLL;
  }
  if (!a1[4])
  {
    v16 = "missing out";
    v17 = 124;
    goto LABEL_16;
  }
  v10 = a1[3] + 80 * a2;
  *(_QWORD *)v10 = a3;
  *(_QWORD *)(v10 + 8) = a4;
  getBufferSHA1Digest(a3, a4, (unsigned __int8 *)(v10 + 16));
  v11 = a1[2];
  v12 = a1[3];
  *(_DWORD *)(v12 + 80 * a2 + 36) = 1;
  if (v11)
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      if (a2 != v14)
      {
        v15 = a1[3];
        if (*(_QWORD *)(v15 + v13))
        {
          if (!sha1cmp(v15 + 80 * a2 + 16, v15 + v13 + 16))
          {
            v12 = a1[3];
            *(_DWORD *)(v12 + 80 * a2 + 36) = 0;
            break;
          }
          v11 = a1[2];
        }
      }
      ++v14;
      v13 += 80;
      if (v14 >= v11)
      {
        v12 = a1[3];
        break;
      }
    }
  }
  result = sha1cmp(v12 + 80 * a2 + 16, (uint64_t)(a1 + 6));
  if ((_DWORD)result)
    return 0;
  *(_DWORD *)(a1[3] + 80 * a2 + 36) = 0;
  return result;
}

uint64_t bxdiff5SetOut(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (a2 && a3)
  {
    *(_QWORD *)(a1 + 32) = a2;
    *(_QWORD *)(a1 + 40) = a3;
    getBufferSHA1Digest(a2, a3, (unsigned __int8 *)(a1 + 48));
    return 0;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetOut", 155, 54, 0, "invalid out,outSize", a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5SetInPatch(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  char v11;

  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetInPatch", 165, 54, 0, "invalid I=%zu", a7, a8, a2);
  }
  else
  {
    if (a3 && a4)
    {
      result = 0;
      v10 = *(_QWORD *)(a1 + 24) + 80 * a2;
      *(_QWORD *)(v10 + 64) = a3;
      *(_QWORD *)(v10 + 72) = a4;
      return result;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5SetInPatch", 166, 54, 0, "invalid inPatch,inPatchSize", a7, a8, v11);
  }
  return 0xFFFFFFFFLL;
}

uint64_t bxdiff5ReadInControlsFromInPatch(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  void *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  __int16 v38;
  int v39;
  uint64_t v40;
  uint64_t v41;

  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    v9 = "invalid input index";
    v10 = 176;
    goto LABEL_12;
  }
  v8 = *(_QWORD *)(a1 + 24);
  if (!*(_QWORD *)(v8 + 80 * a2))
  {
    v9 = "input data is missing";
    v10 = 177;
    goto LABEL_12;
  }
  if (!*(_QWORD *)(a1 + 32))
  {
    v9 = "output data is missing";
    v10 = 178;
    goto LABEL_12;
  }
  if (*(_QWORD *)(v8 + 80 * a2 + 40))
  {
    v9 = "input controls already present";
    v10 = 179;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", v10, 54, 0, v9, a7, a8, v41);
    return 0xFFFFFFFFLL;
  }
  v11 = *(_QWORD *)(v8 + 80 * a2 + 64);
  if (!v11 || (v12 = *(_QWORD *)(v8 + 80 * a2 + 72), v12 <= 0x57))
  {
    v9 = "input patch is missing or invalid";
    v10 = 180;
    goto LABEL_12;
  }
  if (!*(_DWORD *)(v8 + 80 * a2 + 36))
    return 0;
  if (*(_QWORD *)v11 != 0x3035464649445842 || *(_DWORD *)(v11 + 8) != 1 || (v14 = *(_QWORD *)(v11 + 24)) == 0)
  {
    v17 = "patch is not a valid 1:1 BXDIFF50";
    v18 = 199;
    goto LABEL_28;
  }
  if (*(_QWORD *)(v11 + 16) != *(_QWORD *)(a1 + 40))
  {
    v17 = "out size mismatch in patch";
    v18 = 202;
    goto LABEL_28;
  }
  if (*(_QWORD *)(a1 + 48) != *(_QWORD *)(v11 + 40)
    || *(_QWORD *)(a1 + 56) != *(_QWORD *)(v11 + 48)
    || *(_DWORD *)(a1 + 64) != (unint64_t)*(unsigned int *)(v11 + 56))
  {
    v17 = "out digest mismatch in patch";
    v18 = 203;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", v18, 54, 0, v17, a7, a8, v41);
    v19 = 0;
    goto LABEL_29;
  }
  v21 = v8 + 80 * a2;
  v22 = *(_QWORD *)(v21 + 16);
  v23 = *(_QWORD *)(v21 + 24);
  v24 = *(unsigned int *)(v21 + 32);
  if (v22 != *(_QWORD *)(v11 + 68) || v23 != *(_QWORD *)(v11 + 76) || v24 != *(_DWORD *)(v11 + 84))
  {
    v17 = "in digest mismatch in patch";
    v18 = 204;
    goto LABEL_28;
  }
  v41 = a1;
  if (v11 + 88 + v14 > v11 + v12)
  {
    v17 = "invalid patch payload size";
    v18 = 212;
    goto LABEL_28;
  }
  v27 = *(_DWORD *)(v11 + 12);
  v19 = ILowMemoryDecoderStreamCreateWithBuffer(v11 + 88, v14, 0x10000uLL);
  if (!v19)
  {
    v37 = "Control stream init";
    v38 = 215;
    v39 = 0;
    goto LABEL_58;
  }
  v20 = 0;
  v30 = 0;
  v31 = 0;
  v32 = v27 & 1;
  while (1)
  {
    if (v30 < v31)
      goto LABEL_51;
    if (v31)
      v31 += v31 >> 1;
    else
      v31 = 4096;
    v33 = reallocf(v20, 24 * v31);
    if (!v33)
      break;
    v20 = v33;
LABEL_51:
    v34 = ILowMemoryDecoderStreamRead(v19, (char *)v20 + 24 * v30, 24 * (v31 - v30));
    if ((v34 & 0x8000000000000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", 227, 54, 0, "ILZMAMemStreamRead", v35, v36, v41);
      ILowMemoryDecoderStreamDestroy(v19);
      goto LABEL_30;
    }
    if (!v34)
    {
      ILowMemoryDecoderStreamDestroy(v19);
      result = 0;
      v40 = *(_QWORD *)(v41 + 24) + 80 * a2;
      *(_QWORD *)(v40 + 40) = v20;
      *(_DWORD *)(v40 + 48) = v32;
      *(_QWORD *)(v40 + 56) = v30;
      return result;
    }
    v30 += v34 / 0x18;
  }
  v39 = *__error();
  v37 = "malloc";
  v38 = 223;
LABEL_58:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5ReadInControlsFromInPatch", v38, 54, v39, v37, v28, v29, v41);
LABEL_29:
  ILowMemoryDecoderStreamDestroy(v19);
  v20 = 0;
LABEL_30:
  free(v20);
  return 0xFFFFFFFFLL;
}

uint64_t bxdiff5CreateInControls(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  int8x16_t **v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  uint64_t result;
  uint64_t v17;
  unint64_t v18;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  int LargeFileControls;
  char v25;

  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    v14 = "invalid input index";
    v15 = 247;
    goto LABEL_5;
  }
  v10 = *(_QWORD *)(a1 + 24);
  v11 = v10 + 80 * a2;
  v13 = *(_QWORD *)(v11 + 40);
  v12 = (int8x16_t **)(v11 + 40);
  if (v13)
  {
    v14 = "input controls already present";
    v15 = 248;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateInControls", v15, 54, 0, v14, a7, a8, v25);
    return 0xFFFFFFFFLL;
  }
  v17 = *(_QWORD *)(v10 + 80 * a2);
  if (!v17 || (v18 = *(_QWORD *)(v10 + 80 * a2 + 8)) == 0)
  {
    v14 = "input is missing or invalid";
    v15 = 249;
    goto LABEL_5;
  }
  if (!*(_DWORD *)(v10 + 80 * a2 + 36))
    return 0;
  v20 = *(_QWORD *)(a1 + 32);
  v21 = *(_QWORD *)(a1 + 40);
  v22 = (uint64_t *)(v10 + 80 * a2 + 56);
  if (!(v18 >> 28) || v21 >> 28 == 0)
  {
    if ((getBXDiffControls(v17, v18, v20, v21, v12, (uint64_t)v22, (int *)a1, a8) & 0x80000000) != 0)
    {
      v14 = "generic controls";
      v15 = 270;
      goto LABEL_5;
    }
  }
  else
  {
    LargeFileControls = GetLargeFileControls(v17, v18, v20, v21, (void **)v12, v22, (uint64_t *)a1, a8);
    if (LargeFileControls < 0)
    {
      v14 = "largefile controls";
      v15 = 262;
      goto LABEL_5;
    }
  }
  if (!a3)
    return 0;
  if ((forceInPlaceControls(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 8), *(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 56), *(_DWORD *)(a1 + 4)) & 0x80000000) != 0)
  {
    v14 = "forceInPlaceControls";
    v15 = 278;
    goto LABEL_5;
  }
  result = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 24) + 80 * a2 + 48) = 1;
  return result;
}

uint64_t bxdiff5CreateComboControls(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  unint64_t v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;

  v8 = *(_QWORD *)(a1 + 16);
  if (!v8)
    goto LABEL_7;
  v10 = 0;
  v11 = (int *)(*(_QWORD *)(a1 + 24) + 36);
  v12 = *(_QWORD *)(a1 + 16);
  do
  {
    v13 = *v11;
    v11 += 20;
    if (v13)
      ++v10;
    --v12;
  }
  while (v12);
  if (v10 > 1)
  {
    *(_DWORD *)(a1 + 80) = 1;
    v15 = (uint64_t *)calloc(v8, 0x18uLL);
    if (v15)
    {
      v16 = v15;
      v17 = v15;
      v18 = v8;
      do
      {
        initDiffSegmentVector(v17);
        v17 += 3;
        --v18;
      }
      while (v18);
      v25 = 0;
      v26 = 0;
      v27 = *(_QWORD *)(a1 + 24);
      do
      {
        if (*(_DWORD *)(v27 + v25 + 36))
        {
          v28 = *(_QWORD *)(v27 + v25 + 40);
          if (!v28)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 309, 54, 0, "missing controls for input %zu", v23, v24, v18);
            goto LABEL_28;
          }
          if ((pushControls((unint64_t *)&v16[3 * v26], v28, *(_QWORD *)(v27 + v25 + 56), 0, 0) & 0x80000000) != 0)
          {
            v33 = "pushControls";
            v34 = 312;
            goto LABEL_27;
          }
          v27 = *(_QWORD *)(a1 + 24);
          if (!*(_DWORD *)(v27 + v25 + 48))
            *(_DWORD *)(a1 + 80) = 0;
          ++v26;
        }
        ++v18;
        v25 += 80;
      }
      while (v8 != v18);
      if ((mergeDiffSegmentVectors(v26, v16, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        v33 = "mergeDiffSegmentVectors";
        v34 = 321;
      }
      else
      {
        if ((getComboControlsFromMergedDiffSegmentVectors((char *)v26, v16, (_QWORD *)(a1 + 72), (uint64_t *)(a1 + 88)) & 0x80000000) == 0)
        {
          v29 = 1;
          goto LABEL_29;
        }
        v33 = "getComboControlsFromMergedDiffSegmentVectors";
        v34 = 324;
      }
LABEL_27:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", v34, 54, 0, v33, v23, v24, v37);
LABEL_28:
      v29 = 0;
LABEL_29:
      if (v8 <= 1)
        v35 = 1;
      else
        v35 = v8;
      v36 = (uint64_t)v16;
      do
      {
        BlobBufferFree(v36);
        v36 += 24;
        --v35;
      }
      while (v35);
      free(v16);
    }
    else
    {
      v30 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 300, 54, *v30, "malloc", v31, v32, v37);
      v29 = 0;
    }
    if (v29)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboControls", 289, 54, 0, "creating combo controls requires 2 or more unique inputs", a7, a8, v37);
    return 0xFFFFFFFFLL;
  }
}

uint64_t bxdiff5CreateInPatch(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 24) + 80 * a2;
  return bxdiff5CreatePatchBackend(1, v2, v2 + 8, v2 + 16, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a1 + 48, *(_QWORD *)(v2 + 40), *(_QWORD *)(v2 + 56), (_QWORD *)(v2 + 64), (size_t *)(v2 + 72), *(_DWORD *)(v2 + 48), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
}

uint64_t bxdiff5CreatePatchBackend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t __size, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10, size_t *a11, int a12, int a13, unsigned int a14)
{
  size_t *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  int64x2_t v24;
  int64x2_t v25;
  int64x2_t *v26;
  uint64_t v27;
  int v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  size_t v32;
  _OWORD *v33;
  _QWORD *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  int64_t *v49;
  uint64_t v50;
  int64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  _BYTE *v58;
  int64_t v59;
  char v60;
  char v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  size_t v68;
  uint64_t v69;
  int *v71;
  uint64_t v72;
  uint64_t v73;
  size_t v74;
  size_t *v75;
  uint64_t v76;
  uint64_t v77;
  size_t v78;
  size_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  FILE **v85;
  char v86;
  char *v87;
  uint64_t v88;
  void *__dsta[2];
  char *__dst;

  v19 = a10;
  v18 = a11;
  v22 = (char *)malloc(__size);
  if (!v22)
  {
    v28 = *__error();
    v29 = "malloc";
    v30 = 447;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", v30, 54, v28, v29, v20, v21, v86);
    v34 = 0;
LABEL_49:
    free(v22);
    free(v34);
    v67 = 0;
    v68 = 0;
    v69 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  v23 = a9;
  if (a9)
  {
    v24 = 0uLL;
    v25 = vdupq_n_s64(0x8000000000000000);
    v26 = (int64x2_t *)a8;
    v27 = a9;
    do
    {
      v24 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*v26), (int8x16_t)vsubq_s64(v25, *v26), *(int8x16_t *)v26), v24);
      v26 = (int64x2_t *)((char *)v26 + 8 * a1 + 16);
      --v27;
    }
    while (v27);
  }
  else
  {
    v24 = 0uLL;
  }
  v88 = a1 + 2;
  if (a13 > 1)
  {
    *(int64x2_t *)__dsta = v24;
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 backend, out: %zu B, diff: %zu B, lit: %zu B, ctrl: %zu B\n", __size, v24.u64[0], v24.u64[1], 8 * (a1 + 2) * a9);
    v24 = *(int64x2_t *)__dsta;
  }
  if (vaddvq_s64(v24) != __size)
  {
    v29 = "size inconsistency: diff + archive != out";
    v30 = 458;
    v28 = 0;
    goto LABEL_48;
  }
  __dst = v22;
  v31 = 28 * a1 + lzma_stream_buffer_bound() * a1;
  v32 = v31 + lzma_stream_buffer_bound() + 60;
  if (a13 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch allocated: %zu B\n", v32);
  v33 = malloc(v32);
  v34 = v33;
  if (!v33)
  {
    v71 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 469, 54, *v71, "malloc", v72, v73, v86);
LABEL_52:
    v19 = a10;
    v22 = __dst;
    goto LABEL_49;
  }
  *(_OWORD *)((char *)v33 + 44) = 0u;
  v33[1] = 0u;
  v33[2] = 0u;
  *v33 = 0u;
  v87 = (char *)v33 + 60;
  bzero((char *)v33 + 60, 28 * a1);
  *v34 = 0x3035464649445842;
  v34[2] = __size;
  *(_OWORD *)(v34 + 5) = *(_OWORD *)a7;
  *((_DWORD *)v34 + 14) = *(_DWORD *)(a7 + 16);
  *((_DWORD *)v34 + 2) = a1;
  *((_DWORD *)v34 + 3) = a12 != 0;
  if (a1)
  {
    v35 = (char *)v34 + 68;
    v36 = a1;
    do
    {
      *(_OWORD *)v35 = *(_OWORD *)a4;
      *((_DWORD *)v35 + 4) = *(_DWORD *)(a4 + 16);
      a4 += 20;
      v35 += 28;
      --v36;
    }
    while (v36);
  }
  v37 = (char *)v34 + v32;
  v38 = (uint64_t)&v87[28 * a1];
  if (a13 > 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch headers: %zu B\n", v38 - (_QWORD)v34);
  v19 = a10;
  v39 = plzmaEncodeBuffer(v38, (uint64_t)&v37[-v38], a8, 8 * (a1 + 2) * a9, a14);
  if (v39 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 499, 54, 0, "Payload compression", v40, v41, v86);
    v22 = __dst;
    goto LABEL_49;
  }
  v42 = v38 + v39;
  v34[3] = v39;
  if (a13 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch control payload: %zu B\n", v39);
  v22 = __dst;
  if (a1)
  {
    v43 = 0;
    v44 = a5;
    while (!a9)
    {
      v48 = v22;
LABEL_42:
      v63 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)v22, v48 - v22, a14);
      if (v63 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 530, 54, 0, "Payload compression", v64, v65, v86);
        goto LABEL_52;
      }
      v66 = v63;
      *(_QWORD *)&v87[28 * v43] = v63;
      if (a13 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch diff[%zu] payload: %zu B\n", v43, v63);
      v42 += v66;
      ++v43;
      v22 = __dst;
      v44 = a5;
      if (v43 == a1)
        goto LABEL_56;
    }
    v45 = 0;
    v46 = 0;
    v47 = 0;
    v48 = v22;
    while (1)
    {
      v49 = (int64_t *)(a8 + 8 * v45 * v88);
      v50 = v49[1];
      v51 = 0x8000000000000000 - *v49;
      if (*v49 >= 0)
        v51 = *v49;
      v52 = 0x8000000000000000 - v50;
      if (v50 >= 0)
        v52 = v49[1];
      v53 = v49[v43 + 2];
      if (v53 < 0)
        v53 = 0x8000000000000000 - v53;
      if (v46 < 0)
        break;
      v54 = v51 + v46;
      if (v51 + v46 > __size)
        break;
      if (v47 < 0 || (v55 = v51 + v47, v51 + v47 > *(_QWORD *)(a3 + 8 * v43)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 519, 54, 0, "in[%zu] access out of range", a2, v88, v43);
        goto LABEL_69;
      }
      if (v51 >= 1)
      {
        v56 = (char *)(*(_QWORD *)(a2 + 8 * v43) + v47);
        v57 = (char *)(v44 + v46);
        v58 = v48;
        v59 = v51;
        do
        {
          v61 = *v57++;
          v60 = v61;
          v62 = *v56++;
          *v58++ = v60 - v62;
          --v59;
        }
        while (v59);
      }
      v48 += v51;
      v46 = v54 + v52;
      v47 = v55 + v53;
      if (++v45 == a9)
        goto LABEL_42;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 518, 54, 0, "out access out of range", a2, v88, v86);
    goto LABEL_69;
  }
  v44 = a5;
LABEL_56:
  if (a9)
  {
    v74 = 0;
    v75 = (size_t *)(a8 + 8);
    v76 = 8 * a1 + 16;
    v22 = __dst;
    do
    {
      v77 = *(v75 - 1);
      if (v77 < 0)
        v77 = 0x8000000000000000 - v77;
      if ((*v75 & 0x8000000000000000) == 0)
        v78 = *v75;
      else
        v78 = 0x8000000000000000 - *v75;
      v79 = v77 + v74;
      memcpy(v22, (const void *)(v44 + v77 + v74), v78);
      v44 = a5;
      v22 += v78;
      v74 = v79 + v78;
      v75 = (size_t *)((char *)v75 + v76);
      --v23;
    }
    while (v23);
  }
  v80 = v22 - __dst;
  v22 = __dst;
  v81 = plzmaEncodeBuffer(v42, (uint64_t)&v37[-v42], (uint64_t)__dst, v80, a14);
  if (v81 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreatePatchBackend", 554, 54, 0, "Payload compression", v82, v83, v86);
    v18 = a11;
LABEL_69:
    v19 = a10;
    goto LABEL_49;
  }
  v84 = v42 + v81;
  v34[4] = v81;
  if (a13 <= 1)
  {
    v68 = v84 - (_QWORD)v34;
  }
  else
  {
    v85 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch archive payload: %zu B\n", v81);
    v68 = v84 - (_QWORD)v34;
    fprintf(*v85, "BXDiff5 patch total size: %zu B\n", v84 - (_QWORD)v34);
  }
  v18 = a11;
  v19 = a10;
  free(__dst);
  v67 = reallocToFit(v34, v68);
  v69 = 0;
LABEL_50:
  *v19 = v67;
  *v18 = v68;
  return v69;
}

uint64_t bxdiff5CreateComboPatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  size_t v10;
  int *v11;
  int v12;
  uint64_t PatchBackend;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  void *v17;
  BOOL v18;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  char v32;

  if (*(_QWORD *)(a1 + 72))
  {
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = 0;
      v11 = (int *)(*(_QWORD *)(a1 + 24) + 36);
      do
      {
        v12 = *v11;
        v11 += 20;
        if (v12)
          ++v10;
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
    }
    v14 = calloc(v10, 8uLL);
    v15 = calloc(v10, 8uLL);
    v16 = (char *)calloc(v10, 0x14uLL);
    v17 = v16;
    if (v14)
      v18 = v15 == 0;
    else
      v18 = 1;
    if (v18 || v16 == 0)
    {
      v20 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 609, 54, *v20, "malloc", v21, v22, v32);
      PatchBackend = 0xFFFFFFFFLL;
    }
    else
    {
      v23 = *(_QWORD *)(a1 + 16);
      if (v23)
      {
        v24 = 0;
        v25 = 0;
        v26 = 0;
        do
        {
          v27 = *(_QWORD *)(a1 + 24);
          if (*(_DWORD *)(v27 + v24 + 36))
          {
            v14[v26] = *(_QWORD *)(v27 + v24);
            v28 = *(_QWORD *)(a1 + 24) + v24;
            v15[v26] = *(_QWORD *)(v28 + 8);
            v29 = &v16[20 * v26];
            v30 = *(_OWORD *)(v28 + 16);
            *((_DWORD *)v29 + 4) = *(_DWORD *)(v28 + 32);
            *(_OWORD *)v29 = v30;
            ++v26;
            v23 = *(_QWORD *)(a1 + 16);
          }
          ++v25;
          v24 += 80;
        }
        while (v25 < v23);
      }
      PatchBackend = bxdiff5CreatePatchBackend(v10, (uint64_t)v14, (uint64_t)v15, (uint64_t)v16, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a1 + 48, *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 88), (_QWORD *)(a1 + 96), (size_t *)(a1 + 104), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
    }
    free(v14);
    free(v15);
    free(v17);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateComboPatch", 600, 54, 0, "missing combo controls", a7, a8, v32);
    return 0xFFFFFFFFLL;
  }
  return PatchBackend;
}

uint64_t BXDiff5(uint64_t a1, void **a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return BXDiff5WithIndividualPatches(a1, a2, a3, 0, 0, a6, a7, a8);
}

uint64_t BXDiff5WithIndividualPatches(uint64_t a1, void **a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _QWORD *v9;
  _QWORD *v10;
  int v14;
  size_t v15;
  int v16;
  BOOL v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  __int16 v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  int v49;
  uint64_t v50;
  int *v51;
  int v52;
  uint64_t v53;
  int *v54;
  int v55;
  __int128 v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  size_t v60;
  char *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  char v67;
  int v68;
  unint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  const char *v75;
  __int16 v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  char v93;
  char v94;
  char v95;
  void **v96;
  _QWORD *v97;
  int v98;
  int v99;
  uint64_t v100;
  int v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  void *v106[2];
  __int128 v107;
  __int128 v108;
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  if (HIDWORD(*(_QWORD *)a1))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 645, 54, 0, "Invalid number of inputs: %zu", a7, a8, *(_QWORD *)a1);
    return 0xFFFFFFFFLL;
  }
  v9 = (_QWORD *)a5;
  v10 = (_QWORD *)a4;
  v14 = *(_DWORD *)(a1 + 48);
  enterThreadErrorContext(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, v93);
  v15 = *(_QWORD *)a1;
  v16 = *(_DWORD *)(a1 + 52);
  if (v10)
    v17 = v9 == 0;
  else
    v17 = 1;
  v18 = !v17;
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  *(_OWORD *)v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v102 = 0u;
  v19 = *(_DWORD *)(a1 + 44);
  v99 = v18;
  LODWORD(v100) = *(_DWORD *)(a1 + 40);
  HIDWORD(v100) = v16;
  v101 = v19;
  bxdiff5Alloc(v15, &v100, (uint64_t)&v102);
  *a2 = 0;
  *a3 = 0;
  if (v10 && v15)
    bzero(v10, 8 * v15);
  if (v9 && v15)
    bzero(v9, 8 * v15);
  if (bxdiff5SetOut((uint64_t)&v102, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), v20, v21, v22, v23, v24))
  {
    v32 = "bxdiff5SetOut";
    v33 = 672;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", v33, 54, 0, v32, v30, v31, v94);
    LODWORD(v34) = 0;
    goto LABEL_18;
  }
  if (v15)
  {
    v45 = 0;
    while (!bxdiff5SetIn(&v102, v45, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v45), *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v45), v28, v29, v30, v31))
    {
      if (v15 == ++v45)
        goto LABEL_28;
    }
    v32 = "bxdiff5SetIn";
    v33 = 675;
    goto LABEL_17;
  }
LABEL_28:
  v46 = v103;
  if ((_QWORD)v103)
  {
    v47 = 0;
    v48 = (int *)(*((_QWORD *)&v103 + 1) + 36);
    do
    {
      v49 = *v48;
      v48 += 20;
      if (v49)
        ++v47;
      --v46;
    }
    while (v46);
    if (!v47)
      *(_DWORD *)(*((_QWORD *)&v103 + 1) + 36) = 1;
  }
  if (v16 >= 2)
    bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
  if (v15)
  {
    v50 = v103;
    v96 = a2;
    if ((_QWORD)v103)
    {
      v34 = 0;
      v51 = (int *)(*((_QWORD *)&v103 + 1) + 36);
      do
      {
        v52 = *v51;
        v51 += 20;
        if (v52)
          ++v34;
        --v50;
      }
      while (v50);
      if (v34 == 1)
      {
        v53 = 0;
        v54 = (int *)(*((_QWORD *)&v103 + 1) + 36);
        while (1)
        {
          v55 = *v54;
          v54 += 20;
          if (v55)
            break;
          if (v15 == ++v53)
          {
            v32 = "could not find unique input";
            v33 = 699;
            goto LABEL_17;
          }
        }
        v67 = v14;
        v98 = v16;
        v99 = 0;
        v97 = a3;
        v68 = 1;
        v34 = 1;
LABEL_59:
        v69 = 0;
        v70 = v67 & 2;
        if (v15 <= 1)
          v71 = 1;
        else
          v71 = v15;
        v72 = 36;
        do
        {
          if (*(_DWORD *)(*((_QWORD *)&v103 + 1) + v72))
          {
            if (bxdiff5CreateInControls((uint64_t)&v102, v69, v70, v27, v28, v29, v30, v31))
            {
              v32 = "bxdiff5CreateInControls";
              v33 = 710;
              goto LABEL_17;
            }
            v73 = v53 == v69 ? v68 : 0;
            if ((v99 || v73) && bxdiff5CreateInPatch((uint64_t)&v102, v69))
            {
              v32 = "bxdiff5CreateInPatch";
              v33 = 718;
              goto LABEL_17;
            }
          }
          ++v69;
          v72 += 80;
        }
        while (v71 != v69);
        if (v98 >= 2)
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
        if (v34 >= 2)
        {
          if (bxdiff5CreateComboControls((uint64_t)&v102, v25, v26, v27, v28, v29, v30, v31))
          {
            v32 = "bxdiff5CreateComboControls";
            v33 = 730;
            goto LABEL_17;
          }
          v79 = 0;
          v80 = *((_QWORD *)&v103 + 1);
          v81 = v71;
          do
          {
            free(*(void **)(v80 + v79 + 40));
            v80 = *((_QWORD *)&v103 + 1);
            v89 = *((_QWORD *)&v103 + 1) + v79;
            *(_QWORD *)(v89 + 40) = 0;
            *(_QWORD *)(v89 + 56) = 0;
            v79 += 80;
            --v81;
          }
          while (v81);
          if (v98 > 1)
            bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
          if (bxdiff5CreateComboPatch((uint64_t)&v102, v82, v83, v84, v85, v86, v87, v88))
          {
            v32 = "bxdiff5CreateComboPatch";
            v33 = 747;
            goto LABEL_17;
          }
        }
        if (v98 >= 2)
          bxdiff5Dump((uint64_t)&v102, (FILE *)*MEMORY[0x24BDAC8D8]);
        if (v34 >= 2)
        {
          v90 = *((_QWORD *)&v108 + 1);
          *v96 = (void *)v108;
          *v97 = v90;
          v108 = 0uLL;
          if (!v99)
            goto LABEL_97;
          v91 = (_QWORD *)(*((_QWORD *)&v103 + 1) + 64);
          do
          {
            *v10++ = *v91;
            *v9++ = v91[1];
            *v91 = 0;
            v91[1] = 0;
            v91 += 10;
            --v71;
          }
          while (v71);
        }
        if (v34 == 1)
        {
          v92 = *((_QWORD *)&v103 + 1) + 80 * v53;
          *v96 = *(void **)(v92 + 64);
          *v97 = *(_QWORD *)(v92 + 72);
          *(_QWORD *)(v92 + 64) = 0;
          *(_QWORD *)(v92 + 72) = 0;
          goto LABEL_18;
        }
LABEL_97:
        LODWORD(v34) = 1;
LABEL_18:
        if (v15)
        {
          v35 = 0;
          v36 = *((_QWORD *)&v103 + 1);
          do
          {
            v37 = v36 + v35;
            *(_QWORD *)v37 = 0;
            free(*(void **)(v37 + 40));
            v36 = *((_QWORD *)&v103 + 1);
            *(_QWORD *)(*((_QWORD *)&v103 + 1) + v35 + 40) = 0;
            v35 += 80;
            --v15;
          }
          while (v15);
        }
        goto LABEL_21;
      }
      v67 = v14;
      v98 = v16;
      v97 = a3;
      v68 = 0;
    }
    else
    {
      v67 = v14;
      v98 = v16;
      v97 = a3;
      v68 = 0;
      v34 = 0;
    }
    v53 = -1;
    goto LABEL_59;
  }
  v56 = v104;
  v57 = DWORD1(v102);
  v58 = DWORD2(v102);
  v59 = lzma_stream_buffer_bound();
  v60 = v59 + 60;
  if (v57 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch capacity: %zu B\n", v60);
  v61 = (char *)malloc(v60);
  v62 = v61;
  if (v61)
  {
    *(_OWORD *)v61 = 0u;
    *((_OWORD *)v61 + 1) = 0u;
    *(_OWORD *)(v61 + 44) = 0u;
    *((_OWORD *)v61 + 2) = 0u;
    *(_QWORD *)v61 = 0x3035464649445842;
    *((_QWORD *)v61 + 1) = 0;
    *((_QWORD *)v61 + 2) = *((_QWORD *)&v56 + 1);
    *(_OWORD *)(v61 + 40) = v105;
    *((_DWORD *)v61 + 14) = v106[0];
    v63 = plzmaEncodeBuffer((uint64_t)(v61 + 60), v59, v56, *((uint64_t *)&v56 + 1), v58);
    if ((v63 & 0x8000000000000000) == 0)
    {
      v66 = (char *)v62 + v63 + 60;
      v62[4] = v63;
      if (v57 >= 1)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "BXDiff5 patch archive payload size: %zu B\n", v63);
      *a2 = reallocToFit(v62, v66 - (char *)v62);
      *a3 = v66 - (char *)v62;
      LODWORD(v34) = 1;
      goto LABEL_21;
    }
    v75 = "Payload compression";
    v76 = 406;
    v74 = 0;
  }
  else
  {
    v74 = *__error();
    v75 = "malloc patch";
    v76 = 386;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"bxdiff5CreateFullReplacementBackend", v76, 54, v74, v75, v64, v65, v94);
  free(v62);
  *a2 = 0;
  *a3 = 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"BXDiff5WithIndividualPatches", 689, 54, 0, "bxdiff5CreateFullReplacementBackend", v77, v78, v95);
  LODWORD(v34) = 0;
LABEL_21:
  *(_QWORD *)&v104 = 0;
  free(v106[1]);
  v106[1] = 0;
  bxdiff5Free((uint64_t)&v102, v38, v39, v40, v41, v42, v43, v44);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return (v34 - 1);
  else
    return result;
}

uint64_t plzmaEncodeBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t NWritten;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _QWORD *v29;

  v29 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v10 = IMemStreamCreate(a3, a4);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", 348, 54, 0, "is", v8, v9, v25);
    v19 = 0;
LABEL_8:
    v22 = 1;
    goto LABEL_9;
  }
  v11 = OMemStreamCreate(a1, a2);
  v19 = v11;
  if (!v11)
  {
    v20 = "os";
    v21 = 349;
    goto LABEL_7;
  }
  *(_QWORD *)((char *)&v25 + 4) = a5 | 0x100000000;
  LODWORD(v25) = 0;
  *(_QWORD *)&v26 = 0x100000;
  *((_QWORD *)&v26 + 1) = IMemStreamRead;
  *((_QWORD *)&v27 + 1) = v10;
  *(_QWORD *)&v28 = OMemStreamWrite;
  v29 = v11;
  if (ParallelCompressionEncode((uint64_t)&v25, v12, v13, v14, v15, v16, v17, v18))
  {
    v20 = "encode";
    v21 = 358;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiff5.c", (uint64_t)"plzmaEncodeBuffer", v21, 54, 0, v20, v17, v18, v25);
    goto LABEL_8;
  }
  v22 = 0;
LABEL_9:
  NWritten = OMemStreamGetNWritten((uint64_t)v19);
  IMagicStreamDestroy(v10);
  IMagicStreamDestroy(v19);
  if (v22)
    return -1;
  else
    return NWritten;
}

void *StringTableCreate()
{
  void *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  char v5;

  v0 = calloc(1uLL, 0x28uLL);
  if (!v0)
  {
    v1 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableCreate", 30, 35, *v1, "malloc", v2, v3, v5);
  }
  return v0;
}

uint64_t stringTableReserve(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v4;
  void *v5;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= a2)
    return 0;
  v4 = v2 ? v2 + (v2 >> 1) : 32;
  if (v4 <= a2)
    v4 = a2;
  *(_DWORD *)(a1 + 4) = v4;
  v5 = reallocf(*(void **)(a1 + 8), 16 * v4);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
    return 0;
  v7 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"stringTableReserve", 23, 35, *v7, "malloc", v8, v9, v10);
  return 0xFFFFFFFFLL;
}

void StringTableDestroy(void **a1)
{
  if (a1)
  {
    BlobBufferFree((uint64_t)(a1 + 2));
    free(a1[1]);
    free(a1);
  }
}

uint64_t StringTableAppend(unsigned int *a1, const void *a2, size_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v11;
  __int16 v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  _QWORD v17[2];

  if (a4)
    *a4 = *a1;
  if (HIDWORD(a3))
  {
    v11 = "string too long for StringTable";
    v12 = 74;
  }
  else if (stringTableReserve((uint64_t)a1, *a1 + 1))
  {
    v11 = "increasing string table capacity";
    v12 = 77;
  }
  else
  {
    v17[0] = 0;
    v17[1] = 0;
    if (!BlobBufferStore((uint64_t)(a1 + 4), 0, a3 + 1, v17))
    {
      v14 = *((_QWORD *)a1 + 1) + 16 * *a1;
      v15 = v17[0];
      *(_QWORD *)v14 = v17[0];
      *(_DWORD *)(v14 + 8) = a3;
      v16 = (void *)(*((_QWORD *)a1 + 4) + v15);
      memcpy(v16, a2, a3);
      result = 0;
      *((_BYTE *)v16 + a3) = 0;
      ++*a1;
      return result;
    }
    v11 = "insertion failed in string table";
    v12 = 81;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppend", v12, 35, 0, v11, a7, a8, v17[0]);
  return 0xFFFFFFFFLL;
}

uint64_t StringTableAppendTable(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  __int16 v8;
  uint64_t result;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  _QWORD v15[2];

  if (a3)
    *a3 = *(_DWORD *)a1;
  if (!*a2)
    return 0;
  if (stringTableReserve(a1, *(_DWORD *)a1 + *a2))
  {
    v7 = "increasing string table capacity";
    v8 = 152;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableAppendTable", v8, 35, 0, v7, v5, v6, v15[0]);
    return 0xFFFFFFFFLL;
  }
  v15[0] = 0;
  v15[1] = 0;
  if (BlobBufferStore(a1 + 16, *((const void **)a2 + 4), *((_QWORD *)a2 + 3), v15))
  {
    v7 = "increasing blob capacity failed";
    v8 = 156;
    goto LABEL_9;
  }
  if (*a2)
  {
    v10 = 0;
    v11 = 0;
    v12 = *(_QWORD *)(a1 + 8);
    do
    {
      v13 = v11 + *(_DWORD *)a1;
      *(_OWORD *)(v12 + 16 * v13) = *(_OWORD *)(*((_QWORD *)a2 + 1) + v10);
      v12 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(v12 + 16 * v13) += v15[0];
      ++v11;
      v14 = *a2;
      v10 += 16;
    }
    while (v11 < v14);
  }
  else
  {
    LODWORD(v14) = 0;
  }
  result = 0;
  *(_DWORD *)a1 += v14;
  return result;
}

size_t StringTableSort(unsigned int *a1, _QWORD *a2)
{
  size_t result;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  result = *a1;
  if ((_DWORD)result)
  {
    if (a2)
    {
      v5 = calloc(result, 4uLL);
      if (!v5)
      {
        v13 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/StringTable.c", (uint64_t)"StringTableSort", 195, 35, *v13, "malloc", v14, v15, v16);
        return 0xFFFFFFFFLL;
      }
      v6 = v5;
      *a2 = v5;
      result = *a1;
      if ((_DWORD)result)
      {
        v7 = 0;
        v8 = (_DWORD *)(*((_QWORD *)a1 + 1) + 12);
        do
        {
          *v8 = v7;
          v8 += 4;
          ++v7;
        }
        while (result != v7);
      }
    }
    else
    {
      v6 = 0;
    }
    qsort_r(*((void **)a1 + 1), result, 0x10uLL, a1, (int (__cdecl *)(void *, const void *, const void *))stringTableIndexCompareProc);
    if (*a1 < 2)
    {
      v11 = 1;
    }
    else
    {
      v9 = 0;
      v10 = 1;
      v11 = 1;
      do
      {
        v12 = *((_QWORD *)a1 + 1);
        if (!strcmp((const char *)(*((_QWORD *)a1 + 4) + *(_QWORD *)(v12 + 16 * (v11 - 1))), (const char *)(*((_QWORD *)a1 + 4) + *(_QWORD *)(v12 + v9 + 16))))
        {
          if (v6)
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11 - 1;
        }
        else
        {
          if (v6)
            v6[*(unsigned int *)(v12 + v9 + 28)] = v11;
          if (v10 != v11)
            *(_OWORD *)(v12 + 16 * v11) = *(_OWORD *)(v12 + v9 + 16);
          ++v11;
        }
        ++v10;
        v9 += 16;
      }
      while (v10 < *a1);
    }
    result = 0;
    *a1 = v11;
  }
  return result;
}

uint64_t stringTableIndexCompareProc(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return strcmp((const char *)(*(_QWORD *)(a1 + 32) + *a2), (const char *)(*(_QWORD *)(a1 + 32) + *a3));
}

uint64_t getBXDiffControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int8x16_t **a5, uint64_t a6, int *a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD *v10;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void **v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t NWritten;
  uint64_t v27;
  int8x16_t *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t BestMatch;
  uint64_t v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  unsigned __int8 v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unsigned __int8 v53;
  int v55;
  BOOL v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  unsigned __int8 v62;
  unint64_t v63;
  uint64_t v64;
  char *v65;
  char *v66;
  unint64_t v67;
  char v68;
  char v69;
  char v70;
  unsigned __int8 v71;
  int v73;
  int v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  int *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int64x2_t v90;
  int8x16_t *v91;
  uint64_t v92;
  int8x16_t *v93;
  const char *v94;
  __int16 v95;
  int8x16_t *v96;
  unint64_t v97;
  int *v98;
  uint64_t v99;
  uint64_t v100;
  int64x2_t v101;
  uint64_t v102;
  uint64_t v103;
  char v105;
  _QWORD *v106;
  int8x16_t **v107;
  int v108;
  int64x2_t v109;
  int8x16_t *__ptr;
  BOOL v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;

  v8 = 0xFFFFFFFFLL;
  if (!a2 || !a4)
    return v8;
  v10 = (_QWORD *)a6;
  if (a2 >= a4)
    v13 = a4;
  else
    v13 = a2;
  if (v13 >= 0x10000)
  {
    v14 = a2 - a4;
    if (a2 < a4)
      v14 = a4 - a2;
    v15 = (unsigned __int8 *)a1;
    v16 = (unsigned __int8 *)a3;
    do
    {
      v18 = *v15++;
      v17 = v18;
      v19 = *v16++;
      if (v17 != v19)
        ++v14;
      --v13;
    }
    while (v13);
    if (v14 <= a4 / 0x64)
    {
      v96 = (int8x16_t *)calloc(1uLL, 0x18uLL);
      if (v96)
      {
        *a5 = v96;
        *v10 = 1;
        if (a2 <= a4)
        {
          v8 = 0;
          v101.i64[0] = a2;
          v101.i64[1] = a4 - a2;
          *v96 = vbslq_s8((int8x16_t)vcltzq_s64(v101), (int8x16_t)vsubq_s64(vdupq_n_s64(0x8000000000000000), v101), (int8x16_t)v101);
          v96[1].i64[0] = 0;
        }
        else
        {
          v8 = 0;
          v97 = 0x8000000000000000 - a4;
          v96->i64[1] = 0;
          v96[1].i64[0] = 0;
          if ((a4 & 0x8000000000000000) == 0)
            v97 = a4;
          v96->i64[0] = v97;
        }
        return v8;
      }
      v98 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffFastPathControls", 101, 24, *v98, "calloc", v99, v100, v105);
      v94 = "building fast path controls";
      v95 = 311;
LABEL_121:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", v95, 24, 0, v94, v21, v22, v105);
      return 0xFFFFFFFFLL;
    }
  }
  v20 = BXDiffMatchesCreate(a1, a2, a3, a4, a7, a6, (uint64_t)a7, a8);
  if (!v20)
  {
    v94 = "creating diff match lookup object";
    v95 = 319;
    goto LABEL_121;
  }
  v23 = (void **)v20;
  v24 = BXDiffMatchesIBuf(v20);
  v25 = BXDiffMatchesISize((uint64_t)v23);
  NWritten = OMemStreamGetNWritten((uint64_t)v23);
  v27 = BXDiffMatchesOSize((uint64_t)v23);
  v28 = 0;
  v117 = 0;
  if (!v25 || !v27)
    goto LABEL_126;
  if (v27 < 1)
  {
    v30 = 0;
    v93 = 0;
    goto LABEL_123;
  }
  v115 = (uint64_t)v23;
  v106 = v10;
  v107 = a5;
  __ptr = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v113 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = v27;
  v108 = 1;
  v109 = vdupq_n_s64(0x8000000000000000);
  v116 = v27;
  do
  {
    v112 = v30;
    v34 += v33;
    v111 = v34 < v27;
    v114 = v29;
    v36 = 0;
    if (v34 >= v27)
    {
LABEL_46:
      if (v33 == v36)
      {
        v30 = v112;
        if (v34 != v27)
          continue;
        goto LABEL_50;
      }
    }
    else
    {
      v37 = v34;
      do
      {
        BestMatch = BXDiffMatchesGetBestMatch(v115, v37, &v117);
        v39 = BestMatch + v37;
        if (BestMatch + v37 <= v35)
          v33 = BestMatch;
        else
          v33 = v35 - v37;
        if (v34 >= v33 + v37)
        {
          v27 = v116;
        }
        else
        {
          if (v39 >= v35)
            v39 = v35;
          v40 = (unsigned __int8 *)(NWritten + v34);
          v41 = v39 - v34;
          v42 = v31 + v34;
          v27 = v116;
          do
          {
            if (v42 < v25 && *(unsigned __int8 *)(v24 + v42) == *v40)
              ++v36;
            ++v40;
            ++v42;
            --v41;
          }
          while (v41);
          v34 = v39;
        }
        v43 = v33 != v36 || v33 == 0;
        if (!v43 || v33 > v36 + 8)
        {
          v34 = v37;
          v29 = v114;
          goto LABEL_46;
        }
        if (v37 + v31 < v25)
          v36 -= *(unsigned __int8 *)(v24 + v37 + v31) == *(unsigned __int8 *)(NWritten + v37);
        ++v37;
      }
      while (v37 < v27);
      v111 = 0;
      v34 = v27;
    }
    v30 = v112;
LABEL_50:
    v45 = v34 - v32;
    v46 = v25 - v113;
    if (v34 - v32 < v25 - v113)
      v46 = v34 - v32;
    if (v46 < 1)
    {
      v51 = 0;
    }
    else
    {
      v47 = 0;
      v48 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      do
      {
        v52 = v49 | (v50 << 8);
        v53 = *(_BYTE *)(v24 + v47 + v113) - *(_BYTE *)(NWritten + v47 + v32);
        if ((v50 & 0xFF000000FF0000) != 0 || (unsigned __int16)v52 == 0)
          v55 = 3;
        else
          v55 = 4;
        v56 = __OFADD__(v55, v48);
        v57 = v55 + v48;
        if ((v57 < 0) ^ v56 | (v57 == 0))
          v58 = v51;
        else
          v58 = v47 + 1;
        v59 = v57 & (v57 >> 31);
        v48 -= 4;
        ++v47;
        if (!v53)
        {
          v51 = v58;
          v48 = v59;
        }
        v50 = v52;
        v49 = v53;
      }
      while (v47 != v46);
    }
    if (!v111)
      goto LABEL_86;
    if (v45 >= v117)
      v45 = v117;
    if (v45 >= 1)
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
      v63 = 0;
      v64 = 0;
      v65 = (char *)(NWritten - 1 + v34);
      v66 = (char *)(v24 - 1 + v117);
      do
      {
        ++v60;
        v67 = v62 | (v63 << 8);
        v43 = (v63 & 0xFF000000FF0000) == 0;
        v69 = *v66--;
        v68 = v69;
        v70 = *v65--;
        v71 = v68 - v70;
        if (!v43 || (unsigned __int16)v67 == 0)
          v73 = 3;
        else
          v73 = 4;
        v56 = __OFADD__(v73, v61);
        v74 = v73 + v61;
        if ((v74 < 0) ^ v56 | (v74 == 0))
          v75 = v64;
        else
          v75 = v60;
        v76 = v74 & (v74 >> 31);
        v61 -= 4;
        if (!v71)
        {
          v64 = v75;
          v61 = v76;
        }
        v63 = v67;
        v62 = v71;
      }
      while (v45 != v60);
    }
    else
    {
LABEL_86:
      v64 = 0;
    }
    v77 = v51 + v32 - (v34 - v64);
    if (v51 + v32 > v34 - v64)
    {
      if (v77 < 1)
      {
        v80 = 0;
      }
      else
      {
        v78 = 0;
        v79 = 0;
        v80 = 0;
        do
        {
          v81 = *(unsigned __int8 *)(NWritten + v79 + v34 - v64);
          v78 -= v81 == *(unsigned __int8 *)(v24 + v117 - v64 + v79);
          v82 = *(unsigned __int8 *)(v24 + v113 - (v32 - (v34 - v64)) + v79);
          if (v78 >= 0)
            v83 = v79 + 1;
          else
            v83 = v80;
          if (v78 < 0)
            v84 = v78 + 1;
          else
            v84 = 0;
          ++v79;
          if (v81 == v82)
          {
            v80 = v83;
            v78 = v84;
          }
        }
        while (v79 < v77);
      }
      v51 = v34 - v64 - v32 + v80;
      v64 -= v80;
    }
    v85 = v114;
    if (v30 >= v114)
    {
      v114 += 0x40000;
      __ptr = (int8x16_t *)reallocf(__ptr, 24 * (v85 + 0x40000));
      if (!__ptr)
      {
        v86 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"bxdiffControlsWithMatches", 255, 24, *v86, "malloc", v87, v88, v105);
        __ptr = 0;
        v108 = 0;
      }
      v27 = v116;
    }
    v89 = v51 + v32;
    v32 = v34 - v64;
    v90.i64[0] = v51;
    v90.i64[1] = v34 - v64 - v89;
    v91 = (int8x16_t *)((char *)__ptr + 24 * v30);
    *v91 = vbslq_s8((int8x16_t)vcltzq_s64(v90), (int8x16_t)vsubq_s64(v109, v90), (int8x16_t)v90);
    v92 = v117 - (v51 + v113 + v64);
    if (v92 < 0)
      v92 = 0x8000000000000000 - v92;
    v91[1].i64[0] = v92;
    ++v30;
    v113 = v117 - v64;
    v31 = v117 - v34;
    v29 = v114;
  }
  while (v34 < v27);
  v10 = v106;
  a5 = v107;
  if (!v108)
  {
    v23 = (void **)v115;
    v28 = __ptr;
LABEL_126:
    free(v28);
    *a5 = 0;
    *v10 = 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffBase.c", (uint64_t)"getBXDiffControls", 324, 24, 0, "building diff controls", v102, v103, v105);
    goto LABEL_127;
  }
  v93 = __ptr;
  if (__ptr)
    v93 = (int8x16_t *)reallocToFit(__ptr, 24 * v30);
  v23 = (void **)v115;
LABEL_123:
  *a5 = v93;
  *v10 = v30;
LABEL_127:
  BXDiffMatchesDestroy(v23);
  if (*a5)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

_DWORD *ParallelCompressionAFSCStreamOpen(int a1, unint64_t a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  const char *v11;
  __int16 v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  compression_algorithm v19;
  size_t v20;
  char v21;
  compression_algorithm v22;
  char v23;
  size_t v24;
  unint64_t v25;
  _DWORD *v26;
  _DWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  char v35;

  v10 = calloc(1uLL, 0x78uLL);
  if (!v10)
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", 163, 86, *v13, "malloc", v14, v15, v35);
LABEL_39:
    free(v10);
    return 0;
  }
  if (!a2)
  {
    v11 = "File too small for AFSC";
    v12 = 167;
LABEL_7:
    v16 = 0;
LABEL_38:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamOpen", v12, 86, v16, v11, v8, v9, v35);
    free(*((void **)v10 + 5));
    free(*((void **)v10 + 8));
    free(*((void **)v10 + 10));
    free(*((void **)v10 + 11));
    goto LABEL_39;
  }
  if (a2 >= 0xFA000001)
  {
    v11 = "File too large for AFSC";
    v12 = 168;
    goto LABEL_7;
  }
  if (a3)
    v17 = a3;
  else
    v17 = 4;
  v18 = v17 - 3;
  if ((v17 - 3) <= 0xA && ((0x551u >> v18) & 1) != 0)
    v17 = dword_20643EE60[v18];
  v19 = 0;
  v20 = 0;
  v21 = -52;
  v22 = 1285;
  v23 = -1;
  switch(v17)
  {
    case 4:
      goto LABEL_19;
    case 8:
      v22 = 2304;
      v23 = 6;
      goto LABEL_19;
    case 10:
      goto LABEL_22;
    case 12:
      v22 = COMPRESSION_LZFSE;
      goto LABEL_19;
    case 14:
      v22 = COMPRESSION_LZBITMAP;
LABEL_19:
      v20 = compression_encode_scratch_buffer_size(v22);
      v24 = compression_decode_scratch_buffer_size(v22);
      if (v20 <= v24)
        v20 = v24;
      v19 = v22;
      v21 = v23;
LABEL_22:
      *v10 = a1;
      v25 = (a2 + 0xFFFF) >> 16;
      *((_QWORD *)v10 + 1) = a2;
      v10[4] = v17;
      v10[5] = v19;
      *((_BYTE *)v10 + 24) = v21;
      v10[7] = a4;
      v10[8] = v25;
      v26 = calloc(v25 + 1, 4uLL);
      *((_QWORD *)v10 + 5) = v26;
      if (!v26)
      {
        v16 = *__error();
        v11 = "malloc";
        v12 = 210;
        goto LABEL_38;
      }
      v27 = v26;
      *((_OWORD *)v10 + 3) = xmmword_20643EE10;
      v28 = malloc(0x100000uLL);
      *((_QWORD *)v10 + 8) = v28;
      if (!v28)
      {
        v16 = *__error();
        v11 = "malloc";
        v12 = 214;
        goto LABEL_38;
      }
      *((_QWORD *)v10 + 9) = 0;
      v29 = malloc(0x10000uLL);
      *((_QWORD *)v10 + 10) = v29;
      if (!v29)
      {
        v16 = *__error();
        v11 = "malloc";
        v12 = 217;
        goto LABEL_38;
      }
      if (v20)
      {
        v30 = malloc(v20);
        *((_QWORD *)v10 + 11) = v30;
        if (!v30)
        {
          v16 = *__error();
          v11 = "malloc";
          v12 = 221;
          goto LABEL_38;
        }
      }
      v31 = 2;
      if (v10[4] == 4)
        v31 = 3;
      v32 = 4;
      if (v10[4] == 4)
        v32 = 264;
      v33 = ((unint64_t)v10[8] << v31) + v32;
      if (HIDWORD(v33))
      {
        v11 = "File too large for AFSC";
        v12 = 235;
        goto LABEL_7;
      }
      v10[27] = v33;
      *v27 = v33;
      v10[26] = 0;
      *((_QWORD *)v10 + 12) = 0;
      v10[28] = 0;
      break;
    default:
      v35 = v17;
      v11 = "invalid compression type %d";
      v12 = 192;
      goto LABEL_7;
  }
  return v10;
}

uint64_t ParallelCompressionAFSCStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  unint64_t v10;
  size_t v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  compression_algorithm v23;
  BOOL v24;
  size_t v25;
  size_t v26;
  char v28;

  if (*(_QWORD *)(a1 + 96) + a3 <= *(_QWORD *)(a1 + 8))
  {
    if (!a3)
      return 0;
    v10 = 0;
    v14 = *(_QWORD *)(a1 + 56);
    while (v14 + 65537 <= *(_QWORD *)(a1 + 48) || (flushToResourceFork(a1) & 0x80000000) == 0)
    {
      v15 = *(_QWORD *)(a1 + 72);
      if (0x10000 - v15 + v10 <= a3)
        v16 = 0x10000 - v15;
      else
        v16 = a3 - v10;
      if (v16 == 0x10000)
      {
        v17 = (char *)(a2 + v10);
      }
      else
      {
        v17 = *(char **)(a1 + 80);
        memcpy(&v17[v15], (const void *)(a2 + v10), v16);
        v15 = *(_QWORD *)(a1 + 72);
      }
      v18 = *(_QWORD *)(a1 + 96) + v16;
      *(_QWORD *)(a1 + 96) = v18;
      v10 += v16;
      v19 = v15 + v16;
      *(_QWORD *)(a1 + 72) = v15 + v16;
      if ((v15 + v16) >> 16 || v18 >= *(_QWORD *)(a1 + 8))
      {
        v21 = *(_QWORD *)(a1 + 56);
        v20 = *(_QWORD *)(a1 + 64);
        v22 = (_BYTE *)(v20 + v21);
        v23 = *(_DWORD *)(a1 + 20);
        v24 = v19 < 0x78 || v23 == 0;
        if (v24
          || (v25 = compression_encode_buffer((uint8_t *)(v20 + v21), 0x10000uLL, (const uint8_t *)v17, v19, *(void **)(a1 + 88), v23)) == 0|| (*(_BYTE *)(a1 + 28) & 1) != 0 && (v26 = v25 + (v25 >> 6), v25 = v26 + 32, v26 == -32)|| v25 > *(_QWORD *)(a1 + 72) + 1)
        {
          *v22 = *(_BYTE *)(a1 + 24);
          memcpy(v22 + 1, v17, *(_QWORD *)(a1 + 72));
          v25 = *(_QWORD *)(a1 + 72) + 1;
        }
        *(_QWORD *)(a1 + 72) = 0;
        v14 = *(_QWORD *)(a1 + 56) + v25;
        *(_QWORD *)(a1 + 56) = v14;
        *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * ++*(_DWORD *)(a1 + 104)) = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 104))
                                                                                        + v25;
        if (v10 < a3)
          continue;
      }
      return v10;
    }
    v8 = "update resource fork";
    v9 = 270;
  }
  else
  {
    v8 = "too many bytes received";
    v9 = 262;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamWrite", v9, 86, 0, v8, a7, a8, v28);
  return -1;
}

uint64_t flushToResourceFork(uint64_t a1)
{
  int v2;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char v8;

  v2 = fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), *(_QWORD *)(a1 + 56), *(_DWORD *)(a1 + 108), 0);
  if (v2 < 0)
  {
    v3 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"flushToResourceFork", 142, 86, *v3, "fsetxattr resource fork", v4, v5, v8);
  }
  v6 = *(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 108) = v6;
  *(_DWORD *)(a1 + 112) = 1;
  return (v2 >> 31);
}

uint64_t ParallelCompressionAFSCStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;
  __int16 v10;
  int v11;
  uint64_t v12;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  size_t v23;
  unint64_t v24;
  off_t v25;
  u_int32_t *v26;
  u_int32_t v27;
  size_t v28;
  const uint8_t *v30;
  size_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  unint64_t v40;
  int v41;
  stat v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0;
  memset(&v42, 0, sizeof(v42));
  if (*(_QWORD *)(a1 + 96) >= *(_QWORD *)(a1 + 8) && !*(_QWORD *)(a1 + 72))
  {
    v14 = *(_DWORD *)(a1 + 112);
    v15 = *(_DWORD *)(a1 + 20);
    if (v15)
      v15 = (*(unsigned __int8 *)(a1 + 28) >> 1) & 1;
    if (*(_DWORD *)(a1 + 32) > 1u)
      v15 = 1;
    if ((unint64_t)(*(_QWORD *)(a1 + 56) - 3569) < 0xFFFFFFFFFFFFF1FFLL)
      v15 = 1;
    if (v14 | v15)
    {
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        v9 = "update resource fork";
        v10 = 341;
        goto LABEL_5;
      }
      v14 = *(_DWORD *)(a1 + 112);
    }
    v16 = (__PAIR64__(*(_DWORD *)(a1 + 16), v14) - 1) >> 32;
    v17 = *(_QWORD *)(a1 + 8);
    v18 = *(_QWORD *)(a1 + 80);
    *(_DWORD *)v18 = 1668116582;
    *(_DWORD *)(v18 + 4) = v16;
    *(_QWORD *)(v18 + 8) = v17;
    v19 = 16;
    *(_QWORD *)(a1 + 72) = 16;
    if (!*(_DWORD *)(a1 + 112))
    {
      memcpy((void *)(*(_QWORD *)(a1 + 80) + 16), *(const void **)(a1 + 64), *(_QWORD *)(a1 + 56));
      v19 = *(_QWORD *)(a1 + 72) + *(_QWORD *)(a1 + 56);
      *(_QWORD *)(a1 + 72) = v19;
      *(_QWORD *)(a1 + 56) = 0;
    }
    if (fsetxattr(*(_DWORD *)a1, "com.apple.decmpfs", *(const void **)(a1 + 80), v19, 0, 0) < 0)
    {
      v11 = *__error();
      v9 = "fsetxattr decmpfs";
      v10 = 363;
      goto LABEL_6;
    }
    if (!*(_DWORD *)(a1 + 112))
    {
      v21 = 0;
      goto LABEL_36;
    }
    if (*(_DWORD *)(a1 + 16) == 4)
    {
      v20 = *(_QWORD *)(a1 + 64);
      *(_OWORD *)v20 = old_resource_fork_map;
      *(_OWORD *)(v20 + 16) = unk_20643EE3B;
      *(_OWORD *)(v20 + 32) = xmmword_20643EE4B;
      *(_WORD *)(v20 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 50;
      if ((flushToResourceFork(a1) & 0x80000000) != 0)
      {
        v9 = "update resource fork";
        v10 = 373;
        goto LABEL_5;
      }
      v21 = *(_DWORD *)(a1 + 108);
      if (*(_DWORD *)(a1 + 16) == 4)
      {
        v22 = *(_DWORD *)(a1 + 32);
        if ((unint64_t)(8 * v22) + 264 > *(_QWORD *)(a1 + 48))
        {
          LOBYTE(v41) = 8 * v22 + 8;
          v9 = "File a radar to increase obuf_capacity, sz=%zu";
          v10 = 382;
          goto LABEL_5;
        }
        v43 = 0u;
        v44 = 0u;
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        v51 = 0u;
        v52 = 0u;
        v49 = 0u;
        v50 = 0u;
        v55 = 0u;
        v56 = 0u;
        v53 = 0u;
        v54 = 0u;
        v57 = 0u;
        v32 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)v32 = 0x10000;
        *(int8x8_t *)(v32 + 4) = vrev32_s8((int8x8_t)vadd_s32(vdup_n_s32(v21), (int32x2_t)0xFFFFFECEFFFFFFCELL));
        *(_DWORD *)(v32 + 12) = 838860800;
        v33 = v44;
        *(_OWORD *)(v32 + 16) = v43;
        *(_OWORD *)(v32 + 32) = v33;
        v34 = v48;
        *(_OWORD *)(v32 + 80) = v47;
        *(_OWORD *)(v32 + 96) = v34;
        v35 = v46;
        *(_OWORD *)(v32 + 48) = v45;
        *(_OWORD *)(v32 + 64) = v35;
        v36 = v52;
        *(_OWORD *)(v32 + 144) = v51;
        *(_OWORD *)(v32 + 160) = v36;
        v37 = v50;
        *(_OWORD *)(v32 + 112) = v49;
        *(_OWORD *)(v32 + 128) = v37;
        v38 = v56;
        *(_OWORD *)(v32 + 208) = v55;
        *(_OWORD *)(v32 + 224) = v38;
        v39 = v54;
        *(_OWORD *)(v32 + 176) = v53;
        *(_OWORD *)(v32 + 192) = v39;
        *(_OWORD *)(v32 + 240) = v57;
        *(_DWORD *)(v32 + 256) = bswap32(v21 - 310);
        *(_DWORD *)(v32 + 260) = v22;
        v23 = 264;
        *(_QWORD *)(a1 + 56) = 264;
        if (*(_DWORD *)(a1 + 32))
        {
          v40 = 0;
          v23 = 264;
          do
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 64) + v23) = (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v40) - 260) | ((unint64_t)(*(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v40 + 4) - *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v40)) << 32);
            ++v40;
            v23 = *(_QWORD *)(a1 + 56) + 8;
            *(_QWORD *)(a1 + 56) = v23;
          }
          while (v40 < *(unsigned int *)(a1 + 32));
        }
        goto LABEL_35;
      }
    }
    else
    {
      v21 = *(_DWORD *)(a1 + 108);
    }
    v23 = (4 * *(_DWORD *)(a1 + 32) + 4);
    if (*(_QWORD *)(a1 + 48) < v23)
    {
      v41 = 4 * *(_DWORD *)(a1 + 32) + 4;
      v9 = "File a radar to increase obuf_capacity, sz=%zu";
      v10 = 408;
      goto LABEL_5;
    }
    memcpy(*(void **)(a1 + 64), *(const void **)(a1 + 40), (4 * *(_DWORD *)(a1 + 32) + 4));
    *(_QWORD *)(a1 + 56) = v23;
LABEL_35:
    if (fsetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(const void **)(a1 + 64), v23, 0, 0) < 0)
    {
      v11 = *__error();
      v9 = "fsetxattr resource fork header";
      v10 = 418;
      goto LABEL_6;
    }
LABEL_36:
    if (ftruncate(*(_DWORD *)a1, 0))
    {
      v11 = *__error();
      v9 = "ftruncate";
      v10 = 422;
      goto LABEL_6;
    }
    if ((*(_BYTE *)(a1 + 28) & 4) != 0 || !*(_DWORD *)(a1 + 112) || 93 * *(_QWORD *)(a1 + 8) / 0x64uLL >= v21)
    {
      if (fstat(*(_DWORD *)a1, &v42))
      {
        v11 = *__error();
        v9 = "fstat";
        v10 = 465;
        goto LABEL_6;
      }
      if (fchflags(*(_DWORD *)a1, v42.st_flags | 0x20) < 0)
      {
        v11 = *__error();
        v9 = "fchflags UF_COMPRESSED";
        v10 = 466;
        goto LABEL_6;
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 32))
      {
        v24 = 0;
        v25 = 0;
        while (1)
        {
          v26 = (u_int32_t *)(*(_QWORD *)(a1 + 40) + 4 * v24);
          v27 = v26[1];
          v28 = v27 - *v26;
          if (v27 == *v26 || v28 >= 0x10002)
          {
            v9 = "Invalid chunk size";
            v10 = 437;
            goto LABEL_5;
          }
          if (fgetxattr(*(_DWORD *)a1, "com.apple.ResourceFork", *(void **)(a1 + 64), v27 - *v26, *v26, 32) != v28)
          {
            v9 = "reading chunk";
            v10 = 440;
            goto LABEL_5;
          }
          v30 = *(const uint8_t **)(a1 + 64);
          if (*v30 == *(unsigned __int8 *)(a1 + 24))
          {
            v31 = (v28 - 1);
            memcpy(*(void **)(a1 + 80), v30 + 1, v31);
          }
          else
          {
            v31 = compression_decode_buffer(*(uint8_t **)(a1 + 80), 0x10000uLL, v30, v28, *(void **)(a1 + 88), (compression_algorithm)*(_DWORD *)(a1 + 20));
          }
          if (v31 != 0x10000)
          {
            if (!v31)
            {
              v9 = "Decompression";
              v10 = 451;
              goto LABEL_5;
            }
            if (v31 + v25 != *(_QWORD *)(a1 + 8))
              break;
          }
          if (pwrite(*(_DWORD *)a1, *(const void **)(a1 + 80), v31, v25) != v31)
          {
            v9 = "writing chunk";
            v10 = 454;
            goto LABEL_5;
          }
          ++v24;
          v25 += v31;
          if (v24 >= *(unsigned int *)(a1 + 32))
            goto LABEL_56;
        }
        v9 = "Invalid uncompressed chunk size";
        v10 = 452;
        goto LABEL_5;
      }
LABEL_56:
      if (fremovexattr(*(_DWORD *)a1, "com.apple.ResourceFork", 32) < 0)
      {
        v11 = *__error();
        v9 = "Removing xattr";
        v10 = 459;
        goto LABEL_6;
      }
      if (fremovexattr(*(_DWORD *)a1, "com.apple.decmpfs", 32) < 0)
      {
        v11 = *__error();
        v9 = "Removing xattr";
        v10 = 460;
        goto LABEL_6;
      }
    }
    v12 = 0;
    goto LABEL_7;
  }
  v9 = "not enough bytes received";
  v10 = 325;
LABEL_5:
  v11 = 0;
LABEL_6:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCStreamClose", v10, 86, v11, v9, a7, a8, v41);
  v12 = 0xFFFFFFFFLL;
LABEL_7:
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 88));
  free((void *)a1);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadataFD(int a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  off_t *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  unsigned int v19;
  off_t v20;
  unint64_t v21;
  int v23;
  stat v24;

  memset(&v24, 0, sizeof(v24));
  if (fstat(a1, &v24))
  {
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", 488, 86, *v8, "fstat", v9, v10, v23);
    v11 = 0;
LABEL_22:
    v12 = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  if ((v24.st_flags & 0x20) != 0)
  {
    v11 = (off_t *)malloc(0x1000uLL);
    if (v11)
    {
      v13 = fgetxattr(a1, "com.apple.decmpfs", v11, 0x1000uLL, 0, 32);
      if ((v13 & 0x8000000000000000) != 0)
      {
        v16 = "Missing decmpfs xattr";
        v17 = 504;
      }
      else if (v13 > 0xF)
      {
        if (*(_DWORD *)v11 == 1668116582)
        {
          v19 = *((_DWORD *)v11 + 1);
          if (v19 > 0xE)
            goto LABEL_27;
          v20 = v11[1];
          if (((1 << v19) & 0x2A88) != 0)
          {
            v12 = 0;
            *a2 = v20;
            *a3 = v19;
            goto LABEL_5;
          }
          if (((1 << v19) & 0x5510) != 0)
          {
            *a2 = v20;
            *a3 = v19;
            v21 = fgetxattr(a1, "com.apple.ResourceFork", 0, 0, 0, 32);
            if ((v21 & 0x8000000000000000) != 0)
            {
              v16 = "Missing resource fork xattr";
              v17 = 532;
            }
            else
            {
              if (!HIDWORD(v21))
              {
                v12 = 0;
                *a4 = v21;
                goto LABEL_23;
              }
              v16 = "Invalid resource fork xattr";
              v17 = 533;
            }
          }
          else
          {
LABEL_27:
            v23 = *((_DWORD *)v11 + 1);
            v16 = "Invalid compression type %u in decmpfs xattr";
            v17 = 524;
          }
        }
        else
        {
          v16 = "Invalid decmpfs xattr";
          v17 = 507;
        }
      }
      else
      {
        v16 = "Truncated decmpfs xattr";
        v17 = 505;
      }
      v18 = 0;
    }
    else
    {
      v18 = *__error();
      v16 = "malloc";
      v17 = 501;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadataFD", v17, 86, v18, v16, v14, v15, v23);
    goto LABEL_22;
  }
  v11 = 0;
  v12 = 0;
  *a2 = v24.st_size;
  *a3 = -1;
LABEL_5:
  *a4 = 0;
LABEL_23:
  free(v11);
  return v12;
}

uint64_t ParallelCompressionAFSCGetMetadata(const char *a1, off_t *a2, unsigned int *a3, _DWORD *a4)
{
  char v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (char)a1;
  v8 = open(a1, 0);
  if (v8 < 0)
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 550, 86, *v13, "open %s", v14, v15, v7);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v9 = v8;
    if ((ParallelCompressionAFSCGetMetadataFD(v8, a2, a3, a4) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCGetMetadata", 553, 86, 0, "retrieving AFSC metadata: %s", v10, v11, v7);
      v12 = 0xFFFFFFFFLL;
    }
    else
    {
      v12 = 0;
    }
    close(v9);
  }
  return v12;
}

uint64_t ParallelCompressionAFSCFixupMetadata(const std::__fs::filesystem::path *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int *v18;
  uint64_t v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  char v24;
  int v25;
  int8x8_t v26;
  int8x8_t v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  ssize_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  int v60;
  u_int32_t v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  unint64_t v67;
  unsigned int v68;
  int v69;
  u_int32_t v70;
  unsigned int v71;
  size_t v72;
  int v73;
  int v74;
  _DWORD *v75;
  int *v76;
  int *v77;
  BOOL v78;
  int v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  _DWORD *v87;
  uint64_t v88;
  size_t v89;
  unint64_t *v90;
  int v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  std::error_code *v95;
  int v96;
  int v97;
  uint64_t v98;
  u_int32_t v99;
  size_t v100;
  unsigned int v101;
  size_t v103;
  size_t v104;
  u_int32_t v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  int *v114;
  int v115;
  unint64_t *v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  int v121;
  uint64_t v122;
  uint64_t v123;
  const char *v124;
  __int16 v125;
  int v126;
  uint64_t v127;
  uint64_t v128;
  int *v129;
  uint64_t v130;
  uint64_t v131;
  int *v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  const char *v144;
  __int16 v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  const char *v155;
  __int16 v156;
  int *v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  uint64_t v161;
  uint64_t v162;
  const char *v163;
  __int16 v164;
  int v165;
  uint64_t v166;
  uint64_t v167;
  const char *v168;
  __int16 v169;
  char v170;
  uint64_t v171;
  size_t size;
  unint64_t v173;
  uint64_t v174;
  uint64_t v175;
  u_int32_t position;
  unsigned int v177;
  int v178;
  int v179;
  unint64_t *v180;
  int v181;
  _DWORD *v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int v185;
  int v186;
  char v187;
  int *v188;
  int *v189;
  int fd;
  _QWORD value[2];
  stat v192;
  unint64_t v193;
  u_int32_t v194;
  unsigned int v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  int v211;
  std::__fs::filesystem::path __from;
  uint64_t v213;

  v213 = *MEMORY[0x24BDAC8D0];
  v195 = -1;
  v194 = 0;
  v193 = 0;
  memset(&v192, 0, sizeof(v192));
  v211 = 0;
  v209 = 0u;
  v210 = 0u;
  v207 = 0u;
  v208 = 0u;
  v205 = 0u;
  v206 = 0u;
  v203 = 0u;
  v204 = 0u;
  v201 = 0u;
  v202 = 0u;
  v199 = 0u;
  v200 = 0u;
  v197 = 0u;
  v198 = 0u;
  v196 = 0u;
  value[0] = 0;
  value[1] = 0;
  if ((unint64_t)__strlcpy_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 581, 86, 0, "Path too long: %s", v6, v7, (char)a1);
LABEL_5:
    v17 = 0;
    v18 = 0;
LABEL_134:
    v45 = 0;
    v75 = 0;
    v77 = 0;
    v35 = -1;
LABEL_135:
    v37 = -1;
    goto LABEL_136;
  }
  if ((unint64_t)__strlcat_chk() >= 0x400)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 582, 86, 0, "Path too long: %s", v15, v16, (char)a1);
    goto LABEL_5;
  }
  v18 = (int *)malloc(0x100000uLL);
  if (!v18)
  {
    v23 = *__error();
    v21 = "malloc";
    v22 = 586;
LABEL_133:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v22, 86, v23, v21, v13, v14, v170);
    v17 = 0;
    goto LABEL_134;
  }
  if (a2)
    v19 = a2;
  else
    v19 = 4;
  if ((v19 + 1) > 0xF)
    goto LABEL_131;
  v20 = 1 << (v19 + 1);
  if ((v20 & 0x5511) != 0)
  {
    if (a3)
    {
      v170 = a3;
      v21 = "Invalid resource fork size request: %u";
      v22 = 605;
LABEL_132:
      v23 = 0;
      goto LABEL_133;
    }
    goto LABEL_16;
  }
  if ((v20 & 0xAA20) == 0)
  {
LABEL_131:
    v170 = v19;
    v21 = "Invalid compression type request %d";
    v22 = 608;
    goto LABEL_132;
  }
LABEL_16:
  if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
  {
LABEL_130:
    v170 = (char)a1;
    v21 = "obtain AFSC data: %s";
    v22 = 615;
    goto LABEL_132;
  }
  v24 = 0;
  v181 = 0;
  v25 = 0;
  v182 = v18 + 3;
  v180 = (unint64_t *)(v18 + 66);
  v26 = (int8x8_t)vadd_s32(vdup_n_s32(a3), (int32x2_t)0xFFFFFECEFFFFFFCELL);
  v27 = vrev32_s8(v26);
  position = v26.i32[0];
  v177 = bswap32(a3 - 310);
  v28 = (int)v19 - 4;
  v185 = (0x551u >> (v19 - 4)) & 1;
  while (1)
  {
    v29 = v193;
    if (v193 >= 0xFA000001)
    {
      v21 = "Invalid AFSC data";
      v22 = 616;
      goto LABEL_132;
    }
    v187 = v24;
    if (v195 == (_DWORD)v19)
    {
      if (!a3 || v194 == a3)
        goto LABEL_152;
      if ((v19 & 0x80000000) == 0)
        goto LABEL_55;
    }
    else if ((v19 & 0x80000000) == 0)
    {
      v174 = v28;
      v30 = 4;
      if (v19 > 0xE)
      {
        v33 = v19;
      }
      else
      {
        v31 = 1 << v19;
        if (((1 << v19) & 0x5510) != 0)
          v32 = 6;
        else
          v32 = 4;
        if ((v31 & 0x2A88) != 0)
          v30 = 4;
        else
          v30 = v32;
        if ((v31 & 0x2A88) != 0)
          v33 = v19 + 1;
        else
          v33 = v19;
      }
      v34 = open((const char *)a1, 0);
      v35 = v34;
      if ((v34 & 0x80000000) == 0)
      {
        if (!fstat(v34, &v192))
        {
          v178 = v25;
          v36 = mkstemp((char *)&__from);
          v37 = v36;
          if (v36 < 0)
          {
            v157 = __error();
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 664, 86, *v157, "mkstemp", v158, v159, v170);
            v17 = 0;
            v45 = 0;
          }
          else
          {
            v45 = ParallelCompressionAFSCStreamOpen(v36, v29, v33, v30);
            if (v45)
            {
              v183 = v19;
              fd = v35;
              v188 = v18;
              v46 = 0;
              v47 = 0;
              v48 = 0x100000;
              v49 = 0x100000;
              while (1)
              {
                v50 = v29 >= v49 ? v49 : v29;
                if (v49 - 0x100000 >= v29)
                  break;
                v51 = v50 + v46;
                v52 = read(fd, v188, v50 + v46);
                if (v52 < 0)
                {
                  v126 = *__error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 675, 86, v126, "read: %s", v127, v128, (char)a1);
                  goto LABEL_149;
                }
                if (v52 < v51)
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 676, 86, 0, "truncated read: %s", v56, v57, (char)a1);
LABEL_149:
                  v17 = 0;
LABEL_150:
                  v75 = 0;
                  v77 = 0;
                  v18 = v188;
                  goto LABEL_151;
                }
                v47 += 0x100000;
                v58 = ParallelCompressionAFSCStreamWrite((uint64_t)v45, (uint64_t)v188, v51, v53, v54, v55, v56, v57);
                v49 += 0x100000;
                v46 -= 0x100000;
                if (v29 >= v47)
                  v59 = v47;
                else
                  v59 = v29;
                v48 -= 0x100000;
                if (v58 < (uint64_t)(v59 + v48))
                {
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 678, 86, 0, "write to stream failed: %s", v43, v44, (char)a1);
                  goto LABEL_149;
                }
              }
              if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v38, v39, v40, v41, v42, v43, v44) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 683, 86, 0, "Stream close error", v93, v94, v170);
                v17 = 0;
                v45 = 0;
                goto LABEL_150;
              }
              fchown(v37, v192.st_uid, v192.st_gid);
              fchmod(v37, v192.st_mode & 0xFFF);
              close(fd);
              close(v37);
              rename(&__from, a1, v95);
              v97 = v96;
              unlink((const char *)&__from);
              v18 = v188;
              v19 = v183;
              v28 = v174;
              v25 = v178;
              if ((v97 & 0x80000000) == 0)
                goto LABEL_55;
              v23 = *__error();
              v170 = (char)a1;
              v21 = "rename: %s";
              v22 = 694;
              goto LABEL_133;
            }
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 667, 86, 0, "creating compression stream %s", v43, v44, (char)a1);
            v17 = 0;
          }
          v75 = 0;
          v77 = 0;
          goto LABEL_136;
        }
        v141 = *__error();
        v170 = (char)a1;
        v144 = "stat: %s";
        v145 = 661;
        goto LABEL_170;
      }
      v146 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 660, 86, v146, "open: %s", v147, v148, (char)a1);
LABEL_171:
      v17 = 0;
      v45 = 0;
      v75 = 0;
      v77 = 0;
      goto LABEL_135;
    }
    v60 = open((const char *)a1, 9);
    v35 = v60;
    if (v60 < 0)
    {
      v135 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 629, 86, v135, "open %s", v136, v137, (char)a1);
      goto LABEL_171;
    }
    if (write(v60, 0, 0) < 0)
    {
      v141 = *__error();
      v144 = "write";
      v145 = 630;
LABEL_170:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v145, 86, v141, v144, v142, v143, v170);
      goto LABEL_171;
    }
    if (close(v35) < 0)
    {
      v23 = *__error();
      v21 = "close";
      v22 = 631;
      goto LABEL_133;
    }
    v195 = -1;
    v194 = 0;
LABEL_55:
    if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) != 0)
    {
      v170 = (char)a1;
      v21 = "obtain AFSC data: %s";
      v22 = 699;
      goto LABEL_132;
    }
    if (v195 != (_DWORD)v19)
    {
      v21 = "Couldn't convert to requested compression type";
      v22 = 700;
      goto LABEL_132;
    }
    if (!a3)
      goto LABEL_152;
    v61 = v194;
    v62 = a3 - v194;
    if (a3 == v194)
      goto LABEL_152;
    if (a3 >= v194)
      break;
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 711, 86, "Can't shrink resource fork: %s (current %u, target %u)", v12, v13, v14, (char)a1);
LABEL_61:
    if ((v187 & 1) != 0)
    {
      v21 = "Second pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)";
      v170 = (char)a1;
      v22 = 852;
      goto LABEL_132;
    }
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 859, 86, "First pass fixup failed: %s, compression_type=%d (expected %d), resource_fork_size=%u (expected %u)", v12, v13, v14, (char)a1);
    v63 = open((const char *)a1, 9);
    v35 = v63;
    if (v63 < 0)
    {
      v138 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 864, 86, v138, "open %s", v139, v140, (char)a1);
      goto LABEL_171;
    }
    if (write(v63, 0, 0) < 0)
    {
      v141 = *__error();
      v144 = "write";
      v145 = 865;
      goto LABEL_170;
    }
    if (close(v35) < 0)
    {
      v23 = *__error();
      v21 = "close";
      v22 = 866;
      goto LABEL_133;
    }
    v195 = -1;
    v194 = 0;
    v64 = ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194);
    v24 = 1;
    if (v64 < 0)
      goto LABEL_130;
  }
  if (v28 > 0xA || !v185)
  {
    v170 = v19;
    v21 = "Invalid compression type %u";
    v22 = 722;
    goto LABEL_132;
  }
  v184 = v19;
  v186 = dword_20643EE8C[v28];
  v65 = open((const char *)a1, 0);
  v66 = v65;
  if (v65 < 0)
  {
    v149 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 727, 86, v149, "open: %s", v150, v151, (char)a1);
LABEL_176:
    v17 = 0;
    v45 = 0;
    v75 = 0;
    v77 = 0;
    v37 = -1;
    v35 = v66;
    goto LABEL_136;
  }
  if (fstat(v65, &v192))
  {
    v152 = *__error();
    v155 = "fstat";
    v156 = 728;
LABEL_175:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v156, 86, v152, v155, v153, v154, v170);
    goto LABEL_176;
  }
  if (fgetxattr(v66, "com.apple.decmpfs", value, 0x10uLL, 0, 32) != 16)
  {
    v152 = *__error();
    v155 = "Reading decmpfs";
    v156 = 729;
    goto LABEL_175;
  }
  fd = v66;
  if (fchflags(v66, v192.st_flags & 0xFFFFFFDF) < 0)
  {
    v121 = *__error();
    v124 = "fchflags UF_COMPRESSED";
    v125 = 730;
LABEL_145:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v125, 86, v121, v124, v122, v123, v170);
    v17 = 0;
    v45 = 0;
    v75 = 0;
    v77 = 0;
    goto LABEL_146;
  }
  v179 = v25;
  v67 = v29 + 0xFFFF;
  v173 = (v29 + 0xFFFF) >> 16;
  v175 = v28;
  v68 = v61 + 0x100000;
  v69 = -v61;
  v70 = v61;
  while (1)
  {
    v71 = a3 >= v68 ? v68 : a3;
    if (v70 >= a3)
      break;
    v72 = v71 + v69;
    if (v70 == v61)
      __memset_chk();
    v73 = fsetxattr(fd, "com.apple.ResourceFork", v18, v72, v70, 0);
    v68 += 0x100000;
    v69 -= 0x100000;
    v70 += 0x100000;
    if (v73)
    {
      v121 = *__error();
      v124 = "Expanding resource fork";
      v125 = 738;
      goto LABEL_145;
    }
  }
  v74 = v173;
  v75 = malloc((4 * v173 + 4));
  size = (4 * v173 + 4);
  v76 = (int *)malloc(size);
  v77 = v76;
  if (v75)
    v78 = v76 == 0;
  else
    v78 = 1;
  if (v78)
  {
    v160 = *__error();
    v163 = "malloc";
    v164 = 744;
    goto LABEL_183;
  }
  v171 = (v67 >> 16);
  if ((_DWORD)v184 != 4)
  {
    v35 = fd;
    v89 = (4 * v173 + 4);
    if (fgetxattr(fd, "com.apple.ResourceFork", v75, size, 0, 32) == size)
    {
LABEL_98:
      v189 = v18;
      memcpy(v77, v75, v89);
      v77[v173] = v75[v173] + v62;
      while (v62 && v74)
      {
        v98 = (v74 - 1);
        v99 = v75[v98];
        v100 = v75[v74] - v99;
        if (fgetxattr(v35, "com.apple.ResourceFork", v189, v100, v99, 32) != v100)
        {
          v129 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 777, 86, *v129, "Reading chunk", v130, v131, v170);
          v17 = 0;
          v45 = 0;
          v37 = -1;
          v18 = v189;
          goto LABEL_136;
        }
        v101 = 0x10000 - v100;
        if (v186 == *(unsigned __int8 *)v189 || v100 > 0x10000)
          v101 = 0;
        if (v62 >= v101)
          v103 = v101;
        else
          v103 = v62;
        if ((_DWORD)v103)
          bzero((char *)v189 + v100, v103);
        v104 = (v103 + v100);
        v105 = v77[v74] - v104;
        v77[v98] = v105;
        v62 -= v103;
        v35 = fd;
        --v74;
        if (fsetxattr(fd, "com.apple.ResourceFork", v189, v104, v105, 0))
        {
          v132 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 791, 86, *v132, "Writing chunk", v133, v134, v170);
          v17 = 0;
          v45 = 0;
          v37 = -1;
          v18 = v189;
          goto LABEL_136;
        }
      }
      v19 = v184;
      if ((_DWORD)v184 == 4)
      {
        v18 = v189;
        v25 = v179;
        *v189 = v179;
        *(int8x8_t *)(v189 + 1) = v27;
        v106 = v209;
        *((_OWORD *)v182 + 12) = v208;
        *((_OWORD *)v182 + 13) = v106;
        *((_OWORD *)v182 + 14) = v210;
        v182[60] = v211;
        v107 = v205;
        *((_OWORD *)v182 + 8) = v204;
        *((_OWORD *)v182 + 9) = v107;
        v108 = v207;
        *((_OWORD *)v182 + 10) = v206;
        *((_OWORD *)v182 + 11) = v108;
        v109 = v201;
        *((_OWORD *)v182 + 4) = v200;
        *((_OWORD *)v182 + 5) = v109;
        v110 = v203;
        *((_OWORD *)v182 + 6) = v202;
        *((_OWORD *)v182 + 7) = v110;
        v111 = v197;
        *(_OWORD *)v182 = v196;
        *((_OWORD *)v182 + 1) = v111;
        v112 = v199;
        *((_OWORD *)v182 + 2) = v198;
        *((_OWORD *)v182 + 3) = v112;
        v189[64] = v177;
        v189[65] = v181;
        v113 = v171;
        if ((_DWORD)v173)
        {
          v114 = v77 + 1;
          v115 = *v77;
          v116 = v180;
          do
          {
            v117 = *v114++;
            *v116++ = (v115 - 260) | ((unint64_t)(v117 - v115) << 32);
            v115 = v117;
            --v113;
          }
          while (v113);
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", v189, (8 * v173) + 264, 0, 0))
        {
          v165 = *__error();
          v168 = "Writing resource fork header";
          v169 = 817;
          goto LABEL_189;
        }
        if (fsetxattr(v35, "com.apple.ResourceFork", &old_resource_fork_map, 0x32uLL, position, 0))
        {
          v165 = *__error();
          v168 = "Writing resource map";
          v169 = 820;
          goto LABEL_189;
        }
      }
      else
      {
        v18 = v189;
        v25 = v179;
        if (fsetxattr(v35, "com.apple.ResourceFork", v77, size, 0, 0))
        {
          v165 = *__error();
          v168 = "Writing chunk sizes";
          v169 = 827;
          goto LABEL_189;
        }
      }
      if (fsetxattr(v35, "com.apple.decmpfs", value, 0x10uLL, 0, 0))
      {
        v165 = *__error();
        v168 = "Writing decmpfs";
        v169 = 831;
      }
      else
      {
        if ((fchflags(v35, v192.st_flags | 0x20) & 0x80000000) == 0)
        {
          close(v35);
          free(v75);
          free(v77);
          if ((ParallelCompressionAFSCGetMetadata((const char *)a1, (off_t *)&v193, &v195, &v194) & 0x80000000) == 0)
          {
            if (v195 != (_DWORD)v184)
            {
              v28 = v175;
              goto LABEL_61;
            }
            v28 = v175;
            if (v194 != a3)
              goto LABEL_61;
LABEL_152:
            if ((v187 & 1) != 0)
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 876, 86, "Second pass fixup succeeded: %s", v12, v13, v14, (char)a1);
            v45 = 0;
            v75 = 0;
            v77 = 0;
            v35 = -1;
            v17 = 1;
            goto LABEL_135;
          }
          v170 = (char)a1;
          v21 = "obtain AFSC data: %s";
          v22 = 840;
          goto LABEL_132;
        }
        v165 = *__error();
        v168 = "fchflags UF_COMPRESSED";
        v169 = 832;
      }
    }
    else
    {
      v165 = *__error();
      v168 = "Reading chunk sizes";
      v169 = 763;
    }
LABEL_189:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v169, 86, v165, v168, v166, v167, v170);
    v17 = 0;
    v45 = 0;
    goto LABEL_135;
  }
  if (fgetxattr(fd, "com.apple.ResourceFork", v18, (8 * v173) + 264, 0, 32) == (8 * v173)
                                                                                              + 264)
  {
    v79 = *v18;
    v80 = *((_OWORD *)v182 + 13);
    v208 = *((_OWORD *)v182 + 12);
    v209 = v80;
    v210 = *((_OWORD *)v182 + 14);
    v211 = v182[60];
    v81 = *((_OWORD *)v182 + 9);
    v204 = *((_OWORD *)v182 + 8);
    v205 = v81;
    v82 = *((_OWORD *)v182 + 11);
    v206 = *((_OWORD *)v182 + 10);
    v207 = v82;
    v83 = *((_OWORD *)v182 + 5);
    v200 = *((_OWORD *)v182 + 4);
    v201 = v83;
    v84 = *((_OWORD *)v182 + 7);
    v202 = *((_OWORD *)v182 + 6);
    v203 = v84;
    v85 = *((_OWORD *)v182 + 1);
    v196 = *(_OWORD *)v182;
    v197 = v85;
    v86 = *((_OWORD *)v182 + 3);
    v198 = *((_OWORD *)v182 + 2);
    v199 = v86;
    v181 = v18[65];
    v35 = fd;
    v179 = v79;
    if ((_DWORD)v173)
    {
      v87 = v75 + 1;
      v88 = (v67 >> 16);
      v89 = (4 * v173 + 4);
      v90 = v180;
      do
      {
        v91 = *(_DWORD *)v90;
        v92 = *((_DWORD *)v90++ + 1);
        v91 += 260;
        *(v87 - 1) = v91;
        *v87++ = v91 + v92;
        --v88;
      }
      while (v88);
    }
    else
    {
      v89 = 4;
    }
    goto LABEL_98;
  }
  v160 = *__error();
  v163 = "Reading chunk sizes";
  v164 = 749;
LABEL_183:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", v164, 86, v160, v163, v161, v162, v170);
  v17 = 0;
  v45 = 0;
LABEL_146:
  v37 = -1;
LABEL_151:
  v35 = fd;
LABEL_136:
  if ((ParallelCompressionAFSCStreamClose((uint64_t)v45, v8, v9, v10, v11, v12, v13, v14) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCFixupMetadata", 877, 86, 0, "Stream close error", v118, v119, v170);
    v17 = 0;
  }
  if ((v35 & 0x80000000) == 0)
    close(v35);
  if ((v37 & 0x80000000) == 0)
  {
    close(v37);
    unlink((const char *)&__from);
  }
  free(v18);
  free(v75);
  free(v77);
  if (v17)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t ParallelCompressionAFSCUseMaxEmbeddedSize(const char *a1)
{
  int v2;

  v2 = 1;
  return fsctl(a1, 0xC0044A36uLL, &v2, 0);
}

uint64_t ParallelCompressionAFSCCompress(const char *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  ssize_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  void *v17;
  int v18;
  int v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  ssize_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  const char *v41;
  __int16 v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  __int16 v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  char v58;
  int v59;
  unsigned int v60;
  unint64_t v61;

  v61 = 0;
  v60 = -1;
  if ((ParallelCompressionAFSCGetMetadata(a1, (off_t *)&v61, &v60, &v59) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 907, 86, 0, "looking up AFSC data: %s", v4, v5, (char)a1);
    return 0xFFFFFFFFLL;
  }
  v6 = v61;
  if (!v61)
    return 0;
  if (v60 == -1)
  {
    if (!a2)
      return 0;
    v17 = malloc(0x10000uLL);
    if (v17)
    {
      v18 = open(a1, 2);
      if ((v18 & 0x80000000) == 0)
      {
        v19 = v18;
        v20 = ParallelCompressionAFSCStreamOpen(v18, v6, 0, 0);
        if (v20)
        {
          v28 = (uint64_t)v20;
          v29 = 0;
          v30 = 0;
          v31 = 0x10000;
          v32 = 0x10000;
          while (1)
          {
            if (v6 >= v32)
              v33 = v32;
            else
              v33 = v6;
            if (v32 - 0x10000 >= v6)
            {
              v51 = 1;
              goto LABEL_43;
            }
            v34 = v33 + v29;
            v35 = read(v19, v17, v33 + v29);
            if (v35 < 0)
            {
              v52 = *__error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 950, 86, v52, "read: %s", v53, v54, (char)a1);
              goto LABEL_42;
            }
            if (v34 != v35)
            {
              v58 = (char)a1;
              v41 = "truncated read: %s";
              v42 = 951;
              goto LABEL_41;
            }
            v39 = ParallelCompressionAFSCStreamWrite(v28, (uint64_t)v17, v34, v36, v37, v38, v26, v27);
            if (v39 < 0)
              break;
            v30 += 0x10000;
            v32 += 0x10000;
            v29 -= 0x10000;
            if (v6 >= v30)
              v40 = v30;
            else
              v40 = v6;
            v31 -= 0x10000;
            if (v40 + v31 != v39)
            {
              v58 = (char)a1;
              v41 = "truncated write: %s";
              v42 = 954;
              goto LABEL_41;
            }
          }
          v58 = (char)a1;
          v41 = "Stream write failed: %s";
          v42 = 953;
LABEL_41:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v42, 86, 0, v41, v26, v27, v58);
LABEL_42:
          v51 = 0;
LABEL_43:
          if ((ParallelCompressionAFSCStreamClose(v28, v21, v22, v23, v24, v25, v26, v27) & 0x80000000) == 0)
            goto LABEL_46;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 956, 86, 0, "AFSC compression failed: %s", v55, v56, (char)a1);
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 942, 86, 0, "creating AFSC stream: %s", v26, v27, (char)a1);
        }
        v51 = 0;
LABEL_46:
        close(v19);
LABEL_47:
        free(v17);
        if (v51)
          return 0;
        else
          return 0xFFFFFFFFLL;
      }
      v46 = *__error();
      v57 = (char)a1;
      v49 = "open: %s";
      v50 = 940;
    }
    else
    {
      v46 = *__error();
      v49 = "malloc";
      v50 = 938;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", v50, 86, v46, v49, v47, v48, v57);
    v51 = 0;
    goto LABEL_47;
  }
  if (a2)
    return 0;
  v7 = open(a1, 9);
  if (v7 < 0)
  {
    v43 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 921, 86, v43, "open: %s", v44, v45, (char)a1);
    return 0xFFFFFFFFLL;
  }
  v8 = v7;
  v9 = write(v7, 0, 0);
  if (v9 < 0)
  {
    v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 922, 86, *v10, "write: %s", v11, v12, (char)a1);
  }
  if (close(v8) < 0)
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ParallelCompressionAFSCStream.c", (uint64_t)"ParallelCompressionAFSCCompress", 923, 86, *v13, "close: %s", v14, v15, (char)a1);
  }
  return v9 >> 63;
}

uint64_t fullReplacementBXPatch5(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CC_SHA1_CTX *v18;
  CC_SHA1_CTX *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  const char *v26;
  __int16 v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v12 = *(_QWORD *)(a1 + 32);
  if (a5 >= 1)
    fwrite("Full replacement patch\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  if (v12 + 60 <= a2)
  {
    if (v12 + 60 < a2)
      fwrite("Extra bytes in patch (ignored)", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    v14 = (char *)malloc(0x20000uLL);
    if (v14)
    {
      v17 = ILowMemoryDecoderStreamCreateWithBuffer(a1 + 60, v12, 0x20000uLL);
      if (v17)
      {
        v18 = (CC_SHA1_CTX *)OSHA1StreamCreate(a3, 0, a4);
        if (v18)
        {
          v19 = v18;
          v20 = *(_QWORD *)(a1 + 16);
          if (v20)
          {
            v21 = 0;
            while (1)
            {
              v22 = v20 - v21;
              if (v22 >= 0x20000)
                v23 = 0x20000;
              else
                v23 = v22;
              if (ILowMemoryDecoderStreamRead(v17, v14, v23) != v23)
              {
                v26 = "reading from payload stream";
                v27 = 62;
                goto LABEL_32;
              }
              if (OSHA1StreamWrite(v19, v14, v23) != v23)
                break;
              v21 += v23;
              v20 = *(_QWORD *)(a1 + 16);
              if (v21 >= v20)
                goto LABEL_18;
            }
            v26 = "writing to digest stream";
            v27 = 64;
          }
          else
          {
LABEL_18:
            OSHA1StreamDestroy(v19, (unsigned __int8 *)&v32);
            if (v32 == *(_QWORD *)(a1 + 40)
              && v33 == *(_QWORD *)(a1 + 48)
              && v34 == (unint64_t)*(unsigned int *)(a1 + 56))
            {
              v13 = 0;
LABEL_34:
              free(v14);
              ILowMemoryDecoderStreamDestroy(v17);
              return v13;
            }
            v26 = "Invalid output digest after patch application";
            v27 = 71;
          }
        }
        else
        {
          v26 = "Digest stream init";
          v27 = 52;
        }
      }
      else
      {
        v26 = "Payload stream init";
        v27 = 51;
      }
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", v27, 42, 0, v26, v15, v16, v32);
    }
    else
    {
      v28 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 50, 42, *v28, "malloc", v29, v30, v32);
      v17 = 0;
    }
    v13 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"fullReplacementBXPatch5", 45, 42, 0, "Missing bytes in patch", a7, a8, v32);
  return 0xFFFFFFFFLL;
}

uint64_t BXDiff5GetPatchInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v5;

  if (a2 < 8)
    return 0xFFFFFFFFLL;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  result = 0xFFFFFFFFLL;
  if (a2 >= 0x3C && *(_QWORD *)a1 == 0x3035464649445842)
  {
    result = 0;
    *(_QWORD *)a3 = *(_QWORD *)(a1 + 16);
    v5 = *(_DWORD *)(a1 + 12) & 1;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8) == 0;
    *(_DWORD *)(a3 + 12) = v5;
  }
  return result;
}

uint64_t BXPatch5(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, void *, uint64_t), uint64_t a6, int a7)
{
  _QWORD v8[2];

  v8[0] = a1;
  v8[1] = a2;
  return BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsBufferStreamPRead, (uint64_t)v8, a2, a3, a4, a5, a6, a7 > 0);
}

uint64_t BXPatch5WithFlags(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, void *, uint64_t), uint64_t a6, uint64_t a7)
{
  _QWORD v8[2];

  v8[0] = a1;
  v8[1] = a2;
  return BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsBufferStreamPRead, (uint64_t)v8, a2, a3, a4, a5, a6, a7);
}

uint64_t BXPatch5StreamWithFlags(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t (*a6)(uint64_t, void *, uint64_t), uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  unsigned int v12;
  unint64_t v13;
  int v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  void *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v39;
  unint64_t v40;
  uint64_t result;
  int v42;
  const char *v43;
  __int16 v44;
  FILE **v45;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  size_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  CC_SHA1_CTX *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  void *v91;
  unint64_t v92;
  unint64_t v93;
  size_t v94;
  char *v95;
  char *v96;
  size_t i;
  char v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  size_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void ***v109;
  CC_SHA1_CTX *v110;
  unsigned int v111;
  int v112;
  const char *v113;
  __int16 v114;
  uint64_t v115;
  uint64_t v116;
  const char *v117;
  __int16 v118;
  const char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char v130;
  char v131;
  uint64_t v132;
  uint64_t v133;
  CC_SHA1_CTX *v134;
  uint64_t v135;
  size_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  void *v148;
  int v149;
  void *v150;
  uint64_t *v151;
  char *v152;
  CC_SHA1_CTX c;
  unsigned __int8 md[8];
  uint64_t v155;
  int v156;
  uint64_t v157;

  v157 = *MEMORY[0x24BDAC8D0];
  if (a5 <= 0x3B)
  {
    v8 = "Invalid patch size";
    v9 = 264;
    goto LABEL_48;
  }
  if (*(_QWORD *)a4 != 0x3035464649445842)
  {
    v8 = "Invalid patch header";
    v9 = 265;
    goto LABEL_48;
  }
  v12 = *(_DWORD *)(a4 + 8);
  v13 = 28 * v12 + 60;
  if (v13 > a5)
  {
    v8 = "Invalid patch size";
    v9 = 269;
    goto LABEL_48;
  }
  v16 = a8 & 1;
  v17 = *(_QWORD *)(a4 + 24);
  v18 = __CFADD__(v13, v17);
  v19 = v13 + v17;
  if (v18)
    v19 = -1;
  if (!v12)
  {
    v39 = *(_QWORD *)(a4 + 32);
    v18 = __CFADD__(v19, v39);
    v40 = v19 + v39;
    if (v18)
      v40 = -1;
    if (v40 <= a5)
      return fullReplacementBXPatch5(a4, a5, (uint64_t)a6, a7, a8 & 1, (uint64_t)a6, a7, a8);
    goto LABEL_42;
  }
  v23 = *(unsigned int *)(a4 + 8);
  v24 = (uint64_t *)(a4 + 60);
  do
  {
    v25 = *v24;
    v24 = (uint64_t *)((char *)v24 + 28);
    v18 = __CFADD__(v19, v25);
    v19 += v25;
    if (v18)
      v19 = -1;
    --v23;
  }
  while (v23);
  v26 = *(_QWORD *)(a4 + 32);
  v18 = __CFADD__(v19, v26);
  v27 = v19 + v26;
  if (v18)
    v27 = -1;
  if (v27 > a5)
  {
LABEL_42:
    v8 = "Invalid patch size";
    v9 = 278;
    goto LABEL_48;
  }
  v151 = (uint64_t *)(a4 + 60);
  *(_QWORD *)md = 0;
  v155 = 0;
  v156 = 0;
  memset(&c, 0, sizeof(c));
  v28 = malloc(0x40000uLL);
  if (!v28)
  {
    v42 = *__error();
    v43 = "malloc";
    v44 = 156;
LABEL_46:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"getStreamSHA1Digest", v44, 42, v42, v43, v32, v33, v130);
    free(v28);
    goto LABEL_47;
  }
  v149 = v16;
  CC_SHA1_Deprecated_Init(&c);
  v29 = 0;
  if (a3)
  {
    while (1)
    {
      v30 = v29 + 0x40000 <= a3 ? 0x40000 : a3 - v29;
      v31 = a1(a2, v28, v30, v29);
      if (v31 <= 0)
        break;
      v34 = v31;
      CC_SHA1_Deprecated_Update(&c, v28, v31);
      v29 += v34;
      if (v29 >= a3)
        goto LABEL_27;
    }
    v43 = "inProc read";
    v44 = 165;
    v42 = 0;
    goto LABEL_46;
  }
LABEL_27:
  CC_SHA1_Deprecated_Final(md, &c);
  free(v28);
  if (v29 != a3)
  {
LABEL_47:
    v8 = "Input digest failed";
    v9 = 285;
    goto LABEL_48;
  }
  if (!v149)
  {
    v36 = a4 + 40;
    if (*(_QWORD *)md != *(_QWORD *)(a4 + 40)
      || v155 != *(_QWORD *)(a4 + 48)
      || v156 != (unint64_t)*(unsigned int *)(a4 + 56))
    {
      goto LABEL_56;
    }
LABEL_76:
    if ((copyStream(a1, a2, a3, a6, a7) & 0x80000000) == 0)
      return 0;
    v8 = "Output copy failed\n";
    v9 = 293;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v9, 42, 0, v8, a7, a8, v130);
    return 0xFFFFFFFFLL;
  }
  v45 = (FILE **)MEMORY[0x24BDAC8D8];
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Input variants in patch: %u\n", *(_DWORD *)(a4 + 8));
  v36 = a4 + 40;
  if (*(_QWORD *)md == *(_QWORD *)(a4 + 40)
    && v155 == *(_QWORD *)(a4 + 48)
    && v156 == (unint64_t)*(unsigned int *)(a4 + 56))
  {
    fwrite("No-op patch matching, writing input\n", 0x24uLL, 1uLL, *v45);
    goto LABEL_76;
  }
LABEL_56:
  v48 = *(unsigned int *)(a4 + 8);
  if (!(_DWORD)v48)
  {
LABEL_66:
    v8 = "Input doesn't match any of the expected patch inputs";
    v9 = 310;
    goto LABEL_48;
  }
  v49 = 0;
  v50 = a4 + 68;
  while (1)
  {
    v51 = *(_QWORD *)md == *(_QWORD *)v50 && v155 == *(_QWORD *)(v50 + 8);
    if (v51 && v156 == (unint64_t)*(unsigned int *)(v50 + 16))
      break;
    ++v49;
    v50 += 28;
    if (v48 == v49)
      goto LABEL_66;
  }
  v146 = v49;
  if (v149)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Patch matching entry %u\n", v49);
    v49 = v146;
    v48 = *(unsigned int *)(a4 + 8);
  }
  v135 = v36;
  v53 = v151;
  v142 = (uint64_t)v151 + 28 * v48;
  v144 = *(_QWORD *)(a4 + 24);
  v54 = v142 + v144;
  if ((_DWORD)v48)
  {
    v55 = 0;
    v56 = 0;
    do
    {
      if (v49 == v55)
        v56 = v54;
      v57 = *v53;
      v53 = (uint64_t *)((char *)v53 + 28);
      v54 += v57;
      ++v55;
    }
    while (v48 != v55);
  }
  else
  {
    v56 = 0;
  }
  v138 = *(_QWORD *)(a4 + 32);
  v140 = *(_QWORD *)(v50 - 8);
  if (v54 + v138 - a4 != a5)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 331, 42, "Warning: extra bytes in patch (ignored)\n", v35, a7, a8, v130);
    LODWORD(v48) = *(_DWORD *)(a4 + 8);
  }
  v137 = *(_QWORD *)(a4 + 16);
  v58 = 8 * (v48 + 2);
  v152 = (char *)malloc(0x20000uLL);
  v59 = malloc(0x20000uLL);
  v136 = v58;
  v60 = v58;
  v61 = v152;
  v150 = malloc(v60);
  enterThreadErrorContext((uint64_t)v150, v62, v63, v64, v65, v66, v67, v68, v130);
  v148 = v59;
  if (!v59 || !v152 || !v150)
  {
    v112 = *__error();
    v113 = "malloc";
    v114 = 351;
LABEL_133:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v114, 42, v112, v113, v69, v70, v131);
    v115 = 0;
    v73 = 0;
    v116 = 0;
    v109 = 0;
    v110 = 0;
    v111 = -1;
    v91 = v148;
    goto LABEL_155;
  }
  v145 = ILowMemoryDecoderStreamCreateWithBuffer(v142, v144, 0x20000uLL);
  if (!v145)
  {
    v113 = "Control stream init";
    v114 = 352;
    v112 = 0;
    goto LABEL_133;
  }
  v73 = ILowMemoryDecoderStreamCreateWithBuffer(v56, v140, 0x20000uLL);
  if (!v73)
  {
    v117 = "Diff stream init";
    v118 = 353;
LABEL_136:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v118, 42, 0, v117, v71, v72, v131);
    v116 = 0;
    v109 = 0;
    v110 = 0;
    v111 = -1;
    v91 = v148;
    v115 = v145;
    goto LABEL_155;
  }
  v143 = ILowMemoryDecoderStreamCreateWithBuffer(v54, v138, 0x20000uLL);
  if (!v143)
  {
    v117 = "Archive stream init";
    v118 = 354;
    goto LABEL_136;
  }
  v74 = (CC_SHA1_CTX *)OSHA1StreamCreate((uint64_t)a6, 0, a7);
  if (!v74)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 355, 42, 0, "Digest stream init", v75, v76, v131);
    v109 = 0;
    v110 = 0;
    v111 = -1;
    v91 = v148;
    v115 = v145;
LABEL_141:
    v116 = v143;
    goto LABEL_155;
  }
  v139 = v73;
  v134 = v74;
  v141 = OBufferedStreamCreate((uint64_t)OSHA1StreamWrite, (uint64_t)OSHA1StreamAbort, (uint64_t)v74, 0x20000uLL);
  if (!v141)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 356, 42, 0, "OBufferedStreamCreate", v82, v83, v131);
    v109 = 0;
    v111 = -1;
    v61 = v152;
    v91 = v148;
    v116 = v143;
    v115 = v145;
    goto LABEL_154;
  }
  if (!v137)
  {
LABEL_123:
    OBufferedStreamDestroy((void ***)v141, v77, v78, v79, v80, v81, v82, v83);
    OSHA1StreamDestroy(v134, md);
    if (*(_QWORD *)md == *(_QWORD *)v135
      && v155 == *(_QWORD *)(v135 + 8)
      && v156 == (unint64_t)*(unsigned int *)(v135 + 16))
    {
      v109 = 0;
      v110 = 0;
      v111 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 421, 42, 0, "Invalid output digest after patch application", v105, v106, v131);
      v109 = 0;
      v110 = 0;
      v111 = -1;
    }
    v61 = v152;
    v91 = v148;
    v115 = v145;
    v73 = v139;
    goto LABEL_141;
  }
  v84 = 0;
  v85 = 0;
  v133 = (v146 + 2);
  while (1)
  {
    if (ILowMemoryDecoderStreamRead(v145, (char *)v150, v136) != v136)
    {
      v121 = "reading from control stream";
      v122 = 362;
      goto LABEL_151;
    }
    v86 = *((_QWORD *)v150 + 1);
    if (*(uint64_t *)v150 >= 0)
      v87 = *(_QWORD *)v150;
    else
      v87 = 0x8000000000000000 - *(_QWORD *)v150;
    v88 = 0x8000000000000000 - v86;
    if (v86 >= 0)
      v88 = *((_QWORD *)v150 + 1);
    v147 = v88;
    v89 = *((_QWORD *)v150 + v133);
    if (v89 < 0)
      v89 = 0x8000000000000000 - v89;
    v132 = v89;
    if (v85 < 0 || v87 + v85 > a3)
    {
      v121 = "Invalid in segment in patch";
      v122 = 369;
      goto LABEL_151;
    }
    if (v87 + v84 + v147 > *(_QWORD *)(a4 + 16))
    {
      v121 = "Invalid out segment in patch";
      v122 = 370;
LABEL_151:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v122, 42, 0, v121, v82, v83, v131);
      v111 = -1;
      v61 = v152;
LABEL_152:
      v91 = v148;
      goto LABEL_153;
    }
    if (v87)
      break;
LABEL_114:
    if (v147)
    {
      v99 = 0;
      v100 = v147;
      while (1)
      {
        v101 = v100 - v99;
        if (v101 >= 0x20000)
          v102 = 0x20000;
        else
          v102 = v101;
        if (ILowMemoryDecoderStreamRead(v143, v152, v102) != v102)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", 405, 42, 0, "reading from archive stream", v103, v104, v131);
          v111 = -1;
          v61 = v152;
          goto LABEL_152;
        }
        if (OBufferedStreamWrite((unint64_t **)v141, v152, v102) != v102)
          break;
        v99 += v102;
        v84 += v102;
        v100 = v147;
        if (v99 >= v147)
          goto LABEL_122;
      }
      v121 = "writing to digest stream";
      v122 = 407;
      goto LABEL_151;
    }
LABEL_122:
    v85 += v132;
    if (v84 >= v137)
      goto LABEL_123;
  }
  v90 = 0;
  v91 = v148;
  v92 = v87;
  while (1)
  {
    v93 = v92 - v90;
    if (v93 >= 0x20000)
      v94 = 0x20000;
    else
      v94 = v93;
    if (ILowMemoryDecoderStreamRead(v139, v152, v94) != v94)
    {
      v119 = "reading from diff stream";
      v120 = 379;
      goto LABEL_145;
    }
    if (a1(a2, v148, v94, v85) != v94)
    {
      v119 = "reading from input stream";
      v120 = 381;
      goto LABEL_145;
    }
    v95 = (char *)v148;
    v96 = v152;
    for (i = v94; i; --i)
    {
      v98 = *v95++;
      *v96++ += v98;
    }
    if (OBufferedStreamWrite((unint64_t **)v141, v152, v94) != v94)
      break;
    v90 += v94;
    v85 += v94;
    v84 += v94;
    v92 = v87;
    if (v90 >= v87)
      goto LABEL_114;
  }
  v119 = "writing to digest stream";
  v120 = 390;
LABEL_145:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5StreamWithFlags", v120, 42, 0, v119, v82, v83, v131);
  v111 = -1;
  v61 = v152;
LABEL_153:
  v116 = v143;
  v115 = v145;
  v73 = v139;
  v109 = (void ***)v141;
LABEL_154:
  v110 = v134;
LABEL_155:
  free(v150);
  free(v61);
  free(v91);
  OBufferedStreamDestroy(v109, v123, v124, v125, v126, v127, v128, v129);
  OSHA1StreamDestroy(v110, md);
  ILowMemoryDecoderStreamDestroy(v115);
  ILowMemoryDecoderStreamDestroy(v73);
  ILowMemoryDecoderStreamDestroy(v116);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v111;
  else
    return result;
}

uint64_t BXPatch5WithFlagsBufferStreamPRead(_QWORD *a1, void *__dst, size_t __n, uint64_t a4)
{
  uint64_t result;

  if (!__n)
    return 0;
  result = -1;
  if (!__CFADD__(a4, __n) && a4 + __n <= a1[1])
  {
    memcpy(__dst, (const void *)(*a1 + a4), __n);
    return __n;
  }
  return result;
}

uint64_t BXPatch5FileWithFlags(const char *a1, uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5, uint64_t a6)
{
  char v11;
  unsigned int v12;
  int v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  stat v22;
  uint64_t v23;
  off_t st_size;

  v11 = (char)a1;
  st_size = 0;
  memset(&v22, 0, sizeof(v22));
  v12 = open(a1, 0);
  v23 = v12;
  if ((v12 & 0x80000000) != 0)
  {
    v18 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 235, 42, *v18, "open: %s", v19, v20, v11);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v13 = v12;
    if (fstat(v12, &v22))
    {
      v14 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5FileWithFlags", 236, 42, *v14, "fstat: %s", v15, v16, v11);
      v17 = 0xFFFFFFFFLL;
LABEL_6:
      close(v13);
      return v17;
    }
    st_size = v22.st_size;
    v17 = BXPatch5StreamWithFlags((uint64_t (*)(uint64_t, void *, uint64_t, unint64_t))BXPatch5WithFlagsFileStreamPRead, (uint64_t)&v23, v22.st_size, a2, a3, a4, a5, a6);
    v13 = v23;
    if ((v23 & 0x80000000) == 0)
      goto LABEL_6;
  }
  return v17;
}

ssize_t BXPatch5WithFlagsFileStreamPRead(uint64_t a1, void *a2, size_t a3, off_t a4)
{
  ssize_t result;

  if (!a3)
    return 0;
  result = -1;
  if (!__CFADD__(a4, a3) && a4 + a3 <= *(_QWORD *)(a1 + 8))
    return pread(*(_DWORD *)a1, a2, a3, a4);
  return result;
}

uint64_t copyStream(uint64_t (*a1)(uint64_t, void *, uint64_t, unint64_t), uint64_t a2, unint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t), uint64_t a5)
{
  void *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  char v22;

  v10 = malloc(0x40000uLL);
  if (!v10)
  {
    v18 = *__error();
    v19 = "malloc";
    v20 = 188;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"copyStream", v20, 42, v18, v19, v14, v15, v22);
    v17 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  v11 = 0;
  if (a3)
  {
    while (1)
    {
      if (v11 + 0x40000 <= a3)
        v12 = 0x40000;
      else
        v12 = a3 - v11;
      v13 = a1(a2, v10, v12, v11);
      if (v13 <= 0)
      {
        v19 = "inProc read";
        v20 = 196;
        goto LABEL_15;
      }
      v16 = a4(a5, v10, v13);
      if (v16 <= 0)
        break;
      v11 += v16;
      if (v11 >= a3)
        goto LABEL_9;
    }
    v19 = "outProc write";
    v20 = 198;
LABEL_15:
    v18 = 0;
    goto LABEL_16;
  }
LABEL_9:
  if (v11 == a3)
    v17 = 0;
  else
    v17 = 0xFFFFFFFFLL;
LABEL_17:
  free(v10);
  return v17;
}

uint64_t BXPatch5InPlace(const char *a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  uint64_t FileSHA1Digest;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  BOOL v26;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  void *v40;
  char *v41;
  size_t i;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  void *v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  unint64_t v72;
  unint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  char *v82;
  unint64_t *v83;
  unint64_t v84;
  unint64_t v85;
  size_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t j;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  char *v104;
  unint64_t v105;
  uint64_t v106;
  size_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  char v125;
  char v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  void *v130;
  unint64_t v131;
  unint64_t v132;
  char *v133;
  _BYTE *v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  char *v143;
  char *v144;
  void *v145;
  _QWORD *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int v151;
  uint64_t v152;

  v152 = *MEMORY[0x24BDAC8D0];
  if (a3 <= 0x3B)
  {
    v8 = "Invalid patch size";
    v9 = 441;
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v9, 42, 0, v8, a7, a8, v125);
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)a2 != 0x3035464649445842)
  {
    v8 = "Invalid patch header";
    v9 = 442;
    goto LABEL_29;
  }
  if ((*(_BYTE *)(a2 + 12) & 1) == 0)
  {
    v8 = "Patch can't be applied in-place";
    v9 = 445;
    goto LABEL_29;
  }
  if (a4 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Input variants in patch: %u\n", *(_DWORD *)(a2 + 8));
  v149 = 0;
  v150 = 0;
  v151 = 0;
  FileSHA1Digest = getFileSHA1Digest(a1, (uint64_t)&v149);
  if ((_DWORD)FileSHA1Digest)
  {
    v8 = "computing file digest";
    v9 = 450;
    goto LABEL_29;
  }
  if (v149 == *(_QWORD *)(a2 + 40)
    && v150 == *(_QWORD *)(a2 + 48)
    && v151 == (unint64_t)*(unsigned int *)(a2 + 56))
  {
    if (a4 >= 1)
      fwrite("No-op patch matching, do nothing\n", 0x21uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return 0;
  }
  v22 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v22)
  {
LABEL_28:
    v8 = "Input doesn't match any of the expected patch inputs (in-place)";
    v9 = 467;
    goto LABEL_29;
  }
  v23 = 0;
  v24 = (uint64_t *)(a2 + 60);
  v25 = a2 + 68;
  while (1)
  {
    v26 = v149 == *(_QWORD *)v25 && v150 == *(_QWORD *)(v25 + 8);
    if (v26 && v151 == (unint64_t)*(unsigned int *)(v25 + 16))
      break;
    ++v23;
    v25 += 28;
    if (v22 == v23)
      goto LABEL_28;
  }
  if (a4 >= 1)
  {
    FileSHA1Digest = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "In-place patch matching entry %u\n", v23);
    v22 = *(unsigned int *)(a2 + 8);
  }
  v29 = (uint64_t)v24 + 28 * v22 + *(_QWORD *)(a2 + 24);
  v147 = *(_QWORD *)(a2 + 24);
  v143 = (char *)v24 + 28 * v22;
  if ((_DWORD)v22)
  {
    v30 = 0;
    v31 = 0;
    do
    {
      if (v23 == v30)
        v31 = v29;
      v32 = *v24;
      v24 = (uint64_t *)((char *)v24 + 28);
      v29 += v32;
      ++v30;
    }
    while (v22 != v30);
  }
  else
  {
    v31 = 0;
  }
  v33 = *(_QWORD *)(v25 - 8);
  v128 = *(_QWORD *)(a2 + 32);
  if (v29 + v128 - a2 != a3)
  {
    FileSHA1Digest = pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 489, 42, "Warning: extra bytes in patch (ignored)\n", v19, a7, a8, v125);
    LODWORD(v22) = *(_DWORD *)(a2 + 8);
  }
  enterThreadErrorContext(FileSHA1Digest, v15, v16, v17, v18, v19, a7, a8, v125);
  v134 = malloc(0x1000uLL);
  if (!v134)
  {
    v54 = *__error();
    v57 = 511;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v57, 42, v54, "malloc", v55, v56, v126);
    v40 = 0;
    v65 = 0;
    v66 = 0;
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v70 = 0;
    goto LABEL_95;
  }
  v34 = malloc(0x1000uLL);
  if (!v34)
  {
    v54 = *__error();
    v57 = 513;
    goto LABEL_62;
  }
  v130 = v34;
  v135 = (v22 + 2);
  v136 = 8 * v135;
  v133 = (char *)malloc(8 * v135);
  v35 = ILowMemoryDecoderStreamCreateWithBuffer((uint64_t)v143, v147, 0x1000uLL);
  if (!v35)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 517, 42, 0, "Control stream init", v36, v37, v126);
    v40 = 0;
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v70 = 0;
LABEL_64:
    v66 = v130;
    v65 = v133;
    goto LABEL_95;
  }
  v127 = v33;
  v139 = v35;
  v140 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = v133;
  for (i = 8 * (v22 + 2); ; v38 = &v144[i])
  {
    v144 = v38;
    v148 = v39;
    if (v39 == v140)
    {
      v43 = v39 + (v39 >> 1);
      if (v39 >> 5 <= 0xC34)
        v43 = 2 * v39;
      if (!v39)
        v43 = 2000;
      v140 = v43;
      v44 = (char *)reallocf(v40, i * v43);
      i = 8 * (v22 + 2);
      v41 = v133;
      v40 = v44;
      if (!v44)
      {
        v65 = v133;
        v94 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 527, 42, v94, "malloc", v95, v96, v126);
LABEL_92:
        v67 = 0;
        v68 = 0;
        v69 = 0;
        v66 = v130;
LABEL_94:
        v70 = v139;
        goto LABEL_95;
      }
    }
    v45 = ILowMemoryDecoderStreamRead(v139, v41, i);
    if (!v45)
      break;
    v48 = (uint64_t *)v41;
    v49 = v144;
    v50 = (v22 + 2);
    if (v45 != i)
    {
      v65 = v41;
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 533, 42, 0, "reading from control stream S=%lld", v46, v47, v45);
      goto LABEL_92;
    }
    do
    {
      v52 = *v48++;
      v51 = v52;
      v53 = 0x8000000000000000 - v52;
      if (v52 < 0)
        v51 = v53;
      *(_QWORD *)&v49[(_QWORD)v40] = v51;
      v49 += 8;
      --v50;
    }
    while (v50);
    v39 = v148 + 1;
  }
  if (a4 >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%zu controls in patch (%zu B allocated)\n", v148, v136 * v140);
  v71 = PagedFileCreate(a1, *(_QWORD *)(a2 + 16), 0x2800000uLL, a4);
  if (!v71)
  {
    v67 = 0;
    v68 = 0;
    v69 = 0;
    v66 = v130;
    v65 = v133;
    goto LABEL_94;
  }
  v67 = v71;
  if (v148)
  {
    v72 = 0;
    v73 = (unint64_t *)v40;
    v74 = v148;
    do
    {
      v131 = *v73;
      v141 = v72;
      v145 = (void *)v73[(v23 + 2)];
      PagedFileRetainIn(v67, v72, *v73, v60, v61, v62, v63, v64);
      v72 = (unint64_t)v145 + v131 + v141;
      v73 = (unint64_t *)((char *)v73 + v136);
      --v74;
    }
    while (v74);
  }
  PagedFileReleaseAllIn((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
  if (a4 > 1)
    PagedFileDump((uint64_t)v67, "Input retained");
  v75 = ILowMemoryDecoderStreamCreateWithBuffer(v31, v127, 0x1000uLL);
  v70 = v139;
  if (!v75)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 563, 42, 0, "Diff stream init", v76, v77, v126);
    v68 = 0;
    v69 = 0;
    goto LABEL_64;
  }
  v142 = v75;
  v146 = v67;
  if (v148)
  {
    v78 = 0;
    v79 = 0;
    v80 = 0;
    v81 = (v23 + 2);
    v82 = (char *)v130;
    v129 = v81;
    while (1)
    {
      v83 = (unint64_t *)((char *)v40 + 8 * v78 * v135);
      v84 = *v83;
      v85 = v83[1];
      v137 = v83[v81];
      if (a4 >= 3)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "DIFF STREAM: I=%zu OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu IDELTA=%lld\n", v78, v79, v80, v84, v85, v137);
        PagedFileDump((uint64_t)v146, "Before applying control");
        v82 = (char *)v130;
      }
      v132 = v85;
      if (v84)
        break;
LABEL_88:
      v80 += v137;
      v79 += v132;
      ++v78;
      v81 = v129;
      if (v78 == v148)
        goto LABEL_105;
    }
    while (1)
    {
      if (v84 >= 0x1000)
        v86 = 4096;
      else
        v86 = v84;
      if (ILowMemoryDecoderStreamRead(v142, v82, v86) != v86)
      {
        v119 = "reading from diff stream";
        v120 = 584;
        goto LABEL_130;
      }
      if (PagedFileReadAndReleaseIn((uint64_t)v146, v80, v86, (uint64_t)v134, v87, v88, v89, v90))
      {
        v119 = "reading from input stream";
        v120 = 587;
        goto LABEL_130;
      }
      for (j = 0; j != v86; ++j)
        *((_BYTE *)v130 + j) += v134[j];
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v79, v86, (uint64_t)v130, v91, v92, v89, v90))
        break;
      v80 += v86;
      v79 += v86;
      v84 -= v86;
      v82 = (char *)v130;
      if (!v84)
        goto LABEL_88;
    }
    v119 = "writing output";
    v120 = 593;
LABEL_130:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v120, 42, 0, v119, v89, v90, v126);
    v68 = 0;
LABEL_137:
    v66 = v130;
LABEL_138:
    v65 = v133;
    v70 = v139;
    v67 = v146;
LABEL_139:
    v69 = v142;
LABEL_95:
    PagedFileDestroy((uint64_t)v67, v58, v59, v60, v61, v62, v63, v64);
    free(v40);
    free(v65);
    free(v134);
    free(v66);
    ILowMemoryDecoderStreamDestroy(v70);
    ILowMemoryDecoderStreamDestroy(v69);
    ILowMemoryDecoderStreamDestroy(v68);
LABEL_96:
    v97 = 0;
    goto LABEL_97;
  }
  v80 = 0;
LABEL_105:
  v67 = v146;
  if (a4 >= 2)
    PagedFileDump((uint64_t)v146, "Diff stream applied");
  if (!PagedFileHasNoIn((uint64_t)v146))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 608, 42, 0, "some input bytes are still mapped after diff expansion", v99, v100, v126);
    v68 = 0;
    v66 = v130;
    v65 = v133;
    v70 = v139;
    goto LABEL_139;
  }
  v68 = ILowMemoryDecoderStreamCreateWithBuffer(v29, v128, 0x1000uLL);
  if (!v68)
  {
    v121 = "Archive stream init";
    v122 = 611;
LABEL_136:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", v122, 42, 0, v121, v101, v102, v126);
    goto LABEL_137;
  }
  if (v148)
  {
    v138 = 0;
    v103 = 0;
    while (1)
    {
      v104 = (char *)v40 + 8 * v138 * v135;
      v106 = *(_QWORD *)v104;
      v105 = *((_QWORD *)v104 + 1);
      if (a4 >= 3)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE STREAM: OPOS=%llu IPOS=%llu NDIFF=%llu NARCHIVE=%llu\n", v103, v80, v106, v105);
      v103 += v106;
      if (v105)
        break;
LABEL_121:
      if (++v138 == v148)
        goto LABEL_122;
    }
    v66 = v130;
    while (1)
    {
      if (v105 >= 0x1000)
        v107 = 4096;
      else
        v107 = v105;
      if (ILowMemoryDecoderStreamRead(v68, (char *)v66, v107) != v107)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 630, 42, 0, "reading from archive stream", v110, v111, v126);
        goto LABEL_138;
      }
      if (PagedFileRetainAndWriteOut((uint64_t)v146, v103, v107, (uint64_t)v66, v108, v109, v110, v111))
        break;
      v103 += v107;
      v105 -= v107;
      v66 = v130;
      if (!v105)
        goto LABEL_121;
    }
    v121 = "writing output";
    v122 = 633;
    goto LABEL_136;
  }
LABEL_122:
  if (a4 >= 2)
    PagedFileDump((uint64_t)v146, "Archive stream applied");
  if (!PagedFileHasAllOut((uint64_t)v146))
  {
    v121 = "some output bytes are missing or referenced more than once after archive expansion";
    v122 = 643;
    goto LABEL_136;
  }
  PagedFileDestroy((uint64_t)v146, v112, v113, v114, v115, v116, v101, v102);
  free(v40);
  free(v133);
  free(v134);
  free(v130);
  ILowMemoryDecoderStreamDestroy(v139);
  ILowMemoryDecoderStreamDestroy(v142);
  ILowMemoryDecoderStreamDestroy(v68);
  if (getFileSHA1Digest(a1, (uint64_t)&v149))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 658, 42, 0, "computing file digest", v117, v118, v126);
    v97 = 0;
  }
  else
  {
    v97 = 1;
  }
  if (v149 != *(_QWORD *)(a2 + 40)
    || v150 != *(_QWORD *)(a2 + 48)
    || v151 != (unint64_t)*(unsigned int *)(a2 + 56))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch5.c", (uint64_t)"BXPatch5InPlace", 659, 42, 0, "Invalid output digest", v117, v118, v126);
    goto LABEL_96;
  }
LABEL_97:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v97)
    v98 = 0;
  else
    v98 = -1;
  if ((int)result >= 0)
    return v98;
  else
    return result;
}

uint64_t CC_CKSUM_Init(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return 1;
}

uint64_t CC_CKSUM_Update(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v3 = *(_DWORD *)a1;
  if (a3)
  {
    v4 = a3;
    v5 = a3;
    do
    {
      v6 = *a2++;
      v3 = CKSUMTable[v6 ^ HIBYTE(v3)] ^ (v3 << 8);
      --v5;
    }
    while (v5);
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)a1 = v3;
  *(_QWORD *)(a1 + 8) += v4;
  return 1;
}

uint64_t CC_CKSUM_Final(unsigned int *a1, uint64_t a2)
{
  unsigned int v2;
  unint64_t v3;
  BOOL v4;

  v2 = *(_DWORD *)a2;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    do
    {
      v2 = CKSUMTable[v3 ^ HIBYTE(v2)] ^ (v2 << 8);
      v4 = v3 > 0xFF;
      v3 >>= 8;
    }
    while (v4);
  }
  *a1 = ~v2;
  return 1;
}

unsigned int *ThreadPipelineCreate(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6)
{
  unsigned int *v12;
  unsigned int *v13;
  void *v14;
  void *v15;
  size_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  size_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;

  v12 = (unsigned int *)calloc(1uLL, 0x1A8uLL);
  v13 = v12;
  if (v12)
  {
    *v12 = a1;
    v14 = calloc(a1, 0x198uLL);
    *((_QWORD *)v13 + 1) = v14;
    if (v14)
    {
      v15 = calloc(1uLL, 0x20uLL);
      *((_QWORD *)v13 + 2) = v15;
      if (v15)
      {
        v16 = *v13;
        v13[10] = 0;
        v13[11] = v16;
        v17 = calloc(v16, 4uLL);
        *((_QWORD *)v13 + 6) = v17;
        if (v17)
        {
          if (pthread_mutex_init((pthread_mutex_t *)(v13 + 14), 0))
          {
            v21 = "SharedArrayInit: pthread_mutex_init failed\n";
            v22 = 56;
          }
          else
          {
            if (!pthread_cond_init((pthread_cond_t *)(v13 + 30), 0))
            {
              v29 = *v13 + 1;
              v13[42] = 0;
              v13[43] = v29;
              v30 = calloc(v29, 4uLL);
              *((_QWORD *)v13 + 22) = v30;
              if (v30)
              {
                if (pthread_mutex_init((pthread_mutex_t *)(v13 + 46), 0))
                {
                  v34 = "SharedArrayInit: pthread_mutex_init failed\n";
                  v35 = 56;
                }
                else
                {
                  if (!pthread_cond_init((pthread_cond_t *)(v13 + 62), 0))
                  {
                    v13[6] = -1;
                    v13[74] = 0;
                    if (pthread_mutex_init((pthread_mutex_t *)(v13 + 76), 0)
                      || pthread_cond_init((pthread_cond_t *)(v13 + 92), 0))
                    {
                      v26 = "SemInit";
                      v27 = 184;
                    }
                    else if (*v13)
                    {
                      v36 = 0;
                      v37 = 0;
                      while (1)
                      {
                        v38 = *((_QWORD *)v13 + 1);
                        v39 = v38 + v36;
                        *(_QWORD *)(v39 + 16) = v13;
                        *(_DWORD *)(v39 + 8) = v37;
                        v43 = v37;
                        *(_QWORD *)(v39 + 24) = *(_QWORD *)(a2 + 8 * v37);
                        *(_QWORD *)(v39 + 32) = a3;
                        *(_DWORD *)(v39 + 40) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 48), 0)
                          || pthread_cond_init((pthread_cond_t *)(v39 + 112), 0))
                        {
                          v26 = "SemInit";
                          v27 = 194;
                          goto LABEL_14;
                        }
                        *(_DWORD *)(v38 + v36 + 160) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v38 + v36 + 168), 0)
                          || pthread_cond_init((pthread_cond_t *)(v38 + v36 + 232), 0))
                        {
                          v26 = "SemInit";
                          v27 = 195;
                          goto LABEL_14;
                        }
                        v40 = v38 + v36;
                        *(_DWORD *)(v40 + 280) = 0;
                        if (pthread_mutex_init((pthread_mutex_t *)(v40 + 288), 0)
                          || pthread_cond_init((pthread_cond_t *)(v40 + 352), 0))
                        {
                          v26 = "SemInit";
                          v27 = 196;
                          goto LABEL_14;
                        }
                        if ((createThread((pthread_t *)v39, (uint64_t)threadPipelineWorkerThreadProc, v39, a6) & 0x80000000) != 0)
                          break;
                        v37 = v43 + 1;
                        v36 += 408;
                        if (v43 + 1 >= (unint64_t)*v13)
                          goto LABEL_37;
                      }
                      v26 = "Thread creation";
                      v27 = 197;
                    }
                    else
                    {
LABEL_37:
                      v41 = *((_QWORD *)v13 + 2);
                      *(_QWORD *)(v41 + 8) = v13;
                      *(_QWORD *)(v41 + 16) = a4;
                      *(_QWORD *)(v41 + 24) = a5;
                      if ((createThread((pthread_t *)v41, (uint64_t)threadPipelineConsumerThreadProc, v41, 0) & 0x80000000) == 0)
                        return v13;
                      v26 = "Thread creation";
                      v27 = 206;
                    }
                    goto LABEL_14;
                  }
                  v34 = "SharedArrayInit: pthread_cond_init failed\n";
                  v35 = 57;
                }
              }
              else
              {
                v34 = "SharedArrayInit: malloc failed\n";
                v35 = 55;
              }
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v35, 0, v34, v31, v32, v33, v42);
              v26 = "SharedArrayInit";
              v27 = 182;
LABEL_14:
              v23 = 0;
              goto LABEL_15;
            }
            v21 = "SharedArrayInit: pthread_cond_init failed\n";
            v22 = 57;
          }
        }
        else
        {
          v21 = "SharedArrayInit: malloc failed\n";
          v22 = 55;
        }
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v22, 0, v21, v18, v19, v20, v42);
        v26 = "SharedArrayInit";
        v27 = 180;
        goto LABEL_14;
      }
      v23 = *__error();
      v26 = "malloc";
      v27 = 179;
    }
    else
    {
      v23 = *__error();
      v26 = "malloc";
      v27 = 177;
    }
  }
  else
  {
    v23 = *__error();
    v26 = "malloc";
    v27 = 172;
  }
LABEL_15:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineCreate", v27, 87, v23, v26, v24, v25, v42);
  ThreadPipelineDestroy((uint64_t)v13);
  return 0;
}

uint64_t threadPipelineWorkerThreadProc(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v3;
  pthread_cond_t *v4;
  unsigned int *v5;
  pthread_mutex_t *v6;
  pthread_cond_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  const char *v23;
  __int16 v24;
  unsigned int v25;
  const char *v27;
  __int16 v28;
  pthread_cond_t *v29;
  pthread_mutex_t *v30;
  pthread_mutex_t *v31;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = (pthread_mutex_t *)(a1 + 48);
  v4 = (pthread_cond_t *)(a1 + 112);
  v5 = (unsigned int *)(v2 + 416);
  v30 = (pthread_mutex_t *)(a1 + 168);
  v31 = (pthread_mutex_t *)(v2 + 56);
  v29 = (pthread_cond_t *)(a1 + 232);
  v6 = (pthread_mutex_t *)(a1 + 288);
  v7 = (pthread_cond_t *)(a1 + 352);
  while (1)
  {
    v8 = *(_DWORD *)(a1 + 8);
    if (pthread_mutex_lock(v31))
    {
      v27 = "SharedArrayPush: pthread_mutex_lock failed\n";
      v28 = 117;
      goto LABEL_37;
    }
    v12 = *(unsigned int *)(v2 + 40);
    v13 = *(_DWORD *)(v2 + 44);
    v14 = v12;
    if (v12 < v13)
    {
      *(_DWORD *)(*(_QWORD *)(v2 + 48) + 4 * v12) = v8;
      v14 = *(_DWORD *)(v2 + 40);
    }
    *(_DWORD *)(v2 + 40) = v14 + 1;
    if (!v14)
    {
      if (pthread_cond_broadcast((pthread_cond_t *)(v2 + 120)))
        break;
    }
    if (pthread_mutex_unlock(v31))
    {
      v27 = "SharedArrayPush: pthread_mutex_unlock failed\n";
      v28 = 124;
      goto LABEL_37;
    }
    if (v12 >= v13)
    {
      v27 = "SharedArrayPush: stack is full\n";
      v28 = 125;
      goto LABEL_37;
    }
    if (pthread_mutex_lock(v3))
      goto LABEL_28;
    while (1)
    {
      v17 = *(_DWORD *)(a1 + 40);
      if (v17 > 0)
        break;
      if (pthread_cond_wait(v4, v3))
        goto LABEL_28;
    }
    *(_DWORD *)(a1 + 40) = v17 - 1;
    if (pthread_mutex_unlock(v3))
    {
LABEL_28:
      v23 = "SemAcquire";
      v24 = 72;
      goto LABEL_29;
    }
    if ((*(_QWORD *)(a1 + 400) & 0x8000000000000000) != 0)
      return a1;
    if (((*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 24)) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", 82, 87, 0, "worker proc reported an error", v18, v19, (char)v29);
      do
        v20 = __ldxr(v5);
      while (__stxr(v20 + 1, v5));
    }
    if (pthread_mutex_lock(v30)
      || (v21 = *(_DWORD *)(a1 + 160), *(_DWORD *)(a1 + 160) = v21 + 1, !v21) && pthread_cond_broadcast(v29)
      || pthread_mutex_unlock(v30))
    {
      v23 = "SemRelease";
      v24 = 85;
      goto LABEL_29;
    }
    if (!pthread_mutex_lock(v6))
    {
      while (1)
      {
        v22 = *(_DWORD *)(a1 + 280);
        if (v22 > 0)
          break;
        if (pthread_cond_wait(v7, v6))
          goto LABEL_27;
      }
      *(_DWORD *)(a1 + 280) = v22 - 1;
      if (!pthread_mutex_unlock(v6))
        continue;
    }
LABEL_27:
    v23 = "SemAcquire";
    v24 = 88;
    goto LABEL_29;
  }
  v27 = "SharedArrayPush: pthread_cond_broadcast failed\n";
  v28 = 122;
LABEL_37:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v28, 0, v27, v9, v10, v11, (char)v29);
  v23 = "SharedArrayPush";
  v24 = 69;
LABEL_29:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineWorkerThreadProc", v24, 87, 0, v23, v15, v16, (char)v29);
  do
    v25 = __ldxr(v5);
  while (__stxr(v25 + 1, v5));
  return a1;
}

uint64_t threadPipelineConsumerThreadProc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  __int16 v11;
  pthread_cond_t *v12;
  pthread_mutex_t *v13;
  unsigned int *v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  pthread_cond_t *v18;
  uint64_t v19;
  uint64_t v20;
  pthread_mutex_t *v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  unsigned int *v29;
  unsigned int v30;
  pthread_cond_t *v32;

  v2 = *(_QWORD *)(a1 + 8);
  if (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)))
  {
    v12 = (pthread_cond_t *)(v2 + 248);
    v13 = (pthread_mutex_t *)(v2 + 304);
    v32 = (pthread_cond_t *)(v2 + 368);
    v14 = (unsigned int *)(v2 + 416);
    do
    {
      while (1)
      {
        v15 = *(_DWORD *)(v2 + 168);
        if (v15)
          break;
        if (pthread_cond_wait(v12, (pthread_mutex_t *)(v2 + 184)))
        {
          v6 = "SharedArrayPop: pthread_cond_wait failed\n";
          v7 = 94;
          goto LABEL_3;
        }
      }
      v16 = v15 - 1;
      *(_DWORD *)(v2 + 168) = v16;
      v17 = *(_DWORD *)(*(_QWORD *)(v2 + 176) + 4 * v16);
      if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 184)))
      {
        v6 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        v7 = 98;
        goto LABEL_3;
      }
      if (v17 == -2)
      {
        if (!pthread_mutex_lock(v13))
        {
          v23 = *(_DWORD *)(v2 + 296);
          *(_DWORD *)(v2 + 296) = v23 + 1;
          if (v23 || !pthread_cond_broadcast(v32))
            pthread_mutex_unlock(v13);
        }
      }
      else
      {
        if (v17 == -1)
          return a1;
        v18 = v12;
        v19 = *(_QWORD *)(v2 + 8);
        v20 = v19 + 408 * v17;
        v21 = (pthread_mutex_t *)(v20 + 168);
        if (pthread_mutex_lock((pthread_mutex_t *)(v20 + 168)))
          goto LABEL_31;
        v22 = (int *)(v20 + 160);
        while (*v22 <= 0)
        {
          if (pthread_cond_wait((pthread_cond_t *)(v19 + 408 * v17 + 232), v21))
            goto LABEL_31;
        }
        --*v22;
        if (pthread_mutex_unlock(v21))
        {
LABEL_31:
          v10 = "SemAcquire";
          v11 = 134;
          goto LABEL_32;
        }
        if (((*(uint64_t (**)(_QWORD, _QWORD))(a1 + 24))(*(_QWORD *)(a1 + 16), *(_QWORD *)(v19 + 408 * v17 + 24)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", 141, 87, 0, "consumer proc reported an error", v24, v25, (char)v32);
          do
            v26 = __ldxr(v14);
          while (__stxr(v26 + 1, v14));
        }
        v12 = v18;
        v13 = (pthread_mutex_t *)(v2 + 304);
        if (pthread_mutex_lock((pthread_mutex_t *)(v19 + 408 * v17 + 288))
          || (v27 = v19 + 408 * v17, v28 = *(_DWORD *)(v27 + 280), *(_DWORD *)(v27 + 280) = v28 + 1, !v28)
          && pthread_cond_broadcast((pthread_cond_t *)(v19 + 408 * v17 + 352))
          || pthread_mutex_unlock((pthread_mutex_t *)(v19 + 408 * v17 + 288)))
        {
          v10 = "SemRelease";
          v11 = 144;
          goto LABEL_32;
        }
      }
    }
    while (!pthread_mutex_lock((pthread_mutex_t *)(v2 + 184)));
  }
  v6 = "SharedArrayPop: pthread_mutex_lock failed\n";
  v7 = 91;
LABEL_3:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v7, 0, v6, v3, v4, v5, (char)v32);
  v10 = "SharedArrayDequeue";
  v11 = 114;
LABEL_32:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"threadPipelineConsumerThreadProc", v11, 87, 0, v10, v8, v9, (char)v32);
  v29 = (unsigned int *)(v2 + 416);
  do
    v30 = __ldxr(v29);
  while (__stxr(v30 + 1, v29));
  return a1;
}

uint64_t ThreadPipelineDestroy(uint64_t result)
{
  unsigned int *v1;
  _QWORD *v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  pthread_cond_t *v32;
  _opaque_pthread_t **v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  char v41;
  char v42;

  if (result)
  {
    v1 = (unsigned int *)result;
    v2 = *(_QWORD **)(result + 8);
    if (v2)
    {
      v3 = *(unsigned int *)result;
      if (!(_DWORD)v3)
      {
        v6 = 1;
        goto LABEL_41;
      }
      v4 = 0;
      do
      {
        if (*v2)
          ++v4;
        v2 += 51;
        --v3;
      }
      while (v3);
      if (v4)
      {
        v5 = 0;
        v6 = 1;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 14)))
          {
            v10 = 91;
            v11 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_15:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v10, 0, v11, v7, v8, v9, v41);
            v15 = -1;
          }
          else
          {
            while (1)
            {
              v12 = v1[10];
              if (v12)
                break;
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 30), (pthread_mutex_t *)(v1 + 14)))
              {
                v10 = 94;
                v11 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_15;
              }
            }
            v22 = v12 - 1;
            v1[10] = v22;
            v15 = *(_DWORD *)(*((_QWORD *)v1 + 6) + 4 * v22);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 14)))
              goto LABEL_17;
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v23, v24, v25, v41);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 237, 87, 0, "SharedArrayPop", v13, v14, v42);
          v6 = 0;
LABEL_17:
          v16 = *((_QWORD *)v1 + 1);
          v17 = v16 + 408 * v15;
          *(_QWORD *)(v17 + 400) = -1;
          if (pthread_mutex_lock((pthread_mutex_t *)(v17 + 48))
            || (v20 = v16 + 408 * v15, v21 = *(_DWORD *)(v20 + 40), *(_DWORD *)(v20 + 40) = v21 + 1, !v21)
            && pthread_cond_broadcast((pthread_cond_t *)(v16 + 408 * v15 + 112))
            || pthread_mutex_unlock((pthread_mutex_t *)(v17 + 48)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 245, 87, 0, "SemRelease", v18, v19, v41);
            v6 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v17) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 246, 87, 0, "joinThread", v26, v27, v41);
            v6 = 0;
          }
          *(_QWORD *)v17 = 0;
          if (++v5 == v4)
          {
            if (!*v1)
              goto LABEL_41;
            goto LABEL_33;
          }
        }
      }
      v6 = 1;
LABEL_33:
      v28 = 0;
      v29 = 352;
      do
      {
        v30 = *((_QWORD *)v1 + 1);
        v31 = v30 + v29;
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v30 + v29 - 304)))
          pthread_cond_destroy((pthread_cond_t *)(v31 - 240));
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v31 - 184)))
          pthread_cond_destroy((pthread_cond_t *)(v30 + v29 - 120));
        v32 = (pthread_cond_t *)(v30 + v29);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v32[-2].__opaque[24]))
          pthread_cond_destroy(v32);
        ++v28;
        v29 += 408;
      }
      while (v28 < *v1);
LABEL_41:
      free(*((void **)v1 + 1));
      *((_QWORD *)v1 + 1) = 0;
    }
    else
    {
      v6 = 1;
    }
    v33 = (_opaque_pthread_t **)*((_QWORD *)v1 + 2);
    if (v33)
    {
      if (*v33)
      {
        if ((SharedArrayEnqueue(v1 + 42, -1) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 272, 87, 0, "SharedArrayEnqueue", v34, v35, v41);
          v6 = 0;
        }
        if ((joinThread(*v33) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 273, 87, 0, "joinThread", v36, v37, v41);
          v6 = 0;
        }
        *v33 = 0;
        v33 = (_opaque_pthread_t **)*((_QWORD *)v1 + 2);
      }
      free(v33);
      *((_QWORD *)v1 + 2) = 0;
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 14)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 30)))
      free(*((void **)v1 + 6));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 46)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 62)))
      free(*((void **)v1 + 22));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 76)))
      pthread_cond_destroy((pthread_cond_t *)(v1 + 92));
    v40 = atomic_load(v1 + 104);
    if (v40 >= 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineDestroy", 285, 87, 0, "Threads reported errors", v38, v39, v41);
      v6 = 0;
    }
    free(v1);
    if (v6)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t ThreadPipelineGetWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  pthread_mutex_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  char v21;

  if (*(_DWORD *)(a1 + 24) != -1)
  {
    v8 = "Missing call to RunWorker before GetWorker";
    v9 = 294;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineGetWorker", v9, 87, 0, v8, a7, a8, v21);
    return 0;
  }
  v11 = (pthread_mutex_t *)(a1 + 56);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 56)))
  {
    v15 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v16 = 91;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v16, 0, v15, v12, v13, v14, v21);
    v8 = "SharedArrayPop failed";
    v9 = 298;
    goto LABEL_11;
  }
  while (1)
  {
    v17 = *(_DWORD *)(a1 + 40);
    if (v17)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 120), v11))
    {
      v15 = "SharedArrayPop: pthread_cond_wait failed\n";
      v16 = 94;
      goto LABEL_10;
    }
  }
  v18 = v17 - 1;
  *(_DWORD *)(a1 + 40) = v18;
  v19 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4 * v18);
  if (pthread_mutex_unlock(v11))
  {
    v15 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    v16 = 98;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = v19;
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 408 * v19 + 24);
}

uint64_t ThreadPipelineRunWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  const char *v14;
  __int16 v15;
  char v16;

  v8 = *(_DWORD *)(a1 + 24);
  if (v8 == -1)
  {
    v14 = "Missing call to GetWorker before RunWorker";
    v15 = 311;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 24) = -1;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v10 + 1;
  *(_QWORD *)(v9 + 408 * v8 + 400) = v10;
  if ((SharedArrayEnqueue((unsigned int *)(a1 + 168), v8) & 0x80000000) != 0)
  {
    v14 = "SharedArrayEnqueue failed";
    v15 = 324;
    goto LABEL_10;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(v9 + 408 * v8 + 48))
    || (v11 = v9 + 408 * v8, v12 = *(_DWORD *)(v11 + 40), *(_DWORD *)(v11 + 40) = v12 + 1, !v12)
    && pthread_cond_broadcast((pthread_cond_t *)(v9 + 408 * v8 + 112))
    || (result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 408 * v8 + 48)), (_DWORD)result))
  {
    v14 = "SemRelease failed";
    v15 = 325;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineRunWorker", v15, 87, 0, v14, a7, a8, v16);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t ThreadPipelineFlush(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  const char *v5;
  __int16 v6;
  uint64_t result;
  char v8;

  if ((SharedArrayEnqueue((unsigned int *)(a1 + 168), -2) & 0x80000000) != 0)
  {
    v5 = "SharedArrayEnqueue failed";
    v6 = 333;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPipeline.c", (uint64_t)"ThreadPipelineFlush", v6, 87, 0, v5, v2, v3, v8);
    return 0xFFFFFFFFLL;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 304)))
    goto LABEL_8;
  while (1)
  {
    v4 = *(_DWORD *)(a1 + 296);
    if (v4 > 0)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 368), (pthread_mutex_t *)(a1 + 304)))
      goto LABEL_8;
  }
  *(_DWORD *)(a1 + 296) = v4 - 1;
  result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  if ((_DWORD)result)
  {
LABEL_8:
    v5 = "SemAquire failed";
    v6 = 336;
    goto LABEL_9;
  }
  return result;
}

_BYTE *pc_zero_coder_decode(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  unint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  unsigned __int8 *v23;
  int v24;
  unsigned int v25;
  unsigned __int8 v26;
  unsigned __int8 v27;
  BOOL v28;

  v4 = (unint64_t)&a3[a4];
  v5 = &a1[a2];
  if (a2 >= 8 && a4 >= 9)
  {
    v6 = a1;
    while (1)
    {
      v7 = *a3;
      if ((*a3 & 1) != 0)
      {
        v8 = a3[1];
        a3 += 2;
        if ((v7 & 2) != 0)
        {
LABEL_6:
          v10 = *a3++;
          v9 = v10;
          if ((v7 & 4) != 0)
            goto LABEL_7;
          goto LABEL_11;
        }
      }
      else
      {
        v8 = 0;
        ++a3;
        if ((v7 & 2) != 0)
          goto LABEL_6;
      }
      v9 = 0;
      if ((v7 & 4) != 0)
      {
LABEL_7:
        v12 = *a3++;
        v11 = v12;
        if ((v7 & 8) != 0)
          goto LABEL_8;
        goto LABEL_12;
      }
LABEL_11:
      v11 = 0;
      if ((v7 & 8) != 0)
      {
LABEL_8:
        v14 = *a3++;
        v13 = v14;
        goto LABEL_13;
      }
LABEL_12:
      v13 = 0;
LABEL_13:
      *v6 = v8;
      v6[1] = v9;
      v6[2] = v11;
      v6[3] = v13;
      if ((v7 & 0x10) != 0)
      {
        v22 = *a3++;
        v15 = v22;
        if ((v7 & 0x20) != 0)
        {
LABEL_15:
          v17 = *a3++;
          v16 = v17;
          if ((v7 & 0x40) != 0)
            goto LABEL_16;
          goto LABEL_20;
        }
      }
      else
      {
        v15 = 0;
        if ((v7 & 0x20) != 0)
          goto LABEL_15;
      }
      v16 = 0;
      if ((v7 & 0x40) != 0)
      {
LABEL_16:
        v19 = *a3++;
        v18 = v19;
        if ((v7 & 0x80) != 0)
          goto LABEL_17;
        goto LABEL_21;
      }
LABEL_20:
      v18 = 0;
      if ((v7 & 0x80) != 0)
      {
LABEL_17:
        v21 = *a3++;
        v20 = v21;
        goto LABEL_22;
      }
LABEL_21:
      v20 = 0;
LABEL_22:
      v6[4] = v15;
      v6[5] = v16;
      v6[6] = v18;
      v6[7] = v20;
      v23 = v6 + 16;
      v6 += 8;
      if (v23 > v5 || (unint64_t)(a3 + 9) > v4)
        goto LABEL_26;
    }
  }
  v6 = a1;
LABEL_26:
  if ((unint64_t)a3 < v4)
  {
    v24 = *a3++;
    v25 = v24 | 0x100;
    while (v6 != v5)
    {
      if ((v25 & 1) != 0)
      {
        if (a3 == (unsigned __int8 *)v4)
          return (_BYTE *)(v6 - a1);
        v27 = *a3++;
        v26 = v27;
      }
      else
      {
        v26 = 0;
      }
      *v6++ = v26;
      v28 = v25 > 3;
      v25 >>= 1;
      if (!v28)
        goto LABEL_26;
    }
    v6 = &a1[a2];
  }
  return (_BYTE *)(v6 - a1);
}

_BYTE *pc_zero_coder_encode(char *a1, uint64_t a2, char *a3, uint64_t a4)
{
  unint64_t v5;
  char *v6;
  char v7;
  int v8;
  int v9;
  int v10;
  char *v11;
  int v12;
  int v13;
  int v14;
  char v15;
  int v16;
  char *v17;
  int v18;
  unsigned __int8 v19;
  char *v20;
  int v21;

  if (a2 < 9)
    return 0;
  v5 = (unint64_t)&a3[a4];
  v6 = a1;
  while ((unint64_t)(a3 + 8) <= v5)
  {
    v7 = *a3;
    v8 = a3[1];
    v9 = a3[2];
    v10 = a3[3];
    if (!*a3)
    {
      v11 = v6 + 1;
      if (!a3[1])
        goto LABEL_8;
LABEL_7:
      *v11++ = v8;
      v7 |= 2u;
      goto LABEL_8;
    }
    v11 = v6 + 2;
    v6[1] = v7;
    v7 = 1;
    if (v8)
      goto LABEL_7;
LABEL_8:
    if (v9)
    {
      *v11++ = v9;
      v7 |= 4u;
    }
    if (v10)
    {
      *v11++ = v10;
      v7 |= 8u;
    }
    v12 = a3[5];
    v13 = a3[6];
    v14 = a3[7];
    if (a3[4])
    {
      *v11++ = a3[4];
      v7 |= 0x10u;
    }
    if (v12)
    {
      *v11++ = v12;
      v7 |= 0x20u;
    }
    if (v13)
    {
      *v11++ = v13;
      v7 |= 0x40u;
    }
    if (v14)
    {
      *v11++ = v14;
      v7 |= 0x80u;
    }
    *v6 = v7;
    v6 = v11;
    a3 += 8;
    if (v11 + 9 > &a1[a2])
      return 0;
  }
  if ((unint64_t)a3 >= v5)
  {
    v17 = v6;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    v17 = v6 + 1;
    v18 = -1 << (a4 & 7);
    v19 = 1;
    v20 = a3;
    do
    {
      v21 = *v20;
      if (v21)
      {
        *v17++ = v21;
        v18 |= 1 << v15;
      }
      v15 = ++v16;
      v20 = &a3[v19++];
    }
    while ((unint64_t)v20 < v5);
    *v6 = v18;
  }
  return (_BYTE *)(v17 - a1);
}

uint64_t compressionWorkerProc(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int *v10;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v21;

  v9 = *a1;
  v10 = (unsigned int *)(*a1 + 112);
  if (atomic_load(v10))
  {
    result = 0;
    a1[6] = -1;
    return result;
  }
  v13 = a1[2];
  a1[6] = v13;
  if (v13 == -2)
    return 0;
  if (v13 == -1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", 244, 37, 0, "NOP received", a7, a8, v21);
    return 0;
  }
  if (v13 < 0)
  {
    v15 = "Invalid iBlock received";
    v16 = 246;
  }
  else
  {
    if (!*(_DWORD *)(v9 + 4))
    {
      v17 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v9 + 96))(a1[5], *(_QWORD *)(v9 + 16), a1[1], a1[3]);
      v18 = a1[3];
      if ((v17 & 0x8000000000000000) != 0 || v17 >= v18)
      {
        memcpy((void *)a1[5], (const void *)a1[1], v18);
        v17 = a1[3];
        v18 = v17;
      }
      a1[7] = v17;
      a1[8] = v18;
      if (*(int *)(v9 + 24) >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Worker: encode block %5lld: %7llu => %7llu\n");
      return 0;
    }
    if (a1[3] == a1[4])
    {
      memcpy((void *)a1[5], (const void *)a1[1], a1[3]);
      v14 = a1[3];
      a1[7] = v14;
      goto LABEL_19;
    }
    v19 = (*(uint64_t (**)(uint64_t))(v9 + 96))(a1[5]);
    if ((v19 & 0x8000000000000000) == 0 && v19 == a1[4])
    {
      a1[7] = v19;
      v14 = a1[3];
LABEL_19:
      a1[8] = v14;
      if (*(int *)(v9 + 24) >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Worker: decode block %5lld: %7llu => %7llu\n");
      return 0;
    }
    v21 = a1[6];
    v15 = "invalid output size/decoder error: block=%lld, inSize=%lld, outSize=%lld, expectedOutSize=%lld";
    v16 = 292;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"compressionWorkerProc", v16, 37, 0, v15, a7, a8, v21);
  a1[6] = -1;
  result = 0xFFFFFFFFLL;
  while (!__ldaxr(v10))
  {
    if (!__stlxr(1u, v10))
      return result;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t outputStreamProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int8x16_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  char v26;
  int8x16_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v8 = (unsigned int *)(a1 + 112);
  if (atomic_load((unsigned int *)(a1 + 112)))
    return 0;
  v13 = *(_QWORD *)(a2 + 48);
  if (v13 > 0xFFFFFFFFFFFFFFFDLL)
  {
    v14 = 0;
LABEL_5:
    result = 0;
    *(_QWORD *)(a1 + 88) += v14;
    return result;
  }
  if ((v13 & 0x8000000000000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 327, 37, 0, "invalid block ID in write thread %lld", a7, a8, *(_QWORD *)(a2 + 48));
LABEL_20:
    v14 = 0;
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 4) != 1)
  {
    v18 = vrev64q_s8(*(int8x16_t *)(a2 + 56));
    v27 = vextq_s8(v18, v18, 8uLL);
    v19 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(_QWORD *)(a1 + 72), (uint64_t)&v27, 16);
    if ((v19 & 0x8000000000000000) == 0)
    {
      v14 = v19;
      if (v19 == 16)
      {
        v20 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(_QWORD *)(a1 + 72), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 56));
        if (v20 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 351, 37, 0, "writing block payload", v21, v22, v26);
          v14 = 16;
        }
        else
        {
          v14 = v20 + 16;
          if (v20 == *(_QWORD *)(a2 + 56))
            goto LABEL_5;
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 353, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v21, v22, v20);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 347, 37, 0, "Truncated block header (%lld/16 bytes written)", v16, v17, v19);
      }
      goto LABEL_22;
    }
    v23 = "writing block header";
    v24 = 345;
    goto LABEL_19;
  }
  v15 = pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 56), *(_QWORD *)(a1 + 72), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 56));
  if (v15 < 0)
  {
    v23 = "writing block";
    v24 = 334;
LABEL_19:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", v24, 37, 0, v23, v16, v17, v26);
    goto LABEL_20;
  }
  v14 = v15;
  if (v15 == *(_QWORD *)(a2 + 56))
    goto LABEL_5;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"outputStreamProc", 336, 37, 0, "Truncated block payload (%lld/%llu bytes written)", v16, v17, v15);
LABEL_22:
  *(_QWORD *)(a1 + 88) += v14;
  while (!__ldaxr(v8))
  {
    if (!__stlxr(1u, v8))
      return 0xFFFFFFFFLL;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t pcWrite(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  if (a4)
  {
    v6 = a4;
    v8 = 0;
    while (1)
    {
      v9 = a1(a2, a3, v6);
      v12 = v9;
      if (v9 < 0)
        break;
      a3 += v9;
      v8 += v9;
      v6 -= v9;
      if (!v6)
        return v8;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 131, 37, 0, "pcWrite failed", v10, v11, v16);
    return v12;
  }
  else
  {
    v8 = a1(a2, 0, 0);
    if (v8 < 0)
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v13, v14, v16);
  }
  return v8;
}

uint64_t PCompressFilter(unsigned int *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int DefaultNThreads;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  const char *v15;
  __int16 v16;
  unint64_t v17;
  unsigned int EncoderDecoder;
  FILE *v19;
  FILE **v20;
  FILE *v21;
  char *DecoderDescription;
  __int128 v23;
  __int128 v24;
  unsigned int v25;
  uint64_t (*DecoderFilter)();
  void (*v27)(_QWORD);
  void (*v28)(_QWORD);
  unsigned int v29;
  uint64_t result;
  void *v31;
  unint64_t v32;
  _QWORD *v33;
  size_t v34;
  void *v35;
  void *v36;
  __int16 v37;
  unint64_t v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  int *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  signed int v47;
  void *v48;
  void *v49;
  char *v50;
  _QWORD *v51;
  uint64_t v52;
  unsigned int *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  unint64_t v64;
  uint64_t Worker;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int *v86;
  uint64_t v87;
  uint64_t v88;
  const char *v89;
  __int16 v90;
  int v91;
  const char *v92;
  __int16 v93;
  char v94;
  int v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  char v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char v105;
  char v106;
  unint64_t v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  void *v114[2];
  unsigned int v115[3];
  int v116;
  unint64_t v117[4];

  v117[2] = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext((uint64_t)a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8, v105);
  *(_QWORD *)v115 = 0;
  v113 = 0u;
  *(_OWORD *)v114 = 0u;
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  v108 = 0u;
  DefaultNThreads = a1[2];
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  a1[2] = DefaultNThreads;
  if (a1[1] == 1)
  {
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(_QWORD *)(a2 + 16), (uint64_t)&v116, 4) != 4)goto LABEL_34;
    if (a3)
      *a3 += 4;
    v14 = 0;
    while (getHeader(v14, (uint64_t)v117) || v116 != LODWORD(v117[0]))
    {
      if (++v14 == 7)
      {
        if (compression_stream_identify_algorithm() == -1)
        {
          v15 = "invalid header in input stream";
          v16 = 179;
        }
        else
        {
          v15 = "compressed stream detected : try compression_tool";
          v16 = 178;
        }
LABEL_33:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processFileHeader", v16, 37, 0, v15, v12, v13, v106);
LABEL_34:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", 507, 37, 0, "processFileHeader", v12, v13, v106);
        goto LABEL_35;
      }
    }
    v117[0] = 0;
    if (pcRead(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))a2, *(_QWORD *)(a2 + 16), (uint64_t)v117, 8) != 8)goto LABEL_34;
    if (a3)
      *a3 += 8;
    if (!v117[0])
    {
      v15 = "invalid blockSize in input stream";
      v16 = 191;
      goto LABEL_33;
    }
    *((_QWORD *)a1 + 2) = bswap64(v117[0]);
    *a1 = v14;
    if ((int)a1[6] >= 1)
    {
      v20 = (FILE **)MEMORY[0x24BDAC8D8];
      v21 = (FILE *)*MEMORY[0x24BDAC8D8];
      DecoderDescription = PCompressGetDecoderDescription(v14);
      fprintf(v21, "Decoder: %s\n", DecoderDescription);
      fprintf(*v20, "Blocksize: %llu\n");
    }
  }
  else
  {
    v17 = *((_QWORD *)a1 + 2);
    EncoderDecoder = PCompressGetEncoderDecoder(*a1);
    if (getHeader(EncoderDecoder, (uint64_t)&v116)
      || pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(_QWORD *)(a2 + 40), (uint64_t)&v116, 4) != 4)
    {
      goto LABEL_34;
    }
    if (a3)
      a3[1] += 4;
    v117[0] = bswap64(v17);
    if (pcWrite(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24), *(_QWORD *)(a2 + 40), (uint64_t)v117, 8) != 8)goto LABEL_34;
    if (a3)
      a3[1] += 8;
    if ((int)a1[6] >= 1)
    {
      v19 = (FILE *)*MEMORY[0x24BDAC8D8];
      PCompressGetEncoderDescription(*a1);
      fprintf(v19, "Encoder: %s\n");
    }
  }
  v23 = *((_OWORD *)a1 + 1);
  v108 = *(_OWORD *)a1;
  v109 = v23;
  v113 = 0u;
  *(_OWORD *)v114 = 0u;
  *(_QWORD *)v115 = 0;
  v24 = *(_OWORD *)(a2 + 16);
  v110 = *(_OWORD *)a2;
  v111 = v24;
  v112 = *(_OWORD *)(a2 + 32);
  if (a3)
    v113 = *(_OWORD *)a3;
  v25 = *a1;
  if (a1[1])
    DecoderFilter = PCompressGetDecoderFilter(v25);
  else
    DecoderFilter = PCompressGetEncoderFilter(v25);
  v114[0] = DecoderFilter;
  v31 = calloc((int)a1[2], 0x48uLL);
  v114[1] = v31;
  if (!v31)
  {
    v37 = 468;
LABEL_98:
    v86 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", v37, 37, *v86, "malloc", v87, v88, v106);
LABEL_99:
    v89 = "initFilterState";
    v90 = 510;
LABEL_105:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"PCompressFilter", v90, 37, 0, v89, v45, v46, v106);
    v94 = 0;
    v95 = 1;
    goto LABEL_106;
  }
  v32 = a1[2];
  if ((int)v32 < 1)
    goto LABEL_53;
  v33 = v31;
  v34 = *((_QWORD *)a1 + 2);
  v35 = malloc(v34);
  v33[1] = v35;
  v36 = malloc(v34);
  v33[5] = v36;
  *v33 = &v108;
  v37 = 477;
  if (!v35 || !v36)
    goto LABEL_98;
  v38 = 0;
  v39 = v33 + 9;
  do
  {
    if (v32 - 1 == v38)
      goto LABEL_53;
    v40 = malloc(v34);
    v39[1] = v40;
    v41 = malloc(v34);
    v39[5] = v41;
    *v39 = &v108;
    ++v38;
    if (!v40)
      break;
    v39 += 9;
  }
  while (v41);
  v42 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"initFilterState", 477, 37, *v42, "malloc", v43, v44, v106);
  if (v38 < v32)
    goto LABEL_99;
LABEL_53:
  v107 = v109;
  v47 = DWORD2(v108);
  v48 = malloc(8 * SDWORD2(v108));
  if (!v48)
  {
    v91 = *__error();
    v92 = "malloc";
    v93 = 372;
LABEL_103:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", v93, 37, v91, v92, v59, v60, v106);
    goto LABEL_104;
  }
  v49 = v48;
  if (v47 >= 1)
  {
    v50 = (char *)v114[1];
    v51 = v48;
    v52 = v47;
    do
    {
      *v51++ = v50;
      v50 += 72;
      --v52;
    }
    while (v52);
  }
  v53 = ThreadPipelineCreate(v47, (uint64_t)v48, (uint64_t)compressionWorkerProc, (uint64_t)&v108, (uint64_t)outputStreamProc, 0);
  if (!v53)
  {
    v92 = "creating pipeline";
    v93 = 375;
    v91 = 0;
    goto LABEL_103;
  }
  v61 = (uint64_t)v53;
  v62 = 0;
  v63 = 1;
  v64 = v107;
  while (1)
  {
    if (atomic_load(v115))
    {
      v63 = 0;
      goto LABEL_120;
    }
    if (!v63)
      break;
    Worker = ThreadPipelineGetWorker(v61, v54, v55, v56, v57, v58, v59, v60);
    if (!Worker)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 387, 37, 0, "getting worker from pipeline", v67, v68, v106);
      v82 = 0;
LABEL_94:
      v63 = 0;
      goto LABEL_95;
    }
    v69 = (uint64_t *)Worker;
    if (DWORD1(v108) == 1)
    {
      v70 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, (uint64_t)v117, 16);
      v77 = v70;
      if (v70)
      {
        if (v70 < 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 397, 37, 0, "reading block header", v75, v76, v106);
          v82 = 0;
          v83 = 0;
          v77 = 0;
        }
        else if (v70 == 16)
        {
          v78 = bswap64(v117[0]);
          v79 = bswap64(v117[1]);
          if (v79 > v64 || v78 > v64)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 405, 37, 0, "Invalid block header payload=0x%llx raw=0x%llx block=0x%llx\n", v75, v76, v79);
            v82 = 0;
            v83 = 0;
            v77 = 16;
          }
          else
          {
            v80 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, v69[1], v79);
            if (v80 < 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 411, 37, 0, "reading block payload", v75, v76, v106);
              v82 = 0;
              v83 = 0;
              v77 = 16;
            }
            else
            {
              v77 = v80 + 16;
              if (v80 == v79)
              {
                v81 = v78;
                v82 = 0;
                v69[3] = v79;
                v69[4] = v81;
                v83 = 1;
                v69[2] = v62;
              }
              else
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 415, 37, 0, "Truncated block payload (%lld/%llu bytes read)", v75, v76, v80);
                v82 = 0;
                v83 = 0;
              }
            }
            v64 = v107;
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 399, 37, 0, "Truncated block header (%lld/16 bytes read)", v75, v76, v70);
          v82 = 0;
          v83 = 0;
        }
      }
      else
      {
        v82 = 1;
        v83 = 1;
      }
    }
    else
    {
      v84 = pcRead((uint64_t (*)(uint64_t, uint64_t, uint64_t))v110, v111, *(_QWORD *)(Worker + 8), v64);
      if (v84 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 428, 37, 0, "reading block", v75, v76, v106);
        v82 = 0;
LABEL_90:
        v63 = 0;
        v85 = -1;
        goto LABEL_91;
      }
      v77 = v84;
      if (!v84)
      {
        v85 = -2;
        v82 = 1;
        goto LABEL_89;
      }
      v82 = 0;
      v69[3] = v84;
      v69[4] = 0;
      v83 = 1;
      v69[2] = v62;
    }
    *(_QWORD *)&v113 = v113 + v77;
    if (!v82 && v83)
    {
      v82 = 0;
      v63 = 1;
      goto LABEL_92;
    }
    if (!v83)
      goto LABEL_90;
    v85 = -2;
LABEL_89:
    v63 = 1;
LABEL_91:
    v69[2] = v85;
LABEL_92:
    if ((ThreadPipelineRunWorker(v61, (uint64_t)v69, v71, v72, v73, v74, v75, v76) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 445, 37, 0, "RunWorker", v59, v60, v106);
      goto LABEL_94;
    }
LABEL_95:
    ++v62;
    if (v82)
      goto LABEL_120;
  }
  atomic_load(v115);
LABEL_120:
  if ((ThreadPipelineDestroy(v61) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"processStream", 447, 37, 0, "ThreadPipelineDestroy", v100, v101, v106);
    free(v49);
    goto LABEL_104;
  }
  free(v49);
  if (!v63)
  {
LABEL_104:
    v89 = "processStream";
    v90 = 513;
    goto LABEL_105;
  }
  v102 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 40), 0, 0);
  if (v102 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcWrite", 121, 37, 0, "pcWrite EOF failed", v103, v104, v106);
    v89 = "writing EOF";
    v90 = 520;
    goto LABEL_105;
  }
  v95 = 0;
  *((_QWORD *)&v113 + 1) += v102;
  v94 = 1;
LABEL_106:
  v96 = v114[1];
  if (v114[1])
  {
    if (SDWORD2(v108) >= 1)
    {
      v97 = 0;
      v98 = 0;
      do
      {
        free(*(void **)((char *)v114[1] + v97 + 8));
        free(*(void **)((char *)v114[1] + v97 + 40));
        ++v98;
        v97 += 72;
      }
      while (v98 < SDWORD2(v108));
      v96 = v114[1];
    }
    free(v96);
    v114[1] = 0;
  }
  v99 = v94 ^ 1;
  if (!a3)
    v99 = 1;
  if ((v99 & 1) == 0)
  {
    v29 = 0;
    *(_OWORD *)a3 = v113;
    goto LABEL_40;
  }
  if (!v95)
  {
    v29 = 0;
    goto LABEL_40;
  }
LABEL_35:
  v27 = *(void (**)(_QWORD))(a2 + 32);
  if (v27)
    v27(*(_QWORD *)(a2 + 40));
  v28 = *(void (**)(_QWORD))(a2 + 8);
  if (v28)
    v28(*(_QWORD *)(a2 + 16));
  v29 = -1;
LABEL_40:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v29;
  else
    return result;
}

uint64_t pcRead(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  if (!a4)
    return 0;
  v4 = a4;
  v8 = 0;
  while (1)
  {
    v9 = a1(a2, a3, v4);
    v12 = v9;
    if (v9 < 0)
      break;
    if (v9)
    {
      a3 += v9;
      v8 += v9;
      v4 -= v9;
      if (v4)
        continue;
    }
    return v8;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Filter.c", (uint64_t)"pcRead", 82, 37, 0, "pcRead failed", v10, v11, v14);
  return v12;
}

uint64_t getHeader(unsigned int a1, uint64_t a2)
{
  int DecoderKey;
  uint64_t result;
  char v5;

  DecoderKey = PCompressGetDecoderKey(a1);
  if (DecoderKey == 63)
    return 0xFFFFFFFFLL;
  v5 = DecoderKey;
  result = 0;
  *(_DWORD *)a2 = 538976288;
  *(_WORD *)a2 = 25200;
  *(_BYTE *)(a2 + 2) = 122;
  *(_BYTE *)(a2 + 3) = v5;
  return result;
}

uint64_t clusterLookup(uint64_t a1, unint64_t a2, char *__source, char *__dst, size_t __size, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t result;
  unint64_t v17;
  char *v18;
  char *v19;
  char v20;

  if (HIDWORD(a2))
  {
    v8 = "cluster id out of range";
    v9 = 213;
    v10 = 0;
LABEL_3:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"clusterLookup", v9, 2, v10, v8, a7, a8, v20);
    return 0xFFFFFFFFLL;
  }
  v17 = *(_QWORD *)a1;
  if (*(_QWORD *)a1 <= a2)
  {
    do
    {
      if (v17)
        v17 += v17 >> 1;
      else
        v17 = 32;
    }
    while (v17 <= a2);
    v19 = (char *)reallocf(*(void **)(a1 + 8), 1028 * v17);
    *(_QWORD *)(a1 + 8) = v19;
    if (!v19)
    {
      v10 = *__error();
      v8 = "malloc";
      v9 = 221;
      goto LABEL_3;
    }
    v18 = v19;
    bzero(&v19[1028 * *(_QWORD *)a1], 1028 * (v17 - *(_QWORD *)a1));
    *(_QWORD *)a1 = v17;
  }
  else
  {
    v18 = *(char **)(a1 + 8);
  }
  if (*(_DWORD *)&v18[1028 * a2])
  {
    strlcpy(__dst, &v18[1028 * a2 + 4], __size);
    return 1;
  }
  else
  {
    strlcpy(&v18[1028 * a2 + 4], __source, 0x400uLL);
    result = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 1028 * a2) = 1;
  }
  return result;
}

uint64_t setEntryAttributes(char *a1, uint64_t a2)
{
  int *v4;
  int v5;
  FILE **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;
  unint64_t DataSize;
  unsigned int *DataPtr;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  void (*v23)(_QWORD, uint64_t);
  unint64_t *v24;
  unint64_t v25;
  char *v27;
  char path[2048];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v4 = *(int **)a1;
  v5 = *(_DWORD *)(*(_QWORD *)a1 + 24);
  bzero(path, 0x800uLL);
  v6 = (FILE **)MEMORY[0x24BDAC8D8];
  if (*v4 >= 3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] set attributes: %s\n", *(_DWORD *)(a2 + 2296), (const char *)(a2 + 144));
  if ((concatExtractPath(path, 0x800uLL, a1 + 12, (const char *)(a2 + 144)) & 0x80000000) != 0)
  {
    LOBYTE(v27) = a2 - 112;
    v11 = "invalid path: %s";
    v10 = 252;
    goto LABEL_16;
  }
  if (*(_DWORD *)(a2 + 4) == 68 && (clearEntryXAT(path) & 0x80000000) != 0)
  {
    v27 = path;
    v11 = "clear XAT: %s";
    v10 = 257;
    goto LABEL_16;
  }
  v9 = v5 & 1;
  if (yaa_setEntryAttributes(path, (int *)a2, a2 + 2192, v9))
  {
    v10 = 261;
    v11 = "setEntryAttributes";
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"setEntryAttributes", v10, 2, 0, v11, v7, v8, (char)v27);
    v21 = 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  v12 = *(_QWORD *)(a2 + 2280);
  if (v12)
  {
    DataSize = MemBufferGetDataSize(v12);
    DataPtr = (unsigned int *)MemBufferGetDataPtr(*(_QWORD *)(a2 + 2280));
    if (yaa_setEntryXAT(path, a2, v9, DataSize, DataPtr, v15, v16, v17))
    {
      v11 = "setEntryXAT";
      v10 = 266;
      goto LABEL_16;
    }
  }
  v18 = *(_QWORD *)(a2 + 2288);
  if (v18)
  {
    v19 = MemBufferGetDataSize(v18) / 0x120uLL;
    v20 = MemBufferGetDataPtr(*(_QWORD *)(a2 + 2288));
    if (yaa_setEntryACL(path, a2, v9, v19, v20))
    {
      v11 = "setEntryACL";
      v10 = 272;
      goto LABEL_16;
    }
  }
  v21 = 0;
LABEL_17:
  v22 = *(int **)a1;
  v23 = *(void (**)(_QWORD, uint64_t))(*(_QWORD *)a1 + 96);
  if (v23)
  {
    v23(*((_QWORD *)v22 + 18), a2);
    v22 = *(int **)a1;
  }
  v24 = (unint64_t *)(a1 + 1528);
  do
    v25 = __ldxr(v24);
  while (__stxr(v25 - 1, v24));
  if (*v22 >= 3)
    fprintf(*v6, "[%7d] end: %s\n", *(_DWORD *)(a2 + 2296), (const char *)(a2 + 144));
  return v21;
}

uint64_t inFlightQueueEntry(_QWORD *a1, int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a1[174];
  if (!v2)
    return 0;
  v3 = a1[177];
  v4 = a1[175];
  v5 = (a2 - *(_DWORD *)(v3 + 2320 * v4 + 2296));
  if ((int)v5 < 0 || v2 <= v5)
    return 0;
  v6 = v4 + v5;
  v7 = a1[173];
  if (v6 < v7)
    v7 = 0;
  v8 = v6 - v7;
  v9 = v3 + 2320 * v8;
  if (v8 >= 0)
    return v9;
  else
    return 0;
}

uint64_t writeToThread(uint64_t a1, char *a2, size_t a3)
{
  size_t v3;
  pthread_mutex_t *v6;
  pthread_cond_t *v7;
  pthread_mutex_t *v8;
  pthread_cond_t *v9;
  unint64_t FreeSize;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  const char *v17;
  __int16 v18;
  char v19;

  if (!a3)
    return 0;
  v3 = a3;
  v6 = (pthread_mutex_t *)(a1 + 32);
  v7 = (pthread_cond_t *)(a1 + 96);
  v8 = (pthread_mutex_t *)(a1 + 152);
  v9 = (pthread_cond_t *)(a1 + 216);
  while (1)
  {
    FreeSize = MemBufferGetFreeSize(*(_QWORD **)(a1 + 16));
    if (FreeSize >= v3)
      v11 = v3;
    else
      v11 = FreeSize;
    if (v11)
    {
      MemBufferFillFromBuffer(*(unint64_t **)(a1 + 16), v11, a2);
      a2 += v11;
      v3 -= v11;
      goto LABEL_18;
    }
    if (pthread_mutex_lock(v6)
      || (v14 = *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 24) = v14 + 1, !v14) && pthread_cond_broadcast(v7)
      || pthread_mutex_unlock(v6))
    {
      v17 = "SemRelease";
      v18 = 755;
      goto LABEL_21;
    }
    if (pthread_mutex_lock(v8))
      goto LABEL_20;
    while (1)
    {
      v15 = *(_DWORD *)(a1 + 144);
      if (v15 > 0)
        break;
      if (pthread_cond_wait(v9, v8))
        goto LABEL_20;
    }
    *(_DWORD *)(a1 + 144) = v15 - 1;
    if (pthread_mutex_unlock(v8))
    {
LABEL_20:
      v17 = "SemAcquire";
      v18 = 758;
      goto LABEL_21;
    }
    if (!MemBufferGetFreeSize(*(_QWORD **)(a1 + 16)))
      break;
LABEL_18:
    if (!v3)
      return 0;
  }
  v17 = "thread didn't consume data";
  v18 = 761;
LABEL_21:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"writeToThread", v18, 2, 0, v17, v12, v13, v19);
  return 0xFFFFFFFFLL;
}

uint64_t SemRelease(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t result;

  v2 = (pthread_mutex_t *)(a1 + 8);
  result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (!(_DWORD)result)
  {
    if ((*(_DWORD *)a1)++)
      return pthread_mutex_unlock(v2);
    result = pthread_cond_broadcast((pthread_cond_t *)(a1 + 72));
    if (!(_DWORD)result)
      return pthread_mutex_unlock(v2);
  }
  return result;
}

uint64_t SemAcquire(uint64_t a1)
{
  pthread_mutex_t *v2;

  v2 = (pthread_mutex_t *)(a1 + 8);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 8)))
    return 0xFFFFFFFFLL;
  while (*(int *)a1 <= 0)
  {
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 72), v2))
      return 0xFFFFFFFFLL;
  }
  --*(_DWORD *)a1;
  if (pthread_mutex_unlock(v2))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t ParallelArchiveExtract()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int DefaultNThreads;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  uint64_t result;
  int v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  double v22;
  BOOL v23;
  unint64_t v24;
  _QWORD *v25;
  char *v26;
  _opaque_pthread_t **v27;
  uint64_t v28;
  char *v29;
  pthread_mutex_t *v30;
  int *v31;
  char *v32;
  char *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  FILE **v47;
  int v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  FILE *v64;
  unint64_t v65;
  FILE *v66;
  unint64_t v67;
  FILE *v68;
  unint64_t v69;
  FILE *v70;
  unint64_t v71;
  FILE *v72;
  unint64_t v73;
  FILE *v74;
  unint64_t v75;
  FILE *v76;
  unint64_t v77;
  FILE *v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  char *v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int v90;
  uint64_t v91;
  unint64_t v92;
  char *v93;
  char *v94;
  void **v95;
  char *v96;
  char *v97;
  int v98;
  uint64_t v99;
  double RealTime;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  double v111;
  int v112;
  char *v113;
  unsigned int v114;
  char *v115;
  char v116;
  char v117;
  uint64_t v118;
  int v119;
  _DWORD v120[2];
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  void (*v124)();
  _DWORD *(*v125)(_DWORD *, _DWORD *);
  uint64_t (*v126)(uint64_t, char *, size_t);
  uint64_t (*v127)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v128)(uint64_t);
  uint64_t (*v129)(uint64_t, uint64_t, uint64_t);
  int **v130;
  int *v131;
  int v132;
  char v133[1024];
  int v134;
  int v135;
  int v136;
  void *v137;
  pthread_mutex_t v138;
  pthread_cond_t v139;
  size_t __count;
  void *v141;
  int v142;
  pthread_mutex_t v143;
  pthread_mutex_t v144;
  unsigned int v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  void *v150;
  uint64_t v151;
  void *v152;
  uint64_t v153;
  void *v154;
  void *v155;
  void *v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159[3];
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  __int128 v165[512];
  _DWORD v166[36];
  char v167[2136];
  void **v168;
  void **v169;
  int v170;
  int v171;
  uint64_t v172;

  v0 = MEMORY[0x24BDAC7A8]();
  v172 = *MEMORY[0x24BDAC8D0];
  if (!v0)
    return 0xFFFFFFFFLL;
  v8 = v0;
  enterThreadErrorContext(v0, v1, v2, v3, v4, v5, v6, v7, v116);
  bzero(&v132, 0x628uLL);
  v131 = (int *)v8;
  DefaultNThreads = *(_DWORD *)(v8 + 20);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  LODWORD(__count) = DefaultNThreads;
  v145 = -1;
  v10 = *(_DWORD *)(v8 + 40);
  v132 = (*(_DWORD *)(v8 + 24) >> 1) & 1;
  v134 = v10;
  pthread_mutex_init(&v143, 0);
  pthread_mutex_init(&v144, 0);
  v118 = v8;
  if (!realpath_DARWIN_EXTSN(*(const char **)(v8 + 8), v133))
  {
    v17 = *__error();
    v20 = *(const char **)(v8 + 8);
    v21 = 1889;
    goto LABEL_15;
  }
  v135 = 0;
  v136 = __count;
  v137 = calloc(__count, 4uLL);
  if (!v137)
  {
    v14 = "SharedArrayInit: malloc failed\n";
    v15 = 55;
    goto LABEL_13;
  }
  if (pthread_mutex_init(&v138, 0))
  {
    v14 = "SharedArrayInit: pthread_mutex_init failed\n";
    v15 = 56;
LABEL_13:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayInit", v15, 0, v14, v11, v12, v13, v117);
    v20 = "SharedArrayInit";
    v21 = 1892;
    goto LABEL_14;
  }
  if (pthread_cond_init(&v139, 0))
  {
    v14 = "SharedArrayInit: pthread_cond_init failed\n";
    v15 = 57;
    goto LABEL_13;
  }
  v141 = calloc(__count, 0x130uLL);
  if (!v141)
  {
    v17 = *__error();
    v20 = "malloc";
    v21 = 1896;
    goto LABEL_15;
  }
  if ((_DWORD)__count)
  {
    v91 = 0;
    v92 = 0;
    while (1)
    {
      v93 = (char *)v141;
      v94 = (char *)v141 + v91;
      *(_QWORD *)((char *)v141 + v91) = &v131;
      v95 = MemBufferCreate(0x100000uLL);
      *((_QWORD *)v94 + 2) = v95;
      if (!v95)
        break;
      *((_DWORD *)v94 + 6) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v94 + 32), 0)
        || (v96 = &v93[v91], pthread_cond_init((pthread_cond_t *)&v93[v91 + 96], 0)))
      {
        v20 = "SemInit";
        v21 = 1903;
        goto LABEL_14;
      }
      *((_DWORD *)v96 + 36) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(v96 + 152), 0)
        || (v97 = &v93[v91], pthread_cond_init((pthread_cond_t *)(v97 + 216), 0)))
      {
        v20 = "SemInit";
        v21 = 1904;
        goto LABEL_14;
      }
      if (createThread((pthread_t *)v97 + 1, (uint64_t)extractThreadProc, (uint64_t)v94, 0))
      {
        v17 = *__error();
        v20 = "createThread";
        v21 = 1905;
        goto LABEL_15;
      }
      ++v92;
      v91 += 304;
      if (v92 >= __count)
        goto LABEL_90;
    }
    v20 = "MemBufferCreate";
    v21 = 1902;
LABEL_14:
    v17 = 0;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", v21, 2, v17, v20, v18, v19, v117);
    v119 = 0;
    v22 = 0.0;
    goto LABEL_16;
  }
LABEL_90:
  v122 = 0;
  v98 = *(_DWORD *)(v8 + 16);
  if (!v98)
    v98 = getDefaultNThreads();
  v120[0] = 0;
  v120[1] = v98;
  v99 = *(_QWORD *)(v8 + 64);
  v121 = *(_QWORD *)(v8 + 48);
  v130 = &v131;
  v123 = v99;
  v124 = extractBeginProc;
  v125 = extractBlobProc;
  v126 = extractPayloadProc;
  v127 = extractPaddingProc;
  v128 = extractEndProc;
  v129 = extractPaddingProc;
  RealTime = getRealTime();
  v108 = ParallelArchiveRead((uint64_t)v120, v101, v102, v103, v104, v105, v106, v107);
  v111 = getRealTime();
  v112 = 1;
  if (v108 | v142)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1929, 2, 0, "ParallelArchiveRead failed", v109, v110, v117);
    v142 = 1;
    v112 = 0;
  }
  v22 = v111 - RealTime;
  v119 = v112;
  if (v145 != -1 && v146)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1937, 2, 0, "aborting current receiving thread", v109, v110, v117);
    v142 = 1;
    v113 = (char *)v141;
    v114 = v145;
    if (!v146)
    {
      SemAcquire((uint64_t)v141 + 304 * v145 + 144);
      v146 = 1;
    }
    v115 = &v113[304 * v114];
    MemBufferClear(*((_QWORD **)v115 + 2));
    v146 = 0;
    SemRelease((uint64_t)(v115 + 24));
  }
  while (1)
  {
LABEL_16:
    if (v141)
      v23 = (_DWORD)__count == 0;
    else
      v23 = 1;
    if (!v23)
    {
      v24 = 0;
      do
      {
        v25 = v141;
        v26 = (char *)v141 + 304 * v24;
        v28 = *((_QWORD *)v26 + 1);
        v27 = (_opaque_pthread_t **)(v26 + 8);
        if (v28)
        {
          LODWORD(v165[0]) = 0;
          v29 = (char *)v141 + 304 * v24;
          v30 = (pthread_mutex_t *)(v29 + 152);
          if (!pthread_mutex_lock((pthread_mutex_t *)(v29 + 152)))
          {
            v31 = (int *)(v29 + 144);
            while (*v31 <= 0)
            {
              if (pthread_cond_wait((pthread_cond_t *)&v25[38 * v24 + 27], v30))
                goto LABEL_28;
            }
            --*v31;
            pthread_mutex_unlock(v30);
          }
LABEL_28:
          v32 = (char *)&v25[38 * v24];
          MemBufferFillFromBuffer(*((unint64_t **)v32 + 2), 4uLL, v165);
          if (!pthread_mutex_lock((pthread_mutex_t *)(v32 + 32)))
          {
            v33 = (char *)&v25[38 * v24];
            v34 = *((_DWORD *)v33 + 6);
            *((_DWORD *)v33 + 6) = v34 + 1;
            if (v34 || !pthread_cond_broadcast((pthread_cond_t *)&v25[38 * v24 + 12]))
              pthread_mutex_unlock((pthread_mutex_t *)(v32 + 32));
          }
          if (joinThread(*v27))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1970, 2, 0, "joinThread", v35, v36, v117);
            v119 = 0;
          }
        }
        v37 = (char *)&v25[38 * v24];
        MemBufferDestroy(*((void ***)v37 + 2));
        if (!pthread_mutex_destroy((pthread_mutex_t *)(v37 + 32)))
          pthread_cond_destroy((pthread_cond_t *)&v25[38 * v24 + 12]);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v25[38 * v24 + 19]))
          pthread_cond_destroy((pthread_cond_t *)&v25[38 * v24 + 27]);
        v38 = v25[38 * v24 + 36];
        do
          v39 = __ldaxr(&v160);
        while (__stlxr(v39 + v38, &v160));
        v40 = v25[38 * v24 + 37];
        do
          v41 = __ldaxr(&v164);
        while (__stlxr(v41 + v40, &v164));
        ++v24;
      }
      while (v24 < __count);
    }
    if (pthread_mutex_lock(&v143))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"processDeferredEntries", 692, 2, 0, "pthread_mutex_lock", v42, v43, v117);
      goto LABEL_56;
    }
    v46 = v151;
    v47 = (FILE **)MEMORY[0x24BDAC8D8];
    if (!v151)
      break;
    v48 = 1;
    do
    {
      memset(v167, 0, 368);
      memset(v166, 0, sizeof(v166));
      v151 = v46 - 1;
      v49 = (char *)v152 + 16 * v46 - 16;
      pc_zero_coder_decode((unsigned __int8 *)v166, 2320, *(unsigned __int8 **)v49, *((_QWORD *)v49 + 1));
      if (v171 != 6 || v166[1] != 68)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"processDeferredEntries", 702, 2, 0, "Invalid entry state", v50, v51, v117);
        v48 = 0;
      }
      saveThreadErrorContext(v165);
      if (*v131 >= 3)
        fprintf(*v47, "[%7d] processing deferred Dir: %s\n", v170, v167);
      if ((setEntryAttributes((char *)&v131, (uint64_t)v166) & 0x80000000) != 0)
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"processDeferredEntries", 711, 2, "Failed to set dir attributes", v52, v53, v54, v117);
        restoreThreadErrorContext(v165);
        v171 = 7;
        ++v153;
      }
      MemBufferDestroy(v168);
      MemBufferDestroy(v169);
      free(*(void **)v49);
      *(_QWORD *)v49 = 0;
      v46 = v151;
    }
    while (v151);
    pthread_mutex_unlock(&v143);
    if (v48)
      goto LABEL_58;
LABEL_56:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 1983, 2, 0, "Processing deferred entries", v44, v45, v117);
    v119 = 0;
  }
  pthread_mutex_unlock(&v143);
LABEL_58:
  v55 = v119;
  if (v119)
  {
    if (*(int *)v8 >= 1)
    {
      v56 = atomic_load(&v160);
      v57 = atomic_load(&v164);
      v58 = v57 + v56;
      v59 = atomic_load(&v161);
      v60 = atomic_load(&v162);
      v61 = v58 + v59 + v60;
      v62 = atomic_load(&v163);
      v63 = v61 + v62;
      v64 = *v47;
      v65 = atomic_load(&v157);
      fprintf(v64, "%12lld entries in archive\n", v65);
      v66 = *v47;
      v67 = atomic_load(&v158);
      fprintf(v66, "%12lld entries extracted\n", v67);
      fprintf(*v47, "%12llu entries failed to extract\n", v153);
      fprintf(*v47, "%12lld max entries in flight\n", v149);
      v68 = *v47;
      v69 = atomic_load(v159);
      fprintf(v68, "%12lld deferred directories\n", v69);
      fprintf(*v47, "%12llu bytes in archive\n", v147);
      fprintf(*v47, "%12lld bytes received in regular files\n", v63);
      v70 = *v47;
      v71 = atomic_load(&v160);
      fprintf(v70, "%12lld bytes stored in regular files\n", v71);
      v72 = *v47;
      v73 = atomic_load(&v164);
      fprintf(v72, "%12lld bytes not stored in holes\n", v73);
      v74 = *v47;
      v75 = atomic_load(&v161);
      fprintf(v74, "%12lld bytes not stored in hard links\n", v75);
      v76 = *v47;
      v77 = atomic_load(&v162);
      fprintf(v76, "%12lld bytes not stored in clones\n", v77);
      v78 = *v47;
      v79 = atomic_load(&v163);
      fprintf(v78, "%12lld bytes not stored in same data files\n", v79);
      fprintf(*v47, "%12.0f MB/s\n", (double)v63 / v22 * 0.000000953674316);
      if (*(int *)v8 >= 3)
      {
        if ((_DWORD)__count)
        {
          v80 = 0;
          v81 = 288;
          do
          {
            v82 = (char *)v141;
            fprintf(*v47, "-- thread %d:\n", v80);
            v83 = &v82[v81];
            fprintf(*v47, "%12lld entries stored\n", *((_QWORD *)v83 - 2));
            fprintf(*v47, "%12lld bytes received\n", *((_QWORD *)v83 - 1));
            fprintf(*v47, "%12lld bytes stored\n", *(_QWORD *)v83);
            fprintf(*v47, "%12lld buffers exchanged\n", *((_QWORD *)v83 - 3));
            ++v80;
            v81 += 304;
          }
          while (v80 < __count);
        }
      }
    }
  }
  free(v141);
  if (!pthread_mutex_destroy(&v138) && !pthread_cond_destroy(&v139))
    free(v137);
  pthread_mutex_destroy(&v143);
  pthread_mutex_destroy(&v144);
  if (v148)
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 2024, 2, 0, "Destroying state with non-empty in-flight queue", v84, v85, v117);
  free(v150);
  if (v151)
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 2026, 2, 0, "Destroying state with non-empty deferred queue", v86, v87, v117);
  free(v152);
  free(v154);
  free(v155);
  free(v156);
  if (v153 && (*(_BYTE *)(v118 + 24) & 8) == 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"ParallelArchiveExtract", 2035, 2, 0, "%llu entries failed to extract", v88, v89, v153);
    v55 = 0;
  }
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v55)
    v90 = 0;
  else
    v90 = -1;
  if ((int)result >= 0)
    return v90;
  else
    return result;
}

uint64_t extractThreadProc()
{
  uint64_t v0;
  unsigned int *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  void **v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int *v16;
  uint64_t v17;
  unint64_t *v18;
  const char *v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int16 v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t DataSize;
  void *DataPtr;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  size_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int *v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __int16 v84;
  const char *v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  size_t v95;
  const void *v96;
  void *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  __int16 v102;
  const char *v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  __int16 v119;
  unint64_t v120;
  unsigned int *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  __int16 v130;
  const char *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  void **v136;
  uint64_t v137;
  uint64_t v138;
  void **v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  _DWORD *v148;
  uint64_t v149;
  uint64_t v150;
  char v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  __int16 v155;
  const char *v156;
  __int16 v157;
  __int16 v158;
  int v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  _BOOL4 v165;
  int v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  mode_t v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  char *v175;
  uint64_t v176;
  uint64_t v177;
  int v178;
  int *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  int v185;
  const char *v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  uint64_t v196;
  uint64_t v197;
  int *v198;
  uint64_t v199;
  uint64_t v200;
  int *v201;
  uint64_t v202;
  uint64_t v203;
  int *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  char v215;
  char v216;
  unsigned int v217;
  int v218;
  const char *v219;
  pthread_mutex_t *v220;
  int v221;
  int v222;
  int v223;
  uint64_t (*v224)(uint64_t, __int128 *, unint64_t, size_t, void *);
  uint64_t v225;
  void (*v226)(uint64_t, __int128 *, uint64_t *);
  void (*v227)(_QWORD, __int128 *);
  unsigned int v228;
  pthread_mutex_t *v229;
  unint64_t *v230;
  int v231;
  size_t v232;
  unsigned int *v233;
  uint64_t v234;
  unint64_t *v235;
  pthread_mutex_t *v236;
  void *v237;
  size_t v238;
  int v239;
  uint64_t v240;
  uint64_t v241;
  dev_t v242;
  _OWORD v243[4];
  __int128 v244;
  uint64_t v245;
  int __dst;
  sockaddr v247;
  __int128 v248;
  __int128 v249;
  __int128 v250;
  __int128 v251;
  char v252[26];
  char v253[1024];
  __int128 __s[512];
  std::__fs::filesystem::path v255[85];
  __int128 v256;
  dev_t v257[4];
  __int128 v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  _OWORD v265[64];
  char v266[1032];
  uint64_t v267;

  v0 = MEMORY[0x24BDAC7A8]();
  v267 = *MEMORY[0x24BDAC8D0];
  v1 = *(unsigned int **)v0;
  v2 = **(_QWORD **)v0;
  v223 = *(_DWORD *)v2;
  v3 = 678152731 * ((unint64_t)(v0 - *(_QWORD *)(*(_QWORD *)v0 + 1176)) >> 4);
  __dst = -1;
  memset(v265, 0, 368);
  v264 = 0u;
  v263 = 0u;
  v262 = 0u;
  v261 = 0u;
  v260 = 0u;
  v259 = 0u;
  v258 = 0u;
  *(_OWORD *)v257 = 0u;
  v256 = 0u;
  v245 = 0;
  v244 = 0u;
  memset(v243, 0, sizeof(v243));
  bzero(v255, 0x800uLL);
  v239 = -1;
  v225 = *(_QWORD *)(v2 + 144);
  v226 = *(void (**)(uint64_t, __int128 *, uint64_t *))(v2 + 88);
  v227 = *(void (**)(_QWORD, __int128 *))(v2 + 96);
  v224 = *(uint64_t (**)(uint64_t, __int128 *, unint64_t, size_t, void *))(v2 + 104);
  v4 = *(_DWORD *)(v2 + 24);
  v5 = MemBufferCreate(0x10000uLL);
  v235 = (unint64_t *)MemBufferCreate(0x10000uLL);
  if (!v5 || !v235)
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 818, 2, 0, "MemBufferCreate", v6, v7, v215);
  v240 = 0;
  v241 = 0;
  v242 = 0;
  if (*(_QWORD *)(*(_QWORD *)v1 + 32) <= 8uLL)
    v8 = 8;
  else
    v8 = *(_QWORD *)(*(_QWORD *)v1 + 32);
  v238 = v8;
  v237 = calloc(v8, 0x120uLL);
  if (!v237)
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 823, 2, 0, "malloc ACE", v9, v10, v215);
  v233 = v1 + 260;
  if (SharedArrayPush_0(v1 + 260, v3))
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 826, 2, 0, "SharedArrayPush", v11, v12, v215);
  v228 = v4 & 1;
  v236 = (pthread_mutex_t *)(v0 + 152);
  if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 152))
    || (v15 = *(_DWORD *)(v0 + 144), *(_DWORD *)(v0 + 144) = v15 + 1, !v15)
    && pthread_cond_broadcast((pthread_cond_t *)(v0 + 216))
    || pthread_mutex_unlock(v236))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 835, 2, 0, "SemRelease", v13, v14, v215);
  }
  v234 = 0;
  v16 = 0;
  v232 = 0;
  v17 = 0;
  v18 = (unint64_t *)(v1 + 382);
  v229 = (pthread_mutex_t *)(v1 + 298);
  v220 = (pthread_mutex_t *)(v1 + 314);
  if ((v4 & 0x10000) != 0)
    v19 = " (MSU)";
  else
    v19 = (const char *)&unk_206434423;
  v219 = v19;
  v221 = (16 * v4) & 0x40;
  v222 = v4;
  v231 = 7;
  v20 = 1;
  v230 = (unint64_t *)v5;
  while ((_DWORD)v17 != -1)
  {
    v21 = v17;
    if ((_DWORD)v17 == 6)
      break;
    if ((v20 & 1) != 0)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 32)))
        goto LABEL_29;
      while (1)
      {
        v24 = *(_DWORD *)(v0 + 24);
        if (v24 > 0)
          break;
        if (pthread_cond_wait((pthread_cond_t *)(v0 + 96), (pthread_mutex_t *)(v0 + 32)))
          goto LABEL_29;
      }
      *(_DWORD *)(v0 + 24) = v24 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v0 + 32)))
LABEL_29:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 847, 2, 0, "SemAcquire", v22, v23, v215);
      ++*(_QWORD *)(v0 + 264);
    }
    if (MemBufferGetDataSize(*(_QWORD *)(v0 + 16)) || !v1[296])
    {
      v20 = v17;
      switch((int)v17)
      {
        case 0:
        case 2:
          if ((unint64_t)MemBufferGetDataSize(*(_QWORD *)(v0 + 16)) < 4)
            goto LABEL_100;
          if (MemBufferFlushToBuffer(*(_QWORD **)(v0 + 16), 4uLL, &__dst, v29, v30, v31, v32, v33) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 870, 2, 0, "MemBufferFlushToBuffer", v34, v35, v215);
            v20 = 0;
            continue;
          }
          v20 = 0;
          *(_QWORD *)(v0 + 280) += 4;
          v17 = 6;
          if (!(v21 | __dst))
            continue;
          if (!(_DWORD)v21)
          {
            v20 = 0;
            v17 = 1;
            if (__dst == 1)
              continue;
          }
          if ((_DWORD)v21 == 2 && __dst == 2)
          {
            if ((BYTE1(v256) & 2) != 0)
            {
              v20 = 0;
              v17 = 3;
              v232 = v260;
              continue;
            }
            v17 = 2;
            v36 = 882;
            v37 = "unexpected DAT blob";
            goto LABEL_164;
          }
          if ((_DWORD)v21 == 2 && __dst == 3)
          {
            if ((BYTE1(v256) & 4) == 0)
            {
              v17 = 2;
              v36 = 889;
              v37 = "unexpected XAT blob";
LABEL_164:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v36, 2, 0, v37, v34, v35, v215);
              goto LABEL_146;
            }
            v20 = 0;
            v17 = 3;
            v232 = *((_QWORD *)&v260 + 1);
          }
          else if ((_DWORD)v21 == 2 && __dst == 4)
          {
            if ((BYTE1(v256) & 8) == 0)
            {
              v17 = 2;
              v36 = 896;
              v37 = "unexpected ACL blob";
              goto LABEL_164;
            }
            v20 = 0;
            v17 = 3;
            v232 = v261;
          }
          else
          {
            v20 = 0;
            if (__dst == 5 && (_DWORD)v21 == 2)
              v17 = 4;
            else
              v17 = 0xFFFFFFFFLL;
          }
          continue;
        case 1:
          if ((unint64_t)MemBufferGetDataSize(*(_QWORD *)(v0 + 16)) < 0x8EC)
          {
            v21 = 1;
            goto LABEL_100;
          }
          if (MemBufferFlushToBuffer(*(_QWORD **)(v0 + 16), 0x890uLL, &v256, v40, v41, v42, v43, v44) < 0)
          {
            v119 = 914;
            goto LABEL_156;
          }
          if (MemBufferFlushToBuffer(*(_QWORD **)(v0 + 16), 0x58uLL, v243, v71, v72, v73, v74, v75) < 0)
          {
            v119 = 915;
            goto LABEL_156;
          }
          if (MemBufferFlushToBuffer(*(_QWORD **)(v0 + 16), 4uLL, &v239, v76, v77, v78, v74, v75) < 0)
          {
            v119 = 916;
LABEL_156:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v119, 2, 0, "MemBufferFlushToBuffer", v74, v75, v215);
LABEL_222:
            v20 = 0;
            v17 = 1;
            continue;
          }
          *(int64x2_t *)(v0 + 272) = vaddq_s64(*(int64x2_t *)(v0 + 272), (int64x2_t)xmmword_20643F2C0);
          if (!v226)
            goto LABEL_189;
          v240 = 0;
          v241 = 0;
          v242 = 0;
          v226(v225, &v256, &v240);
          if ((v240 & 1) != 0)
          {
            LODWORD(v256) = v256 | 2;
            DWORD2(v256) = HIDWORD(v240);
            if ((v240 & 2) == 0)
            {
LABEL_81:
              if ((v240 & 8) == 0)
                goto LABEL_82;
              goto LABEL_167;
            }
          }
          else if ((v240 & 2) == 0)
          {
            goto LABEL_81;
          }
          LODWORD(v256) = v256 | 4;
          HIDWORD(v256) = v241;
          if ((v240 & 8) == 0)
          {
LABEL_82:
            if ((v240 & 4) == 0)
              goto LABEL_84;
LABEL_83:
            LODWORD(v256) = v256 | 8;
            v257[0] = HIDWORD(v241);
            goto LABEL_84;
          }
LABEL_167:
          LODWORD(v256) = v256 | 0x10;
          v257[1] = v242;
          if ((v240 & 4) != 0)
            goto LABEL_83;
LABEL_84:
          if ((v240 & 0xF) == 0)
            goto LABEL_189;
          v79 = v239;
          if (pthread_mutex_lock(v229))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueOverrideAttributes", 392, 2, 0, "pthread_mutex_lock", v80, v81, v215);
            goto LABEL_87;
          }
          v148 = (_DWORD *)inFlightQueueEntry(v1, v79);
          if (!v148)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueOverrideAttributes", 396, 2, 0, "couldn't locate entry [%d] in queue", v149, v150, v79);
            pthread_mutex_unlock(v229);
LABEL_87:
            v84 = 937;
            v85 = "override attributes";
LABEL_220:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v84, 2, 0, v85, v82, v83, v215);
LABEL_221:
            v231 = 0;
            goto LABEL_222;
          }
          v151 = v240;
          if ((v240 & 1) != 0)
          {
            *v148 |= 2u;
            v148[2] = HIDWORD(v240);
            v151 = v240;
            if ((v240 & 2) == 0)
            {
LABEL_185:
              if ((v151 & 8) == 0)
                goto LABEL_186;
              goto LABEL_226;
            }
          }
          else if ((v240 & 2) == 0)
          {
            goto LABEL_185;
          }
          *v148 |= 4u;
          v148[3] = v241;
          v151 = v240;
          if ((v240 & 8) == 0)
          {
LABEL_186:
            if ((v151 & 4) == 0)
              goto LABEL_188;
LABEL_187:
            *v148 |= 8u;
            v148[4] = HIDWORD(v241);
            goto LABEL_188;
          }
LABEL_226:
          *v148 |= 0x10u;
          v148[5] = v242;
          if ((v240 & 4) != 0)
            goto LABEL_187;
LABEL_188:
          pthread_mutex_unlock(v229);
          do
LABEL_189:
            v152 = __ldxr(v18);
          while (__stxr(v152 + 1, v18));
          if (**(int **)v1 >= 3)
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] begin: %s\n", v239, (const char *)v265);
          if ((concatExtractPath((char *)v255, 0x800uLL, (char *)v1 + 12, (const char *)v265) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 943, 2, 0, "invalid path: %s", v153, v154, (char)v265);
            goto LABEL_221;
          }
          v155 = v256;
          if ((v256 & 0x400) != 0)
          {
            if ((MemBufferIncreaseCapacity((uint64_t)v5, *((size_t *)&v260 + 1)) & 0x8000000000000000) != 0)
            {
              v84 = 948;
              v85 = "allocate XAT blob";
              goto LABEL_220;
            }
            v155 = v256;
          }
          if ((v155 & 0x800) != 0 && (MemBufferIncreaseCapacity((uint64_t)v235, v261) & 0x8000000000000000) != 0)
          {
            v84 = 952;
            v85 = "allocate ACL blob";
            goto LABEL_220;
          }
          if (!MemBufferIsEmpty((uint64_t)v5) || !MemBufferIsEmpty((uint64_t)v235))
          {
            v84 = 956;
            v85 = "XAT/ACL blob is not empty";
            goto LABEL_220;
          }
          switch(DWORD1(v256))
          {
            case 'B':
            case 'C':
              if (v223 >= 3)
              {
                v156 = "CHAR";
                if (DWORD1(v256) == 66)
                  v156 = "BLOCK";
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] %s SPECIAL: %s\n", v239, v156, (const char *)v255);
              }
              if ((v256 & 0x20) == 0)
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1183, 2, 0, "DEV field is not set for a block/char special entry", v82, v83, v215);
              unlink((const char *)v255);
              v157 = v257[1];
              if ((v256 & 0x10) == 0)
                v157 = 420;
              if (DWORD1(v256) == 66)
                v158 = 24576;
              else
                v158 = 0x2000;
              v159 = mknod((const char *)v255, v158 | v157, v257[2]);
              v20 = 0;
              v17 = 2;
              v231 = 3;
              if (v159)
              {
                pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1197, 2, "mknod %s", v160, v161, v162, (char)v255);
                goto LABEL_251;
              }
              continue;
            case 'D':
              v20 = 0;
              v17 = 2;
              v231 = 1;
              if (v223 >= 3)
              {
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] DIR deferred: %s\n");
                goto LABEL_239;
              }
              continue;
            case 'E':
            case 'G':
            case 'I':
            case 'J':
            case 'K':
            case 'M':
            case 'N':
            case 'O':
            case 'Q':
            case 'R':
              goto LABEL_231;
            case 'F':
              v163 = v3;
              v164 = v1[259];
              v165 = (v256 & 8) != 0 && statIsCompressed(v257[0]) && (_QWORD)v260 != 0;
              if (v223 >= 3)
              {
                v186 = (const char *)&unk_206434423;
                if (v165)
                  v186 = " (C)";
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] FILE writing %s%s: %s\n", v239, v186, v219, (const char *)v265);
              }
              if (v165)
              {
                if ((v243[0] & 0x20) != 0
                  && (v187 = v244 - 3, (v244 - 3) <= 0xB)
                  && ((0xFF3u >> v187) & 1) != 0)
                {
                  v188 = dword_20643F324[v187];
                  v164 = dword_20643F354[v187];
                }
                else
                {
                  v188 = 4;
                }
              }
              else
              {
                v188 = 0;
              }
              v189 = v188 | v221;
              if ((v222 & 0x10000) != 0)
                v190 = v189 | 0x2B;
              else
                v190 = v189;
              if ((v222 & 0x10) != 0)
              {
                if ((v243[0] & 0x80) != 0)
                  v191 = DWORD2(v244);
                else
                  v191 = -1;
              }
              else
              {
                v191 = -1;
              }
              removeFile((const char *)v255);
              saveThreadErrorContext(__s);
              v16 = OArchiveFileStreamCreate((const char *)v255, v260, v190 | 0x100u, v191, v164);
              if (!v16)
              {
                pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1050, 2, "OArchiveFileStreamCreate: %s", v192, v193, v194, (char)v255);
                restoreThreadErrorContext(__s);
              }
              v20 = 0;
              v231 = 2;
              v17 = 2;
              v3 = v163;
              v5 = (void **)v230;
              continue;
            case 'H':
              v20 = 0;
              v17 = 2;
              v231 = 1;
              if (v223 < 3)
                continue;
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] HLINK (legacy) deferred: %s\n");
              goto LABEL_239;
            case 'L':
              if (v223 >= 3)
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] SLINK: %s -> %s\n", v239, (const char *)v265, v266);
              unlink((const char *)v255);
              v166 = symlink(v266, (const char *)v255);
              v20 = 0;
              v17 = 2;
              v231 = 3;
              if (!v166)
                continue;
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1074, 2, "symlink %s -> %s", v167, v168, v169, (char)v255);
              goto LABEL_251;
            case 'P':
              if (v223 >= 3)
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] FIFO: %s\n", v239, (const char *)v265);
              unlink((const char *)v255);
              if ((v256 & 0x10) != 0)
                v170 = LOWORD(v257[1]) | 0x1000;
              else
                v170 = 4516;
              v171 = mkfifo((const char *)v255, v170);
              v20 = 0;
              v17 = 2;
              v231 = 3;
              if (!v171)
                continue;
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1096, 2, "mkfifo %s", v172, v173, v174, (char)v255);
LABEL_251:
              v20 = 0;
              v231 = 7;
              continue;
            case 'S':
              if (v223 >= 3)
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] SOCKET: %s\n", v239, (const char *)v265);
              unlink((const char *)v255);
              bzero(__s, 0x400uLL);
              bzero(v253, 0x400uLL);
              v251 = 0u;
              memset(v252, 0, sizeof(v252));
              v249 = 0u;
              v250 = 0u;
              v247 = (sockaddr)0;
              v248 = 0u;
              __strlcpy_chk();
              v175 = strrchr((char *)__s, 47);
              if (!v175)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1125, 2, 0, "could not determine parent directory: %s", v176, v177, (char)v255);
LABEL_286:
                v231 = 3;
                goto LABEL_116;
              }
              *v175 = 0;
              v251 = 0u;
              memset(v252, 0, sizeof(v252));
              v249 = 0u;
              v250 = 0u;
              v247 = (sockaddr)0;
              v248 = 0u;
              __strlcpy_chk();
              v247.sa_len = strlen(v247.sa_data) + 3;
              v247.sa_family = 1;
              v178 = socket(1, 1, 0);
              if (v178 < 0)
              {
                v195 = *__error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1150, 2, v195, "socket failed: %s", v196, v197, (char)v255);
                goto LABEL_286;
              }
              v218 = v178;
              if (pthread_mutex_lock(v220) < 0)
              {
                v179 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1157, 2, *v179, "locking chdir_mutex failed: %s", v180, v181, (char)v255);
              }
              if (getcwd(v253, 0x400uLL))
              {
                if (chdir((const char *)__s) < 0 || bind(v218, &v247, 0x6Au) < 0)
                {
                  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1164, 2, "chdir+bind failed: %s/%s", v182, v183, v184, (char)__s);
                  v185 = 7;
                }
                else
                {
                  v185 = 3;
                }
                v231 = v185;
                if (chdir(v253) < 0)
                {
                  v198 = __error();
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1168, 2, *v198, "chdir failed: %s", v199, v200, (char)v253);
                }
              }
              else
              {
                v201 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1170, 2, *v201, "getcwd failed: %s", v202, v203, (char)v255);
                v231 = 3;
              }
              if (pthread_mutex_unlock(v220) < 0)
              {
                v204 = __error();
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1171, 2, *v204, "unlocking chdir_mutex failed: %s", v205, v206, (char)v255);
              }
              close(v218);
              break;
            default:
              if ((DWORD1(v256) - 120) >= 2)
              {
LABEL_231:
                v17 = 2;
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1205, 2, 0, "unsupported entry type", v82, v83, v215);
                v231 = 0;
                goto LABEL_146;
              }
              v20 = 0;
              v17 = 2;
              v231 = 1;
              if (v223 >= 3)
              {
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] HLINK/CLONE deferred: %s\n");
LABEL_239:
                v20 = 0;
                v231 = 1;
              }
              continue;
          }
          goto LABEL_116;
        case 3:
          DataSize = MemBufferGetDataSize(*(_QWORD *)(v0 + 16));
          DataPtr = (void *)MemBufferGetDataPtr(*(_QWORD *)(v0 + 16));
          if (DataSize >= v232)
            v52 = v232;
          else
            v52 = DataSize;
          *(_QWORD *)(v0 + 280) += v52;
          switch(__dst)
          {
            case 4:
              if (MemBufferFillFromBuffer(v235, v52, DataPtr) < 0)
              {
                v102 = 1239;
                v103 = "storing ACL blob contents";
LABEL_150:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v102, 2, 0, v103, v50, v51, v215);
                v20 = 0;
                v17 = 3;
                v5 = (void **)v230;
                continue;
              }
              break;
            case 3:
              if (MemBufferFillFromBuffer(v230, v52, DataPtr) < 0)
              {
                v102 = 1234;
                v103 = "storing XAT blob contents";
                goto LABEL_150;
              }
              break;
            case 2:
              if (!v16 || OArchiveFileStreamWrite((uint64_t)v16, (char *)DataPtr, v52, v47, v48, v49, v50, v51) != v52)
              {
                pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1227, 2, "OArchiveFileStreamWrite", v49, v50, v51, v215);
                v231 = 7;
              }
              break;
            default:
              v102 = 1241;
              v103 = "invalid op in BLOB PAYLOAD";
              goto LABEL_150;
          }
          MemBufferDecreaseSize(*(_QWORD *)(v0 + 16), v52, v53, v54, v55, v49, v50, v51);
          v232 -= v52;
          if (v232)
          {
            v21 = 3;
            v5 = (void **)v230;
            goto LABEL_100;
          }
          v232 = 0;
          v20 = 0;
          v17 = 2;
          v5 = (void **)v230;
          if (__dst == 4)
          {
            v20 = 0;
            v232 = 0;
            if ((BYTE1(v256) & 8) != 0)
            {
              if ((_QWORD)v261)
              {
                v108 = MemBufferGetDataSize((uint64_t)v235);
                v109 = MemBufferGetDataPtr((uint64_t)v235);
                v115 = yaa_decodeACL((uint64_t)&v256, &v238, &v237, v108, v109, v110, v111, v112);
                if (v115 < 0)
                  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1255, 2, 0, "decodeEntryACL", v113, v114, v215);
                v116 = v115 & ~(v115 >> 63);
                if (v224)
                {
                  v116 = v224(v225, &v256, v116, v238, v237);
                  if (v116 > v238)
                  {
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1262, 2, 0, "invalid user ACL callback return value", v117, v118, v215);
                    v116 = 0;
                  }
                }
                v234 = v116;
                MemBufferClear(v235);
                v232 = 0;
LABEL_116:
                v20 = 0;
                v17 = 2;
              }
            }
          }
          break;
        case 4:
          *(_QWORD *)&__s[0] = 0;
          if ((unint64_t)MemBufferGetDataSize(*(_QWORD *)(v0 + 16)) < 8)
          {
            v21 = 4;
            goto LABEL_100;
          }
          if (MemBufferFlushToBuffer(*(_QWORD **)(v0 + 16), 8uLL, __s, v56, v57, v58, v59, v60) < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1283, 2, 0, "MemBufferFlushToBuffer", v86, v87, v215);
            v17 = 4;
            goto LABEL_146;
          }
          *(_QWORD *)(v0 + 280) += 8;
          v88 = v239;
          v89 = *(_QWORD *)&__s[0];
          if (pthread_mutex_lock(v229))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreEntryEnd", 415, 2, 0, "pthread_mutex_lock", v90, v91, v215);
LABEL_91:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1285, 2, 0, "store entryEnd", v92, v93, v216);
            goto LABEL_145;
          }
          v142 = inFlightQueueEntry(v1, v88);
          if (!v142)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreEntryEnd", 419, 2, 0, "couldn't locate entry [%d] in queue", v143, v144, v88);
            pthread_mutex_unlock(v229);
            goto LABEL_91;
          }
          *(_QWORD *)(v142 + 2312) = v89;
          pthread_mutex_unlock(v229);
LABEL_145:
          v17 = 5;
LABEL_146:
          v20 = 0;
          continue;
        case 5:
          v61 = (unsigned int *)v16;
          v62 = v231;
          if (v61)
          {
            *(_QWORD *)&__s[0] = 0;
            *(_QWORD *)v253 = 0;
            OArchiveFileStreamDestroyEx(v61, 0, __s, v253, v25, v26, v27, v28);
            v63 = *(_QWORD *)(v0 + 296) + *(_QWORD *)v253;
            *(_QWORD *)(v0 + 288) += *(_QWORD *)&__s[0];
            *(_QWORD *)(v0 + 296) = v63;
            if ((v256 & 8) != 0
              && statIsCompressed(v257[0])
              && (_QWORD)v260
              && (v243[0] & 0x20) != 0
              && (v243[0] & 0x40) != 0
              && DWORD1(v244)
              && (ParallelCompressionAFSCFixupMetadata(v255, v244, DWORD1(v244)) & 0x80000000) != 0)
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1310, 2, "ParallelCompressionAFSCFixupMetadata failed: %s (aft=%d afr=%u)", v64, v65, v66, (char)v255);
            }
          }
          if (v231 == 2)
            v62 = 3;
          if (v62 == 7)
            goto LABEL_132;
          if (v62 == 3)
          {
            saveThreadErrorContext(__s);
            if (yaa_setEntryAttributes((char *)v255, (int *)&v256, (uint64_t)v243, v228))
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1329, 2, "setEntryAttributes: %s", v67, v68, v69, (char)v255);
              v70 = 7;
            }
            else
            {
              v70 = 3;
            }
            if ((BYTE1(v256) & 4) != 0)
            {
              v120 = MemBufferGetDataSize((uint64_t)v5);
              v121 = (unsigned int *)MemBufferGetDataPtr((uint64_t)v5);
              if (yaa_setEntryXAT((char *)v255, (uint64_t)&v256, v228, v120, v121, v122, v123, v124))
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1338, 2, 0, "setEntryXAT: %s", v125, v126, (char)v255);
                v70 = 7;
              }
            }
            if ((BYTE1(v256) & 8) != 0
              && yaa_setEntryACL((const char *)v255, (uint64_t)&v256, v228, v234, (uint64_t)v237))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1348, 2, 0, "setEntryACL: %s", v127, v128, (char)v255);
              v70 = 7;
            }
            if (v227)
              v227(*(_QWORD *)(*(_QWORD *)v1 + 144), &v256);
            do
              v129 = __ldxr(v18);
            while (__stxr(v129 - 1, v18));
            if (v70 == 7)
            {
              restoreThreadErrorContext(__s);
              v62 = 7;
            }
            else
            {
              v62 = 4;
            }
          }
          else
          {
            v231 = v62;
            v217 = v3;
            v94 = v239;
            v95 = MemBufferGetDataSize((uint64_t)v5);
            v96 = (const void *)MemBufferGetDataPtr((uint64_t)v5);
            v97 = v237;
            if (pthread_mutex_lock(v229))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 436, 2, 0, "pthread_mutex_lock", v98, v99, v215);
              v3 = v217;
              v5 = (void **)v230;
              goto LABEL_180;
            }
            v132 = inFlightQueueEntry(v1, v94);
            if (!v132)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 440, 2, 0, "couldn't locate entry [%d] in queue", v133, v134, v94);
              goto LABEL_178;
            }
            v135 = v132;
            if (v95)
            {
              v136 = MemBufferCreateWithData(v95, v96);
              *(_QWORD *)(v135 + 2280) = v136;
              if (!v136)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 445, 2, 0, "allocating XAT blob", v137, v138, v215);
LABEL_178:
                v3 = v217;
LABEL_179:
                pthread_mutex_unlock(v229);
                v5 = (void **)v230;
LABEL_180:
                v130 = 1372;
                v131 = "store XAT and ACL blobs in entry";
LABEL_181:
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", v130, 2, 0, v131, v100, v101, v215);
                v16 = 0;
                v20 = 0;
                v17 = 5;
                continue;
              }
            }
            if (v234)
            {
              v139 = MemBufferCreateWithData(288 * v234, v97);
              *(_QWORD *)(v135 + 2288) = v139;
              if (!v139)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueStoreBlobs", 450, 2, 0, "allocating ACL blob", v140, v141, v215);
                v3 = v217;
                goto LABEL_179;
              }
            }
            pthread_mutex_unlock(v229);
            v3 = v217;
            v5 = (void **)v230;
            v62 = v231;
          }
LABEL_132:
          v231 = v62;
          if (inFlightQueueRetire())
          {
            v130 = 1380;
            v131 = "retiring entry from in-flight state";
            goto LABEL_181;
          }
          if (MemBufferGetDataSize(*(_QWORD *)(v0 + 16)))
          {
            v130 = 1383;
            v131 = "buffer is not empty";
            goto LABEL_181;
          }
          v239 = -1;
          MemBufferClear(v5);
          MemBufferClear(v235);
          if (SharedArrayPush_0(v233, v3))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1398, 2, 0, "SharedArrayPush", v145, v146, v215);
            v16 = 0;
            v234 = 0;
            v21 = 5;
            goto LABEL_100;
          }
          v21 = 0;
          v16 = 0;
          goto LABEL_46;
        case 6:
          goto LABEL_100;
        case 7:
          goto LABEL_43;
        default:
          continue;
      }
    }
    else
    {
LABEL_43:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1406, 2, 0, "aborting entry", v27, v28, v215);
      v239 = -1;
      MemBufferClear(v5);
      MemBufferClear(v235);
      if (SharedArrayPush_0(v233, v3))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1421, 2, 0, "SharedArrayPush", v38, v39, v215);
        v234 = 0;
        v21 = 7;
      }
      else
      {
        v21 = 0;
LABEL_46:
        v234 = 0;
      }
LABEL_100:
      if (pthread_mutex_lock(v236)
        || (v106 = *(_DWORD *)(v0 + 144), *(_DWORD *)(v0 + 144) = v106 + 1, !v106)
        && pthread_cond_broadcast((pthread_cond_t *)(v0 + 216))
        || (v107 = pthread_mutex_unlock(v236), v20 = 1, v17 = v21, v107))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractThreadProc", 1443, 2, 0, "SemRelease", v104, v105, v215);
        v20 = 1;
        v17 = v21;
      }
    }
  }
  MemBufferDestroy(v5);
  MemBufferDestroy((void **)v235);
  OArchiveFileStreamDestroy((unsigned int *)v16, v207, v208, v209, v210, v211, v212, v213);
  free(v237);
  return 0;
}

void extractBeginProc()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  void (*v14)(_QWORD, _DWORD *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(_QWORD, _QWORD *);
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unint64_t v28;
  int v29;
  unint64_t *v30;
  __int128 v31;
  __int128 v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  int v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  int v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  __int16 v52;
  int v53;
  size_t v54;
  size_t v55;
  char *v56;
  void *v57;
  unint64_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  uint64_t v62;
  size_t v63;
  size_t v64;
  uint64_t v65;
  int v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  unint64_t v71;
  unint64_t *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  int *v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int *v81;
  uint64_t v82;
  uint64_t v83;
  gid_t v84;
  uid_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  const char *v89;
  __int16 v90;
  int v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _QWORD *v102;
  stat v103;
  _OWORD v104[3];
  int v105[4];
  __int128 v106;
  unint64_t v107;
  _QWORD __dst[274];
  char v109[2048];
  uint64_t v110;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v11 = v0;
  v110 = *MEMORY[0x24BDAC8D0];
  bzero(v109, 0x800uLL);
  v107 = 0;
  *(_OWORD *)v105 = 0u;
  v106 = 0u;
  memset(v104, 0, sizeof(v104));
  bzero(__dst, 0x890uLL);
  v12 = (int *)(v11 + 1320);
  *(_OWORD *)(v11 + 1320) = xmmword_20643F2D0;
  v13 = *(_QWORD *)(v11 + 1368);
  *(_QWORD *)(v11 + 1352) = v13;
  *(_QWORD *)(v11 + 1368) = v13 + v2;
  *(_QWORD *)(v11 + 1336) = 0xFFFFFFFF00000000;
  if (!*(_DWORD *)(v11 + 1184))
  {
    if (v10[1] == 77)
    {
      *(_DWORD *)(v11 + 1332) = 1;
      v14 = *(void (**)(_QWORD, _DWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 112);
      if (v14)
        v14(*(_QWORD *)(*(_QWORD *)v11 + 144), v10, v8, v6, v4, v2);
      return;
    }
    memcpy(__dst, v10, sizeof(__dst));
    v18 = (unint64_t *)(v11 + 1504);
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
    *(_DWORD *)(v11 + 1324) = 0;
    v20 = *(_QWORD *)v11;
    v21 = *(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)v11 + 72);
    if (v21)
    {
      if ((*(_BYTE *)(v20 + 26) & 2) != 0)
      {
        LODWORD(__dst[0]) |= 0x40u;
        __dst[4] = v13;
      }
      LODWORD(v21) = v21(*(_QWORD *)(v20 + 144), __dst) == 0;
      *(_DWORD *)(v11 + 1324) = (_DWORD)v21;
    }
    v22 = 0;
    if (v6)
    {
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = (unint64_t *)(v8 + 8);
      v31 = 0uLL;
      v15 = 4411984;
      v16 = 5067842;
      v17 = 4803654;
      v32 = 0uLL;
      do
      {
        v33 = *(_DWORD *)(v30 - 1) & 0xDFDFDF;
        if (v33 <= 0x494C45)
        {
          if ((*(_DWORD *)(v30 - 1) & 0xDFDFDFu) > 0x434C52)
          {
            if (v33 == 4410451)
            {
              v29 |= 0x10u;
              v24 = *v30;
            }
            else if (v33 == 4411984)
            {
              v29 |= 0x80u;
              switch(*v30)
              {
                case 'A':
                  v27 = 1;
                  break;
                case 'B':
                  v27 = 2;
                  break;
                case 'C':
                  v27 = 3;
                  break;
                case 'D':
                  v27 = 4;
                  break;
                case 'E':
                  v27 = 5;
                  break;
                case 'F':
                  v27 = 6;
                  break;
                default:
                  v27 = -1;
                  break;
              }
            }
          }
          else if (v33 == 4410435)
          {
            v29 |= 8u;
            v23 = *v30;
          }
          else if (v33 == 4410440)
          {
            v29 |= 4u;
            v22 = *v30;
          }
        }
        else if ((*(_DWORD *)(v30 - 1) & 0xDFDFDFu) <= 0x4D5442)
        {
          if (v33 == 4803654)
          {
            v29 |= 0x100u;
            v28 = *v30;
          }
          else if (v33 == 5067842)
          {
            v29 |= 2u;
            v32 = *(_OWORD *)v30;
          }
        }
        else
        {
          switch(v33)
          {
            case 0x544641u:
              v29 |= 0x20u;
              v25 = *(_DWORD *)v30;
              break;
            case 0x524641u:
              v29 |= 0x40u;
              v26 = *(_DWORD *)v30;
              break;
            case 0x4D5443u:
              v29 |= 1u;
              v31 = *(_OWORD *)v30;
              break;
          }
        }
        v30 += 129;
        --v6;
      }
      while (v6);
      v107 = v28;
      DWORD2(v106) = v27;
      *(_QWORD *)&v106 = __PAIR64__(v26, v25);
      *(_QWORD *)v105 = v23;
      *(_QWORD *)&v105[2] = v24;
      *((_QWORD *)&v104[2] + 1) = v22;
      *(_OWORD *)((char *)&v104[1] + 8) = v32;
      *(_OWORD *)((char *)v104 + 8) = v31;
    }
    else
    {
      LOWORD(v29) = 0;
    }
    LOWORD(v104[0]) = v29;
    if (!(_DWORD)v21 && HIDWORD(__dst[0]) == 70)
    {
      if ((v29 & 4) != 0 && v22 != -1)
      {
        v34 = clusterLookup(v11 + 1456, v22, (char *)&__dst[18], (char *)&__dst[146], 0x400uLL, v15, v16, v17);
        if (v34 < 0)
        {
          v53 = *__error();
          v51 = "looking up cluster";
          v52 = 1589;
          goto LABEL_72;
        }
        if (v34)
        {
          HIDWORD(__dst[0]) = 120;
          *(_DWORD *)(v11 + 1336) = 1;
          v35 = __dst[8];
          v36 = (unint64_t *)(v11 + 1552);
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 + v35, v36));
        }
      }
      if (HIDWORD(__dst[0]) == 70)
      {
        if ((v104[0] & 8) != 0 && *(_QWORD *)v105 != -1)
        {
          v38 = clusterLookup(v11 + 1472, *(unint64_t *)v105, (char *)&__dst[18], (char *)&__dst[146], 0x400uLL, v15, v16, v17);
          if (v38 < 0)
          {
            v53 = *__error();
            v51 = "looking up cluster";
            v52 = 1611;
            goto LABEL_72;
          }
          if (v38)
          {
            HIDWORD(__dst[0]) = 121;
            *(_DWORD *)(v11 + 1336) = 1;
            v39 = __dst[8];
            v40 = (unint64_t *)(v11 + 1560);
            do
              v41 = __ldaxr(v40);
            while (__stlxr(v41 + v39, v40));
          }
        }
        if (HIDWORD(__dst[0]) == 70 && (v104[0] & 0x10) != 0 && *(_QWORD *)&v105[2] != -1 && *(_DWORD *)(v11 + 8))
        {
          v42 = clusterLookup(v11 + 1488, *(unint64_t *)&v105[2], (char *)&__dst[18], (char *)&__dst[146], 0x400uLL, v15, v16, v17);
          if (v42 < 0)
          {
            v53 = *__error();
            v51 = "looking up cluster";
            v52 = 1633;
            goto LABEL_72;
          }
          if (v42)
          {
            HIDWORD(__dst[0]) = 121;
            *(_DWORD *)(v11 + 1336) = 1;
            v43 = __dst[8];
            v44 = (unint64_t *)(v11 + 1568);
            do
              v45 = __ldaxr(v44);
            while (__stlxr(v45 + v43, v44));
          }
        }
      }
    }
    v46 = *(_QWORD *)(v11 + 1352);
    if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 1192)))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueInsert", 316, 2, 0, "pthread_mutex_lock", v47, v48, (char)v102);
LABEL_69:
      *v12 = -1;
      goto LABEL_70;
    }
    v54 = *(_QWORD *)(v11 + 1392);
    v55 = *(_QWORD *)(v11 + 1384);
    if (v54 >= v55)
    {
      if (v55)
        v55 += v55 >> 1;
      else
        v55 = 128;
      v56 = (char *)calloc(v55, 0x910uLL);
      if (!v56)
      {
        v77 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueInsert", 327, 2, *v77, "malloc", v78, v79, (char)v102);
        pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1192));
        goto LABEL_69;
      }
      v57 = v56;
      if (*(_QWORD *)(v11 + 1392))
      {
        v58 = 0;
        v59 = *(_QWORD *)(v11 + 1400);
        v60 = v56;
        do
        {
          memcpy(v60, (const void *)(*(_QWORD *)(v11 + 1416) + 2320 * v59), 0x910uLL);
          v61 = *(_QWORD *)(v11 + 1384);
          if (v59 + 1 < v61)
            v61 = 0;
          v59 = v59 + 1 - v61;
          ++v58;
          v60 += 2320;
        }
        while (v58 < *(_QWORD *)(v11 + 1392));
      }
      free(*(void **)(v11 + 1416));
      *(_QWORD *)(v11 + 1416) = v57;
      *(_QWORD *)(v11 + 1384) = v55;
      *(_QWORD *)(v11 + 1400) = 0;
      v54 = *(_QWORD *)(v11 + 1392);
    }
    if (v54)
    {
      v62 = *(_QWORD *)(v11 + 1400);
    }
    else
    {
      v62 = 0;
      *(_QWORD *)(v11 + 1400) = 0;
    }
    v63 = v62 + v54;
    if (v63 >= v55)
      v64 = v55;
    else
      v64 = 0;
    v65 = *(_QWORD *)(v11 + 1416) + 2320 * (v63 - v64);
    v66 = *(_DWORD *)(v11 + 1376);
    *(_DWORD *)(v11 + 1376) = v66 + 1;
    bzero((void *)v65, 0x910uLL);
    memcpy((void *)v65, __dst, 0x890uLL);
    v67 = v104[0];
    *(_OWORD *)(v65 + 2208) = v104[1];
    *(_OWORD *)(v65 + 2192) = v67;
    v68 = v104[2];
    v69 = *(_OWORD *)v105;
    v70 = v106;
    *(_QWORD *)(v65 + 2272) = v107;
    *(_OWORD *)(v65 + 2256) = v70;
    *(_OWORD *)(v65 + 2240) = v69;
    *(_OWORD *)(v65 + 2224) = v68;
    *(_DWORD *)(v65 + 2296) = v66;
    *(int64x2_t *)(v65 + 2304) = vdupq_n_s64(v46);
    *(_DWORD *)(v65 + 2300) = 0;
    v71 = *(_QWORD *)(v11 + 1392) + 1;
    *(_QWORD *)(v11 + 1392) = v71;
    if (v71 > *(_QWORD *)(v11 + 1408))
      *(_QWORD *)(v11 + 1408) = v71;
    if (**(int **)v11 >= 3)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] inserted: %s\n", v66, (const char *)&__dst[18]);
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1192));
    *v12 = v66;
    if ((v66 & 0x80000000) == 0)
    {
      if (*(_DWORD *)(v11 + 1324))
        return;
      v72 = (unint64_t *)(v11 + 1512);
      do
        v73 = __ldxr(v72);
      while (__stxr(v73 + 1, v72));
      if ((concatExtractPath(v109, 0x800uLL, (char *)(v11 + 12), (const char *)&__dst[18]) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1671, 2, 0, "invalid path: %s", v74, v75, (char)&__dst[18]);
        v76 = 0;
      }
      else
      {
        v76 = 1;
      }
      v80 = HIDWORD(__dst[0]);
      if (HIDWORD(__dst[0]) == 68)
      {
        if (**(int **)v11 >= 3)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] DIR mkdir: %s\n", *v12, (const char *)&__dst[18]);
        memset(&v103, 0, sizeof(v103));
        if (!lstat(v109, &v103) && (v103.st_mode & 0xF000) != 0x4000)
          unlink(v109);
        if (mkdir(v109, 0x1EDu) && *__error() != 17)
        {
          v81 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1687, 2, *v81, "%s", v82, v83, (char)v109);
          v76 = 0;
        }
        if ((__dst[0] & 6) != 0)
        {
          if ((__dst[0] & 4) != 0)
            v84 = HIDWORD(__dst[1]);
          else
            v84 = -1;
          if ((__dst[0] & 2) != 0)
            v85 = __dst[1];
          else
            v85 = -1;
          chown(v109, v85, v84);
        }
        v80 = HIDWORD(__dst[0]);
      }
      if (v80 == 70 && (__dst[0] & 0x200) == 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1701, 2, 0, "Regular file is missing DAT blob: %s", v74, v75, (char)&__dst[18]);
        v76 = 0;
      }
      if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 1056)))
      {
        v89 = "SharedArrayPop: pthread_mutex_lock failed\n";
        v90 = 91;
      }
      else
      {
        while (1)
        {
          v91 = *(_DWORD *)(v11 + 1040);
          if (v91)
            break;
          if (pthread_cond_wait((pthread_cond_t *)(v11 + 1120), (pthread_mutex_t *)(v11 + 1056)))
          {
            v89 = "SharedArrayPop: pthread_cond_wait failed\n";
            v90 = 94;
            goto LABEL_134;
          }
        }
        v92 = v91 - 1;
        *(_DWORD *)(v11 + 1040) = v92;
        *(_DWORD *)(v11 + 1340) = *(_DWORD *)(*(_QWORD *)(v11 + 1048) + 4 * v92);
        if (!pthread_mutex_unlock((pthread_mutex_t *)(v11 + 1056)))
        {
          v93 = *(_QWORD *)(v11 + 1176) + 304 * *(unsigned int *)(v11 + 1340);
          if (SemAcquire(v93 + 144))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1721, 2, 0, "SemAcquire", v94, v95, (char)v102);
            v76 = 0;
          }
          *(_DWORD *)(v11 + 1344) = 1;
          v103.st_dev = 1;
          if (writeToThread(v93, (char *)&v103, 4uLL))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1729, 2, 0, "writeToThread", v96, v97, (char)v102);
            v76 = 0;
          }
          if (writeToThread(v93, (char *)__dst, 0x890uLL))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1730, 2, 0, "writeToThread", v98, v99, (char)v102);
            v76 = 0;
          }
          if (writeToThread(v93, (char *)v104, 0x58uLL))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", 1731, 2, 0, "writeToThread", v100, v101, (char)v102);
            if (!writeToThread(v93, (char *)(v11 + 1320), 4uLL))
              goto LABEL_73;
          }
          else if (!writeToThread(v93, (char *)(v11 + 1320), 4uLL))
          {
            if (v76)
              return;
LABEL_73:
            *(_DWORD *)(v11 + 1184) = 1;
            return;
          }
          v51 = "writeToThread";
          v52 = 1732;
          goto LABEL_71;
        }
        v89 = "SharedArrayPop: pthread_mutex_unlock failed\n";
        v90 = 98;
      }
LABEL_134:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPop", v90, 0, v89, v86, v87, v88, (char)v102);
      v51 = "SharedArrayPop";
      v52 = 1710;
LABEL_71:
      v53 = 0;
LABEL_72:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBeginProc", v52, 2, v53, v51, v49, v50, (char)v102);
      goto LABEL_73;
    }
LABEL_70:
    v102 = &__dst[18];
    v51 = "extractInsertEntry: %s";
    v52 = 1657;
    goto LABEL_71;
  }
}

_DWORD *extractBlobProc(_DWORD *result, _DWORD *a2)
{
  _DWORD *v3;
  uint64_t (*v4)(_QWORD, _DWORD *);
  uint64_t v5;
  unsigned int v6;
  int v7;
  _DWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  int v13;

  v3 = result;
  if (result[333])
  {
    v4 = *(uint64_t (**)(_QWORD, _DWORD *))(*(_QWORD *)result + 120);
    if (v4)
      result = (_DWORD *)v4(*(_QWORD *)(*(_QWORD *)result + 144), a2);
  }
  if ((v3[330] & 0x80000000) == 0 && !v3[331])
  {
    v5 = *((_QWORD *)v3 + 147);
    v6 = v3[335];
    v3[332] = 0;
    v7 = *a2 & 0xDFDFDF;
    if (v7 == 4997953)
    {
      v9 = 4;
    }
    else if (v7 == 5521752)
    {
      v9 = 3;
    }
    else
    {
      v8 = v3 + 332;
      if (v7 != 5521732 || v3[334])
      {
LABEL_15:
        *v8 = 1;
        return result;
      }
      v9 = 2;
    }
    v13 = v9;
    result = (_DWORD *)writeToThread(v5 + 304 * v6, (char *)&v13, 4uLL);
    if (!(_DWORD)result)
      return result;
    result = (_DWORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractBlobProc", 1771, 2, 0, "writeToThread", v10, v11, v12);
    v8 = v3 + 296;
    goto LABEL_15;
  }
  return result;
}

uint64_t extractPayloadProc(uint64_t result, char *a2, size_t a3)
{
  uint64_t v5;
  uint64_t (*v6)(_QWORD, char *, size_t);
  uint64_t v7;
  uint64_t v8;
  char v9;

  v5 = result;
  *(_QWORD *)(result + 1368) += a3;
  if (*(_DWORD *)(result + 1332))
  {
    v6 = *(uint64_t (**)(_QWORD, char *, size_t))(*(_QWORD *)result + 128);
    if (v6)
      result = v6(*(_QWORD *)(*(_QWORD *)result + 144), a2, a3);
  }
  if ((*(_DWORD *)(v5 + 1320) & 0x80000000) == 0 && !*(_DWORD *)(v5 + 1324) && !*(_DWORD *)(v5 + 1328))
  {
    result = writeToThread(*(_QWORD *)(v5 + 1176) + 304 * *(unsigned int *)(v5 + 1340), a2, a3);
    if ((_DWORD)result)
    {
      result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractPayloadProc", 1800, 2, 0, "extractWriteToThread", v7, v8, v9);
      *(_DWORD *)(v5 + 1184) = 1;
    }
  }
  return result;
}

uint64_t extractEndProc(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD);
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  const char *v7;
  __int16 v8;
  uint64_t v9;
  int v10;
  char v11;
  int v12;

  v1 = result;
  *(_QWORD *)(result + 1360) = *(_QWORD *)(result + 1368);
  if (*(_DWORD *)(result + 1332))
  {
    v2 = *(uint64_t (**)(_QWORD))(*(_QWORD *)result + 136);
    if (v2)
      result = v2(*(_QWORD *)(*(_QWORD *)result + 144));
  }
  if ((*(_DWORD *)(v1 + 1320) & 0x80000000) == 0)
  {
    if (*(_DWORD *)(v1 + 1324))
    {
      result = inFlightQueueRetire();
      if ((result & 0x80000000) == 0)
      {
LABEL_7:
        *(_DWORD *)(v1 + 1320) = -1;
        *(_DWORD *)(v1 + 1340) = -1;
        return result;
      }
      v7 = "Updating entry state";
      v8 = 1851;
    }
    else
    {
      v5 = *(_QWORD *)(v1 + 1176);
      v6 = *(_DWORD *)(v1 + 1340);
      v12 = 5;
      if (writeToThread(v5 + 304 * v6, (char *)&v12, 4uLL))
      {
        v7 = "extractWriteToThread";
        v8 = 1840;
      }
      else if (writeToThread(v5 + 304 * v6, (char *)(v1 + 1360), 8uLL))
      {
        v7 = "extractWriteToThread";
        v8 = 1841;
      }
      else
      {
        *(_DWORD *)(v1 + 1344) = 0;
        if (!pthread_mutex_lock((pthread_mutex_t *)(v5 + 304 * v6 + 32)))
        {
          v9 = v5 + 304 * v6;
          v10 = *(_DWORD *)(v9 + 24);
          *(_DWORD *)(v9 + 24) = v10 + 1;
          if (v10 || !pthread_cond_broadcast((pthread_cond_t *)(v5 + 304 * v6 + 96)))
          {
            result = pthread_mutex_unlock((pthread_mutex_t *)(v5 + 304 * v6 + 32));
            if (!(_DWORD)result)
              goto LABEL_7;
          }
        }
        v7 = "SemRelease";
        v8 = 1846;
      }
    }
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"extractEndProc", v8, 2, 0, v7, v3, v4, v11);
    *(_DWORD *)(v1 + 1184) = 1;
  }
  return result;
}

uint64_t extractPaddingProc(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 1368) += a3;
  return result;
}

uint64_t SharedArrayPush_0(unsigned int *a1, int a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  char v14;

  v4 = (pthread_mutex_t *)(a1 + 4);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 4)))
  {
    v8 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v9 = 117;
  }
  else
  {
    v10 = *a1;
    v11 = a1[1];
    v12 = v10;
    if (v10 < v11)
    {
      *(_DWORD *)(*((_QWORD *)a1 + 1) + 4 * v10) = a2;
      v12 = *a1;
    }
    *a1 = v12 + 1;
    if (v12 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 20)))
    {
      if (pthread_mutex_unlock(v4))
      {
        v8 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v9 = 124;
      }
      else
      {
        if (v10 < v11)
          return 0;
        v8 = "SharedArrayPush: stack is full\n";
        v9 = 125;
      }
    }
    else
    {
      v8 = "SharedArrayPush: pthread_cond_broadcast failed\n";
      v9 = 122;
    }
  }
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/../ParallelCompression/../Common/SharedArray.h", (uint64_t)"SharedArrayPush", v9, 0, v8, v5, v6, v7, v14);
  return 0xFFFFFFFFLL;
}

uint64_t inFlightQueueRetire()
{
  uint64_t v0;
  unsigned int v1;
  unsigned int v2;
  int v3;
  int v4;
  _QWORD *v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  const char *v14;
  const char *v15;
  __int16 v16;
  int v17;
  char *v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _BOOL4 v38;
  uint64_t v39;
  BOOL v40;
  uint64_t v43;
  int v44;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  _BYTE *v53;
  uint64_t v54;
  uint64_t v55;
  size_t v56;
  void *v57;
  unint64_t v58;
  __int16 v59;
  int v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  char v64;
  char v65;
  char __src[2610];
  char v67[2048];
  uint64_t v68;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v5 = (_QWORD *)v0;
  v68 = *MEMORY[0x24BDAC8D0];
  v6 = (pthread_mutex_t *)(v0 + 1192);
  if (pthread_mutex_lock((pthread_mutex_t *)(v0 + 1192)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 467, 2, 0, "pthread_mutex_lock", v7, v8, v64);
    return 0xFFFFFFFFLL;
  }
  v10 = inFlightQueueEntry(v5, v4);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 471, 2, 0, "couldn't locate entry [%d] in queue", v11, v12, v4);
    goto LABEL_12;
  }
  v13 = *(_DWORD *)(v10 + 2300);
  switch(v13)
  {
    case 0u:
      *(_DWORD *)(v10 + 2300) = v2;
      v13 = v2;
      goto LABEL_6;
    case 7u:
LABEL_6:
      if (*(int *)*v5 >= 3)
      {
        if (v13 > 7)
          v14 = "???";
        else
          v14 = off_24BF0B910[v13];
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] retiring %s: %s\n", v4, v14, (const char *)(v10 + 144));
      }
      if (v5[174])
      {
        v65 = v4;
        v18 = (char *)v5 + 12;
        v19 = v5 + 190;
        v20 = v5[175];
        v17 = 1;
        while (1)
        {
          v21 = v5[177];
          v22 = v21 + 2320 * v20;
          v23 = (int *)(v22 + 2300);
          v24 = *(_DWORD *)(v22 + 2300);
          if (v24 != 1)
          {
            if (!v24)
              goto LABEL_13;
            goto LABEL_22;
          }
          v28 = *(_DWORD *)(v22 + 4);
          if (v28 == 72)
          {
            bzero(__src, 0x800uLL);
            bzero(v67, 0x800uLL);
            if ((concatExtractPath(__src, 0x800uLL, v18, (const char *)(v22 + 144)) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 497, 2, 0, "invalid path: %s", v29, v30, v22 - 112);
              goto LABEL_12;
            }
            if (concatPath(v67, 0x800uLL, v18, (const char *)(v22 + 1168)))
            {
              v15 = "concatPath";
              v16 = 498;
LABEL_11:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", v16, 2, 0, v15, v11, v12, v64);
              goto LABEL_12;
            }
            if (*(int *)*v5 >= 3)
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] HLINK (legacy) %s -> %s\n", *(_DWORD *)(v21 + 2320 * v20 + 2296), (const char *)(v22 + 144), v67);
            unlink(__src);
            if (link(v67, __src))
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 512, 2, "%s", v31, v11, v12, (char)__src);
              v24 = 7;
            }
            else
            {
              v24 = 3;
            }
            *v23 = v24;
            goto LABEL_22;
          }
          if (v28 == 120)
            break;
          v35 = *(_DWORD *)(v22 + 4);
          if (v35 == 121)
          {
            bzero(__src, 0x800uLL);
            bzero(v67, 0x800uLL);
            if ((concatExtractPath(__src, 0x800uLL, v18, (const char *)(v22 + 144)) & 0x80000000) != 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 551, 2, 0, "invalid path: %s", v36, v37, v22 - 112);
              goto LABEL_12;
            }
            if (concatPath(v67, 0x800uLL, v18, (const char *)(v22 + 1168)))
            {
              v15 = "concatPath";
              v16 = 552;
              goto LABEL_11;
            }
            if (*(int *)*v5 >= 3)
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] CLONE %s -> %s\n", *(_DWORD *)(v21 + 2320 * v20 + 2296), (const char *)(v22 + 144), (const char *)(v22 + 1168));
            unlink(__src);
            if (clonefile(v67, __src, 0))
            {
              v18 = (char *)v5 + 12;
              if ((copyFileSegment(v67, 0, 0xFFFFFFFFFFFFFFFFLL, __src) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 563, 2, 0, "cloning file, falling back to copy, failed: %s", v11, v12, (char)__src);
                v17 = 0;
              }
            }
            else
            {
              v18 = (char *)v5 + 12;
            }
            *v23 = 3;
            v24 = 3;
LABEL_22:
            if (v24 == 3)
              goto LABEL_23;
            if ((v24 & 0xFFFFFFFC) == 4)
            {
              v27 = 1;
              goto LABEL_77;
            }
            goto LABEL_60;
          }
          if (v35 == 68)
          {
            v38 = (*(_DWORD *)v22 & 8) != 0 && *(_DWORD *)(v22 + 16) != 0;
            if ((*(_DWORD *)v22 & 0x10) != 0 && (~*(_DWORD *)(v22 + 20) & 0x1ED) != 0)
              v38 = 1;
            v39 = v21 + 2320 * v20;
            if (*(_QWORD *)(v39 + 2288))
              v40 = 0;
            else
              v40 = (*(_DWORD *)v22 & 0x100) == 0;
            if (v40 && *(_QWORD *)(v39 + 2280) == 0 && !v38)
            {
              *v23 = 3;
LABEL_23:
              if ((setEntryAttributes((char *)v5, v21 + 2320 * v20) & 0x80000000) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 590, 2, 0, "setEntryAttributes failed", v25, v26, v64);
                v27 = 1;
                v24 = 7;
              }
              else
              {
                v27 = 1;
                v24 = 4;
              }
            }
            else
            {
              v27 = 0;
              v24 = 6;
            }
            *v23 = v24;
LABEL_77:
            v43 = *v5;
            if (*(_QWORD *)(*v5 + 80))
            {
              v44 = *(_DWORD *)(v43 + 24);
              if ((v44 & 8) != 0)
              {
                *(_DWORD *)v22 |= 0x20u;
                *(_DWORD *)(v22 + 24) = v24 == 7;
                v43 = *v5;
                v44 = *(_DWORD *)(*v5 + 24);
              }
              if ((v44 & 0x20000) != 0)
              {
                *(_DWORD *)v22 |= 0x40u;
                *(_QWORD *)(v22 + 32) = *(_QWORD *)(v21 + 2320 * v20 + 2312);
                v43 = *v5;
              }
              (*(void (**)(_QWORD, uint64_t))(v43 + 80))(*(_QWORD *)(v43 + 144), v21 + 2320 * v20);
              v24 = *v23;
            }
            if (v24 == 7)
              ++v5[181];
            if (*(int *)*v5 < 2 || v24 == 5)
            {
              if ((v27 & 1) == 0)
                goto LABEL_96;
            }
            else
            {
              if (v24 == 7)
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s (with errors)\n");
              else
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n");
              if ((v27 & 1) == 0)
              {
LABEL_96:
                v47 = v5[179];
                v48 = v5[178];
                v49 = (void *)v5[180];
                if (v47 < v48)
                  goto LABEL_101;
                v50 = v48 + (v48 >> 1);
                v40 = v48 == 0;
                v51 = 16;
                if (!v40)
                  v51 = v50;
                v5[178] = v51;
                v52 = (char *)reallocf(v49, 16 * v51);
                v5[180] = v52;
                if (v52)
                {
                  v49 = v52;
                  v47 = v5[179];
                  bzero(&v52[16 * v47], 16 * (v5[178] - v47));
LABEL_101:
                  v53 = pc_zero_coder_encode(__src, 2610, (char *)v22, 2320);
                  *((_QWORD *)v49 + 2 * v47 + 1) = v53;
                  if (v53)
                  {
                    v56 = (size_t)v53;
                    v57 = malloc((size_t)v53);
                    *((_QWORD *)v49 + 2 * v47) = v57;
                    if (v57)
                    {
                      memcpy(v57, __src, v56);
                      ++v5[179];
                      do
                        v58 = __ldxr(v19);
                      while (__stxr(v58 + 1, v19));
                      goto LABEL_110;
                    }
                    v60 = *__error();
                    v59 = 652;
                    v61 = "Allocating deferred entry";
                  }
                  else
                  {
                    v59 = 648;
                    v60 = 0;
                    v61 = "zero_coder_encode";
                  }
                }
                else
                {
                  v60 = *__error();
                  v59 = 637;
                  v61 = "Allocating deferred stack";
                }
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", v59, 2, v60, v61, v54, v55, v64);
                v17 = 0;
LABEL_110:
                v18 = (char *)v5 + 12;
                goto LABEL_111;
              }
            }
            v46 = v21 + 2320 * v20;
            MemBufferDestroy(*(void ***)(v46 + 2280));
            MemBufferDestroy(*(void ***)(v46 + 2288));
            goto LABEL_110;
          }
LABEL_60:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 599, 2, 0, "Invalid entry state [%d] %s: %s", v11, v12, v65);
          v17 = 0;
LABEL_111:
          bzero((void *)v22, 0x910uLL);
          v62 = v5[175];
          if (v62 + 1 == v5[173])
            v20 = 0;
          else
            v20 = v62 + 1;
          v5[175] = v20;
          v63 = v5[174] - 1;
          v5[174] = v63;
          if (!v63)
            goto LABEL_13;
        }
        bzero(__src, 0x800uLL);
        bzero(v67, 0x800uLL);
        if ((concatExtractPath(__src, 0x800uLL, v18, (const char *)(v22 + 144)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 524, 2, 0, "invalid path: %s", v32, v33, v22 - 112);
LABEL_12:
          v17 = 0;
          goto LABEL_13;
        }
        if (concatPath(v67, 0x800uLL, v18, (const char *)(v22 + 1168)))
        {
          v15 = "concatPath";
          v16 = 525;
          goto LABEL_11;
        }
        if (*(int *)*v5 >= 3)
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "[%7d] HLINK %s -> %s\n", *(_DWORD *)(v21 + 2320 * v20 + 2296), (const char *)(v22 + 144), (const char *)(v22 + 1168));
        unlink(__src);
        if (link(v67, __src))
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Extract.c", (uint64_t)"inFlightQueueRetire", 539, 2, "%s", v34, v11, v12, (char)__src);
          v24 = 7;
        }
        else
        {
          v24 = 3;
        }
        v18 = (char *)v5 + 12;
        *v23 = v24;
        goto LABEL_22;
      }
      v17 = 1;
LABEL_13:
      pthread_mutex_unlock(v6);
      if (v17)
        return 0;
      else
        return 0xFFFFFFFFLL;
    default:
      v64 = v4;
      v15 = "Invalid entry state [%d] %s: %s";
      v16 = 476;
      goto LABEL_11;
  }
}

unsigned int *ThreadPoolCreate(unsigned int a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v6;
  unsigned int *v7;
  void *v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;

  v6 = (unsigned int *)calloc(1uLL, 0xA8uLL);
  v7 = v6;
  if (v6)
  {
    *v6 = a1;
    v8 = calloc(a1, 0xA8uLL);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = *v7;
      v7[8] = 0;
      v7[9] = v9;
      v10 = calloc(v9, 4uLL);
      *((_QWORD *)v7 + 5) = v10;
      if (v10)
      {
        if (pthread_mutex_init((pthread_mutex_t *)(v7 + 12), 0))
        {
          v14 = "SharedArrayInit: pthread_mutex_init failed\n";
          v15 = 56;
        }
        else
        {
          if (!pthread_cond_init((pthread_cond_t *)(v7 + 28), 0))
          {
            v7[4] = -1;
            if (!*v7)
              return v7;
            v22 = 0;
            v23 = 0;
            while (1)
            {
              v24 = *((_QWORD *)v7 + 1);
              v25 = v24 + v22;
              *(_QWORD *)(v25 + 16) = v7;
              *(_DWORD *)(v25 + 8) = v23;
              *(_QWORD *)(v25 + 24) = *(_QWORD *)(a2 + 8 * v23);
              *(_QWORD *)(v25 + 32) = a3;
              *(_DWORD *)(v25 + 40) = 0;
              if (pthread_mutex_init((pthread_mutex_t *)(v24 + v22 + 48), 0)
                || pthread_cond_init((pthread_cond_t *)(v25 + 112), 0))
              {
                v19 = "SemInit";
                v20 = 115;
                goto LABEL_12;
              }
              if ((createThread((pthread_t *)(v24 + v22), (uint64_t)threadPoolWorkerThreadProc, v24 + v22, 0) & 0x80000000) != 0)
                break;
              ++v23;
              v22 += 168;
              if (v23 >= *v7)
                return v7;
            }
            v19 = "Thread creation";
            v20 = 116;
            goto LABEL_12;
          }
          v14 = "SharedArrayInit: pthread_cond_init failed\n";
          v15 = 57;
        }
      }
      else
      {
        v14 = "SharedArrayInit: malloc failed\n";
        v15 = 55;
      }
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayInit", v15, 0, v14, v11, v12, v13, v26);
      v19 = "SharedArrayInit";
      v20 = 104;
LABEL_12:
      v16 = 0;
      goto LABEL_13;
    }
    v16 = *__error();
    v19 = "malloc";
    v20 = 103;
  }
  else
  {
    v16 = *__error();
    v19 = "malloc";
    v20 = 98;
  }
LABEL_13:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolCreate", v20, 90, v16, v19, v17, v18, v26);
  ThreadPoolDestroy((uint64_t)v7);
  return 0;
}

uint64_t threadPoolWorkerThreadProc(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  __int16 v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int *v22;
  unsigned int v23;
  char v25;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 8);
  if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 48)))
  {
LABEL_2:
    v7 = "SharedArrayPush: pthread_mutex_lock failed\n";
    v8 = 117;
  }
  else
  {
    v13 = (unsigned int *)(v2 + 160);
    while (1)
    {
      v14 = *(unsigned int *)(v2 + 32);
      v15 = *(_DWORD *)(v2 + 36);
      v16 = v14;
      if (v14 < v15)
      {
        *(_DWORD *)(*(_QWORD *)(v2 + 40) + 4 * v14) = v3;
        v16 = *(_DWORD *)(v2 + 32);
      }
      *(_DWORD *)(v2 + 32) = v16 + 1;
      if (!v16)
      {
        if (pthread_cond_broadcast((pthread_cond_t *)(v2 + 112)))
          break;
      }
      if (pthread_mutex_unlock((pthread_mutex_t *)(v2 + 48)))
      {
        v7 = "SharedArrayPush: pthread_mutex_unlock failed\n";
        v8 = 124;
        goto LABEL_3;
      }
      if (v14 >= v15)
      {
        v7 = "SharedArrayPush: stack is full\n";
        v8 = 125;
        goto LABEL_3;
      }
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 48)))
        goto LABEL_23;
      while (1)
      {
        v17 = *(_DWORD *)(a1 + 40);
        if (v17 > 0)
          break;
        if (pthread_cond_wait((pthread_cond_t *)(a1 + 112), (pthread_mutex_t *)(a1 + 48)))
          goto LABEL_23;
      }
      *(_DWORD *)(a1 + 40) = v17 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48)))
      {
LABEL_23:
        v11 = "SemAcquire";
        v12 = 59;
        goto LABEL_24;
      }
      v18 = *(_QWORD *)(a1 + 160);
      if (v18 != -2)
      {
        if (v18 < 0)
          return a1;
        if (((*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 24)) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"threadPoolWorkerThreadProc", 72, 90, 0, "worker proc reported an error", v19, v20, v25);
          do
            v21 = __ldxr(v13);
          while (__stxr(v21 + 1, v13));
        }
      }
      v3 = *(_DWORD *)(a1 + 8);
      if (pthread_mutex_lock((pthread_mutex_t *)(v2 + 48)))
        goto LABEL_2;
    }
    v7 = "SharedArrayPush: pthread_cond_broadcast failed\n";
    v8 = 122;
  }
LABEL_3:
  pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPush", v8, 0, v7, v4, v5, v6, v25);
  v11 = "SharedArrayPush";
  v12 = 56;
LABEL_24:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"threadPoolWorkerThreadProc", v12, 90, 0, v11, v9, v10, v25);
  v22 = (unsigned int *)(v2 + 160);
  do
    v23 = __ldxr(v22);
  while (__stxr(v23 + 1, v22));
  return a1;
}

uint64_t ThreadPoolDestroy(uint64_t result)
{
  unsigned int *v1;
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  pthread_cond_t *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  char v35;
  char v36;

  if (result)
  {
    v1 = (unsigned int *)result;
    v2 = *(uint64_t **)(result + 8);
    if (v2)
    {
      v3 = *(unsigned int *)result;
      if (!(_DWORD)v3)
      {
        v7 = 1;
        goto LABEL_37;
      }
      v4 = 0;
      do
      {
        v5 = *v2;
        v2 += 21;
        if (v5)
          ++v4;
        --v3;
      }
      while (v3);
      if (v4)
      {
        v6 = 0;
        v7 = 1;
        while (1)
        {
          if (pthread_mutex_lock((pthread_mutex_t *)(v1 + 12)))
          {
            v11 = 91;
            v12 = "SharedArrayPop: pthread_mutex_lock failed\n";
LABEL_15:
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v11, 0, v12, v8, v9, v10, v35);
            v16 = -1;
          }
          else
          {
            while (1)
            {
              v13 = v1[8];
              if (v13)
                break;
              if (pthread_cond_wait((pthread_cond_t *)(v1 + 28), (pthread_mutex_t *)(v1 + 12)))
              {
                v11 = 94;
                v12 = "SharedArrayPop: pthread_cond_wait failed\n";
                goto LABEL_15;
              }
            }
            v23 = v13 - 1;
            v1[8] = v23;
            v16 = *(_DWORD *)(*((_QWORD *)v1 + 5) + 4 * v23);
            if (!pthread_mutex_unlock((pthread_mutex_t *)(v1 + 12)))
              goto LABEL_17;
            pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", 98, 0, "SharedArrayPop: pthread_mutex_unlock failed\n", v24, v25, v26, v35);
          }
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 147, 90, 0, "SharedArrayPop", v14, v15, v36);
          v7 = 0;
LABEL_17:
          v17 = *((_QWORD *)v1 + 1);
          v18 = v17 + 168 * v16;
          *(_QWORD *)(v18 + 160) = -1;
          if (pthread_mutex_lock((pthread_mutex_t *)(v18 + 48))
            || (v21 = v17 + 168 * v16, v22 = *(_DWORD *)(v21 + 40), *(_DWORD *)(v21 + 40) = v22 + 1, !v22)
            && pthread_cond_broadcast((pthread_cond_t *)(v17 + 168 * v16 + 112))
            || pthread_mutex_unlock((pthread_mutex_t *)(v18 + 48)))
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 155, 90, 0, "SemRelease", v19, v20, v35);
            v7 = 0;
          }
          if ((joinThread(*(_opaque_pthread_t **)v18) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 156, 90, 0, "joinThread", v27, v28, v35);
            v7 = 0;
          }
          *(_QWORD *)v18 = 0;
          if (++v6 == v4)
          {
            if (!*v1)
              goto LABEL_37;
            goto LABEL_33;
          }
        }
      }
      v7 = 1;
LABEL_33:
      v29 = 0;
      v30 = 112;
      do
      {
        v31 = (pthread_cond_t *)(*((_QWORD *)v1 + 1) + v30);
        if (!pthread_mutex_destroy((pthread_mutex_t *)&v31[-2].__opaque[24]))
          pthread_cond_destroy(v31);
        ++v29;
        v30 += 168;
      }
      while (v29 < *v1);
LABEL_37:
      free(*((void **)v1 + 1));
      *((_QWORD *)v1 + 1) = 0;
    }
    else
    {
      v7 = 1;
    }
    if (!pthread_mutex_destroy((pthread_mutex_t *)(v1 + 12)) && !pthread_cond_destroy((pthread_cond_t *)(v1 + 28)))
      free(*((void **)v1 + 5));
    v34 = atomic_load(v1 + 40);
    if (v34 >= 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolDestroy", 171, 90, 0, "Threads reported errors", v32, v33, v35);
      v7 = 0;
    }
    free(v1);
    if (v7)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t ThreadPoolGetWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  pthread_mutex_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  char v21;

  if (*(_DWORD *)(a1 + 16) != -1)
  {
    v8 = "Missing call to RunWorker before GetWorker";
    v9 = 182;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolGetWorker", v9, 90, 0, v8, a7, a8, v21);
    return 0;
  }
  v11 = (pthread_mutex_t *)(a1 + 48);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 48)))
  {
    v15 = "SharedArrayPop: pthread_mutex_lock failed\n";
    v16 = 91;
LABEL_10:
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v16, 0, v15, v12, v13, v14, v21);
    v8 = "SharedArrayPop failed";
    v9 = 186;
    goto LABEL_11;
  }
  while (1)
  {
    v17 = *(_DWORD *)(a1 + 32);
    if (v17)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 112), v11))
    {
      v15 = "SharedArrayPop: pthread_cond_wait failed\n";
      v16 = 94;
      goto LABEL_10;
    }
  }
  v18 = v17 - 1;
  *(_DWORD *)(a1 + 32) = v18;
  v19 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v18);
  if (pthread_mutex_unlock(v11))
  {
    v15 = "SharedArrayPop: pthread_mutex_unlock failed\n";
    v16 = 98;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 16) = v19;
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 168 * v19 + 24);
}

uint64_t ThreadPoolRunWorker(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  pthread_mutex_t *v12;
  uint64_t v13;
  int v14;
  uint64_t result;
  const char *v16;
  __int16 v17;
  char v18;

  v8 = *(_DWORD *)(a1 + 16);
  if (v8 == -1)
  {
    v16 = "Missing call to GetWorker before RunWorker";
    v17 = 199;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolRunWorker", v17, 90, 0, v16, a7, a8, v18);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 16) = -1;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v10 + 1;
  v11 = v9 + 168 * v8;
  *(_QWORD *)(v11 + 160) = v10;
  v12 = (pthread_mutex_t *)(v11 + 48);
  if (pthread_mutex_lock((pthread_mutex_t *)(v11 + 48))
    || (v13 = v9 + 168 * v8, v14 = *(_DWORD *)(v13 + 40), *(_DWORD *)(v13 + 40) = v14 + 1, !v14)
    && pthread_cond_broadcast((pthread_cond_t *)(v9 + 168 * v8 + 112))
    || (result = pthread_mutex_unlock(v12), (_DWORD)result))
  {
    v16 = "SemRelease failed";
    v17 = 211;
    goto LABEL_9;
  }
  return result;
}

uint64_t ThreadPoolSync(unsigned int *a1)
{
  uint64_t v1;
  int v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v24;
  char v25;

  v1 = *a1;
  if (!(_DWORD)v1)
  {
    v7 = 1;
    goto LABEL_30;
  }
  v3 = 0;
  v4 = (uint64_t *)*((_QWORD *)a1 + 1);
  do
  {
    v5 = *v4;
    v4 += 21;
    if (v5)
      ++v3;
    --v1;
  }
  while (v1);
  if (v3)
  {
    v6 = 0;
    v7 = 1;
    while (1)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)))
      {
        v11 = 91;
        v12 = "SharedArrayPop: pthread_mutex_lock failed\n";
      }
      else
      {
        while (1)
        {
          v13 = a1[8];
          if (v13)
            break;
          if (pthread_cond_wait((pthread_cond_t *)(a1 + 28), (pthread_mutex_t *)(a1 + 12)))
          {
            v11 = 94;
            v12 = "SharedArrayPop: pthread_cond_wait failed\n";
            goto LABEL_15;
          }
        }
        a1[8] = v13 - 1;
        if (!pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12)))
          goto LABEL_16;
        v11 = 98;
        v12 = "SharedArrayPop: pthread_mutex_unlock failed\n";
      }
LABEL_15:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/SharedArray.h", (uint64_t)"SharedArrayPop", v11, 0, v12, v8, v9, v10, v24);
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolSync", 231, 90, 0, "SharedArrayPop", v14, v15, v25);
      v7 = 0;
LABEL_16:
      if (++v6 == v3)
      {
        if (!*a1)
          goto LABEL_30;
        goto LABEL_21;
      }
    }
  }
  v7 = 1;
LABEL_21:
  v16 = 0;
  v17 = 0;
  do
  {
    v18 = *((_QWORD *)a1 + 1);
    if (*(_QWORD *)(v18 + v16))
    {
      if ((v19 = v18 + v16, *(_QWORD *)(v18 + v16 + 160) = -2,
                             pthread_mutex_lock((pthread_mutex_t *)(v18 + v16 + 48)))
        || (v22 = *(_DWORD *)(v19 + 40), *(_DWORD *)(v19 + 40) = v22 + 1, !v22)
        && pthread_cond_broadcast((pthread_cond_t *)(v18 + v16 + 112))
        || pthread_mutex_unlock((pthread_mutex_t *)(v18 + v16 + 48)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ThreadPool.c", (uint64_t)"ThreadPoolSync", 240, 90, 0, "SemRelease", v20, v21, v24);
        v7 = 0;
      }
    }
    ++v17;
    v16 += 168;
  }
  while (v17 < *a1);
LABEL_30:
  if (v7)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t RawImageGetPatchInfo(__int128 *a1, unint64_t a2, void *__s, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  int v10;
  BOOL v12;
  uint64_t result;
  __int128 v15;
  __int128 v16;

  if (a2 <= 0x2D)
  {
    v8 = "invalid patch size";
    v9 = 488;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImageGetPatchInfo", v9, 135, 0, v8, a7, a8, v15);
    return 0xFFFFFFFFLL;
  }
  v15 = *a1;
  v16 = *(__int128 *)((char *)a1 + 30);
  v10 = (unsigned __int16)*((_QWORD *)a1 + 1);
  v12 = *(_QWORD *)a1 != 0x3031464649444952 || v10 == 0 || (unint64_t)((unsigned __int128)a1[1] >> 16) == 0;
  if (v12 || (unint64_t)v16 < 0x2F || (unint64_t)v16 >= *((_QWORD *)&v16 + 1))
  {
    v8 = "bad header";
    v9 = 497;
    goto LABEL_17;
  }
  if (__s)
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
  *((_DWORD *)__s + 2) = v10 == 1;
  result = 0;
  if ((BYTE10(v15) & 1) != 0)
    *((_DWORD *)__s + 3) = 1;
  return result;
}

uint64_t RawImagePatchInternal(uint64_t a1, AAByteStream_impl *a2)
{
  int DefaultNThreads;
  int v5;
  AAByteStream_impl *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  int v17;
  unsigned int **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  __int128 *v28;
  _QWORD *v29;
  char *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  size_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  FILE **v51;
  const char *v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  int v56;
  const char *v57;
  const char *v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  AAByteStream_impl *v62;
  uint64_t v63;
  uint64_t v64;
  AAByteStream_impl *v65;
  uint64_t v66;
  AAFlagSet v67;
  uint64_t v68;
  uint64_t v69;
  AAByteStream v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char v75;
  const char *v76;
  __int16 v77;
  int v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  _OWORD *v86;
  __int128 v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  __int16 v105;
  __int128 *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  char *v111;
  uint64_t v112;
  _QWORD *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  BOOL v118;
  BOOL v119;
  const char *v121;
  __int16 v122;
  uint64_t **v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t *v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _BYTE *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  char *v161;
  uint64_t v162;
  uint64_t v163;
  _BYTE *v164;
  uint64_t v165;
  _BYTE *v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unint64_t v171;
  uint64_t v172;
  uint64_t v173;
  _BYTE *v174;
  uint64_t v175;
  uint64_t v176;
  _BYTE *v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  unint64_t v182;
  int v183;
  uint64_t *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  const char *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  int *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  const char *v208;
  const char *v209;
  int v210;
  int v211;
  FILE *v212;
  const char *v213;
  size_t v214;
  uint64_t v215;
  unint64_t *v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  const char *v220;
  __int16 v221;
  int v222;
  unint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  const char *v240;
  __int16 v241;
  const char *v242;
  __int16 v243;
  AAByteStream_impl *v244;
  BOOL v245;
  BOOL v246;
  BOOL v247;
  unint64_t v248;
  __int16 v249;
  char v250;
  char v251;
  char v252;
  uint64_t v253;
  uint64_t v254;
  unsigned int v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  unint64_t v261;
  unint64_t v262;
  unint64_t v263;
  unint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  int v268;
  int v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  AAByteStream compressed_stream;
  uint64_t **s;
  unsigned int **v275;
  void *v276;
  _BYTE *v277;
  unint64_t v278;
  AAByteStream_impl *v279;
  AAByteStream_impl *v280;
  uint64_t v281;
  AAByteStream_impl *v282;
  int v283;
  AAByteStream_impl *v284;
  uint64_t v285;
  int v286;
  uint64_t *v287;
  _QWORD *v288;
  unsigned int **v289;
  unsigned int **v290;
  uint64_t v291;
  AAByteStream_impl *v292;

  v5 = *(_DWORD *)(a1 + 40);
  DefaultNThreads = *(_DWORD *)(a1 + 44);
  if (!DefaultNThreads)
  {
    DefaultNThreads = getDefaultNThreads();
    *(_DWORD *)(a1 + 44) = DefaultNThreads;
  }
  if (DefaultNThreads >= 3)
    *(_DWORD *)(a1 + 44) = 2;
  if (!*(_QWORD *)(a1 + 16))
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 24);
  v6 = a2;
  if (!a2)
  {
    v18 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 32), 0, 0);
    v6 = (AAByteStream_impl *)v18;
    if (!v18)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 542, 135, 0, "AAFileStreamOpenWithPath", v19, v20, v250);
      v31 = 0;
      v30 = 0;
      v29 = 0;
      v28 = 0;
      v27 = 0;
      goto LABEL_30;
    }
    if ((v5 & 1) != 0 && (io_set_nocache(v18) & 0x80000000) != 0)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 543, 135, "io_set_nocache %s", v21, v22, v23, *(_QWORD *)(a1 + 32));
  }
  v7 = malloc(0x2EuLL);
  v10 = v7;
  if (!v7)
  {
    v17 = *__error();
    v15 = "aaMalloc";
    v16 = 108;
    goto LABEL_24;
  }
  if (!*((_QWORD *)v6 + 2))
    goto LABEL_17;
  v11 = 0;
  v12 = 46;
  v13 = v7;
  do
  {
    v14 = (*((uint64_t (**)(_QWORD, _QWORD *, uint64_t))v6 + 2))(*(_QWORD *)v6, v13, v12);
    if (v14 < 0)
      goto LABEL_17;
    if (!v14)
      break;
    v13 = (_QWORD *)((char *)v13 + v14);
    v11 += v14;
    v12 -= v14;
  }
  while (v12);
  if (v11 != 46)
  {
LABEL_17:
    v15 = "aaByteStreamReadExpected";
    v16 = 110;
    goto LABEL_18;
  }
  if (*v10 != 0x3031464649444952
    || !*((_WORD *)v10 + 4)
    || !*(_QWORD *)((char *)v10 + 18)
    || (v35 = *(_QWORD *)((char *)v10 + 30), v35 < 0x2F)
    || v35 >= *(_QWORD *)((char *)v10 + 38))
  {
    v15 = "bad header";
    v16 = 118;
LABEL_18:
    v17 = 0;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v16, 135, v17, v15, v8, v9, v250);
LABEL_25:
    free(v10);
    v24 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 548, 135, *v24, "patch_read_header", v25, v26, v251);
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
LABEL_26:
    v31 = 0;
    goto LABEL_27;
  }
  if (v35 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_50:
    v44 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", 122, 135, *v44, "aaReallocf", v45, v46, v250);
    v10 = 0;
    goto LABEL_25;
  }
  v36 = (char *)realloc(v10, v35);
  if (!v36)
  {
    free(v10);
    goto LABEL_50;
  }
  v30 = v36;
  v39 = *(_QWORD *)(v36 + 30) - 46;
  if (*((_QWORD *)v6 + 2))
  {
    if (*(_QWORD *)(v36 + 30) == 46)
      goto LABEL_54;
    v40 = 0;
    v41 = v36 + 46;
    v42 = *(_QWORD *)(v36 + 30) - 46;
    while (1)
    {
      v43 = (*((uint64_t (**)(_QWORD, char *, uint64_t))v6 + 2))(*(_QWORD *)v6, v41, v42);
      if (v43 < 0)
        break;
      if (v43)
      {
        v41 += v43;
        v40 += v43;
        v42 -= v43;
        if (v42)
          continue;
      }
      goto LABEL_53;
    }
    v40 = v43;
  }
  else
  {
    v40 = -1;
  }
LABEL_53:
  if (v39 != v40)
  {
    v53 = "aaByteStreamReadExpected";
    v54 = 124;
LABEL_62:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_header", v54, 135, 0, v53, v37, v38, v250);
    v10 = v30;
    goto LABEL_25;
  }
LABEL_54:
  v47 = 0;
  v48 = *(_QWORD *)(v30 + 38);
  v49 = *((unsigned __int16 *)v30 + 4);
  do
  {
    v50 = *(_QWORD *)&v30[v47 + 46];
    if (v48 >= v50)
    {
      v53 = "bad header";
      v54 = 130;
      goto LABEL_62;
    }
    v47 += 8;
    v48 = v50;
  }
  while (8 * v49 + 8 != v47);
  if (*(int *)(a1 + 48) >= 1)
  {
    v51 = (FILE **)MEMORY[0x24BDAC8D8];
    if ((_DWORD)v49 == 1)
      v52 = "*full replacement*";
    else
      v52 = *(const char **)(a1 + 16);
    v55 = "(stream based)";
    if (*(_QWORD *)(a1 + 32))
      v55 = *(const char **)(a1 + 32);
    v56 = *(_DWORD *)(a1 + 40);
    if ((v56 & 1) != 0)
      v57 = "no";
    else
      v57 = "yes";
    if ((v56 & 2) != 0)
      v58 = "yes";
    else
      v58 = "no";
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImagePatch\n  Input:        %s\n  Output:       %s\n  Patch:        %s\n  CryptexCache: %s\n  StaticContent: %s\n", v52, *(const char **)(a1 + 24), v55, v57, v58);
    if (*(int *)(a1 + 48) >= 2)
    {
      fprintf(*v51, "  - Variants:   %d\n  - Flags:      %llx\n  - # controls: %llu\n  - Patch size: %llu bytes\n    - Metadata: %llu bytes\n    - Controls: %llu bytes\n", *((unsigned __int16 *)v30 + 4), *(_QWORD *)(v30 + 10), *(_QWORD *)(v30 + 18), *(_QWORD *)&v30[8 * *((unsigned __int16 *)v30 + 4) + 46], *(_QWORD *)(v30 + 38) - *(_QWORD *)(v30 + 30), *(_QWORD *)(v30 + 46) - *(_QWORD *)(v30 + 38));
      if (*((_WORD *)v30 + 4))
      {
        v59 = 0;
        do
        {
          if (v59)
            v60 = "Diff";
          else
            v60 = "Literal";
          v61 = v59 + 1;
          fprintf(*v51, "    - %s stream: %llu bytes\n", v60, *(_QWORD *)&v30[8 * v59 + 54] - *(_QWORD *)&v30[8 * v59 + 46]);
          v59 = v61;
        }
        while (v61 < *((unsigned __int16 *)v30 + 4));
      }
    }
  }
  v62 = aaIntervalInputStreamOpen((uint64_t)v6, *(_QWORD *)(v30 + 30), *(_QWORD *)(v30 + 38));
  v65 = v62;
  if (!v62)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 187, 135, 0, "aaIntervalInputStreamOpen", v63, v64, v250);
    v29 = 0;
    v70 = 0;
    goto LABEL_95;
  }
  v66 = *(unsigned int *)(a1 + 48);
  if (v66 <= 3)
    v67 = v66 << 62;
  else
    v67 = 0xC000000000000000;
  v70 = AADecompressionInputStreamOpen(v62, v67, *(_DWORD *)(a1 + 44));
  if (!v70)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", 189, 135, 0, "AADecompressionInputStreamOpen", v68, v69, v250);
    v29 = 0;
    goto LABEL_95;
  }
  v29 = calloc(*((unsigned __int16 *)v30 + 4), 8uLL);
  if (!v29)
  {
    v76 = "aaCalloc";
    v77 = 193;
    goto LABEL_94;
  }
  if (*((_WORD *)v30 + 4))
  {
    v73 = 0;
    while (1)
    {
      v74 = rawimg_create_with_stream(v70, v73 == 0);
      v29[v73] = v74;
      if (!v74)
        break;
      if (++v73 >= (unint64_t)*((unsigned __int16 *)v30 + 4))
        goto LABEL_89;
    }
    v76 = "rawimg_create_with_stream";
    v77 = 199;
LABEL_94:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_read_variants", v77, 135, 0, v76, v71, v72, v250);
LABEL_95:
    free(v29);
    v75 = 1;
  }
  else
  {
LABEL_89:
    v75 = 0;
  }
  v78 = AAByteStreamClose(v70);
  v79 = AAByteStreamClose(v65);
  if (!v29 || (v75 & 1) != 0 || v79 < 0 || v78 < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 552, 135, 0, "patch_read_variants", v80, v81, v250);
    v27 = 0;
    v28 = 0;
    v29 = 0;
    goto LABEL_26;
  }
  v82 = calloc(*((unsigned __int16 *)v30 + 4), 0x20uLL);
  v31 = v82;
  if (!v82)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 556, 135, 0, "aaCalloc", v83, v84, v250);
    v28 = 0;
    goto LABEL_368;
  }
  if (*((_WORD *)v30 + 4))
  {
    v85 = 0;
    v86 = v82;
    do
    {
      v87 = *(_OWORD *)(v29[v85] + 2104);
      *v86 = *(_OWORD *)(v29[v85] + 2088);
      v86[1] = v87;
      v86 += 2;
      ++v85;
      v88 = *((unsigned __int16 *)v30 + 4);
    }
    while (v85 < v88);
    *(_QWORD *)(*v29 + 2048) = *(_QWORD *)(a1 + 24);
    if ((_DWORD)v88 == 1)
    {
      v28 = 0;
      v269 = 0;
      v275 = 0;
      s = 0;
      v287 = 0;
      compressed_stream = 0;
      v279 = 0;
      v89 = *v29;
      v90 = *(_DWORD *)(a1 + 40);
      v91 = v90 & 1;
      goto LABEL_106;
    }
  }
  else
  {
    *(_QWORD *)(*v29 + 2048) = *(_QWORD *)(a1 + 24);
  }
  v106 = (__int128 *)malloc(0x2000uLL);
  v28 = v106;
  if (!v106)
  {
    v121 = "aaMalloc";
    v122 = 568;
    goto LABEL_367;
  }
  saveThreadErrorContext(v106);
  v109 = *((unsigned __int16 *)v30 + 4);
  if (!*((_WORD *)v30 + 4))
  {
LABEL_138:
    restoreThreadErrorContext(v28);
    goto LABEL_139;
  }
  v110 = &v31[4 * v109 - 4];
  v111 = (char *)(v29 - 1);
  while (1)
  {
    v291 = v109;
    v112 = v109 - 1;
    *(_QWORD *)(*(_QWORD *)&v111[8 * v109] + 2048) = *(_QWORD *)(a1 + 16);
    if (!rawimg_get_digests(*(_QWORD *)&v111[8 * v109], 4, 1, 1))
    {
      v113 = *(_QWORD **)&v111[8 * v291];
      v114 = v113[261];
      v115 = v113[262];
      v116 = v113[263];
      v117 = v113[264];
      v118 = *v110 == v114 && v110[1] == v115;
      v119 = v118 && v110[2] == v116;
      if (v119 && v110[3] == v117)
        break;
    }
    v110 -= 4;
    v109 = v112;
    if (!v112)
      goto LABEL_138;
  }
  restoreThreadErrorContext(v28);
  v269 = v112;
  if ((v112 & 0x80000000) != 0)
  {
LABEL_139:
    v121 = "ImagePatch: No variant found";
    v122 = 586;
    goto LABEL_367;
  }
  if ((_DWORD)v291 == 1)
    goto LABEL_279;
  v184 = &v31[4 * v112];
  v185 = *v184;
  v186 = v184[1];
  v188 = v184[2];
  v187 = v184[3];
  if (*v31 == v185 && v31[1] == v186 && v31[2] == v188 && v31[3] == v187)
  {
    *(_QWORD *)(*v29 + 2048) = *(_QWORD *)(a1 + 16);
LABEL_279:
    v207 = *v29;
    v208 = *(const char **)(*v29 + 2048);
    v209 = *(const char **)(a1 + 24);
    v210 = strcmp(v208, v209);
    v211 = *(_DWORD *)(a1 + 48);
    if (v210)
    {
      if (v211 >= 2)
      {
        fwrite("ImagePatch: Digest match. Copy input to output.\n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
        v207 = *v29;
      }
      if ((copyFileSegment(v208, 0, *(_QWORD *)(v207 + 2120), v209) & 0x80000000) != 0)
      {
        v121 = "copyFileSegment";
        v122 = 607;
        goto LABEL_367;
      }
    }
    else if (v211 >= 2)
    {
      v212 = (FILE *)*MEMORY[0x24BDAC8D8];
      v213 = "ImagePatch: Digest match. Output already correct.\n";
      v214 = 50;
      goto LABEL_375;
    }
LABEL_376:
    v27 = 1;
    rawimg_show(*v29, 1, *(_DWORD *)(a1 + 48));
    if (*(_QWORD *)a1
      && ((*(uint64_t (**)(_QWORD, uint64_t))a1)(*(_QWORD *)(a1 + 8), 100) & 0x80000000) != 0)
    {
      v121 = "callback signaled abort";
      v122 = 641;
      goto LABEL_367;
    }
    goto LABEL_369;
  }
  rawimg_show(v29[v112], 0, *(_DWORD *)(a1 + 48));
  v90 = *(_DWORD *)(a1 + 40);
  v91 = v90 & 1;
  v285 = *v29;
  v288 = (_QWORD *)v29[v269];
  v192 = (const char *)v288[256];
  v283 = strcmp(v192, *(const char **)(*v29 + 2048));
  if (!v283)
  {
    if ((v30[10] & 1) != 0)
    {
      if (*(_DWORD *)(a1 + 48))
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ImagePatch: Patching with excess space <= %d bytes.\n", *(_DWORD *)(v30 + 26));
    }
    else
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 245, 135, "ImagePatch: Patch not created with in place. No bound on needed excess space.", v193, v194, v195, v250);
    }
    v223 = v288[265];
    if (*(_QWORD *)(v285 + 2120) > v223)
      v223 = *(_QWORD *)(v285 + 2120);
    v281 = v223;
    v290 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v285 + 2048), 2, 0x1A4u);
    if (!v290)
    {
      v240 = "AAFileStreamOpenWithPath";
      v241 = 252;
      goto LABEL_346;
    }
    if ((v90 & 1) != 0)
    {
      if ((io_set_nocache(v290) & 0x80000000) != 0)
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 257, 135, "io_set_nocache %s", v224, v225, v226, *(_QWORD *)(v285 + 2048));
      LODWORD(v227) = *(_DWORD *)(a1 + 48);
      v227 = v227 >= 3 ? 3 : v227;
      v290 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v290, 0x1000000uLL, 14, 1, v227 << 62);
      if (!v290)
      {
        v240 = "aaCacheStreamOpen";
        v241 = 259;
        goto LABEL_346;
      }
    }
    v275 = (unsigned int **)aaInSituStreamOpen(v290, v281, *(_DWORD *)(v30 + 26), *(_DWORD *)(a1 + 48), 1);
    if (!v275)
    {
      v240 = "aaInSituStreamOpen";
      v241 = 264;
      goto LABEL_346;
    }
    if (*((unsigned __int16 *)v30 + 4) <= 1u)
    {
      s = 0;
      v287 = 0;
      compressed_stream = 0;
      v279 = 0;
      v268 = 0;
      v289 = v275;
      v123 = aaSegmentStreamOpen(v275, (_QWORD *)v285);
      goto LABEL_145;
    }
    v289 = v275;
LABEL_324:
    s = aaSegmentStreamOpen(v275, v288);
    if (!s)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 290, 135, 0, "aaSegmentStreamOpen", v231, v232, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
      compressed_stream = 0;
      v292 = 0;
      v282 = 0;
      v287 = 0;
      s = 0;
      goto LABEL_347;
    }
    v287 = aaForkInputStreamOpen(s, (uint64_t)v288, 0, v228, v229, v230, v231, v232);
    if (!v287)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 292, 135, 0, "aaForkInputStreamOpen", v233, v234, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
      compressed_stream = 0;
      v292 = 0;
      v282 = 0;
      v287 = 0;
      goto LABEL_347;
    }
    compressed_stream = aaIntervalInputStreamOpen((uint64_t)v6, *(_QWORD *)&v30[8 * v269 + 46], *(_QWORD *)&v30[8 * v291 + 46]);
    if (compressed_stream)
    {
      LODWORD(v237) = *(_DWORD *)(a1 + 48);
      if (v237 >= 3)
        v237 = 3;
      else
        v237 = v237;
      v279 = AADecompressionInputStreamOpen(compressed_stream, v237 << 62, *(_DWORD *)(a1 + 44));
      if (v279)
      {
        if (v283)
          goto LABEL_306;
        v268 = 0;
        goto LABEL_144;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 298, 135, 0, "AADecompressionInputStreamOpen", v238, v239, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
    }
    else
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 296, 135, 0, "aaIntervalInputStreamOpen", v235, v236, v250);
      v276 = 0;
      v284 = 0;
      v279 = 0;
      v280 = 0;
      compressed_stream = 0;
    }
LABEL_273:
    v292 = 0;
    v282 = 0;
    goto LABEL_347;
  }
  if (*((unsigned __int16 *)v30 + 4) > 1u)
  {
    v275 = (unsigned int **)AAFileStreamOpenWithPath(v192, 0, 0);
    if (v275)
    {
      if ((v90 & 1) == 0)
        goto LABEL_271;
      if ((io_set_nocache(v275) & 0x80000000) != 0)
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 284, 135, "io_set_nocache %s", v198, v199, v200, v288[256]);
      LODWORD(v201) = *(_DWORD *)(a1 + 48);
      v201 = v201 >= 3 ? 3 : v201;
      v91 = 1;
      v275 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v275, 0x1000000uLL, 14, 1, v201 << 62);
      if (v275)
      {
LABEL_271:
        v289 = 0;
        goto LABEL_324;
      }
      v240 = "aaCacheStreamOpen";
      v241 = 286;
    }
    else
    {
      v240 = "AAFileStreamOpenWithPath";
      v241 = 281;
    }
LABEL_346:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v241, 135, 0, v240, v196, v197, v250);
    v276 = 0;
    v284 = 0;
    v279 = 0;
    v280 = 0;
    compressed_stream = 0;
    v289 = 0;
    v292 = 0;
    v282 = 0;
    v287 = 0;
    s = 0;
    v275 = 0;
LABEL_347:
    v286 = 0;
    v277 = 0;
    goto LABEL_348;
  }
  v275 = 0;
  s = 0;
  v287 = 0;
  compressed_stream = 0;
  v279 = 0;
LABEL_306:
  v89 = v285;
LABEL_106:
  v285 = v89;
  v289 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(v89 + 2048), 1538, 0x1A4u);
  if (!v289)
  {
    v104 = "AAFileStreamOpenWithPath";
    v105 = 305;
    goto LABEL_142;
  }
  if ((v90 & 2) != 0 && (io_hint_static_content(v289) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 308, 135, "ImagePatch: Static content hint failed.", v94, v95, v96, v250);
  if ((io_preallocate(v289, *(_QWORD *)(v285 + 2120)) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 311, 135, "ImagePatch: Preallocation failed.", v97, v98, v99, v250);
  if (v91)
  {
    if ((io_set_nocache(v289) & 0x80000000) != 0)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 316, 135, "io_set_nocache %s", v100, v101, v102, *(_QWORD *)(v285 + 2048));
    LODWORD(v103) = *(_DWORD *)(a1 + 48);
    if (v103 >= 3)
      v103 = 3;
    else
      v103 = v103;
    v268 = 1;
    v289 = (unsigned int **)aaCacheStreamOpen((AAByteStream_impl *)v289, 0x100000uLL, 14, 1, v103 << 62);
    if (!v289)
    {
      v104 = "aaCacheStreamOpen";
      v105 = 318;
LABEL_142:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v105, 135, 0, v104, v92, v93, v250);
      v276 = 0;
      v282 = 0;
      v284 = 0;
      v280 = 0;
      v289 = 0;
      v292 = 0;
      goto LABEL_347;
    }
  }
  else
  {
    v268 = 1;
  }
LABEL_144:
  v123 = aaSegmentStreamOpen(v289, (_QWORD *)v285);
LABEL_145:
  v282 = (AAByteStream_impl *)v123;
  if (!v123)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 322, 135, 0, "aaSegmentStreamOpen", v124, v125, v250);
    v276 = 0;
    v284 = 0;
    v280 = 0;
    goto LABEL_273;
  }
  v292 = aaForkOutputStreamOpen((uint64_t)v123, (_QWORD *)v285);
  if (!v292)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 324, 135, 0, "aaForkOutputStreamOpen", v126, v127, v250);
    v276 = 0;
    v284 = 0;
    v280 = 0;
    v292 = 0;
    goto LABEL_347;
  }
  v280 = aaIntervalInputStreamOpen((uint64_t)v6, *(_QWORD *)(v30 + 46), *(_QWORD *)(v30 + 54));
  if (!v280)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 328, 135, 0, "aaIntervalInputStreamOpen", v128, v129, v250);
    v276 = 0;
    v284 = 0;
    v280 = 0;
    goto LABEL_347;
  }
  LODWORD(v130) = *(_DWORD *)(a1 + 48);
  if (v130 >= 3)
    v130 = 3;
  else
    v130 = v130;
  v284 = AADecompressionInputStreamOpen(v280, v130 << 62, *(_DWORD *)(a1 + 44));
  if (!v284)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 330, 135, 0, "AADecompressionInputStreamOpen", v131, v132, v250);
    v276 = 0;
    v284 = 0;
    goto LABEL_347;
  }
  v276 = calloc(1uLL, 0x10040uLL);
  if (!v276)
  {
    v202 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_create", 36, 135, *v202, "aaCalloc", v203, v204, v250);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", 338, 135, 0, "control_reader_create", v205, v206, v252);
    v276 = 0;
    goto LABEL_347;
  }
  *((_QWORD *)v276 + 0x2000) = v6;
  *((_QWORD *)v276 + 8195) = v30;
  *((_QWORD *)v276 + 8196) = a1;
  v139 = *((unsigned __int16 *)v30 + 4) + 1;
  *((_QWORD *)v276 + 8197) = 0x2000 / v139 * v139;
  *((_QWORD *)v276 + 8198) = -1;
  v140 = *(_QWORD *)(v30 + 18);
  *((_QWORD *)v276 + 8199) = v140 * v139;
  v141 = v268;
  if (!v140)
    v141 = 1;
  if ((v141 & 1) == 0)
  {
    v278 = 0;
    v215 = 0;
    while (1)
    {
      v216 = (unint64_t *)ctrl_reader_get((uint64_t)v276, v278, v133, v134, v135, v136, v137, v138);
      if (!v216)
      {
        v220 = "ctrl_reader_get";
        v221 = 349;
        goto LABEL_302;
      }
      if ((*v216 & 0x8000000000000000) == 0)
        v217 = *v216;
      else
        v217 = 0x8000000000000000 - *v216;
      v218 = v216[v269 + 1];
      if (v218 < 0)
        v218 = 0x8000000000000000 - v218;
      v267 = v218;
      if (v217)
        break;
LABEL_299:
      v215 += v267;
      if (++v278 >= *(_QWORD *)(v30 + 18))
        goto LABEL_156;
    }
    while (1)
    {
      v219 = v217 >= 0x10000 ? 0x10000 : v217;
      if (v219 != aaByteStreamSimulate(v287))
        break;
      v215 += v219;
      v217 -= v219;
      if (!v217)
        goto LABEL_299;
    }
    v220 = "aaByteStreamSimulate";
    v221 = 358;
LABEL_302:
    v222 = 0;
    goto LABEL_308;
  }
LABEL_156:
  v277 = calloc(1uLL, 0x20000uLL);
  if (!v277)
  {
    v222 = *__error();
    v220 = "aaCalloc";
    v221 = 371;
LABEL_308:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v221, 135, v222, v220, v137, v138, v250);
    goto LABEL_347;
  }
  v264 = 0;
  v257 = 0;
  v254 = v269 + 1;
  v148 = *(_QWORD *)(v30 + 18);
  v255 = 1;
  while (!v148)
  {
LABEL_244:
    v183 = v268;
    if (v255 > 1)
      v183 = 1;
    ++v255;
    if (v183 == 1)
    {
      if ((AAByteStreamTruncate(v289) & 0x80000000) == 0)
      {
        v286 = 1;
        goto LABEL_348;
      }
      v242 = "AAByteStreamTruncate";
      v243 = 457;
LABEL_384:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v243, 135, 0, v242, v146, v147, v250);
      v286 = 0;
LABEL_348:
      if (v275 == v289)
        v244 = 0;
      else
        v244 = (AAByteStream_impl *)v275;
      goto LABEL_351;
    }
  }
  v256 = 0;
  v263 = 0;
  v259 = 0;
  while (2)
  {
    v149 = (unint64_t *)ctrl_reader_get((uint64_t)v276, v256, v142, v143, v144, v145, v146, v147);
    if (!v149)
    {
      v242 = "ctrl_reader_get";
      v243 = 387;
      goto LABEL_384;
    }
    v150 = *v149;
    v151 = v149[1];
    if ((*v149 & 0x8000000000000000) != 0)
      v150 = 0x8000000000000000 - *v149;
    v261 = v150;
    v152 = 0x8000000000000000 - v151;
    if (v151 >= 0)
      v152 = v149[1];
    v260 = v152;
    v153 = v149[v254];
    if (v153 < 0)
      v153 = 0x8000000000000000 - v153;
    v253 = v153;
    if (v255 == 2)
    {
      v263 += v261;
      if ((v268 & 1) == 0 && v263 < *(_QWORD *)(v285 + 2056))
        goto LABEL_170;
LABEL_215:
      if (v260)
      {
        v262 = 0;
        while (1)
        {
          v172 = v260 - v262;
          if (v260 - v262 >= 0x10000)
            v172 = 0x10000;
          v266 = v172;
          if (!*((_QWORD *)v284 + 2))
          {
LABEL_336:
            v242 = "aaByteStreamReadExpected";
            v243 = 439;
            goto LABEL_384;
          }
          if (v172)
          {
            v173 = 0;
            v174 = v277;
            v175 = v172;
            while (1)
            {
              v176 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t))v284 + 2))(*(_QWORD *)v284, v174, v175);
              if (v176 < 0)
                break;
              if (v176)
              {
                v174 += v176;
                v173 += v176;
                v175 -= v176;
                if (v175)
                  continue;
              }
              goto LABEL_229;
            }
            v173 = v176;
LABEL_229:
            if (v266 != v173)
              goto LABEL_336;
            if (!*((_QWORD *)v292 + 5))
              goto LABEL_337;
            v272 = 0;
            v177 = v277;
            v178 = v263;
            v179 = v266;
            while (1)
            {
              v180 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t, unint64_t))v292 + 5))(*(_QWORD *)v292, v177, v179, v178);
              if (v180 < 1)
                break;
              v177 += v180;
              v272 += v180;
              v178 += v180;
              v179 -= v180;
              if (!v179)
                goto LABEL_236;
            }
            v272 = v180;
LABEL_236:
            if (v266 != v272)
            {
LABEL_337:
              v242 = "aaByteStreamWriteExpected";
              v243 = 440;
              goto LABEL_384;
            }
          }
          else if (!*((_QWORD *)v292 + 5))
          {
            goto LABEL_337;
          }
          v264 += v266;
          if (*(_QWORD *)a1)
          {
            if (v264 > v257)
            {
              v181 = *(_QWORD *)(v285 + 2080);
              if (v264 < v181)
              {
                v182 = ((v181 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
                if (((*(uint64_t (**)(_QWORD, unint64_t))a1)(*(_QWORD *)(a1 + 8), v264 / (v181 / 0x64 + 1)) & 0x80000000) != 0)
                {
                  v249 = 450;
                  goto LABEL_387;
                }
                v257 = v264 + (v182 >> 2);
              }
            }
          }
          v263 += v266;
          v262 += v266;
          if (v262 >= v260)
            goto LABEL_243;
        }
      }
      goto LABEL_243;
    }
    if (!v261)
    {
LABEL_212:
      v259 += v253;
      if ((v268 & 1) != 0 || v255 != 1 || v263 < *(_QWORD *)(v285 + 2056))
        goto LABEL_215;
LABEL_170:
      v263 += v260;
LABEL_243:
      v148 = *(_QWORD *)(v30 + 18);
      if (++v256 >= v148)
        goto LABEL_244;
      continue;
    }
    break;
  }
  v258 = 0;
  while (2)
  {
    v154 = v261 - v258;
    if (v261 - v258 >= 0x10000)
      v154 = 0x10000;
    v265 = v154;
    if (!v287[4])
      goto LABEL_340;
    if (v154)
    {
      v270 = 0;
      v155 = v277;
      v156 = v259;
      v157 = v154;
      while (1)
      {
        v158 = ((uint64_t (*)(uint64_t, _BYTE *, uint64_t, uint64_t))v287[4])(*v287, v155, v157, v156);
        if (v158 < 0)
          break;
        if (v158)
        {
          v155 += v158;
          v270 += v158;
          v156 += v158;
          v157 -= v158;
          if (v157)
            continue;
        }
        goto LABEL_183;
      }
      v270 = v158;
LABEL_183:
      if (v265 != v270)
      {
LABEL_340:
        v242 = "aaByteStreamPReadExpected";
        v243 = 400;
        goto LABEL_384;
      }
    }
    v159 = *(_QWORD *)(v285 + 2072);
    if (v263 >= v159)
    {
LABEL_198:
      if (!*((_QWORD *)v292 + 5))
        goto LABEL_342;
      if (v265)
      {
        v271 = 0;
        v166 = v277;
        v167 = v263;
        v168 = v265;
        while (1)
        {
          v169 = (*((uint64_t (**)(_QWORD, _BYTE *, uint64_t, unint64_t))v292 + 5))(*(_QWORD *)v292, v166, v168, v167);
          if (v169 < 1)
            break;
          v166 += v169;
          v271 += v169;
          v167 += v169;
          v168 -= v169;
          if (!v168)
            goto LABEL_205;
        }
        v271 = v169;
LABEL_205:
        if (v265 != v271)
        {
LABEL_342:
          v242 = "aaByteStreamWriteExpected";
          v243 = 412;
          goto LABEL_384;
        }
      }
    }
    else
    {
      if (v265 + v263 > v159)
      {
        v242 = "bad controls";
        v243 = 406;
        goto LABEL_384;
      }
      if (!*((_QWORD *)v279 + 2))
        goto LABEL_380;
      if (v265)
      {
        v160 = 0;
        v161 = v277 + 0x10000;
        v162 = v265;
        while (1)
        {
          v163 = (*((uint64_t (**)(_QWORD, char *, uint64_t))v279 + 2))(*(_QWORD *)v279, v161, v162);
          if (v163 < 0)
            break;
          if (v163)
          {
            v161 += v163;
            v160 += v163;
            v162 -= v163;
            if (v162)
              continue;
          }
          goto LABEL_196;
        }
        v160 = v163;
LABEL_196:
        v164 = v277;
        v165 = v265;
        if (v265 != v160)
        {
LABEL_380:
          v242 = "aaByteStreamReadExpected";
          v243 = 407;
          goto LABEL_384;
        }
        do
        {
          *v164 += v164[0x10000];
          ++v164;
          --v165;
        }
        while (v165);
        goto LABEL_198;
      }
      if (!*((_QWORD *)v292 + 5))
        goto LABEL_342;
    }
    v264 += v265;
    if (!*(_QWORD *)a1 || v264 <= v257 || (v170 = *(_QWORD *)(v285 + 2080), v264 >= v170))
    {
LABEL_211:
      v259 += v265;
      v263 += v265;
      v258 += v265;
      if (v258 >= v261)
        goto LABEL_212;
      continue;
    }
    break;
  }
  v171 = ((v170 >> 2) * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64;
  if (((*(uint64_t (**)(_QWORD, unint64_t))a1)(*(_QWORD *)(a1 + 8), v264 / (v170 / 0x64 + 1)) & 0x80000000) == 0)
  {
    v257 = v264 + (v171 >> 2);
    goto LABEL_211;
  }
  v249 = 422;
LABEL_387:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"patch_apply", v249, 135, 0, "callback signaled abort", v146, v147, v250);
  if (v275 == v289)
    v244 = 0;
  else
    v244 = (AAByteStream_impl *)v275;
  if (v279)
    AAByteStreamCancel(v279);
  AAByteStreamCancel(v284);
  v286 = 0;
LABEL_351:
  if (v276)
  {
    AAByteStreamClose(*((AAByteStream *)v276 + 8194));
    AAByteStreamClose(*((AAByteStream *)v276 + 8193));
    free(v276);
  }
  free(v277);
  AAByteStreamClose((AAByteStream)v287);
  AAByteStreamClose((AAByteStream)s);
  AAByteStreamClose(v244);
  AAByteStreamClose(v292);
  AAByteStreamClose(v282);
  AAByteStreamClose((AAByteStream)v289);
  AAByteStreamClose(v279);
  AAByteStreamClose(compressed_stream);
  AAByteStreamClose(v284);
  AAByteStreamClose(v280);
  if (v286)
  {
    if (rawimg_get_digests(*v29, 4, 0, 1)
      || (*v31 == *(_QWORD *)(*v29 + 2088) ? (v245 = v31[1] == *(_QWORD *)(*v29 + 2096)) : (v245 = 0),
          v245 ? (v246 = v31[2] == *(_QWORD *)(*v29 + 2104)) : (v246 = 0),
          v246 ? (v247 = v31[3] == *(_QWORD *)(*v29 + 2112)) : (v247 = 0),
          !v247))
    {
      v121 = "digest mismatch";
      v122 = 630;
      goto LABEL_367;
    }
    if (*(int *)(a1 + 48) >= 2)
    {
      v212 = (FILE *)*MEMORY[0x24BDAC8D8];
      v213 = "ImagePatch: Digest match. Output reconstructed.\n";
      v214 = 48;
LABEL_375:
      fwrite(v213, v214, 1uLL, v212);
    }
    goto LABEL_376;
  }
  v121 = "patch_apply";
  v122 = 621;
LABEL_367:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", v122, 135, 0, v121, v107, v108, v250);
LABEL_368:
  v27 = 0;
LABEL_369:
  if (*((_WORD *)v30 + 4))
  {
    v248 = 0;
    do
      rawimg_destroy((uint64_t *)v29[v248++]);
    while (v248 < *((unsigned __int16 *)v30 + 4));
  }
LABEL_27:
  if (!a2)
  {
LABEL_30:
    if (AAByteStreamClose(v6) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"RawImagePatchInternal", 649, 135, 0, "AAByteStreamClose", v32, v33, v250);
      v27 = 0;
    }
  }
  free(v31);
  free(v30);
  free(v29);
  free(v28);
  if (v27)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t RawImagePatch(uint64_t a1)
{
  return RawImagePatchInternal(a1, 0);
}

uint64_t ctrl_reader_get(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v11;
  uint64_t v12;
  AAByteStream_impl *v13;
  uint64_t v14;
  AAFlagSet v15;
  AAByteStream v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  char v30;

  v8 = a1 + 0x10000;
  v9 = *(_QWORD *)(a1 + 65560);
  if (*(_QWORD *)(v9 + 18) <= a2)
    return 0;
  v11 = a2 + a2 * *(unsigned __int16 *)(v9 + 8);
  if (v11 >= *(_QWORD *)(a1 + 65584))
    goto LABEL_8;
  v12 = *(_QWORD *)(a1 + 65568);
  *(_QWORD *)(a1 + 65584) = -*(_QWORD *)(a1 + 65576);
  AAByteStreamClose(*(AAByteStream *)(a1 + 65552));
  *(_QWORD *)(v8 + 16) = 0;
  AAByteStreamClose(*(AAByteStream *)(v8 + 8));
  *(_QWORD *)(v8 + 8) = 0;
  v13 = aaIntervalInputStreamOpen(*(_QWORD *)v8, *(_QWORD *)(v9 + 38), *(_QWORD *)(v9 + 46));
  *(_QWORD *)(v8 + 8) = v13;
  if (!v13)
  {
    v27 = "aaIntervalInputStreamOpen";
    v28 = 81;
LABEL_24:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImagePatch.c", (uint64_t)"ctrl_reader_get", v28, 135, 0, v27, a7, a8, v30);
    return 0;
  }
  v14 = *(unsigned int *)(v12 + 48);
  if (v14 <= 3)
    v15 = v14 << 62;
  else
    v15 = 0xC000000000000000;
  v16 = AADecompressionInputStreamOpen(v13, v15, *(_DWORD *)(v12 + 44));
  *(_QWORD *)(v8 + 16) = v16;
  if (!v16)
  {
    v27 = "AADecompressionInputStreamOpen";
    v28 = 83;
    goto LABEL_24;
  }
LABEL_8:
  while (1)
  {
    v17 = *(_QWORD *)(v8 + 40);
    v18 = *(_QWORD *)(v8 + 48);
    v19 = v17 + v18;
    if (v11 < v17 + v18)
      return a1 + 8 * (v11 - v18);
    *(_QWORD *)(v8 + 48) = v19;
    v20 = *(_QWORD *)(v8 + 56) - v19;
    if (v20 < v17)
      v17 = v20;
    v21 = *(_QWORD *)(v8 + 16);
    if (*(_QWORD *)(v21 + 16))
    {
      v22 = 0;
      v23 = 8 * v17;
      if (8 * v17)
      {
        v24 = a1;
        v25 = 8 * v17;
        while (1)
        {
          v26 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v21 + 16))(*(_QWORD *)v21, v24, v25);
          if (v26 < 0)
            break;
          if (v26)
          {
            v24 += v26;
            v22 += v26;
            v25 -= v26;
            if (v25)
              continue;
          }
          goto LABEL_19;
        }
        v22 = v26;
      }
LABEL_19:
      if (v23 == v22)
        continue;
    }
    v27 = "aaByteStreamReadExpected";
    v28 = 91;
    goto LABEL_24;
  }
}

uint64_t ParallelArchiveCheckAndFix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int DefaultNThreads;
  void *v10;
  void *v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t result;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  FILE **v41;
  FILE *v42;
  unint64_t v43;
  FILE *v44;
  unint64_t v45;
  FILE *v46;
  unint64_t v47;
  FILE *v48;
  unint64_t v49;
  FILE *v50;
  unint64_t v51;
  char v52;
  char v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t *v59;
  uint64_t v60;
  char v61[1024];
  unsigned int *v62;
  void *v63;
  void *v64;
  unsigned int v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71[2];

  v71[1] = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v52);
  bzero(v61, 0x458uLL);
  v60 = a1;
  DefaultNThreads = *(_DWORD *)(a1 + 4);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v59 = 0;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v54 = 0u;
  v65 = DefaultNThreads;
  v10 = calloc(DefaultNThreads, 0x8B0uLL);
  v63 = v10;
  v11 = malloc(8 * DefaultNThreads);
  v64 = v11;
  if (v10)
    v12 = v11 == 0;
  else
    v12 = 1;
  if (v12)
  {
    v13 = *__error();
    v16 = "malloc";
    v17 = 365;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", v17, 13, v13, v16, v14, v15, v53);
    goto LABEL_18;
  }
  if (!realpath_DARWIN_EXTSN(*(const char **)(a1 + 16), v61))
  {
    v13 = *__error();
    v16 = *(const char **)(a1 + 16);
    v17 = 366;
    goto LABEL_17;
  }
  v18 = v65;
  if (v65)
  {
    v19 = 0;
    do
    {
      v20 = (uint64_t **)((char *)v63 + 2224 * v19);
      *v20 = &v60;
      *((_QWORD *)v64 + v19++) = v20;
    }
    while (v19 != v18);
  }
  v62 = ThreadPoolCreate(v18, (uint64_t)v64, (uint64_t)checkAndFixThreadProc);
  if (!v62)
  {
    v16 = "ThreadPoolCreate";
    v17 = 375;
    v13 = 0;
    goto LABEL_17;
  }
  v54 = 0u;
  v55 = 0u;
  v57 = 0u;
  v58 = 0u;
  v56 = 0u;
  DWORD1(v54) = *(_DWORD *)(a1 + 4);
  v26 = *(_QWORD *)(a1 + 40);
  *((_QWORD *)&v54 + 1) = *(_QWORD *)(a1 + 24);
  *((_QWORD *)&v55 + 1) = v26;
  *(_QWORD *)&v56 = checkAndFixBeginEntry;
  *((_QWORD *)&v56 + 1) = checkAndFixBlob;
  *(_QWORD *)&v57 = checkAndFixPayload;
  *(_QWORD *)&v58 = checkAndFixEndEntry;
  v59 = &v60;
  if (ParallelArchiveRead((uint64_t)&v54, v21, v22, v23, v24, v25, v14, v15))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", 390, 13, 0, "reading manifest", v27, v28, v53);
    v29 = 0;
  }
  else
  {
    v29 = 1;
  }
  if ((ThreadPoolDestroy((uint64_t)v62) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", 393, 13, 0, "ThreadPoolDestroy failed", v38, v39, v53);
    v29 = 0;
    v62 = 0;
    goto LABEL_19;
  }
  v62 = 0;
  v40 = atomic_load(v71);
  if (v40 > 0)
  {
LABEL_18:
    v29 = 0;
    goto LABEL_19;
  }
  if (*(int *)a1 >= 1)
  {
    v41 = (FILE **)MEMORY[0x24BDAC8D8];
    v42 = (FILE *)*MEMORY[0x24BDAC8D8];
    v43 = atomic_load(&v66);
    fprintf(v42, "%12lld entries in manifest\n", v43);
    v44 = *v41;
    v45 = atomic_load(&v67);
    fprintf(v44, "%12lld entries valid\n", v45);
    v46 = *v41;
    v47 = atomic_load(&v68);
    fprintf(v46, "%12lld entries fixed\n", v47);
    v48 = *v41;
    v49 = atomic_load(&v69);
    fprintf(v48, "%12lld entries invalid\n", v49);
    v50 = *v41;
    v51 = atomic_load(&v70);
    fprintf(v50, "%12lld entries missing\n", v51);
  }
LABEL_19:
  if ((ThreadPoolDestroy((uint64_t)v62) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"ParallelArchiveCheckAndFix", 409, 13, 0, "ThreadPoolDestroy", v30, v31, v53);
    v29 = 0;
  }
  v32 = v63;
  if (v63)
  {
    if (v65)
    {
      v33 = 0;
      v34 = 2216;
      do
      {
        free(*(void **)((char *)v63 + v34));
        ++v33;
        v34 += 2224;
      }
      while (v33 < v65);
      v32 = v63;
    }
    free(v32);
  }
  free(v64);
  result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    if (v29)
    {
      if (atomic_load(&v69))
      {
        return 0;
      }
      else
      {
        v37 = atomic_load(&v70);
        return v37 == 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t checkAndFixThreadProc(uint64_t **a1)
{
  char *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t, int *);
  int v7;
  unint64_t *v8;
  unint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  int v19;
  _BOOL4 v20;
  int v21;
  int v22;
  int v23;
  unsigned __int8 *v24;
  unsigned __int8 *p_s2;
  unsigned int *v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL4 v29;
  int v30;
  unint64_t *v31;
  unint64_t v32;
  int v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  _BOOL4 v48;
  int IsCompressed;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  __int16 v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  char v67;
  int v68;
  int v69;
  stat v70;
  __int128 __s2;
  __int128 v72;
  uint64_t *v73;
  uint64_t *v74;
  unsigned int v75;
  char v76[2048];
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  v2 = (char *)*a1;
  v3 = **a1;
  v4 = *(_DWORD *)v3;
  v6 = *(void (**)(uint64_t, uint64_t, int *))(v3 + 48);
  v5 = *(_QWORD *)(v3 + 56);
  v7 = *(_DWORD *)(v3 + 12);
  bzero(v76, 0x800uLL);
  v8 = (unint64_t *)(v2 + 1072);
  memset(&v70, 0, sizeof(v70));
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  v10 = (int *)(a1 + 1);
  if (concatPath(v76, 0x800uLL, v2 + 8, (const char *)a1 + 152))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 80, 13, 0, "building full path: %s", v11, v12, (_BYTE)a1 - 104);
    v13 = (unint64_t *)(v2 + 1112);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
LABEL_6:
    v15 = (unint64_t *)(v2 + 1096);
    v16 = 2;
    goto LABEL_11;
  }
  if (v4 >= 3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "> %s %zu\n", v76, (size_t)a1[276]);
  if (lstat(v76, &v70))
    goto LABEL_10;
  if (*((_DWORD *)a1 + 3) == 72)
    v19 = 70;
  else
    v19 = *((_DWORD *)a1 + 3);
  if (v19 != getAAEntryType(v70.st_mode))
    goto LABEL_6;
  v20 = *((_DWORD *)a1 + 3) == 70 && statIsCompressed(v70.st_flags) != 0;
  v21 = *v10;
  if ((*v10 & 8) != 0)
  {
    if (statIsCompressed(*((_DWORD *)a1 + 6)))
      v20 = 1;
    v21 = *((_DWORD *)a1 + 2);
  }
  v22 = *(_DWORD *)(*(_QWORD *)v2 + 8) & v21;
  v23 = *((_DWORD *)a1 + 3);
  if (v23 == 70)
  {
    v74 = 0;
    v73 = 0;
    v75 = 0;
    __s2 = 0u;
    v72 = 0u;
    v69 = 0;
    if ((v22 & 0x2000) != 0)
      v24 = (unsigned __int8 *)&v73;
    else
      v24 = 0;
    if ((v22 & 0x4000) != 0)
      p_s2 = (unsigned __int8 *)&__s2;
    else
      p_s2 = 0;
    if ((v22 & 0x1000) != 0)
      v26 = (unsigned int *)&v69;
    else
      v26 = 0;
    if ((getFileDigests(v76, v24, p_s2, v26) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 120, 13, 0, "computing file digests: %s", v27, v28, (char)v76);
      v31 = (unint64_t *)(v2 + 1112);
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
      goto LABEL_6;
    }
    v29 = (v22 & 0x2000) != 0
       && (*(uint64_t **)((char *)a1 + 100) != v73
        || *(uint64_t **)((char *)a1 + 108) != v74
        || *((_DWORD *)a1 + 29) != (unint64_t)v75);
    if ((v22 & 0x4000) != 0
      && (unint64_t)a1[15] ^ (unint64_t)__s2 | (unint64_t)a1[16] ^ *((_QWORD *)&__s2 + 1) | (unint64_t)a1[17] ^ (unint64_t)v72 | (unint64_t)a1[18] ^ *((_QWORD *)&v72 + 1))
    {
      v29 = 1;
    }
    if ((v22 & 0x1000) != 0 && *((_DWORD *)a1 + 24) != v69)
      v29 = 1;
    v35 = *((_DWORD *)a1 + 3);
    if (v35 != 76 || (v22 & 0x10000) == 0)
    {
      if (!v29)
      {
        v30 = 0;
        goto LABEL_80;
      }
LABEL_71:
      if (v35 == 70)
      {
        v29 = 1;
        if (a1[276])
        {
          v30 = 1;
          if ((v7 & 1) == 0)
          {
            __s2 = 0uLL;
            *(_QWORD *)&v72 = 0;
            v41 = open(v76, 2);
            if (v41 < 0)
            {
              v62 = __error();
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 154, 13, *v62, "%s", v63, v64, (char)v76);
              v65 = (unint64_t *)(v2 + 1112);
              do
                v66 = __ldxr(v65);
              while (__stxr(v66 + 1, v65));
              goto LABEL_6;
            }
            v42 = v41;
            v43 = ParallelArchiveECCFixFileSegment(v41, 0, v70.st_size, (__int128 *)a1[277], (unint64_t)a1[276], (uint64_t)&__s2);
            close(v42);
            if (v43 < 0)
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 163, 13, "Data not fixed with ECC (diag 0x%08x): %s", v44, v45, v46, SBYTE4(v72));
              v47 = 1;
            }
            else
            {
              pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 169, 13, "Data fixed with ECC (diag 0x%08x): %s", v44, v45, v46, SBYTE4(v72));
              v47 = 0;
            }
            ParallelCompressionUpdateWarning(DWORD1(v72) | 0xFF000000, &unk_206434423);
            if (lstat(v76, &v70))
              goto LABEL_10;
            v29 = 1;
            v30 = v47;
          }
          goto LABEL_80;
        }
      }
      else
      {
        v29 = 1;
      }
      v30 = 1;
      goto LABEL_80;
    }
LABEL_62:
    bzero(&__s2, 0x400uLL);
    if (readlink(v76, (char *)&__s2, 0x400uLL) < 0)
    {
      v36 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 136, 13, *v36, "reading link: %s", v37, v38, (char)v76);
      v39 = (unint64_t *)(v2 + 1112);
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
      goto LABEL_6;
    }
    v30 = strncmp((const char *)a1 + 1176, (const char *)&__s2, 0x400uLL) | v29;
    if (!v30)
    {
      v29 = 0;
      goto LABEL_80;
    }
    v35 = *((_DWORD *)a1 + 3);
    goto LABEL_71;
  }
  v29 = 0;
  if (v23 != 76)
  {
    v30 = 0;
    goto LABEL_80;
  }
  v30 = 0;
  if ((v22 & 0x10000) != 0)
    goto LABEL_62;
LABEL_80:
  v68 = v30;
  v48 = (v22 & 2) != 0 && v70.st_uid != *((_DWORD *)a1 + 4);
  if ((v22 & 4) != 0)
  {
    if (v70.st_gid != *((_DWORD *)a1 + 5))
      v48 = 1;
    if ((v22 & 0x10) == 0)
    {
LABEL_85:
      if ((v22 & 8) == 0)
        goto LABEL_88;
      goto LABEL_86;
    }
  }
  else if ((v22 & 0x10) == 0)
  {
    goto LABEL_85;
  }
  if ((*((_DWORD *)a1 + 7) & 0xFFF) != (v70.st_mode & 0xFFF))
    v48 = 1;
  if ((v22 & 8) != 0)
  {
LABEL_86:
    if (v70.st_flags != *((_DWORD *)a1 + 6))
      v48 = 1;
  }
LABEL_88:
  if (*((_DWORD *)a1 + 3) != 70)
    goto LABEL_105;
  IsCompressed = statIsCompressed(v70.st_flags);
  if (v20)
  {
    if (IsCompressed)
      goto LABEL_105;
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 200, 13, "Compressing the file: %s\n", v50, v51, v52, (char)v76);
    if ((ParallelCompressionAFSCCompress(v76, 1) & 0x80000000) != 0)
    {
      v56 = "Error compressing file";
      v57 = 201;
LABEL_103:
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", v57, 13, v56, v53, v54, v55, v67);
    }
  }
  else
  {
    if (!IsCompressed)
      goto LABEL_105;
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 212, 13, "Decompressing the file: %s\n", v50, v51, v52, (char)v76);
    if ((ParallelCompressionAFSCCompress(v76, 0) & 0x80000000) != 0)
    {
      v56 = "Error decompressing file";
      v57 = 213;
      goto LABEL_103;
    }
  }
  if (lstat(v76, &v70))
  {
LABEL_10:
    v15 = (unint64_t *)(v2 + 1104);
    v16 = 3;
    goto LABEL_11;
  }
LABEL_105:
  v58 = v48;
  if (v48)
  {
    v58 = v48;
    if ((v7 & 2) == 0)
    {
      if ((yaa_setEntryAttributes(v76, v10, 0, 0) & 0x80000000) != 0)
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 234, 13, "Attr not fixed: %s", v59, v60, v61, (char)v76);
        v58 = 1;
      }
      else
      {
        pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixThreadProc", 238, 13, "Attr fixed: %s", v59, v60, v61, (char)v76);
        v58 = 0;
      }
    }
  }
  if (v58 | v68)
    goto LABEL_6;
  if (v48 || v29)
    v15 = (unint64_t *)(v2 + 1088);
  else
    v15 = (unint64_t *)(v2 + 1080);
  v16 = v48 || v29;
  do
LABEL_11:
    v17 = __ldxr(v15);
  while (__stxr(v17 + 1, v15));
  if (v6)
    v6(v5, v16, v10);
  return 0;
}

_QWORD *checkAndFixBeginEntry(_QWORD *result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t Worker;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  char v15;

  if (a2[1] != 77)
  {
    v9 = result;
    Worker = ThreadPoolGetWorker(result[129], (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    v9[130] = Worker;
    if (Worker)
    {
      *(_QWORD *)(Worker + 2208) = 0;
      return memcpy((void *)(Worker + 8), a2, 0x890uLL);
    }
    else
    {
      result = (_QWORD *)pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixBeginEntry", 291, 13, 0, "ThreadPoolGetWorker failed", v11, v12, v15);
      v13 = v9 + 139;
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
  }
  return result;
}

size_t checkAndFixEndEntry(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  char v14;

  v8 = *(_QWORD *)(result + 1040);
  if (v8)
  {
    v9 = result;
    result = ThreadPoolRunWorker(*(_QWORD *)(result + 1032), v8, a3, a4, a5, a6, a7, a8);
    if ((result & 0x80000000) != 0)
    {
      result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixEndEntry", 305, 13, 0, "ThreadPoolRunWorker failed", v10, v11, v14);
      v12 = (unint64_t *)(v9 + 1112);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    *(_QWORD *)(v9 + 1040) = 0;
  }
  return result;
}

uint64_t checkAndFixBlob(uint64_t result, _DWORD *a2, size_t __size)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char v11;

  v3 = *(_QWORD *)(result + 1040);
  if (v3)
  {
    v4 = result;
    v5 = (*a2 & 0xDFDFDF) == 4408665;
    *(_DWORD *)(result + 1068) = (*a2 & 0xDFDFDF) == 4408665;
    if (v5 && *(_QWORD *)(v3 + 2200) < __size)
    {
      *(_QWORD *)(v3 + 2200) = __size;
      result = (uint64_t)reallocf(*(void **)(v3 + 2216), __size);
      *(_QWORD *)(v3 + 2216) = result;
      if (!result)
      {
        v6 = __error();
        result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixBlob", 327, 13, *v6, "malloc", v7, v8, v11);
        v9 = (unint64_t *)(v4 + 1112);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
    }
  }
  return result;
}

uint64_t checkAndFixPayload(uint64_t result, const void *a2, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  char v14;

  v8 = *(_QWORD **)(result + 1040);
  if (v8)
  {
    v9 = result;
    if (*(_DWORD *)(result + 1068))
    {
      v11 = v8[276];
      if (v11 + __n <= v8[275])
      {
        result = (uint64_t)memcpy((void *)(v8[277] + v11), a2, __n);
        v8[276] += __n;
      }
      else
      {
        result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/CheckAndFix.c", (uint64_t)"checkAndFixPayload", 342, 13, 0, "Invalid YEC blob size", a7, a8, v14);
        v12 = (unint64_t *)(v9 + 1112);
        do
          v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
      }
    }
  }
  return result;
}

uint64_t ParallelCompressionGetCompressedSize(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  char v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t *v24;

  v3 = a2;
  if (a2 >= 0x400)
  {
    v24 = 0;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v19 = 0;
    v7 = IMemStreamCreate(a1, a2);
    if (v7)
    {
      DWORD2(v20) = a3;
      LODWORD(v20) = 0;
      DWORD1(v20) = getDefaultNThreads();
      *(_QWORD *)&v21 = 0x200000;
      *((_QWORD *)&v21 + 1) = IMemStreamRead;
      *((_QWORD *)&v22 + 1) = v7;
      *(_QWORD *)&v23 = getCompressedSizeCounterProc;
      v24 = &v19;
      if (!ParallelCompressionEncode((uint64_t)&v20, v8, v9, v10, v11, v12, v13, v14))
      {
        if (v19 < v3)
          v3 = v19;
        goto LABEL_9;
      }
      v15 = "ParallelCompressionEncode";
      v16 = 75;
    }
    else
    {
      v15 = "IMemStreamCreate";
      v16 = 64;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ParallelCompressionGetCompressedSize", v16, 39, 0, v15, v5, v6, v18);
    v3 = -1;
LABEL_9:
    IMagicStreamDestroy(v7);
  }
  return v3;
}

uint64_t getCompressedSizeCounterProc(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  *a1 += a3;
  return a3;
}

uint64_t IDecoderStreamThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  char vars0;

  if (ParallelCompressionDecode(a1, a2, a3, a4, a5, a6, a7, a8))
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamThreadProc", 100, 39, 0, "decoder failed", v8, v9, vars0);
  return 0;
}

uint64_t IDecoderStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  char v29;

  v10 = malloc(0x48uLL);
  v18 = (uint64_t)v10;
  if (v10)
  {
    v10[2] = 0u;
    v10[3] = 0u;
    *v10 = 0u;
    v10[1] = 0u;
    v19 = SharedBufferCreate(a4, v11, v12, v13, v14, v15, v16, v17);
    *(_QWORD *)(v18 + 64) = v19;
    if (!v19)
    {
      v23 = "fail to init buffer";
      v24 = 112;
      v22 = 0;
      goto LABEL_7;
    }
    *(_DWORD *)v18 = 0;
    *(_DWORD *)(v18 + 4) = a5;
    *(_QWORD *)(v18 + 8) = a1;
    *(_QWORD *)(v18 + 16) = a2;
    *(_QWORD *)(v18 + 24) = a3;
    *(_QWORD *)(v18 + 32) = SharedBufferWrite;
    *(_QWORD *)(v18 + 40) = SharedBufferAbort;
    *(_QWORD *)(v18 + 48) = v19;
    if (createThread((pthread_t *)(v18 + 56), (uint64_t)IDecoderStreamThreadProc, v18, 0))
    {
      v22 = *__error();
      v23 = "failed to start decoder thread";
      v24 = 125;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", v24, 39, v22, v23, v20, v21, v29);
      IDecoderStreamDestroy((_QWORD *)v18);
      return 0;
    }
  }
  else
  {
    v25 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamCreate", 107, 39, *v25, "malloc", v26, v27, v29);
  }
  return v18;
}

void IDecoderStreamDestroy(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _opaque_pthread_t *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  _BYTE v10[1024];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (a1)
  {
    if (a1[8])
    {
      while (1)
      {
        v2 = SharedBufferRead(a1[8], (uint64_t)v10, 0x400uLL);
        if (v2 < 0)
          break;
        if (!v2)
          goto LABEL_7;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 155, 39, 0, "flushing shared buffer", v3, v4, v9);
    }
LABEL_7:
    v5 = (_opaque_pthread_t *)a1[7];
    if (v5)
    {
      if (joinThread(v5))
      {
        v6 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"IDecoderStreamDestroy", 163, 39, *v6, "failed to join decoder thread", v7, v8, v9);
      }
    }
    SharedBufferDestroy(a1[8]);
    free(a1);
  }
}

uint64_t IDecoderStreamRead(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1)
    return SharedBufferRead(*(_QWORD *)(a1 + 64), a2, a3);
  else
    return -1;
}

size_t IDecoderStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
    return SharedBufferAbort(*(_QWORD *)(result + 64), a2, a3, a4, a5, a6, a7, a8, a9);
  return result;
}

uint64_t OEncoderStreamThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  char vars0;

  if (ParallelCompressionEncode(a1, a2, a3, a4, a5, a6, a7, a8))
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamThreadProc", 192, 39, 0, "encoder failed", v8, v9, vars0);
  return 0;
}

uint64_t OEncoderStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5, uint64_t a6, int a7)
{
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v40;

  v14 = malloc(0x60uLL);
  v22 = (uint64_t)v14;
  if (v14)
  {
    v14[10] = 0;
    *((_OWORD *)v14 + 3) = 0u;
    *((_OWORD *)v14 + 4) = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    *((_OWORD *)v14 + 2) = 0u;
    *(_OWORD *)v14 = 0u;
    v23 = SharedBufferCreate(a4, v15, v16, v17, v18, v19, v20, v21);
    *(_QWORD *)(v22 + 88) = v23;
    if (!v23)
    {
      v27 = "init buffer";
      v28 = 204;
      v26 = 0;
      goto LABEL_7;
    }
    *(_DWORD *)(v22 + 4) = a7;
    *(_DWORD *)(v22 + 8) = a5;
    *(_DWORD *)v22 = 0;
    *(_QWORD *)(v22 + 16) = a6;
    *(_QWORD *)(v22 + 24) = SharedBufferRead;
    *(_QWORD *)(v22 + 32) = SharedBufferAbort;
    *(_QWORD *)(v22 + 40) = v23;
    *(_QWORD *)(v22 + 48) = a1;
    *(_QWORD *)(v22 + 56) = a2;
    *(_QWORD *)(v22 + 64) = a3;
    if (createThread((pthread_t *)(v22 + 80), (uint64_t)OEncoderStreamThreadProc, v22, 0))
    {
      v26 = *__error();
      v27 = "failed to start encoder thread";
      v28 = 219;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamCreate", v28, 39, v26, v27, v24, v25, v40);
      OEncoderStreamDestroy(v22, v32, v33, v34, v35, v36, v37, v38);
      return 0;
    }
  }
  else
  {
    v29 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamCreate", 199, 39, *v29, "malloc", v30, v31, v40);
  }
  return v22;
}

void OEncoderStreamDestroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _opaque_pthread_t *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;

  if (a1)
  {
    if (!*(_DWORD *)(a1 + 72))
      SharedBufferWrite(*(unsigned int **)(a1 + 88), 0, 0, a4, a5, a6, a7, a8);
    v9 = *(_opaque_pthread_t **)(a1 + 80);
    if (v9)
    {
      if (joinThread(v9))
      {
        v10 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamDestroy", 260, 39, *v10, "failed to join encoder thread", v11, v12, v13);
      }
    }
    SharedBufferDestroy(*(_QWORD *)(a1 + 88));
    free((void *)a1);
  }
}

uint64_t OEncoderStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char vars0;

  if (!a1)
    return -1;
  v8 = *(_DWORD *)(a1 + 72);
  if (!a3)
  {
    if (v8)
      return 0;
    *(_DWORD *)(a1 + 72) = 1;
    return SharedBufferWrite(*(unsigned int **)(a1 + 88), a2, a3, a4, a5, a6, a7, a8);
  }
  if (!v8)
    return SharedBufferWrite(*(unsigned int **)(a1 + 88), a2, a3, a4, a5, a6, a7, a8);
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OEncoderStreamWrite", 241, 39, 0, "extra bytes written after EOF has been sent", a7, a8, vars0);
  return -1;
}

size_t OEncoderStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
    return SharedBufferAbort(*(_QWORD *)(result + 88), a2, a3, a4, a5, a6, a7, a8, a9);
  return result;
}

_QWORD *OFileEncoderStreamCreateWithFD(int a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, int a6)
{
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  char v27;

  v12 = malloc(0x10uLL);
  v13 = v12;
  if (v12)
  {
    v12[1] = 0;
    v14 = OFileStreamCreateWithFD(a1, a2);
    *v13 = v14;
    if (!v14
      || (v22 = OEncoderStreamCreate((uint64_t)OFileStreamWrite, (uint64_t)OFileStreamAbort, (uint64_t)v14, a3, a4, a5, a6),
          (v13[1] = v22) == 0))
    {
      OFileEncoderStreamDestroy((uint64_t)v13, v15, v16, v17, v18, v19, v20, v21);
      return 0;
    }
  }
  else
  {
    v23 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"OFileEncoderStreamCreateWithFD", 355, 39, *v23, "malloc", v24, v25, v27);
  }
  return v13;
}

void OFileEncoderStreamDestroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    OEncoderStreamDestroy(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
    OFileStreamDestroy(*(int **)a1);
    free((void *)a1);
  }
}

uint64_t OFileEncoderStreamWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return OEncoderStreamWrite(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t ILowMemoryDecoderStreamCreate(uint64_t (*a1)(uint64_t, uint64_t, unint64_t), uint64_t a2, uint64_t a3, size_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  void **v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t DataPtr;
  unsigned __int8 *v15;
  BOOL v18;
  const char *v19;
  __int16 v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v25;
  int v26;
  int v27;
  unint64_t DataSize;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unint64_t v45;
  unint64_t v46;
  char v47;

  v8 = malloc(0xD8uLL);
  v9 = (uint64_t)v8;
  if (v8)
  {
    v8[26] = 0;
    *((_OWORD *)v8 + 11) = 0u;
    *((_OWORD *)v8 + 12) = 0u;
    *((_OWORD *)v8 + 9) = 0u;
    *((_OWORD *)v8 + 10) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    *((_OWORD *)v8 + 8) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    *((_OWORD *)v8 + 2) = 0u;
    if (a4 <= 0x1000)
      a4 = 4096;
    *(_OWORD *)v8 = 0uLL;
    v10 = MemBufferCreate(a4);
    *(_QWORD *)(v9 + 56) = v10;
    if (!v10)
      goto LABEL_27;
    v11 = MemBufferCreate(a4);
    *(_QWORD *)(v9 + 64) = v11;
    if (!v11)
      goto LABEL_27;
    *(_DWORD *)(v9 + 32) = -1;
    *(_QWORD *)v9 = a1;
    *(_QWORD *)(v9 + 8) = a2;
    *(_QWORD *)(v9 + 16) = a3;
    if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0xCuLL, a1, a3) != 12)
    {
      v19 = "couldn't read enough header bytes from compressed file";
      v20 = 465;
      goto LABEL_26;
    }
    DataPtr = MemBufferGetDataPtr(*(_QWORD *)(v9 + 56));
    if ((*(_DWORD *)(v9 + 32) & 0x80000000) != 0)
    {
      v15 = (unsigned __int8 *)DataPtr;
      if (*(_WORD *)DataPtr == 25200 && *(_BYTE *)(DataPtr + 2) == 122)
      {
        v25 = 0;
        while (1)
        {
          v26 = v15[3];
          if (v26 == PCompressGetDecoderKey(v25))
            break;
          if (++v25 == 7)
          {
            if ((*(_DWORD *)(v9 + 32) & 0x80000000) == 0)
              return v9;
            goto LABEL_12;
          }
        }
        *(_QWORD *)(v9 + 40) = bswap64(*(_QWORD *)(v15 + 4));
        *(_QWORD *)(v9 + 48) = PCompressGetDecoderFilter(v25);
        MemBufferDecreaseSize(*(_QWORD *)(v9 + 56), 0xCuLL, v34, v35, v36, v37, v38, v39);
        if ((MemBufferIncreaseCapacity(*(_QWORD *)(v9 + 56), *(_QWORD *)(v9 + 40)) & 0x8000000000000000) != 0)
        {
          v19 = "MemBufferIncreaseCapacity in";
          v20 = 487;
        }
        else
        {
          if ((MemBufferIncreaseCapacity(*(_QWORD *)(v9 + 64), *(_QWORD *)(v9 + 40)) & 0x8000000000000000) == 0)
          {
            *(_DWORD *)(v9 + 32) = 0;
            return v9;
          }
          v19 = "MemBufferIncreaseCapacity out";
          v20 = 488;
        }
        goto LABEL_26;
      }
LABEL_12:
      if (*(_DWORD *)v15 == 1484404733 && *((_WORD *)v15 + 2) == 90)
      {
        if (!lzma_stream_decoder())
        {
          *(_DWORD *)(v9 + 32) = 1;
          return v9;
        }
        v19 = "lzma_stream_decoder";
        v20 = 503;
        goto LABEL_26;
      }
      v18 = *(_WORD *)v15 == 23106 && v15[2] == 104;
      if (v18 && v15[3] - 49 <= 8)
      {
        if (BZ2_bzDecompressInit((bz_stream *)(v9 + 72), 0, 0))
        {
          v19 = "BZ2_bzDecompressInit";
          v20 = 514;
LABEL_26:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", v20, 39, 0, v19, v12, v13, v47);
LABEL_27:
          ILowMemoryDecoderStreamDestroy(v9);
          return 0;
        }
        v44 = 3;
LABEL_54:
        *(_DWORD *)(v9 + 32) = v44;
        return v9;
      }
      v27 = *v15;
      if (v27 == 120)
      {
        if (-1108378657 * (v15[1] | 0x7800u) <= 0x8421084)
        {
          if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB) == COMPRESSION_STATUS_OK)
          {
            MemBufferDecreaseSize(*(_QWORD *)(v9 + 56), 2uLL, v40, v41, v42, v43, v12, v13);
            *(_DWORD *)(v9 + 32) = 2;
            return v9;
          }
          v19 = "compression_stream_init";
          v20 = 570;
          goto LABEL_26;
        }
      }
      else if (v27 == 31 && v15[1] == 139 && v15[2] == 8)
      {
        if (MemBufferFillFromIStream(*(unint64_t **)(v9 + 56), 0x1000uLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))v9, *(_QWORD *)(v9 + 16)) < 0)
        {
          v19 = "reading gzip header data";
          v20 = 525;
          goto LABEL_26;
        }
        DataSize = MemBufferGetDataSize(*(_QWORD *)(v9 + 56));
        if ((v15[3] & 4) != 0)
        {
          if (DataSize <= 0xB)
          {
            v19 = "parsing gzip header";
            v20 = 531;
            goto LABEL_26;
          }
          v33 = *((unsigned __int16 *)v15 + 5) + 12;
          if (v33 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 534;
            goto LABEL_26;
          }
        }
        else
        {
          v33 = 10;
        }
        if ((v15[3] & 8) != 0)
        {
          v45 = v33 + 2;
          if (v33 + 2 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 539;
            goto LABEL_26;
          }
          if (v33 + 2 < DataSize)
          {
            while (v15[v33 + 1])
            {
              if (DataSize - 2 == ++v33)
              {
                v45 = DataSize;
                goto LABEL_63;
              }
            }
            v45 = v33 + 2;
          }
        }
        else
        {
          v45 = v33;
        }
LABEL_63:
        if ((v15[3] & 0x10) != 0)
        {
          v46 = v45 + 2;
          if (v45 + 2 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 545;
            goto LABEL_26;
          }
          if (v45 + 2 < DataSize)
          {
            while (v15[v45 + 1])
            {
              if (DataSize - 2 == ++v45)
              {
                v46 = DataSize;
                goto LABEL_65;
              }
            }
            v46 = v45 + 2;
          }
        }
        else
        {
          v46 = v45;
        }
LABEL_65:
        if ((v15[3] & 2) != 0)
        {
          v46 += 2;
          if (v46 > DataSize)
          {
            v19 = "parsing gzip header";
            v20 = 551;
            goto LABEL_26;
          }
        }
        MemBufferDecreaseSize(*(_QWORD *)(v9 + 56), v46, v29, v30, v31, v32, v12, v13);
        if (compression_stream_init((compression_stream *)(v9 + 72), COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB))
        {
          v19 = "compression_stream_init";
          v20 = 557;
          goto LABEL_26;
        }
        v44 = 2;
        goto LABEL_54;
      }
      v19 = "Could not identify compressed stream format";
      v20 = 579;
      goto LABEL_26;
    }
  }
  else
  {
    v21 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreate", 452, 39, *v21, "malloc", v22, v23, v47);
  }
  return v9;
}

void ILowMemoryDecoderStreamDestroy(uint64_t a1)
{
  int v2;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 32);
    switch(v2)
    {
      case 3:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 72));
        break;
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 72));
        break;
      case 1:
        lzma_end();
        break;
    }
    MemBufferDestroy(*(void ***)(a1 + 56));
    MemBufferDestroy(*(void ***)(a1 + 64));
    IMagicStreamDestroy(*(void **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t ILowMemoryDecoderStreamCreateWithBuffer(uint64_t a1, uint64_t a2, size_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t result;
  char v9;

  v4 = IMemStreamCreate(a1, a2);
  if (v4)
  {
    v7 = v4;
    result = ILowMemoryDecoderStreamCreate((uint64_t (*)(uint64_t, uint64_t, unint64_t))IMemStreamRead, (uint64_t)IMemStreamAbort, (uint64_t)v4, a3);
    if (result)
    {
      *(_QWORD *)(result + 24) = v7;
      return result;
    }
    IMagicStreamDestroy(v7);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamCreateWithBuffer", 596, 39, 0, "IMemStreamCreate failed", v5, v6, v9);
  }
  return 0;
}

uint64_t ILowMemoryDecoderStreamRead(uint64_t a1, char *a2, size_t a3)
{
  int v6;
  uint64_t v7;
  unint64_t DataSize;
  size_t v9;
  const void *DataPtr;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t FreeSize;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  compression_status v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  compression_status v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v56;
  unint64_t v57;
  void *FreePtr;
  const void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t (*v97)(uint64_t, unint64_t, uint64_t, unint64_t);
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  const char *v106;
  __int16 v107;
  char v109;
  bz_stream *stream;

  if (a1)
  {
    v6 = 0;
    v7 = 0;
    stream = (bz_stream *)(a1 + 72);
    do
    {
      if (!a3)
        return v7;
      DataSize = MemBufferGetDataSize(*(_QWORD *)(a1 + 64));
      if (DataSize >= a3)
        v9 = a3;
      else
        v9 = DataSize;
      if (v9)
      {
        DataPtr = (const void *)MemBufferGetDataPtr(*(_QWORD *)(a1 + 64));
        memcpy(a2, DataPtr, v9);
        MemBufferDecreaseSize(*(_QWORD *)(a1 + 64), v9, v11, v12, v13, v14, v15, v16);
        v7 += v9;
        a3 -= v9;
        if (!a3)
          return v7;
        a2 += v9;
      }
      if (*(_DWORD *)(a1 + 208))
        return v7;
      v17 = *(unint64_t **)(a1 + 56);
      if (!*(_DWORD *)(a1 + 32))
      {
        v43 = MemBufferGetDataSize((uint64_t)v17);
        v44 = v43;
        if (v43 <= 0xF)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), 16 - v43, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(_QWORD *)(a1 + 16)) < 0)
          {
            v106 = "reading block header failed";
            v107 = 645;
            goto LABEL_76;
          }
          v44 = MemBufferGetDataSize(*(_QWORD *)(a1 + 56));
          if (!v44)
          {
            *(_DWORD *)(a1 + 208) = 1;
            return v7;
          }
        }
        v45 = (unint64_t *)MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
        v51 = *v45;
        v50 = v45[1];
        v52 = bswap64(*v45);
        v53 = bswap64(v50);
        v54 = *(_QWORD *)(a1 + 40);
        if (v52 > v54 || v53 > v54)
        {
          v106 = "invalid block header";
          v107 = 655;
          goto LABEL_76;
        }
        MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), 0x10uLL, v46, v47, v48, v49, v18, v19);
        v56 = v53 >= v44 - 16;
        v57 = v53 - (v44 - 16);
        if (v57 != 0 && v56)
        {
          if (MemBufferFillFromIStream(*(unint64_t **)(a1 + 56), v57, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(_QWORD *)(a1 + 16)) != v57)
          {
            v106 = "reading block payload failed";
            v107 = 665;
            goto LABEL_76;
          }
          MemBufferGetDataSize(*(_QWORD *)(a1 + 56));
        }
        if (v51 == v50)
        {
          FreePtr = (void *)MemBufferGetFreePtr(*(_QWORD *)(a1 + 64));
          v59 = (const void *)MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
          memcpy(FreePtr, v59, v52);
        }
        else
        {
          v97 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, unint64_t))(a1 + 48);
          v98 = MemBufferGetFreePtr(*(_QWORD *)(a1 + 64));
          v99 = MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
          if (v97(v98, v52, v99, v53) != v52)
          {
            v106 = "decoding block payload failed";
            v107 = 677;
            goto LABEL_76;
          }
        }
        MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v53, v60, v61, v62, v63, v18, v19);
        MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v52, v100, v101, v102, v103, v104, v105);
        goto LABEL_62;
      }
      if (MemBufferFillFromIStream(v17, 0xFFFFFFFFFFFFFFFFLL, *(uint64_t (**)(uint64_t, uint64_t, unint64_t))a1, *(_QWORD *)(a1 + 16)) < 0)
      {
        v106 = "reading payload failed";
        v107 = 687;
        goto LABEL_76;
      }
      v20 = MemBufferGetDataPtr(*(_QWORD *)(a1 + 56));
      v21 = MemBufferGetDataSize(*(_QWORD *)(a1 + 56));
      v22 = MemBufferGetFreePtr(*(_QWORD *)(a1 + 64));
      FreeSize = MemBufferGetFreeSize(*(_QWORD **)(a1 + 64));
      v26 = FreeSize;
      v27 = *(_DWORD *)(a1 + 32);
      switch(v27)
      {
        case 1:
          *(_QWORD *)(a1 + 72) = v20;
          *(_QWORD *)(a1 + 80) = v21;
          *(_QWORD *)(a1 + 96) = v22;
          *(_QWORD *)(a1 + 104) = FreeSize;
          v64 = lzma_code();
          v71 = v64;
          if (v64 > 0xA || ((1 << v64) & 0x403) == 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 738, 39, 0, "decoding lzma payload", v69, v70, v109);
            v81 = 1;
            goto LABEL_60;
          }
          v72 = *(_QWORD *)(a1 + 72);
          v73 = *(_QWORD *)(a1 + 96);
          MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v72 - v20, v65, v66, v67, v68, v69, v70);
          if (v73 == v22 && v72 == v20)
            ++v6;
          else
            v6 = 0;
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v73 - v22, v74, v75, v76, v77, v78, v79);
          if (v71 != 1)
          {
            v81 = 14;
LABEL_60:
            if (v71 > 0xA || ((1 << v71) & 0x403) == 0)
              continue;
            goto LABEL_62;
          }
          break;
        case 3:
          *(_QWORD *)(a1 + 72) = v20;
          *(_DWORD *)(a1 + 80) = v21;
          *(_QWORD *)(a1 + 96) = v22;
          *(_DWORD *)(a1 + 104) = FreeSize;
          v82 = BZ2_bzDecompress(stream);
          if (v82 < 0)
          {
            v106 = "decoding bzip2 payload";
            v107 = 722;
            goto LABEL_76;
          }
          v87 = v82;
          v88 = *(_QWORD *)(a1 + 72);
          v89 = *(_QWORD *)(a1 + 96);
          MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v88 - v20, v83, v84, v85, v86, v18, v19);
          if (v89 == v22 && v88 == v20)
            ++v6;
          else
            v6 = 0;
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v89 - v22, v90, v91, v92, v93, v94, v95);
          if (v87 != 4)
            goto LABEL_62;
          break;
        case 2:
          *(_QWORD *)(a1 + 88) = v20;
          *(_QWORD *)(a1 + 96) = v21;
          *(_QWORD *)(a1 + 72) = v22;
          *(_QWORD *)(a1 + 80) = FreeSize;
          v28 = compression_stream_process((compression_stream *)stream, 0);
          if (v28 < 0)
          {
            v106 = "decoding zlib payload";
            v107 = 706;
            goto LABEL_76;
          }
          v33 = v28;
          v34 = *(_QWORD *)(a1 + 96);
          v35 = *(_QWORD *)(a1 + 80);
          MemBufferDecreaseSize(*(_QWORD *)(a1 + 56), v21 - v34, v29, v30, v31, v32, v18, v19);
          if (v26 == v35 && v21 == v34)
            ++v6;
          else
            v6 = 0;
          MemBufferIncreaseSize(*(unint64_t **)(a1 + 64), v26 - v35, v36, v37, v38, v39, v40, v41);
          if (v33 != COMPRESSION_STATUS_END)
            goto LABEL_62;
          break;
        default:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", 748, 39, 0, "invalid decoder: %d", v24, v25, *(_DWORD *)(a1 + 32));
          return -1;
      }
      *(_DWORD *)(a1 + 208) = 1;
LABEL_62:
      if (v6 >= 3)
      {
        v106 = "Truncated stream";
        v107 = 753;
LABEL_76:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOCompressedStreams.c", (uint64_t)"ILowMemoryDecoderStreamRead", v107, 39, 0, v106, v18, v19, v109);
        return -1;
      }
      v81 = 0;
    }
    while (!v81);
  }
  return -1;
}

uint64_t ILowMemoryDecoderStreamAbort(uint64_t result)
{
  uint64_t v1;
  void (*v2)(_QWORD);

  if (result)
  {
    v1 = result;
    v2 = *(void (**)(_QWORD))(result + 8);
    if (v2)
      v2(*(_QWORD *)(result + 16));
    return IMemStreamAbort(*(_QWORD *)(v1 + 24));
  }
  return result;
}

size_t PCompressCopyEncode(void *a1, size_t a2, void *__src, size_t __n)
{
  size_t v4;

  if (a2 < __n)
    return -1;
  v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

size_t PCompressCopyDecode(void *a1, size_t a2, void *__src, size_t __n)
{
  size_t v4;

  if (a2 < __n)
    return -1;
  v4 = __n;
  memcpy(a1, __src, __n);
  return v4;
}

_QWORD *ISparseArchiveStreamCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int i;
  unint64_t v20;
  char *v21;
  BOOL v22;
  char *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;
  FILE **v33;
  uint64_t v34;
  unint64_t v35;
  FILE *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  __int16 v42;
  int *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _DWORD *v50;
  int v51;
  int v52;
  char v54;
  char v55;
  uint64_t v56;
  int v57;
  char __s[22];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int16 v70;
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v54);
  v57 = 0;
  v9 = calloc(1uLL, 0x40uLL);
  if (!v9)
  {
    v43 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamCreate", 46, 8, *v43, "malloc", v44, v45, v55);
    v12 = 0;
LABEL_37:
    v16 = 0;
LABEL_59:
    v51 = 0;
    goto LABEL_60;
  }
  v12 = (char *)IFileStreamCreateWithFilename(*(const char **)(a1 + 32), 0, -1);
  if (!v12)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamCreate", 50, 8, 0, "creating index file stream", v10, v11, v55);
    goto LABEL_37;
  }
  v13 = ArchiveTreeCreateFromIndex((uint64_t)IFileStreamRead, (uint64_t)v12, *(int (**)(uint64_t, _BYTE *, _QWORD))(a1 + 40), *(_QWORD *)(a1 + 48), *(_DWORD *)(a1 + 4), *(_DWORD *)a1);
  v16 = (uint64_t)v13;
  if (!v13)
  {
    v41 = "loading archive tree";
    v42 = 53;
    goto LABEL_57;
  }
  v17 = ArchiveTreeSize(v13);
  if (v17)
  {
    v18 = v17;
    for (i = 0; v18 != i; ++i)
    {
      *(_QWORD *)__s = -1;
      v56 = -1;
      if (ArchiveTreeNodeSegment(v16, i, __s, &v56))
      {
        v41 = "reading node segment";
        v42 = 61;
        goto LABEL_57;
      }
      v20 = v9[1];
      v21 = (char *)v9[3];
      if (v20)
        v22 = v21 == 0;
      else
        v22 = 1;
      if (v22)
        goto LABEL_18;
      v23 = &v21[16 * v20];
      v26 = *((_QWORD *)v23 - 1);
      v24 = (uint64_t *)(v23 - 8);
      v25 = v26;
      v27 = v26 + *(v24 - 1);
      if (v27 > *(_QWORD *)__s)
      {
        v41 = "invalid segment order";
        v42 = 67;
        goto LABEL_57;
      }
      if (v25 == -1)
      {
        v41 = "invalid segments in archive";
        v42 = 68;
        goto LABEL_57;
      }
      if (v27 != *(_QWORD *)__s)
      {
LABEL_18:
        v30 = v9[2];
        if (v20 >= v30)
        {
          v31 = v30 + (v30 >> 1);
          if (!v30)
            v31 = 32;
          v9[2] = v31;
          v21 = (char *)reallocf(v21, 16 * v31);
          v9[3] = v21;
          if (!v21)
          {
            v49 = *__error();
            v41 = "malloc";
            v42 = 78;
            goto LABEL_58;
          }
          v20 = v9[1];
        }
        v32 = &v21[16 * v20];
        *(_QWORD *)v32 = *(_QWORD *)__s;
        *((_QWORD *)v32 + 1) = v56;
        v9[1] = v20 + 1;
      }
      else
      {
        v28 = v25 + v56;
        if (v56 == -1)
          v29 = -1;
        else
          v29 = v28;
        *v24 = v29;
      }
    }
  }
  if (*(int *)a1 >= 1)
  {
    v33 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu segments to read in archive\n", v9[1]);
    if (*(int *)a1 >= 2)
    {
      if (v9[1])
      {
        v34 = 0;
        v35 = 0;
        do
        {
          v36 = *v33;
          if (*(_QWORD *)(v9[3] + v34 + 8) == -1)
            fprintf(v36, "segment=%zu offset=%llu size=<to EOF>\n");
          else
            fprintf(v36, "segment=%zu offset=%llu size=%llu\n");
          ++v35;
          v34 += 16;
        }
        while (v35 < v9[1]);
      }
    }
  }
  if (loadFileSegment(*(const char **)(a1 + 8), &v57, 4uLL, 0))
  {
    v41 = "reading archive header";
    v42 = 100;
    goto LABEL_57;
  }
  if ((unsigned __int16)v57 == 25200 && BYTE2(v57) == 122)
  {
    v70 = 0;
    v69 = 0u;
    v68 = 0u;
    v67 = 0u;
    v66 = 0u;
    v65 = 0u;
    v64 = 0u;
    v63 = 0u;
    v62 = 0u;
    v61 = 0u;
    v60 = 0u;
    v59 = 0u;
    *(_OWORD *)&__s[6] = 0u;
    strcpy(__s, "r,c=1");
    if (*(_QWORD *)(a1 + 16))
      v48 = snprintf(&__s[5], 0xC3uLL, ",o=%llu", *(_QWORD *)(a1 + 16)) + 5;
    else
      v48 = 5;
    if (*(_QWORD *)(a1 + 24) != -1)
      snprintf(&__s[v48], 200 - v48, ",s=%llu", *(_QWORD *)(a1 + 24));
    v50 = ParallelCompressionFileOpen(*(const char **)(a1 + 8), __s, v37, v38, v39, v40, v14, v15);
    v9[4] = v50;
    if (!v50)
    {
      v41 = "creating archive decoder stream";
      v42 = 110;
LABEL_57:
      v49 = 0;
LABEL_58:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamCreate", v42, 8, v49, v41, v14, v15, v55);
      goto LABEL_59;
    }
  }
  else
  {
    v47 = IFileStreamCreateWithFilename(*(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
    v9[5] = v47;
    if (!v47)
    {
      v41 = "creating archive file stream";
      v42 = 116;
      goto LABEL_57;
    }
  }
  v51 = 1;
LABEL_60:
  IFileStreamDestroy(v12);
  ArchiveTreeDestroy(v16);
  v52 = leaveThreadErrorContext(0, 0, 0);
  if (!v51 || v52 < 0)
  {
    ISparseArchiveStreamDestroy((uint64_t)v9);
    return 0;
  }
  return v9;
}

void ISparseArchiveStreamDestroy(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a1)
  {
    free(*(void **)(a1 + 24));
    ParallelCompressionFileClose(*(void **)(a1 + 32), v2, v3, v4, v5, v6, v7, v8);
    IFileStreamDestroy(*(char **)(a1 + 40));
    free((void *)a1);
  }
}

uint64_t ISparseArchiveStreamRead(_QWORD *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  char v36;

  if (a3)
  {
    v8 = a3;
    v11 = 0;
    while (1)
    {
      v12 = a1[6];
      if (v12 >= a1[1])
        return v11;
      v14 = a1[3];
      v13 = a1[4];
      v15 = v14 + 16 * v12;
      v16 = 16 * v12;
      v18 = *(_QWORD *)(v15 + 8);
      v17 = (_QWORD *)(v15 + 8);
      v19 = a1[7];
      v20 = v18 - v19;
      if (v8 >= v18 - v19)
        v21 = v20;
      else
        v21 = v8;
      v22 = *(_QWORD *)(v14 + v16);
      v23 = v22 + v19;
      if (v13)
      {
        if (ParallelCompressionFileSeek(v13, v22 + v19, 0, a4, a5, a6, a7, a8) != v23)
        {
          v33 = "seek archive decoder";
          v34 = 163;
          goto LABEL_23;
        }
        v27 = ParallelCompressionFileRead(a1[4], a2, v21, v24, v25, v26, a7, a8);
        if (v27 < 0)
          goto LABEL_20;
      }
      else
      {
        v28 = a1[5];
        if (!v28)
          goto LABEL_20;
        if (IFileStreamSetPos(v28, v22 + v19, a3, a4, a5, a6, a7, a8) != v23)
        {
          v33 = "seek file decoder";
          v34 = 168;
          goto LABEL_23;
        }
        v27 = IFileStreamRead(a1[5], a2, v21, v29, v30, v31, a7, a8);
        if (v27 < 0)
        {
LABEL_20:
          v33 = "archive read failed";
          v34 = 171;
LABEL_23:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ISparseArchiveStream.c", (uint64_t)"ISparseArchiveStreamRead", v34, 8, 0, v33, a7, a8, v36);
          return -1;
        }
      }
      if (v27)
      {
        v32 = a1[7] + v27;
        a1[7] = v32;
        if (v32 == *v17)
        {
          ++a1[6];
          a1[7] = 0;
        }
        a2 += v27;
        v11 += v27;
        v8 -= v27;
        if (v8)
          continue;
      }
      return v11;
    }
  }
  return 0;
}

uint64_t initBestMatchThreadProc()
{
  uint64_t v0;
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int i;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int *v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  _DWORD *v21;
  int v22;
  unsigned int *v23;
  _BYTE *v24;
  int v25;
  int v26;
  _DWORD *v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  BOOL v34;
  int v35;
  _BYTE *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  _DWORD *v57;
  int v58;
  int v59;
  _DWORD *v60;
  unsigned int v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int v68;
  _BYTE v70[7];
  _DWORD v71[3072];
  uint64_t v72;

  v0 = MEMORY[0x24BDAC7A8]();
  v72 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)v0;
  v2 = *(_DWORD *)(v0 + 20);
  bzero(v71, 0x3000uLL);
  bzero(v70, 0x7000uLL);
  v3 = *(_DWORD *)(v0 + 12);
  v4 = *(_DWORD *)(v0 + 16);
  v5 = *(_DWORD *)(v1 + 36);
  v6 = v5 - v2;
  if (v5 < v2)
    v6 = 0;
  if (v4 + v2 > v5)
    v4 = v6;
  if (v3 < v4)
  {
    for (i = *(_DWORD *)(v0 + 12); i < v4; ++i)
    {
      v8 = *(_QWORD *)(v1 + 48);
      v9 = *(_DWORD *)(v8 + 8 * i + 4);
      if (v9 < 0x400)
      {
        v10 = i;
        v11 = *(_QWORD *)(v1 + 24);
        v12 = 0;
        if (v2)
        {
          v13 = (int *)(v11 + i);
          v14 = v2;
          do
          {
            v15 = *v13++;
            v12 = -1640531535 * (v15 + v12) - 1640531535;
            v14 -= 4;
          }
          while (v14);
        }
        v16 = *(_QWORD *)(v0 + 32);
        v17 = v12 ^ HIWORD(v12);
        v18 = v12 >> *(_DWORD *)(v1 + 44);
        if (*(unsigned __int16 *)(v16 + 6 * v18 + 4) == (unsigned __int16)v17)
        {
          v19 = *(_DWORD *)(v16 + 6 * v18);
          if (v19 >= *(_DWORD *)(v0 + 8))
          {
            v20 = ((_WORD)i - (_WORD)v19) & 0x3FF;
            v21 = &v71[3 * (((_WORD)i - (_WORD)v19) & 0x3FF)];
            if (v19 != v21[1] + i - *v21 || v71[3 * (((_WORD)i - (_WORD)v19) & 0x3FF) + 2] + *v21 < i)
            {
              v22 = v19 & 0x3FF;
              v23 = (unsigned int *)&v70[28 * (v19 & 0x3FF)];
              if (*v23 == v19)
              {
                v24 = &v70[28 * (v19 & 0x3FF)];
                v25 = *((_DWORD *)v24 + 2);
                v26 = i - v25;
                if (v25 != *((_DWORD *)v24 + 5) + i - v25)
                  goto LABEL_26;
                v27 = &v70[28 * (v19 & 0x3FF)];
                v29 = v27[3];
                v28 = v27[4];
                v30 = v28 + v26;
                v31 = v27[1];
                if (v28 + v26 <= v31)
                  v30 = v27[1];
                v32 = (v30 + v26);
                v33 = v27[6] + v28;
                if (v33 >= v29 + v31)
                  v33 = v29 + v31;
                v34 = v33 >= v32;
                v35 = v33 - v32;
                if (v35 != 0 && v34)
                {
                  v19 = v19 - i + v32;
                  v10 = v32;
                }
                else
                {
LABEL_26:
                  v35 = 0;
LABEL_27:
                  LODWORD(v32) = i;
                }
                v37 = 0;
                if (v19 >= v32 - v3)
                  v38 = v32 - v3;
                else
                  v38 = v19;
                v39 = *(_QWORD *)(v1 + 16);
                v40 = v39 + v19;
                v41 = v11 + v10;
                v42 = -1;
                while (1)
                {
                  v37 += 8;
                  if (v37 > v38)
                    break;
                  v42 += 8;
                  v43 = *(_QWORD *)(v41 - v37) ^ *(_QWORD *)(v40 - v37);
                  if (v43)
                  {
                    v42 = v37 + (__clz(v43) >> 3) - 8;
                    goto LABEL_39;
                  }
                }
                while (1)
                {
                  v44 = v42 + 2;
                  if (v42 + 2 > v38)
                    break;
                  ++v42;
                  if (*(unsigned __int8 *)(v40 - v44) != *(unsigned __int8 *)(v41 - v44))
                    goto LABEL_39;
                }
                v42 = v38;
LABEL_39:
                v45 = v19 - v42;
                v46 = v32 - v42;
                v47 = v42 + v35;
                v48 = *(_DWORD *)(v1 + 32) - v45;
                LODWORD(v49) = *(_DWORD *)(v1 + 36) - v46;
                if (v48 >= v49)
                  v49 = v49;
                else
                  v49 = v48;
                v50 = v39 + v45;
                v51 = v11 + v46;
                while (1)
                {
                  v52 = v47 + 8;
                  if (v47 + 8 > v49)
                    break;
                  v53 = *(_QWORD *)(v50 + v47);
                  v54 = *(_QWORD *)(v51 + v47);
                  v47 += 8;
                  v55 = v54 ^ v53;
                  if (v55)
                  {
                    LODWORD(v49) = v52 + (__clz(__rbit64(v55)) >> 3) - 8;
                    goto LABEL_52;
                  }
                }
                if (v47 < v49)
                {
                  v56 = v47;
                  while (*(unsigned __int8 *)(v50 + v56) == *(unsigned __int8 *)(v51 + v56))
                  {
                    if (++v56 >= v49)
                      goto LABEL_52;
                  }
                  LODWORD(v49) = v56;
                }
LABEL_52:
                if (v49 >= v2)
                {
                  *v21 = v46;
                  v21[1] = v45;
                  v71[3 * v20 + 2] = v49;
                  v57 = &v70[28 * v22];
                  v58 = v57[1];
                  v59 = v57[3];
                  v57[5] = v25;
                  v57[6] = v59;
                  v57[1] = v46;
                  v57[2] = i;
                  v57[3] = v49;
                  v57[4] = v58;
                  v60 = (_DWORD *)(v8 + 8 * v46);
                  if (v49 > v60[1])
                  {
                    *v60 = v45;
                    *(_DWORD *)(*(_QWORD *)(v1 + 48) + 8 * v46 + 4) = v49;
                    if ((int)v49 + (int)v46 > i + 1024)
                      i = v49 + v46 - 1024;
                  }
                }
                continue;
              }
              v25 = 0;
              v35 = 0;
              *v23 = v19;
              v36 = &v70[28 * (v19 & 0x3FF)];
              *((_QWORD *)v36 + 1) = 0;
              *((_DWORD *)v36 + 1) = 0;
              goto LABEL_27;
            }
          }
        }
      }
      else
      {
        i = i + v9 - 1024;
      }
    }
  }
  if (*(_DWORD *)(v0 + 24))
  {
    v61 = *(_DWORD *)(v0 + 16);
    v62 = (*(_DWORD *)(v0 + 12) + 1);
    if (v62 < v61)
    {
      v63 = 8 * (*(_DWORD *)(v0 + 12) + 1);
      do
      {
        v64 = *(_QWORD *)(v1 + 48);
        v65 = v64 + v63;
        v66 = *(_DWORD *)(v64 + v63 - 4);
        if (v66 > v2 && v66 > *(_DWORD *)(v64 + v63 + 4))
        {
          v68 = *(_DWORD *)(v65 - 8) + 1;
          if (v68 < *(_DWORD *)(v1 + 32))
          {
            *(_DWORD *)(v64 + v63) = v68;
            *(_DWORD *)(v65 + 4) = v66 - 1;
            v61 = *(_DWORD *)(v0 + 16);
          }
        }
        ++v62;
        v63 += 8;
      }
      while (v62 < v61);
    }
  }
  return 0;
}

uint64_t BXDiffMatchesCreate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  unint64_t v10;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  int DefaultNThreads;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  _DWORD *v23;
  _DWORD *v24;
  unsigned int v25;
  _DWORD *v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  uint64_t v35;
  int *v36;
  unsigned __int8 *v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unint64_t v48;
  int *v49;
  int v50;
  uint64_t v51;
  uint64_t *v52;
  _DWORD *v53;
  unint64_t v54;
  uint64_t v55;
  int v56;
  unint64_t i;
  unsigned int v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  _DWORD *v70;
  uint64_t v71;
  unsigned int *v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  unsigned int v78;
  int v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  int v87;
  const char *v88;
  __int16 v89;
  int *v90;
  uint64_t v91;
  uint64_t v92;
  int v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  size_t v98;
  int v99;
  unsigned int v100;
  unsigned int v101;
  _DWORD *v102;
  uint64_t *v103;
  uint64_t v104;
  size_t v105;
  char v106;
  void *v107;
  char v108;
  uint64_t *v109;
  uint64_t v110;
  _DWORD *v111;
  unsigned int *v112;
  _DWORD *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t *v117;
  _DWORD *v118;
  size_t v119;
  unsigned int *v120;
  const char *v121;
  __int16 v122;
  int *v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  _DWORD *v130;
  unsigned int v131;
  unsigned int v132;
  uint64_t v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  int *v137;
  int *v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  int v142;
  unsigned int v143;
  int *v144;
  unsigned int v145;
  int v146;
  unsigned int v147;
  unsigned int v148;
  int *v149;
  unsigned int v150;
  int v151;
  __int16 v152;
  unsigned int v153;
  unsigned int *v154;
  unsigned int v155;
  unsigned int v156;
  __int16 v157;
  __int16 v158;
  char *v159;
  int v160;
  int v161;
  uint64_t v162;
  unsigned int v163;
  unsigned int v164;
  const char *v165;
  __int16 v166;
  int v167;
  _DWORD *v168;
  unsigned int v169;
  _DWORD *v170;
  uint64_t *v171;
  unint64_t v172;
  unsigned int v173;
  uint64_t v174;
  int v175;
  unsigned int v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  void *v180;
  void *v181;
  uint64_t v182;

  v182 = *MEMORY[0x24BDAC8D0];
  v177 = 0;
  v178 = 0;
  v179 = 0;
  v8 = *a5;
  if (!*a5)
    v8 = 6;
  if (a4 >= 0x4B000)
    v9 = v8;
  else
    v9 = 20;
  if (a2 > 0xFFFFFFFE || (v10 = a4, a4 >= 0xFFFFFFFF))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", 994, 92, 0, "isize,osize too large", a7, a8, v167);
    return 0;
  }
  v15 = calloc(1uLL, 0x40uLL);
  v16 = (uint64_t)v15;
  if (!v15)
  {
    v87 = *__error();
    v88 = "malloc";
    v89 = 998;
    goto LABEL_108;
  }
  v17 = *(_QWORD *)a5;
  v15[2] = a5[2];
  *(_QWORD *)v15 = v17;
  DefaultNThreads = a5[2];
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  *(_DWORD *)(v16 + 8) = DefaultNThreads;
  *(_QWORD *)(v16 + 16) = a1;
  *(_QWORD *)(v16 + 24) = a3;
  *(_DWORD *)(v16 + 32) = a2;
  *(_DWORD *)(v16 + 36) = v10;
  if ((getProfile(&v177, v9) & 0x80000000) != 0)
  {
    v167 = *a5;
    v88 = "loading profile: %d";
    v89 = 1008;
    goto LABEL_106;
  }
  if ((int)v177 >= 1)
  {
    getRealTime();
    v21 = malloc(4 * a2 + 1028);
    v22 = malloc(8 * a2);
    v23 = v22;
    if (!v21 || !v22)
    {
      v90 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"qsufsort32", 377, 92, *v90, "malloc", v91, v92, v167);
      free(v21);
      free(v23);
      *(_QWORD *)(v16 + 56) = 0;
      v89 = 1021;
      v87 = 0;
      v88 = "qsufsort32";
      goto LABEL_108;
    }
    v24 = v21 + 257;
    v21[257] = a2;
    *v22 = 0;
    if ((_DWORD)a2)
    {
      v170 = v21;
      v172 = v10;
      v174 = v16;
      v25 = 0;
      v175 = a2 ^ 0x80000000;
      v26 = v22 + 1;
      do
      {
        if (*v23 == v175)
          break;
        v27 = 0;
        v28 = -1;
        do
        {
          v29 = &v23[2 * v27];
          v30 = *v29;
          if ((v30 & 0x80000000) != 0)
          {
            LODWORD(v31) = v30 ^ 0x80000000;
          }
          else
          {
            v31 = v24[v30];
            if (v25)
            {
              if (v31 > v27)
              {
                v32 = v31 - v27;
                v33 = &v26[2 * v27];
                do
                {
                  *v33 = v24[*(v33 - 1) + v25];
                  v33 += 2;
                  --v32;
                }
                while (v32);
              }
            }
            else if (v31 > v27)
            {
              v34 = 0;
              v35 = (v31 - 1);
              v36 = &v26[2 * v35];
              v37 = (unsigned __int8 *)(a1 + v35);
              v38 = 1;
              v39 = v31;
              do
              {
                v40 = *v37--;
                v41 = __PAIR64__(v40, v34) >> 8;
                v42 = v39 + 2;
                v43 = v39 - 1;
                v44 = v41 | 0xFF;
                v34 = v38 + (v41 & 0xFFFFFF00);
                if (v42 < v31)
                  v34 = v44;
                *(v36 - 1) = v43;
                *v36 = v34;
                v36 -= 2;
                ++v38;
                v39 = v43;
              }
              while (v27 < v43);
            }
            quicksort64(v31 - v27, (unint64_t *)&v23[2 * v27], 24);
            v45 = v27 + 1;
            if (v27 + 1 <= v31)
            {
              v46 = v29[1];
              do
              {
                v47 = v46;
                if (v45 >= v31)
                  v46 = 0;
                else
                  v46 = v26[2 * v45];
                if (v47 != v46)
                {
                  if (v45 - v27 < 2)
                  {
                    if (v28 >= a2)
                      v28 = v27;
                  }
                  else if (v28 < a2)
                  {
                    v23[2 * v28] = v27 ^ 0x80000000;
                    v28 = -1;
                  }
                  if (v45 > v27)
                  {
                    v48 = v45 - (unint64_t)v27;
                    v49 = &v23[2 * v27];
                    do
                    {
                      v50 = *v49;
                      v49 += 2;
                      v24[v50] = v45;
                      --v48;
                    }
                    while (v48);
                    v27 = v45;
                  }
                }
                ++v45;
              }
              while (v45 <= v31);
            }
          }
          v27 = v31;
        }
        while (v31 < a2);
        if (v28 < a2)
          v23[2 * v28] = v175;
        if (v25 >= 3)
          v25 *= 2;
        else
          v25 = 3;
      }
      while (v25 < a2);
      v51 = 0;
      v10 = v172;
      v16 = v174;
      v21 = v170;
      do
      {
        *(_QWORD *)&v23[2 * (v24[v51] - 1)] = v51;
        ++v51;
      }
      while (a2 != v51);
    }
    if (a2)
    {
      v52 = (uint64_t *)v23;
      v53 = v24;
      v54 = a2;
      do
      {
        v55 = *v52++;
        *v53++ = v55;
        --v54;
      }
      while (v54);
    }
    v56 = 0;
    *v21 = 0;
    v21[256] = a2;
    for (i = 1; i != 256; ++i)
    {
      v58 = a2;
      if (v56 != (_DWORD)a2)
      {
        if (v56 + 1 >= a2)
        {
          v58 = a2;
        }
        else
        {
          v58 = a2;
          do
          {
            if (i <= *(unsigned __int8 *)(a1 + v24[v56 + ((v58 - v56) >> 1)]))
              v58 = v56 + ((v58 - v56) >> 1);
            else
              v56 += (v58 - v56) >> 1;
          }
          while (v58 > v56 + 1);
        }
        v59 = v24[v56];
        if (v59 != a2 && i == *(unsigned __int8 *)(a1 + v59))
          v58 = v56;
      }
      v21[i] = v58;
      v56 = v58;
    }
    free(v23);
    *(_QWORD *)(v16 + 56) = v21;
    getRealTime();
  }
  if (SHIDWORD(v177) >= 1)
  {
    v60 = malloc(8 * v10);
    *(_QWORD *)(v16 + 48) = v60;
    if (!v60)
    {
      v87 = *__error();
      v88 = "malloc";
      v89 = 1033;
      goto LABEL_108;
    }
    if (*(_DWORD *)(v16 + 36))
    {
      v61 = 0;
      v62 = 0;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v16 + 48) + v61) = 0xFFFFFFFFLL;
        ++v62;
        v61 += 8;
      }
      while (v62 < *(unsigned int *)(v16 + 36));
    }
  }
  v63 = *(_QWORD *)(v16 + 48);
  if (*(_QWORD *)(v16 + 56))
  {
    if (v63)
    {
      v65 = HIDWORD(v178);
      v64 = v179;
      getRealTime();
      v66 = *(_DWORD *)(v16 + 36);
      if (v66)
      {
        v67 = 0;
        v68 = 1;
        do
        {
          v69 = v67;
          v70 = (_DWORD *)(*(_QWORD *)(v16 + 48) + 8 * v67);
          if (v70[1] < v64)
          {
            v71 = *(_QWORD *)(v16 + 56);
            v72 = (unsigned int *)(v71 + 4 * *(unsigned __int8 *)(*(_QWORD *)(v16 + 24) + v67));
            v73 = *v72;
            v74 = v72[1] + 1;
            LODWORD(v180) = -1;
            v75 = bestMatchInRange(v16, v71 + 1028, v67, v73, v74, &v180);
            v76 = (int)v180;
            *v70 = (_DWORD)v180;
            *(_DWORD *)(*(_QWORD *)(v16 + 48) + 8 * v67 + 4) = v75;
            if (v75 >= v64)
            {
              if ((v76 + 1) < *(_DWORD *)(v16 + 32))
              {
                v77 = 8 * v68;
                v78 = v75 - 1;
                v79 = 1;
                do
                {
                  v80 = v67 + v79 < *(_DWORD *)(v16 + 36) && v78 >= v64;
                  if (!v80)
                    break;
                  *(_DWORD *)(*(_QWORD *)(v16 + 48) + v77) = v76 + v79;
                  *(_DWORD *)(*(_QWORD *)(v16 + 48) + v77 + 4) = v78;
                  v77 += 8;
                  ++v79;
                  --v78;
                }
                while ((v76 + v79) < *(_DWORD *)(v16 + 32));
              }
              if (v67 && v76)
              {
                v81 = 0;
                v82 = v67 - 1;
                v83 = 8 * v67;
                v84 = v75 + 1;
                do
                {
                  v85 = *(_QWORD *)(v16 + 48) + v83;
                  if (*(_DWORD *)(v85 - 8) != -1)
                    break;
                  if (*(unsigned __int8 *)(*(_QWORD *)(v16 + 16) + (v76 + v81 - 1)) != *(unsigned __int8 *)(*(_QWORD *)(v16 + 24) + v82 + v81))
                    break;
                  *(_DWORD *)(v85 - 8) = v76 - 1 + v81;
                  *(_DWORD *)(*(_QWORD *)(v16 + 48) + v83 - 4) = v84;
                  if (!(v82 + v81))
                    break;
                  v86 = v76 + v81--;
                  v83 -= 8;
                  ++v84;
                }
                while (v86 != 1);
              }
            }
            v66 = *(_DWORD *)(v16 + 36);
          }
          v67 += v65;
          v68 += v65;
        }
        while (v69 + v65 < v66);
      }
LABEL_185:
      getRealTime();
    }
    goto LABEL_186;
  }
  if (!v63)
  {
LABEL_186:
    if ((int)v177 >= 2)
    {
      free(*(void **)(v16 + 56));
      *(_QWORD *)(v16 + 56) = 0;
    }
    return v16;
  }
  v94 = -13;
  do
  {
    v95 = v94 + 33;
    v96 = 1 << (v94++ + 33 + v178);
  }
  while (v95 < SHIDWORD(v179) && v96 < *(_DWORD *)(v16 + 32));
  *(_DWORD *)(v16 + 40) = v94 + 32;
  *(_DWORD *)(v16 + 44) = -v94;
  v97 = v179;
  getRealTime();
  v98 = *(unsigned int *)(v16 + 8);
  v180 = 0;
  v181 = 0;
  v99 = 1;
  v101 = *(_DWORD *)(v16 + 32);
  v100 = *(_DWORD *)(v16 + 36);
  if (v101 >= v100)
    v101 = *(_DWORD *)(v16 + 36);
  if (v101 < 2 * v97)
  {
    v102 = 0;
    v103 = 0;
    goto LABEL_184;
  }
  v104 = 0;
  v105 = 6 * (1 << *(_DWORD *)(v16 + 40));
  v176 = ((v98 + v100 - 1) / v98 + 0xFFFF) & 0xFFFF0000;
  v106 = 1;
  do
  {
    v107 = calloc(1uLL, v105);
    *(&v180 + v104) = v107;
    if (!v107)
    {
      v123 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 852, 92, *v123, "malloc", v124, v125, v167);
      v102 = 0;
      v103 = 0;
LABEL_183:
      v99 = 0;
      goto LABEL_184;
    }
    v108 = ((_DWORD)v98 != 1) & v106;
    v104 = 1;
    v106 = 0;
  }
  while ((v108 & 1) != 0);
  v102 = calloc(v98, 0x28uLL);
  v109 = (uint64_t *)malloc(8 * v98);
  v103 = v109;
  if (!v102 || !v109)
  {
    v126 = *__error();
    v121 = "malloc";
    v122 = 862;
LABEL_182:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v122, 92, v126, v121, v115, v116, v167);
    goto LABEL_183;
  }
  if (!(_DWORD)v98)
    goto LABEL_129;
  v117 = v109;
  v118 = v102;
  v119 = v98;
  do
  {
    *v117++ = (uint64_t)v118;
    v118[5] = v97;
    *(_QWORD *)v118 = v16;
    v118 += 10;
    --v119;
  }
  while (v119);
  if ((_DWORD)v98 == 1)
  {
    v120 = 0;
  }
  else
  {
LABEL_129:
    v120 = ThreadPoolCreate(v98, (uint64_t)v109, (uint64_t)initBestMatchThreadProc);
    if (!v120)
    {
      v121 = "ThreadPoolCreate";
      v122 = 874;
      goto LABEL_181;
    }
  }
  v127 = *(_DWORD *)(v16 + 32);
  if (v127)
  {
    v171 = v103;
    v168 = v102;
    v128 = 0;
    v129 = 0;
    while (1)
    {
      v169 = v128;
      v130 = *(&v180 + v128);
      v80 = v127 >= v97;
      v131 = v127 - v97;
      if (!v80)
        v131 = 0;
      v173 = v129 + v96;
      if (v129 + v96 < v131)
        v131 = v129 + v96;
      v132 = v129 + 4;
      if (v129 + 4 < v131)
      {
        v133 = *(_QWORD *)(v16 + 16);
        v134 = v129;
        do
        {
          v135 = v132;
          if (v97)
          {
            v136 = 0;
            v137 = (int *)(v133 + v134);
            v138 = v137;
            v139 = v97;
            do
            {
              v140 = *v138++;
              v136 = -1640531535 * (v140 + v136) - 1640531535;
              v139 -= 4;
            }
            while (v139);
            v141 = 0;
            v142 = *(_DWORD *)(v16 + 44);
            v143 = v136 >> v142;
            v144 = (int *)((char *)v137 + 1);
            v145 = v97;
            do
            {
              v146 = *v144++;
              v141 = -1640531535 * (v146 + v141) - 1640531535;
              v145 -= 4;
            }
            while (v145);
            v147 = 0;
            v148 = v141 >> v142;
            v149 = (int *)((char *)v137 + 2);
            v150 = v97;
            do
            {
              v151 = *v149++;
              v147 = -1640531535 * (v151 + v147) - 1640531535;
              v150 -= 4;
            }
            while (v150);
            LODWORD(v110) = 0;
            v152 = HIWORD(v136) ^ v136;
            v153 = v147 >> v142;
            v154 = (unsigned int *)((char *)v137 + 3);
            v155 = v97;
            do
            {
              v156 = *v154++;
              v115 = v156;
              v110 = -1640531535 * (v156 + v110) - 1640531535;
              v155 -= 4;
            }
            while (v155);
            v157 = HIWORD(v141) ^ v141;
            v158 = HIWORD(v147) ^ v147;
            v112 = (_DWORD *)((char *)v130 + 6 * v143);
            v113 = (_DWORD *)((char *)v130 + 6 * v148);
            v111 = (_DWORD *)((char *)v130 + 6 * v153);
          }
          else
          {
            v153 = 0;
            v158 = 0;
            v143 = 0;
            v152 = 0;
            v157 = 0;
            v148 = 0;
            v110 = 0;
            v142 = *(_DWORD *)(v16 + 44);
            v111 = v130;
            v112 = v130;
            v113 = v130;
          }
          v114 = v110 ^ WORD1(v110);
          v159 = (char *)v130 + 6 * (v110 >> v142);
          *v112 = v134;
          *((_WORD *)v130 + 3 * v143 + 2) = v152;
          *v113 = v134 + 1;
          *((_WORD *)v130 + 3 * v148 + 2) = v157;
          *v111 = v134 + 2;
          *((_WORD *)v130 + 3 * v153 + 2) = v158;
          *(_DWORD *)v159 = v134 + 3;
          *((_WORD *)v159 + 2) = v110 ^ WORD1(v110);
          v132 = v135 + 4;
          v134 = v135;
        }
        while (v135 + 4 < v131);
      }
      if (v120 && (ThreadPoolSync(v120) & 0x80000000) != 0)
        break;
      if ((_DWORD)v98)
      {
        v160 = 0;
        v161 = v98;
        while (1)
        {
          v162 = v120
               ? ThreadPoolGetWorker((uint64_t)v120, v110, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116)
               : *v171;
          if (!v162)
            break;
          *(_QWORD *)(v162 + 32) = v130;
          *(_DWORD *)(v162 + 24) = v173 >= *(_DWORD *)(v16 + 32);
          *(_DWORD *)(v162 + 8) = v129;
          *(_DWORD *)(v162 + 12) = v160 * v176;
          v163 = v160 * v176 + v176;
          *(_DWORD *)(v162 + 16) = v163;
          v164 = *(_DWORD *)(v16 + 36);
          if (v160 * v176 > v164)
            *(_DWORD *)(v162 + 12) = v164;
          if (v163 > v164)
            *(_DWORD *)(v162 + 16) = v164;
          if (v120)
          {
            if ((ThreadPoolRunWorker((uint64_t)v120, v162, (uint64_t)v111, (uint64_t)v112, (uint64_t)v113, v114, v115, v116) & 0x80000000) != 0)
            {
              v165 = "ThreadPoolRunWorker";
              v166 = 920;
              goto LABEL_178;
            }
          }
          else
          {
            initBestMatchThreadProc();
          }
          ++v160;
          if (!--v161)
            goto LABEL_171;
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", 910, 92, 0, "ThreadPoolGetWorker", v115, v116, v167);
        v99 = 0;
        goto LABEL_175;
      }
LABEL_171:
      v128 = v169 ^ (v120 != 0);
      v127 = *(_DWORD *)(v16 + 32);
      v129 += v96;
      if (v173 >= v127)
      {
        v99 = 1;
LABEL_175:
        v102 = v168;
        v103 = v171;
        goto LABEL_176;
      }
    }
    v165 = "ThreadPoolSync";
    v166 = 906;
LABEL_178:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"initBestMatchFromHashes", v166, 92, 0, v165, v115, v116, v167);
    v99 = 0;
    v102 = v168;
    v103 = v171;
    goto LABEL_179;
  }
  v99 = 1;
LABEL_176:
  if (v120)
  {
LABEL_179:
    if ((ThreadPoolDestroy((uint64_t)v120) & 0x80000000) == 0)
      goto LABEL_184;
    v121 = "ThreadPoolDestroy";
    v122 = 930;
LABEL_181:
    v126 = 0;
    goto LABEL_182;
  }
LABEL_184:
  free(v102);
  free(v103);
  free(v180);
  free(v181);
  if (v99)
    goto LABEL_185;
  v88 = "initBestMatchFromHashes";
  v89 = 1069;
LABEL_106:
  v87 = 0;
LABEL_108:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"BXDiffMatchesCreate", v89, 92, v87, v88, v19, v20, v167);
  BXDiffMatchesDestroy((void **)v16);
  return 0;
}

size_t getProfile(_DWORD *a1, int a2)
{
  int v3;
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  size_t result;
  size_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  char v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  char *__endptr;

  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  if (a2)
    v3 = a2;
  else
    v3 = 6;
  switch(v3)
  {
    case 2:
      v4 = xmmword_20643F450;
      goto LABEL_10;
    case 3:
      v4 = xmmword_20643F440;
      goto LABEL_10;
    case 4:
      v4 = xmmword_20643F430;
      goto LABEL_10;
    case 5:
      v4 = xmmword_20643F420;
      goto LABEL_10;
    case 6:
      *(_OWORD *)a1 = xmmword_20643F420;
      v5 = 0x1A00000010;
      goto LABEL_30;
    case 7:
      v6 = xmmword_20643F420;
      goto LABEL_15;
    case 8:
      *(_OWORD *)a1 = xmmword_20643F410;
      v5 = 0x1A0000000CLL;
      goto LABEL_30;
    case 9:
      v6 = xmmword_20643F410;
LABEL_15:
      *(_OWORD *)a1 = v6;
      v5 = 0x1A00000008;
      goto LABEL_30;
    case 10:
      v7 = xmmword_20643F400;
      goto LABEL_24;
    case 11:
      v7 = xmmword_20643F3F0;
      goto LABEL_24;
    case 12:
      v7 = xmmword_20643F3E0;
      goto LABEL_24;
    case 13:
      v8 = xmmword_20643F3D0;
      goto LABEL_26;
    case 14:
      v8 = xmmword_20643F3C0;
      goto LABEL_26;
    case 15:
      v7 = xmmword_20643F3B0;
      goto LABEL_24;
    case 16:
      v7 = xmmword_20643F3A0;
      goto LABEL_24;
    case 17:
      v7 = xmmword_20643F390;
LABEL_24:
      *(_OWORD *)a1 = v7;
      v5 = 24;
      goto LABEL_30;
    case 18:
      v8 = xmmword_20643F390;
LABEL_26:
      *(_OWORD *)a1 = v8;
      v5 = 16;
      goto LABEL_30;
    case 19:
      *(_OWORD *)a1 = xmmword_20643F390;
      v5 = 8;
      goto LABEL_30;
    case 20:
      *a1 = 1;
      *(_QWORD *)(a1 + 3) = 0;
      *(_QWORD *)(a1 + 1) = 0;
      a1[5] = 0;
      goto LABEL_31;
    case 21:
      *(_OWORD *)a1 = xmmword_20643F420;
      v5 = 0x1800000010;
      goto LABEL_30;
    default:
      v4 = xmmword_20643F460;
LABEL_10:
      *(_OWORD *)a1 = v4;
      v5 = 0x1A00000018;
LABEL_30:
      *((_QWORD *)a1 + 2) = v5;
LABEL_31:
      result = (size_t)getenv("BXDIFF_MATCHES_PROFILE");
      if (!result)
        return result;
      v10 = result;
      result = strlen((const char *)result);
      if (!result)
        return result;
      v11 = result;
      v12 = 0;
      v13 = MEMORY[0x24BDAC740];
      break;
  }
  while (1)
  {
    v14 = __tolower(*(char *)(v10 + v12));
    v17 = v14;
    if (v14 > 0x7F)
    {
      if (__maskrune(v14, 0x4000uLL))
        goto LABEL_52;
    }
    else if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000) != 0)
    {
      goto LABEL_52;
    }
    v18 = v17 - 58;
    if (v17 - 58 > 0x39)
      goto LABEL_44;
    if (((1 << v18) & 0x224820000000000) != 0)
      break;
    if (((1 << v18) & 3) != 0)
      goto LABEL_52;
LABEL_44:
    if (v17 != 44)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 505, 92, 0, "Invalid profile code: %c", v15, v16, v17);
      goto LABEL_56;
    }
LABEL_52:
    if (v11 == ++v12)
      return 0;
  }
  __endptr = 0;
  v19 = strtol((const char *)(v10 + v12 + 1), &__endptr, 10);
  if (!*__error())
  {
    switch(v17)
    {
      case 'c':
        v22 = a1 + 1;
        goto LABEL_51;
      case 'd':
        v22 = a1 + 3;
        goto LABEL_51;
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
        goto LABEL_55;
      case 'i':
        v22 = a1 + 2;
        goto LABEL_51;
      case 'l':
        v22 = a1 + 4;
        goto LABEL_51;
      default:
        v22 = a1;
        if (v17 != 115)
        {
LABEL_55:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 515, 92, 0, "Invalid profile code: %c", v20, v21, v17);
          goto LABEL_56;
        }
LABEL_51:
        *v22 = v19;
        break;
    }
    goto LABEL_52;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"parseProfile", 508, 92, 0, "Invalid profile value: %s", v20, v21, v10 + v12 + 1);
LABEL_56:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"getProfile", 560, 92, 0, "parsing profile: %s", v23, v24, v10);
  return 0xFFFFFFFFLL;
}

void BXDiffMatchesDestroy(void **a1)
{
  if (a1)
  {
    free(a1[7]);
    free(a1[6]);
    free(a1);
  }
}

uint64_t BXDiffMatchesGetBestMatch(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t result;
  unsigned int *v9;
  unsigned int v10;

  v10 = 0;
  if (*(_DWORD *)(a1 + 36) <= a2)
  {
    v7 = 0;
    goto LABEL_6;
  }
  v5 = *(_QWORD *)(a1 + 48);
  if (v5)
  {
    v6 = (unsigned int *)(v5 + 8 * a2);
    v7 = *v6;
    v10 = v7;
    if ((_DWORD)v7 != -1)
    {
      LODWORD(result) = v6[1];
      goto LABEL_7;
    }
  }
  v7 = *(_QWORD *)(a1 + 56);
  if (!v7)
  {
LABEL_6:
    LODWORD(result) = 0;
    goto LABEL_7;
  }
  v9 = (unsigned int *)(v7 + 4 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + a2));
  result = bestMatchInRange(a1, v7 + 1028, a2, *v9, v9[1], &v10);
  v7 = v10;
  if (v5)
    *(_QWORD *)(v5 + 8 * a2) = v10 | (unint64_t)(result << 32);
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t bestMatchInRange(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, _DWORD *a6)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t result;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  int v38;
  int v39;
  int v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;

  if (a5 <= a4)
  {
    v19 = 0;
    result = 0;
  }
  else
  {
    v6 = 0;
    v7 = *(unsigned int *)(a2 + 4 * a4);
    v8 = a4;
    v9 = *(_DWORD *)(a1 + 32);
    v10 = *(_DWORD *)(a1 + 36) - a3;
    if (v10 >= v9 - (int)v7)
      v11 = (v9 - v7);
    else
      v11 = v10;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_QWORD *)(a1 + 24);
    v14 = v13 + a3;
    while (1)
    {
      v15 = v6 + 8;
      if (v6 + 8 > v11)
        break;
      v16 = *(_QWORD *)(v12 + v7 + v6);
      v17 = *(_QWORD *)(v14 + v6);
      v6 += 8;
      v18 = v17 ^ v16;
      if (v18)
      {
        LODWORD(v11) = v15 + (__clz(__rbit64(v18)) >> 3) - 8;
        goto LABEL_16;
      }
    }
    if (v6 < v11)
    {
      v21 = v11 - v6;
      v22 = (unsigned __int8 *)(v13 + a3 + v6);
      v23 = (unsigned __int8 *)(v12 + v7 + v6);
      while (1)
      {
        v25 = *v23++;
        v24 = v25;
        v26 = *v22++;
        if (v24 != v26)
          break;
        ++v6;
        if (!--v21)
          goto LABEL_16;
      }
      LODWORD(v11) = v6;
    }
LABEL_16:
    v27 = 0;
    v28 = a5 - 1;
    v29 = *(unsigned int *)(a2 + 4 * v28);
    LODWORD(v30) = v9 - v29;
    if (v10 >= v9 - (int)v29)
      v30 = v30;
    else
      v30 = v10;
    while (1)
    {
      v31 = v27 + 8;
      if (v27 + 8 > v30)
        break;
      v32 = *(_QWORD *)(v12 + v29 + v27);
      v33 = *(_QWORD *)(v14 + v27);
      v27 += 8;
      v34 = v33 ^ v32;
      if (v34)
      {
        LODWORD(v30) = v31 + (__clz(__rbit64(v34)) >> 3) - 8;
        goto LABEL_28;
      }
    }
    if (v27 < v30)
    {
      v35 = v30 - v27;
      v36 = (unsigned __int8 *)(v13 + a3 + v27);
      v37 = (unsigned __int8 *)(v12 + v29 + v27);
      while (1)
      {
        v39 = *v37++;
        v38 = v39;
        v40 = *v36++;
        if (v38 != v40)
          break;
        ++v27;
        if (!--v35)
          goto LABEL_28;
      }
      LODWORD(v30) = v27;
    }
LABEL_28:
    v41 = v28 - v8;
    if ((unint64_t)(v28 - v8) < 2)
    {
      v42 = v8;
    }
    else
    {
      do
      {
        v42 = v8 + (v41 >> 1);
        v43 = *(unsigned int *)(a2 + 4 * v42);
        LODWORD(v44) = v9 - v43;
        if (v10 >= v9 - (int)v43)
          v44 = v44;
        else
          v44 = v10;
        if (v11 >= v30)
          LODWORD(v45) = v30;
        else
          LODWORD(v45) = v11;
        v46 = v12 + v43;
        while (1)
        {
          v47 = v45 + 8;
          if ((int)v45 + 8 > v44)
            break;
          v48 = *(_QWORD *)(v46 + v45);
          v49 = *(_QWORD *)(v14 + v45);
          LODWORD(v45) = v45 + 8;
          v50 = v49 ^ v48;
          if (v50)
          {
            LODWORD(v45) = v47 + (__clz(__rbit64(v50)) >> 3) - 8;
            goto LABEL_39;
          }
        }
        if (v45 >= v44)
        {
LABEL_46:
          LODWORD(v45) = v44;
          goto LABEL_47;
        }
        v45 = v45;
        while (*(unsigned __int8 *)(v46 + v45) == *(unsigned __int8 *)(v14 + v45))
        {
          if (++v45 >= v44)
            goto LABEL_46;
        }
LABEL_39:
        if (v45 < v44
          && *(unsigned __int8 *)(v13 + v45 + a3) < *(unsigned __int8 *)(v12 + (v45 + v43)))
        {
          v28 = v42;
          v42 = v8;
          LODWORD(v30) = v45;
          goto LABEL_48;
        }
LABEL_47:
        LODWORD(v11) = v45;
        v8 = v42;
LABEL_48:
        v41 = v28 - v42;
      }
      while ((unint64_t)(v28 - v42) > 1);
    }
    if (v11 <= v30)
      v51 = v28;
    else
      v51 = v42;
    if (v11 <= v30)
      result = v30;
    else
      result = v11;
    v19 = *(_DWORD *)(a2 + 4 * v51);
  }
  *a6 = v19;
  return result;
}

uint64_t BXDiffMatchesIBuf(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t BXDiffMatchesISize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BXDiffMatchesOSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t GetBXDiffMaxMemoryUsage(unint64_t a1, unint64_t a2, int a3, int a4)
{
  int DefaultNThreads;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v16;
  char v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  DefaultNThreads = a3;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  if (!a3)
    DefaultNThreads = getDefaultNThreads();
  if (a4)
    v8 = a4;
  else
    v8 = 6;
  if (a2 >= 0x4B000)
    v9 = v8;
  else
    v9 = 20;
  if ((getProfile(&v19, v9) & 0x80000000) != 0)
  {
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffMatches.c", (uint64_t)"GetBXDiffMaxMemoryUsage", 1190, 92, "loading profile: %d", v10, v11, v12, v9);
    return 0;
  }
  else
  {
    v13 = 8 * a2;
    if (SHIDWORD(v19) <= 0)
      v13 = 0;
    if ((int)v19 < 1)
    {
      v16 = 19;
      do
      {
        v17 = v16 + 1;
        if (v16 + 1 >= SHIDWORD(v21))
          break;
        v18 = (1 << (v20 + v16++ + 1));
      }
      while (v18 < a1);
      v14 = 6 << v17 << (DefaultNThreads != 1);
    }
    else
    {
      v14 = 4 * a1;
    }
    return v14 + v13;
  }
}

unint64_t quicksort64(unint64_t result, unint64_t *a2, int a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t j;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t i;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;

  if (result >= 2)
  {
    v5 = result;
    while (2)
    {
      switch(v5)
      {
        case 2uLL:
          v32 = *a2;
          v33 = a2[1];
          if (HIDWORD(*a2) > HIDWORD(v33))
          {
            *a2 = v33;
            a2[1] = v32;
          }
          break;
        case 3uLL:
          v54 = *a2;
          v55 = a2[2];
          v56 = HIDWORD(*a2);
          if (v56 <= HIDWORD(v55))
          {
            v57 = a2[2];
            v55 = *a2;
          }
          else
          {
            v56 = HIDWORD(v55);
            *a2 = v55;
            a2[2] = v54;
            v57 = v54;
          }
          v66 = a2[1];
          if (v56 <= HIDWORD(v66))
          {
            v56 = HIDWORD(v66);
          }
          else
          {
            *a2 = v66;
            a2[1] = v55;
            v66 = v55;
          }
          if (v56 > HIDWORD(v57))
          {
            a2[1] = v57;
            a2[2] = v66;
          }
          break;
        case 4uLL:
          v35 = *a2;
          v34 = a2[1];
          if (HIDWORD(*a2) <= HIDWORD(v34))
          {
            v36 = a2[1];
            v34 = *a2;
          }
          else
          {
            *a2 = v34;
            a2[1] = v35;
            v36 = v35;
          }
          v59 = a2[2];
          v58 = a2[3];
          v60 = HIDWORD(v59);
          if (HIDWORD(v59) <= HIDWORD(v58))
          {
            v61 = a2[3];
            v58 = a2[2];
          }
          else
          {
            v60 = HIDWORD(v58);
            a2[2] = v58;
            a2[3] = v59;
            v61 = v59;
          }
          if (v60 >= HIDWORD(v34))
          {
            v34 = v58;
          }
          else
          {
            *a2 = v58;
            a2[2] = v34;
          }
          v68 = HIDWORD(v36);
          if (HIDWORD(v36) <= HIDWORD(v61))
          {
            v61 = v36;
          }
          else
          {
            v68 = HIDWORD(v61);
            a2[1] = v61;
            a2[3] = v36;
          }
          if (v68 > HIDWORD(v34))
          {
            a2[1] = v34;
            a2[2] = v61;
          }
          break;
        case 5uLL:
          v37 = *a2;
          v38 = a2[1];
          if (HIDWORD(*a2) <= HIDWORD(v38))
          {
            v39 = a2[1];
            v38 = *a2;
          }
          else
          {
            *a2 = v38;
            a2[1] = v37;
            v39 = v37;
          }
          v63 = a2[2];
          v62 = a2[3];
          v64 = HIDWORD(v63);
          if (HIDWORD(v63) <= HIDWORD(v62))
          {
            v65 = a2[3];
            v62 = a2[2];
          }
          else
          {
            v64 = HIDWORD(v62);
            a2[2] = v62;
            a2[3] = v63;
            v65 = v63;
          }
          if (v64 >= HIDWORD(v38))
          {
            v67 = v62;
            v62 = v38;
          }
          else
          {
            *a2 = v62;
            a2[2] = v38;
            v67 = v38;
          }
          v69 = a2[4];
          v70 = HIDWORD(v39);
          if (HIDWORD(v39) <= HIDWORD(v69))
          {
            v71 = a2[4];
            v69 = v39;
          }
          else
          {
            v70 = HIDWORD(v69);
            a2[1] = v69;
            a2[4] = v39;
            v71 = v39;
          }
          if (v70 >= HIDWORD(v62))
          {
            v62 = v69;
          }
          else
          {
            *a2 = v69;
            a2[1] = v62;
          }
          v72 = HIDWORD(v67);
          if (HIDWORD(v67) <= HIDWORD(v65))
          {
            v73 = v65;
            v65 = v67;
          }
          else
          {
            v72 = HIDWORD(v65);
            a2[2] = v65;
            a2[3] = v67;
            v73 = v67;
          }
          if (v72 >= HIDWORD(v62))
          {
            v62 = v65;
          }
          else
          {
            a2[1] = v65;
            a2[2] = v62;
          }
          v74 = HIDWORD(v73);
          if (HIDWORD(v73) <= HIDWORD(v71))
          {
            v71 = v73;
          }
          else
          {
            v74 = HIDWORD(v71);
            a2[3] = v71;
            a2[4] = v73;
          }
          if (v74 < HIDWORD(v62))
          {
            a2[2] = v71;
            a2[3] = v62;
          }
          break;
        default:
          if (a3 <= 0)
          {
            for (i = 1; i != v5; ++i)
            {
              v41 = a2[i];
              v42 = i;
              while (1)
              {
                v43 = v42 - 1;
                v44 = (v42 - 1) >> 1;
                v45 = a2[v44];
                if (v45 >= v41)
                  break;
                a2[v42] = v45;
                v42 = (v42 - 1) >> 1;
                if (v43 <= 1)
                  goto LABEL_63;
              }
              v44 = v42;
LABEL_63:
              a2[v44] = v41;
            }
            v46 = v5 - 1;
            v47 = a2[v5 - 1];
            a2[v5 - 1] = *a2;
            if (v5 - 1 >= 2)
            {
              do
              {
                v48 = 0;
                v49 = 0;
                v50 = 1;
                while (1)
                {
                  v51 = a2[v50];
                  v52 = v48 + 2;
                  if (v48 + 2 >= v46)
                  {
                    v52 = v50;
                  }
                  else
                  {
                    v53 = a2[v52];
                    if (v51 >= v53)
                      v52 = v50;
                    if (v51 <= v53)
                      v51 = v53;
                  }
                  if (v47 >= v51)
                    break;
                  a2[v49] = v51;
                  v48 = 2 * v52;
                  v50 = (2 * v52) | 1;
                  v49 = v52;
                  if (v50 >= v46)
                    goto LABEL_77;
                }
                v52 = v49;
LABEL_77:
                a2[v52] = v47;
                v47 = a2[--v46];
                a2[v46] = *a2;
              }
              while (v46 > 1);
            }
            *a2 = v47;
          }
          else
          {
            v6 = v5 >> 2;
            v7 = &a2[v5 >> 1];
            v8 = *a2;
            v9 = v7[-(v5 >> 2)];
            if (HIDWORD(*a2) <= HIDWORD(v9))
            {
              v10 = v7[-(v5 >> 2)];
              v9 = *a2;
            }
            else
            {
              *a2 = v9;
              v7[-(v5 >> 2)] = v8;
              v10 = v8;
            }
            v11 = *v7;
            v12 = v7[v6];
            v13 = HIDWORD(*v7);
            if (v13 <= HIDWORD(v12))
            {
              v14 = v7[v6];
              v12 = *v7;
            }
            else
            {
              v13 = HIDWORD(v12);
              *v7 = v12;
              v7[v6] = v11;
              v14 = v11;
            }
            if (v13 >= HIDWORD(v9))
            {
              v15 = v12;
              v12 = v9;
            }
            else
            {
              *a2 = v12;
              *v7 = v9;
              v15 = v9;
            }
            v16 = &a2[v5];
            v17 = *(v16 - 1);
            v18 = HIDWORD(v10);
            if (HIDWORD(v10) <= HIDWORD(v17))
            {
              v19 = *(v16 - 1);
              v17 = v10;
            }
            else
            {
              v18 = HIDWORD(v17);
              v7[-(v5 >> 2)] = v17;
              *(v16 - 1) = v10;
              v19 = v10;
            }
            if (v18 >= HIDWORD(v12))
            {
              v12 = v17;
            }
            else
            {
              *a2 = v17;
              v7[-(v5 >> 2)] = v12;
            }
            v20 = HIDWORD(v15);
            if (HIDWORD(v15) <= HIDWORD(v14))
            {
              v21 = v14;
              v14 = v15;
            }
            else
            {
              v20 = HIDWORD(v14);
              *v7 = v14;
              v7[v6] = v15;
              v21 = v15;
            }
            if (v20 >= HIDWORD(v12))
            {
              v12 = v14;
            }
            else
            {
              v7[-(v5 >> 2)] = v14;
              *v7 = v12;
            }
            v22 = HIDWORD(v21);
            if (HIDWORD(v21) <= HIDWORD(v19))
            {
              v19 = v21;
            }
            else
            {
              v22 = HIDWORD(v19);
              v7[v6] = v19;
              *(v16 - 1) = v21;
            }
            if (v22 < HIDWORD(v12))
            {
              *v7 = v19;
              v7[v6] = v12;
            }
            v23 = 0;
            v24 = *((unsigned int *)v7 + 1);
            v25 = a2 - 1;
            v26 = v5;
            while (1)
            {
              if (v23 < v5)
              {
                while (HIDWORD(a2[v23]) < v24)
                {
                  if (v5 == ++v23)
                  {
                    v23 = v5;
                    goto LABEL_36;
                  }
                }
              }
              do
              {
LABEL_36:
                v27 = v26;
                if (!v26)
                  break;
                --v26;
              }
              while (HIDWORD(v25[v27]) >= v24);
              if (v23 >= v27)
                break;
              if (v23 + 1 != v27)
              {
                v28 = a2[v23];
                a2[v23] = v25[v27];
                v25[v27] = v28;
              }
              v26 = v27 - 1;
              ++v23;
            }
            for (j = v27; j < v5; ++j)
            {
              v30 = a2[j];
              if (v24 == HIDWORD(v30))
              {
                if (j != v27)
                {
                  v31 = a2[v27];
                  a2[v27] = v30;
                  a2[j] = v31;
                }
                ++v27;
              }
            }
            --a3;
            result = quicksort64();
            v5 -= v27;
            a2 += v27;
            if (v5 >= 2)
              continue;
          }
          break;
      }
      break;
    }
  }
  return result;
}

AAByteStream AACompressionOutputStreamOpen(AAByteStream compressed_stream, AACompressionAlgorithm compression_algorithm, size_t block_size, AAFlagSet flags, int n_threads)
{
  _QWORD *v9;
  uint64_t *v10;
  void *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  __int16 v21;
  unsigned int *v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v32;
  _BYTE buf[3];
  char v34;
  unint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v9 = calloc(1uLL, 0x68uLL);
  if (!v9)
  {
    v16 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"AACompressionOutputStreamOpen", 254, 19, *v16, "malloc", v17, v18, v32);
    v10 = 0;
LABEL_37:
    free(v9);
    aaCompressionOutputStreamClose(v10, v24, v25, v26, v27, v28, v29, v30);
    return 0;
  }
  v10 = (uint64_t *)calloc(1uLL, 0x30uLL);
  if (!v10)
  {
    v19 = *__error();
    v20 = "malloc";
    v21 = 256;
LABEL_36:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"AACompressionOutputStreamOpen", v21, 19, v19, v20, v13, v14, v32);
    goto LABEL_37;
  }
  if (!n_threads)
    n_threads = getDefaultNThreads();
  *((_DWORD *)v10 + 2) = n_threads;
  v11 = calloc(n_threads, 8uLL);
  v10[2] = (uint64_t)v11;
  if (*((_DWORD *)v10 + 2))
  {
    v12 = 0;
    while (1)
    {
      *(_QWORD *)(v10[2] + 8 * v12) = CompressionWorkerDataCreate(block_size, (compression_algorithm)compression_algorithm);
      v15 = v10[2];
      if (!*(_QWORD *)(v15 + 8 * v12))
        break;
      ++v12;
      v11 = (void *)*((unsigned int *)v10 + 2);
      if (v12 >= (unint64_t)v11)
        goto LABEL_13;
    }
    v20 = "Worker data allocation";
    v21 = 264;
    goto LABEL_35;
  }
  v15 = (uint64_t)v11;
  LODWORD(v11) = 0;
LABEL_13:
  v22 = ThreadPipelineCreate(v11, v15, (uint64_t)CompressionWorkerProc, (uint64_t)v10, (uint64_t)CompressionConsumerProc, 0);
  *v10 = (uint64_t)v22;
  if (!v22)
  {
    v20 = "Thread allocation";
    v21 = 267;
LABEL_35:
    v19 = 0;
    goto LABEL_36;
  }
  v10[3] = (uint64_t)compressed_stream;
  qmemcpy(buf, "pbz", sizeof(buf));
  v23 = 122;
  if ((int)compression_algorithm <= 1284)
  {
    if (compression_algorithm)
    {
      if (compression_algorithm == 256)
      {
        v23 = 52;
      }
      else
      {
        if (compression_algorithm != 774)
          goto LABEL_34;
        v23 = 120;
      }
    }
    else
    {
      v23 = 45;
    }
  }
  else
  {
    if ((int)compression_algorithm <= 2048)
    {
      if (compression_algorithm == 1285)
        goto LABEL_31;
      if (compression_algorithm == 1794)
      {
        v23 = 98;
        goto LABEL_31;
      }
LABEL_34:
      v20 = "Invalid compression algorithm";
      v21 = 274;
      goto LABEL_35;
    }
    if (compression_algorithm == 2049)
    {
      v23 = 101;
    }
    else
    {
      if (compression_algorithm != 2304)
        goto LABEL_34;
      v23 = 102;
    }
  }
LABEL_31:
  v34 = v23;
  v35 = bswap64(block_size);
  if (AAByteStreamWrite(compressed_stream, buf, 0xCuLL) != 12)
  {
    v20 = "writing stream magic";
    v21 = 277;
    goto LABEL_35;
  }
  v9[3] = aaCompressionOutputStreamWrite;
  v9[7] = aaCompressionOutputStreamAbort;
  *v9 = v10;
  v9[1] = aaCompressionOutputStreamClose;
  v9[9] = aaCompressionOutputStreamFlush;
  return (AAByteStream)v9;
}

_QWORD *CompressionWorkerDataCreate(size_t a1, compression_algorithm a2)
{
  __int16 v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  void *v12;
  void *v13;
  size_t v14;
  void *v15;
  char v16;

  v4 = 56;
  v5 = calloc(1uLL, 0x38uLL);
  v6 = v5;
  if (!v5)
    goto LABEL_5;
  v5[1] = 0;
  v5[2] = 0;
  *v5 = a1;
  if (a1 >= 0x2000000001)
  {
    *__error() = 12;
    v6[3] = 0;
    *__error() = 12;
    v7 = v6 + 4;
    v4 = 62;
LABEL_4:
    *v7 = 0;
LABEL_5:
    v8 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"CompressionWorkerDataCreate", v4, 19, *v8, "malloc", v9, v10, v16);
    CompressionWorkerDataDestroy((void **)v6);
    return 0;
  }
  v12 = malloc(a1);
  v6[3] = v12;
  v13 = malloc(a1);
  v6[4] = v13;
  v4 = 62;
  if (!v12 || !v13)
    goto LABEL_5;
  *((_DWORD *)v6 + 10) = a2;
  if (a2)
  {
    if (a2 != COMPRESSION_LZMA)
    {
      v14 = compression_encode_scratch_buffer_size(a2);
      if (v14)
      {
        if (v14 < 0x2000000001)
        {
          v15 = malloc(v14);
          v6[6] = v15;
          if (v15)
            return v6;
          v4 = 68;
          goto LABEL_5;
        }
        *__error() = 12;
        v7 = v6 + 6;
        v4 = 68;
        goto LABEL_4;
      }
    }
  }
  return v6;
}

uint64_t CompressionWorkerProc(uint64_t a1)
{
  size_t v2;
  compression_algorithm v3;
  int64_t v4;
  size_t v5;
  BOOL v6;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 40);
  if (!v3
    || (v3 != COMPRESSION_LZMA
      ? (v5 = compression_encode_buffer(*(uint8_t **)(a1 + 32), *(_QWORD *)a1, *(const uint8_t **)(a1 + 24), v2, *(void **)(a1 + 48), v3)): (v4 = PCompressLZMA6Encode(*(uint8_t **)(a1 + 32), *(_QWORD *)a1, *(const uint8_t **)(a1 + 24), v2), v5 = v4 & ~(v4 >> 63)), v5 ? (v6 = v5 + (v2 >> 4) >= v2) : (v6 = 1), v6))
  {
    memcpy(*(void **)(a1 + 32), *(const void **)(a1 + 24), v2);
    v5 = v2;
  }
  *(_QWORD *)(a1 + 16) = v5;
  return 0;
}

uint64_t CompressionConsumerProc(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __int16 v7;
  int8x16_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(a1 + 40))
  {
    v8 = vrev64q_s8(*(int8x16_t *)(a2 + 8));
    if (AAByteStreamWrite(*(AAByteStream *)(a1 + 24), &v8, 0x10uLL) == 16)
    {
      if (AAByteStreamWrite(*(AAByteStream *)(a1 + 24), *(const void **)(a2 + 32), *(_QWORD *)(a2 + 16)) == *(_QWORD *)(a2 + 16))
        return 0;
      v7 = 119;
    }
    else
    {
      v7 = 115;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"CompressionConsumerProc", v7, 19, 0, "Stream write failed", v4, v5, v8.i8[0]);
    *(_DWORD *)(a1 + 40) = 1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t aaCompressionOutputStreamWrite(uint64_t a1, uint64_t __src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  char *v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t Worker;
  size_t v15;
  uint64_t v16;
  size_t v17;
  const char *v18;
  __int16 v19;
  char v21;

  if (!a3)
    return 0;
  v8 = a3;
  v9 = (char *)__src;
  v11 = 0;
  while (1)
  {
    v12 = *(uint64_t **)(a1 + 32);
    if (v12)
    {
      v13 = v12[1];
      goto LABEL_7;
    }
    Worker = ThreadPipelineGetWorker(*(_QWORD *)a1, __src, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 32) = Worker;
    if (!Worker)
      break;
    v12 = (uint64_t *)Worker;
    v13 = 0;
    *(_QWORD *)(Worker + 8) = 0;
    *(_QWORD *)(Worker + 16) = 0;
LABEL_7:
    if (*v12 - v13 >= v8)
      v15 = v8;
    else
      v15 = *v12 - v13;
    memcpy((void *)(v12[3] + v13), v9, v15);
    v16 = *v12;
    v17 = v12[1] + v15;
    v12[1] = v17;
    if (v17 == v16)
    {
      if ((ThreadPipelineRunWorker(*(_QWORD *)a1, *(_QWORD *)(a1 + 32), a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        v18 = "running worker";
        v19 = 186;
        goto LABEL_18;
      }
      *(_QWORD *)(a1 + 32) = 0;
    }
    v9 += v15;
    v11 += v15;
    v8 -= v15;
    if (!v8)
      return v11;
  }
  v18 = "getting next worker";
  v19 = 168;
LABEL_18:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamWrite", v19, 19, 0, v18, a7, a8, v21);
  *(_DWORD *)(a1 + 40) = 1;
  return -1;
}

uint64_t aaCompressionOutputStreamAbort(uint64_t result)
{
  *(_DWORD *)(result + 40) = 1;
  return result;
}

uint64_t *aaCompressionOutputStreamClose(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;

  if (result)
  {
    v8 = result;
    v9 = result[4];
    if (v9)
    {
      if ((ThreadPipelineRunWorker(*result, v9, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamClose", 133, 19, 0, "RunWorker", v10, v11, v20);
        v12 = 0;
      }
      else
      {
        v12 = 1;
      }
      v8[4] = 0;
    }
    else
    {
      v12 = 1;
    }
    if ((ThreadPipelineDestroy(*v8) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamClose", 138, 19, 0, "Thread shutdown", v13, v14, v20);
      v12 = 0;
    }
    v15 = (void *)v8[2];
    if (v15)
    {
      if (*((_DWORD *)v8 + 2))
      {
        v16 = 0;
        do
          CompressionWorkerDataDestroy(*(void ***)(v8[2] + 8 * v16++));
        while (v16 < *((unsigned int *)v8 + 2));
        v15 = (void *)v8[2];
      }
      free(v15);
    }
    if (*((_DWORD *)v8 + 11)
      && (AAByteStreamSeek((AAByteStream)v8[3], 0, 1) < 0 || (AAByteStreamTruncate((_QWORD *)v8[3]) & 0x80000000) != 0))
    {
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamClose", 151, 19, "Truncate on compressed stream failed", v17, v18, v19, v20);
    }
    free(v8);
    if (v12)
      return 0;
    else
      return (uint64_t *)0xFFFFFFFFLL;
  }
  return result;
}

uint64_t aaCompressionOutputStreamFlush(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  off_t v4;
  off_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v10;
  __int16 v11;
  char v12;

  if (*(_DWORD *)(a1 + 40))
    return 0xFFFFFFFFLL;
  if ((ThreadPipelineFlush(*(_QWORD *)a1) & 0x80000000) != 0)
  {
    v10 = "ThreadPipelineFlush";
    v11 = 209;
LABEL_15:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamFlush", v11, 19, 0, v10, v2, v3, v12);
    *(_DWORD *)(a1 + 40) = 1;
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(a1 + 32))
  {
    v4 = AAByteStreamSeek(*(AAByteStream *)(a1 + 24), 0, 1);
    if (v4 < 0)
    {
      v10 = "AAByteStreamSeek";
      v11 = 216;
    }
    else
    {
      v5 = v4;
      CompressionWorkerProc(*(_QWORD *)(a1 + 32));
      if ((CompressionConsumerProc(a1, *(_QWORD *)(a1 + 32)) & 0x80000000) != 0)
      {
        v10 = "CompressionConsumerProc";
        v11 = 220;
      }
      else
      {
        if (v5 == AAByteStreamSeek(*(AAByteStream *)(a1 + 24), v5, 0))
        {
          *(_DWORD *)(a1 + 44) = 1;
          goto LABEL_8;
        }
        v10 = "AAByteStreamSeek";
        v11 = 223;
      }
    }
    goto LABEL_15;
  }
LABEL_8:
  if ((AAByteStreamFlush(*(_QWORD **)(a1 + 24)) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACompressionStream.c", (uint64_t)"aaCompressionOutputStreamFlush", 230, 19, "Flush on underlying stream failed", v6, v7, v8, v12);
  return 0;
}

void CompressionWorkerDataDestroy(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    free(a1[4]);
    free(a1[6]);
    free(a1);
  }
}

uint64_t ParallelArchiveGenerateMSUBOM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return generateBOM(a1, 1, a3, a4, a5, a6, a7, a8);
}

uint64_t generateBOM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int DefaultNThreads;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  size_t v35;
  size_t v36;
  size_t v37;
  int *v38;
  int v39;
  uint64_t i;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t j;
  uint64_t v49;
  _DWORD *v50;
  char *v51;
  _DWORD *v52;
  int v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  _DWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  char *v65;
  int v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  const char *v71;
  __int16 v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  unsigned int v84;
  uint64_t result;
  FILE **v86;
  const char *v87;
  uint64_t v88;
  size_t v89;
  unsigned int v90;
  const char *v91;
  size_t v92;
  FILE **v93;
  ssize_t v94;
  size_t v95;
  uint64_t v96;
  unint64_t k;
  size_t v98;
  uint64_t v99;
  unsigned int v100;
  unint64_t v101;
  FILE **v102;
  char v103;
  char v104;
  _DWORD v105[2];
  uint64_t v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  _DWORD *v111;
  uint64_t v112;
  _DWORD v113[2];
  __int128 v114;
  int __fd[4];
  int v116[2];
  void *v117;
  int v118[2];
  void *v119;
  size_t __count;
  size_t v121;
  size_t v122;
  void *v123;
  void *v124;
  unsigned int v125;
  unsigned int v126;
  _DWORD v127[4];
  size_t v128[3];
  int v129;
  uint64_t v130;
  int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  int8x8_t v135;
  int v136;
  _BYTE v137[24];
  unint64_t v138;
  unint64_t v139;
  size_t v140;
  _DWORD __buf[281];
  uint64_t v142;

  v8 = a2;
  v142 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v103);
  bzero(__fd, 0x4D8uLL);
  v113[0] = *(_DWORD *)a1;
  v113[1] = v8;
  v114 = *(_OWORD *)(a1 + 48);
  v110 = 0u;
  v109 = 0u;
  v108 = 0u;
  v107 = 0u;
  DefaultNThreads = *(_DWORD *)(a1 + 16);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v105[0] = 0;
  v105[1] = DefaultNThreads;
  v15 = *(_QWORD *)(a1 + 40);
  v106 = *(_QWORD *)(a1 + 24);
  v111 = v113;
  *((_QWORD *)&v107 + 1) = v15;
  *(_QWORD *)&v108 = bomBeginProc;
  if (storeBlock((uint64_t)v113, 0, 0, __buf, v10, v11, v12, v13))
  {
    v23 = "alloc first block";
    v24 = 929;
LABEL_70:
    v83 = 0;
    goto LABEL_71;
  }
  v25 = ParallelArchiveRead((uint64_t)v105, v16, v17, v18, v19, v20, v21, v22);
  if (v25 | v129)
  {
    v23 = "ParallelArchiveRead";
    v24 = 934;
    goto LABEL_70;
  }
  qsort(v117, *(size_t *)v116, 0x30uLL, (int (__cdecl *)(const void *, const void *))BOMEntryCompareProc);
  if (createTree((uint64_t)v113, *(unint64_t *)v116, (void (*)(uint64_t, unint64_t, int8x8_t *))getPathsPK, (uint64_t)v113, 0x1000uLL, &v125, v26, v27))
  {
    v23 = "path_tree";
    v24 = 940;
    goto LABEL_70;
  }
  if (!__count)
  {
    v66 = createTree((uint64_t)v113, 0, 0, 0, 0x1000uLL, &v126, v21, v22);
    goto LABEL_62;
  }
  v28 = (char *)calloc(2 * __count, 4uLL);
  if (!v28)
  {
    v67 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createHLinks", 499, 52, *v67, "malloc", v68, v69, v104);
    v34 = 0;
    goto LABEL_60;
  }
  v29 = calloc(__count, 8uLL);
  v34 = v29;
  if (!v29)
  {
    v70 = *__error();
    v71 = "malloc";
    v72 = 501;
    goto LABEL_59;
  }
  v35 = *(_QWORD *)v116;
  if (!*(_QWORD *)v116)
  {
    if (!__count)
    {
LABEL_47:
      v59 = 0;
LABEL_48:
      if (v113[0] >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%zu clusters in main hlinks tree\n", v59);
      if (createTree((uint64_t)v113, v59, (void (*)(uint64_t, unint64_t, int8x8_t *))getTablePK, (uint64_t)v28, 0x1000uLL, &v126, v32, v33))
      {
        v71 = "hlink_tree";
        v72 = 577;
        goto LABEL_58;
      }
      v66 = 0;
      goto LABEL_61;
    }
LABEL_45:
    v71 = "mismatch in hlink entry count";
    v72 = 511;
    goto LABEL_58;
  }
  v36 = 0;
  v37 = 0;
  v38 = (int *)((char *)v117 + 36);
  do
  {
    v39 = *v38;
    v38 += 12;
    if (v39 != -1)
    {
      if (v36 >= __count)
      {
        v71 = "mismatch in hlink entry count";
        v72 = 508;
        goto LABEL_58;
      }
      v29[v36++] = v37;
      v35 = *(_QWORD *)v116;
    }
    ++v37;
  }
  while (v37 < v35);
  if (v36 != __count)
    goto LABEL_45;
  if (!v36)
    goto LABEL_47;
  for (i = 0; i != v36; ++i)
  {
    v41 = v34[i];
    if (*((_DWORD *)v117 + 12 * v41 + 9) != -1)
    {
      v42 = (char *)v117 + 48 * v41;
      bzero((char *)__buf + 2, 0x462uLL);
      LOWORD(__buf[0]) = 12078;
      __memcpy_chk();
      v43 = *((_QWORD *)v42 + 1);
      *((_BYTE *)__buf + v43 + 2) = 0;
      if (storeBlock((uint64_t)v113, __buf, v43 + 3, (_DWORD *)v42 + 10, v44, v45, v46, v47))
      {
        v71 = "hlink_path";
        v72 = 525;
        goto LABEL_58;
      }
    }
  }
  for (j = 0; j != v36; ++j)
  {
    v49 = v34[j];
    v50 = v117;
    v51 = (char *)v117 + 48 * v49;
    v53 = *((_DWORD *)v51 + 4);
    v52 = v51 + 16;
    if (v52[5] == v53)
    {
      v54 = 0;
      v55 = 0;
      do
      {
        v56 = v34[v54];
        if (v50[12 * v56 + 9] == *v52)
        {
          v57 = &v28[8 * v55];
          *(_DWORD *)v57 = 0;
          *((_DWORD *)v57 + 1) = v50[12 * v56 + 10];
          ++v55;
        }
        ++v54;
      }
      while (v36 != v54);
      if (v113[0] > 1)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%zu entries in hlinks cluster %zu\n", v55, j);
      if (createTree((uint64_t)v113, v55, (void (*)(uint64_t, unint64_t, int8x8_t *))getTablePK, (uint64_t)v28, 0x40uLL, &v50[12 * v49 + 11], v32, v33))
      {
        v71 = "hlink_cluster_tree";
        v72 = 551;
        goto LABEL_58;
      }
    }
  }
  v58 = 0;
  v59 = 0;
  while (1)
  {
    v60 = v117;
    v61 = v34[v58];
    if (*((_DWORD *)v117 + 12 * v61 + 9) == *((_DWORD *)v117 + 12 * v61 + 4))
      break;
LABEL_39:
    if (v36 == ++v58)
      goto LABEL_48;
  }
  v112 = 0;
  __buf[0] = bswap32(*((_DWORD *)v117 + 12 * v61 + 11));
  if (storeBlock((uint64_t)v113, __buf, 4uLL, (_DWORD *)&v112 + 1, v30, v31, v32, v33))
  {
    v72 = 567;
    goto LABEL_57;
  }
  __buf[0] = bswap32(v60[12 * v61 + 7]);
  if (!storeBlock((uint64_t)v113, __buf, 4uLL, &v112, v62, v63, v32, v33))
  {
    v64 = v112;
    v65 = &v28[8 * v59];
    *(_DWORD *)v65 = HIDWORD(v112);
    *((_DWORD *)v65 + 1) = v64;
    ++v59;
    goto LABEL_39;
  }
  v72 = 569;
LABEL_57:
  v71 = "storeBlock";
LABEL_58:
  v70 = 0;
LABEL_59:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createHLinks", v72, 52, v70, v71, v32, v33, v104);
LABEL_60:
  v66 = -1;
LABEL_61:
  free(v34);
  free(v28);
LABEL_62:
  if (v66)
  {
    v23 = "hlinks";
    v24 = 943;
    goto LABEL_70;
  }
  if (createTree((uint64_t)v113, *(unint64_t *)v118, (void (*)(uint64_t, unint64_t, int8x8_t *))getSize64PK, (uint64_t)v113, 0x80uLL, v127, v21, v22))
  {
    v23 = "size64_tree";
    v24 = 946;
    goto LABEL_70;
  }
  if (createBomInfo((uint64_t)v113, v73, v74, v75, v76, v77, v21, v22))
  {
    v23 = "bom_info";
    v24 = 949;
    goto LABEL_70;
  }
  if (createVIndex((uint64_t)v113, v78, v79, v80, v81, v82, v21, v22))
  {
    v23 = "vindex";
    v24 = 952;
    goto LABEL_70;
  }
  if (v113[0] >= 1)
  {
    v86 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu entries in BOM\n", *(size_t *)v116);
    fprintf(*v86, "%12zu hard link entries\n", __count);
    fprintf(*v86, "%12zu hard link clusters\n", v121);
    fprintf(*v86, "%12zu blocks allocated\n", v122);
    fprintf(*v86, "%12zu B in state blob storage\n", v128[1]);
  }
  v124 = calloc(v122, 8uLL);
  if (!v124)
  {
    v83 = *__error();
    v23 = "malloc";
    v24 = 967;
    goto LABEL_71;
  }
  v87 = *(const char **)(a1 + 8);
  if (!v87)
  {
    v23 = "No output_file given";
    v24 = 970;
    goto LABEL_70;
  }
  v104 = -92;
  __fd[0] = open(v87, 1537);
  if (__fd[0] < 0)
  {
    v83 = *__error();
    v23 = *(const char **)(a1 + 8);
    v24 = 972;
    goto LABEL_71;
  }
  v88 = 0;
  v136 = 83886080;
  *(_OWORD *)v137 = xmmword_20643F4E0;
  v89 = 516;
  do
  {
    switch(v88)
    {
      case 0:
        v90 = v127[2];
        v91 = "BomInfo";
        break;
      case 1:
        v90 = v125;
        v91 = "Paths";
        break;
      case 2:
        v90 = v126;
        v91 = "HLIndex";
        break;
      case 3:
        v90 = v127[0];
        v91 = "Size64";
        break;
      case 4:
        v90 = v127[3];
        v91 = "VIndex";
        break;
      default:
        v23 = "invalid entry?";
        v24 = 993;
        goto LABEL_70;
    }
    v92 = strlen(v91);
    *(_DWORD *)((char *)&v130 + v89) = bswap32(v90);
    *(_QWORD *)v137 += 4;
    *((_BYTE *)&v130 + (*(_QWORD *)v137)++) = v92 + 1;
    memcpy((char *)&v130 + *(_QWORD *)v137, v91, v92);
    *(_QWORD *)v137 += v92;
    *((_BYTE *)&v130 + *(_QWORD *)v137) = 0;
    v89 = ++*(_QWORD *)v137;
    ++v88;
  }
  while (v88 != 5);
  *(_QWORD *)&v137[16] = v89 - *(_QWORD *)&v137[8];
  if (v113[0] >= 1)
  {
    v93 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu B written for header\n", *(size_t *)&v137[8]);
    fprintf(*v93, "%12zu B written for TOC\n", *(size_t *)&v137[16]);
    v89 = *(_QWORD *)v137;
  }
  v94 = write(__fd[0], &v130, v89);
  if (v94 != *(_QWORD *)v137)
  {
    v83 = *__error();
    v23 = "write";
    v24 = 1008;
    goto LABEL_71;
  }
  v95 = v122;
  if ((_DWORD)v122)
  {
    v96 = 0;
    for (k = 0; k < v95; ++k)
    {
      v98 = *((_QWORD *)v123 + v96 + 1);
      if (v98)
      {
        if ((v94 | v98) >> 32)
        {
          v23 = "overflow in offset,size";
          v24 = 1016;
          goto LABEL_70;
        }
        if (write(__fd[0], (const void *)(v128[2] + *((_QWORD *)v123 + v96)), v98) != v98)
        {
          v83 = *__error();
          v23 = "write";
          v24 = 1018;
          goto LABEL_71;
        }
        v99 = (4 * v96) & 0x3FFFFFFF8;
        *(_DWORD *)((char *)v124 + v99) = bswap32(*(unsigned int *)v137);
        *(_DWORD *)((char *)v124 + v99 + 4) = bswap32(v98);
        v95 = v122;
        v94 = *(_QWORD *)v137 + v98;
        *(_QWORD *)v137 += v98;
        v140 += v98;
      }
      v96 += 2;
    }
  }
  if (v113[0] >= 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu B written for blocks\n", v140);
    v95 = v122;
    v94 = *(_QWORD *)v137;
  }
  v138 = v94;
  __buf[0] = bswap32(v95);
  if (write(__fd[0], __buf, 4uLL) != 4)
  {
    v83 = *__error();
    v23 = "write";
    v24 = 1033;
    goto LABEL_71;
  }
  *(_QWORD *)v137 += 4;
  if (write(__fd[0], v124, 8 * v95) != 8 * v95)
  {
    v83 = *__error();
    v23 = "write";
    v24 = 1036;
LABEL_71:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"generateBOM", v24, 52, v83, v23, v21, v22, v104);
    v84 = -1;
    goto LABEL_72;
  }
  *(_QWORD *)v137 += 8 * v95;
  __buf[0] = 0;
  if (write(__fd[0], __buf, 4uLL) != 4)
  {
    v83 = *__error();
    v23 = "write";
    v24 = 1040;
    goto LABEL_71;
  }
  *(_QWORD *)v137 += 4;
  v100 = v138;
  v101 = *(_QWORD *)v137 - v138;
  v139 = *(_QWORD *)v137 - v138;
  if (HIDWORD(v138) || HIDWORD(v101))
  {
    v23 = "overflow in offset,size";
    v24 = 1045;
    goto LABEL_70;
  }
  if (v113[0] >= 1)
  {
    v102 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu B written for blocks table\n", *(_QWORD *)v137 - v138);
    fprintf(*v102, "%12zu B final BOM size\n", *(size_t *)v137);
    v100 = v138;
    LODWORD(v101) = v139;
  }
  v131 = 0x1000000;
  v132 = bswap32(v122);
  v130 = 0x65726F74534D4F42;
  v133 = bswap32(v100);
  v134 = bswap32(v101);
  v135 = vrev32_s8((int8x8_t)vmovn_s64(*(int64x2_t *)&v137[8]));
  if (pwrite(__fd[0], &v130, 0x200uLL, 0) != 512)
  {
    v83 = *__error();
    v23 = "write";
    v24 = 1064;
    goto LABEL_71;
  }
  v84 = 0;
LABEL_72:
  BlobBufferFree((uint64_t)v128);
  free(v117);
  free(v119);
  free(v123);
  free(v124);
  if ((__fd[0] & 0x80000000) == 0)
    close(__fd[0]);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v84;
  else
    return result;
}

uint64_t ParallelArchiveGenerateBOM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return generateBOM(a1, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t bomBeginProc(uint64_t result, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  BOOL v9;
  int v10;
  BOOL v11;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  uint64_t (*v16)(_QWORD, char *, _QWORD);
  int v17;
  char *v18;
  size_t v19;
  size_t v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  size_t v27;
  size_t v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  char *v38;
  int v39;
  unsigned int *v40;
  unsigned int *v41;
  char *v42;
  int v43;
  char *v44;
  int v45;
  const char *v46;
  int v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  int *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  unsigned int *v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  int v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  __int16 v82;
  char v83;
  size_t v84;
  unsigned int v85;
  size_t v86;
  size_t v87;
  uint64_t IsCompressed;
  char *v89;
  uint64_t v90;
  char *v91;
  char *v92;
  BOOL v93;
  size_t v94;
  _BYTE v95[14];
  int32x2_t v96;
  char v97;
  unsigned int v98[276];
  char __s[1024];
  uint64_t v100;

  v100 = *MEMORY[0x24BDAC8D0];
  v8 = a2[1] - 77;
  v9 = v8 > 6;
  v10 = (1 << v8) & 0x49;
  v11 = v9 || v10 == 0;
  if (!v11)
    return result;
  v13 = result;
  if ((*((_BYTE *)a2 + 1) & 0x80) == 0)
  {
    v14 = "missing PAT field";
    v15 = 622;
LABEL_42:
    v43 = 0;
LABEL_43:
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"bomBeginProc", v15, 52, v43, v14, a7, a8, (char)v91);
    ++*(_DWORD *)(v13 + 184);
    return result;
  }
  __strlcpy_chk();
  v16 = *(uint64_t (**)(_QWORD, char *, _QWORD))(v13 + 8);
  if (v16)
  {
    result = v16(*(_QWORD *)(v13 + 16), __s, a2[1]);
    if ((int)result < 1)
      return result;
  }
  v17 = a2[1];
  if (v17 == 68 && !__s[0])
    strcpy(__s, ".");
  v18 = __s;
  v19 = strlen(__s);
  v20 = v19;
  if (!v19)
  {
    v94 = 0;
LABEL_24:
    v23 = *(_QWORD *)(v13 + 40);
    v26 = v23 != 0;
    goto LABEL_25;
  }
  v21 = 0;
  v22 = __s;
  while (v22[v19] != 47)
  {
    ++v21;
    --v22;
    if (v19 == v21)
    {
      v18 = __s;
      v94 = v19;
      goto LABEL_24;
    }
  }
  v18 = &v22[v19 + 1];
  v94 = v21 - 1;
  v23 = *(_QWORD *)(v13 + 40);
  if (!v23)
    goto LABEL_24;
  v24 = *(_QWORD *)(v13 + 48) + 48 * v23 - 48;
  v25 = *(_QWORD *)(v13 + 40);
  while (v20 - *(_QWORD *)(v24 + 8) != v21
       || memcmp((const void *)(*(_QWORD *)(v13 + 176) + *(_QWORD *)v24), __s, v20 - v21))
  {
    v24 -= 48;
    if (!--v25)
      goto LABEL_24;
  }
  v26 = *(_DWORD *)(v24 + 16);
  if (!v26)
    goto LABEL_24;
LABEL_25:
  if (v17 != 72)
  {
    v30 = -1;
    v32 = -1;
    goto LABEL_32;
  }
  v92 = v18;
  v27 = strlen((const char *)a2 + 1168);
  if (!v23)
    goto LABEL_30;
  v28 = v27;
  v29 = cmpBOMPath(v13, a2 + 292, v27, 0);
  if (v29 < 0)
    goto LABEL_30;
  if (v29)
  {
    v30 = v23 - 1;
    v31 = cmpBOMPath(v13, a2 + 292, v28, v23 - 1);
    if (v31 <= 0)
    {
      if (v31)
      {
        v58 = 0;
        while (v58 + 1 < v30)
        {
          v59 = v58 + ((v30 - v58) >> 1);
          v60 = cmpBOMPath(v13, a2 + 292, v28, v59);
          if (v60 < 0)
            v30 = v58 + ((v30 - v58) >> 1);
          else
            v58 += (v30 - v58) >> 1;
          if (!v60)
          {
            v30 = v59;
            goto LABEL_63;
          }
        }
        goto LABEL_30;
      }
LABEL_63:
      if ((v30 & 0x8000000000000000) == 0)
        goto LABEL_64;
    }
LABEL_30:
    v91 = __s;
    v14 = "missing hard link target entry: %s";
    v15 = 666;
    goto LABEL_42;
  }
  v30 = 0;
LABEL_64:
  v61 = *(_QWORD *)(v13 + 48) + 48 * v30;
  v63 = *(_DWORD *)(v61 + 36);
  v62 = (int *)(v61 + 36);
  v32 = *(v62 - 5);
  v64 = *(_QWORD *)(v13 + 88);
  *(_QWORD *)(v13 + 88) = v64 + 1;
  if (v63 == -1)
  {
    *v62 = v32;
    v65 = v64 + 2;
    v66 = *(_QWORD *)(v13 + 96) + 1;
    *(_QWORD *)(v13 + 88) = v65;
    *(_QWORD *)(v13 + 96) = v66;
  }
  v18 = v92;
LABEL_32:
  v33 = *(_QWORD *)(v13 + 32);
  if (v23 >= v33)
  {
    v35 = v33 + (v33 >> 1);
    v11 = v33 == 0;
    v36 = 0x4000;
    if (!v11)
      v36 = v35;
    *(_QWORD *)(v13 + 32) = v36;
    v34 = (char *)reallocf(*(void **)(v13 + 48), 48 * v36);
    *(_QWORD *)(v13 + 48) = v34;
    if (!v34)
    {
      v43 = *__error();
      v14 = "malloc";
      v15 = 688;
      goto LABEL_43;
    }
    v23 = *(_QWORD *)(v13 + 40);
  }
  else
  {
    v34 = *(char **)(v13 + 48);
  }
  v37 = *(_DWORD *)(v13 + 56);
  if (v37 == -1)
  {
    v14 = "too many entries";
    v15 = 695;
    goto LABEL_42;
  }
  v38 = &v34[48 * v23];
  v39 = v37 + 1;
  *(_DWORD *)(v13 + 56) = v39;
  *((_DWORD *)v38 + 4) = v39;
  v40 = (unsigned int *)(v38 + 16);
  *((_DWORD *)v38 + 5) = v26;
  v41 = (unsigned int *)(v38 + 20);
  *((_DWORD *)v38 + 9) = v32;
  v42 = v34;
  if (BlobBufferStore(v13 + 160, __s, v20, v38))
  {
    v14 = "path_blob";
    v15 = 703;
    goto LABEL_42;
  }
  v44 = v42;
  v45 = a2[1];
  if (v45 == 72)
  {
    v46 = v18;
    v47 = *(_DWORD *)(*(_QWORD *)(v13 + 48) + 48 * v30 + 28);
    v48 = v44;
    *(_DWORD *)&v44[48 * v23 + 28] = v47;
  }
  else
  {
    bzero(v98, 0x44DuLL);
    v57 = *a2;
    if ((*a2 & 0x10) == 0)
    {
      v91 = __s;
      v14 = "missing MOD field: %s";
      v15 = 720;
      goto LABEL_42;
    }
    if ((v57 & 2) == 0)
    {
      v91 = __s;
      v14 = "missing UID field: %s";
      v15 = 721;
      goto LABEL_42;
    }
    if ((v57 & 4) == 0)
    {
      v91 = __s;
      v14 = "missing GID field: %s";
      v15 = 722;
      goto LABEL_42;
    }
    if ((v57 & 0x100) == 0)
    {
      v91 = __s;
      v14 = "missing MTM field: %s";
      v15 = 723;
      goto LABEL_42;
    }
    v76 = a2[5];
    switch(v45)
    {
      case 'B':
        if ((v57 & 0x20) == 0)
        {
          v91 = __s;
          v14 = "missing DEV field: %s";
          v15 = 749;
          goto LABEL_42;
        }
        v46 = v18;
        v81 = v76 | 0x6000;
        goto LABEL_107;
      case 'C':
        if ((v57 & 0x20) == 0)
        {
          v91 = __s;
          v14 = "missing DEV field: %s";
          v15 = 756;
          goto LABEL_42;
        }
        v46 = v18;
        v81 = v76 | 0x2000;
LABEL_107:
        v93 = *(_DWORD *)(v13 + 4) == 0;
        if (*(_DWORD *)(v13 + 4))
          v82 = 17;
        else
          v82 = 1;
        v83 = 4;
        goto LABEL_116;
      case 'D':
        v46 = v18;
        v81 = v76 | 0x4000;
        v93 = *(_DWORD *)(v13 + 4) == 0;
        if (*(_DWORD *)(v13 + 4))
          v82 = 17;
        else
          v82 = 1;
        v83 = 2;
        goto LABEL_116;
      case 'F':
        if ((v57 & 0x80) == 0)
        {
          v91 = __s;
          v14 = "missing SIZ field: %s";
          v15 = 727;
          goto LABEL_42;
        }
        if ((v57 & 0x1000) == 0)
        {
          v91 = __s;
          v14 = "missing CKS field: %s";
          v15 = 728;
          goto LABEL_42;
        }
        if ((v57 & 8) == 0)
        {
          v91 = __s;
          v14 = "missing FLG field: %s";
          v15 = 729;
          goto LABEL_42;
        }
        v46 = v18;
        v81 = v76 | 0xFFFF8000;
        v93 = *(_DWORD *)(v13 + 4) == 0;
        if (*(_DWORD *)(v13 + 4))
          v82 = 19;
        else
          v82 = 3;
        v83 = 1;
        goto LABEL_116;
      case 'L':
        if ((v57 & 0x10000) == 0)
        {
          v91 = __s;
          v14 = "missing LNK field: %s";
          v15 = 742;
          goto LABEL_42;
        }
        v46 = v18;
        v81 = v76 | 0xFFFFA000;
        v93 = *(_DWORD *)(v13 + 4) == 0;
        v83 = 3;
        if (*(_DWORD *)(v13 + 4))
          v82 = 19;
        else
          v82 = 3;
LABEL_116:
        v95[0] = v83;
        v95[1] = 1;
        *(_WORD *)&v95[2] = v82 << 8;
        *(_WORD *)&v95[4] = bswap32(v81) >> 16;
        *(int8x8_t *)&v95[6] = vrev32_s8(*(int8x8_t *)(a2 + 2));
        v96 = vrev64_s32((int32x2_t)vrev32_s8((int8x8_t)vmovn_s64(*(int64x2_t *)(a2 + 10))));
        v97 = 1;
        if ((v82 & 2) != 0)
        {
          if ((v57 & 0x1000) != 0)
            v85 = a2[22];
          else
            v85 = 0;
          v98[0] = bswap32(v85);
          v84 = 27;
        }
        else
        {
          v84 = 23;
        }
        if (v45 == 76)
        {
          v86 = strlen((const char *)a2 + 1168);
          *(_DWORD *)&v95[v84] = bswap32(v86 + 1);
          v87 = v84 + 4;
          memcpy(&v95[v84 + 4], a2 + 292, v86);
          v84 += v86 + 4 + 1;
          v95[v86 + v87] = 0;
        }
        else if ((v45 & 0xFFFFFFFE) == 0x42)
        {
          *(_DWORD *)&v95[v84] = bswap32(a2[6]);
          v84 += 4;
        }
        if (!v93)
        {
          *(_DWORD *)&v95[v84] = 0x8000000;
          IsCompressed = statIsCompressed(a2[4]);
          v89 = strstr(__s, "/usr/standalone/update");
          v90 = (IsCompressed << 32) | 0xF1;
          if (v89)
            v90 = 0x1000000F1;
          *(_QWORD *)&v95[v84 + 4] = v90;
          v84 += 12;
        }
        if (storeBlock(v13, v95, v84, &v44[48 * v23 + 28], v55, v56, a7, a8))
        {
          v14 = "attr";
          v15 = 830;
          goto LABEL_42;
        }
        v48 = v44;
        break;
      default:
        v91 = __s;
        v14 = "invalid entry type: %s";
        v15 = 763;
        goto LABEL_42;
    }
  }
  bzero(&v95[4], 0x460uLL);
  *(_DWORD *)v95 = bswap32(*v41);
  __memcpy_chk();
  v95[v94 + 4] = 0;
  if (storeBlock(v13, v95, v94 + 5, &v48[48 * v23 + 24], v49, v50, v51, v52))
  {
    v14 = "name";
    v15 = 846;
    goto LABEL_42;
  }
  *(_DWORD *)v95 = bswap32(*v40);
  v67 = &v48[48 * v23];
  v69 = *((_DWORD *)v67 + 7);
  v68 = (unsigned int *)(v67 + 28);
  *(_DWORD *)&v95[4] = bswap32(v69);
  result = storeBlock(v13, v95, 8uLL, v68 + 1, v53, v54, a7, a8);
  if ((_DWORD)result)
  {
    v14 = "tree_ptr";
    v15 = 856;
    goto LABEL_42;
  }
  v72 = *((_QWORD *)a2 + 5);
  if (HIDWORD(v72))
  {
    v74 = *(_QWORD *)(v13 + 64);
    v73 = *(_QWORD *)(v13 + 72);
    if (v73 >= v74)
    {
      v77 = v74 + (v74 >> 1);
      if (!v74)
        v77 = 0x4000;
      *(_QWORD *)(v13 + 64) = v77;
      v75 = (char *)reallocf(*(void **)(v13 + 80), 8 * v77);
      *(_QWORD *)(v13 + 80) = v75;
      if (!v75)
      {
        v43 = *__error();
        v14 = "malloc";
        v15 = 868;
        goto LABEL_43;
      }
      v73 = *(_QWORD *)(v13 + 72);
      v72 = *((_QWORD *)a2 + 5);
    }
    else
    {
      v75 = *(char **)(v13 + 80);
    }
    v78 = &v75[8 * v73];
    *(_QWORD *)v95 = bswap64(v72);
    if (storeBlock(v13, v95, 8uLL, v78, v70, v71, a7, a8))
    {
      v14 = "size";
      v15 = 877;
      goto LABEL_42;
    }
    *(_DWORD *)v95 = bswap32(*v68);
    result = storeBlock(v13, v95, 4uLL, (_DWORD *)v78 + 1, v79, v80, a7, a8);
    if ((_DWORD)result)
    {
      v14 = "attr";
      v15 = 881;
      goto LABEL_42;
    }
    ++*(_QWORD *)(v13 + 72);
  }
  if (*(int *)v13 >= 2)
    result = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "entry_id=%u parent_id=%u %s\n", *v40, *v41, v46);
  ++*(_QWORD *)(v13 + 40);
  return result;
}

uint64_t storeBlock(uint64_t a1, const void *a2, size_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  const char *v9;
  __int16 v10;
  unint64_t v15;
  uint64_t v16;
  void *v17;
  int v18;
  uint64_t result;
  _QWORD *v20;
  char v21;

  v8 = *(_QWORD *)(a1 + 112);
  if (v8 >= 0xFFFFFFFF)
  {
    v9 = "too many blocks";
    v10 = 168;
LABEL_13:
    v18 = 0;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"storeBlock", v10, 52, v18, v9, a7, a8, v21);
    return 0xFFFFFFFFLL;
  }
  if (HIDWORD(a3))
  {
    v21 = a3;
    v9 = "block is too large: %zu B";
    v10 = 169;
    goto LABEL_13;
  }
  v15 = *(_QWORD *)(a1 + 104);
  if (v8 >= v15)
  {
    v16 = v15 + (v15 >> 1);
    if (!v15)
      v16 = 4096;
    *(_QWORD *)(a1 + 104) = v16;
    v17 = reallocf(*(void **)(a1 + 120), 16 * v16);
    *(_QWORD *)(a1 + 120) = v17;
    if (!v17)
    {
      v18 = *__error();
      v9 = "malloc";
      v10 = 177;
      goto LABEL_14;
    }
    v8 = *(_QWORD *)(a1 + 112);
  }
  *a4 = v8;
  if (a3)
  {
    if (BlobBufferStore(a1 + 160, a2, a3, (_QWORD *)(*(_QWORD *)(a1 + 120) + 16 * v8)))
    {
      v9 = "blob store";
      v10 = 187;
      goto LABEL_13;
    }
    v8 = *(_QWORD *)(a1 + 112);
  }
  else
  {
    v20 = (_QWORD *)(*(_QWORD *)(a1 + 120) + 16 * v8);
    *v20 = 0;
    v20[1] = 0;
  }
  result = 0;
  *(_QWORD *)(a1 + 112) = v8 + 1;
  return result;
}

uint64_t BOMEntryCompareProc(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  _BOOL4 v8;

  v2 = *(_DWORD *)(a1 + 20);
  v3 = *(_DWORD *)(a2 + 20);
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  if (v2 > v3)
    return 1;
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(_DWORD *)(a2 + 16);
  v7 = v5 >= v6;
  v8 = v5 > v6;
  if (v7)
    return v8;
  else
    return 0xFFFFFFFFLL;
}

uint64_t createTree(uint64_t a1, unint64_t a2, void (*a3)(uint64_t, unint64_t, int8x8_t *), uint64_t a4, size_t __size, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v14;
  size_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  size_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _DWORD *v24;
  size_t v25;
  void *v26;
  unint64_t v27;
  unint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  size_t v36;
  size_t v37;
  uint64_t v38;
  __int32 v39;
  __int32 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  _DWORD *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unsigned int v62;
  _DWORD *v63;
  unint64_t i;
  unint64_t v65;
  int *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  const char *v70;
  __int16 v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  char v77;
  unint64_t v78;
  _DWORD *v79;
  size_t v80;
  size_t v81;
  _WORD *v82;
  _DWORD *v83;
  _DWORD *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  size_t v89;
  int8x8_t v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  char v94;
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  if (a2 >= 0xFFFFFFFF)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 259, 52, 0, "too many entries in tree", a7, a8, v77);
    return 0xFFFFFFFFLL;
  }
  v14 = malloc(__size);
  if (!v14)
  {
    v20 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 273, 52, *v20, "malloc", v21, v22, v77);
    v23 = 0;
    v24 = 0;
LABEL_67:
    v76 = 0;
    goto LABEL_68;
  }
  v15 = (__size - 16) >> 3;
  v16 = a2;
  if (a2 < 2)
  {
    v18 = 0;
  }
  else
  {
    v17 = 0;
    v18 = 0;
    do
    {
      if (v17)
        v19 = v15 + 1;
      else
        v19 = (__size - 16) >> 3;
      v16 = (v16 + v19 - 1) / v19;
      v18 += v16;
      --v17;
    }
    while (v16 > 1);
  }
  if (v18 <= 1)
    v25 = 1;
  else
    v25 = v18;
  v24 = calloc(v25, 4uLL);
  if (!v24)
  {
    v66 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 287, 52, *v66, "malloc", v67, v68, v77);
    v23 = 0;
    goto LABEL_67;
  }
  v81 = v15 + 1;
  v26 = calloc(v25, 4uLL);
  v23 = v26;
  if (!v26)
  {
    v69 = *__error();
    v70 = "malloc";
    v71 = 289;
LABEL_66:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", v71, 52, v69, v70, v43, v44, v77);
    goto LABEL_67;
  }
  v85 = a1;
  if (a2)
  {
    v79 = a6;
    v80 = v25;
    v89 = __size;
    v83 = v24;
    v84 = v26;
    v27 = 0;
    v28 = 0;
    v29 = v14 + 3;
    v30 = 1;
    a6 = (_DWORD *)a2;
    v82 = v14;
    do
    {
      v86 = v30;
      bzero(v14, v89);
      v35 = v27 + v15;
      if (v27 + v15 <= (unint64_t)a6)
        v36 = v15;
      else
        v36 = (size_t)a6 - v27;
      v90 = 0;
      if (v36)
      {
        v37 = 0;
        v38 = 6;
        do
        {
          a3(a4, v27 + v37, &v90);
          v39 = v90.i32[1];
          *(int8x8_t *)&v29[2 * v37] = vrev32_s8(v90);
          v38 += 4;
          ++v37;
        }
        while (v37 < v36);
        v40 = v39;
        a1 = v85;
      }
      else
      {
        v40 = 0;
        v38 = 6;
      }
      v24 = v83;
      v84[v28] = v40;
      *(_DWORD *)&v82[v38] = 0;
      v14 = v82;
      *v82 = 256;
      v82[1] = bswap32(v36) >> 16;
      if (storeBlock(a1, v82, v89, &v83[v28], v31, v32, v33, v34))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createTree", 337, 52, 0, "storing page", v43, v44, v77);
        v76 = 0;
        v23 = v84;
        goto LABEL_68;
      }
      ++v28;
      a6 = (_DWORD *)a2;
      v30 = v86 + 1;
      v27 = v35;
    }
    while (v35 < a2);
    v24 = v83;
    v23 = v84;
    if (v28)
    {
      v45 = 0;
      do
      {
        v46 = v45 + 1;
        if (v45 + 1 >= v28)
        {
          v47 = 0;
          if (!v45)
          {
LABEL_36:
            v48 = 0;
            goto LABEL_37;
          }
        }
        else
        {
          v47 = v83[v45 + 1];
          if (!v45)
            goto LABEL_36;
        }
        v48 = v83[v45 - 1];
LABEL_37:
        v49 = *(_QWORD *)(a1 + 176) + *(_QWORD *)(*(_QWORD *)(a1 + 120) + 16 * v83[v45]);
        *(_DWORD *)(v49 + 4) = bswap32(v47);
        *(_DWORD *)(v49 + 8) = bswap32(v48);
        v45 = v46;
      }
      while (v86 != v46);
    }
    if (v28 < 2)
    {
      v65 = 0;
    }
    else
    {
      v50 = 0;
      v51 = 4 * v15 + 4;
      v52 = v28;
      while (2)
      {
        v53 = 0;
        v78 = v28;
        v54 = &v83[v50];
        v87 = v50;
        v55 = (char *)&v84[v50];
        do
        {
          bzero(v82, v89);
          v60 = v53 + v81;
          v61 = v52 - v53;
          if (v53 + v81 <= v52)
            v61 = v81;
          if (v61)
          {
            v62 = v84[v53 + v87];
            *((_DWORD *)v82 + 3) = bswap32(v83[v53 + v87]);
            if (v61 != 1)
            {
              v63 = v82 + 10;
              for (i = 1; i < v61; ++i)
              {
                *(v63 - 1) = bswap32(v62);
                v62 = *(_DWORD *)&v55[4 * i];
                *v63 = bswap32(v54[i]);
                v63 += 2;
              }
            }
          }
          else
          {
            v62 = 0;
          }
          v84[v28] = v62;
          *v82 = 0;
          v82[1] = bswap32(v61 - 1) >> 16;
          if (storeBlock(v85, v82, v89, &v83[v28], v56, v57, v58, v59))
          {
            v70 = "storing page";
            v71 = 388;
            goto LABEL_65;
          }
          ++v28;
          v54 = (_DWORD *)((char *)v54 + v51);
          v55 += v51;
          v53 += v81;
        }
        while (v60 < v52);
        v65 = v78;
        v52 = v28 - v78;
        v50 = v78;
        LODWORD(a6) = a2;
        if (v28 - v78 >= 2)
          continue;
        break;
      }
    }
  }
  else
  {
    bzero(v14, __size);
    *v14 = 256;
    if (storeBlock(a1, v14, __size, v24, v72, v73, v74, v75))
    {
      v70 = "storing page";
      v71 = 301;
LABEL_65:
      v69 = 0;
      goto LABEL_66;
    }
    v79 = a6;
    v80 = v25;
    LODWORD(v89) = __size;
    v65 = 0;
    v28 = 1;
    LODWORD(a6) = 0;
  }
  if (v28 != v80)
  {
    v77 = v28;
    v70 = "mismatch in number of tree pages: i_page=%zu n_pages=%zu";
    v71 = 399;
    goto LABEL_65;
  }
  v90 = (int8x8_t)0x100000065657274;
  v91 = bswap32(v24[v65]);
  v92 = bswap32(v89);
  v93 = bswap32(a6);
  v94 = 0;
  if (storeBlock(v85, &v90, 0x15uLL, v79, v41, v42, v43, v44))
  {
    v70 = "storing base block";
    v71 = 413;
    goto LABEL_65;
  }
  v76 = 1;
LABEL_68:
  free(v14);
  free(v24);
  free(v23);
  if (v76)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t getPathsPK(uint64_t result, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(result + 48) + 48 * a2;
  *a3 = *(_DWORD *)(v3 + 32);
  a3[1] = *(_DWORD *)(v3 + 24);
  return result;
}

uint64_t getSize64PK(uint64_t result, uint64_t a2, _DWORD *a3)
{
  _DWORD *v3;

  v3 = (_DWORD *)(*(_QWORD *)(result + 80) + 8 * a2);
  *a3 = *v3;
  a3[1] = v3[1];
  return result;
}

uint64_t createBomInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  _DWORD v12[50];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v8 = bswap32(*(_DWORD *)(a1 + 56) + 1);
  v12[0] = 0x1000000;
  v12[1] = v8;
  v12[2] = 0;
  result = storeBlock(a1, v12, 0xCuLL, (_DWORD *)(a1 + 152), a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createBomInfo", 458, 52, 0, "storing bom_info block", v10, v11, v12[0]);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t createVIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  unsigned int v15;
  uint64_t result;
  _DWORD v17[3];
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (createTree(a1, 0, 0, 0, 0x80uLL, (_DWORD *)(a1 + 148), a7, a8))
  {
    v13 = "vindex_tree";
    v14 = 466;
  }
  else
  {
    v15 = bswap32(*(_DWORD *)(a1 + 148));
    v17[0] = 0x1000000;
    v17[1] = v15;
    v17[2] = 0;
    v18 = 0;
    result = storeBlock(a1, v17, 0xDuLL, (_DWORD *)(a1 + 156), v9, v10, v11, v12);
    if (!(_DWORD)result)
      return result;
    v13 = "storing vindex block";
    v14 = 477;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/GenerateBOM.c", (uint64_t)"createVIndex", v14, 52, 0, v13, v11, v12, v17[0]);
  return 0xFFFFFFFFLL;
}

uint64_t cmpBOMPath(uint64_t a1, void *__s1, size_t a3, uint64_t a4)
{
  size_t v4;
  size_t v5;
  uint64_t result;
  int v7;
  unsigned int v8;

  v4 = a3;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 48 * a4 + 8);
  if (v5 < a3)
    a3 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 48 * a4 + 8);
  LODWORD(result) = memcmp(__s1, (const void *)(*(_QWORD *)(a1 + 176) + *(_QWORD *)(*(_QWORD *)(a1 + 48) + 48 * a4)), a3);
  if (v5 <= v4)
    v7 = 0;
  else
    v7 = -1;
  if (v5 >= v4)
    v8 = v7;
  else
    v8 = 1;
  if ((_DWORD)result)
    return result;
  else
    return v8;
}

uint64_t getTablePK(uint64_t result, uint64_t a2, _DWORD *a3)
{
  _DWORD *v3;

  v3 = (_DWORD *)(result + 8 * a2);
  *a3 = *v3;
  a3[1] = v3[1];
  return result;
}

uint64_t ParallelArchiveExtractClones()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  FILE **v20;
  uint64_t v21;
  int v22;
  int v23;
  const char *v24;
  __int16 v25;
  uint64_t result;
  FILE **v27;
  char v28;
  char v29;
  _OWORD v30[2];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  int *v34;
  statfs v35;
  int v36;
  char v37[1028];
  void *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;

  v0 = MEMORY[0x24BDAC7A8]();
  v41 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(v0, v1, v2, v3, v4, v5, v6, v7, v28);
  bzero(&v36, 0xED0uLL);
  v34 = 0;
  v32 = 0u;
  v33 = 0u;
  v31 = 0u;
  memset(v30, 0, sizeof(v30));
  v36 = *(_DWORD *)v0;
  if (realpath_DARWIN_EXTSN(*(const char **)(v0 + 16), v37))
  {
    v13 = *(_QWORD *)(v0 + 48);
    if (v13)
    {
      v38 = (void *)ParallelArchiveDBSetCreate(v13, *(_QWORD *)(v0 + 56), 0, v8, v9, v10, v11, v12);
      if (v38)
      {
        v39 = 0;
        v19 = *(_DWORD *)v0;
        if (*(int *)v0 >= 1)
        {
          memset(&v35, 0, 512);
          if (!statfs(v37, &v35))
          {
            v20 = (FILE **)MEMORY[0x24BDAC8D8];
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu initial free blocks\n", v35.f_bfree);
            fprintf(*v20, "%12llu initial available blocks\n", v35.f_bavail);
            fprintf(*v20, "%12llu initial blocks\n", v35.f_blocks);
          }
          v19 = *(_DWORD *)v0;
        }
        *(_QWORD *)&v30[0] = __PAIR64__(*(_DWORD *)(v0 + 4), v19);
        v21 = *(_QWORD *)(v0 + 40);
        *(_OWORD *)((char *)v30 + 8) = *(_OWORD *)(v0 + 24);
        *((_QWORD *)&v30[1] + 1) = v21;
        *(_QWORD *)&v31 = extractClonesBegin;
        v34 = &v36;
        *(_QWORD *)&v33 = extractClonesEnd;
        *((_QWORD *)&v31 + 1) = extractClonesBlob;
        *(_QWORD *)&v32 = extractClonesData;
        if ((ParallelArchiveRead((uint64_t)v30, v14, v15, v16, v17, v18, v11, v12) & 0x80000000) == 0)
        {
          v22 = 0;
          goto LABEL_16;
        }
        v24 = "reading archive";
        v25 = 189;
      }
      else
      {
        v24 = "connecting to database";
        v25 = 162;
      }
    }
    else
    {
      v24 = "No database provided";
      v25 = 160;
    }
    v23 = 0;
  }
  else
  {
    v23 = *__error();
    v24 = *(const char **)(v0 + 16);
    v25 = 159;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"ParallelArchiveExtractClones", v25, 71, v23, v24, v11, v12, v29);
  v22 = 1;
LABEL_16:
  ParallelArchiveDBSetDestroy((uint64_t)v38);
  result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    if ((v22 & 1) == 0 && *(int *)v0 >= 1)
    {
      v27 = (FILE **)MEMORY[0x24BDAC8D8];
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu entries extracted\n", v40);
      memset(&v35, 0, 512);
      if (!statfs(v37, &v35))
      {
        fprintf(*v27, "%12llu final free blocks\n", v35.f_bfree);
        fprintf(*v27, "%12llu final available blocks\n", v35.f_bavail);
        fprintf(*v27, "%12llu final blocks\n", v35.f_blocks);
      }
    }
    return (v22 << 31 >> 31);
  }
  return result;
}

size_t extractClonesBegin(uint64_t a1, int *a2)
{
  size_t result;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  int v8;
  uid_t v9;
  gid_t v10;
  char v11;
  char __s[2048];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  result = (size_t)memcpy((void *)(a1 + 1048), a2, 0x890uLL);
  *(_OWORD *)(a1 + 3240) = 0u;
  *(_OWORD *)(a1 + 3256) = 0u;
  *(_OWORD *)(a1 + 3272) = 0u;
  *(_OWORD *)(a1 + 3288) = 0u;
  *(_OWORD *)(a1 + 3304) = 0u;
  *(_OWORD *)(a1 + 3320) = 0u;
  *(_OWORD *)(a1 + 3336) = 0u;
  *(_OWORD *)(a1 + 3352) = 0u;
  *(_OWORD *)(a1 + 3368) = 0u;
  *(_OWORD *)(a1 + 3384) = 0u;
  *(_OWORD *)(a1 + 3400) = 0u;
  *(_OWORD *)(a1 + 3416) = 0u;
  *(_OWORD *)(a1 + 3432) = 0u;
  *(_OWORD *)(a1 + 3448) = 0u;
  *(_OWORD *)(a1 + 3464) = 0u;
  *(_OWORD *)(a1 + 3480) = 0u;
  *(_QWORD *)(a1 + 3496) = 0;
  *(_DWORD *)(a1 + 3504) = 0;
  *(_OWORD *)(a1 + 3732) = 0u;
  *(_OWORD *)(a1 + 3748) = 0u;
  *(_OWORD *)(a1 + 3700) = 0u;
  *(_OWORD *)(a1 + 3716) = 0u;
  *(_OWORD *)(a1 + 3668) = 0u;
  *(_OWORD *)(a1 + 3684) = 0u;
  *(_OWORD *)(a1 + 3636) = 0u;
  *(_OWORD *)(a1 + 3652) = 0u;
  *(_OWORD *)(a1 + 3604) = 0u;
  *(_OWORD *)(a1 + 3620) = 0u;
  *(_OWORD *)(a1 + 3572) = 0u;
  *(_OWORD *)(a1 + 3588) = 0u;
  *(_OWORD *)(a1 + 3540) = 0u;
  *(_OWORD *)(a1 + 3556) = 0u;
  *(_OWORD *)(a1 + 3508) = 0u;
  *(_OWORD *)(a1 + 3524) = 0u;
  *(_QWORD *)(a1 + 3768) = 0;
  *(_DWORD *)(a1 + 3776) = 0;
  if (*(_DWORD *)(a1 + 1052) == 68)
  {
    bzero(__s, 0x800uLL);
    if (concatPath(__s, 0x800uLL, (char *)(a1 + 4), (const char *)(a1 + 1192)))
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesBegin", 49, 71, 0, "concatPath", v5, v6, v11);
    v7 = strlen(__s);
    makePath(__s, v7);
    result = mkdir(__s, 0x1EDu);
    v8 = *a2;
    if ((*a2 & 2) != 0)
    {
      v9 = a2[2];
      if ((v8 & 4) != 0)
        goto LABEL_6;
    }
    else
    {
      v9 = -1;
      if ((v8 & 4) != 0)
      {
LABEL_6:
        v10 = a2[3];
        return chown(__s, v9, v10);
      }
    }
    if ((v8 & 6) == 0)
      return result;
    v10 = -1;
    return chown(__s, v9, v10);
  }
  return result;
}

uint64_t extractClonesEnd(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  __int16 v5;
  int v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char __s[2048];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(result + 1052) != 77)
  {
    v1 = result;
    bzero(__s, 0x800uLL);
    if (concatPath(__s, 0x800uLL, (char *)(v1 + 4), (const char *)(v1 + 1192)))
    {
      v4 = "concatPath";
      v5 = 67;
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
    }
    v6 = *(_DWORD *)(v1 + 1052);
    if (v6 != 68)
    {
      if (v6 == 76)
      {
        v10 = strlen(__s);
        makePath(__s, v10);
        unlink(__s);
        if (symlink((const char *)(v1 + 2216), __s))
        {
          v11 = *__error();
          return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", 82, 71, v11, "%s", v12, v13, (char)__s);
        }
      }
      else
      {
        if (v6 != 70)
        {
          LOBYTE(v14) = *(_DWORD *)(v1 + 1052);
          v4 = "Unsupported file type [%c] %s";
          v5 = 85;
          return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
        }
        v7 = strlen(__s);
        makePath(__s, v7);
        unlink(__s);
        if ((ParallelArchiveDBCloneWithSet(*(uint64_t **)(v1 + 1032), (char *)(v1 + 3508), (uint64_t)__s, v1 + 3240, *(_QWORD *)(v1 + 3496), 0, v8, v9) & 0x80000000) != 0)
        {
          v14 = __s;
          v4 = "cloning file: %s";
          v5 = 77;
          return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
        }
      }
    }
    result = yaa_setEntryAttributes(__s, (int *)(v1 + 1048), 0, *(_DWORD *)(v1 + 1040));
    if ((result & 0x80000000) != 0)
    {
      v14 = __s;
      v4 = "setting attributes: %s";
      v5 = 92;
      return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ExtractClones.c", (uint64_t)"extractClonesEnd", v5, 71, 0, v4, v2, v3, (char)v14);
    }
    ++*(_QWORD *)(v1 + 3784);
    if (*(int *)v1 >= 2)
      return fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", __s);
  }
  return result;
}

_DWORD *extractClonesBlob(_DWORD *result, _DWORD *a2)
{
  int v2;
  _QWORD *v3;

  if (result[263] != 77)
  {
    result[944] = 0;
    result[876] = 0;
    v2 = *a2 & 0xDFDFDF;
    if (v2 == 4277337)
    {
      result[944] = 1;
      v3 = result + 942;
    }
    else
    {
      if (v2 != 4932697)
        return result;
      result[876] = 1;
      v3 = result + 874;
    }
    *v3 = 0;
  }
  return result;
}

char *extractClonesData(char *result, void *__src, unint64_t a3)
{
  size_t v3;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;

  if (*((_DWORD *)result + 263) != 77)
  {
    v3 = a3;
    v5 = result;
    if (*((_DWORD *)result + 876))
    {
      v6 = *((_QWORD *)result + 437);
      if (256 - v6 >= a3)
        v7 = a3;
      else
        v7 = 256 - v6;
      result = (char *)memcpy(&result[v6 + 3240], __src, v7);
      v5[437] += v7;
    }
    if (*((_DWORD *)v5 + 944))
    {
      v8 = v5[471];
      if (256 - v8 < v3)
        v3 = 256 - v8;
      result = (char *)memcpy((char *)v5 + v8 + 3508, __src, v3);
      v5[471] += v3;
    }
  }
  return result;
}

uint64_t jsonPushLabel(uint64_t a1, char a2)
{
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _BYTE *v7;
  size_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v4 = *(_QWORD *)(a1 + 72);
  v5 = *(_QWORD *)(a1 + 80);
  v6 = (_QWORD *)(a1 + 72);
  if (v5 >= v4)
  {
    if (v4)
      v8 = v4 + (v4 >> 1);
    else
      v8 = 256;
    *(_QWORD *)(a1 + 72) = v8;
    v7 = reallocf(*(void **)(a1 + 88), v8);
    *(_QWORD *)(a1 + 88) = v7;
    if (!v7)
    {
      v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"jsonPushLabel", 358, 109, *v10, "malloc", v11, v12, v14);
      *v6 = 0;
      v6[1] = 0;
      return 0xFFFFFFFFLL;
    }
    v5 = *(_QWORD *)(a1 + 80);
  }
  else
  {
    v7 = *(_BYTE **)(a1 + 88);
  }
  v9 = 0;
  *(_QWORD *)(a1 + 80) = v5 + 1;
  v7[v5] = a2;
  return v9;
}

uint64_t jsonPushValue(uint64_t a1, char a2)
{
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _BYTE *v7;
  size_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = (_QWORD *)(a1 + 96);
  if (v5 >= v4)
  {
    if (v4)
      v8 = v4 + (v4 >> 1);
    else
      v8 = 256;
    *(_QWORD *)(a1 + 96) = v8;
    v7 = reallocf(*(void **)(a1 + 112), v8);
    *(_QWORD *)(a1 + 112) = v7;
    if (!v7)
    {
      v10 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"jsonPushValue", 372, 109, *v10, "malloc", v11, v12, v14);
      *v6 = 0;
      v6[1] = 0;
      return 0xFFFFFFFFLL;
    }
    v5 = *(_QWORD *)(a1 + 104);
  }
  else
  {
    v7 = *(_BYTE **)(a1 + 112);
  }
  v9 = 0;
  *(_QWORD *)(a1 + 104) = v5 + 1;
  v7[v5] = a2;
  return v9;
}

_QWORD *AAJSONInputStreamOpen(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  char v12;

  v2 = malloc(0x78uLL);
  v3 = v2;
  if (v2)
  {
    memset_s(v2, 0x78uLL, 0, 0x78uLL);
    v3[1] = a1;
    v3[5] = 0x10000;
    v4 = malloc(0x10000uLL);
    v3[8] = v4;
    if (v4)
    {
      *(_QWORD *)((char *)v3 + 20) = 32;
      v3[4] = calloc(0x20uLL, 4uLL);
    }
    else
    {
      v8 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamOpen", 387, 109, *v8, "malloc", v9, v10, v12);
      AAJSONInputStreamClose((void **)v3);
      return 0;
    }
  }
  else
  {
    v5 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamOpen", 382, 109, *v5, "malloc", v6, v7, v12);
  }
  return v3;
}

void AAJSONInputStreamClose(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1[11]);
    free(a1[14]);
    free(a1[8]);
    free(a1);
  }
}

uint64_t AAJSONInputStreamRead(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t result;
  uint64_t v14;
  unint64_t v15;
  unsigned __int8 *v16;
  ssize_t v17;
  int v18;
  char v19;
  unsigned __int8 v20;
  unint64_t v21;
  char v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  const char *v28;
  int v29;
  const char *v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;
  _BOOL4 v34;
  _BOOL4 v35;
  int v37;
  uint64_t v38;
  int v39;
  const char *v40;
  unint64_t v41;
  int v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;

  if (atomic_load((unsigned int *)a1))
    return 0xFFFFFFFFLL;
  v10 = *(_DWORD *)(a1 + 16);
  if (v10 == 9 || v10 == -1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamRead", 418, 109, 0, "unexpected read call", a7, a8, v46);
    return 0xFFFFFFFFLL;
  }
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  v14 = MEMORY[0x24BDAC740];
  while (2)
  {
    v15 = *(_QWORD *)(a1 + 56);
    v16 = *(unsigned __int8 **)(a1 + 64);
    if (v15 >= *(_QWORD *)(a1 + 48))
    {
      v17 = AAByteStreamRead(*(AAByteStream *)(a1 + 8), v16, *(_QWORD *)(a1 + 40));
      if (v17 < 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamRead", 430, 109, 0, "read error: %zd", a7, a8, v17);
LABEL_104:
        result = 0xFFFFFFFFLL;
        *(_DWORD *)(a1 + 16) = -1;
        return result;
      }
      if (!v17)
      {
        v30 = "EOF reached";
        v31 = 431;
        goto LABEL_103;
      }
      v15 = 0;
      *(_QWORD *)(a1 + 48) = v17;
      v16 = *(unsigned __int8 **)(a1 + 64);
    }
    *(_QWORD *)(a1 + 56) = v15 + 1;
    v18 = v16[v15];
    v19 = v16[v15];
    switch(*(_DWORD *)(a1 + 16))
    {
      case 0:
        *(_QWORD *)(a1 + 104) = 0;
        if ((char)v18 < 0)
        {
          if (__maskrune((char)v18, 0x4000uLL))
            continue;
        }
        else if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) != 0)
        {
          continue;
        }
        if (v18 == 34)
          goto LABEL_68;
        if (v18 == 43 || v18 == 45 || ((char)v18 - 48) <= 9)
        {
          if ((jsonPushValue(a1, v18) & 0x80000000) == 0)
          {
            v23 = 3;
            goto LABEL_69;
          }
          v30 = "jsonPushValue";
          v31 = 451;
          goto LABEL_103;
        }
        if (v18 == 123)
        {
          v32 = *(unsigned int *)(a1 + 24);
          if ((_DWORD)v32 == *(_DWORD *)(a1 + 20))
          {
            v30 = "max level reached";
            v31 = 465;
            goto LABEL_103;
          }
          v27 = 0;
          v44 = *(_QWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 24) = v32 + 1;
          *(_DWORD *)(v44 + 4 * v32) = 0;
          v37 = 6;
          goto LABEL_125;
        }
        if (v18 == 91)
        {
          v33 = *(unsigned int *)(a1 + 24);
          if ((_DWORD)v33 == *(_DWORD *)(a1 + 20))
          {
            v30 = "max level reached";
            v31 = 457;
            goto LABEL_103;
          }
          v37 = 0;
          v45 = *(_QWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 24) = v33 + 1;
          v27 = 1;
          *(_DWORD *)(v45 + 4 * v33) = 1;
          goto LABEL_125;
        }
        if (((char)v18 - 97) <= 0x19)
        {
          if ((jsonPushValue(a1, v18) & 0x80000000) == 0)
          {
            v23 = 4;
            goto LABEL_69;
          }
          v30 = "jsonPushValue";
          v31 = 473;
          goto LABEL_103;
        }
        v25 = *(_DWORD *)(a1 + 24) - 1;
        v34 = (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * v25) & 1) == 0 || (char)v18 != 93;
        v35 = (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * v25) & 1) == 0 && (char)v18 == 125;
        if (v34 && !v35)
          goto LABEL_102;
        goto LABEL_121;
      case 1:
        if (v18 == 92)
        {
          v23 = 2;
          goto LABEL_69;
        }
        if (v18 == 34)
        {
          *(_DWORD *)(a1 + 16) = 5;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            v27 = 3;
            goto LABEL_126;
          }
          v30 = "jsonPushValue";
          v31 = 499;
          goto LABEL_103;
        }
        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          v30 = "jsonPushValue";
          v31 = 503;
          goto LABEL_103;
        }
        continue;
      case 2:
        HIDWORD(v21) = (char)v18;
        LODWORD(v21) = ((char)v18 << 24) - 1644167168;
        v20 = v21 >> 25;
        if (v20 < 0xAu && ((0x341u >> v20) & 1) != 0)
        {
          v22 = asc_20643F521[(char)v20];
        }
        else if ((char)v18 == 102)
        {
          v22 = 12;
        }
        else
        {
          v22 = v19;
        }
        if ((jsonPushValue(a1, v22) & 0x80000000) != 0)
        {
          v30 = "jsonPushValue";
          v31 = 512;
          goto LABEL_103;
        }
LABEL_68:
        v23 = 1;
        goto LABEL_69;
      case 3:
        if (((char)v18 - 48) > 9)
        {
          *(_DWORD *)(a1 + 16) = 5;
          *(_QWORD *)(a1 + 56) = v15;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            v27 = 4;
            goto LABEL_126;
          }
          v30 = "jsonPushValue";
          v31 = 539;
          goto LABEL_103;
        }
        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          v30 = "jsonPushValue";
          v31 = 533;
          goto LABEL_103;
        }
        continue;
      case 4:
        if (((char)v18 - 97) > 0x19)
        {
          *(_DWORD *)(a1 + 16) = 5;
          *(_QWORD *)(a1 + 56) = v15;
          if ((jsonPushValue(a1, 0) & 0x80000000) == 0)
          {
            v28 = *(const char **)(a1 + 112);
            if (!strcmp(v28, "false") || !strcmp(v28, "true"))
            {
              v27 = 6;
            }
            else
            {
              if (strcmp(v28, "null"))
                goto LABEL_102;
              v27 = 7;
            }
            goto LABEL_126;
          }
          v30 = "jsonPushValue";
          v31 = 524;
          goto LABEL_103;
        }
        if ((jsonPushValue(a1, v18) & 0x80000000) != 0)
        {
          v30 = "jsonPushValue";
          v31 = 519;
          goto LABEL_103;
        }
        continue;
      case 5:
        if ((char)v18 < 0)
        {
          if (__maskrune((char)v18, 0x4000uLL))
            continue;
        }
        else if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) != 0)
        {
          continue;
        }
        v24 = *(_DWORD *)(a1 + 24);
        if (!v24)
        {
          v30 = "invalid JSON state";
          v31 = 546;
          goto LABEL_103;
        }
        v25 = v24 - 1;
        v26 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * v25);
        if (v18 != 44)
        {
          if (v18 == 93)
          {
            if ((v26 & 1) != 0)
              goto LABEL_121;
            v19 = 93;
          }
          else if (v18 == 125)
          {
            goto LABEL_91;
          }
LABEL_102:
          v46 = v19;
          v30 = "invalid char %c %s";
          v31 = 610;
          goto LABEL_103;
        }
        if ((v26 & 1) != 0)
          v23 = 0;
        else
          v23 = 6;
LABEL_69:
        *(_DWORD *)(a1 + 16) = v23;
        continue;
      case 6:
        *(_QWORD *)(a1 + 80) = 0;
        if (((char)v18 & 0x80000000) == 0)
        {
          if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) == 0)
            goto LABEL_61;
          continue;
        }
        if (__maskrune((char)v18, 0x4000uLL))
          continue;
LABEL_61:
        if (v18 == 34)
        {
          v23 = 7;
          goto LABEL_69;
        }
        if (v18 != 125)
          goto LABEL_102;
        v29 = *(_DWORD *)(a1 + 24);
        if (!v29)
          goto LABEL_92;
        v25 = v29 - 1;
        v26 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * v25);
LABEL_91:
        if ((v26 & 1) != 0)
        {
LABEL_92:
          v19 = 125;
          goto LABEL_102;
        }
LABEL_121:
        *(_DWORD *)(a1 + 24) = v25;
        if (v25)
          v37 = 5;
        else
          v37 = 9;
        v27 = 2;
LABEL_125:
        *(_DWORD *)(a1 + 16) = v37;
LABEL_126:
        if (a2)
          memset_s(a2, 0x38uLL, 0, 0x38uLL);
        *a2 = v27;
        v38 = *(_QWORD *)(a1 + 80);
        if (v38)
          v38 = *(_QWORD *)(a1 + 88);
        *((_QWORD *)a2 + 1) = v38;
        a2[12] = *(_DWORD *)(a1 + 24);
        if (v27 == 6)
        {
          v39 = strcmp(*(const char **)(a1 + 112), "true");
          result = 0;
          a2[9] = v39 == 0;
        }
        else if (v27 == 4)
        {
          v40 = *(const char **)(a1 + 112);
          if (*v40 == 45)
          {
            v41 = strtoull(v40 + 1, 0, 10);
            result = 0;
            *((_QWORD *)a2 + 3) = v41;
            v42 = -1;
          }
          else
          {
            v43 = strtoull(v40, 0, 0);
            result = 0;
            *((_QWORD *)a2 + 3) = v43;
            v42 = v43 != 0;
          }
          a2[8] = v42;
        }
        else
        {
          result = 0;
          if (v27 == 3)
            *((_QWORD *)a2 + 2) = *(_QWORD *)(a1 + 112);
        }
        return result;
      case 7:
        if ((char)v18 == 34)
        {
          if ((jsonPushLabel(a1, 0) & 0x80000000) == 0)
          {
            v23 = 8;
            goto LABEL_69;
          }
          v30 = "jsonPushLabel";
          v31 = 587;
LABEL_103:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAJSONStreams.c", (uint64_t)"AAJSONInputStreamRead", v31, 109, 0, v30, a7, a8, v46);
          goto LABEL_104;
        }
        if ((jsonPushLabel(a1, v18) & 0x80000000) != 0)
        {
          v30 = "jsonPushLabel";
          v31 = 591;
          goto LABEL_103;
        }
        continue;
      case 8:
        if ((char)v18 < 0)
        {
          if (__maskrune((char)v18, 0x4000uLL))
            continue;
        }
        else if ((*(_DWORD *)(v14 + 4 * (char)v18 + 60) & 0x4000) != 0)
        {
          continue;
        }
        if ((char)v18 != 58)
          goto LABEL_102;
        v23 = 0;
        goto LABEL_69;
      default:
        goto LABEL_102;
    }
  }
}

uint64_t pc_array_compare(uint64_t (*a1)(_QWORD, _QWORD), _QWORD *a2, _QWORD *a3)
{
  return a1(*a2, *a3);
}

_QWORD *pc_array_init(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = malloc(a2 * a1 + 64);
  if (v4)
  {
    *v4 = 0;
    v4[1] = a2;
    v5 = v4 + 8;
    v4[2] = a1;
  }
  else
  {
    v6 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_init", 26, 139, *v6, "malloc", v7, v8, v10);
    return 0;
  }
  return v5;
}

_QWORD *pc_array_init(uint64_t a1)
{
  return pc_array_init(a1, 8);
}

void pc_array_free(uint64_t a1)
{
  if (a1)
    free((void *)(a1 - 64));
}

char *pc_array_compact(uint64_t a1)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char vars0;

  v3 = *(_QWORD *)(a1 - 64);
  v4 = *(_QWORD *)(a1 - 56);
  v2 = (char *)(a1 - 64);
  if (v4 <= v3)
    return v2 + 64;
  *(_QWORD *)(a1 - 56) = v3;
  v2 = (char *)reallocf(v2, *(_QWORD *)(a1 - 48) * v3 + 64);
  if (v2)
    return v2 + 64;
  v6 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_compact", 56, 139, *v6, "reallocf", v7, v8, vars0);
  return 0;
}

_QWORD *pc_array_append(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  const char *v17;
  __int16 v18;
  int v19;
  char v21;

  v9 = *(_QWORD *)(a1 - 64);
  v10 = *(_QWORD *)(a1 - 56);
  v11 = (_QWORD *)(a1 - 64);
  if (v10 > v9)
    goto LABEL_7;
  v12 = 2 * v10;
  v13 = v10 == 0;
  v14 = 16;
  if (!v13)
    v14 = v12;
  *(_QWORD *)(a1 - 56) = v14;
  if (v14 <= v9)
  {
    v17 = "too many elements";
    v18 = 70;
    v19 = 0;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_append", v18, 139, v19, v17, a7, a8, v21);
    return 0;
  }
  v15 = reallocf((void *)(a1 - 64), *(_QWORD *)(a1 - 48) * v14 + 64);
  if (!v15)
  {
    v19 = *__error();
    v17 = "reallocf";
    v18 = 72;
    goto LABEL_10;
  }
  v11 = v15;
  v9 = *v15;
LABEL_7:
  v16 = v11 + 8;
  memcpy((char *)v11 + v11[2] * v9 + 64, __src, v11[2]);
  ++*v11;
  return v16;
}

void pc_array_sort(void *a1, int (__cdecl *__compar)(const void *, const void *))
{
  qsort(a1, *((_QWORD *)a1 - 8), *((_QWORD *)a1 - 6), __compar);
}

_QWORD *pc_array_indirect_sort(uint64_t a1, void *a2)
{
  uint64_t v3;
  size_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v3 = a1;
  v4 = *(_QWORD *)(a1 - 64);
  v5 = malloc(8 * v4);
  v6 = v5;
  if (v5)
  {
    if (v4)
    {
      v7 = *(_QWORD *)(v3 - 48);
      v8 = v5;
      v9 = v4;
      do
      {
        *v8++ = v3;
        v3 += v7;
        --v9;
      }
      while (v9);
    }
    qsort_r(v5, v4, 8uLL, a2, (int (__cdecl *)(void *, const void *, const void *))pc_array_compare);
  }
  else
  {
    v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/GenericArray.c", (uint64_t)"pc_array_indirect_sort", 95, 139, *v10, "malloc", v11, v12, v14);
  }
  return v6;
}

uint64_t pc_array_aggregate(char *a1, unsigned int (*a2)(char *, char *), uint64_t (*a3)(char *, char *))
{
  uint64_t result;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  size_t v11;

  if (*((_QWORD *)a1 - 8) < 2uLL)
    return 0;
  v7 = &a1[*((_QWORD *)a1 - 6)];
  v8 = 1;
  v9 = 1;
  v10 = a1;
  while (1)
  {
    if (a2(v10, v7))
    {
      v11 = *((_QWORD *)a1 - 6);
      v10 += v11;
      if (v10 < v7)
        memcpy(v10, v7, v11);
      ++v9;
      goto LABEL_9;
    }
    if ((a3(v10, v7) & 0x80000000) != 0)
      return 0xFFFFFFFFLL;
LABEL_9:
    ++v8;
    v7 += *((_QWORD *)a1 - 6);
    if (v8 >= *((_QWORD *)a1 - 8))
    {
      result = 0;
      *((_QWORD *)a1 - 8) = v9;
      return result;
    }
  }
}

uint64_t ParallelArchiveConvert(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void **v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t result;
  int v25;
  unsigned int v26;
  char v27;
  char v28;
  _OWORD v29[2];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD v35[2];
  void *v36[2];
  void **v37;
  int v38;
  uint64_t v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void **v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v27);
  v33 = 0;
  v31 = 0u;
  v32 = 0u;
  v30 = 0u;
  memset(v29, 0, sizeof(v29));
  bzero(v36, 0xC10uLL);
  v35[0] = a1;
  v35[1] = a2;
  v10 = MemBufferCreate(0x100000uLL);
  v37 = v10;
  v11 = MemBufferCreate(0x100000uLL);
  v43 = v11;
  if (!v10 || !v11)
  {
    v21 = "allocating state buffers";
    v22 = 769;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"ParallelArchiveConvert", v22, 62, 0, v21, v17, v18, v28);
    v20 = 1;
    goto LABEL_10;
  }
  *(_QWORD *)&v29[0] = 0;
  DWORD1(v29[0]) = *(_DWORD *)(a2 + 4);
  v19 = *(_OWORD *)(a2 + 24);
  *((_QWORD *)&v29[1] + 1) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)&v30 = convertBegin;
  *((_QWORD *)&v30 + 1) = convertBlob;
  *(_QWORD *)&v31 = convertPayload;
  *(_OWORD *)((char *)v29 + 8) = v19;
  *((_QWORD *)&v31 + 1) = convertPadding;
  *(_QWORD *)&v32 = convertEnd;
  *((_QWORD *)&v32 + 1) = convertPadding;
  v33 = v35;
  if ((ParallelArchiveRead((uint64_t)v29, v12, v13, v14, v15, v16, v17, v18) & 0x80000000) != 0)
  {
    v21 = "Archive read";
    v22 = 787;
    goto LABEL_9;
  }
  if (*(int *)a2 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu bytes read\n", v39);
  v20 = 0;
LABEL_10:
  MemBufferDestroy(v43);
  MemBufferDestroy(v37);
  if (v42)
  {
    v59 = 0u;
    v58 = 0u;
    v57 = 0u;
    v56 = 0u;
    v55 = 0u;
    v54 = 0u;
    v53 = 0u;
    v52 = 0u;
    v51 = 0u;
    v50 = 0u;
    v49 = 0u;
    v48 = 0u;
    v47 = 0u;
    v46 = 0u;
    v45 = 0u;
    v44 = 0u;
    v34 = 0;
    ParallelArchiveDBRequestCloseAndGetKey(v42);
  }
  if (v41)
    ParallelArchiveDBRequestClose(v41);
  ParallelArchiveDBSetDestroy((uint64_t)v36[0]);
  ParallelArchiveDBSessionDestroy((uint64_t)v36[1]);
  free(v40);
  v23 = v38;
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v23)
    v25 = 1;
  else
    v25 = v20;
  v26 = v25 << 31 >> 31;
  if ((int)result >= 0)
    return v26;
  else
    return result;
}

uint64_t convertBegin(uint64_t result, _DWORD *a2, const void *a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(_QWORD, _DWORD *, _QWORD);
  const char *v24;
  __int16 v25;
  uint64_t v26;
  uint64_t (*v27)(_QWORD);
  int v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  BOOL v33;
  unsigned int v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  const char *v40;
  int v41;
  __int16 v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  uint64_t v62;
  uint64_t (*v63)(_QWORD);
  char v64;
  char v65[1024];
  char v66[1024];
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(result + 56))
    return result;
  v11 = result;
  v12 = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 2296) = 0;
  *(_QWORD *)(result + 64) = v12 + a6;
  *(_QWORD *)(result + 72) = 0;
  *(_QWORD *)(result + 80) = 0;
  *(_QWORD *)(result + 88) = 0;
  MemBufferClear(*(_QWORD **)(result + 2856));
  bzero((void *)(v11 + 96), 0x890uLL);
  if ((reserveExtraFields(v11, a4) & 0x80000000) != 0)
  {
    v24 = "allocating extraFields";
    v25 = 424;
LABEL_10:
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertBegin", v25, 62, 0, v24, v13, v14, v64);
    if (!*(_DWORD *)(v11 + 56))
    {
      *(_DWORD *)(v11 + 56) = 1;
      v26 = *(_QWORD *)(v11 + 8);
      v27 = *(uint64_t (**)(_QWORD))(v26 + 32);
      if (v27)
        return v27(*(_QWORD *)(v26 + 40));
    }
    return result;
  }
  memcpy((void *)(v11 + 96), a2, 0x890uLL);
  result = (uint64_t)memcpy(*(void **)(v11 + 2304), a3, 1032 * a4);
  *(_QWORD *)(v11 + 2296) = a4;
  v33 = a2[1] == 77;
  *(_DWORD *)(v11 + 72) = v33;
  if (v33)
    return result;
  if (*(_DWORD *)(v11 + 60))
    goto LABEL_6;
  v28 = 99103;
  if (a6 >= 8)
  {
    v29 = 0;
    v30 = 0;
    do
    {
      v31 = v30;
      v30 = *(_BYTE *)(a5 + v29++) & 7 | (8 * v30);
    }
    while (v29 != 8);
    v32 = ((8 * v31) >> 6) & 0x3FFFF;
    v33 = v32 == 29121 || v32 == 29127;
    if (v33)
      v28 = 99191;
    else
      v28 = 99103;
  }
  *(_DWORD *)(v11 + 40) = v28;
  *(_DWORD *)(v11 + 44) = 0;
  if ((resolveFields(v11, v15, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
  {
    v24 = "resolving output fields";
    v25 = 472;
    goto LABEL_10;
  }
  result = writeMetadata();
  if ((result & 0x80000000) != 0)
  {
    v24 = "writing metadata";
    v25 = 475;
    goto LABEL_10;
  }
  if (!*(_DWORD *)(v11 + 60))
  {
    v24 = "metadata entry was not written";
    v25 = 482;
    goto LABEL_10;
  }
LABEL_6:
  v22 = *(_QWORD *)(v11 + 8);
  v23 = *(uint64_t (**)(_QWORD, _DWORD *, _QWORD))(v22 + 48);
  if (v23)
  {
    result = v23(*(_QWORD *)(v22 + 56), a2 + 36, a2[1]);
    *(_DWORD *)(v11 + 76) = (int)result < 1;
    if ((int)result < 1)
      return result;
  }
  else if (*(_DWORD *)(v11 + 76))
  {
    return result;
  }
  v34 = *(_DWORD *)(v11 + 96);
  if (*(_QWORD *)(v11 + 2296))
  {
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    LOWORD(v39) = 0;
    while (1)
    {
      v40 = (const char *)(*(_QWORD *)(v11 + 2304) + v35);
      *(_DWORD *)v66 = 0;
      result = yaa_parseFields(v40, 0, v66);
      v41 = *(_DWORD *)v66;
      if (*(_DWORD *)v66)
      {
        if ((*(_DWORD *)(v11 + 52) & *(_DWORD *)v66) != 0)
          goto LABEL_33;
      }
      else if (*(_DWORD *)(*(_QWORD *)(v11 + 8) + 20))
      {
LABEL_33:
        if (v36 != v37)
          result = (uint64_t)memcpy((void *)(*(_QWORD *)(v11 + 2304) + 1032 * v37), (const void *)(*(_QWORD *)(v11 + 2304) + v35), 0x408uLL);
        ++v37;
      }
      v39 = v41 | v38 | (unsigned __int16)v39;
      v38 = v39 & 0xFFFF0000;
      ++v36;
      v35 += 1032;
      if (v36 >= *(_QWORD *)(v11 + 2296))
      {
        v42 = v39;
        goto LABEL_40;
      }
    }
  }
  v42 = 0;
  LOWORD(v38) = 0;
  v37 = 0;
LABEL_40:
  v43 = 0;
  *(_QWORD *)(v11 + 2296) = v37;
  v44 = *(_DWORD *)(v11 + 48);
  *(_DWORD *)(v11 + 96) = v44 & v34;
  v45 = v44 & 0x2000;
  if ((v34 & 0x2200) != 0x200)
    v45 = 512;
  if ((v34 & 0x4200) == 0x200)
    v46 = v44 & 0x4000;
  else
    v46 = 512;
  if ((v34 & 0x1200) == 0x200)
    v47 = v44 & 0x1000;
  else
    v47 = 512;
  v48 = (v34 >> 7) & 1;
  if ((v34 & 0x200) == 0)
    v48 = 1;
  v33 = v48 == 0;
  v49 = v44 & 0x80;
  if (!v33)
    v49 = 0;
  if ((v42 & 8) == 0 && (v34 & 0x200) != 0)
    v43 = *(_WORD *)(v11 + 52) & 8;
  v50 = 0;
  v51 = *(_DWORD *)(v11 + 84) & 0xFFFF8D7F | v45;
  v52 = v46 | v47;
  v53 = *(_WORD *)(v11 + 88) & 0xFFE7 | v43;
  if ((v42 & 0x10) == 0 && (v34 & 0x200) != 0)
    v50 = *(_WORD *)(v11 + 52) & 0x10;
  v54 = v51 | v52;
  v55 = v50 | v53;
  if ((v42 & 0x100) != 0 || (v34 & 0x200) == 0)
  {
    v57 = (v34 >> 9) & 1;
    if ((v42 & 0x10) != 0)
      v58 = (v34 >> 9) & 1;
    else
      v58 = 1;
    LOWORD(v55) = v55 & 0xFEFF;
    if ((v34 & 0x80) == 0)
      v58 = 1;
    v56 = v44 & 0x200;
    if (v58)
      v56 = 0;
  }
  else
  {
    v56 = 0;
    v55 = v55 & 0xFFFFFEFF | ((HIBYTE(*(unsigned __int16 *)(v11 + 52)) & 1) << 8);
    LOBYTE(v57) = 1;
  }
  *(_WORD *)(v11 + 88) = v55;
  *(_DWORD *)(v11 + 84) = v56 | v49 | v54 & 0xFFFFFD7F;
  if (**(int **)(v11 + 8) >= 3)
  {
    bzero(v66, 0x400uLL);
    bzero(v65, 0x400uLL);
    yaa_serializeFields(v66, 0x400uLL, v34, v38 | v42);
    yaa_serializeFields(v65, 0x400uLL, *(_DWORD *)(v11 + 84), *(_DWORD *)(v11 + 88));
    result = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: generating %s -> %s\n", (const char *)(v11 + 240), v66, v65);
  }
  if ((v42 & 2) == 0
    && (*(_WORD *)(v11 + 52) & 2) != 0
    && (result = insertUINTField(v11, v12), (result & 0x80000000) != 0))
  {
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertBegin", 544, 62, 0, "inserting IDX", v59, v60, v64);
    if (!*(_DWORD *)(v11 + 56))
    {
      *(_DWORD *)(v11 + 56) = 1;
      v62 = *(_QWORD *)(v11 + 8);
      v63 = *(uint64_t (**)(_QWORD))(v62 + 32);
      if (v63)
        return v63(*(_QWORD *)(v62 + 40));
    }
  }
  else
  {
    if ((*(_BYTE *)(v11 + 40) & 0x80) != 0)
      v61 = v57;
    else
      v61 = 1;
    if ((v61 & 1) == 0)
      *(_QWORD *)(v11 + 160) = *(_QWORD *)(v11 + 136);
  }
  return result;
}

void convertEnd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  const char *DataPtr;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int v19;
  int v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  void (*v24)(_QWORD);
  char *v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t DataSize;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t i;
  __int16 v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;

  if (*(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 76))
    return;
  if (*(_DWORD *)(a1 + 72))
  {
    if ((reserveBlobPayload(a1, 1) & 0x80000000) != 0)
    {
      v17 = "allocating blob buffer";
      v18 = 561;
    }
    else
    {
      DataPtr = (const char *)MemBufferGetDataPtr(*(_QWORD *)(a1 + 2856));
      DataPtr[MemBufferGetDataSize(*(_QWORD *)(a1 + 2856))] = 0;
      if ((yaa_parseFields(DataPtr, (_DWORD *)(a1 + 40), (_WORD *)(a1 + 44)) & 0x80000000) != 0)
      {
        v17 = "parsing YAF blob";
        v18 = 565;
      }
      else if ((resolveFields(a1, v12, v13, v14, v15, v16, v9, v10) & 0x80000000) != 0)
      {
        v17 = "resolving output fields";
        v18 = 568;
      }
      else
      {
        if ((writeMetadata() & 0x80000000) == 0)
          return;
        v17 = "writing metadata";
        v18 = 571;
      }
    }
    goto LABEL_22;
  }
  v19 = *(_DWORD *)(a1 + 84);
  if ((v19 & 0x200) != 0 && *(_QWORD *)(a1 + 16))
  {
    v19 &= ~0x200u;
    *(_DWORD *)(a1 + 84) = v19;
    *(_DWORD *)(a1 + 96) |= 0x200u;
    v20 = 1;
  }
  else
  {
    v20 = 0;
  }
  if (*(_DWORD *)(a1 + 80))
  {
    v21 = "writing entry header twice";
    v22 = 368;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"writeHeader", v22, 62, 0, v21, a7, a8, v51);
    v17 = "writing entry header";
    v18 = 587;
    goto LABEL_22;
  }
  if (v19 || *(_DWORD *)(a1 + 88))
  {
    v21 = "writing header before all required fields are updated";
    v22 = 369;
    goto LABEL_20;
  }
  if ((ParallelArchiveWriteEntryHeader(*(_QWORD *)a1, a1 + 96, *(_QWORD *)(a1 + 2304), *(_QWORD *)(a1 + 2296), a5, a6, a7, a8) & 0x80000000) != 0)
  {
    v21 = "writing entry header";
    v22 = 373;
    goto LABEL_20;
  }
  *(_DWORD *)(a1 + 80) = 1;
  if (v20)
  {
    if (*(_QWORD *)(a1 + 2584))
      v25 = (char *)(a1 + 2328);
    else
      v25 = 0;
    v26 = *(_QWORD *)(a1 + 160);
    v27 = ParallelArchiveDBReadRequestOpenWithSet(*(uint64_t **)(a1 + 16), v25, a1 + 2592, *(_QWORD *)(a1 + 2848), 0, v26, 0, a8);
    *(_QWORD *)(a1 + 2312) = v27;
    if (!v27)
    {
      v17 = "opening read request from database";
      v18 = 597;
      goto LABEL_22;
    }
    v28 = MemBufferTransmit(*(unint64_t **)(a1 + 32), v26, (size_t (*)(int, void *, size_t))readFromDBProc, a1, (uint64_t (*)(uint64_t, uint64_t, uint64_t))archiveWriterProc, a1, v9, v10);
    if (v28 < 0 || v28 != v26)
    {
      v17 = "readining from database";
      v18 = 600;
      goto LABEL_22;
    }
    ParallelArchiveDBRequestClose(*(_QWORD **)(a1 + 2312));
    *(_QWORD *)(a1 + 2312) = 0;
  }
  if (MemBufferGetDataSize(*(_QWORD *)(a1 + 2856)))
  {
    v32 = MemBufferGetDataPtr(*(_QWORD *)(a1 + 2856));
    DataSize = MemBufferGetDataSize(*(_QWORD *)(a1 + 2856));
    if ((ParallelArchiveWriteEntryData(*(_QWORD *)a1, v32, DataSize, v34, v35, v36, v37, v38) & 0x80000000) != 0)
    {
      v17 = "writing entry data BLOBS";
      v18 = 612;
LABEL_22:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertEnd", v18, 62, 0, v17, v9, v10, v51);
      if (!*(_DWORD *)(a1 + 56))
      {
        *(_DWORD *)(a1 + 56) = 1;
        v23 = *(_QWORD *)(a1 + 8);
        v24 = *(void (**)(_QWORD))(v23 + 32);
        if (v24)
          v24(*(_QWORD *)(v23 + 40));
      }
      return;
    }
  }
  if (*(_QWORD *)(a1 + 2296))
  {
    v39 = 0;
    for (i = 0; i < *(_QWORD *)(a1 + 2296); ++i)
    {
      v41 = *(_WORD *)(a1 + 92);
      if ((v41 & 8) != 0
        && (*(_DWORD *)(*(_QWORD *)(a1 + 2304) + v39) & 0xDFDFDF) == 0x414459
        && (v42 = *(_QWORD *)(a1 + 2584)) != 0)
      {
        if ((ParallelArchiveWriteEntryData(*(_QWORD *)a1, a1 + 2328, v42, v29, v30, v31, v9, v10) & 0x80000000) != 0)
        {
          v17 = "writing entry data YDA";
          v18 = 620;
          goto LABEL_22;
        }
      }
      else if ((v41 & 0x10) != 0
             && (*(_DWORD *)(*(_QWORD *)(a1 + 2304) + v39) & 0xDFDFDF) == 0x4B4459
             && (v43 = *(_QWORD *)(a1 + 2848)) != 0)
      {
        if ((ParallelArchiveWriteEntryData(*(_QWORD *)a1, a1 + 2592, v43, v29, v30, v31, v9, v10) & 0x80000000) != 0)
        {
          v17 = "writing entry data YDK";
          v18 = 625;
          goto LABEL_22;
        }
      }
      else if ((*(_WORD *)(a1 + 92) & 0x100) != 0 && (*(_DWORD *)(*(_QWORD *)(a1 + 2304) + v39) & 0xDFDFDF) == 0x434559)
      {
        v44 = OECCStreamGetDataSize(*(_QWORD *)(a1 + 3096));
        v45 = OECCStreamGetDataPtr(*(_QWORD *)(a1 + 3096));
        if ((ParallelArchiveWriteEntryData(*(_QWORD *)a1, v45, v44, v46, v47, v48, v49, v50) & 0x80000000) != 0)
        {
          v17 = "writing entry data YEC";
          v18 = 632;
          goto LABEL_22;
        }
      }
      v39 += 1032;
    }
  }
  OECCStreamDestroy(*(void ***)(a1 + 3096));
  *(_QWORD *)(a1 + 3096) = 0;
}

uint64_t convertBlob(uint64_t result, __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  __int16 v10;
  int v11;
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  const char *v17;
  __int16 v18;
  int v19;
  int v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;
  uint64_t (*v27)(_QWORD);
  char v28;

  if (*(_DWORD *)(result + 56))
    return result;
  v8 = result;
  if (*(_DWORD *)(result + 76))
    return result;
  *(_DWORD *)(result + 2868) = 0;
  v10 = *a2;
  *(_BYTE *)(result + 2866) = *((_BYTE *)a2 + 2);
  *(_WORD *)(result + 2864) = v10;
  *(_BYTE *)(result + 2867) = 0;
  *(_QWORD *)(result + 2872) = a3;
  v11 = *(_DWORD *)(result + 2864);
  v12 = v11 & 0xDFDFDF;
  if (*(_DWORD *)(result + 72))
  {
    if (v12 != 4604249)
      return result;
    result = reserveBlobPayload(result, a3 + 1);
    if ((result & 0x80000000) == 0)
    {
      *(_DWORD *)(v8 + 2868) = 1;
      return result;
    }
    v17 = "allocating blob buffer";
    v18 = 661;
    goto LABEL_48;
  }
  if (v12 == 4997953)
  {
    v13 = 11;
LABEL_12:
    v14 = *(_DWORD *)(result + 48) >> v13;
    *(_DWORD *)(result + 2868) = v14 & 1;
    if ((v14 & 1) == 0)
      goto LABEL_23;
    goto LABEL_21;
  }
  if (v12 == 5521752)
  {
    v13 = 10;
    goto LABEL_12;
  }
  v15 = *(_QWORD *)(result + 2296);
  if (!v15)
    goto LABEL_23;
  v16 = *(_DWORD **)(result + 2304);
  while (((*v16 ^ v11) & 0xDFDFDF) != 0)
  {
    v16 += 258;
    if (!--v15)
      goto LABEL_23;
  }
  *(_DWORD *)(result + 2868) = 1;
LABEL_21:
  result = reserveBlobPayload(result, a3);
  if ((result & 0x80000000) != 0)
  {
    v17 = "allocating blob buffer";
    v18 = 683;
    goto LABEL_48;
  }
  v11 = *(_DWORD *)(v8 + 2864);
LABEL_23:
  v19 = v11 & 0xDFDFDF;
  switch(v19)
  {
    case 5521732:
      v20 = *(_DWORD *)(v8 + 84);
      if ((v20 & 0x80) != 0)
      {
        *(_DWORD *)(v8 + 96) |= 0x80u;
        *(_QWORD *)(v8 + 136) = a3;
      }
      LOWORD(v21) = v20 & 0xFF7F;
      *(_DWORD *)(v8 + 84) = v20 & 0xFFFFFF7F;
      if ((v20 & 0x2000) != 0)
      {
        result = CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)(v8 + 2880));
        v21 = *(_DWORD *)(v8 + 84);
        if ((v21 & 0x4000) == 0)
        {
LABEL_31:
          if ((v21 & 0x1000) == 0)
            goto LABEL_33;
          goto LABEL_32;
        }
      }
      else if ((v20 & 0x4000) == 0)
      {
        goto LABEL_31;
      }
      result = CC_SHA256_Init((CC_SHA256_CTX *)(v8 + 2976));
      if ((*(_DWORD *)(v8 + 84) & 0x1000) == 0)
      {
LABEL_33:
        v22 = *(_WORD *)(v8 + 88);
        if ((v22 & 0x100) != 0)
        {
          result = (uint64_t)OECCStreamCreate(1, 0x4000u, a3);
          *(_QWORD *)(v8 + 3096) = result;
          if (!result)
          {
            v24 = "creating ECC context to get YEC";
            v25 = 228;
LABEL_47:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"processDATBegin", v25, 62, 0, v24, a7, a8, v28);
            v17 = "processing DAT begin";
            v18 = 693;
LABEL_48:
            result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertBlob", v18, 62, 0, v17, a7, a8, v28);
            if (!*(_DWORD *)(v8 + 56))
            {
              *(_DWORD *)(v8 + 56) = 1;
              v26 = *(_QWORD *)(v8 + 8);
              v27 = *(uint64_t (**)(_QWORD))(v26 + 32);
              if (v27)
                return v27(*(_QWORD *)(v26 + 40));
            }
            return result;
          }
          v22 = *(_WORD *)(v8 + 88);
        }
        if ((v22 & 0x18) == 0)
          return result;
        v23 = *(_QWORD *)(v8 + 24);
        if (v23)
        {
          result = (uint64_t)ParallelArchiveDBRequestOpenForWriting(v23, *(_QWORD *)(v8 + 160), 0);
          *(_QWORD *)(v8 + 2320) = result;
          if (result)
            return result;
          v24 = "creating database write request";
          v25 = 236;
        }
        else
        {
          v24 = "can't connect to database to get YDA YDK";
          v25 = 234;
        }
        goto LABEL_47;
      }
LABEL_32:
      result = CC_CKSUM_Init(v8 + 3080);
      goto LABEL_33;
    case 4932697:
      *(_QWORD *)(v8 + 2848) = 0;
      break;
    case 4277337:
      *(_QWORD *)(v8 + 2584) = 0;
      break;
  }
  return result;
}

uint64_t convertPayload(uint64_t result, void *__src, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t (*v18)(_QWORD);
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  char v22;

  if (*(_DWORD *)(result + 56))
    return result;
  v9 = result;
  *(_QWORD *)(result + 64) += __n;
  if (*(_DWORD *)(result + 76))
    return result;
  *(_QWORD *)(result + 2872) -= __n;
  if (*(_DWORD *)(result + 2868))
  {
    result = MemBufferFillFromBuffer(*(unint64_t **)(result + 2856), __n, __src);
    if (result < 0)
    {
      v15 = "storing blob data";
      v16 = 710;
      goto LABEL_19;
    }
  }
  if (*(_DWORD *)(v9 + 72))
    return result;
  v11 = *(_DWORD *)(v9 + 2864) & 0xDFDFDF;
  if (v11 == 4277337)
  {
    v19 = *(_QWORD *)(v9 + 2584);
    if (__n + v19 - 256 <= 0xFFFFFFFFFFFFFEFELL)
    {
      v15 = "YDA payload is too large";
      v16 = 727;
      goto LABEL_19;
    }
    result = (uint64_t)memcpy((void *)(v9 + 2328 + v19), __src, __n);
    v21 = *(_QWORD *)(v9 + 2584) + __n;
    *(_QWORD *)(v9 + 2584) = v21;
    *(_BYTE *)(v9 + 2328 + v21) = 0;
    goto LABEL_28;
  }
  if (v11 == 4932697)
  {
    v20 = *(_QWORD *)(v9 + 2848);
    if (v20 + __n >= 0x101)
    {
      v15 = "YDK payload is too large";
      v16 = 734;
      goto LABEL_19;
    }
    result = (uint64_t)memcpy((void *)(v9 + v20 + 2592), __src, __n);
    *(_QWORD *)(v9 + 2848) += __n;
LABEL_28:
    if ((*(_DWORD *)(v9 + 2864) & 0xDFDFDF) != 0x544144)
      return result;
    if (*(_QWORD *)(v9 + 2872))
      return result;
    result = processDATEnd(v9);
    if ((result & 0x80000000) == 0)
      return result;
    v15 = "processing DAT end";
    v16 = 742;
    goto LABEL_19;
  }
  if (v11 != 5521732)
    goto LABEL_28;
  result = *(_QWORD *)(v9 + 2320);
  if (result)
  {
    result = ParallelArchiveDBRequestWrite((_QWORD *)result);
    if (result < 0)
    {
      v13 = "writing data to database request";
      v14 = 248;
      goto LABEL_36;
    }
  }
  v12 = *(_DWORD *)(v9 + 84);
  if ((v12 & 0x2000) == 0)
  {
    if ((v12 & 0x4000) == 0)
      goto LABEL_13;
LABEL_33:
    result = CC_SHA256_Update((CC_SHA256_CTX *)(v9 + 2976), __src, __n);
    if ((*(_DWORD *)(v9 + 84) & 0x1000) == 0)
      goto LABEL_15;
    goto LABEL_14;
  }
  result = CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(v9 + 2880), __src, __n);
  v12 = *(_DWORD *)(v9 + 84);
  if ((v12 & 0x4000) != 0)
    goto LABEL_33;
LABEL_13:
  if ((v12 & 0x1000) != 0)
LABEL_14:
    result = CC_CKSUM_Update(v9 + 3080, (unsigned __int8 *)__src, __n);
LABEL_15:
  if ((*(_WORD *)(v9 + 88) & 0x100) == 0)
    goto LABEL_28;
  result = OECCStreamWrite(*(_QWORD *)(v9 + 3096), (char *)__src, __n, a4, a5, a6, a7, a8);
  if ((result & 0x8000000000000000) == 0)
    goto LABEL_28;
  v13 = "writing data to ECC stream";
  v14 = 258;
LABEL_36:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"processDATPayload", v14, 62, 0, v13, a7, a8, v22);
  v15 = "processing DAT payload";
  v16 = 723;
LABEL_19:
  result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"convertPayload", v16, 62, 0, v15, a7, a8, v22);
  if (!*(_DWORD *)(v9 + 56))
  {
    *(_DWORD *)(v9 + 56) = 1;
    v17 = *(_QWORD *)(v9 + 8);
    v18 = *(uint64_t (**)(_QWORD))(v17 + 32);
    if (v18)
      return v18(*(_QWORD *)(v17 + 40));
  }
  return result;
}

uint64_t convertPadding(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(result + 56))
    *(_QWORD *)(result + 64) += a3;
  return result;
}

uint64_t reserveExtraFields(uint64_t a1, unint64_t a2)
{
  void *v3;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  if (*(_QWORD *)(a1 + 2288) > a2)
    return 0;
  *(_QWORD *)(a1 + 2288) = a2 + 8;
  v3 = reallocf(*(void **)(a1 + 2304), 1032 * (a2 + 8));
  *(_QWORD *)(a1 + 2304) = v3;
  if (v3)
    return 0;
  v5 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"reserveExtraFields", 98, 62, *v5, "malloc", v6, v7, v8);
  return 0xFFFFFFFFLL;
}

uint64_t resolveFields(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  __int16 v16;
  int v17;
  _BOOL4 v18;
  int v19;
  const char *v22;
  __int16 v23;
  size_t v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  _OWORD *v29;
  FILE **v30;
  char v31;
  char v32[1024];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_DWORD *)(v9 + 12);
  v11 = *(unsigned __int16 *)(v9 + 16);
  v12 = *(_DWORD *)(a1 + 40);
  v13 = *(_DWORD *)(a1 + 44);
  v14 = v12 & v10;
  v15 = v11 | (*(unsigned __int16 *)(v9 + 18) << 16);
  *(_DWORD *)(a1 + 48) = v12 & v10;
  *(_DWORD *)(a1 + 52) = v13 & v15;
  v16 = v13 & v15 & 0xFFFD | v11 & 2;
  *(_WORD *)(a1 + 52) = v16;
  v17 = (v12 >> 9) & 1;
  v18 = (v12 & 0x80) == 0;
  if ((v13 & 0x10) == 0)
    v18 = 1;
  if (!v18)
    v17 = 1;
  v19 = 0;
  if ((v10 & 0x1000) != 0 && (v12 & 0x1000) == 0 && v17)
  {
    v14 |= 0x1000u;
    *(_DWORD *)(a1 + 48) = v14;
    v19 = 1;
  }
  if ((v10 & 0x2000) != 0 && (v12 & 0x2000) == 0 && v17)
  {
    v14 |= 0x2000u;
    *(_DWORD *)(a1 + 48) = v14;
    v19 = 1;
  }
  if ((v10 & 0x4000) != 0 && (v12 & 0x4000) == 0 && v17)
  {
    v14 |= 0x4000u;
    *(_DWORD *)(a1 + 48) = v14;
    v19 = 1;
  }
  if ((v10 & 0x80) != 0 && (v12 & 0x80) == 0 && v17)
  {
    v14 |= 0x80u;
    *(_DWORD *)(a1 + 48) = v14;
    v19 = 1;
  }
  if ((v11 & 0x10) != 0 && v17 && (v13 & 0x10) == 0)
  {
    v16 |= 0x10u;
    *(_WORD *)(a1 + 52) = v16;
    v19 = 1;
  }
  if ((v11 & 0x100) != 0 && v17 && (v13 & 0x100) == 0)
  {
    *(_WORD *)(a1 + 52) = v16 | 0x100;
    v19 = 1;
  }
  if ((v10 & 0x200) != 0 && (v12 & 0x200) == 0 && v17)
  {
    v14 |= 0x200u;
    *(_DWORD *)(a1 + 48) = v14;
  }
  if (v19 && (v14 & 0x200) != 0)
  {
    v22 = "Can't write DAT-based field and DAT itself at the same time";
    v23 = 142;
LABEL_42:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"resolveFields", v23, 62, 0, v22, a7, a8, v31);
    return 0xFFFFFFFFLL;
  }
  if ((v12 & 0x200) == 0 && (v14 & 0x200) != 0)
  {
    if (v18 || (v25 = *(_QWORD *)(v9 + 64)) == 0)
    {
      *(_DWORD *)(a1 + 48) = v14 & 0xFFFFFDFF;
    }
    else
    {
      v26 = ParallelArchiveDBSetCreate(v25, *(_QWORD *)(v9 + 72), 0, a4, a5, a6, a7, a8);
      *(_QWORD *)(a1 + 16) = v26;
      if (!v26)
      {
        v22 = "connecting to database";
        v23 = 152;
        goto LABEL_42;
      }
      if (**(int **)(a1 + 8) >= 1)
        fwrite("Reading DAT blobs from database\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
  }
  v27 = *(_WORD *)(a1 + 52);
  if ((v27 & 0x10) != 0 && (*(_WORD *)(a1 + 44) & 0x10) == 0)
  {
    if ((*(_BYTE *)(a1 + 41) & 2) != 0 && (v28 = *(_QWORD *)(a1 + 8), *(_QWORD *)(v28 + 64) == 1))
    {
      v29 = ParallelArchiveDBSessionCreate(**(char ***)(v28 + 72), (void *)(a1 + 2328), 0x100uLL, 0);
      *(_QWORD *)(a1 + 24) = v29;
      if (!v29)
      {
        v22 = "connecting to database";
        v23 = 164;
        goto LABEL_42;
      }
      *(_QWORD *)(a1 + 2584) = strlen((const char *)(a1 + 2328));
      if (**(int **)(a1 + 8) >= 1)
        fwrite("Writing DAT blobs to database\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    }
    else
    {
      *(_WORD *)(a1 + 52) = v27 & 0xFFEF;
    }
  }
  *(_WORD *)(a1 + 52) = (*(_WORD *)(a1 + 52) >> 1) & 8 | *(_WORD *)(a1 + 52) & 0xFFF7;
  if (**(int **)(a1 + 8) >= 1)
  {
    bzero(v32, 0x400uLL);
    yaa_serializeFields(v32, 0x400uLL, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44));
    v30 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Input fields:          %s\n", v32);
    yaa_serializeFields(v32, 0x400uLL, v10, v15);
    fprintf(*v30, "Allowed output fields: %s\n", v32);
    yaa_serializeFields(v32, 0x400uLL, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52));
    fprintf(*v30, "Output fields:         %s\n", v32);
  }
  return 0;
}

uint64_t writeMetadata()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  const char *v3;
  __int16 v4;
  uint64_t result;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15[1024];
  _BYTE v16[3];
  _BYTE v17[5];
  unint64_t v18;
  uint64_t v19;
  _QWORD v20[274];

  v0 = MEMORY[0x24BDAC7A8]();
  v20[273] = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(v0 + 60))
  {
    v3 = "writing archive metadata twice";
    v4 = 334;
  }
  else
  {
    v6 = v0;
    bzero(v15, 0x400uLL);
    if ((yaa_serializeFields(v15, 0x400uLL, *(_DWORD *)(v6 + 48), *(_DWORD *)(v6 + 52)) & 0x80000000) != 0)
    {
      v3 = "serializing YAF entry";
      v4 = 342;
    }
    else
    {
      v7 = strlen(v15) + 1;
      bzero(v20, 0x888uLL);
      v19 = 0x4D00000001;
      bzero(v17, 0x405uLL);
      qmemcpy(v16, "YAF", sizeof(v16));
      *(_DWORD *)&v17[1] = 2;
      v18 = v7;
      if ((ParallelArchiveWriteEntryHeader(*(_QWORD *)v6, (uint64_t)&v19, (uint64_t)v16, 1, v8, v9, v10, v11) & 0x80000000) != 0)
      {
        v3 = "writing metadata entry header";
        v4 = 356;
      }
      else
      {
        if ((ParallelArchiveWriteEntryData(*(_QWORD *)v6, (uint64_t)v15, v7, v12, v13, v14, v1, v2) & 0x80000000) == 0)
        {
          result = 0;
          *(_DWORD *)(v6 + 60) = 1;
          return result;
        }
        v3 = "writing metadata entry blob";
        v4 = 357;
      }
    }
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"writeMetadata", v4, 62, 0, v3, v1, v2, v15[0]);
  return 0xFFFFFFFFLL;
}

uint64_t insertUINTField(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _WORD *v6;
  uint64_t result;
  char v8;

  if ((reserveExtraFields(a1, *(_QWORD *)(a1 + 2296) + 1) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"insertUINTField", 191, 62, 0, "reserving extra fields", v4, v5, v8);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v6 = (_WORD *)(*(_QWORD *)(a1 + 2304) + 1032 * *(_QWORD *)(a1 + 2296));
    bzero(v6, 0x408uLL);
    result = 0;
    *((_DWORD *)v6 + 1) = 1;
    *v6 = 17481;
    *((_BYTE *)v6 + 2) = 88;
    *((_QWORD *)v6 + 1) = a2;
    ++*(_QWORD *)(a1 + 2296);
  }
  return result;
}

uint64_t reserveBlobPayload(uint64_t a1, uint64_t a2)
{
  uint64_t DataSize;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v11;

  DataSize = MemBufferGetDataSize(*(_QWORD *)(a1 + 2856));
  if (__CFADD__(DataSize, a2))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"reserveBlobPayload", 106, 62, 0, "invalid blob size: %llu", v5, v6, a2);
  }
  else
  {
    v7 = MemBufferIncreaseCapacity(*(_QWORD *)(a1 + 2856), DataSize + a2);
    if ((v7 & 0x8000000000000000) == 0)
      return 0;
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"reserveBlobPayload", 107, 62, 0, "resize blob buffer", v8, v9, v11);
  }
  return 0xFFFFFFFFLL;
}

uint64_t readFromDBProc(uint64_t a1)
{
  return ParallelArchiveDBRequestRead(*(_QWORD **)(a1 + 2312));
}

unint64_t archiveWriterProc(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t result;

  LODWORD(result) = ParallelArchiveWriteEntryData(*a1, a2, a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) == 0)
    return a3;
  else
    return (int)result;
}

uint64_t processDATEnd(uint64_t a1)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  __int16 v5;
  uint64_t DataSize;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  __int16 v10;
  __int16 v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  char v15;

  v2 = *(_DWORD *)(a1 + 84);
  if ((v2 & 0x2000) != 0)
  {
    *(_DWORD *)(a1 + 96) |= 0x2000u;
    CC_SHA1_Deprecated_Final((unsigned __int8 *)(a1 + 188), (CC_SHA1_CTX *)(a1 + 2880));
    v2 = *(_DWORD *)(a1 + 84);
  }
  v3 = v2 & 0xFFFFDFFF;
  *(_DWORD *)(a1 + 84) = v2 & 0xFFFFDFFF;
  if ((v2 & 0x4000) != 0)
  {
    *(_DWORD *)(a1 + 96) |= 0x4000u;
    CC_SHA256_Final((unsigned __int8 *)(a1 + 208), (CC_SHA256_CTX *)(a1 + 2976));
    v3 = *(_DWORD *)(a1 + 84);
  }
  v4 = v3 & 0xFFFFBFFF;
  *(_DWORD *)(a1 + 84) = v3 & 0xFFFFBFFF;
  if ((v3 & 0x1000) != 0)
  {
    *(_DWORD *)(a1 + 96) |= 0x1000u;
    CC_CKSUM_Final((unsigned int *)(a1 + 184), a1 + 3080);
    v4 = *(_DWORD *)(a1 + 84);
  }
  *(_DWORD *)(a1 + 84) = v4 & 0xFFFFEFFF;
  v5 = *(_WORD *)(a1 + 88);
  if ((v5 & 0x100) != 0)
  {
    DataSize = OECCStreamGetDataSize(*(_QWORD *)(a1 + 3096));
    if ((insertBLOBField(a1, (__int16 *)"YEC", DataSize) & 0x80000000) != 0)
    {
      v13 = "inserting YEC";
      v14 = 295;
      goto LABEL_24;
    }
    *(_WORD *)(a1 + 92) |= 0x100u;
    v5 = *(_WORD *)(a1 + 88);
  }
  *(_WORD *)(a1 + 88) = v5 & 0xFEFF;
  result = *(_QWORD *)(a1 + 2320);
  if (!result)
    return result;
  if ((ParallelArchiveDBRequestCloseAndGetKey((_QWORD *)result) & 0x80000000) != 0)
  {
    v13 = "finalizing database write";
    v14 = 304;
  }
  else
  {
    *(_QWORD *)(a1 + 2320) = 0;
    v10 = *(_WORD *)(a1 + 88);
    if ((v10 & 0x10) != 0)
    {
      if ((insertBLOBField(a1, (__int16 *)"YDK", *(_QWORD *)(a1 + 2848)) & 0x80000000) != 0)
      {
        v13 = "inserting YDK";
        v14 = 312;
        goto LABEL_24;
      }
      *(_WORD *)(a1 + 92) |= 0x10u;
      v10 = *(_WORD *)(a1 + 88);
    }
    v11 = v10 & 0xFFEF;
    *(_WORD *)(a1 + 88) = v10 & 0xFFEF;
    if ((v10 & 8) == 0)
      goto LABEL_19;
    v12 = *(_QWORD *)(a1 + 2584);
    if (!v12)
      goto LABEL_19;
    if ((insertBLOBField(a1, (__int16 *)"YDA", v12) & 0x80000000) == 0)
    {
      *(_WORD *)(a1 + 92) |= 8u;
      v11 = *(_WORD *)(a1 + 88);
LABEL_19:
      result = 0;
      *(_WORD *)(a1 + 88) = v11 & 0xFFF7;
      return result;
    }
    v13 = "inserting YDA";
    v14 = 320;
  }
LABEL_24:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"processDATEnd", v14, 62, 0, v13, v7, v8, v15);
  return 0xFFFFFFFFLL;
}

uint64_t insertBLOBField(uint64_t a1, __int16 *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _WORD *v8;
  uint64_t result;
  __int16 v10;
  char v11;

  if ((reserveExtraFields(a1, *(_QWORD *)(a1 + 2296) + 1) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Convert.c", (uint64_t)"insertBLOBField", 204, 62, 0, "reserving extra fields", v6, v7, v11);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v8 = (_WORD *)(*(_QWORD *)(a1 + 2304) + 1032 * *(_QWORD *)(a1 + 2296));
    bzero(v8, 0x408uLL);
    result = 0;
    *((_DWORD *)v8 + 1) = 2;
    v10 = *a2;
    *((_BYTE *)v8 + 2) = *((_BYTE *)a2 + 2);
    *v8 = v10;
    *((_QWORD *)v8 + 1) = a3;
    ++*(_QWORD *)(a1 + 2296);
  }
  return result;
}

_DWORD *ParallelCompressionFileOpen(const char *a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  uint64_t v10;
  size_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  size_t v19;
  unint64_t v20;
  const char *v21;
  __int16 v22;
  _DWORD *v23;
  int v25;
  int v26;
  unsigned int v27;
  unint64_t v28;
  const char *v29;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  _DWORD *v38;
  int v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  FILE **v48;
  FILE *v49;
  char *EncoderDescription;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  const char *v58;
  __int16 v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  char v67;
  unsigned int v68;
  uint64_t (*DecoderFilter)();
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  int8x16_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  uint64_t v82;
  int8x16_t *v83;
  uint64_t v84;
  unint64_t v85;
  void *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  size_t v90;
  uint64_t v91;
  _QWORD *v92;
  void *v93;
  FILE **v94;
  FILE *v95;
  char *DecoderDescription;
  char v97;
  uint64_t v99;
  unint64_t __offseta;
  int v101;
  int DefaultNThreads;
  unint64_t v103;
  int v104;
  uint64_t v105;
  int v106;
  int8x16_t v107;
  __int16 __buf;
  char v109;
  unsigned __int8 v110;
  unint64_t v111;
  stat __endptr;
  uint64_t v113;

  v113 = *MEMORY[0x24BDAC8D0];
  if (!a1 || !__s)
  {
    v21 = "invalid args";
    v22 = 149;
LABEL_74:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", v22, 46, 0, v21, a7, a8, v97);
    return 0;
  }
  v9 = strlen(__s);
  v10 = 0;
  v11 = 0;
  __offseta = 0;
  v103 = 0;
  v105 = 0;
  v106 = 0;
  v12 = -1;
  v13 = MEMORY[0x24BDAC740];
  v14 = -1;
  v15 = -1;
  v99 = -1;
  v101 = -1;
  DefaultNThreads = -1;
  v104 = -1;
  while (1)
  {
    v16 = __s[v11];
    if ((v16 & 0x80000000) != 0)
    {
      if (__maskrune(__s[v11], 0x4000uLL))
      {
LABEL_6:
        ++v11;
LABEL_7:
        v17 = 4;
        goto LABEL_8;
      }
    }
    else if ((*(_DWORD *)(v13 + 4 * v16 + 60) & 0x4000) != 0)
    {
      goto LABEL_6;
    }
    if ((v12 & 0x80000000) == 0)
      break;
    v18 = 1;
    switch(v16)
    {
      case 'o':
      case 's':
      case 't':
        goto LABEL_53;
      case 'p':
      case 'q':
      case 'u':
        goto LABEL_90;
      case 'r':
        ++HIDWORD(v105);
        goto LABEL_52;
      case 'v':
        LODWORD(v105) = v105 + 1;
        goto LABEL_52;
      case 'w':
        ++v106;
LABEL_52:
        v18 = v10;
        goto LABEL_53;
      default:
        if (v16 - 97 >= 3)
        {
LABEL_90:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 190, 46, 0, "invalid option in mode: %s (was '%c')", a7, a8, (char)__s);
          return 0;
        }
LABEL_53:
        ++v11;
        v17 = 4;
        v10 = v18;
        v12 = v16;
        break;
    }
LABEL_8:
    if (v17 != 4)
      return 0;
  }
  if (v15 == -1 && (_DWORD)v10)
  {
    if (v16 != 61)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 199, 46, 0, "invalid option in mode: %s (%c requires an arg)", a7, a8, (char)__s);
      return 0;
    }
    v15 = v11++;
    v10 = 1;
    goto LABEL_7;
  }
  if (v14 == -1 && (_DWORD)v10)
  {
    if (v12 == 97)
    {
      v19 = v11 + 4;
      if (v11 + 4 > v9)
        goto LABEL_24;
      if (!strncmp(&__s[v11], "lzma", 4uLL))
      {
        v14 = 1;
      }
      else if (!strncmp(&__s[v11], "zlib", 4uLL))
      {
        v14 = 0;
      }
      else
      {
LABEL_24:
        v19 = v11 + 5;
        if (v11 + 5 <= v9 && !strncmp(&__s[v11], "lzfse", 5uLL))
        {
          v14 = 4;
        }
        else
        {
          v19 = v11 + 8;
          if (v11 + 8 <= v9 && !strncmp(&__s[v11], "lzbitmap", 8uLL))
          {
            v14 = 5;
          }
          else
          {
            v19 = v11 + 3;
            if (v11 + 3 > v9 || (v14 = 3, strncmp(&__s[v11], "lz4", 3uLL)))
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 214, 46, 0, "invalid compression algorithm in mode: %s", a7, a8, (char)__s);
              return 0;
            }
          }
        }
      }
      v12 = 97;
      v10 = 1;
      v17 = 4;
      v11 = v19;
      v104 = v14;
      goto LABEL_8;
    }
    *(_QWORD *)&__endptr.st_dev = 0;
    v20 = strtoull(&__s[v11], (char **)&__endptr, 10);
    if (*(char **)&__endptr.st_dev == &__s[v11] || (v14 = v20, v20 == -1))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 223, 46, 0, "invalid argument for '%c' in mode: %s", a7, a8, v12);
      v14 = -1;
      v17 = 1;
    }
    else
    {
      v11 = *(_QWORD *)&__endptr.st_dev - (_QWORD)__s;
      if (v12 == 98 && v11 < v9 && **(_BYTE **)&__endptr.st_dev == 109)
      {
        v14 = v20 << 20;
        ++v11;
      }
      if (v12 == 98 && v11 < v9 && __s[v11] == 107)
      {
        v14 <<= 10;
        ++v11;
      }
      if (v12 == 98 && v11 < v9)
      {
        if (__s[v11] == 98)
          ++v11;
LABEL_49:
        v17 = 4;
        v103 = v14;
      }
      else
      {
        v17 = 4;
        if (v12 > 110)
        {
          switch(v12)
          {
            case 'o':
              __offseta = v14;
              break;
            case 's':
              v99 = v14;
              break;
            case 't':
              if (v14)
                DefaultNThreads = v14;
              else
                DefaultNThreads = getDefaultNThreads();
              break;
          }
        }
        else
        {
          if (v12 == 98)
            goto LABEL_49;
          if (v12 == 99)
            v101 = v14;
        }
      }
    }
    v10 = 1;
    goto LABEL_8;
  }
  if (v16 == 44)
  {
    v10 = 0;
    ++v11;
    v12 = -1;
    v14 = -1;
    v17 = 4;
    v15 = -1;
    goto LABEL_8;
  }
  if ((_BYTE)v16)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 252, 46, 0, "invalid character in mode: %s ('%c')", a7, a8, (char)__s);
    return 0;
  }
  v26 = HIDWORD(v105);
  v25 = v106;
  if (HIDWORD(v105) + v106 != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 256, 46, 0, "mode should specify either 'w' or 'r': %s", a7, a8, (char)__s);
    return 0;
  }
  if (HIDWORD(v105) && ((v104 & 0x80000000) == 0 || v103 || (DefaultNThreads & 0x80000000) == 0))
  {
    v21 = "a,b,t options are invalid in read mode";
    v22 = 257;
    goto LABEL_74;
  }
  if (v106 && (v101 & 0x80000000) == 0)
  {
    v21 = "c option is invalid in write mode";
    v22 = 258;
    goto LABEL_74;
  }
  if (v106 != 0 && v104 < 0)
    v27 = 4;
  else
    v27 = v104;
  if (v106 != 0 && v103 == 0)
    v28 = 0x800000;
  else
    v28 = v103;
  if (v106)
  {
    v29 = a1;
    if (DefaultNThreads <= 0)
      DefaultNThreads = getDefaultNThreads();
  }
  else
  {
    v29 = a1;
  }
  if (v101 >= 1 || HIDWORD(v105) == 0)
    v31 = v101;
  else
    v31 = 1;
  if (HIDWORD(v105))
  {
    memset(&__endptr, 0, sizeof(__endptr));
    if (stat(v29, &__endptr))
    {
      v34 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 270, 46, v34, "%s", v35, v36, (char)v29);
      return 0;
    }
    if ((__endptr.st_mode & 0xF000) != 0x8000)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 271, 46, 0, "%s must be an existing regular file", v32, v33, (char)v29);
      return 0;
    }
    if (__endptr.st_size <= __offseta)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 272, 46, 0, "invalid segment offset: %llu", v32, v33, __offseta);
      return 0;
    }
    v37 = v99;
    if (v99 == -1)
    {
      v37 = __endptr.st_size - __offseta;
    }
    else
    {
      if (__CFADD__(__offseta, v99))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 277, 46, 0, "invalid segment size: %llu", v32, v33, v99);
        return 0;
      }
      if (__offseta + v99 > __endptr.st_size)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 278, 46, 0, "invalid segment size: %llu", v32, v33, v99);
        return 0;
      }
    }
    v99 = v37;
    if (v37 <= 0xB)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 283, 46, 0, "invalid segment size: %llu", v32, v33, v37);
      return 0;
    }
    v29 = a1;
    v26 = HIDWORD(v105);
    v25 = v106;
  }
  v38 = calloc(1uLL, 0x88uLL);
  v23 = v38;
  if (!v38)
  {
    v51 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 287, 46, *v51, "malloc", v52, v53, v97);
    return v23;
  }
  *v38 = v26 == 0;
  v38[1] = -1;
  v38[2] = v105;
  if (!v25)
  {
    v54 = open(v29, 0);
    v23[1] = v54;
    if (v54 < 0)
    {
      v63 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 316, 46, v63, "%s", v64, v65, (char)v29);
      goto LABEL_144;
    }
    if (pread(v54, &__buf, 0xCuLL, __offseta) != 12)
    {
      v58 = "reading file header";
      v59 = 320;
      goto LABEL_142;
    }
    if (__buf != 25200 || v109 != 122)
    {
      v58 = "invalid file header";
      v59 = 321;
      goto LABEL_142;
    }
    v67 = v110;
    if (v110 <= 0x64u)
    {
      switch(v110)
      {
        case '-':
          v68 = 6;
          goto LABEL_161;
        case '4':
          v68 = 3;
          goto LABEL_161;
        case 'b':
          v68 = 5;
          goto LABEL_161;
      }
    }
    else if (v110 > 0x77u)
    {
      if (v110 == 120)
      {
        v68 = 1;
        goto LABEL_161;
      }
      if (v110 == 122)
      {
        v68 = 0;
        goto LABEL_161;
      }
    }
    else
    {
      if (v110 == 101)
      {
        v68 = 4;
        goto LABEL_161;
      }
      if (v110 == 102)
      {
        v68 = 2;
LABEL_161:
        DecoderFilter = PCompressGetDecoderFilter(v68);
        *((_QWORD *)v23 + 3) = DecoderFilter;
        if (DecoderFilter)
        {
          *((_QWORD *)v23 + 5) = bswap64(v111);
          v70 = __offseta + 12;
          v71 = v99 + __offseta;
          if (__offseta + 12 < v99 + __offseta)
          {
            v72 = 0;
            while (1)
            {
              if (v71 - v70 <= 0xF)
              {
                v58 = "truncated block header";
                v59 = 347;
                goto LABEL_142;
              }
              if (pread(v23[1], &__endptr, 0x10uLL, v70) != 16)
              {
                v97 = v70;
                v58 = "reading block header at offset %llu";
                v59 = 348;
                goto LABEL_142;
              }
              v73 = v70 + 16;
              v74 = vrev64q_s8(*(int8x16_t *)&__endptr.st_dev);
              v75 = v71 - (v70 + 16);
              v76 = v74.i64[1];
              if (v75 < v74.i64[1])
              {
                v58 = "truncated block payload";
                v59 = 352;
                goto LABEL_142;
              }
              v107 = v74;
              v77 = v74.i64[0];
              if (v74.i64[1] > (unint64_t)v74.i64[0] || v74.i64[0] > *((_QWORD *)v23 + 5))
              {
                v58 = "corrupted file";
                v59 = 353;
                goto LABEL_142;
              }
              v79 = *((_QWORD *)v23 + 6);
              v80 = *((_QWORD *)v23 + 7);
              v81 = (char *)*((_QWORD *)v23 + 8);
              if (v79 >= v80)
              {
                v82 = v80 + (v80 >> 1);
                if (!v80)
                  v82 = 32;
                *((_QWORD *)v23 + 7) = v82;
                v81 = (char *)reallocf(v81, 40 * v82);
                *((_QWORD *)v23 + 8) = v81;
                if (!v81)
                {
                  v66 = *__error();
                  v58 = "malloc";
                  v59 = 361;
                  goto LABEL_143;
                }
                v79 = *((_QWORD *)v23 + 6);
              }
              v83 = (int8x16_t *)&v81[40 * v79];
              v83->i64[0] = v72;
              v83->i64[1] = v73;
              v83[1] = v107;
              v83[2].i64[0] = -1;
              v70 = v76 + v73;
              if ((int)v105 <= 1)
              {
                v72 += v77;
              }
              else
              {
                v84 = v77 + v72;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "block %zu: compressed:%llu..%llu raw:%llu..%llu\n", v79, v73, v70, v72, v84);
                v79 = *((_QWORD *)v23 + 6);
                v72 = v84;
              }
              *((_QWORD *)v23 + 6) = v79 + 1;
              if (v70 >= v71)
                goto LABEL_183;
            }
          }
          v72 = 0;
LABEL_183:
          if (v70 == v71)
          {
            *((_QWORD *)v23 + 4) = v72;
            *((_QWORD *)v23 + 9) = v31;
            v85 = *((_QWORD *)v23 + 5);
            if (is_mul_ok(v31, v85))
            {
              v86 = malloc(v31 * v85);
              *((_QWORD *)v23 + 10) = v86;
              if (!v86)
              {
                v66 = *__error();
                v58 = "malloc";
                v59 = 392;
                goto LABEL_143;
              }
              v87 = (char *)calloc(v31, 0x18uLL);
              *((_QWORD *)v23 + 11) = v87;
              if (v87)
              {
                v88 = v87;
                v89 = *((_QWORD *)v23 + 9);
                v90 = *((_QWORD *)v23 + 5);
                if (v89)
                {
                  v91 = *((_QWORD *)v23 + 10);
                  v92 = v88 + 16;
                  do
                  {
                    *((_OWORD *)v92 - 1) = xmmword_20643F540;
                    *v92 = v91;
                    v92 += 3;
                    v91 += v90;
                    --v89;
                  }
                  while (v89);
                }
                v93 = malloc(v90);
                *((_QWORD *)v23 + 12) = v93;
                if (v93)
                {
                  *((_QWORD *)v23 + 13) = 0;
                  *((_QWORD *)v23 + 14) = 0;
                  if ((int)v105 >= 1)
                  {
                    v94 = (FILE **)MEMORY[0x24BDAC8D8];
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "filename: %s\n", a1);
                    fwrite("mode: r\n", 8uLL, 1uLL, *v94);
                    v95 = *v94;
                    DecoderDescription = PCompressGetDecoderDescription(v68);
                    fprintf(v95, "algorithm: %s\n", DecoderDescription);
                    fprintf(*v94, "payload segment: %llu [%llu]\n", __offseta, v99);
                    fprintf(*v94, "raw data size: %llu B\n", *((_QWORD *)v23 + 4));
                    fprintf(*v94, "blocks: %zu\n", *((_QWORD *)v23 + 6));
                    fprintf(*v94, "block size: %zu B\n", *((_QWORD *)v23 + 5));
                    fprintf(*v94, "cache size: %zu B (%d blocks)\n");
                  }
                  return v23;
                }
                v66 = *__error();
                v58 = "malloc";
                v59 = 405;
              }
              else
              {
                v66 = *__error();
                v58 = "malloc";
                v59 = 394;
              }
LABEL_143:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", v59, 46, v66, v58, v55, v56, v97);
              goto LABEL_144;
            }
            v58 = "Invalid cache size";
            v59 = 390;
          }
          else
          {
            v58 = "extra bytes found in file";
            v59 = 383;
          }
LABEL_142:
          v66 = 0;
          goto LABEL_143;
        }
        v67 = v110;
LABEL_188:
        v97 = v67;
        v58 = "unsupported decoder in file header: %c";
        v59 = 334;
        goto LABEL_142;
      }
    }
    *((_QWORD *)v23 + 3) = 0;
    goto LABEL_188;
  }
  v39 = open(v29, 1537, 420);
  v23[1] = v39;
  if (v39 < 0)
  {
    v60 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileOpen", 297, 46, v60, "%s", v61, v62, (char)v29);
  }
  else
  {
    v40 = OFileEncoderStreamCreateWithFD(v39, -1, v28, v27, v28, DefaultNThreads);
    *((_QWORD *)v23 + 2) = v40;
    if (v40)
    {
      if ((int)v105 >= 1)
      {
        v48 = (FILE **)MEMORY[0x24BDAC8D8];
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "filename: %s\n", v29);
        fwrite("mode: w\n", 8uLL, 1uLL, *v48);
        v49 = *v48;
        EncoderDescription = PCompressGetEncoderDescription(v27);
        fprintf(v49, "algorithm: %s\n", EncoderDescription);
        fprintf(*v48, "block size: %zu B\n", v28);
        fprintf(*v48, "n threads: %d\n");
      }
      return v23;
    }
  }
LABEL_144:
  ParallelCompressionFileClose(v23, v41, v42, v43, v44, v45, v46, v47);
  return 0;
}

uint64_t ParallelCompressionFileClose(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  FILE **v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;

  if (a1)
  {
    if (!*(_DWORD *)a1 && *((int *)a1 + 2) >= 1)
    {
      v9 = (FILE **)MEMORY[0x24BDAC8D8];
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "read: %llu B\n", *((_QWORD *)a1 + 15));
      fprintf(*v9, "decoded: %llu B\n", *((_QWORD *)a1 + 16));
      v10 = *((_QWORD *)a1 + 15);
      if (v10)
        fprintf(*v9, "decoded/read ratio: %.2f\n", (double)*((unint64_t *)a1 + 16) / (double)v10);
    }
    v11 = *((_QWORD *)a1 + 2);
    if (v11)
    {
      OFileEncoderStreamWrite(v11, 0, 0, a4, a5, a6, a7, a8);
      OFileEncoderStreamDestroy(*((_QWORD *)a1 + 2), v12, v13, v14, v15, v16, v17, v18);
    }
    v19 = *((_DWORD *)a1 + 1);
    if ((v19 & 0x80000000) == 0)
      close(v19);
    free(*((void **)a1 + 8));
    free(*((void **)a1 + 10));
    free(*((void **)a1 + 11));
    free(*((void **)a1 + 12));
    free(a1);
  }
  return 0;
}

uint64_t ParallelCompressionFileSeek(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  char vars0;

  if (*(_DWORD *)a1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"ParallelCompressionFileSeek", 458, 46, 0, "invalid mode", a7, a8, vars0);
  }
  else
  {
    if (a3)
    {
      if (a3 == 2)
      {
        v9 = (_QWORD *)(a1 + 32);
      }
      else
      {
        if (a3 != 1)
          return -1;
        v9 = (_QWORD *)(a1 + 104);
      }
      a2 += *v9;
    }
    if ((a2 & 0x8000000000000000) == 0 && a2 <= *(_QWORD *)(a1 + 32))
    {
      *(_QWORD *)(a1 + 104) = a2;
      return a2;
    }
  }
  return -1;
}

uint64_t ParallelCompressionFileWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (*(_DWORD *)a1 != 1)
    return -1;
  if (!a3)
    return 0;
  result = OFileEncoderStreamWrite(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  if (result < 0)
    return -1;
  return result;
}

uint64_t ParallelCompressionFileRead(uint64_t a1, char *__dst, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  size_t v9;
  unint64_t v11;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  FILE **v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  size_t v30;
  int v31;
  off_t v32;
  ssize_t v33;
  const char *v34;
  unint64_t *v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  const void *v40;
  size_t v41;
  size_t v42;
  ssize_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  const char *v48;
  __int16 v49;
  char v50;

  if (!*(_DWORD *)a1)
  {
    v9 = a3;
    ++*(_QWORD *)(a1 + 112);
    if (!a3)
      return 0;
    v11 = *(_QWORD *)(a1 + 104);
    if (v11 >= *(_QWORD *)(a1 + 32))
      return 0;
    v13 = *(_QWORD *)(a1 + 48);
    if (v13)
    {
      v14 = *(_QWORD *)(a1 + 64);
      if (*(_QWORD *)(v14 + 16) > v11)
      {
        v15 = 0;
        goto LABEL_20;
      }
      v17 = v13 - 1;
      if (*(_QWORD *)(v14 + 40 * v17) <= v11)
      {
        v15 = v17;
        goto LABEL_20;
      }
      v18 = 0;
      while (1)
      {
        v15 = v17;
        do
        {
          if (v18 >= v15)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"locateBlock", 78, 46, 0, "locateBlock failed", a7, a8, v50);
            goto LABEL_19;
          }
          v17 = v15;
          v15 = (v15 + v18) >> 1;
          v19 = *(_QWORD *)(v14 + 40 * v15);
        }
        while (v19 > v11);
        v18 = v15;
        if (*(_QWORD *)(v14 + 40 * v15 + 16) + v19 > v11)
        {
LABEL_20:
          v8 = 0;
          v20 = (FILE **)MEMORY[0x24BDAC8D8];
          while (1)
          {
            if (v15 >= *(_QWORD *)(a1 + 48))
              return v8;
            v21 = *(_QWORD *)(a1 + 64);
            v22 = *(_QWORD *)(v21 + 40 * v15 + 32);
            if (v22 != -1)
            {
              v23 = *(_QWORD *)(a1 + 88);
              *(_QWORD *)(v23 + 24 * v22 + 8) = *(_QWORD *)(a1 + 112);
              goto LABEL_44;
            }
            v24 = *(_QWORD *)(a1 + 72);
            v25 = *(_QWORD *)(a1 + 88);
            if (v24)
            {
              v26 = 0;
              v27 = (_QWORD *)(v25 + 8);
              v22 = -1;
              while (*(v27 - 1) != -1)
              {
                if (v22 == -1 || *v27 < *(_QWORD *)(v25 + 24 * v22 + 8))
                  v22 = v26;
                ++v26;
                v27 += 3;
                if (v24 == v26)
                  goto LABEL_34;
              }
              v22 = v26;
            }
            else
            {
              v22 = -1;
            }
LABEL_34:
            v28 = *(_QWORD *)(v25 + 24 * v22);
            if (v28 != -1)
            {
              if (*(int *)(a1 + 8) >= 2)
              {
                fprintf(*v20, "Block %zu evicted from cache\n", *(_QWORD *)(v25 + 24 * v22));
                v21 = *(_QWORD *)(a1 + 64);
                v25 = *(_QWORD *)(a1 + 88);
                v28 = *(_QWORD *)(v25 + 24 * v22);
              }
              *(_QWORD *)(v21 + 40 * v28 + 32) = -1;
              *(_QWORD *)(v25 + 24 * v22) = -1;
            }
            v29 = (_QWORD *)(v21 + 40 * v15);
            v30 = v29[3];
            v31 = *(_DWORD *)(a1 + 4);
            v32 = v29[1];
            if (v30 == v29[2])
            {
              v33 = pread(v31, *(void **)(v25 + 24 * v22 + 16), v30, v32);
              if (v33 < 0 || (v21 = *(_QWORD *)(a1 + 64), v33 != *(_QWORD *)(v21 + 40 * v15 + 24)))
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"loadBlock", 117, 46, 0, "reading uncompressed block %zu", a7, a8, v15);
                return -1;
              }
              v34 = "Block %zu loaded in cache\n";
              if (*(int *)(a1 + 8) <= 1)
                goto LABEL_43;
            }
            else
            {
              v43 = pread(v31, *(void **)(a1 + 96), v30, v32);
              if (v43 < 0 || v43 != *(_QWORD *)(*(_QWORD *)(a1 + 64) + 40 * v15 + 24))
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)"loadBlock", 125, 46, 0, "reading compressed block %zu", v44, v45, v15);
                return -1;
              }
              v46 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, ssize_t))(a1 + 24))(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 24 * v22 + 16), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 96), v43);
              if (v46 < 0 || (v21 = *(_QWORD *)(a1 + 64), v46 != *(_QWORD *)(v21 + 40 * v15 + 16)))
              {
                v50 = v15;
                v47 = "loadBlock";
                v48 = "decoding compressed block %zu";
                v49 = 128;
                goto LABEL_60;
              }
              v34 = "Block %zu loaded and decoded in cache\n";
              if (*(int *)(a1 + 8) < 2)
                goto LABEL_43;
            }
            fprintf(*v20, v34, v15);
            v21 = *(_QWORD *)(a1 + 64);
LABEL_43:
            v23 = *(_QWORD *)(a1 + 88);
            v35 = (unint64_t *)(v23 + 24 * v22);
            v36 = *(_QWORD *)(a1 + 112);
            *v35 = v15;
            v35[1] = v36;
            v37 = v21 + 40 * v15;
            *(_QWORD *)(v37 + 32) = v22;
            *(_QWORD *)(a1 + 128) += *(_QWORD *)(v37 + 16);
LABEL_44:
            if (v22 >= *(_QWORD *)(a1 + 72))
            {
              v47 = "ParallelCompressionFileRead";
              v48 = "invalid entry";
              v49 = 506;
LABEL_60:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/File.c", (uint64_t)v47, v49, 46, 0, v48, a7, a8, v50);
              return -1;
            }
            v38 = (_QWORD *)(v21 + 40 * v15);
            v39 = *(_QWORD *)(a1 + 104);
            v40 = (const void *)(*(_QWORD *)(v23 + 24 * v22 + 16) + v39 - *v38);
            v41 = v38[2] + *v38 - v39;
            if (v9 >= v41)
              v42 = v41;
            else
              v42 = v9;
            memcpy(__dst, v40, v42);
            __dst += v42;
            *(_QWORD *)(a1 + 104) += v42;
            *(_QWORD *)(a1 + 120) += v42;
            v8 += v42;
            ++v15;
            v9 -= v42;
            if (!v9)
              return v8;
          }
        }
      }
    }
LABEL_19:
    v15 = -1;
    goto LABEL_20;
  }
  return -1;
}

unsigned __int8 *patchCacheKeyFromSHA1(unsigned __int8 *result, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  _BYTE *v4;
  BOOL v5;

  v2 = 0;
  do
  {
    v3 = *result++;
    v4 = (_BYTE *)(a2 + v2);
    *v4 = patchCacheKeyFromSHA1_hex[(unint64_t)v3 >> 4];
    v4[1] = patchCacheKeyFromSHA1_hex[v3 & 0xF];
    v5 = v2 >= 0x26;
    v2 += 2;
  }
  while (!v5);
  return result;
}

_BYTE *patchCacheOpenFromURL(const char *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  __int16 v13;
  _BYTE *result;
  char v15;

  if (!a1)
  {
    v12 = "Invalid patch cache URL (NULL)";
    v13 = 56;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheOpenFromURL", v13, 38, 0, v12, a7, a8, v15);
    return 0;
  }
  if (!strncasecmp(a1, "file:", 5uLL))
  {
    result = filePatchCacheOpen(a1, a2);
    if (result)
    {
      *(_DWORD *)result = 1;
      return result;
    }
    v12 = "filePatchCacheOpen failed";
    v13 = 61;
    goto LABEL_8;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheOpenFromURL", 66, 38, 0, "Unknown patch cache URL: %s", v10, v11, (char)a1);
  return 0;
}

uint64_t patchCacheClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (*(_DWORD *)result == 1)
      return filePatchCacheClose((int *)result, a2, a3, a4, a5, a6, a7, a8);
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t patchCacheLookup(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t result;
  char *v13;
  __int128 v14;
  const char *v15;
  __int16 v16;
  unint64_t v17;
  void *__dst;

  if (!a1)
    return 0xFFFFFFFFLL;
  v11 = 0;
  v17 = 0;
  __dst = 0;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  do
  {
    if (!*(_BYTE *)(a2 + v11))
    {
      v15 = "invalid inKey";
      v16 = 142;
LABEL_16:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheLookup", v16, 38, 0, v15, a6, a8, v17);
      return 0xFFFFFFFFLL;
    }
    if (!*(_BYTE *)(a3 + v11))
    {
      v15 = "invalid outKey";
      v16 = 143;
      goto LABEL_16;
    }
    ++v11;
  }
  while (v11 != 40);
  if (*a1 != 1)
    return 0xFFFFFFFFLL;
  result = filePatchCacheLookup((uint64_t)a1, a2, a3, &__dst, &v17, a5, a6);
  if ((result & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if ((_DWORD)result)
  {
    v13 = (char *)__dst;
    v14 = *((_OWORD *)__dst + 1);
    *(_OWORD *)(a4 + 8) = v14;
    *(_QWORD *)(a4 + 24) = 0;
    *(_DWORD *)a4 = 1;
    if ((_QWORD)v14)
    {
      if (v17 >= (uint64_t)v14 + 32)
      {
        memmove(v13, v13 + 32, v14);
        v13 = 0;
        *(_QWORD *)(a4 + 24) = __dst;
        __dst = 0;
      }
    }
    free(v13);
    return 1;
  }
  else
  {
    *(_DWORD *)(a4 + 4) = a5;
  }
  return result;
}

uint64_t patchCacheUpdate(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  const void *v13;
  size_t v14;
  _OWORD *v15;
  void *v16;
  __int128 v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  int v21;
  char v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0xFFFFFFFFLL;
  if (!*(_DWORD *)(a4 + 4))
  {
    v19 = "PatchCache update not expected";
    v20 = 183;
LABEL_15:
    v21 = 0;
LABEL_16:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/PatchCache.c", (uint64_t)"patchCacheUpdate", v20, 38, v21, v19, a7, a8, v23);
    return 0xFFFFFFFFLL;
  }
  for (i = 0; i != 40; ++i)
  {
    if (!*(_BYTE *)(a2 + i))
    {
      v19 = "invalid inKey";
      v20 = 186;
      goto LABEL_15;
    }
    if (!*(_BYTE *)(a3 + i))
    {
      v19 = "invalid outKey";
      v20 = 187;
      goto LABEL_15;
    }
  }
  *(_QWORD *)&v24 = 0x5F44414F4C594150;
  v25 = *(_OWORD *)(a4 + 8);
  *((_QWORD *)&v24 + 1) = time(0);
  v13 = *(const void **)(a4 + 24);
  if (v13)
  {
    v14 = *(_QWORD *)(a4 + 8);
    if (v14 < *(_QWORD *)(a4 + 16))
    {
      v15 = malloc(v14 + 32);
      if (v15)
      {
        v16 = v15;
        v17 = v25;
        *v15 = v24;
        v15[1] = v17;
        memcpy(v15 + 2, v13, v14);
        if (*a1 == 1)
          v18 = filePatchCacheUpdate((uint64_t)a1, a2, a3, (uint64_t)v16, v14 + 32);
        else
          v18 = 0xFFFFFFFFLL;
        free(v16);
        if (!(_DWORD)v18)
          goto LABEL_25;
        return v18;
      }
      v21 = *__error();
      v19 = "malloc";
      v20 = 209;
      goto LABEL_16;
    }
  }
  if (*a1 != 1)
    return 0xFFFFFFFFLL;
  v18 = filePatchCacheUpdate((uint64_t)a1, a2, a3, (uint64_t)&v24, 0x20uLL);
  if (!(_DWORD)v18)
LABEL_25:
    *(_QWORD *)a4 = 1;
  return v18;
}

_QWORD *aaSequentialDecompressionIStreamOpen(uint64_t a1, int a2)
{
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  _QWORD *v6;
  size_t v7;
  size_t v8;
  void *v9;
  void *v10;
  size_t v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  char v20;

  if (!a2)
    getDefaultNThreads();
  v3 = calloc(1uLL, 0x68uLL);
  v4 = malloc(0x160uLL);
  v5 = (uint64_t)v4;
  if (!v4 || (memset_s(v4, 0x160uLL, 0, 0x160uLL), !v3))
  {
    v16 = *__error();
    v17 = "malloc";
    v18 = 266;
LABEL_31:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaSequentialDecompressionIStreamOpen", v18, 20, v16, v17, v14, v15, v20);
    free(v3);
    aaDecompressionStreamClose(v5);
    return 0;
  }
  *(_QWORD *)v5 = a1;
  *(_DWORD *)(v5 + 56) = -1;
  v6 = (_QWORD *)(v5 + 8);
  v7 = *(_QWORD *)(v5 + 16);
  if (!(v7 >> 16))
  {
    do
    {
      v8 = (v7 >> 1) + v7;
      if (((v7 >> 1) & v7) != 0)
        v8 = ((v7 >> 1) & v7) + v7;
      if (v7)
        v7 = v8;
      else
        v7 = 0x4000;
    }
    while (v7 < 0x10000);
    v9 = *(void **)(v5 + 24);
    v10 = realloc(v9, v7);
    if (!v10)
      goto LABEL_29;
    *(_QWORD *)(v5 + 16) = v7;
    *(_QWORD *)(v5 + 24) = v10;
  }
  v11 = *(_QWORD *)(v5 + 40);
  if (v11 >> 16)
    goto LABEL_23;
  do
  {
    v12 = (v11 >> 1) + v11;
    if (((v11 >> 1) & v11) != 0)
      v12 = ((v11 >> 1) & v11) + v11;
    if (v11)
      v11 = v12;
    else
      v11 = 0x4000;
  }
  while (v11 < 0x10000);
  v9 = *(void **)(v5 + 48);
  v13 = realloc(v9, v11);
  if (!v13)
  {
    v6 = (_QWORD *)(v5 + 32);
LABEL_29:
    free(v9);
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    v17 = "allocating buffer";
    v18 = 273;
    goto LABEL_30;
  }
  *(_QWORD *)(v5 + 40) = v11;
  *(_QWORD *)(v5 + 48) = v13;
LABEL_23:
  if (aaDecompressionStreamRefill(v5, 0xCuLL) < 0)
  {
    v17 = "reading magic";
    v18 = 276;
LABEL_30:
    v16 = 0;
    goto LABEL_31;
  }
  __memcpy_chk();
  if (*(_DWORD *)(v5 + 56) == -1)
    *(_DWORD *)(v5 + 56) = 0;
  *v3 = v5;
  v3[1] = aaDecompressionStreamClose;
  v3[2] = aaDecompressionStreamRead;
  v3[7] = aaDecompressionStreamAbort;
  return v3;
}

uint64_t aaDecompressionStreamRefill(uint64_t a1, size_t a2)
{
  size_t v2;
  uint64_t v4;
  AAByteStream_impl *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  void *v13;
  size_t v14;
  ssize_t v15;

  if (!a2)
    return 0;
  v2 = a2;
  v4 = 0;
  v6 = (unint64_t *)(a1 + 8);
  v5 = *(AAByteStream_impl **)a1;
  v8 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    if (v8 != v7)
      goto LABEL_14;
    v9 = v7 + 0x40000;
    if ((uint64_t)(v7 + 0x40000) < 0)
      return -1;
    if (v7 <= 0xFFFFFFFFFFFBFFFFLL)
      break;
    v8 = v7;
LABEL_14:
    v11 = v7;
LABEL_18:
    if (v11 - v8 >= v2)
      v14 = v2;
    else
      v14 = v11 - v8;
    v15 = AAByteStreamRead(v5, (void *)(*(_QWORD *)(a1 + 24) + v8), v14);
    if (v15 < 0)
      return -1;
    if (!v15)
      return v4;
    v8 = *v6 + v15;
    if (__CFADD__(*v6, v15))
      return -1;
    v7 = *(_QWORD *)(a1 + 16);
    if (v8 > v7)
      return -1;
    *v6 = v8;
    v4 += v15;
    v2 -= v15;
    if (!v2)
      return v4;
  }
  do
  {
    while (!v7)
    {
      v7 = 0x4000;
      v11 = 0x4000;
      if (v9 <= 0x4000)
        goto LABEL_16;
    }
    v10 = v7 >> 1;
    if ((v7 & (v7 >> 1)) != 0)
      v10 = v7 & (v7 >> 1);
    v7 += v10;
  }
  while (v7 < v9);
  v11 = v7;
  if (v7 >= 0x2000000001)
  {
    *__error() = 12;
    goto LABEL_32;
  }
LABEL_16:
  v12 = *(void **)(a1 + 24);
  v13 = realloc(v12, v11);
  if (v13)
  {
    *(_QWORD *)(a1 + 16) = v11;
    *(_QWORD *)(a1 + 24) = v13;
    v8 = *(_QWORD *)(a1 + 8);
    goto LABEL_18;
  }
  free(v12);
LABEL_32:
  *v6 = 0;
  v6[1] = 0;
  v4 = -1;
  v6[2] = 0;
  return v4;
}

size_t aaDecompressionStreamReadInput(uint64_t a1, uint64_t a2, size_t nbyte)
{
  size_t v3;
  uint64_t v6;
  size_t v7;
  size_t v8;
  unint64_t v9;
  size_t v10;
  ssize_t v11;

  if (nbyte)
  {
    v3 = nbyte;
    v6 = 0;
    while (1)
    {
      v7 = *(_QWORD *)(a1 + 8);
      if (v7)
      {
        if (v3 >= v7)
          v8 = *(_QWORD *)(a1 + 8);
        else
          v8 = v3;
        memcpy((void *)(a2 + v6), *(const void **)(a1 + 24), v8);
        if ((v8 & 0x8000000000000000) != 0)
          return v8;
        v9 = *(_QWORD *)(a1 + 8);
        v10 = v9 - v8;
        if (v9 >= v8)
        {
          if (v9 != v8)
            memmove(*(void **)(a1 + 24), (const void *)(*(_QWORD *)(a1 + 24) + v8), v9 - v8);
          *(_QWORD *)(a1 + 8) = v10;
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 60))
          return v6;
        v11 = AAByteStreamRead(*(AAByteStream *)a1, (void *)(a2 + v6), v3);
        v8 = v11;
        if (v11 < 0)
          return v8;
        if (!v11)
        {
          *(_DWORD *)(a1 + 60) = 1;
          return v6;
        }
      }
      v6 += v8;
      v3 -= v8;
      if (!v3)
        return v6;
    }
  }
  return 0;
}

uint64_t aaDecompressionStreamClose(uint64_t a1)
{
  int v2;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 56);
    switch(v2)
    {
      case 2:
        compression_stream_destroy((compression_stream *)(a1 + 312));
        break;
      case 4:
        BZ2_bzDecompressEnd((bz_stream *)(a1 + 96));
        break;
      case 3:
        lzma_end();
        break;
    }
    IDecoderStreamDestroy(*(_QWORD **)(a1 + 72));
    free(*(void **)(a1 + 24));
    memset_s((void *)(a1 + 8), 0x18uLL, 0, 0x18uLL);
    free(*(void **)(a1 + 48));
    memset_s((void *)(a1 + 32), 0x18uLL, 0, 0x18uLL);
    free((void *)a1);
  }
  return 0;
}

size_t aaDecompressionStreamRead(uint64_t a1, uint64_t a2, size_t nbyte, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  size_t v10;
  uint64_t v13;
  int v14;
  int v15;
  size_t v16;
  size_t v17;
  unint64_t v18;
  size_t v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  AAByteStream_impl *v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  void *v27;
  void *v28;
  size_t v29;
  ssize_t v30;
  uint64_t v31;
  unint64_t *v32;
  size_t v33;
  _BYTE *v34;
  unint64_t v35;
  size_t v36;
  unint64_t v37;
  size_t v38;
  unint64_t v40;
  unint64_t v41;
  compression_status v42;
  compression_status v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  size_t v48;
  uint64_t v49;
  size_t v50;
  unsigned int v52;
  unsigned int v53;
  int v54;
  unint64_t *v55;
  _BYTE *v56;
  unint64_t v57;
  size_t v58;
  uint64_t v59;
  unint64_t v60;
  int v62;
  int v63;
  int v64;
  unint64_t *v65;
  _BYTE *v66;
  unint64_t v67;
  size_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v72;
  uint64_t v73;
  BOOL v74;
  size_t v75;
  const char *v76;
  __int16 v77;
  char v78;
  int v79;
  size_t v80;
  size_t v81;
  size_t v82;
  unint64_t *v83;

  if (*(_DWORD *)(a1 + 68))
    return -1;
  v10 = nbyte;
  v13 = *(_QWORD *)(a1 + 72);
  if (v13)
    return IDecoderStreamRead(v13, a2, nbyte);
  v14 = *(_DWORD *)(a1 + 56);
  if (v14 == -1)
    return -1;
  if (!v14)
    return aaDecompressionStreamReadInput(a1, a2, nbyte);
  if (!nbyte)
    return 0;
  v15 = 0;
  v16 = 0;
  v83 = (unint64_t *)(a1 + 8);
LABEL_11:
  v17 = *(_QWORD *)(a1 + 32);
  if (v17)
  {
    if (v10 >= v17)
      v8 = *(_QWORD *)(a1 + 32);
    else
      v8 = v10;
    memcpy((void *)(a2 + v16), *(const void **)(a1 + 48), v8);
    if ((v8 & 0x8000000000000000) == 0)
    {
      v18 = *(_QWORD *)(a1 + 32);
      v19 = v18 - v8;
      if (v18 >= v8)
      {
        if (v18 != v8)
          memmove(*(void **)(a1 + 48), (const void *)(*(_QWORD *)(a1 + 48) + v8), v18 - v8);
        *(_QWORD *)(a1 + 32) = v19;
      }
      v16 += v8;
      v10 -= v8;
      goto LABEL_137;
    }
    return v8;
  }
  if (*(_DWORD *)(a1 + 64))
    return v16;
  v21 = *(_QWORD *)(a1 + 8);
  v20 = *(_QWORD *)(a1 + 16);
  if (v20 == v21)
    goto LABEL_53;
  if (*(_DWORD *)(a1 + 60))
    goto LABEL_52;
  v22 = v20 - v21;
  if (v20 == v21)
    goto LABEL_51;
  v8 = 0;
  v23 = *(AAByteStream_impl **)a1;
  while (1)
  {
    if (v21 != v20)
      goto LABEL_37;
    v24 = v20 + 0x40000;
    if ((uint64_t)(v20 + 0x40000) < 0)
      goto LABEL_140;
    if (v20 > 0xFFFFFFFFFFFBFFFFLL)
    {
      v21 = v20;
LABEL_37:
      v26 = v20;
      goto LABEL_41;
    }
    do
    {
      while (!v20)
      {
        v20 = 0x4000;
        v26 = 0x4000;
        if (v24 <= 0x4000)
          goto LABEL_39;
      }
      v25 = v20 >> 1;
      if ((v20 & (v20 >> 1)) != 0)
        v25 = v20 & (v20 >> 1);
      v20 += v25;
    }
    while (v20 < v24);
    v26 = v20;
    if (v20 >= 0x2000000001)
    {
      *__error() = 12;
      goto LABEL_152;
    }
LABEL_39:
    v27 = *(void **)(a1 + 24);
    v28 = realloc(v27, v26);
    if (!v28)
      break;
    *(_QWORD *)(a1 + 16) = v26;
    *(_QWORD *)(a1 + 24) = v28;
    v21 = *(_QWORD *)(a1 + 8);
LABEL_41:
    if (v26 - v21 >= v22)
      v29 = v22;
    else
      v29 = v26 - v21;
    v30 = AAByteStreamRead(v23, (void *)(*(_QWORD *)(a1 + 24) + v21), v29);
    if (v30 < 0)
      goto LABEL_140;
    if (!v30)
      goto LABEL_49;
    v21 = *v83 + v30;
    if (__CFADD__(*v83, v30) || (v20 = *(_QWORD *)(a1 + 16), v21 > v20))
    {
LABEL_140:
      v8 = -1;
      goto LABEL_141;
    }
    *v83 = v21;
    v8 += v30;
    v22 -= v30;
    if (!v22)
    {
LABEL_49:
      if ((v8 & 0x8000000000000000) != 0)
        goto LABEL_141;
      if (!v8)
LABEL_51:
        *(_DWORD *)(a1 + 60) = 1;
LABEL_52:
      v21 = *v83;
LABEL_53:
      v32 = *(unint64_t **)(a1 + 24);
      v31 = *(_QWORD *)(a1 + 32);
      v33 = *(_QWORD *)(a1 + 40) - v31;
      v34 = (_BYTE *)(*(_QWORD *)(a1 + 48) + v31);
      switch(*(_DWORD *)(a1 + 56))
      {
        case 1:
          if (!v21)
          {
            if (!*(_DWORD *)(a1 + 60))
            {
LABEL_146:
              v76 = "truncated stream header";
              v77 = 208;
              goto LABEL_154;
            }
LABEL_120:
            *(_DWORD *)(a1 + 64) = 1;
            goto LABEL_136;
          }
          if (v21 <= 0xF)
            goto LABEL_146;
          v35 = v32[1];
          v36 = bswap64(*v32);
          v37 = bswap64(v35);
          v38 = *(_QWORD *)(a1 + 80);
          if (v36 > v38 || v37 > v38)
          {
            v76 = "corrupted stream header";
            v77 = 217;
            goto LABEL_154;
          }
          v79 = v15;
          v40 = v37 + 16;
          if (v37 + 16 > v21)
          {
            v76 = "truncated stream payload";
            v77 = 218;
            goto LABEL_154;
          }
          if (v36 > v33)
          {
            v76 = "unexpected output buffer size";
            v77 = 219;
            goto LABEL_154;
          }
          v41 = *v32;
          if (*v32 != v35)
          {
            if ((*(uint64_t (**)(_BYTE *, size_t, unint64_t *))(a1 + 88))(v34, v33, v32 + 2) == v36)
              goto LABEL_122;
            v76 = "block decompression failed";
            v77 = 229;
LABEL_154:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", v77, 20, 0, v76, a7, a8, v78);
            return -1;
          }
          memcpy(v34, v32 + 2, v36);
LABEL_122:
          if (v40)
          {
            v72 = *v83 - v40;
            if (*v83 >= v40)
            {
              if (*v83 != v40)
                memmove(*(void **)(a1 + 24), (const void *)(*(_QWORD *)(a1 + 24) + v40), *v83 - v40);
              *v83 = v72;
            }
          }
          if (v41)
          {
            v73 = *(_QWORD *)(a1 + 32);
            v74 = __CFADD__(v73, v36);
            v75 = v73 + v36;
            v15 = v79;
            if (!v74 && v75 <= *(_QWORD *)(a1 + 40))
              *(_QWORD *)(a1 + 32) = v75;
          }
          else
          {
            v15 = v79;
          }
LABEL_136:
          if (v15 >= 3)
          {
            v76 = "truncated stream";
            v77 = 240;
            goto LABEL_154;
          }
LABEL_137:
          v8 = v16;
          if (!v10)
            return v8;
          break;
        case 2:
          *(_QWORD *)(a1 + 328) = v32;
          *(_QWORD *)(a1 + 336) = v21;
          *(_QWORD *)(a1 + 312) = v34;
          *(_QWORD *)(a1 + 320) = v33;
          v42 = compression_stream_process((compression_stream *)(a1 + 312), *(_DWORD *)(a1 + 60) != 0);
          if (v42 < 0)
          {
            v76 = "decoding compression payload";
            v77 = 162;
            goto LABEL_154;
          }
          v43 = v42;
          v44 = v15;
          v45 = *(_QWORD *)(a1 + 336);
          v46 = *(_QWORD *)(a1 + 320);
          v47 = v21 - v45;
          if (v21 != v45)
          {
            v48 = *v83 - v47;
            if (*v83 >= v47)
            {
              if (*v83 != v47)
              {
                v80 = *v83 - v47;
                memmove(*(void **)(a1 + 24), (const void *)(*(_QWORD *)(a1 + 24) + v47), v48);
                v48 = v80;
              }
              *v83 = v48;
            }
          }
          if (v33 != v46)
          {
            v49 = *(_QWORD *)(a1 + 32);
            v50 = v49 + v33 - v46;
            if (!__CFADD__(v49, v33 - v46) && v50 <= *(_QWORD *)(a1 + 40))
              *(_QWORD *)(a1 + 32) = v50;
          }
          if (v33 == v46 && v21 == v45)
            v15 = v44 + 1;
          else
            v15 = 0;
          if (v43 != COMPRESSION_STATUS_END)
            goto LABEL_136;
          goto LABEL_120;
        case 3:
          *(_QWORD *)(a1 + 176) = v32;
          *(_QWORD *)(a1 + 184) = v21;
          *(_QWORD *)(a1 + 200) = v34;
          *(_QWORD *)(a1 + 208) = v33;
          v52 = lzma_code();
          v53 = v52;
          if (v52 <= 0xA && ((1 << v52) & 0x403) != 0)
          {
            v54 = v15;
            v55 = *(unint64_t **)(a1 + 176);
            v56 = *(_BYTE **)(a1 + 200);
            v57 = (char *)v55 - (char *)v32;
            if (v55 != v32)
            {
              v58 = *v83 - v57;
              if (*v83 >= v57)
              {
                if (*v83 != v57)
                {
                  v81 = *v83 - v57;
                  memmove(*(void **)(a1 + 24), (const void *)(*(_QWORD *)(a1 + 24) + v57), v58);
                  v58 = v81;
                }
                *v83 = v58;
              }
            }
            if (v56 != v34)
            {
              v59 = *(_QWORD *)(a1 + 32);
              v60 = v59 + v56 - v34;
              if (!__CFADD__(v59, v56 - v34) && v60 <= *(_QWORD *)(a1 + 40))
                *(_QWORD *)(a1 + 32) = v60;
            }
            if (v56 == v34 && v55 == v32)
              v15 = v54 + 1;
            else
              v15 = 0;
            if (v53 == 1)
              goto LABEL_120;
          }
          else
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", 194, 20, 0, "decoding lzma payload", a7, a8, v78);
          }
          v8 = -1;
          if (v53 <= 0xA && ((1 << v53) & 0x403) != 0)
            goto LABEL_136;
          return v8;
        case 4:
          *(_QWORD *)(a1 + 96) = v32;
          *(_DWORD *)(a1 + 104) = v21;
          *(_QWORD *)(a1 + 120) = v34;
          *(_DWORD *)(a1 + 128) = v33;
          v62 = BZ2_bzDecompress((bz_stream *)(a1 + 96));
          if (v62 < 0)
          {
            v76 = "decoding bzip2 payload";
            v77 = 178;
            goto LABEL_154;
          }
          v63 = v62;
          v64 = v15;
          v65 = *(unint64_t **)(a1 + 96);
          v66 = *(_BYTE **)(a1 + 120);
          v67 = (char *)v65 - (char *)v32;
          if (v65 != v32)
          {
            v68 = *v83 - v67;
            if (*v83 >= v67)
            {
              if (*v83 != v67)
              {
                v82 = *v83 - v67;
                memmove(*(void **)(a1 + 24), (const void *)(*(_QWORD *)(a1 + 24) + v67), v68);
                v68 = v82;
              }
              *v83 = v68;
            }
          }
          if (v66 != v34)
          {
            v69 = *(_QWORD *)(a1 + 32);
            v70 = v69 + v66 - v34;
            if (!__CFADD__(v69, v66 - v34) && v70 <= *(_QWORD *)(a1 + 40))
              *(_QWORD *)(a1 + 32) = v70;
          }
          if (v66 == v34 && v65 == v32)
            v15 = v64 + 1;
          else
            v15 = 0;
          if (v63 != 4)
            goto LABEL_136;
          goto LABEL_120;
        default:
          return -1;
      }
      goto LABEL_11;
    }
  }
  free(v27);
LABEL_152:
  *v83 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v8 = -1;
  *(_QWORD *)(a1 + 24) = 0;
LABEL_141:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AASequentialDecompressionStream.c", (uint64_t)"aaDecompressionStreamRead", 144, 20, 0, "stream read failed", a7, a8, v78);
  return v8;
}

size_t aaDecompressionStreamAbort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t result;

  *(_DWORD *)(a1 + 68) = 1;
  result = *(_QWORD *)(a1 + 72);
  if (result)
    return IDecoderStreamAbort(result, a2, a3, a4, a5, a6, a7, a8, a9);
  return result;
}

_QWORD *AAMemoryInputStreamOpen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  char v17;

  if (!a1 && a2)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 132, 68, 0, "Invalid arguments", a7, a8, v17);
    v10 = 0;
    v11 = 0;
LABEL_8:
    free(v11);
    free(v10);
    return 0;
  }
  v10 = calloc(1uLL, 0x68uLL);
  v12 = malloc(0x20uLL);
  v11 = v12;
  if (!v12 || (memset_s(v12, 0x20uLL, 0, 0x20uLL), !v10))
  {
    v13 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AAMemoryStream.c", (uint64_t)"AAMemoryInputStreamOpen", 137, 68, *v13, "malloc", v14, v15, v17);
    goto LABEL_8;
  }
  *v11 = a1;
  v11[1] = a2;
  *v10 = v11;
  v10[1] = memoryInputStreamClose;
  v10[2] = memoryInputStreamRead;
  v10[4] = memoryInputStreamPRead;
  v10[6] = memoryInputStreamSeek;
  v10[7] = memoryInputStreamCancel;
  return v10;
}

uint64_t memoryInputStreamClose(void *a1)
{
  free(a1);
  return 0;
}

uint64_t memoryInputStreamCancel(uint64_t result)
{
  unsigned int *v1;

  v1 = (unsigned int *)(result + 24);
  while (!__ldaxr(v1))
  {
    if (!__stlxr(1u, v1))
      return result;
  }
  __clrex();
  return result;
}

size_t memoryInputStreamRead(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t *v5;
  uint64_t v6;

  if (atomic_load((unsigned int *)(a1 + 24)))
    return -1;
  v5 = (unint64_t *)(a1 + 16);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + a3, v5));
  return memoryInputStreamPRead(a1, a2, a3, v6);
}

size_t memoryInputStreamPRead(uint64_t a1, void *__dst, uint64_t a3, uint64_t a4)
{
  unsigned int v4;
  size_t v5;
  unint64_t v6;
  unint64_t v7;

  v4 = atomic_load((unsigned int *)(a1 + 24));
  v5 = -1;
  if ((a4 & 0x8000000000000000) == 0 && !v4)
  {
    v6 = *(_QWORD *)(a1 + 8);
    v7 = (uint64_t)v6 >= a4 ? a4 : *(_QWORD *)(a1 + 8);
    if (!__CFADD__(v7, a3))
    {
      if (v7 + a3 < v6)
        v6 = v7 + a3;
      v5 = v6 - v7;
      if (v6 <= v7)
        return 0;
      else
        memcpy(__dst, (const void *)(*(_QWORD *)a1 + v7), v5);
    }
  }
  return v5;
}

uint64_t memoryInputStreamSeek(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;

  if (atomic_load((unsigned int *)(a1 + 24)))
    return -1;
  if (!a3)
    goto LABEL_7;
  if (a3 != 1)
  {
    if (a3 != 2)
      return -1;
    a2 += *(_QWORD *)(a1 + 8);
LABEL_7:
    atomic_store(a2, (unint64_t *)(a1 + 16));
    return a2;
  }
  v4 = (unint64_t *)(a1 + 16);
  do
  {
    v5 = __ldaxr(v4);
    v6 = v5 + a2;
  }
  while (__stlxr(v6, v4));
  return v6;
}

uint64_t LargeFileWorker()
{
  uint64_t v0;
  _QWORD *v2;
  unsigned __int8 *v3;
  void *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  size_t v9;
  size_t v10;
  _QWORD *v11;
  size_t v12;
  int v13;
  char *v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  size_t v23;
  uint64_t v24;
  int v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  int v44;
  uint64_t v45;
  char *v46;
  size_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  unsigned int *v62;
  char v64;
  uint64_t v65;
  unint64_t *v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  size_t v70;
  char *__base;
  void *v72;
  _DWORD __b[4096];
  uint64_t v74;

  v0 = MEMORY[0x24BDAC7A8]();
  v74 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(v0 + 8) = 0;
  if (atomic_load((unsigned int *)(*(_QWORD *)v0 + 104)))
    return 0;
  v2 = (_QWORD *)v0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = *(_QWORD *)v0;
  v7 = *(unsigned int *)(v0 + 32);
  v8 = (unint64_t *)(v0 + 16);
  v72 = 0;
  if ((unint64_t)(*(_QWORD *)(v6 + 56) - (v7 << 21)) >= 0x200000)
    v9 = 0x200000;
  else
    v9 = *(_QWORD *)(v6 + 56) - (v7 << 21);
  v10 = v9 - 17;
  if (v9 >= 0x11)
  {
    v4 = malloc(0x1000000uLL);
    v3 = (unsigned __int8 *)malloc(v9);
    v14 = (char *)malloc(0x40000uLL);
    v5 = v14;
    if (!v4 || (v3 ? (v15 = v14 == 0) : (v15 = 1), v15))
    {
      v25 = *__error();
      v26 = "aaMalloc";
      v27 = 496;
LABEL_72:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", v27, 112, v25, v26, v16, v17, v64);
      v13 = 0;
      goto LABEL_73;
    }
    v66 = v8;
    memset(__b, 255, sizeof(__b));
    v18 = *(_QWORD **)(v6 + 24);
    if (!v18[4])
      goto LABEL_70;
    __base = v5;
    v19 = 0;
    v20 = v9;
    v21 = v7 << 21;
    v22 = v3;
    v67 = v7;
    v68 = v20;
    v23 = v20;
    while (1)
    {
      v24 = ((uint64_t (*)(_QWORD, unsigned __int8 *, size_t, uint64_t))v18[4])(*v18, v22, v23, v21);
      if (v24 < 0)
        break;
      if (v24)
      {
        v22 += v24;
        v19 += v24;
        v21 += v24;
        v23 -= v24;
        if (v23)
          continue;
      }
      goto LABEL_25;
    }
    v19 = v24;
LABEL_25:
    LODWORD(v7) = v67;
    v9 = v68;
    v15 = v68 == v19;
    v5 = __base;
    if (v15)
    {
      v28 = 0;
      v29 = 0;
      do
        v29 = -1640531535 * (v29 + v3[v28++]);
      while (v28 != 16);
      v69 = (uint64_t)v4;
      v30 = 0;
      v31 = 0;
      v32 = 0;
      v33 = 0;
      v34 = *(_DWORD *)(v6 + 76);
      v35 = 16;
      do
      {
        if (v32 >= v30 || (*(_DWORD *)(v6 + 68) & ~v29) == 0)
        {
          v30 = v32 + (2 * *(_DWORD *)(v6 + 72));
          if (v32 >= v31)
          {
            v36 = *(unsigned int *)(*(_QWORD *)(v6 + 40) + 4 * (v29 >> -*(_BYTE *)(v6 + 64)));
            if ((_DWORD)v36 != -1)
            {
              v37 = __ROR8__(__ROR8__(2654435761 * *(_QWORD *)&v3[v32], 41) + 2654435761 * *(_QWORD *)&v3[v32 + 8], 41);
              v38 = HIDWORD(v37) ^ v37;
              v39 = *(_QWORD *)(v6 + 32);
              while (1)
              {
                v40 = v39 + 16 * v36;
                if (*(_DWORD *)(v40 + 8) == v38)
                  break;
                v36 = *(unsigned int *)(v40 + 12);
                if ((_DWORD)v36 == -1)
                  goto LABEL_46;
              }
              v41 = *(_QWORD *)(v39 + 16 * v36);
              v42 = v41 >> 20;
              v43 = v41 & 0xFFFFFFFFFFF00000;
              v44 = __b[v42];
              if (v44 == -1)
              {
LABEL_42:
                if (v33 != 0x4000)
                {
                  v46 = &__base[16 * v33];
                  *(_QWORD *)v46 = v43;
                  *((_DWORD *)v46 + 2) = v44;
                  *((_DWORD *)v46 + 3) = 1;
                  __b[v42] = v33++;
                }
              }
              else
              {
                v45 = __b[v42];
                while (*(_QWORD *)&__base[16 * v45] != v43)
                {
                  v45 = *(unsigned int *)&__base[16 * v45 + 8];
                  if ((_DWORD)v45 == -1)
                    goto LABEL_42;
                }
                ++*(_DWORD *)&__base[16 * v45 + 12];
              }
              v31 = v35;
            }
          }
        }
LABEL_46:
        v29 = -1640531535 * (v29 + v3[v35]) - v34 * v3[v32];
        v35 = v32 + 17;
        v15 = v32++ == v10;
      }
      while (!v15);
      if (!v33)
      {
        v8 = v66;
        goto LABEL_6;
      }
      v65 = (uint64_t)v3;
      qsort(__base, v33, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_rating);
      if (v33 >= 0x10)
        v47 = 16;
      else
        v47 = v33;
      v70 = v47;
      qsort(__base, v47, 0x10uLL, (int (__cdecl *)(const void *, const void *))chunk_compare_by_position);
      v50 = 0;
      LODWORD(v9) = 0;
      do
      {
        v51 = *(_QWORD *)&v5[16 * v50];
        if ((unint64_t)(*(_QWORD *)(v6 + 48) - v51) >= 0x100000)
          v52 = 0x100000;
        else
          v52 = *(_QWORD *)(v6 + 48) - v51;
        v53 = *(_QWORD **)(v6 + 16);
        if (!v53[4])
          goto LABEL_85;
        if (v52)
        {
          v54 = 0;
          v55 = v69 + v9;
          v56 = v52;
          while (1)
          {
            v57 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t))v53[4])(*v53, v55, v56, v51);
            if (v57 < 0)
              break;
            if (v57)
            {
              v55 += v57;
              v54 += v57;
              v51 += v57;
              v56 -= v57;
              if (v56)
                continue;
            }
            goto LABEL_64;
          }
          v54 = v57;
LABEL_64:
          v15 = v52 == v54;
          v5 = __base;
          if (!v15)
          {
LABEL_85:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_output_block", 546, 112, 0, "aaByteStreamPReadExpected", v48, v49, v64);
            v13 = 0;
            v4 = (void *)v69;
            v3 = (unsigned __int8 *)v65;
            goto LABEL_73;
          }
        }
        v9 = (v9 + v52);
        ++v50;
      }
      while (v50 != v70);
      v4 = (void *)v69;
      v3 = (unsigned __int8 *)v65;
      v8 = v66;
      if ((getBXDiffControls(v69, v9, v65, v68, (int8x16_t **)&v72, (uint64_t)v66, (int *)v6, v49) & 0x80000000) != 0)
      {
        v26 = "generic controls";
        v27 = 550;
      }
      else
      {
        v72 = convert_block_controls(v66, v72, *v66, (uint64_t)v5, v58, v59, v16, v17);
        if (v72)
        {
          LODWORD(v7) = v67;
          goto LABEL_8;
        }
        v26 = "convert_block_controls";
        v27 = 552;
      }
    }
    else
    {
LABEL_70:
      v26 = "aaByteStreamPReadExpected";
      v27 = 501;
    }
    v25 = 0;
    goto LABEL_72;
  }
LABEL_6:
  v11 = malloc(0x18uLL);
  v72 = v11;
  if (!v11)
  {
    v25 = *__error();
    v26 = "aaMalloc";
    v27 = 534;
    goto LABEL_72;
  }
  v12 = v9;
  LODWORD(v9) = 0;
  *v11 = 0;
  v11[1] = v12;
  v11[2] = 0;
  *v8 = 1;
LABEL_8:
  if (*(int *)(v6 + 4) >= 3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], " LargeFile: Block = %5u, %5u K cache, %6zu controls\n", v7, v9 >> 10, *v8);
  v13 = 1;
LABEL_73:
  free(v4);
  free(v3);
  free(v5);
  if ((v13 & 1) == 0)
    free(v72);
  v60 = v72;
  if (!v13)
    v60 = 0;
  v2[1] = v60;
  if (v60)
    return 0;
  v62 = (unsigned int *)(*v2 + 104);
  while (!__ldaxr(v62))
  {
    if (!__stlxr(1u, v62))
      return 0xFFFFFFFFLL;
  }
  __clrex();
  return 0xFFFFFFFFLL;
}

uint64_t LargeFileConsumer(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  unsigned int *v15;

  if (atomic_load((unsigned int *)(*a2 + 104)))
    return 0;
  result = a2[1];
  if (result)
  {
    if (a2[2])
    {
      v12 = 0;
      v13 = 0;
      v14 = *(char **)a1;
      do
      {
        v14 = add_control(v14, (unint64_t *)(a1 + 8), (unint64_t *)(a1 + 16), *(_QWORD *)(a2[1] + v12), *(_QWORD *)(a2[1] + v12 + 8), *(_QWORD *)(a2[1] + v12 + 16), a7, a8);
        *(_QWORD *)a1 = v14;
        if (!v14)
          break;
        ++v13;
        v12 += 24;
      }
      while (v13 < a2[2]);
      result = a2[1];
    }
    free((void *)result);
    if (*(_QWORD *)a1)
      return 0;
    v15 = (unsigned int *)(*a2 + 104);
    while (!__ldaxr(v15))
    {
      if (!__stlxr(1u, v15))
        return 0xFFFFFFFFLL;
    }
    __clrex();
    return 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t GetLargeFileMaxMemoryUsage(unint64_t a1, uint64_t a2, int DefaultNThreads)
{
  int v4;
  unsigned int v5;
  unint64_t v6;

  v4 = __clz((a1 + 15) >> 4);
  if (1 << ~(_BYTE)v4 >= (a1 + 15) >> 4)
    v5 = 63 - v4;
  else
    v5 = 64 - v4;
  v6 = 16;
  if (v5 >= 0x1E)
  {
    do
    {
      --v5;
      v6 = (2 * v6);
    }
    while (v5 > 0x1D);
    LOBYTE(v5) = 29;
  }
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  return (4 << v5)
       + 16 * ((5 * (a1 / v6)) >> 2)
       + (GetBXDiffMaxMemoryUsage(0x1000000uLL, 0x200000uLL, 1, 21) + 19136512) * DefaultNThreads;
}

uint64_t GetLargeFileControlsWithStreams(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7)
{
  double RealTime;
  unsigned int DefaultNThreads;
  uint64_t v16;
  int v17;
  int v18;
  unsigned int v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  uint64_t v40;
  char *v41;
  _QWORD *Worker;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  const char *v50;
  __int16 v51;
  int v52;
  int *v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  FILE *v65;
  unint64_t v66;
  void **v67;
  uint64_t v68;
  unint64_t v69;
  double v70;
  uint64_t i;
  _QWORD *v72;
  unsigned int *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  FILE *v89;
  uint64_t v90;
  double v91;
  uint64_t v92;
  const char *v93;
  __int16 v94;
  char v95;
  uint64_t v96;
  uint64_t *v97;
  void *v98;
  uint64_t v99;
  unint64_t v100;
  _DWORD v101[2];
  uint64_t v102;
  uint64_t v103;
  __int128 v104;
  void *v105[2];
  __int128 v106;
  __int128 v107;
  void *v108[2];
  unsigned int v109[4];

  RealTime = getRealTime();
  DefaultNThreads = *((_DWORD *)a7 + 2);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  *(_QWORD *)v109 = 0;
  v107 = 0u;
  *(_OWORD *)v108 = 0u;
  *(_OWORD *)v105 = 0u;
  v106 = 0u;
  v102 = 0;
  v98 = 0;
  v99 = 0;
  v103 = a1;
  v104 = a3;
  v16 = *a7;
  v17 = 16;
  v100 = 0;
  v101[1] = HIDWORD(v16);
  v101[0] = 21;
  v18 = __clz((a2 + 15) >> 4);
  LODWORD(v102) = 1;
  v105[1] = (void *)a2;
  *(_QWORD *)&v106 = a4;
  if (1 << ~(_BYTE)v18 >= (a2 + 15) >> 4)
    v19 = 63 - v18;
  else
    v19 = 64 - v18;
  LODWORD(v107) = 16;
  if (v19 >= 0x1E)
  {
    do
    {
      --v19;
      v17 *= 2;
    }
    while (v19 > 0x1D);
    LODWORD(v107) = v17;
    v19 = 29;
  }
  DWORD2(v106) = v19;
  HIDWORD(v106) = v17 - 1;
  DWORD1(v107) = 840293553;
  if (DefaultNThreads < 0xCCCCCCCD)
  {
    v20 = calloc(DefaultNThreads, 0x28uLL);
  }
  else
  {
    v20 = 0;
    *__error() = 12;
  }
  v108[0] = v20;
  v21 = calloc(DefaultNThreads, 8uLL);
  v108[1] = v21;
  if (!v20 || !v21)
  {
    v49 = *__error();
    v50 = "aaCalloc";
    v51 = 672;
LABEL_35:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v51, 112, v49, v50, v22, v23, v95);
    goto LABEL_36;
  }
  *((_QWORD *)&v104 + 1) = pc_array_init(16, (5 * (a2 / v107)) >> 2);
  if (!*((_QWORD *)&v104 + 1))
  {
    v50 = "pc_array_init";
    v51 = 678;
LABEL_34:
    v49 = 0;
    goto LABEL_35;
  }
  v24 = malloc(4 << SBYTE8(v106));
  v105[0] = v24;
  if (!v24)
  {
    v49 = *__error();
    v50 = "malloc";
    v51 = 683;
    goto LABEL_35;
  }
  memset(v24, 255, 4 << SBYTE8(v106));
  v25 = calloc(DefaultNThreads, 0x20uLL);
  v26 = calloc(DefaultNThreads, 8uLL);
  v27 = v26;
  if (!v25 || !v26)
  {
    v54 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 433, 112, *v54, "aaCalloc", v55, v56, v95);
    v39 = 0;
LABEL_49:
    v48 = 0;
    goto LABEL_50;
  }
  if (DefaultNThreads)
  {
    v28 = v25;
    v29 = v26;
    v30 = DefaultNThreads;
    v31 = v25;
    do
    {
      *v31 = v101;
      v31 += 4;
      *v29++ = v28;
      v28 = v31;
      --v30;
    }
    while (v30);
  }
  v39 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v26, (uint64_t)fingerprint_worker, (uint64_t)v101, (uint64_t)fingerprint_consumer, 0);
  if (!v39)
  {
    v57 = "ThreadPipelineCreate";
    v58 = 444;
LABEL_48:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v58, 112, 0, v57, v37, v38, v95);
    goto LABEL_49;
  }
  v97 = a6;
  if (!v105[1])
  {
LABEL_29:
    a6 = v97;
    if ((ThreadPipelineFlush((uint64_t)v39) & 0x80000000) != 0)
    {
      v57 = "ThreadPipelineFlush";
      v58 = 461;
    }
    else
    {
      *((_QWORD *)&v104 + 1) = pc_array_compact(*((uint64_t *)&v104 + 1));
      if (*((_QWORD *)&v104 + 1))
      {
        v48 = 1;
        goto LABEL_50;
      }
      v57 = "pc_array_compact";
      v58 = 465;
    }
    goto LABEL_48;
  }
  v40 = 0;
  v41 = 0;
  while (1)
  {
    Worker = (_QWORD *)ThreadPipelineGetWorker((uint64_t)v39, v32, v33, v34, v35, v36, v37, v38);
    if (!Worker)
    {
      v59 = "ThreadPipelineGetWorker";
      v60 = 451;
      goto LABEL_45;
    }
    Worker[1] = 0;
    Worker[2] = v41;
    v47 = (uint64_t)v105[1] + v40;
    if ((unint64_t)v105[1] + v40 >= 0x200000)
      v47 = 0x200000;
    Worker[3] = v47;
    if ((ThreadPipelineRunWorker((uint64_t)v39, (uint64_t)Worker, v43, v44, v45, v46, v37, v38) & 0x80000000) != 0)
      break;
    v41 += 0x200000;
    v40 -= 0x200000;
    if (v41 >= v105[1])
      goto LABEL_29;
  }
  v59 = "ThreadPipelineRunWorker";
  v60 = 457;
LABEL_45:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", v60, 112, 0, v59, v37, v38, v95);
  v48 = 0;
  a6 = v97;
LABEL_50:
  if ((ThreadPipelineDestroy((uint64_t)v39) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"process_input", 468, 112, 0, "ThreadPipelineDestroy", v61, v62, v95);
    v48 = 0;
  }
  free(v25);
  free(v27);
  if (!v48)
    goto LABEL_36;
  if (*((int *)a7 + 1) >= 3)
  {
    v65 = (FILE *)*MEMORY[0x24BDAC8D8];
    v66 = (unint64_t)(4 << SBYTE8(v106)) >> 20;
    v67 = a5;
    v68 = (*(_QWORD *)(*((_QWORD *)&v104 + 1) - 64) >> 16) & 0xFFFFFFFFFFFLL;
    v69 = (unint64_t)v105[1] >> 20;
    v70 = getRealTime();
    v96 = v68;
    a5 = v67;
    fprintf(v65, " LargeFile: Using %zu M for hashing.\n LargeFile: Using %zu M for fingerprints.\n LargeFile: Parsed %zu M in %0.2f (s). Added %zu/%zu fingerprints.\n", v66, v96, v69, v70 - RealTime, *(_QWORD *)(*((_QWORD *)&v104 + 1) - 64), (unint64_t)v105[1] / v107);
  }
  v98 = add_control(0, (unint64_t *)&v99, &v100, 0, 0, 0, v63, v64);
  if (!v98)
    goto LABEL_36;
  if (DefaultNThreads)
  {
    for (i = 0; i != DefaultNThreads; *((_QWORD *)v108[1] + i++) = v72)
    {
      v72 = (char *)v108[0] + 40 * i;
      *v72 = v101;
    }
  }
  v73 = ThreadPipelineCreate(DefaultNThreads, (uint64_t)v108[1], (uint64_t)LargeFileWorker, (uint64_t)&v98, (uint64_t)LargeFileConsumer, 0);
  *((_QWORD *)&v107 + 1) = v73;
  if (!v73)
  {
    v50 = "creating pipeline";
    v51 = 711;
    goto LABEL_34;
  }
  if (!a4)
  {
LABEL_67:
    if ((ThreadPipelineDestroy((uint64_t)v73) & 0x80000000) == 0)
    {
      *((_QWORD *)&v107 + 1) = 0;
      v99 = sanitize_internal_controls(v98, v99);
      convert_internal_controls((uint64_t)&v98);
      if (*((int *)a7 + 1) >= 2)
      {
        v89 = (FILE *)*MEMORY[0x24BDAC8D8];
        v90 = v99;
        v91 = getRealTime();
        fprintf(v89, "LargeFile: Constructed %zu controls in %0.2f (s).\n", v90, v91 - RealTime);
      }
      v52 = 0;
      v92 = v99;
      *a5 = v98;
      *a6 = v92;
      goto LABEL_37;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", 725, 112, 0, "ThreadPipelineDestroy failed", v87, v88, v95);
    *((_QWORD *)&v107 + 1) = 0;
LABEL_36:
    v52 = 1;
    goto LABEL_37;
  }
  v79 = 1;
  while (1)
  {
    v80 = ThreadPipelineGetWorker(*((uint64_t *)&v107 + 1), v74, v75, v76, v77, v78, v22, v23);
    if (!v80)
      break;
    *(_DWORD *)(v80 + 32) = v79 - 1;
    if ((ThreadPipelineRunWorker(*((uint64_t *)&v107 + 1), v80, v81, v82, v83, v84, v22, v23) & 0x80000000) != 0
      || (v85 = atomic_load(v109)) != 0)
    {
      v93 = "RunWorker";
      v94 = 723;
      goto LABEL_75;
    }
    v86 = v79++;
    if (a4 <= v86 << 21)
    {
      v73 = (unsigned int *)*((_QWORD *)&v107 + 1);
      goto LABEL_67;
    }
  }
  v93 = "getting worker from pipeline";
  v94 = 718;
LABEL_75:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControlsWithStreams", v94, 112, 0, v93, v22, v23, v95);
  v52 = 1;
LABEL_37:
  ThreadPipelineDestroy(*((uint64_t *)&v107 + 1));
  free(v108[0]);
  free(v108[1]);
  free(v105[0]);
  pc_array_free(*((uint64_t *)&v104 + 1));
  if (v52)
  {
    free(v98);
    *a5 = 0;
    *a6 = 0;
  }
  return (v52 << 31 >> 31);
}

char *add_control(char *__ptr, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  char *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  v12 = __ptr;
  v13 = *a2;
  if (*a2 < *a3)
    goto LABEL_2;
  v15 = v13 + (v13 >> 1) + 1;
  *a3 = v15;
  if (*a2 >= v15)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 213, 112, 0, "too many controls", a7, a8, v21);
    free(v12);
    return 0;
  }
  if (24 * v15 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_10:
    v17 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"add_control", 215, 112, *v17, "aaReallocf", v18, v19, v21);
    return 0;
  }
  v16 = (char *)realloc(__ptr, 24 * v15);
  if (!v16)
  {
    free(v12);
    goto LABEL_10;
  }
  v13 = *a2;
  v12 = v16;
LABEL_2:
  *a2 = v13 + 1;
  v14 = &v12[24 * v13];
  *(_QWORD *)v14 = a4;
  *((_QWORD *)v14 + 1) = a5;
  *((_QWORD *)v14 + 2) = a6;
  return v12;
}

uint64_t sanitize_internal_controls(_QWORD *a1, uint64_t a2)
{
  char *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  v2 = (char *)a1;
  if (a2 >= 2)
  {
    v3 = (unint64_t)&a1[3 * a2];
    v4 = a1 + 3;
    v5 = a1;
    v6 = (char *)a1;
    do
    {
      v7 = v5;
      while (1)
      {
        v5 = v4;
        v8 = *v4;
        if (!v8)
        {
          v9 = *((_QWORD *)v6 + 1) + v7[4];
          goto LABEL_9;
        }
        if (*((_QWORD *)v6 + 1) || *(_QWORD *)v6 + *((_QWORD *)v6 + 2) != v7[5])
          break;
        *(_QWORD *)v6 += v8;
        v9 = v7[4];
LABEL_9:
        *((_QWORD *)v6 + 1) = v9;
        v4 = v5 + 3;
        v7 = v5;
        if ((unint64_t)(v5 + 3) >= v3)
        {
          v2 = v6;
          return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
        }
      }
      v2 = v6 + 24;
      v10 = *(_OWORD *)v5;
      *((_QWORD *)v6 + 5) = v5[2];
      *(_OWORD *)(v6 + 24) = v10;
      v4 = v5 + 3;
      v6 += 24;
    }
    while ((unint64_t)(v5 + 3) < v3);
  }
  return -1431655765 * ((unint64_t)(v2 - (char *)a1) >> 3) + 1;
}

uint64_t convert_internal_controls(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t *v3;
  int64x2_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int64x2_t v8;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = 0;
    v3 = *(uint64_t **)result;
    v4 = vdupq_n_s64(0x8000000000000000);
    do
    {
      v5 = *v3;
      v6 = v3[2] + *v3;
      ++v2;
      v7 = v6;
      if (v2 < v1)
        v7 = v3[5];
      if (v5 < 0)
        v5 = 0x8000000000000000 - v5;
      *v3 = v5;
      v8.i64[0] = v3[1];
      v8.i64[1] = v7 - v6;
      *(int8x16_t *)(v3 + 1) = vbslq_s8((int8x16_t)vcltzq_s64(v8), (int8x16_t)vsubq_s64(v4, v8), (int8x16_t)v8);
      v3 += 3;
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t GetLargeFileControls(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void **a5, uint64_t *a6, uint64_t *a7, uint64_t a8)
{
  AAByteStream_impl *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  AAByteStream_impl *v21;
  uint64_t v22;
  uint64_t v23;
  AAByteStream_impl *v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  char v29;

  v14 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a1, a2, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  v21 = (AAByteStream_impl *)AAMemoryInputStreamOpen(a3, a4, v15, v16, v17, v18, v19, v20);
  v24 = v21;
  if (!v14 || !v21)
  {
    v26 = "AAMemoryInputStreamOpen";
    v27 = 758;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"GetLargeFileControls", v27, 112, 0, v26, v22, v23, v29);
    v25 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }
  if ((GetLargeFileControlsWithStreams((uint64_t)v14, a2, (unint64_t)v21, a4, a5, a6, a7) & 0x80000000) != 0)
  {
    v26 = "GetLargeFileControlsWithStreams";
    v27 = 761;
    goto LABEL_7;
  }
  v25 = 0;
LABEL_8:
  AAByteStreamClose(v14);
  AAByteStreamClose(v24);
  return v25;
}

uint64_t chunk_compare_by_rating(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12));
}

uint64_t chunk_compare_by_position(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

char *convert_block_controls(unint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  __int16 v23;
  unint64_t v26;

  v26 = 0;
  *a1 = 0;
  if (a3)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    do
    {
      v14 = a2[3 * v11];
      if (v14 >= 0)
        v15 = a2[3 * v11];
      else
        v15 = 0x8000000000000000 - v14;
      while (1)
      {
        v16 = v12 & 0xFFFFF;
        v17 = 0x100000 - (v12 & 0xFFFFF);
        if (v17 >= v15)
          break;
        v18 = add_control(v13, a1, &v26, 0x100000 - (v12 & 0xFFFFF), 0, *(_QWORD *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
        if (!v18)
        {
          v23 = 251;
LABEL_18:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"convert_block_controls", v23, 112, 0, "add_control", a7, a8, a3);
          goto LABEL_19;
        }
        v13 = v18;
        v15 -= v17;
        v12 += v17;
      }
      v19 = a2[3 * v11 + 1];
      if (v19 >= 0)
        v20 = a2[3 * v11 + 1];
      else
        v20 = 0x8000000000000000 - v19;
      v21 = add_control(v13, a1, &v26, v15, v20, *(_QWORD *)(a4 + 16 * (v12 >> 20)) + v16, a7, a8);
      if (!v21)
      {
        v23 = 255;
        goto LABEL_18;
      }
      v13 = v21;
      v22 = a2[3 * v11 + 2];
      if (v22 < 0)
        v22 = 0x8000000000000000 - v22;
      v12 += v15 + v22;
      ++v11;
    }
    while (v11 != a3);
  }
  else
  {
LABEL_19:
    v13 = 0;
  }
  free(a2);
  return v13;
}

uint64_t fingerprint_worker(uint64_t *a1)
{
  size_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  unsigned int v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v40;
  int v41;
  unsigned int v42;

  v2 = a1[3];
  if (v2 < 0x11)
    return 0;
  if (v2 >= 0x2000000001)
  {
    *__error() = 12;
LABEL_14:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", 325, 112, 0, "aaMalloc", v4, v5, v40);
    v8 = 0;
    v15 = 0;
    goto LABEL_32;
  }
  v6 = *a1;
  v7 = (unsigned __int8 *)malloc(v2);
  if (!v7)
    goto LABEL_14;
  v8 = v7;
  v15 = pc_array_init(16);
  if (!v15)
  {
    v23 = "pc_array_init";
    v24 = 329;
    goto LABEL_31;
  }
  v16 = a1[3];
  v17 = *(_QWORD **)(v6 + 16);
  if (!v17[4])
  {
    v18 = -1;
LABEL_18:
    if (v16 != v18)
    {
      v23 = "aaByteStreamPReadExpected";
      v24 = 333;
      goto LABEL_31;
    }
    goto LABEL_19;
  }
  if (v16)
  {
    v18 = 0;
    v19 = a1[2];
    v20 = v8;
    v21 = a1[3];
    while (1)
    {
      v22 = ((uint64_t (*)(_QWORD, unsigned __int8 *, uint64_t, uint64_t))v17[4])(*v17, v20, v21, v19);
      if (v22 < 0)
        break;
      if (v22)
      {
        v20 += v22;
        v18 += v22;
        v19 += v22;
        v21 -= v22;
        if (v21)
          continue;
      }
      goto LABEL_18;
    }
    v18 = v22;
    goto LABEL_18;
  }
LABEL_19:
  v25 = 0;
  v26 = 0;
  do
    v26 = -1640531535 * (v26 + v8[v25++]);
  while (v25 != 16);
  v27 = a1[3];
  if (v27 < 0x11)
  {
LABEL_29:
    v3 = 0;
    a1[1] = (uint64_t)v15;
    v15 = 0;
    goto LABEL_33;
  }
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = *(_DWORD *)(v6 + 72) << 8;
  while (1)
  {
    if (v31 < v30 || v31 < v29 && (*(_DWORD *)(v6 + 68) & ~v26) != 0)
      goto LABEL_28;
    v33 = *(unsigned int *)(v6 + 72);
    v40 = v31 + a1[2];
    v34 = __ROR8__(__ROR8__(2654435761 * *(_QWORD *)&v8[v31], 41) + 2654435761 * *(_QWORD *)&v8[v31 + 8], 41);
    v35 = v26 >> -*(_BYTE *)(v6 + 64);
    v41 = HIDWORD(v34) ^ v34;
    v42 = v35;
    v15 = pc_array_append((uint64_t)v15, &v40, v9, v10, v11, v12, v13, v14);
    if (!v15)
      break;
    v29 = v31 + (2 * v33);
    v36 = v28 + (v32 >> 8);
    v37 = v32 + v31;
    v32 = v31 + v32 - v36;
    v30 = v31 + v33 - ((unint64_t)(v37 - v36) >> 8);
    v27 = a1[3];
    v28 = v31;
LABEL_28:
    v26 = -1640531535 * (v26 + v8[v31 + 16]) - *(_DWORD *)(v6 + 76) * v8[v31];
    v38 = v31 + 17;
    ++v31;
    if (v38 >= v27)
      goto LABEL_29;
  }
  v23 = "pc_array_append";
  v24 = 361;
LABEL_31:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_worker", v24, 112, 0, v23, v13, v14, v40);
LABEL_32:
  v3 = 0xFFFFFFFFLL;
LABEL_33:
  free(v8);
  pc_array_free((uint64_t)v15);
  return v3;
}

uint64_t fingerprint_consumer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v11;
  int v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  char v22;

  v8 = *(_QWORD *)(a2 + 8);
  if (!v8)
    return 0;
  v9 = *(_QWORD *)(v8 - 64);
  if (!v9)
  {
LABEL_13:
    v12 = 0;
    goto LABEL_16;
  }
  v11 = 0;
  v12 = 1;
  while (1)
  {
    v13 = (_DWORD *)(v8 + 16 * v11);
    v14 = *(_QWORD *)(a1 + 40);
    v15 = v13[3];
    v16 = *(_DWORD *)(v14 + 4 * v15);
    if (v16 != -1)
    {
      v17 = *(unsigned int *)(v14 + 4 * v15);
      while (1)
      {
        v18 = *(_QWORD *)(a1 + 32) + 16 * v17;
        if (v13[2] == *(_DWORD *)(v18 + 8))
          break;
        v17 = *(unsigned int *)(v18 + 12);
        if ((_DWORD)v17 == -1)
          goto LABEL_8;
      }
      if (*(_QWORD *)v18 < *(_QWORD *)v13)
        *(_QWORD *)v18 = *(_QWORD *)v13;
      goto LABEL_9;
    }
LABEL_8:
    v13[3] = v16;
    v19 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)(v14 + 4 * v15) = *(_QWORD *)(v19 - 64);
    v20 = pc_array_append(v19, v13, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 32) = v20;
    if (!v20)
      break;
LABEL_9:
    v12 = ++v11 < v9;
    if (v11 == v9)
      goto LABEL_13;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/LargeFile.c", (uint64_t)"fingerprint_consumer", 413, 112, 0, "pc_array_append", a7, a8, v22);
LABEL_16:
  pc_array_free(v8);
  return (v12 << 31 >> 31);
}

uint64_t ParallelCompressionEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  __int128 v9;
  _OWORD v11[3];
  unsigned int v12[2];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  v8 = *(_DWORD *)(a1 + 4);
  LODWORD(v15) = *(_DWORD *)a1;
  v14 = *(_QWORD *)(a1 + 16);
  v12[1] = 0;
  v13 = v8;
  v12[0] = *(_DWORD *)(a1 + 8);
  v9 = *(_OWORD *)(a1 + 40);
  v11[0] = *(_OWORD *)(a1 + 24);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 56);
  return PCompressFilter(v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t ParallelCompressionDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  __int128 v9;
  _OWORD v11[3];
  __int128 v12;
  __int128 v13;

  v12 = 0u;
  v13 = 0u;
  v8 = *(_DWORD *)(a1 + 4);
  DWORD2(v13) = *(_DWORD *)a1;
  DWORD1(v12) = 1;
  DWORD2(v12) = v8;
  v9 = *(_OWORD *)(a1 + 24);
  v11[0] = *(_OWORD *)(a1 + 8);
  v11[1] = v9;
  v11[2] = *(_OWORD *)(a1 + 40);
  return PCompressFilter((unsigned int *)&v12, (uint64_t)v11, 0, a4, a5, a6, a7, a8);
}

uint64_t (*PCompressGetEncoderFilter(unsigned int a1))()
{
  if (a1 > 6)
    return 0;
  else
    return off_24BF0B970[a1];
}

uint64_t (*PCompressGetDecoderFilter(unsigned int a1))()
{
  if (a1 > 6)
    return 0;
  else
    return off_24BF0B9A8[a1];
}

char *PCompressGetEncoderDescription(unsigned int a1)
{
  if (a1 > 6)
    return 0;
  else
    return (&off_24BF0B9E0)[a1];
}

uint64_t PCompressGetEncoderDecoder(uint64_t result)
{
  if (result >= 7)
    return 0xFFFFFFFFLL;
  else
    return result;
}

unint64_t PCompressGetDecoderKey(unsigned int a1)
{
  unint64_t v1;

  v1 = 0x2D62653466787AuLL >> (8 * a1);
  if (a1 >= 7)
    LOBYTE(v1) = 63;
  return v1 & 0x7F;
}

char *PCompressGetDecoderDescription(unsigned int a1)
{
  if (a1 > 6)
    return 0;
  else
    return (&off_24BF0BA18)[a1];
}

_QWORD *aaCacheStreamOpen(AAByteStream_impl *a1, unint64_t a2, int a3, int a4, unint64_t a5)
{
  _QWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  int v18;
  off_t v19;
  size_t v20;
  void *v21;
  uint64_t v22;
  unint64_t v23;
  size_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v35;

  v10 = calloc(1uLL, 0x68uLL);
  v11 = calloc(1uLL, 0x70uLL);
  v14 = (uint64_t)v11;
  if (!v11 || !v10)
  {
    v18 = *__error();
    v16 = "aaCalloc";
    v17 = 472;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamOpen", v17, 146, v18, v16, v12, v13, v35);
    free(v10);
    aaCacheStreamClose(v14, v27, v28, v29, v30, v31, v32, v33);
    return 0;
  }
  *(_QWORD *)v11 = a1;
  v11[26] = a4;
  v11[27] = a5 >> 62;
  v15 = ((1 << a3) - 1);
  v11[23] = 1 << a3;
  v11[24] = v15;
  v11[21] = (v15 | a2) >> a3;
  v11[22] = a3;
  if (a2 - 1073741825 <= 0xFFFFFFFFBFFFFFFFLL)
  {
    v16 = "cache too big";
    v17 = 484;
LABEL_17:
    v18 = 0;
    goto LABEL_18;
  }
  v19 = AAByteStreamSeek(a1, 0, 2);
  *(_QWORD *)(v14 + 24) = v19;
  *(_QWORD *)(v14 + 32) = v19;
  if (v19 < 0)
  {
    v16 = "AAByteStreamSeek";
    v17 = 488;
    goto LABEL_17;
  }
  v20 = *(unsigned int *)(v14 + 84);
  if (v20 >= 0xCCCCCCCD)
  {
    *__error() = 12;
    *(_QWORD *)(v14 + 72) = 0;
LABEL_16:
    v16 = "aaCalloc";
    v17 = 492;
    goto LABEL_17;
  }
  v21 = calloc(v20, 0x28uLL);
  *(_QWORD *)(v14 + 72) = v21;
  if (!v21)
    goto LABEL_16;
  if (*(_DWORD *)(v14 + 84))
  {
    v22 = 0;
    v23 = 0;
    v24 = *(unsigned int *)(v14 + 92);
    while (1)
    {
      v25 = calloc(1uLL, v24);
      v26 = *(_QWORD *)(v14 + 72) + v22;
      *(_QWORD *)(v26 + 16) = v25;
      if (!v25)
        break;
      bzero(v25, *(unsigned int *)(v14 + 92));
      *(_QWORD *)v26 = -1;
      v24 = *(unsigned int *)(v14 + 92);
      *(_DWORD *)(v26 + 28) = 0;
      *(_DWORD *)(v26 + 32) = 0;
      *(_DWORD *)(v26 + 24) = v24;
      ++v23;
      v22 += 40;
      if (v23 >= *(unsigned int *)(v14 + 84))
        goto LABEL_15;
    }
    v16 = "aaCalloc";
    v17 = 498;
    goto LABEL_17;
  }
LABEL_15:
  AACustomByteStreamSetData((AAByteStream)v10, (void *)v14);
  AACustomByteStreamSetSeekProc((AAByteStream)v10, (AAByteStreamSeekProc)aaCacheStreamSeek);
  AACustomByteStreamSetPReadProc((AAByteStream)v10, (AAByteStreamPReadProc)aaCacheStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v10, (AAByteStreamPWriteProc)aaCacheStreamPWrite);
  AACustomByteStreamSetReadProc((AAByteStream)v10, (AAByteStreamReadProc)aaCacheStreamRead);
  AACustomByteStreamSetWriteProc((AAByteStream)v10, (AAByteStreamWriteProc)aaCacheStreamWrite);
  AACustomByteStreamSetCancelProc((AAByteStream)v10, (AAByteStreamCancelProc)aaCacheStreamCancel);
  AACustomByteStreamSetCloseProc((AAByteStream)v10, (AAByteStreamCloseProc)aaCacheStreamClose);
  v10[8] = aaCacheStreamTruncate;
  return v10;
}

uint64_t aaCacheStreamSeek(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  char vars0;

  if (*(_DWORD *)(a1 + 100))
    return -1;
  if (a3)
  {
    if (a3 == 2)
    {
      v8 = (_QWORD *)(a1 + 24);
    }
    else
    {
      if (a3 != 1)
      {
LABEL_10:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamSeek", 392, 146, 0, "bad seek", a7, a8, vars0);
        return -1;
      }
      v8 = (_QWORD *)(a1 + 16);
    }
    a2 += *v8;
  }
  if (a2 < 0)
    goto LABEL_10;
  *(_QWORD *)(a1 + 16) = a2;
  return a2;
}

uint64_t aaCacheStreamPRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  int64_t v13;
  unint64_t v14;
  unint64_t v16;
  size_t v17;
  __int128 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v29;
  __int16 v30;
  char v31;

  if (*(_DWORD *)(a1 + 100))
    return -1;
  v9 = a4;
  v11 = *(_QWORD *)(a1 + 24);
  v12 = v11 <= a4;
  v13 = v11 - a4;
  if (v12)
    return 0;
  if (v13 >= a3)
    v14 = a3;
  else
    v14 = v13;
  if (v14)
  {
    v8 = 0;
    while (1)
    {
      v16 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v9 & v16) >= v14)
        v17 = v14;
      else
        v17 = *(unsigned int *)(a1 + 92) - (v9 & v16);
      v18 = cachePageGet(a1, v9 & ~v16, a3, a4, a5, a6, a7, a8);
      if (!v18)
      {
        v29 = "cachePageGet";
        v30 = 224;
        goto LABEL_25;
      }
      v25 = v18;
      v26 = v16 & v9;
      if ((v26 < *((_DWORD *)v18 + 6) || (v26 + v17) > *((_DWORD *)v18 + 7))
        && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v18, v19, v20, v21, v22, v23, v24) & 0x80000000) != 0)
      {
        break;
      }
      memcpy(a2, (const void *)(*((_QWORD *)v25 + 2) + v26), v17);
      ++*(_QWORD *)(a1 + 40);
      v27 = *(_QWORD *)(a1 + 8) + 1;
      *(_QWORD *)(a1 + 8) = v27;
      *((_QWORD *)v25 + 1) = v27;
      if ((v17 & 0x8000000000000000) != 0)
        goto LABEL_26;
      v8 += v17;
      a2 += v17;
      v9 += v17;
      v14 -= v17;
      if (!v14)
        goto LABEL_21;
    }
    v29 = "cachePageReadFromDisk";
    v30 = 229;
LABEL_25:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheRead", v30, 146, 0, v29, v23, v24, v31);
LABEL_26:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPRead", 313, 146, 0, "cacheRead", a7, a8, v31);
    return -1;
  }
  v8 = 0;
LABEL_21:
  *(_QWORD *)(a1 + 16) = v9;
  return v8;
}

uint64_t aaCacheStreamPWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  __int128 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  __int16 v31;
  char v33;

  if (*(_DWORD *)(a1 + 100))
    return -1;
  v8 = a4;
  v9 = a3;
  if (a3)
  {
    v12 = 0;
    while (1)
    {
      v13 = *(unsigned int *)(a1 + 96);
      if (*(unsigned int *)(a1 + 92) - (v8 & v13) >= v9)
        v14 = v9;
      else
        v14 = *(unsigned int *)(a1 + 92) - (v8 & v13);
      v15 = cachePageGet(a1, v8 & ~v13, a3, a4, a5, a6, a7, a8);
      if (!v15)
      {
        v30 = "cachePageGet";
        v31 = 254;
        goto LABEL_28;
      }
      v22 = v15;
      v23 = v13 & v8;
      v24 = v23 + v14;
      v25 = *((_DWORD *)v15 + 6);
      v26 = *((_DWORD *)v15 + 7);
      if (v25 < v26)
      {
        v27 = v24 < v25 || v23 > v26;
        if (v27
          && (cachePageReadFromDisk((uint64_t *)a1, (uint64_t *)v15, v16, v17, v18, v19, v20, v21) & 0x80000000) != 0)
        {
          break;
        }
      }
      memcpy((void *)(*((_QWORD *)v22 + 2) + v23), a2, v14);
      ++*(_QWORD *)(a1 + 48);
      if (v23 < *((_DWORD *)v22 + 6))
        *((_DWORD *)v22 + 6) = v23;
      if (v24 > *((_DWORD *)v22 + 7))
        *((_DWORD *)v22 + 7) = v24;
      v28 = *(_QWORD *)(a1 + 8) + 1;
      *(_QWORD *)(a1 + 8) = v28;
      *((_QWORD *)v22 + 1) = v28;
      *((_DWORD *)v22 + 8) = 1;
      v29 = v8 + (int)v14;
      if (*(_QWORD *)(a1 + 24) < v29)
        *(_QWORD *)(a1 + 24) = v29;
      if ((v14 & 0x8000000000000000) != 0)
        goto LABEL_29;
      v12 += v14;
      a2 += v14;
      v8 += v14;
      v9 -= v14;
      if (!v9)
        goto LABEL_25;
    }
    v30 = "cachePageReadFromDisk";
    v31 = 262;
LABEL_28:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheWrite", v31, 146, 0, v30, v20, v21, v33);
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamPWrite", 346, 146, 0, "cacheWrite", a7, a8, v33);
    return -1;
  }
  v12 = 0;
LABEL_25:
  *(_QWORD *)(a1 + 16) = v8;
  return v12;
}

uint64_t aaCacheStreamRead(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPRead(a1, a2, a3, *(_QWORD *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return aaCacheStreamPWrite(a1, a2, a3, *(_QWORD *)(a1 + 16), a5, a6, a7, a8);
}

uint64_t aaCacheStreamCancel(uint64_t result)
{
  *(_DWORD *)(result + 100) = 1;
  return result;
}

uint64_t aaCacheStreamClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (result)
  {
    v8 = result;
    if (*(_QWORD *)(result + 72))
    {
      if ((cacheFlush(result, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 440, 146, 0, "cacheFlush", v9, v10, v16);
        v11 = 0;
      }
      else
      {
        v11 = 1;
      }
      if (*(_DWORD *)(v8 + 84))
      {
        v12 = 0;
        v13 = 16;
        do
        {
          free(*(void **)(*(_QWORD *)(v8 + 72) + v13));
          ++v12;
          v13 += 40;
        }
        while (v12 < *(unsigned int *)(v8 + 84));
      }
      free(*(void **)(v8 + 72));
    }
    else
    {
      v11 = 1;
    }
    if (*(_DWORD *)(v8 + 104) && AAByteStreamClose(*(AAByteStream *)v8) < 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamClose", 446, 146, 0, "AAByteStreamClose", v14, v15, v16);
      v11 = 0;
    }
    if (*(int *)(v8 + 108) >= 1)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "CacheStream: read ops %zu/%zu, write ops %zu/%zu\n", *(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 40), *(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 48));
    free((void *)v8);
    if (v11)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t aaCacheStreamTruncate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  const char *v13;
  __int16 v14;
  char v15;

  if (!*(_DWORD *)(a1 + 100))
  {
    if ((cacheFlush(a1, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      v13 = "cacheFlush";
      v14 = 411;
    }
    else
    {
      if ((AAByteStreamTruncate(*(_QWORD **)a1) & 0x80000000) == 0)
      {
        result = 0;
        *(_QWORD *)(a1 + 24) = a2;
        *(_QWORD *)(a1 + 32) = a2;
        return result;
      }
      v13 = "AAByteStreamTruncate";
      v14 = 412;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"aaCacheStreamTruncate", v14, 146, 0, v13, v10, v11, v15);
  }
  return 0xFFFFFFFFLL;
}

__int128 *cachePageGet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  __int128 *v11;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 *v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  char v29;

  v8 = *(_QWORD *)(a1 + 72);
  v9 = *(_DWORD *)(a1 + 84) - 1;
  v10 = v9 & ((unint64_t)(0x16069317E428CA9 * a2) >> 32);
  v11 = (__int128 *)(v8 + 40 * v10);
  if (*(_QWORD *)v11 != a2)
  {
    v14 = v10 & 0xFFFFFC00;
    v15 = v10 | 0x3FF;
    if ((v10 | 0x3FF) >= v9)
      v15 = *(_DWORD *)(a1 + 84) - 1;
    if (v14 <= v15)
    {
      v16 = v10 & 0xFFFFFC00;
      while (*(_QWORD *)(v8 + 40 * v14) != a2)
      {
        if (*(_QWORD *)(v8 + 40 * v14 + 8) < *(_QWORD *)(v8 + 40 * v16 + 8))
          v16 = v14;
        if (++v14 > v15)
          goto LABEL_11;
      }
    }
    v16 = v14;
LABEL_11:
    v17 = *((_QWORD *)v11 + 4);
    v19 = *v11;
    v18 = v11[1];
    v20 = (__int128 *)(v8 + 40 * v16);
    v21 = *((_QWORD *)v20 + 4);
    v22 = v20[1];
    *v11 = *v20;
    v11[1] = v22;
    *((_QWORD *)v11 + 4) = v21;
    v23 = *(_QWORD *)(a1 + 72) + 40 * v16;
    *(_OWORD *)v23 = v19;
    *(_OWORD *)(v23 + 16) = v18;
    *(_QWORD *)(v23 + 32) = v17;
    if (*(_QWORD *)v11 != a2)
    {
      if ((cachePageEvict((uint64_t *)a1, v8 + 40 * v10, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageGet", 162, 146, 0, "cachePageEvict", v24, v25, v29);
        return 0;
      }
      else
      {
        v26 = v8 + 40 * v10;
        bzero(*(void **)(v26 + 16), *(unsigned int *)(a1 + 92));
        v27 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)(v26 + 28) = 0;
        *(_DWORD *)(v26 + 32) = 0;
        *(_DWORD *)(v26 + 24) = v27;
        *(_QWORD *)v11 = a2;
      }
    }
  }
  return v11;
}

uint64_t cachePageReadFromDisk(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  uint64_t v11;
  size_t v12;
  int v13;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  uint64_t v27;
  int v28;
  char v30;
  unsigned int v31;
  size_t v32;

  v11 = *((unsigned int *)a2 + 6);
  v10 = *((_DWORD *)a2 + 7);
  if (v10 >= v11)
    v12 = v10 - v11;
  else
    v12 = 0;
  v13 = *((_DWORD *)a2 + 8);
  if (v10 <= v11 || v13 == 0)
  {
    v15 = 0;
  }
  else
  {
    v16 = malloc(v12);
    v15 = v16;
    if (!v16)
    {
      v24 = "aaMalloc";
      v25 = 184;
LABEL_33:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageReadFromDisk", v25, 146, 0, v24, a7, a8, v30);
      v27 = 0xFFFFFFFFLL;
      goto LABEL_34;
    }
    memcpy(v16, (const void *)(a2[2] + v11), v12);
  }
  v17 = *a2;
  if (a1[4] - *a2 >= *((unsigned int *)a1 + 23))
    v18 = *((unsigned int *)a1 + 23);
  else
    v18 = a1[4] - *a2;
  if (v18 < 1)
    goto LABEL_26;
  v19 = *a1;
  if (!*(_QWORD *)(*a1 + 32))
    goto LABEL_32;
  v31 = v10;
  v32 = v12;
  v20 = 0;
  v21 = a2[2];
  v22 = v18;
  while (1)
  {
    v23 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v19 + 32))(*(_QWORD *)v19, v21, v22, v17);
    if (v23 < 0)
      break;
    if (v23)
    {
      v21 += v23;
      v20 += v23;
      v17 += v23;
      v22 -= v23;
      if (v22)
        continue;
    }
    goto LABEL_24;
  }
  v20 = v23;
LABEL_24:
  v12 = v32;
  v10 = v31;
  if (v18 != v20)
  {
LABEL_32:
    v24 = "AAByteStreamPRead";
    v25 = 193;
    goto LABEL_33;
  }
  ++a1[7];
  v13 = *((_DWORD *)a2 + 8);
LABEL_26:
  if (v10 > v11 && v13 != 0)
    memcpy((void *)(a2[2] + *((unsigned int *)a2 + 6)), v15, v12);
  v27 = 0;
  v28 = *((_DWORD *)a1 + 23);
  *((_DWORD *)a2 + 6) = 0;
  *((_DWORD *)a2 + 7) = v28;
LABEL_34:
  free(v15);
  return v27;
}

uint64_t cachePageEvict(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v9;
  unsigned int v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  char v23;

  if (*((_DWORD *)a1 + 25))
    return 0xFFFFFFFFLL;
  if (!*(_DWORD *)(a2 + 32))
    return 0;
  v9 = *(unsigned int *)(a2 + 24);
  v10 = *(_DWORD *)(a2 + 28);
  if (v10 <= v9)
    return 0;
  v12 = *(_QWORD *)a2 + v9;
  v13 = v10 - v9;
  if (v13 >= a1[3] - v12)
    v14 = a1[3] - v12;
  else
    v14 = v13;
  if (v14 <= 0)
  {
    v21 = "bad page";
    v22 = 87;
LABEL_21:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cachePageEvict", v22, 146, 0, v21, a7, a8, v23);
    return 0xFFFFFFFFLL;
  }
  v15 = *a1;
  if (!*(_QWORD *)(*a1 + 40))
    goto LABEL_20;
  v16 = 0;
  v17 = *(_QWORD *)(a2 + 16) + v9;
  v18 = *(_QWORD *)a2 + v9;
  v19 = v14;
  while (1)
  {
    v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v15 + 40))(*(_QWORD *)v15, v17, v19, v18);
    if (v20 < 1)
      break;
    v17 += v20;
    v16 += v20;
    v18 += v20;
    v19 -= v20;
    if (!v19)
      goto LABEL_16;
  }
  v16 = v20;
LABEL_16:
  if (v14 != v16)
  {
LABEL_20:
    v21 = "aaByteStreamPWriteExpected";
    v22 = 90;
    goto LABEL_21;
  }
  ++a1[8];
  if (a1[4] < v14 + v12)
  {
    result = 0;
    a1[4] = v14 + v12;
    return result;
  }
  return 0;
}

uint64_t cacheFlush(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char v16;

  if (*(_DWORD *)(a1 + 100))
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 84))
  {
    v10 = 0;
    v11 = 0;
    while ((cachePageEvict((uint64_t *)a1, *(_QWORD *)(a1 + 72) + v10, a3, a4, a5, a6, a7, a8) & 0x80000000) == 0)
    {
      v14 = *(_QWORD *)(a1 + 72) + v10;
      bzero(*(void **)(v14 + 16), *(unsigned int *)(a1 + 92));
      *(_QWORD *)v14 = -1;
      v15 = *(_DWORD *)(a1 + 92);
      *(_DWORD *)(v14 + 28) = 0;
      *(_DWORD *)(v14 + 32) = 0;
      *(_DWORD *)(v14 + 24) = v15;
      ++v11;
      v10 += 40;
      if (v11 >= *(unsigned int *)(a1 + 84))
        return 0;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/AppleArchive/AACacheStream.c", (uint64_t)"cacheFlush", 115, 146, 0, "cachePageEvict", v12, v13, v16);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

size_t PCompressLZVNEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZVNDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, (compression_algorithm)0x900u);
  if (!result)
    return -1;
  return result;
}

uint64_t getOLDEntryType(unsigned __int16 a1)
{
  unint64_t v1;

  v1 = (((unint64_t)(a1 & 0xF000) - 4096) >> 12) - 3;
  if (v1 > 6)
    return 0;
  else
    return dword_20643F5B8[v1];
}

uint64_t getAAEntryType(__int16 a1)
{
  unsigned int v1;

  v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 14 > 2)
    return 0;
  else
    return dword_20643F588[v1 >> 12];
}

void setAAHeaderFromHeader_v10(_DWORD *a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;
  int v7;
  size_t v8;
  int v9;
  size_t v10;
  uint64_t v11;

  bzero(a1, 0x890uLL);
  v4 = *(unsigned __int16 *)(a2 + 22);
  v5 = *(_QWORD *)(a2 + 2);
  v6 = *a1 | 1;
  switch(*(_BYTE *)(a2 + 1))
  {
    case 1:
      v7 = 70;
      goto LABEL_7;
    case 2:
      v7 = 68;
      goto LABEL_7;
    case 3:
      v7 = 76;
      goto LABEL_7;
    case 4:
      v7 = 72;
LABEL_7:
      a1[1] = v7;
      break;
    default:
      v6 = *a1 & 0xFFFFFFFE;
      v7 = a1[1];
      break;
  }
  v8 = bswap64(v5);
  *a1 = v6 | 2;
  a1[2] = bswap32(*(unsigned __int16 *)(a2 + 24)) >> 16;
  *a1 = v6 | 6;
  a1[3] = bswap32(*(unsigned __int16 *)(a2 + 26)) >> 16;
  *a1 = v6 | 0x16;
  a1[5] = bswap32(*(unsigned __int16 *)(a2 + 28)) >> 16;
  *a1 = v6 | 0x1E;
  a1[4] = bswap32(*(_DWORD *)(a2 + 18));
  v9 = v6 | 0x11E;
  *a1 = v6 | 0x11E;
  *((_QWORD *)a1 + 6) = bswap64(*(_QWORD *)(a2 + 10));
  if (v7 == 70)
  {
    v9 = v6 | 0x31E;
    *a1 = v6 | 0x31E;
    *((_QWORD *)a1 + 8) = v8;
  }
  if (v4)
  {
    v10 = __rev16(v4);
    v9 |= 0x8000u;
    *a1 = v9;
    memcpy(a1 + 36, (const void *)(a2 + 30), v10);
    v11 = v10 + 30;
    if (!v5)
      return;
  }
  else
  {
    v11 = 30;
    if (!v5)
      return;
  }
  if ((v7 | 4) == 0x4C)
  {
    *a1 = v9 | 0x10000;
    memcpy(a1 + 292, (const void *)(a2 + v11), v8);
  }
}

void *setAAHeaderFromHeader_ODC(int *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  size_t v17;
  int v18;
  void *result;
  int v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  size_t v41;
  uint64_t v42;

  bzero(a1, 0x890uLL);
  v4 = 0;
  v5 = 0;
  do
  {
    v6 = *(_BYTE *)(a2 + 57 + v4++) & 7 | (8 * v5);
    v5 = v6;
  }
  while (v4 != 8);
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = *(_BYTE *)(a2 + 64 + v7++) & 7 | (8 * v8);
    v8 = v9;
  }
  while (v7 != 4);
  v10 = 0;
  v11 = 0;
  do
  {
    v12 = *(_BYTE *)(a2 + 68 + v10++) & 7 | (8 * v11);
    v11 = v12;
  }
  while (v10 != 8);
  v13 = 0;
  v14 = 0;
  v15 = (v9 << 24) & 0x1FF000000;
  do
  {
    v16 = *(_BYTE *)(a2 + 16 + v13++) & 7 | (8 * v14);
    v14 = v16;
  }
  while (v13 != 8);
  v17 = v6 & 0x3FFFF;
  v18 = *a1;
  result = (void *)getAAEntryType(v16);
  v20 = (int)result;
  v21 = 0;
  v22 = 0;
  a1[5] = v16 & 0xFFF;
  *a1 = v18 | 0x111;
  a1[1] = (int)result;
  do
  {
    v23 = *(_BYTE *)(a2 + 47 + v21++) & 7 | (8 * v22);
    v22 = v23;
  }
  while (v21 != 4);
  v24 = 0;
  v25 = 0;
  v26 = v23 << 24;
  do
  {
    v27 = *(_BYTE *)(a2 + 51 + v24++) & 7 | (8 * v25);
    v25 = v27;
  }
  while (v24 != 8);
  v28 = 0;
  v29 = 0;
  *((_QWORD *)a1 + 6) = v27 + (v26 & 0x1FF000000);
  *a1 = v18 | 0x113;
  do
  {
    v30 = *(_BYTE *)(a2 + 22 + v28++) & 7 | (8 * v29);
    v29 = v30;
  }
  while (v28 != 8);
  v31 = 0;
  v32 = 0;
  a1[2] = v30 & 0x3FFFF;
  *a1 = v18 | 0x117;
  do
  {
    v33 = *(_BYTE *)(a2 + 28 + v31++) & 7 | (8 * v32);
    v32 = v33;
  }
  while (v31 != 8);
  v34 = 0;
  v35 = 0;
  a1[3] = v33 & 0x3FFFF;
  *a1 = v18 | 0x157;
  do
  {
    v36 = *(_BYTE *)(a2 + 10 + v34++) & 7 | (8 * v35);
    v35 = v36;
  }
  while (v34 != 8);
  v37 = 0;
  v38 = 0;
  *((_QWORD *)a1 + 4) = v36 & 0x3FFFF;
  v39 = v18 | 0x177;
  *a1 = v18 | 0x177;
  do
  {
    v40 = *(_BYTE *)(a2 + 40 + v37++) & 7 | (8 * v38);
    v38 = v40;
  }
  while (v37 != 8);
  v41 = v12 + v15;
  a1[6] = v40 & 0x3FFFF;
  if ((_DWORD)result == 70)
  {
    v39 = v18 | 0x377;
    *a1 = v18 | 0x377;
    *((_QWORD *)a1 + 8) = v41;
  }
  if (v17)
  {
    v39 |= 0x8000u;
    *a1 = v39;
    result = memcpy(a1 + 36, (const void *)(a2 + 76), v17);
    v42 = v17 + 76;
    if (!v41)
      return result;
  }
  else
  {
    v42 = 76;
    if (!v41)
      return result;
  }
  if ((v20 | 4) == 0x4C)
  {
    *a1 = v39 | 0x10000;
    return memcpy(a1 + 292, (const void *)(a2 + v42), v41);
  }
  return result;
}

void *setAAHeaderFromHeader_NEWC(int *a1, uint64_t a2)
{
  uint64_t v4;
  size_t v5;
  int v6;
  char v7;
  uint64_t v8;
  size_t v9;
  int v10;
  char v11;
  uint64_t v12;
  int v13;
  int v14;
  char v15;
  int v16;
  void *result;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  char v22;
  uint64_t v23;
  int v24;
  int v25;
  char v26;
  uint64_t v27;
  int v28;
  int v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  char v34;
  uint64_t v35;
  int v36;
  int v37;
  char v38;
  uint64_t v39;
  int v40;
  int v41;
  char v42;
  int v43;
  uint64_t v44;

  bzero(a1, 0x890uLL);
  v4 = 0;
  v5 = 0;
  do
  {
    v6 = *(char *)(a2 + 94 + v4);
    v5 *= 16;
    v7 = v6 - 48;
    if ((v6 - 48) <= 0x36)
    {
      if (((1 << v7) & 0x3FF) != 0)
      {
        v5 = v5 + *(char *)(a2 + 94 + v4) - 48;
      }
      else if (((1 << v7) & 0x7E0000) != 0)
      {
        v5 = v5 + *(char *)(a2 + 94 + v4) - 55;
      }
      else if (((1 << v7) & 0x7E000000000000) != 0)
      {
        v5 = v5 + *(char *)(a2 + 94 + v4) - 87;
      }
    }
    ++v4;
  }
  while (v4 != 8);
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = *(char *)(a2 + 54 + v8);
    v9 *= 16;
    v11 = v10 - 48;
    if ((v10 - 48) <= 0x36)
    {
      if (((1 << v11) & 0x3FF) != 0)
      {
        v9 = v9 + *(char *)(a2 + 54 + v8) - 48;
      }
      else if (((1 << v11) & 0x7E0000) != 0)
      {
        v9 = v9 + *(char *)(a2 + 54 + v8) - 55;
      }
      else if (((1 << v11) & 0x7E000000000000) != 0)
      {
        v9 = v9 + *(char *)(a2 + 54 + v8) - 87;
      }
    }
    ++v8;
  }
  while (v8 != 8);
  v12 = 0;
  v13 = 0;
  do
  {
    v14 = *(char *)(a2 + 14 + v12);
    v13 *= 16;
    v15 = v14 - 48;
    if ((v14 - 48) <= 0x36)
    {
      if (((1 << v15) & 0x3FF) != 0)
      {
        v13 = v13 + v14 - 48;
      }
      else if (((1 << v15) & 0x7E0000) != 0)
      {
        v13 = v13 + v14 - 55;
      }
      else if (((1 << v15) & 0x7E000000000000) != 0)
      {
        v13 = v13 + v14 - 87;
      }
    }
    ++v12;
  }
  while (v12 != 8);
  v16 = *a1;
  result = (void *)getAAEntryType(v13);
  v18 = (int)result;
  v19 = 0;
  v20 = 0;
  a1[5] = v13 & 0xFFF;
  *a1 = v16 | 0x111;
  a1[1] = (int)result;
  do
  {
    v21 = *(char *)(a2 + 46 + v19);
    v20 *= 16;
    v22 = v21 - 48;
    if ((v21 - 48) <= 0x36)
    {
      if (((1 << v22) & 0x3FF) != 0)
      {
        v20 = v20 + *(char *)(a2 + 46 + v19) - 48;
      }
      else if (((1 << v22) & 0x7E0000) != 0)
      {
        v20 = v20 + *(char *)(a2 + 46 + v19) - 55;
      }
      else if (((1 << v22) & 0x7E000000000000) != 0)
      {
        v20 = v20 + *(char *)(a2 + 46 + v19) - 87;
      }
    }
    ++v19;
  }
  while (v19 != 8);
  v23 = 0;
  v24 = 0;
  *((_QWORD *)a1 + 6) = v20;
  *a1 = v16 | 0x113;
  do
  {
    v25 = *(char *)(a2 + 22 + v23);
    v24 *= 16;
    v26 = v25 - 48;
    if ((v25 - 48) <= 0x36)
    {
      if (((1 << v26) & 0x3FF) != 0)
      {
        v24 = v24 + v25 - 48;
      }
      else if (((1 << v26) & 0x7E0000) != 0)
      {
        v24 = v24 + v25 - 55;
      }
      else if (((1 << v26) & 0x7E000000000000) != 0)
      {
        v24 = v24 + v25 - 87;
      }
    }
    ++v23;
  }
  while (v23 != 8);
  v27 = 0;
  v28 = 0;
  a1[2] = v24;
  *a1 = v16 | 0x117;
  do
  {
    v29 = *(char *)(a2 + 30 + v27);
    v28 *= 16;
    v30 = v29 - 48;
    if ((v29 - 48) <= 0x36)
    {
      if (((1 << v30) & 0x3FF) != 0)
      {
        v28 = v28 + v29 - 48;
      }
      else if (((1 << v30) & 0x7E0000) != 0)
      {
        v28 = v28 + v29 - 55;
      }
      else if (((1 << v30) & 0x7E000000000000) != 0)
      {
        v28 = v28 + v29 - 87;
      }
    }
    ++v27;
  }
  while (v27 != 8);
  v31 = 0;
  v32 = 0;
  a1[3] = v28;
  *a1 = v16 | 0x157;
  do
  {
    v33 = *(char *)(a2 + 6 + v31);
    v32 *= 16;
    v34 = v33 - 48;
    if ((v33 - 48) <= 0x36)
    {
      if (((1 << v34) & 0x3FF) != 0)
      {
        v32 = v32 + *(char *)(a2 + 6 + v31) - 48;
      }
      else if (((1 << v34) & 0x7E0000) != 0)
      {
        v32 = v32 + *(char *)(a2 + 6 + v31) - 55;
      }
      else if (((1 << v34) & 0x7E000000000000) != 0)
      {
        v32 = v32 + *(char *)(a2 + 6 + v31) - 87;
      }
    }
    ++v31;
  }
  while (v31 != 8);
  v35 = 0;
  v36 = 0;
  *((_QWORD *)a1 + 4) = v32;
  do
  {
    v37 = *(char *)(a2 + 78 + v35);
    v36 *= 16;
    v38 = v37 - 48;
    if ((v37 - 48) <= 0x36)
    {
      if (((1 << v38) & 0x3FF) != 0)
      {
        v36 = v36 + v37 - 48;
      }
      else if (((1 << v38) & 0x7E0000) != 0)
      {
        v36 = v36 + v37 - 55;
      }
      else if (((1 << v38) & 0x7E000000000000) != 0)
      {
        v36 = v36 + v37 - 87;
      }
    }
    ++v35;
  }
  while (v35 != 8);
  v39 = 0;
  v40 = 0;
  do
  {
    v41 = *(char *)(a2 + 86 + v39);
    v40 *= 16;
    v42 = v41 - 48;
    if ((v41 - 48) <= 0x36)
    {
      if (((1 << v42) & 0x3FF) != 0)
      {
        v40 = v40 + v41 - 48;
      }
      else if (((1 << v42) & 0x7E0000) != 0)
      {
        v40 = v40 + v41 - 55;
      }
      else if (((1 << v42) & 0x7E000000000000) != 0)
      {
        v40 = v40 + v41 - 87;
      }
    }
    ++v39;
  }
  while (v39 != 8);
  v43 = v16 | 0x177;
  *a1 = v16 | 0x177;
  a1[6] = v40 + (v36 << 24);
  if ((_DWORD)result == 70)
  {
    v43 = v16 | 0x377;
    *a1 = v16 | 0x377;
    *((_QWORD *)a1 + 8) = v9;
  }
  if (v5)
  {
    v43 |= 0x8000u;
    *a1 = v43;
    result = memcpy(a1 + 36, (const void *)(a2 + 110), v5);
    v44 = v5 + 110;
    if (!v9)
      return result;
  }
  else
  {
    v44 = 110;
    if (!v9)
      return result;
  }
  if ((v18 | 4) == 0x4C)
  {
    *a1 = v43 | 0x10000;
    return memcpy(a1 + 292, (const void *)(a2 + v44), v9);
  }
  return result;
}

uint64_t setHeaderFromValues_v10(uint64_t result, char a2, unint64_t a3, unint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned __int16 a9)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 22) = 0;
  *(_BYTE *)result = 16;
  *(_BYTE *)(result + 1) = a2;
  *(_QWORD *)(result + 2) = bswap64(a3);
  *(_QWORD *)(result + 10) = bswap64(a4);
  *(_DWORD *)(result + 18) = bswap32(a5);
  *(_WORD *)(result + 22) = __rev16(a6);
  *(_WORD *)(result + 24) = __rev16(a7);
  *(_WORD *)(result + 26) = __rev16(a8);
  *(_WORD *)(result + 28) = __rev16(a9);
  return result;
}

uint64_t yaa_parseFields(const char *a1, _DWORD *a2, _WORD *a3)
{
  size_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;

  v6 = strlen(a1);
  if (v6)
  {
    v7 = v6;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = MEMORY[0x24BDAC740];
    while (1)
    {
      v12 = *(_DWORD *)&a1[v8] & 0xDFDFDF;
      if (v12 <= 0x4B4E4B)
      {
        if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x444946)
        {
          if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x464158)
          {
            switch(v12)
            {
              case 0x464159u:
                v9 |= 4u;
                goto LABEL_70;
              case 0x474C46u:
                v10 |= 8u;
                goto LABEL_70;
              case 0x4B4459u:
                v9 |= 0x10u;
                goto LABEL_70;
            }
          }
          else
          {
            switch(v12)
            {
              case 0x444947u:
                v10 |= 4u;
                goto LABEL_70;
              case 0x444955u:
                v10 |= 2u;
                goto LABEL_70;
              case 0x444F4Du:
                v10 |= 0x10u;
                goto LABEL_70;
            }
          }
        }
        else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x124857)
        {
          switch(v12)
          {
            case 0x124858u:
              v9 |= 0x40u;
              goto LABEL_70;
            case 0x414459u:
              v9 |= 8u;
              goto LABEL_70;
            case 0x434559u:
              v9 |= 0x100u;
              goto LABEL_70;
          }
        }
        else
        {
          switch(v12)
          {
            case 0x114853u:
              v10 |= 0x2000u;
              goto LABEL_70;
            case 0x114858u:
              v9 |= 0x20u;
              goto LABEL_70;
            case 0x124853u:
              v10 |= 0x4000u;
              goto LABEL_70;
          }
        }
      }
      else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) <= 0x544143)
      {
        if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x505841)
        {
          switch(v12)
          {
            case 0x505842u:
              v9 |= 0x80u;
              goto LABEL_70;
            case 0x505954u:
              v10 |= 1u;
              goto LABEL_70;
            case 0x534B43u:
              v10 |= 0x1000u;
              goto LABEL_70;
          }
        }
        else
        {
          switch(v12)
          {
            case 0x4B4E4Cu:
              v10 |= 0x10000u;
              goto LABEL_70;
            case 0x4C4341u:
              v10 |= 0x800u;
              goto LABEL_70;
            case 0x4D544Du:
              v10 |= 0x100u;
              goto LABEL_70;
          }
        }
      }
      else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) <= 0x564543)
      {
        switch(v12)
        {
          case 0x544144u:
            v10 |= 0x200u;
            goto LABEL_70;
          case 0x544150u:
            v10 |= 0x8000u;
            goto LABEL_70;
          case 0x544158u:
            v10 |= 0x400u;
            goto LABEL_70;
        }
      }
      else if ((*(_DWORD *)&a1[v8] & 0xDFDFDFu) > 0x5A4952)
      {
        if (v12 == 5917011)
        {
          v10 |= 0x80u;
          goto LABEL_70;
        }
        if (v12 == 5920068)
        {
          v9 |= 1u;
          goto LABEL_70;
        }
      }
      else
      {
        if (v12 == 5653828)
        {
          v10 |= 0x20u;
          goto LABEL_70;
        }
        if (v12 == 5784649)
        {
          v9 |= 2u;
          goto LABEL_70;
        }
      }
      if (v8 + 3 < v7)
      {
        v13 = 3;
        do
        {
          v14 = a1[v8 + v13];
          if ((v14 & 0x80000000) != 0)
          {
            if (!__maskrune(v14, 0x500uLL))
              goto LABEL_71;
          }
          else if ((*(_DWORD *)(v11 + 4 * v14 + 60) & 0x500) == 0)
          {
            goto LABEL_71;
          }
          ++v13;
        }
        while (v7 - v8 != v13);
        v13 = v7 - v8;
        goto LABEL_71;
      }
LABEL_70:
      v13 = 3;
LABEL_71:
      v8 += v13;
      v15 = a1[v8];
      if (v15 == 32 || v15 == 44)
      {
        ++v8;
      }
      else if (!a1[v8])
      {
        goto LABEL_77;
      }
      if (v8 >= v7)
      {
LABEL_77:
        if (a2)
          goto LABEL_78;
        goto LABEL_79;
      }
    }
  }
  v10 = 0;
  LOWORD(v9) = 0;
  if (a2)
LABEL_78:
    *a2 = v10;
LABEL_79:
  if (a3)
  {
    *a3 = v9;
    a3[1] = 0;
  }
  return 0;
}

uint64_t yaa_serializeFields(_BYTE *a1, unint64_t a2, int a3, __int16 a4)
{
  BOOL v4;
  int v5;
  uint64_t v6;

  if ((a3 & 1) == 0)
  {
    v5 = 0;
    if ((a3 & 0x8000) == 0)
      goto LABEL_5;
LABEL_14:
    if ((a3 & 1) != 0 && !a2)
      return 0xFFFFFFFFLL;
    if ((a3 & 1) != 0)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 84;
    *(_WORD *)a1 = 16720;
    a1 += 3;
    v5 = 1;
    if ((a3 & 0x10000) == 0)
      goto LABEL_21;
    goto LABEL_6;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 80;
  *(_WORD *)a1 = 22868;
  a1 += 3;
  v5 = 1;
  if ((a3 & 0x8000) != 0)
    goto LABEL_14;
LABEL_5:
  if ((a3 & 0x10000) == 0)
    goto LABEL_21;
LABEL_6:
  if (!a2 && v5)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 75;
  *(_WORD *)a1 = 20044;
  a1 += 3;
  v5 = 1;
LABEL_21:
  if ((a3 & 0x20) != 0)
  {
    if (!a2 && v5)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 86;
    *(_WORD *)a1 = 17732;
    a1 += 3;
    v5 = 1;
    if ((a3 & 2) == 0)
      goto LABEL_37;
  }
  else if ((a3 & 2) == 0)
  {
    goto LABEL_37;
  }
  if (!a2 && v5)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 68;
  *(_WORD *)a1 = 18773;
  a1 += 3;
  v5 = 1;
LABEL_37:
  if ((a3 & 4) != 0)
  {
    if (!a2 && v5)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 68;
    *(_WORD *)a1 = 18759;
    a1 += 3;
    v5 = 1;
    if ((a3 & 0x10) == 0)
    {
LABEL_39:
      if ((a3 & 8) == 0)
        goto LABEL_40;
LABEL_62:
      if (v5 && !a2)
        return 0xFFFFFFFFLL;
      if (v5)
      {
        *a1++ = 44;
        --a2;
      }
      v4 = a2 >= 3;
      a2 -= 3;
      if (!v4)
        return 0xFFFFFFFFLL;
      a1[2] = 71;
      *(_WORD *)a1 = 19526;
      a1 += 3;
      v5 = 1;
      if ((a3 & 0x100) == 0)
        goto LABEL_69;
      goto LABEL_41;
    }
  }
  else if ((a3 & 0x10) == 0)
  {
    goto LABEL_39;
  }
  if (v5 && !a2)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 68;
  *(_WORD *)a1 = 20301;
  a1 += 3;
  v5 = 1;
  if ((a3 & 8) != 0)
    goto LABEL_62;
LABEL_40:
  if ((a3 & 0x100) == 0)
    goto LABEL_69;
LABEL_41:
  if (v5 && !a2)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 77;
  *(_WORD *)a1 = 21581;
  a1 += 3;
  v5 = 1;
LABEL_69:
  if ((a3 & 0x200) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 84;
    *(_WORD *)a1 = 16708;
    a1 += 3;
    v5 = 1;
  }
  if ((a3 & 0x1000) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 83;
    *(_WORD *)a1 = 19267;
    a1 += 3;
    v5 = 1;
  }
  if ((a3 & 0x2000) == 0)
  {
    if ((a3 & 0x4000) == 0)
      goto LABEL_87;
LABEL_102:
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 50;
    *(_WORD *)a1 = 18515;
    a1 += 3;
    v5 = 1;
    if ((a3 & 0x400) == 0)
      goto LABEL_109;
    goto LABEL_88;
  }
  if (v5 && !a2)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 49;
  *(_WORD *)a1 = 18515;
  a1 += 3;
  v5 = 1;
  if ((a3 & 0x4000) != 0)
    goto LABEL_102;
LABEL_87:
  if ((a3 & 0x400) == 0)
    goto LABEL_109;
LABEL_88:
  if (v5 && !a2)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 84;
  *(_WORD *)a1 = 16728;
  a1 += 3;
  v5 = 1;
LABEL_109:
  if ((a3 & 0x800) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 76;
    *(_WORD *)a1 = 17217;
    a1 += 3;
    v5 = 1;
  }
  if ((a3 & 0x80) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 90;
    *(_WORD *)a1 = 18771;
    a1 += 3;
    v5 = 1;
  }
  if ((a4 & 0x80) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 80;
    *(_WORD *)a1 = 22594;
    a1 += 3;
    v5 = 1;
  }
  if ((a4 & 1) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 90;
    *(_WORD *)a1 = 21828;
    a1 += 3;
    v5 = 1;
  }
  if ((a4 & 2) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 88;
    *(_WORD *)a1 = 17481;
    a1 += 3;
    v5 = 1;
  }
  if ((a4 & 0x20) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 49;
    *(_WORD *)a1 = 18520;
    a1 += 3;
    v5 = 1;
    if ((a4 & 0x40) == 0)
      goto LABEL_165;
  }
  else if ((a4 & 0x40) == 0)
  {
    goto LABEL_165;
  }
  if (v5 && !a2)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 50;
  *(_WORD *)a1 = 18520;
  a1 += 3;
  v5 = 1;
LABEL_165:
  if ((a4 & 4) != 0)
  {
    if (v5 && !a2)
      return 0xFFFFFFFFLL;
    if (v5)
    {
      *a1++ = 44;
      --a2;
    }
    v4 = a2 >= 3;
    a2 -= 3;
    if (!v4)
      return 0xFFFFFFFFLL;
    a1[2] = 70;
    *(_WORD *)a1 = 16729;
    a1 += 3;
    v5 = 1;
    if ((a4 & 8) == 0)
    {
LABEL_167:
      if ((a4 & 0x10) == 0)
        goto LABEL_168;
LABEL_190:
      if (v5 && !a2)
        return 0xFFFFFFFFLL;
      if (v5)
      {
        *a1++ = 44;
        --a2;
      }
      v4 = a2 >= 3;
      a2 -= 3;
      if (!v4)
        return 0xFFFFFFFFLL;
      a1[2] = 75;
      *(_WORD *)a1 = 17497;
      a1 += 3;
      v5 = 1;
      if ((a4 & 0x100) == 0)
        goto LABEL_197;
      goto LABEL_169;
    }
  }
  else if ((a4 & 8) == 0)
  {
    goto LABEL_167;
  }
  if (v5 && !a2)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 65;
  *(_WORD *)a1 = 17497;
  a1 += 3;
  v5 = 1;
  if ((a4 & 0x10) != 0)
    goto LABEL_190;
LABEL_168:
  if ((a4 & 0x100) == 0)
    goto LABEL_197;
LABEL_169:
  if (v5 && !a2)
    return 0xFFFFFFFFLL;
  if (v5)
  {
    *a1++ = 44;
    --a2;
  }
  v4 = a2 >= 3;
  a2 -= 3;
  if (!v4)
    return 0xFFFFFFFFLL;
  a1[2] = 67;
  *(_WORD *)a1 = 17753;
  a1 += 3;
LABEL_197:
  if (!a2)
    return 0xFFFFFFFFLL;
  v6 = 0;
  *a1 = 0;
  return v6;
}

uint64_t ECCGenerateThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  const char *v10;
  __int16 v11;
  unint64_t i;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  int v17;
  ssize_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v23;

  if ((*(_DWORD *)(a1 + 40) & 0x80000000) != 0)
  {
    v9 = 0;
  }
  else
  {
    v9 = malloc(*(unsigned int *)(a1 + 28));
    if (!v9)
    {
      v10 = "creating workBuffer";
      v11 = 66;
LABEL_25:
      v21 = 0;
LABEL_26:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ECCGenerateThreadProc", v11, 64, v21, v10, a7, a8, v23);
      goto LABEL_27;
    }
  }
  for (i = *(_QWORD *)(a1 + 8); i < *(_QWORD *)(a1 + 16); ++i)
  {
    v13 = *(unsigned int *)(a1 + 28);
    v14 = i * v13;
    v15 = *(_QWORD *)(a1 + 64);
    if (v15 < i * v13)
    {
      v10 = "Invalid block index";
      v11 = 74;
      goto LABEL_25;
    }
    if (v14 + v13 <= v15)
      v16 = v13;
    else
      v16 = (v15 - v14);
    v17 = *(_DWORD *)(a1 + 40);
    if (v17 < 0)
    {
      v19 = *(_QWORD *)(a1 + 48) + v14;
    }
    else
    {
      v18 = pread(v17, v9, v16, *(_QWORD *)(a1 + 56) + v14);
      if (v18 < 0)
      {
        v21 = *__error();
        v10 = "reading data segment";
        v11 = 82;
        goto LABEL_26;
      }
      v19 = (uint64_t)v9;
      if ((_DWORD)v16 != (_DWORD)v18)
      {
        LOBYTE(v23) = v18;
        v10 = "Truncated read n=%zd pos=%llu read=%llu %s";
        v11 = 83;
        goto LABEL_25;
      }
    }
    v20 = *(unsigned int *)(a1 + 32);
    if (i * v20 + v20 > *(_QWORD *)(a1 + 80))
    {
      v10 = "Parity buffer out of range";
      v11 = 94;
      goto LABEL_25;
    }
    if (*(_DWORD *)(a1 + 24) != 1)
    {
      v23 = *(_DWORD *)(a1 + 24);
      v10 = "invalid variant %u";
      v11 = 101;
      goto LABEL_25;
    }
    if (ECC65537GetParity(v16, v19, *(_QWORD *)(a1 + 72) + i * v20))
    {
      LOBYTE(v23) = i;
      v10 = "generating parity block %llu\n";
      v11 = 99;
      goto LABEL_25;
    }
  }
LABEL_27:
  free(v9);
  return 0;
}

uint64_t ECCFixThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  const char *v10;
  __int16 v11;
  unint64_t i;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  size_t v16;
  int v17;
  ssize_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int8x16_t v22;
  int v23;
  ssize_t v24;
  int v25;
  int v27;
  uint64_t v28;

  if ((*(_DWORD *)(a1 + 40) & 0x80000000) != 0)
  {
    v9 = 0;
  }
  else
  {
    v9 = malloc(*(unsigned int *)(a1 + 28));
    if (!v9)
    {
      v10 = "creating workBuffer";
      v11 = 157;
LABEL_31:
      v25 = 0;
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ECCFixThreadProc", v11, 64, v25, v10, a7, a8, v27);
      goto LABEL_33;
    }
  }
  for (i = *(_QWORD *)(a1 + 8); i < *(_QWORD *)(a1 + 16); ++i)
  {
    v13 = *(unsigned int *)(a1 + 28);
    v14 = i * v13;
    v15 = *(_QWORD *)(a1 + 64);
    if (v15 < i * v13)
    {
      v10 = "Invalid block index";
      v11 = 166;
      goto LABEL_31;
    }
    if (v14 + v13 <= v15)
      v16 = v13;
    else
      v16 = (v15 - v14);
    v17 = *(_DWORD *)(a1 + 40);
    if (v17 < 0)
    {
      v19 = *(_QWORD *)(a1 + 48) + v14;
    }
    else
    {
      v18 = pread(v17, v9, v16, *(_QWORD *)(a1 + 56) + v14);
      if (v18 < 0)
      {
        v25 = *__error();
        v10 = "reading data segment";
        v11 = 174;
        goto LABEL_32;
      }
      v19 = (uint64_t)v9;
      if ((_DWORD)v16 != (_DWORD)v18)
      {
        LOBYTE(v27) = v18;
        v10 = "Truncated read n=%zd pos=%llu read=%u fd=%d";
        v11 = 175;
        goto LABEL_31;
      }
    }
    v20 = *(unsigned int *)(a1 + 32);
    if (i * v20 + v20 > *(_QWORD *)(a1 + 80))
    {
      v10 = "Parity buffer out of range";
      v11 = 187;
      goto LABEL_31;
    }
    if (*(_DWORD *)(a1 + 24) != 1)
    {
      v27 = *(_DWORD *)(a1 + 24);
      v10 = "invalid variant %u";
      v11 = 205;
      goto LABEL_31;
    }
    v28 = 0;
    v21 = ECC65537CheckAndFix(v16, v19, (uint16x8_t *)(*(_QWORD *)(a1 + 72) + i * v20), &v28);
    if (v21 < 0)
    {
      ++*(_QWORD *)(a1 + 88);
    }
    else if (v21)
    {
      ++*(_QWORD *)(a1 + 96);
      v22.i64[0] = v28;
      v22.i64[1] = HIDWORD(v28);
      *(int64x2_t *)(a1 + 104) = vaddq_s64(*(int64x2_t *)(a1 + 104), (int64x2_t)vextq_s8(v22, v22, 8uLL));
      v23 = *(_DWORD *)(a1 + 40);
      if ((v23 & 0x80000000) == 0)
      {
        v24 = pwrite(v23, v9, v16, *(_QWORD *)(a1 + 56) + v14);
        if (v24 < 0)
        {
          v25 = *__error();
          v10 = "writing data segment";
          v11 = 211;
          goto LABEL_32;
        }
        if ((_DWORD)v16 != (_DWORD)v24)
        {
          LOBYTE(v27) = v24;
          v10 = "Truncated write n=%zd pos=%llu read=%u fd=%d";
          v11 = 212;
          goto LABEL_31;
        }
      }
    }
  }
LABEL_33:
  free(v9);
  return 0;
}

unint64_t ParallelArchiveECCGenerateCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  unsigned int DefaultNThreads;
  unsigned int v15;
  unint64_t v16;
  int v17;
  double RealTime;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  double v35;
  unint64_t v37;
  const char *v38;
  __int16 v39;
  uint64_t v40;
  size_t v41;
  unint64_t v42;
  FILE **v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  _opaque_pthread_t *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  BOOL v59;
  __int128 v60;
  int v61;
  int v62;
  int *v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  char v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  off_t v73;
  unint64_t v74;
  _OWORD v75[16];
  __int128 v76;
  int v77;
  __int128 v78;
  int v79;
  uint64_t v80;

  v80 = *MEMORY[0x24BDAC8D0];
  DefaultNThreads = a7[1];
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v15 = a7[4];
  if (v15)
    v16 = v15;
  else
    v16 = 0x4000;
  v17 = *a7;
  v78 = 0uLL;
  v79 = 0;
  v76 = 0uLL;
  v77 = 0;
  RealTime = getRealTime();
  enterThreadErrorContext(v19, v20, v21, v22, v23, v24, v25, v26, v66);
  if (a7[3] != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 262, 64, 0, "Invalid ECC variant: %u", v27, v28, a7[3]);
    goto LABEL_10;
  }
  if (v16 >= 0x1FFE1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 258, 64, 0, "Invalid blockSize: %u", v27, v28, v16);
LABEL_10:
    v29 = 0;
LABEL_11:
    v30 = 0;
LABEL_12:
    v31 = 1;
    goto LABEL_13;
  }
  v72 = a2;
  v73 = a3;
  v37 = (a4 + v16 - 1) / v16;
  v29 = 34 * v37 + 48;
  if (!a5 && !a6)
  {
    v31 = 0;
    v30 = 0;
    goto LABEL_13;
  }
  if (v29 > a6)
  {
    v67 = 34 * v37 + 48;
    v38 = "Output buffer too small, %zu B required, %zu B provided";
    v39 = 273;
LABEL_31:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", v39, 64, 0, v38, v27, v28, v67);
    goto LABEL_11;
  }
  if (v37 >= DefaultNThreads)
    LODWORD(v40) = DefaultNThreads;
  else
    LODWORD(v40) = (a4 + v16 - 1) / v16;
  if (v40 <= 1)
    v40 = 1;
  else
    v40 = v40;
  v74 = v40;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(v72, a4, (unsigned __int8 *)&v78) & 0x80000000) != 0)
    {
      v38 = "computing buffer digest";
      v39 = 287;
      goto LABEL_31;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, v73, a4, (uint64_t)&v78) & 0x80000000) != 0)
  {
    v38 = "computing file digest";
    v39 = 283;
    goto LABEL_31;
  }
  v41 = v74;
  v42 = (v37 + v74 - 1) / v74;
  v69 = v17;
  if (v17 >= 1)
  {
    memset(v75, 0, sizeof(v75));
    sha1ToString((uint64_t)v75, (uint64_t)&v78);
    v43 = (FILE **)MEMORY[0x24BDAC8D8];
    fwrite("ParallelArchiveECCGenerateCommon:\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    fprintf(*v43, "  Input data SHA1: %s\n", (const char *)v75);
    fwrite("  ECC variant: ", 0xFuLL, 1uLL, *v43);
    if (a7[3] == 1)
      fwrite("RS65537\n", 8uLL, 1uLL, *v43);
    fprintf(*v43, "%12llu data size\n", a4);
    fprintf(*v43, "%12u block size\n", v16);
    fprintf(*v43, "%12u ECC parity size per block\n", 34);
    fprintf(*v43, "%11.2f%% parity/data ratio\n", 3400.0 / (double)v16);
    fprintf(*v43, "%12zu block count\n", (a4 + v16 - 1) / v16);
    fprintf(*v43, "%12zu ECC buffer size\n", 34 * v37 + 48);
    fprintf(*v43, "%12u worker threads\n", v74);
    fprintf(*v43, "%12zu blocks per thread\n", v42);
    v41 = v74;
  }
  v30 = (char *)calloc(v41, 0x58uLL);
  if (!v30)
  {
    v63 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 313, 64, *v63, "malloc %u threads", v64, v65, v74);
    goto LABEL_12;
  }
  v44 = 0;
  v45 = a5;
  v46 = 0;
  v68 = v45;
  v71 = v45 + 48;
  v70 = 1;
  do
  {
    v47 = v42 * v46;
    if (v42 * v46 < v37)
    {
      v48 = v47 + v42;
      if (v47 + v42 >= v37)
        v48 = (a4 + v16 - 1) / v16;
      v49 = &v30[v44];
      *((_QWORD *)v49 + 1) = v47;
      *((_QWORD *)v49 + 2) = v48;
      *((_DWORD *)v49 + 7) = v16;
      *((_DWORD *)v49 + 10) = a1;
      *((_QWORD *)v49 + 6) = v72;
      *((_QWORD *)v49 + 7) = v73;
      *((_QWORD *)v49 + 8) = a4;
      *((_QWORD *)v49 + 9) = v71;
      *((_QWORD *)v49 + 10) = 34 * v37;
      *((_DWORD *)v49 + 6) = a7[3];
      *((_QWORD *)v49 + 4) = 34;
      if (createThread((pthread_t *)&v30[v44], (uint64_t)ECCGenerateThreadProc, (uint64_t)&v30[v44], 0))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 336, 64, 0, "createThread", v50, v51, v67);
        v70 = 0;
      }
    }
    ++v46;
    v44 += 88;
  }
  while (88 * v74 != v44);
  v52 = 0;
  v53 = v74;
  while (2)
  {
    v54 = 88 * v52;
    while (1)
    {
      v55 = *(_opaque_pthread_t **)&v30[v54];
      if (v55)
      {
        v56 = joinThread(v55);
        v53 = v74;
        if (v56)
          break;
      }
      ++v52;
      v54 += 88;
      if (v53 == v52)
      {
        v17 = v69;
        if (v70)
        {
          v31 = 0;
          v60 = v78;
          v76 = v78;
          v61 = v79;
          v77 = v79;
          v62 = a7[3];
          a5 = v68;
          *(_QWORD *)v68 = 0x3031304343455842;
          *(_QWORD *)(v68 + 8) = a4;
          *(_OWORD *)(v68 + 16) = v60;
          *(_DWORD *)(v68 + 32) = v61;
          *(_DWORD *)(v68 + 36) = v62;
          *(_DWORD *)(v68 + 40) = v16;
          *(_DWORD *)(v68 + 44) = 0;
        }
        else
        {
          v31 = 1;
          a5 = v68;
        }
        goto LABEL_13;
      }
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCGenerateCommon", 343, 64, 0, "joinThread", v57, v58, v67);
    v70 = 0;
    v31 = 1;
    v59 = v74 - 1 == v52++;
    v53 = v74;
    if (!v59)
      continue;
    break;
  }
  a5 = v68;
  v17 = v69;
LABEL_13:
  free(v30);
  v32 = leaveThreadErrorContext(0, 0, 0);
  if (v32 < 0)
    return v32;
  v33 = v17;
  if (v31)
    v34 = -1;
  else
    v34 = v32;
  if (a5 && v31 != 1 && v33 >= 1)
  {
    v35 = getRealTime();
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Total time %.2fs, %.2f MB/s\n", v35 - RealTime, (double)a4 * 0.000000953674316 / (v35 - RealTime));
    if ((v31 & 1) == 0)
      return v29;
    return v34;
  }
  if ((v31 & 1) != 0)
    return v34;
  return v29;
}

unint64_t ParallelArchiveECCGenerateFromFileSegment(int a1, off_t a2, unint64_t a3, uint64_t a4, unint64_t a5, int *a6)
{
  return ParallelArchiveECCGenerateCommon(a1, 0, a2, a3, a4, a5, a6);
}

uint64_t ParallelArchiveECCFixFileSegment(int a1, off_t a2, unint64_t a3, __int128 *a4, unint64_t a5, uint64_t a6)
{
  return ParallelArchiveECCFixCommon(a1, 0, a2, a3, a4, a5, a6);
}

unint64_t ParallelArchiveECCGenerateFromBuffer(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int *a5)
{
  return ParallelArchiveECCGenerateCommon(-1, a1, 0, a2, a3, a4, a5);
}

uint64_t ParallelArchiveECCFixBuffer(uint64_t a1, unint64_t a2, __int128 *a3, unint64_t a4, uint64_t a5)
{
  return ParallelArchiveECCFixCommon(-1, a1, 0, a2, a3, a4, a5);
}

uint64_t ParallelArchiveECCFixCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, __int128 *a5, unint64_t a6, uint64_t a7)
{
  unsigned int DefaultNThreads;
  double RealTime;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  __int128 v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t result;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  FILE **v45;
  unint64_t v46;
  const char *v47;
  double v48;
  unint64_t v49;
  unsigned int v50;
  size_t v51;
  const char *v52;
  __int16 v53;
  FILE **v54;
  void *v57;
  uint64_t v58;
  size_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  int Thread;
  uint64_t v65;
  uint64_t v66;
  int64x2_t v67;
  int64x2_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  int *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  const char *v77;
  __int16 v78;
  char v81;
  char v82;
  _OWORD *v83;
  uint64_t v84;
  int64x2_t v85;
  unint64_t v86;
  unint64_t v87;
  int64x2_t v88;
  unsigned int v89;
  unint64_t v90;
  int v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;

  v114 = *MEMORY[0x24BDAC8D0];
  DefaultNThreads = *(_DWORD *)(a7 + 4);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v91 = *(_DWORD *)a7;
  v111 = 0;
  v112 = 0;
  v113 = 0;
  v109 = 0u;
  v110 = 0u;
  v108 = 0u;
  RealTime = getRealTime();
  *(_QWORD *)(a7 + 16) = 0;
  *(_DWORD *)(a7 + 12) = 0;
  enterThreadErrorContext(v16, v17, v18, v19, v20, v21, v22, v23, v81);
  v90 = a4;
  if (a6 <= 0x2F)
  {
    v26 = "Truncated ECC buffer";
    v27 = 452;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v27, 64, 0, v26, v24, v25, v82);
LABEL_10:
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    goto LABEL_11;
  }
  v28 = a5[1];
  v108 = *a5;
  v109 = v28;
  v110 = a5[2];
  if ((_QWORD)v108 != 0x3031304343455842)
  {
    v26 = "Invalid ECC magic";
    v27 = 454;
    goto LABEL_9;
  }
  if (HIDWORD(v110))
  {
    v26 = "Invalid ECC header";
    v27 = 455;
    goto LABEL_9;
  }
  v89 = DWORD2(v110);
  if (!DWORD2(v110))
  {
    v26 = "Invalid ECC header";
    v27 = 456;
    goto LABEL_9;
  }
  if (*((_QWORD *)&v108 + 1) != a4)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 457, 64, 0, "Input buffer size mismatch: expected %llu B, got %llu B", v24, v25, SBYTE8(v108));
    goto LABEL_10;
  }
  v35 = DWORD1(v110);
  if (DWORD1(v110) != 1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 476, 64, 0, "Invalid ECC variant: %u", v24, v25, SBYTE4(v110));
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
LABEL_55:
    v34 = v89;
    goto LABEL_11;
  }
  if (DWORD2(v110) >= 0x1FFE1)
  {
    v34 = DWORD2(v110);
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 472, 64, 0, "Invalid blockSize: %u", v24, v25, SBYTE8(v110));
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v35 = 1;
    goto LABEL_11;
  }
  v49 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  v84 = 34 * v49;
  if (34 * v49 + 48 != a6)
  {
    v52 = "Invalid ECC buffer size";
    v53 = 481;
    goto LABEL_52;
  }
  v86 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  if (v49 >= DefaultNThreads)
    v50 = DefaultNThreads;
  else
    v50 = (a4 + DWORD2(v110) - 1) / DWORD2(v110);
  if (v50 <= 1)
    v51 = 1;
  else
    v51 = v50;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      v52 = "computing buffer digest";
      v53 = 495;
      goto LABEL_52;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v111) & 0x80000000) != 0)
  {
    v52 = "computing file digest";
    v53 = 491;
LABEL_52:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v53, 64, 0, v52, v24, v25, v82);
    v29 = 0;
    v30 = 0;
LABEL_53:
    v31 = 0;
    v32 = 0;
    v33 = 0;
LABEL_54:
    v35 = 1;
    goto LABEL_55;
  }
  v87 = (v86 + v51 - 1) / v51;
  if (v91 >= 1)
  {
    v106 = 0u;
    v107 = 0u;
    v104 = 0u;
    v105 = 0u;
    v102 = 0u;
    v103 = 0u;
    v100 = 0u;
    v101 = 0u;
    v98 = 0u;
    v99 = 0u;
    v96 = 0u;
    v97 = 0u;
    v94 = 0u;
    v95 = 0u;
    v92 = 0u;
    v93 = 0u;
    v54 = (FILE **)MEMORY[0x24BDAC8D8];
    fwrite("ParallelArchiveECCFixCommon:\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf(*v54, "  Input data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
    fprintf(*v54, "  Expected SHA1: %s\n", (const char *)&v92);
    fwrite("  ECC variant: ", 0xFuLL, 1uLL, *v54);
    fwrite("RS65537\n", 8uLL, 1uLL, *v54);
    fprintf(*v54, "%12llu data size\n", a4);
    fprintf(*v54, "%12u block size\n", v89);
    fprintf(*v54, "%12u ECC parity size per block\n", 34);
    fprintf(*v54, "%11.2f%% parity/data ratio\n", 3400.0 / (double)v89);
    fprintf(*v54, "%12zu block count\n", v86);
    fprintf(*v54, "%12zu ECC buffer size\n", a6);
    fprintf(*v54, "%12u worker threads\n", v51);
    fprintf(*v54, "%12zu blocks per thread\n", v87);
  }
  if (v111 == (_QWORD)v109 && v112 == *((_QWORD *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v29 = 1;
    goto LABEL_54;
  }
  v57 = calloc(v51, 0x78uLL);
  v30 = (unint64_t)v57;
  if (!v57)
  {
    v72 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 526, 64, *v72, "malloc %u threads", v73, v74, v51);
    v29 = 0;
    goto LABEL_53;
  }
  v58 = 0;
  v83 = a5 + 3;
  v59 = v51;
  v60 = (uint64_t)v57;
  v29 = 1;
  v61 = (v86 + v51 - 1) / v51;
  do
  {
    v62 = v61 * v58;
    if (v61 * v58 < v86)
    {
      v63 = v62 + v87;
      if (v62 + v87 >= v86)
        v63 = v86;
      *(_QWORD *)(v60 + 8) = v62;
      *(_QWORD *)(v60 + 16) = v63;
      *(_DWORD *)(v60 + 40) = a1;
      *(_QWORD *)(v60 + 48) = a2;
      *(_QWORD *)(v60 + 56) = a3;
      *(_QWORD *)(v60 + 64) = v90;
      *(_QWORD *)(v60 + 72) = v83;
      *(_QWORD *)(v60 + 80) = v84;
      *(_DWORD *)(v60 + 24) = 1;
      *(_DWORD *)(v60 + 28) = v89;
      *(_QWORD *)(v60 + 32) = 34;
      Thread = createThread((pthread_t *)v60, (uint64_t)ECCFixThreadProc, v60, 0);
      v61 = (v86 + v51 - 1) / v51;
      if (Thread)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 549, 64, 0, "createThread", v65, v66, v82);
        v61 = (v86 + v51 - 1) / v51;
        v29 = 0;
      }
    }
    ++v58;
    v60 += 120;
    --v59;
  }
  while (v59);
  v67 = 0uLL;
  v68 = 0uLL;
  do
  {
    if (*(_QWORD *)v30)
    {
      v85 = v68;
      v88 = v67;
      if (joinThread(*(_opaque_pthread_t **)v30))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", 556, 64, 0, "joinThread", v69, v70, v82);
        v29 = 0;
      }
      v68 = vaddq_s64(*(int64x2_t *)(v30 + 104), v85);
      v67 = vaddq_s64(*(int64x2_t *)(v30 + 88), v88);
    }
    v30 += 120;
    --v51;
  }
  while (v51);
  v32 = v67.u64[1];
  v33 = v67.i64[0];
  v30 = v68.u64[1];
  v71 = v68.i64[0];
  if (v67.i64[0])
    goto LABEL_81;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, v90, (unsigned __int8 *)&v111) & 0x80000000) != 0)
    {
      v77 = "computing buffer digest";
      v78 = 574;
      goto LABEL_102;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, v90, (uint64_t)&v111) & 0x80000000) != 0)
  {
    v77 = "computing file digest";
    v78 = 570;
LABEL_102:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCFixCommon", v78, 64, 0, v77, v75, v76, v82);
    v29 = 0;
    v33 = 0;
LABEL_81:
    v35 = 1;
    v34 = v89;
LABEL_82:
    v31 = v71;
    goto LABEL_11;
  }
  v34 = v89;
  if (v91 >= 1)
  {
    v106 = 0u;
    v107 = 0u;
    v104 = 0u;
    v105 = 0u;
    v102 = 0u;
    v103 = 0u;
    v100 = 0u;
    v101 = 0u;
    v98 = 0u;
    v99 = 0u;
    v96 = 0u;
    v97 = 0u;
    v94 = 0u;
    v95 = 0u;
    v92 = 0u;
    v93 = 0u;
    sha1ToString((uint64_t)&v92, (uint64_t)&v111);
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  Output data SHA1: %s\n", (const char *)&v92);
    sha1ToString((uint64_t)&v92, (uint64_t)&v109);
  }
  if (v111 == (_QWORD)v109 && v112 == *((_QWORD *)&v109 + 1) && v113 == (unint64_t)v110)
  {
    v33 = 0;
    v35 = 1;
    goto LABEL_82;
  }
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v35 = 1;
  v33 = v86;
LABEL_11:
  result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) != 0)
    return result;
  if (!v29)
    return 0xFFFFFFFFLL;
  v37 = 0x7FFF;
  if (v30 < 0x7FFF)
    v37 = v30;
  v38 = v37 << 8;
  v39 = 255;
  if (v32 < 0xFF)
    v39 = v32;
  v40 = v38 | v39;
  v41 = 255;
  if (v33 < 0xFF)
    v41 = v33;
  v42 = v38 | v41 | 0x800000;
  if (v33)
    v43 = v42;
  else
    v43 = v40;
  if (v91 <= 0)
  {
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v34;
    *(_DWORD *)(a7 + 20) = v43;
    if (v33)
      return 0xFFFFFFFFLL;
  }
  else
  {
    v44 = v34;
    v45 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12llu fixed blocks\n", v32);
    v46 = v31;
    fprintf(*v45, "%12llu fixed bytes\n", v31);
    fprintf(*v45, "%12llu fixed bits\n", v30);
    if (v33)
    {
      fprintf(*v45, "%12llu INVALID BLOCKS\n", v33);
      v47 = "FAIL";
    }
    else
    {
      v47 = "OK";
    }
    fprintf(*v45, "    0x%06x diagnostic code\n", v43);
    *(_DWORD *)(a7 + 12) = v35;
    *(_DWORD *)(a7 + 16) = v44;
    *(_DWORD *)(a7 + 20) = v43;
    v48 = getRealTime();
    fprintf(*v45, "Total time %.2fs, %.2f MB/s (%s)\n", v48 - RealTime, (double)v90 * 0.000000953674316 / (v48 - RealTime), v47);
    v31 = v46;
    if (v33)
      return 0xFFFFFFFFLL;
  }
  if (v31 >= 0x7FFFFFFF)
    return 0x7FFFFFFFLL;
  else
    return v31;
}

uint64_t ParallelArchiveECCVerifyBuffer(uint64_t a1, unint64_t a2, __int128 *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ParallelArchiveECCVerifyCommon(-1, a1, 0, a2, a3, a4, a7, a8);
}

uint64_t ParallelArchiveECCVerifyCommon(int a1, uint64_t a2, off_t a3, unint64_t a4, __int128 *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if (a6 <= 0x2F)
  {
    v8 = "Truncated ECC buffer";
    v9 = 390;
LABEL_7:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"ParallelArchiveECCVerifyCommon", v9, 64, 0, v8, a7, a8, v13);
    return 0xFFFFFFFFLL;
  }
  v13 = *a5;
  v14 = a5[1];
  v15 = a5[2];
  if (*(_QWORD *)a5 != 0x3031304343455842)
  {
    v8 = "Invalid ECC magic";
    v9 = 392;
    goto LABEL_7;
  }
  if (HIDWORD(v15))
  {
    v8 = "Invalid ECC header";
    v9 = 393;
    goto LABEL_7;
  }
  if (!DWORD2(v15))
  {
    v8 = "Invalid ECC header";
    v9 = 394;
    goto LABEL_7;
  }
  if (*((_QWORD *)&v13 + 1) != a4)
    return 0;
  if (a1 < 0)
  {
    if ((getBufferSHA1Digest(a2, a4, (unsigned __int8 *)&v16) & 0x80000000) != 0)
    {
      v8 = "computing buffer digest";
      v9 = 404;
      goto LABEL_7;
    }
  }
  else if ((getFileSegmentSHA1DigestFD(a1, a3, a4, (uint64_t)&v16) & 0x80000000) != 0)
  {
    v8 = "computing file digest";
    v9 = 400;
    goto LABEL_7;
  }
  return v16 == (_QWORD)v14 && v17 == *((_QWORD *)&v14 + 1) && v18 == (unint64_t)v15;
}

uint64_t ParallelArchiveECCVerifyFileSegment(int a1, off_t a2, unint64_t a3, __int128 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ParallelArchiveECCVerifyCommon(a1, 0, a2, a3, a4, a5, a7, a8);
}

_QWORD *OECCStreamCreate(int a1, unsigned int a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  __int16 v12;
  int v13;
  size_t v15;
  void *v16;
  char v17;

  v6 = calloc(1uLL, 0xB0uLL);
  v7 = v6;
  if (v6)
  {
    *(_DWORD *)v6 = a1;
    v6[4] = a3;
    *((_DWORD *)v6 + 10) = a2;
    v8 = malloc(a2);
    v7[8] = v8;
    if (v8)
    {
      if (a1 != 1)
      {
        v11 = "Invalid ECC algorithm";
        v12 = 857;
        goto LABEL_9;
      }
      if (a2 >= 0x1FFE1)
      {
        v11 = "Invalid ECC block size";
        v12 = 853;
LABEL_9:
        v13 = 0;
        goto LABEL_10;
      }
      *((_DWORD *)v7 + 6) = 34;
      v15 = 34 * ((a3 + (unint64_t)a2 - 1) / a2) + 48;
      v7[2] = v15;
      v16 = malloc(v15);
      v7[1] = v16;
      if (v16)
      {
        CC_SHA1_Deprecated_Init((CC_SHA1_CTX *)((char *)v7 + 76));
        v7[7] = 48;
        checkEOF((int *)v7);
        return v7;
      }
      v13 = *__error();
      v11 = "malloc";
      v12 = 862;
    }
    else
    {
      v13 = *__error();
      v11 = "malloc";
      v12 = 846;
    }
  }
  else
  {
    v13 = *__error();
    v11 = "malloc";
    v12 = 841;
  }
LABEL_10:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamCreate", v12, 64, v13, v11, v9, v10, v17);
  OECCStreamDestroy((void **)v7);
  return 0;
}

int *checkEOF(int *result)
{
  uint64_t v1;
  int v2;
  int v3;

  if (*((_QWORD *)result + 6) == *((_QWORD *)result + 4) && !result[43])
  {
    result[43] = 1;
    v1 = *((_QWORD *)result + 1);
    *(_QWORD *)v1 = 0x3031304343455842;
    v2 = *result;
    *(_QWORD *)(v1 + 8) = *((_QWORD *)result + 4);
    *(_DWORD *)(v1 + 44) = 0;
    v3 = result[10];
    *(_DWORD *)(v1 + 36) = v2;
    *(_DWORD *)(v1 + 40) = v3;
    return (int *)CC_SHA1_Deprecated_Final((unsigned __int8 *)(v1 + 16), (CC_SHA1_CTX *)(result + 19));
  }
  return result;
}

void OECCStreamDestroy(void **a1)
{
  if (a1)
  {
    free(a1[8]);
    free(a1[1]);
    free(a1);
  }
}

uint64_t OECCStreamGetDataPtr(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172))
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

uint64_t OECCStreamGetDataSize(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 172))
    return *(_QWORD *)(a1 + 16);
  else
    return 0;
}

uint64_t OECCStreamWrite(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  int v11;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unsigned int v19;
  unint64_t v20;
  size_t v21;
  unsigned int v22;
  size_t v23;
  uint64_t v24;
  char v26;

  v8 = *(_QWORD *)(a1 + 48);
  v9 = __CFADD__(v8, a3);
  v10 = v8 + a3;
  v11 = v9;
  if (v10 <= *(_QWORD *)(a1 + 32) && v11 == 0)
  {
    v16 = a3;
    v17 = a2;
    CC_SHA1_Deprecated_Update((CC_SHA1_CTX *)(a1 + 76), a2, a3);
    v15 = 0;
    if (v16)
    {
      v19 = *(_DWORD *)(a1 + 72);
      do
      {
        v20 = *(unsigned int *)(a1 + 40);
        v21 = v16 + (unint64_t)v19 <= v20 ? v16 : v20 - v19;
        memcpy((void *)(*(_QWORD *)(a1 + 64) + v19), v17, v21);
        v22 = *(_DWORD *)(a1 + 72) + v21;
        *(_DWORD *)(a1 + 72) = v22;
        v23 = *(_QWORD *)(a1 + 48) + v21;
        *(_QWORD *)(a1 + 48) = v23;
        v15 += v21;
        if (v22 < *(_DWORD *)(a1 + 40) && v23 < *(_QWORD *)(a1 + 32))
          break;
        v24 = *(_QWORD *)(a1 + 56);
        if (v24 + (unint64_t)*(unsigned int *)(a1 + 24) > *(_QWORD *)(a1 + 16))
        {
          v13 = "ECC buffer overflow";
          v14 = 914;
          goto LABEL_9;
        }
        if (*(_DWORD *)a1 != 1)
        {
          v13 = "Invalid ECC algorithm";
          v14 = 921;
          goto LABEL_9;
        }
        if ((ECC65537GetParity(v22, *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 8) + v24) & 0x80000000) != 0)
        {
          v13 = "ECC generation failed";
          v14 = 918;
          goto LABEL_9;
        }
        v19 = 0;
        v17 += v21;
        *(_QWORD *)(a1 + 56) += *(unsigned int *)(a1 + 24);
        *(_DWORD *)(a1 + 72) = 0;
        v16 -= v21;
      }
      while (v16);
    }
    checkEOF((int *)a1);
  }
  else
  {
    v13 = "Too many bytes received";
    v14 = 892;
LABEL_9:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/ErrorCorrection.c", (uint64_t)"OECCStreamWrite", v14, 64, 0, v13, a7, a8, v26);
    return -1;
  }
  return v15;
}

uint64_t ParallelCompressionOStreamCreate(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v5;

  v3 = OEncoderStreamCreate(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 8), *(_DWORD *)(a1 + 4), *(_QWORD *)(a1 + 16), *(_DWORD *)a1);
  if (!v3)
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Streams.c", (uint64_t)"ParallelCompressionOStreamCreate", 20, 45, 0, "creating encoder failed", v1, v2, v5);
  return v3;
}

uint64_t *ParallelCompressionIStreamCreate(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t (*v4)(uint64_t, uint64_t, unint64_t);
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  v2 = (uint64_t *)malloc(0x10uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = 0;
    v2[1] = 0;
    v4 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(a1 + 24);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = *(_QWORD *)(a1 + 40);
    v7 = *(_QWORD *)(a1 + 8);
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    {
      v14 = ILowMemoryDecoderStreamCreate(v4, v5, v6, v7);
      v3[1] = v14;
      if (!v14)
      {
LABEL_7:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Streams.c", (uint64_t)"ParallelCompressionIStreamCreate", 63, 45, 0, "creating decoder failed", v9, v10, v16);
        free(v3);
        return 0;
      }
    }
    else
    {
      v8 = IDecoderStreamCreate((uint64_t)v4, v5, v6, v7, *(_DWORD *)a1);
      *v3 = v8;
      if (!v8)
        goto LABEL_7;
    }
  }
  else
  {
    v11 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelCompression/Streams.c", (uint64_t)"ParallelCompressionIStreamCreate", 51, 45, *v11, "malloc", v12, v13, v16);
  }
  return v3;
}

uint64_t ParallelCompressionIStreamRead(uint64_t *a1, char *a2, size_t a3)
{
  if (!a1)
    return -1;
  if (a1[1])
    return ILowMemoryDecoderStreamRead(a1[1], a2, a3);
  return IDecoderStreamRead(*a1, (uint64_t)a2, a3);
}

size_t ParallelCompressionIStreamAbort(size_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
  {
    if (*(_QWORD *)(result + 8))
      return ILowMemoryDecoderStreamAbort(*(_QWORD *)(result + 8));
    else
      return IDecoderStreamAbort(*(_QWORD *)result, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

void ParallelCompressionIStreamDestroy(_QWORD **a1)
{
  if (a1)
  {
    ILowMemoryDecoderStreamDestroy((uint64_t)a1[1]);
    IDecoderStreamDestroy(*a1);
    free(a1);
  }
}

void **MemBufferCreate(size_t a1)
{
  void **v2;
  void **v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v2 = (void **)malloc(0x28uLL);
  v3 = v2;
  if (v2)
  {
    v2[4] = 0;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    if ((MemBufferIncreaseCapacity((uint64_t)v2, a1) & 0x8000000000000000) != 0)
    {
      free(v3[4]);
      free(v3);
      return 0;
    }
  }
  else
  {
    v4 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferCreate", 41, 36, *v4, "malloc", v5, v6, v8);
  }
  return v3;
}

unint64_t MemBufferIncreaseCapacity(uint64_t a1, size_t a2)
{
  unint64_t result;
  void *v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  result = *(_QWORD *)a1;
  if (result < a2)
  {
    v5 = reallocf(*(void **)(a1 + 32), a2);
    *(_QWORD *)(a1 + 32) = v5;
    if (v5)
    {
      *(_QWORD *)a1 = a2;
      return a2;
    }
    else
    {
      v6 = __error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseCapacity", 91, 36, *v6, "malloc", v7, v8, v9);
      return -1;
    }
  }
  return result;
}

void MemBufferDestroy(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1);
  }
}

void **MemBufferCreateWithData(size_t a1, const void *a2)
{
  void **v4;
  void **v5;

  v4 = MemBufferCreate(a1);
  v5 = v4;
  if (v4)
  {
    memcpy(v4[4], a2, a1);
    v5[1] = (void *)a1;
    v5[2] = 0;
    v5[3] = (void *)a1;
  }
  return v5;
}

uint64_t MemBufferGetDataSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t MemBufferGetFreeSize(_QWORD *a1)
{
  return *a1 - a1[1];
}

uint64_t MemBufferGetDataPtr(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 16);
}

uint64_t MemBufferGetFreePtr(uint64_t a1)
{
  size_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v3)
    {
      memmove(*(void **)(a1 + 32), (const void *)(*(_QWORD *)(a1 + 32) + v3), v2);
      v4 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = v4;
    }
  }
  return *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 24);
}

uint64_t MemBufferDecreaseSize(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  unint64_t v10;
  uint64_t result;
  unint64_t v12;

  v9 = (_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 8);
  result = v10 - a2;
  if (v10 >= a2)
  {
    if (v10 == a2)
    {
      result = 0;
      *v9 = 0;
      v9[1] = 0;
      v9[2] = 0;
    }
    else
    {
      v12 = *(_QWORD *)(a1 + 16) + a2;
      *(_QWORD *)(a1 + 8) = result;
      *(_QWORD *)(a1 + 16) = v12;
    }
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferDecreaseSize", 117, 36, 0, "MemBufferDecreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return result;
}

uint64_t MemBufferIncreaseSize(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;

  v8 = a1[3] + a2;
  if (v8 <= *a1)
  {
    a1[3] = v8;
    v9 = a1[1] + a2;
    a1[1] = v9;
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferIncreaseSize", 137, 36, 0, "MemBufferIncreaseSize n is too large: %zu", a7, a8, a2);
    return -1;
  }
  return v9;
}

_QWORD *MemBufferClear(_QWORD *result)
{
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  return result;
}

BOOL MemBufferIsEmpty(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) == 0;
}

uint64_t MemBufferFillFromBuffer(unint64_t *a1, size_t a2, const void *a3)
{
  size_t v6;
  void *FreePtr;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v6 = *a1 - a1[1];
  FreePtr = (void *)MemBufferGetFreePtr((uint64_t)a1);
  if (v6 >= a2)
  {
    memcpy(FreePtr, a3, a2);
    return MemBufferIncreaseSize(a1, a2, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFillFromBuffer", 162, 36, 0, "MemBufferFillFromBuffer n is too large: %zu", v8, v9, a2);
    return -1;
  }
}

uint64_t MemBufferFillFromBufferWithCapacityIncrease(unint64_t *a1, size_t a2, const void *a3)
{
  size_t v6;

  v6 = a1[1] + a2;
  if (v6 > *a1 && (MemBufferIncreaseCapacity((uint64_t)a1, v6) & 0x8000000000000000) != 0)
    return -1;
  else
    return MemBufferFillFromBuffer(a1, a2, a3);
}

uint64_t MemBufferFlushToBuffer(_QWORD *a1, size_t __n, void *__dst, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a1[1] >= __n)
  {
    memcpy(__dst, (const void *)(a1[4] + a1[2]), __n);
    return MemBufferDecreaseSize((uint64_t)a1, __n, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFlushToBuffer", 183, 36, 0, "MemBufferFlushToBuffer n is too large: %zu", a7, a8, __n);
    return -1;
  }
}

uint64_t MemBufferFillFromIStream(unint64_t *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4)
{
  unint64_t v8;
  uint64_t FreePtr;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v8 = *a1 - a1[1];
  FreePtr = MemBufferGetFreePtr((uint64_t)a1);
  if (v8 >= a2)
    v8 = a2;
  if (v8)
  {
    v16 = FreePtr;
    v17 = 0;
    while (1)
    {
      v18 = a3(a4, v16, v8);
      if (v18 < 0)
        break;
      if (v18)
      {
        v16 += v18;
        v17 += v18;
        v8 -= v18;
        if (v8)
          continue;
      }
      return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
    }
    return -1;
  }
  else
  {
    v17 = 0;
    return MemBufferIncreaseSize(a1, v17, v10, v11, v12, v13, v14, v15);
  }
}

uint64_t MemBufferFlushToOStream(_QWORD *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  if (a1[1] >= a2)
    v9 = a2;
  else
    v9 = a1[1];
  if (v9)
  {
    v12 = 0;
    v13 = a1[4] + a1[2];
    while (1)
    {
      v14 = a3(a4, v13, v9);
      if (v14 < 0)
        break;
      if (!v14)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferFlushToOStream", 265, 36, 0, "MemBuffer write proc returned 0", a7, a8, v16);
        return -1;
      }
      v13 += v14;
      v12 += v14;
      v9 -= v14;
      if (!v9)
        return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
    return -1;
  }
  else
  {
    v12 = 0;
    return MemBufferDecreaseSize((uint64_t)a1, v12, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

uint64_t MemBufferTransmit(unint64_t *a1, unint64_t a2, size_t (*a3)(int a1, void *a2, size_t a3), uint64_t a4, uint64_t (*a5)(uint64_t a1, uint64_t a2, uint64_t a3), uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  size_t (*v12)(int, void *, size_t);
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t);
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  const char *v19;
  __int16 v20;
  char v22;

  v8 = a2;
  if ((unint64_t)a3 | (unint64_t)a5)
  {
    if (a3)
      v11 = a4;
    else
      v11 = 0;
    if (a3)
      v12 = a3;
    else
      v12 = IZeroStreamRead;
    if (a5)
      v13 = a5;
    else
      v13 = ONullStreamWrite;
    if (a5)
      v14 = a6;
    else
      v14 = 0;
    if (*a1)
    {
      a1[1] = 0;
      a1[2] = 0;
      a1[3] = 0;
      v9 = 0;
      if (!a2)
        return v9;
      while (1)
      {
        if (*a1 >= v8)
          v15 = v8;
        else
          v15 = *a1;
        v16 = v12(v11, (void *)a1[4], v15);
        if (v16 < 0)
        {
          v19 = "read failed";
          v20 = 294;
          goto LABEL_30;
        }
        v17 = v16;
        v18 = v13(v14, a1[4], v16);
        if ((v18 & 0x8000000000000000) != 0)
        {
          v19 = "write failed";
          v20 = 298;
          goto LABEL_30;
        }
        if (v18 < v17)
          break;
        if (v17)
        {
          v9 += v17;
          if (v8 == -1)
            v8 = -1;
          else
            v8 -= v17;
          if (v8)
            continue;
        }
        return v9;
      }
      v19 = "truncated write";
      v20 = 299;
    }
    else
    {
      v19 = "MemBuffer is not allocated";
      v20 = 281;
    }
LABEL_30:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MemBufferTransmit", v20, 36, 0, v19, a7, a8, v22);
    return -1;
  }
  return a2;
}

_QWORD *MappedBufferCreateWithFilename(const char *a1, unint64_t a2, unint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  off_t v20;
  unint64_t v21;
  char *v22;
  char v23;
  stat v24;

  v6 = malloc(0x28uLL);
  v7 = v6;
  if (v6)
  {
    v6[3] = 0;
    v6[4] = 0;
    v6[1] = -1;
    v6[2] = 0;
    memset(&v24, 0, sizeof(v24));
    v8 = getpagesize();
    *((_DWORD *)v7 + 1) = 1;
    v9 = open(a1, 0);
    *(_DWORD *)v7 = v9;
    if (v9 < 0)
    {
      v13 = *__error();
      v23 = (char)a1;
      v14 = "%s";
      v15 = 344;
      goto LABEL_7;
    }
    v10 = v9;
    if (fstat(v9, &v24))
    {
      v13 = *__error();
      v23 = (char)a1;
      v14 = "%s";
      v15 = 347;
LABEL_7:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFilename", v15, 36, v13, v14, v11, v12, v23);
      MappedBufferDestroy(v7);
      return 0;
    }
    if (v24.st_size > a2)
    {
      if (a3 == -1)
      {
        a3 = v24.st_size - a2;
      }
      else if (a3 + a2 > v24.st_size)
      {
        v23 = a2;
        v14 = "invalid offset=%llu, size=%llu in file %s";
        v15 = 352;
LABEL_19:
        v13 = 0;
        goto LABEL_7;
      }
      if (a3)
      {
        v7[4] = a3;
        v20 = a2 / v8 * v8;
        v21 = a2 % v8;
        v7[2] = v21 + a3;
        v22 = (char *)mmap(0, v21 + a3, 1, 2, v10, v20);
        v7[1] = v22;
        if (v22 != (char *)-1)
        {
          v7[3] = &v22[v21];
          return v7;
        }
        v13 = *__error();
        v14 = "mmap file segment";
        v15 = 364;
        goto LABEL_7;
      }
      v23 = 0;
      v14 = "invalid size=%llu";
      v15 = 354;
      goto LABEL_19;
    }
    v23 = a2;
    v14 = "invalid offset=%llu in file %s";
    v15 = 348;
    goto LABEL_19;
  }
  v16 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/Common/IOBuffers.c", (uint64_t)"MappedBufferCreateWithFilename", 329, 36, *v16, "malloc", v17, v18, v23);
  return v7;
}

void MappedBufferDestroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    v2 = (void *)a1[1];
    if (v2 != (void *)-1)
      munmap(v2, a1[2]);
    if (*((_DWORD *)a1 + 1))
    {
      if ((*(_DWORD *)a1 & 0x80000000) == 0)
        close(*(_DWORD *)a1);
    }
    free(a1);
  }
}

uint64_t MappedBufferGetDataSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t verifyDirThreadProc()
{
  uint64_t v0;
  char *v1;
  uint64_t v2;
  void (*v3)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD);
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  int v16;
  int AAEntryType;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unsigned int v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unsigned int *v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  BOOL v42;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  BOOL v48;
  BOOL v49;
  uint64_t v51;
  _QWORD *v52;
  BOOL v53;
  BOOL v54;
  unint64_t *v56;
  unint64_t v57;
  int v58;
  stat v59;
  stat v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  char v64[2048];
  char v65[2048];
  uint64_t v66;

  v0 = MEMORY[0x24BDAC7A8]();
  v66 = *MEMORY[0x24BDAC8D0];
  v1 = *(char **)v0;
  bzero(v65, 0x800uLL);
  bzero(v64, 0x800uLL);
  memset(&v59, 0, sizeof(v59));
  v3 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v1 + 64);
  v2 = *(_QWORD *)(*(_QWORD *)v1 + 72);
  v4 = (unint64_t *)(v1 + 2136);
  do
    v5 = __ldxr(v4);
  while (__stxr(v5 + 1, v4));
  if (concatPath(v65, 0x800uLL, v1 + 8, (const char *)(v0 + 152)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", 78, 43, 0, "building full path: %s", v6, v7, v0 - 104);
    v8 = (unint64_t *)(v1 + 2176);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    return 0;
  }
  if (lstat(v65, &v59))
  {
    v10 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", 81, 43, *v10, "%s", v11, v12, (char)v65);
    v13 = (unint64_t *)(v1 + 2176);
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    return 0;
  }
  v16 = *(_DWORD *)(v0 + 8);
  AAEntryType = getAAEntryType(v59.st_mode);
  v18 = *(_DWORD *)(v0 + 12);
  if (v18 != 72)
  {
    if (AAEntryType != v18)
    {
      v23 = 1;
      goto LABEL_125;
    }
    if ((v16 & 2) != 0)
      v23 = 2 * (*(_DWORD *)(v0 + 16) != v59.st_uid);
    else
      v23 = 0;
    if ((v16 & 4) != 0)
    {
      if (*(_DWORD *)(v0 + 20) != v59.st_gid)
        v23 |= 4u;
      if ((v16 & 8) == 0)
      {
LABEL_27:
        if ((v16 & 0x10) == 0)
          goto LABEL_28;
        goto LABEL_37;
      }
    }
    else if ((v16 & 8) == 0)
    {
      goto LABEL_27;
    }
    if (*(_DWORD *)(v0 + 24) != v59.st_flags)
      v23 |= 8u;
    if ((v16 & 0x10) == 0)
    {
LABEL_28:
      if ((v16 & 0x80) == 0)
        goto LABEL_29;
      goto LABEL_40;
    }
LABEL_37:
    if (*(_DWORD *)(v0 + 28) != (v59.st_mode & 0xFFF))
      v23 |= 0x10u;
    if ((v16 & 0x80) == 0)
    {
LABEL_29:
      if ((v16 & 0x100) == 0)
        goto LABEL_47;
      goto LABEL_43;
    }
LABEL_40:
    if (*(_QWORD *)(v0 + 48) != v59.st_size)
      v23 |= 0x80u;
    if ((v16 & 0x100) == 0)
    {
LABEL_47:
      if ((v16 & 0x10000) != 0 && AAEntryType == 76)
      {
        bzero(&v60, 0x400uLL);
        if (readlink(v65, (char *)&v60, 0x3FFuLL) < 0)
        {
          v31 = __error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", 129, 43, *v31, "%s", v32, v33, (char)v65);
          v34 = (unint64_t *)(v1 + 2176);
          do
            v35 = __ldxr(v34);
          while (__stxr(v35 + 1, v34));
          return 0;
        }
        if (strcmp((const char *)&v60, (const char *)(v0 + 1176)))
        {
          v23 |= 0x10000u;
          goto LABEL_125;
        }
      }
      else
      {
        if (AAEntryType != 70)
          goto LABEL_124;
        if ((v16 & 0x1000) != 0)
        {
          v29 = (unsigned int *)&v58;
        }
        else
        {
          if ((v16 & 0x6000) == 0)
            goto LABEL_124;
          v29 = 0;
        }
        v58 = 0;
        v62 = 0;
        v61 = 0;
        v63 = 0;
        memset(&v60, 0, 32);
        if ((v16 & 0x2000) != 0)
          v36 = (unsigned __int8 *)&v61;
        else
          v36 = 0;
        if ((v16 & 0x4000) != 0)
          v37 = (unsigned __int8 *)&v60;
        else
          v37 = 0;
        if ((getFileDigests(v65, v36, v37, v29) & 0x80000000) != 0)
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", 141, 43, 0, "verification failed: %s", v38, v39, (char)v65);
          v40 = (unint64_t *)(v1 + 2176);
          do
            v41 = __ldxr(v40);
          while (__stxr(v41 + 1, v40));
        }
        if ((v16 & 0x1000) != 0 && v58 != *(_DWORD *)(v0 + 96))
          v23 |= 0x1000u;
        if ((v16 & 0x2000) != 0)
        {
          v42 = v61 == *(_QWORD *)(v0 + 100) && v62 == *(_QWORD *)(v0 + 108);
          if (!v42 || v63 != (unint64_t)*(unsigned int *)(v0 + 116))
          {
            v44 = *(_QWORD *)(v0 + 2200);
            if (v44)
            {
              v45 = *(_QWORD *)(v0 + 2216) + 8;
              while (1)
              {
                if (*(_DWORD *)(v45 - 4) == 5 && (*(_DWORD *)(v45 - 8) & 0xDFDFDF) == 0x114858)
                {
                  v46 = v61 == *(_QWORD *)v45 && v62 == *(_QWORD *)(v45 + 8);
                  if (v46 && v63 == (unint64_t)*(unsigned int *)(v45 + 16))
                    break;
                }
                v45 += 1032;
                if (!--v44)
                  goto LABEL_96;
              }
            }
            else
            {
LABEL_96:
              v23 |= 0x2000u;
            }
          }
        }
        if ((v16 & 0x4000) != 0)
        {
          v48 = *(_QWORD *)&v60.st_dev == *(_QWORD *)(v0 + 120) && v60.st_ino == *(_QWORD *)(v0 + 128);
          v49 = v48 && *(_QWORD *)&v60.st_uid == *(_QWORD *)(v0 + 136);
          if (!v49 || *(_QWORD *)&v60.st_rdev != *(_QWORD *)(v0 + 144))
          {
            v51 = *(_QWORD *)(v0 + 2200);
            if (!v51)
            {
LABEL_123:
              v23 |= 0x4000u;
              goto LABEL_125;
            }
            v52 = (_QWORD *)(*(_QWORD *)(v0 + 2216) + 8);
            while (1)
            {
              if (*((_DWORD *)v52 - 1) == 6 && (*(_DWORD *)(v52 - 1) & 0xDFDFDF) == 0x124858)
              {
                v53 = *(_QWORD *)&v60.st_dev == *v52 && v60.st_ino == v52[1];
                v54 = v53 && *(_QWORD *)&v60.st_uid == v52[2];
                if (v54 && *(_QWORD *)&v60.st_rdev == v52[3])
                  break;
              }
              v52 += 129;
              if (!--v51)
                goto LABEL_123;
            }
          }
        }
      }
LABEL_124:
      if (!v23)
      {
        v30 = 0;
        if (!v3)
          return 0;
        goto LABEL_128;
      }
      goto LABEL_125;
    }
LABEL_43:
    if (AAEntryType != 68
      && (*(_QWORD *)(v0 + 56) != v59.st_mtimespec.tv_sec
       || *(_QWORD *)(v0 + 64) / 0x3E8uLL != v59.st_mtimespec.tv_nsec / 0x3E8uLL))
    {
      v23 |= 0x100u;
    }
    goto LABEL_47;
  }
  if (concatPath(v64, 0x800uLL, v1 + 8, (const char *)(v0 + 1176)))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", 93, 43, 0, "building full link path: %s", v19, v20, v0 - 104);
    v21 = (unint64_t *)(v1 + 2176);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    return 0;
  }
  memset(&v60, 0, sizeof(v60));
  if (lstat(v64, &v60))
  {
    v24 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirThreadProc", 97, 43, *v24, "%s", v25, v26, (char)v65);
    v27 = (unint64_t *)(v1 + 2176);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
    return 0;
  }
  if (v60.st_ino == v59.st_ino)
  {
    v30 = 0;
    v23 = 0;
    if (!v3)
      return 0;
    goto LABEL_128;
  }
  v23 = 64;
LABEL_125:
  v56 = (unint64_t *)(v1 + 2160);
  do
    v57 = __ldxr(v56);
  while (__stxr(v57 + 1, v56));
  v30 = 3;
  if (v3)
LABEL_128:
    v3(v2, v30, v23, v0 + 8, *(_QWORD *)(v0 + 2216), *(_QWORD *)(v0 + 2200));
  return 0;
}

uint64_t ParallelArchiveVerifyDir(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int DefaultNThreads;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t **v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t result;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  FILE **v40;
  FILE *v41;
  unint64_t v42;
  FILE *v43;
  unint64_t v44;
  FILE *v45;
  unint64_t v46;
  FILE *v47;
  unint64_t v48;
  FILE *v49;
  unint64_t v50;
  FILE *v51;
  unint64_t v52;
  FILE *v53;
  unint64_t v54;
  unint64_t v55;
  FILE *v56;
  unint64_t v57;
  char v58;
  char v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t *v65;
  uint64_t v66;
  char v67[1024];
  unsigned int *v68;
  size_t __count;
  void *v70;
  void *v71;
  unsigned int *v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80[2];

  v80[1] = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v58);
  bzero(v67, 0x880uLL);
  v66 = a1;
  DefaultNThreads = *(_DWORD *)(a1 + 4);
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  v65 = 0;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v60 = 0u;
  LODWORD(__count) = DefaultNThreads;
  if (!realpath_DARWIN_EXTSN(*(const char **)(a1 + 16), v67))
  {
    v25 = *__error();
    v26 = *(const char **)(a1 + 16);
    v27 = 350;
LABEL_18:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", v27, 43, v25, v26, v11, v12, v59);
    goto LABEL_19;
  }
  v70 = calloc(__count, 0x8B0uLL);
  v10 = calloc(__count, 8uLL);
  v71 = v10;
  if (!v70 || !v10)
  {
    v25 = *__error();
    v26 = "malloc";
    v27 = 353;
    goto LABEL_18;
  }
  v68 = ArchiveTreeCreateFromDirectory(*(char **)(a1 + 16), 0, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_DWORD *)(a1 + 4), *(_DWORD *)a1);
  if (!v68)
  {
    v26 = "creating directory tree";
    v27 = 357;
LABEL_17:
    v25 = 0;
    goto LABEL_18;
  }
  v13 = __count;
  if ((_DWORD)__count)
  {
    v14 = 0;
    do
    {
      v15 = (uint64_t **)((char *)v70 + 2224 * v14);
      *v15 = &v66;
      *((_QWORD *)v71 + v14++) = v15;
    }
    while (v14 != v13);
  }
  v72 = ThreadPoolCreate(v13, (uint64_t)v71, (uint64_t)verifyDirThreadProc);
  if (!v72)
  {
    v26 = "ThreadPoolCreate";
    v27 = 366;
    goto LABEL_17;
  }
  v60 = 0u;
  v61 = 0u;
  v63 = 0u;
  v64 = 0u;
  v62 = 0u;
  DWORD1(v60) = *(_DWORD *)(a1 + 4);
  v21 = *(_QWORD *)(a1 + 40);
  *((_QWORD *)&v60 + 1) = *(_QWORD *)(a1 + 24);
  *((_QWORD *)&v61 + 1) = v21;
  *(_QWORD *)&v62 = verifyDirBeginEntry;
  *((_QWORD *)&v62 + 1) = verifyDirBlob;
  *(_QWORD *)&v63 = verifyDirPayload;
  *(_QWORD *)&v64 = verifyDirEndEntry;
  v65 = &v66;
  if (ParallelArchiveRead((uint64_t)&v60, v16, v17, v18, v19, v20, v11, v12))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", 379, 43, 0, "reading manifest", v22, v23, v59);
    v24 = 0;
  }
  else
  {
    v24 = 1;
  }
  if ((ThreadPoolDestroy((uint64_t)v72) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", 382, 43, 0, "ThreadPoolDestroy failed", v37, v38, v59);
    v24 = 0;
    v72 = 0;
    goto LABEL_20;
  }
  v72 = 0;
  v39 = atomic_load(v80);
  if (v39 > 0)
  {
LABEL_19:
    v24 = 0;
    goto LABEL_20;
  }
  if (*(int *)a1 >= 1)
  {
    v40 = (FILE **)MEMORY[0x24BDAC8D8];
    v41 = (FILE *)*MEMORY[0x24BDAC8D8];
    v42 = atomic_load(&v73);
    fprintf(v41, "%12lld entries in manifest\n", v42);
    v43 = *v40;
    v44 = atomic_load(&v74);
    fprintf(v43, "%12lld entries selected\n", v44);
    v45 = *v40;
    v46 = atomic_load(&v77);
    fprintf(v45, "%12lld entries added\n", v46);
    v47 = *v40;
    v48 = atomic_load(&v76);
    fprintf(v47, "%12lld entries removed\n", v48);
    v49 = *v40;
    v50 = atomic_load(&v75);
    fprintf(v49, "%12lld entries compared\n", v50);
    v51 = *v40;
    v52 = atomic_load(&v78);
    fprintf(v51, "%12lld entries compared -> modified\n", v52);
    v53 = *v40;
    v54 = atomic_load(&v75);
    v55 = atomic_load(&v78);
    fprintf(v53, "%12lld entries compared -> verified\n", v54 - v55);
    v56 = *v40;
    v57 = atomic_load(&v79);
    fprintf(v56, "%12lld bytes hashed\n", v57);
  }
LABEL_20:
  ArchiveTreeDestroy((uint64_t)v68);
  if ((ThreadPoolDestroy((uint64_t)v72) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"ParallelArchiveVerifyDir", 403, 43, 0, "ThreadPoolDestroy", v28, v29, v59);
    v24 = 0;
  }
  free(v71);
  v30 = v70;
  if (v70)
  {
    if ((_DWORD)__count)
    {
      v31 = 0;
      v32 = 2216;
      do
      {
        free(*(void **)((char *)v70 + v32));
        ++v31;
        v32 += 2224;
      }
      while (v31 < __count);
      v30 = v70;
    }
    free(v30);
  }
  result = leaveThreadErrorContext(0, 0, 0);
  if ((result & 0x80000000) == 0)
  {
    if (v24)
    {
      if (atomic_load(&v78))
        return 0;
      if (atomic_load(&v77))
      {
        return 0;
      }
      else
      {
        v36 = atomic_load(&v76);
        return v36 == 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t verifyDirBeginEntry()
{
  uint64_t result;
  uint64_t v1;
  const void *v2;
  unint64_t v3;
  uint64_t v4;
  void (*v5)(uint64_t, uint64_t);
  BOOL v6;
  unint64_t v7;
  const void *v8;
  const char *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t (*v13)(_QWORD, uint64_t, _QWORD);
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t Worker;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  char v55;
  uint64_t v56;
  _BYTE v57[4];
  int v58;
  char __s1[2048];
  uint64_t v60;

  result = MEMORY[0x24BDAC7A8]();
  v60 = *MEMORY[0x24BDAC8D0];
  v5 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 64);
  v4 = *(_QWORD *)(*(_QWORD *)result + 72);
  v6 = *(_DWORD *)(v1 + 4) == 77;
  *(_DWORD *)(result + 1084) = v6;
  if (!v6)
  {
    v7 = v3;
    v8 = v2;
    v9 = (const char *)v1;
    v10 = result;
    v11 = (unint64_t *)(result + 2120);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
    v13 = *(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)result + 48);
    if (!v13
      || (result = v13(*(_QWORD *)(*(_QWORD *)result + 56), v1 + 144, *(unsigned int *)(v1 + 4)), (int)result >= 1))
    {
      v14 = (unint64_t *)(v10 + 2128);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 + 1, v14));
      v16 = *(_DWORD *)(v10 + 1072);
      result = (uint64_t)ArchiveTreeSize(*(unsigned int **)(v10 + 1032));
      if (v16 >= result)
      {
LABEL_22:
        v31 = (unint64_t *)(v10 + 2144);
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 + 1, v31));
        if (v5)
          return ((uint64_t (*)(uint64_t, uint64_t, _QWORD, const char *, const void *, unint64_t))v5)(v4, 1, 0, v9, v8, v7);
      }
      else
      {
        v17 = (unint64_t *)(v10 + 2152);
        while (1)
        {
          if (ArchiveTreeNodePath(*(_QWORD *)(v10 + 1032), *(_DWORD *)(v10 + 1072), (uint64_t)__s1, 0x800uLL) < 0)
          {
            result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirBeginEntry", 220, 43, 0, "getting node path", v18, v19, v55);
            v29 = (unint64_t *)(v10 + 2176);
            do
              v30 = __ldxr(v29);
            while (__stxr(v30 + 1, v29));
            return result;
          }
          result = strcmp(__s1, v9 + 144);
          if ((result & 0x80000000) == 0)
            break;
          if (__s1[0])
          {
            do
              v28 = __ldaxr(v17);
            while (__stlxr(v28 + 1, v17));
            if (v5)
            {
              bzero(v57, 0x890uLL);
              __strlcpy_chk();
              v58 = ArchiveTreeNodeEntryType(*(_QWORD *)(v10 + 1032), *(_DWORD *)(v10 + 1072));
              v56 &= 0xFFFFFFFF00000000;
              v5(v4, 2);
            }
          }
          v27 = *(_DWORD *)(v10 + 1072) + 1;
          *(_DWORD *)(v10 + 1072) = v27;
          if (v27 >= ArchiveTreeSize(*(unsigned int **)(v10 + 1032)))
            goto LABEL_27;
        }
        if ((_DWORD)result)
          goto LABEL_22;
LABEL_27:
        Worker = ThreadPoolGetWorker(*(_QWORD *)(v10 + 1064), v20, v21, v22, v23, v24, v25, v26);
        if (Worker)
        {
          v36 = Worker;
          memcpy((void *)(Worker + 8), v9, 0x890uLL);
          if (*(_QWORD *)(v36 + 2208) >= v7)
          {
            v38 = *(void **)(v36 + 2216);
          }
          else
          {
            v37 = 16;
            if (v7 > 0x10)
              v37 = v7;
            *(_QWORD *)(v36 + 2208) = v37;
            v38 = reallocf(*(void **)(v36 + 2216), 1032 * v37);
            *(_QWORD *)(v36 + 2216) = v38;
            if (!v38)
            {
              result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirBeginEntry", 272, 43, 0, "malloc", v39, v40, v55);
              v41 = (unint64_t *)(v10 + 2176);
              do
                v42 = __ldxr(v41);
              while (__stxr(v42 + 1, v41));
              return result;
            }
          }
          memcpy(v38, v8, 1032 * v7);
          *(_QWORD *)(v36 + 2200) = v7;
          *(_DWORD *)(v36 + 8) &= *(_DWORD *)(*(_QWORD *)v10 + 8);
          result = ThreadPoolRunWorker(*(_QWORD *)(v10 + 1064), v36, v45, v46, v47, v48, v49, v50);
          if ((result & 0x80000000) != 0)
          {
            result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirBeginEntry", 281, 43, 0, "ThreadPoolRunWorker failed", v51, v52, v55);
            v53 = (unint64_t *)(v10 + 2176);
            do
              v54 = __ldxr(v53);
            while (__stxr(v54 + 1, v53));
          }
          else
          {
            ++*(_DWORD *)(v10 + 1072);
          }
        }
        else
        {
          result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirBeginEntry", 262, 43, 0, "ThreadPoolGetWorker failed", v34, v35, v55);
          v43 = (unint64_t *)(v10 + 2176);
          do
            v44 = __ldxr(v43);
          while (__stxr(v44 + 1, v43));
        }
      }
    }
  }
  return result;
}

size_t verifyDirEndEntry(size_t result)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  int v7;
  FILE **v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  char v13;
  char v14;
  int v15;
  char v16[1024];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(result + 1084))
  {
    v1 = (const char *)result;
    v2 = *(_QWORD *)(result + 2112);
    if ((unint64_t)(v2 + 1) <= 0x3FF)
    {
      *(_BYTE *)(result + 1088 + v2) = 0;
      v15 = 0;
      result = yaa_parseFields((const char *)(result + 1088), &v15, 0);
      if ((_DWORD)result)
      {
        result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirEndEntry", 296, 43, 0, "parsing YAF metadata field", v3, v4, v13);
        v5 = (unint64_t *)(v1 + 2176);
        do
          v6 = __ldxr(v5);
        while (__stxr(v6 + 1, v5));
        return result;
      }
      v7 = *(_DWORD *)(*(_QWORD *)v1 + 8) & v15;
      v8 = (FILE **)MEMORY[0x24BDAC8D8];
      if (**(int **)v1 >= 1)
      {
        bzero(v16, 0x400uLL);
        fprintf(*v8, "Manifest fields: %s\n", v1 + 1088);
        if (yaa_serializeFields(v16, 0x400uLL, v7, 0))
        {
          result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/VerifyDir.c", (uint64_t)"verifyDirEndEntry", 307, 43, 0, "serializing fields", v9, v10, v14);
          v11 = (unint64_t *)(v1 + 2176);
          do
            v12 = __ldxr(v11);
          while (__stxr(v12 + 1, v11));
          return result;
        }
        result = fprintf(*v8, "Comparison fields: %s\n", v16);
      }
      if ((v7 & 0x400) != 0)
        result = fwrite("Warning: XAT field verification is not implemented\n", 0x33uLL, 1uLL, *v8);
      if ((v7 & 0x800) != 0)
        return fwrite("Warning: ACL field verification is not implemented\n", 0x33uLL, 1uLL, *v8);
    }
  }
  return result;
}

uint64_t verifyDirBlob(uint64_t result, char *a2)
{
  uint64_t v2;
  int v3;

  v2 = result;
  v3 = *(_DWORD *)(result + 1084);
  if (v3)
  {
    result = strncasecmp(a2, "YAF", 3uLL);
    v3 = result == 0;
  }
  *(_DWORD *)(v2 + 1080) = v3;
  return result;
}

char *verifyDirPayload(char *result, const void *a2, size_t __n)
{
  _QWORD *v4;
  uint64_t v5;

  if (*((_DWORD *)result + 270))
  {
    v4 = result;
    v5 = *((_QWORD *)result + 264);
    if (v5 + __n <= 0x3FF)
    {
      result = (char *)memcpy(&result[v5 + 1088], a2, __n);
      v4[264] += __n;
    }
  }
  return result;
}

_OWORD *ParallelArchiveDBSessionCreate(char *a1, void *a2, size_t a3, uint64_t a4)
{
  _OWORD *v8;
  char *v9;
  size_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  int v15;
  const char *v16;
  __int16 v17;
  char *v18;
  int64_t v19;
  char *v20;
  uint64_t v22;
  char v23;

  v8 = calloc(1uLL, 0x58uLL);
  if (v8)
  {
    v9 = strchr(a1, 61);
    if (v9)
    {
      v10 = v9 - a1;
      v11 = v9 + 1;
      if (!isValidAliasOrEngine((uint64_t)a1, v9 - a1))
      {
        v23 = (char)v11;
        v16 = "invalid session URL: %s (invalid alias chars)";
        v17 = 68;
        goto LABEL_15;
      }
      v14 = a1;
      a1 = v11;
    }
    else
    {
      v14 = 0;
      v10 = 0;
    }
    v18 = strchr(a1, 58);
    if (v18)
    {
      v19 = v18 - a1;
      v20 = v18 + 1;
      if (!isValidAliasOrEngine((uint64_t)a1, v18 - a1))
      {
        v23 = (char)v20;
        v16 = "invalid session URL: %s (invalid engine chars)";
        v17 = 78;
        goto LABEL_15;
      }
      if (v19 == 4 && *(_DWORD *)a1 == 1701603686)
      {
        v8[2] = xmmword_24BF0B8B8;
        v8[3] = *(_OWORD *)&off_24BF0B8C8;
        v8[4] = xmmword_24BF0B8D8;
        *((_QWORD *)v8 + 10) = 0;
        *v8 = ParallelArchiveDBSession_FILE;
        v8[1] = *(_OWORD *)&off_24BF0B8A8;
        v22 = (*(uint64_t (**)(char *, uint64_t))v8)(v20, a4);
        *((_QWORD *)v8 + 10) = v22;
        if (v22)
        {
          if (!a2)
            return v8;
          bzero(a2, a3);
          if (v10 + 1 <= a3)
          {
            memcpy(a2, v14, v10);
            *((_BYTE *)a2 + v10) = 0;
            return v8;
          }
          v16 = "invalid aliasCapacity";
          v17 = 98;
        }
        else
        {
          v23 = (char)v20;
          v16 = "create session: %s";
          v17 = 91;
        }
        goto LABEL_15;
      }
      LOBYTE(a1) = (_BYTE)v20;
    }
    v23 = (char)a1;
    v16 = "Invalid session URL: %s (unknown engine)";
    v17 = 87;
LABEL_15:
    v15 = 0;
    goto LABEL_16;
  }
  v15 = *__error();
  v16 = "malloc";
  v17 = 52;
LABEL_16:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSessionCreate", v17, 11, v15, v16, v12, v13, v23);
  free(v8);
  return 0;
}

BOOL isValidAliasOrEngine(uint64_t a1, unint64_t a2)
{
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  if (a2)
  {
    v4 = 0;
    v5 = 0;
    v6 = MEMORY[0x24BDAC740];
    while (1)
    {
      v7 = *(char *)(a1 + v5);
      if ((v7 & 0x80000000) != 0)
      {
        if (__maskrune(*(char *)(a1 + v5), 0x500uLL))
          goto LABEL_9;
      }
      else if ((*(_DWORD *)(v6 + 4 * v7 + 60) & 0x500) != 0)
      {
        goto LABEL_9;
      }
      if (v7 != 95 && v7 != 45)
        return v4;
LABEL_9:
      v4 = ++v5 >= a2;
      if (a2 == v5)
        return v4;
    }
  }
  return 1;
}

uint64_t ParallelArchiveDBSessionDestroy(uint64_t result)
{
  void *v1;
  uint64_t v2;

  if (result)
  {
    v1 = (void *)result;
    v2 = (*(uint64_t (**)(_QWORD))(result + 8))(*(_QWORD *)(result + 80));
    free(v1);
    return v2;
  }
  return result;
}

_QWORD *ParallelArchiveDBRequestOpenForWriting(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  __int16 v12;
  int v13;
  char v15;

  v6 = calloc(1uLL, 0x10uLL);
  v7 = v6;
  if (!v6)
  {
    v13 = *__error();
    v11 = "malloc";
    v12 = 122;
    goto LABEL_5;
  }
  *v6 = a1;
  v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 16))(*(_QWORD *)(a1 + 80), a2, a3);
  v7[1] = v8;
  if (!v8)
  {
    v11 = "Request creation";
    v12 = 126;
    v13 = 0;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBRequestOpenForWriting", v12, 11, v13, v11, v9, v10, v15);
    free(v7);
    return 0;
  }
  return v7;
}

uint64_t ParallelArchiveDBRequestWrite(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*a1 + 24))(a1[1]);
}

uint64_t ParallelArchiveDBRequestCloseAndGetKey(_QWORD *a1)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(_QWORD))(*a1 + 32))(a1[1]);
  free(a1);
  return v2;
}

_QWORD *ParallelArchiveDBRequestOpenForReading(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int v19;
  char v21;

  v12 = calloc(1uLL, 0x10uLL);
  v13 = v12;
  if (!v12)
  {
    v19 = *__error();
    v17 = "malloc";
    v18 = 151;
    goto LABEL_5;
  }
  *v12 = a1;
  v14 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 40))(*(_QWORD *)(a1 + 80), a2, a3, a4, a5, a6);
  v13[1] = v14;
  if (!v14)
  {
    v17 = "Request creation";
    v18 = 155;
    v19 = 0;
LABEL_5:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBRequestOpenForReading", v18, 11, v19, v17, v15, v16, v21);
    free(v13);
    return 0;
  }
  return v13;
}

uint64_t ParallelArchiveDBRequestRead(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD))(*a1 + 48))(a1[1]);
}

uint64_t ParallelArchiveDBRequestClose(_QWORD *a1)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(_QWORD))(*a1 + 64))(a1[1]);
  free(a1);
  return v2;
}

uint64_t ParallelArchiveDBSetCreate(size_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  int v22;
  void *v23;
  uint64_t v25;

  if (!a1)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSetCreate", 191, 11, 0, "nDB is not expected to be 0\n", a7, a8, v25);
    v12 = 0;
    goto LABEL_20;
  }
  v11 = calloc(1uLL, 0x18uLL);
  v12 = (uint64_t)v11;
  if (!v11)
  {
    v16 = *__error();
    v19 = "malloc";
    v20 = 195;
    goto LABEL_19;
  }
  *v11 = a1;
  v11[1] = calloc(a1, 8uLL);
  v13 = calloc(a1, 8uLL);
  *(_QWORD *)(v12 + 16) = v13;
  v14 = *(_QWORD *)(v12 + 8);
  if (v14)
    v15 = v13 == 0;
  else
    v15 = 1;
  if (v15)
  {
    v16 = *__error();
    v19 = "malloc";
    v20 = 200;
    goto LABEL_19;
  }
  v21 = 0;
  v22 = 0;
  while (1)
  {
    *(_QWORD *)(v14 + 8 * v21) = malloc(0x100uLL);
    v23 = *(void **)(*(_QWORD *)(v12 + 8) + 8 * v21);
    if (!v23)
    {
      v16 = *__error();
      v19 = "malloc";
      v20 = 205;
      goto LABEL_19;
    }
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * v21) = ParallelArchiveDBSessionCreate(*(char **)(a2 + 8 * v21), v23, 0x100uLL, a3);
    if (!*(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * v21))
    {
      v25 = *(_QWORD *)(a2 + 8 * v21);
      v19 = "creating session for: %s";
      v20 = 207;
      goto LABEL_24;
    }
    v14 = *(_QWORD *)(v12 + 8);
    if (!**(_BYTE **)(v14 + 8 * v21))
      break;
LABEL_16:
    if (a1 == ++v21)
      return v12;
  }
  if (!v22)
  {
    v22 = 1;
    goto LABEL_16;
  }
  v19 = "Only one default database is allowed";
  v20 = 212;
LABEL_24:
  v16 = 0;
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSetCreate", v20, 11, v16, v19, v17, v18, v25);
LABEL_20:
  ParallelArchiveDBSetDestroy(v12);
  return 0;
}

uint64_t ParallelArchiveDBSetDestroy(uint64_t result)
{
  unint64_t *v1;
  void *v2;
  unint64_t v3;
  void *v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char v11;

  if (result)
  {
    v1 = (unint64_t *)result;
    v2 = *(void **)(result + 8);
    if (v2)
    {
      if (*v1)
      {
        v3 = 0;
        do
          free(*(void **)(v1[1] + 8 * v3++));
        while (v3 < *v1);
        v2 = (void *)v1[1];
      }
      free(v2);
    }
    v4 = (void *)v1[2];
    if (v4)
    {
      if (*v1)
      {
        v5 = 0;
        v6 = 1;
        do
        {
          v7 = *(_QWORD *)(v1[2] + 8 * v5);
          if (v7)
          {
            v8 = (*(uint64_t (**)(_QWORD))(v7 + 8))(*(_QWORD *)(v7 + 80));
            free((void *)v7);
            if (v8 < 0)
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBSetDestroy", 239, 11, 0, "destroying session", v9, v10, v11);
              v6 = 0;
            }
          }
          ++v5;
        }
        while (v5 < *v1);
        v4 = (void *)v1[2];
      }
      else
      {
        v6 = 1;
      }
      free(v4);
    }
    else
    {
      v6 = 1;
    }
    free(v1);
    if (v6)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

_QWORD *ParallelArchiveDBReadRequestOpenWithSet(uint64_t *a1, char *__s2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  int v21;

  v9 = *a1;
  if (*a1)
  {
    v15 = 0;
    v16 = a1[1];
    v17 = -1;
    while (1)
    {
      v18 = *(const char **)(v16 + 8 * v15);
      v19 = v15;
      if (v18)
      {
        v19 = *v18 ? v17 : v15;
        if (*v18 && __s2 != 0)
        {
          v21 = strcmp(v18, __s2);
          v19 = v17;
          if (!v21)
            break;
        }
      }
      ++v15;
      v17 = v19;
      if (v9 == v15)
        goto LABEL_15;
    }
    v19 = v15;
LABEL_15:
    if (v19 != -1)
      return ParallelArchiveDBRequestOpenForReading(*(_QWORD *)(a1[2] + 8 * v19), a3, a4, a5, a6, a7);
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBReadRequestOpenWithSet", 261, 11, 0, "No database in set matches alias %s", a7, a8, (char)__s2);
  return 0;
}

uint64_t ParallelArchiveDBCloneWithSet(uint64_t *a1, char *__s2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  int v21;
  uint64_t v22;

  v9 = *a1;
  if (!*a1)
    goto LABEL_17;
  v15 = 0;
  v16 = a1[1];
  v17 = -1;
  while (1)
  {
    v18 = *(const char **)(v16 + 8 * v15);
    v19 = v15;
    if (v18)
    {
      v19 = *v18 ? v17 : v15;
      if (*v18 && __s2 != 0)
      {
        v21 = strcmp(v18, __s2);
        v19 = v17;
        if (!v21)
          break;
      }
    }
    ++v15;
    v17 = v19;
    if (v9 == v15)
      goto LABEL_15;
  }
  v19 = v15;
LABEL_15:
  if (v19 == -1)
  {
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/ArchiveDatabase.c", (uint64_t)"ParallelArchiveDBCloneWithSet", 281, 11, 0, "No database in set matches alias %s", a7, a8, (char)__s2);
    return 0;
  }
  else
  {
    v22 = *(_QWORD *)(a1[2] + 8 * v19);
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 72))(*(_QWORD *)(v22 + 80), a3, a4, a5, a6);
  }
}

uint64_t ParallelArchiveSort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  unint64_t st_size;
  uint64_t result;
  unsigned int v17;
  int v18;
  BOOL v19;
  const char *v20;
  int v21;
  BOOL v22;
  const char *v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  size_t v32;
  FILE **v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  int v40;
  _DWORD *v41;
  uint64_t *v42;
  uint64_t v43;
  int v44;
  uint64_t v46;
  char *v47;
  int v48;
  uint64_t v49;
  _DWORD *v50;
  int v51;
  FILE **v52;
  uint64_t v53;
  uint64_t v54;
  FILE *v55;
  int v56;
  unint64_t v57;
  unsigned int *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v62;
  _QWORD *v63;
  _DWORD *v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  int *v68;
  _QWORD *v69;
  char *v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  unint64_t v77;
  off_t v78;
  char v79;
  size_t v80;
  ssize_t v81;
  unint64_t v82;
  uint64_t v85;
  size_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char v90;
  _QWORD *v91;
  uint64_t v92;
  BOOL v93;
  char *__s;
  char *__sa;
  _QWORD v96[2];
  void *__base[2];
  void *v98[2];
  void *__buf[2];
  stat v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  _QWORD *v106;
  _QWORD v107[3];

  v107[1] = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v90);
  v9 = *(_DWORD *)a1;
  if (*(int *)a1 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ParallelArchiveSort:\n  input archive: %s\n", *(const char **)(a1 + 8));
  v106 = 0;
  v107[0] = 0;
  v104 = 0u;
  v105 = 0u;
  v102 = 0u;
  v103 = 0u;
  v101 = 0u;
  *(_OWORD *)__buf = 0u;
  memset(&v100, 0, sizeof(v100));
  *(_OWORD *)__base = 0u;
  *(_OWORD *)v98 = 0u;
  v96[1] = a1;
  v96[0] = 1;
  __buf[0] = malloc(0x100000uLL);
  if (!__buf[0])
  {
    v10 = *__error();
    v13 = "malloc";
    v14 = 116;
    goto LABEL_10;
  }
  if (stat(*(const char **)(a1 + 8), &v100))
  {
    v10 = *__error();
    v13 = *(const char **)(a1 + 8);
    v14 = 119;
LABEL_10:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Sort.c", (uint64_t)"ParallelArchiveSort", v14, 49, v10, v13, v11, v12, (char)v91);
    LODWORD(v96[0]) = 0;
    goto LABEL_11;
  }
  st_size = v100.st_size;
  if (loadFileSegment(*(const char **)(a1 + 8), v107, 6uLL, 0))
  {
    v13 = "Reading input file magic failed";
    v14 = 123;
    goto LABEL_9;
  }
  v18 = LODWORD(v107[0]) ^ 0x37303730 | WORD2(v107[0]) ^ 0x3130;
  if (v18)
  {
    v19 = LODWORD(v107[0]) == 925906736 && WORD2(v107[0]) == 14128;
    if (!v19)
    {
      v91 = v107;
      v13 = "Invalid input file: 'odc' or 'newc' raw cpio archive expected: %s";
      v14 = 125;
      goto LABEL_9;
    }
    v20 = 0;
  }
  else
  {
    v20 = "07070100000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000b00000000TRAILER!!!";
  }
  v21 = LODWORD(v107[0]) ^ 0x37303730 | WORD2(v107[0]) ^ 0x3730;
  v19 = v21 == 0;
  v22 = v21 != 0;
  if (v19)
    v23 = "0707070000000000000000000000000000000000010000000000000000000001300000000000TRAILER!!!";
  else
    v23 = v20;
  if (v18)
    v24 = v22;
  else
    v24 = 0;
  v25 = IFileStreamCreateWithFilename(*(const char **)(a1 + 8), 0, -1);
  if (!v25)
  {
    v13 = "Reading input file failed";
    v14 = 134;
    goto LABEL_9;
  }
  v31 = (char *)v25;
  *(_QWORD *)&v101 = 0x100000000;
  *(_QWORD *)&v102 = 0;
  v103 = 0u;
  *((_QWORD *)&v101 + 1) = IFileStreamRead;
  v105 = 0u;
  *((_QWORD *)&v102 + 1) = v25;
  *(_QWORD *)&v103 = indexBeginProc;
  *(_QWORD *)&v104 = indexPayloadAndPaddingProc;
  *((_QWORD *)&v104 + 1) = indexPayloadAndPaddingProc;
  v106 = v96;
  if (ParallelArchiveRead((uint64_t)&v101, v26, v27, v28, v29, v30, v11, v12))
  {
    v13 = "Indexing failed";
    v14 = 145;
    goto LABEL_9;
  }
  IFileStreamDestroy(v31);
  v32 = SLODWORD(__base[0]);
  v98[0] = malloc(4 * SLODWORD(__base[0]));
  if (!v98[0])
  {
    v10 = *__error();
    v13 = "malloc";
    v14 = 148;
    goto LABEL_10;
  }
  v33 = (FILE **)MEMORY[0x24BDAC8D8];
  v93 = v24;
  if (v9 >= 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  %llu B, %d entries\n", __buf[1], v32);
    v32 = SLODWORD(__base[0]);
  }
  qsort(__base[1], v32, 0x8A8uLL, (int (__cdecl *)(const void *, const void *))cmpINode);
  v34 = LODWORD(__base[0]);
  if (SLODWORD(__base[0]) >= 1)
  {
    v35 = 0;
    v36 = (char *)__base[1];
    v37 = (char *)__base[1] - 2184;
    do
    {
      v38 = &v36[2216 * v35];
      v39 = *((_QWORD *)v38 + 4);
      v40 = *((_DWORD *)v38 + 548);
      v41 = v38 + 2196;
      *((_DWORD *)v38 + 549) = v40;
      v42 = (uint64_t *)v37;
      v43 = v35;
      while (1)
      {
        v44 = v43;
        if (v43-- < 1)
          break;
        v46 = *v42;
        v42 -= 277;
        if (v46 != v39)
          goto LABEL_47;
      }
      v44 = 0;
LABEL_47:
      if (v35 != v44)
      {
        v47 = &v36[2216 * v44];
        v48 = *((_DWORD *)v47 + 549);
        if (v48 >= v40)
        {
          v49 = v44;
          if (v35 > v44)
          {
            v50 = v47 + 2196;
            do
            {
              ++v49;
              *v50 = v40;
              v50 += 554;
            }
            while (v35 != v49);
          }
        }
        else
        {
          *v41 = v48;
        }
      }
      ++v35;
      v37 += 2216;
    }
    while (v35 != v34);
  }
  v51 = v34;
  if (v9 > 1)
  {
    qsort(__base[1], (int)v34, 0x8A8uLL, (int (__cdecl *)(const void *, const void *))cmpIndex);
    v51 = (int)__base[0];
    if (SLODWORD(__base[0]) >= 1)
    {
      __s = (char *)v23;
      v52 = v33;
      v53 = 0;
      v54 = 2208;
      do
      {
        v55 = *v52;
        if (v53 == *(_DWORD *)((char *)__base[1] + v54 - 12))
          fprintf(v55, "%d ino=%llu size=%llu -- %s\n");
        else
          fprintf(v55, "%d HLINK(%d) ino=%llu size=%llu -- %s = %s\n");
        ++v53;
        v51 = (int)__base[0];
        v54 += 2216;
      }
      while (v53 < SLODWORD(__base[0]));
      v33 = v52;
      v23 = __s;
    }
  }
  qsort(__base[1], v51, 0x8A8uLL, (int (__cdecl *)(const void *, const void *))cmpSortPath);
  v56 = (int)__base[0];
  if (v9 >= 1)
  {
    if (SLODWORD(__base[0]) < 1)
      goto LABEL_71;
    v57 = 0;
    v58 = (unsigned int *)((char *)__base[1] + 2192);
    do
    {
      v59 = v57;
      v60 = *v58;
      ++v57;
      v58 += 554;
    }
    while (v59 == v60 && v57 < LODWORD(__base[0]));
    if (v59 == v60)
    {
LABEL_71:
      fwrite("Input archive is already sorted\n", 0x20uLL, 1uLL, *v33);
      v56 = (int)__base[0];
    }
  }
  if (v56 >= 1)
  {
    v62 = 0;
    v63 = __base[1];
    v64 = v98[0];
    do
    {
      v63[4] = -1;
      v64[*((int *)v63 + 548)] = v62++;
      v63 += 277;
    }
    while (v62 < SLODWORD(__base[0]));
    v65 = LODWORD(__base[0]);
    if (SLODWORD(__base[0]) >= 1)
    {
      v66 = 0;
      v67 = (char *)__base[1];
      v68 = (int *)v98[0];
      v69 = __base[1];
      do
      {
        v70 = &v67[2216 * v68[*((int *)v69 + 549)]];
        v73 = *((_QWORD *)v70 + 4);
        v72 = v70 + 32;
        v71 = v73;
        if (v73 == -1)
        {
          *v72 = v66;
          v71 = v66++;
        }
        v69[4] = v71;
        v69 += 277;
        --v65;
      }
      while (v65);
    }
  }
  LODWORD(v98[1]) = open(*(const char **)(a1 + 8), 0);
  if (((uint64_t)v98[1] & 0x80000000) != 0)
  {
    v10 = *__error();
    v13 = *(const char **)(a1 + 8);
    v14 = 225;
    goto LABEL_10;
  }
  if (SLODWORD(__base[0]) < 1)
  {
    v75 = 0;
  }
  else
  {
    v74 = 0;
    v75 = 0;
    __sa = (char *)v23;
    do
    {
      v76 = (char *)__base[1] + 2216 * v74;
      v77 = *((_QWORD *)v76 + 276);
      v78 = *((_QWORD *)v76 + 275);
      v92 = v74;
      if (v9 >= 2)
        fprintf(*v33, "%d (old=%d) ino=%llu size=%llu -- %s\n", v74, *((_DWORD *)__base[1] + 554 * v74 + 548), *((_QWORD *)v76 + 4), v77, v76 + 144);
      if (v77)
      {
        v79 = 0;
        do
        {
          if (v77 >= 0x100000)
            v80 = 0x100000;
          else
            v80 = v77;
          v81 = pread((int)v98[1], __buf[0], v80, v78);
          if (v81 < 0)
          {
            v10 = *__error();
            v13 = "read";
            v14 = 247;
            goto LABEL_10;
          }
          if (v81 != v80)
          {
            v13 = "truncated read";
            v14 = 248;
            goto LABEL_9;
          }
          if ((v79 & 1) == 0)
          {
            if (v80 <= 5)
            {
              v13 = "truncated header";
              v14 = 254;
              goto LABEL_9;
            }
            v82 = *((_QWORD *)v76 + 4);
            if (*(_DWORD *)__buf[0] == 925906736 && *((_WORD *)__buf[0] + 2) == 14128)
            {
              if (v82 >= 0x40000)
              {
                v13 = "inode index is too large";
                v14 = 257;
                goto LABEL_9;
              }
              if (v80 <= 0x4B)
              {
                v13 = "truncated header";
                v14 = 258;
                goto LABEL_9;
              }
              toOctal6((_BYTE *)__buf[0] + 12, v82);
            }
            else
            {
              if (*(_DWORD *)__buf[0] != 925906736 || *((_WORD *)__buf[0] + 2) != 12592)
              {
                v13 = "invalid header";
                v14 = 269;
                goto LABEL_9;
              }
              if (HIDWORD(v82))
              {
                v13 = "inode index is too large";
                v14 = 264;
                goto LABEL_9;
              }
              if (v80 <= 0x6D)
              {
                v13 = "truncated header";
                v14 = 265;
                goto LABEL_9;
              }
              toHex8((_BYTE *)__buf[0] + 6, v82);
            }
          }
          v85 = (*(uint64_t (**)(_QWORD, void *, size_t))(a1 + 16))(*(_QWORD *)(a1 + 24), __buf[0], v80);
          if (v85 < 0)
          {
            v13 = "write error";
            v14 = 275;
            goto LABEL_9;
          }
          if (v85 != v80)
          {
            v13 = "truncated write";
            v14 = 276;
            goto LABEL_9;
          }
          v78 += v80;
          v75 += v80;
          v79 = 1;
          v77 -= v80;
        }
        while (v77);
      }
      v74 = v92 + 1;
      v23 = __sa;
      v33 = (FILE **)MEMORY[0x24BDAC8D8];
    }
    while (v92 + 1 < SLODWORD(__base[0]));
  }
  if (!v93)
  {
    v86 = strlen(v23);
    v87 = (*(uint64_t (**)(_QWORD, const char *, size_t))(a1 + 16))(*(_QWORD *)(a1 + 24), v23, v86);
    if (v87 < 0)
    {
      v13 = "write error";
      v14 = 290;
      goto LABEL_9;
    }
    if (v87 != v86)
    {
      v13 = "truncated write";
      v14 = 291;
      goto LABEL_9;
    }
    v75 += v86;
  }
  if (v75 < st_size)
  {
    bzero(__buf[0], 0x100000uLL);
    while (1)
    {
      if (st_size - v75 >= 0x100000)
        v88 = 0x100000;
      else
        v88 = st_size - v75;
      v89 = (*(uint64_t (**)(_QWORD, void *, uint64_t))(a1 + 16))(*(_QWORD *)(a1 + 24), __buf[0], v88);
      if (v89 < 0)
      {
        v13 = "write error";
        v14 = 305;
        goto LABEL_9;
      }
      if (v89 != v88)
        break;
      v75 += v88;
      if (v75 >= st_size)
        goto LABEL_11;
    }
    v13 = "truncated write";
    v14 = 306;
LABEL_9:
    v10 = 0;
    goto LABEL_10;
  }
LABEL_11:
  if (((uint64_t)v98[1] & 0x80000000) == 0)
    close((int)v98[1]);
  free(__base[1]);
  free(v98[0]);
  free(__buf[0]);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (LODWORD(v96[0]))
    v17 = 0;
  else
    v17 = -1;
  if ((int)result >= 0)
    return v17;
  else
    return result;
}

uint64_t indexBeginProc(uint64_t a1, void *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t result;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  char v18;

  v9 = *(_DWORD *)(a1 + 16);
  v10 = *(int *)(a1 + 20);
  if (v9 < (int)v10)
  {
    v11 = *(char **)(a1 + 24);
LABEL_5:
    *(_DWORD *)(a1 + 16) = v9 + 1;
    v12 = &v11[2216 * v9];
    result = (uint64_t)memcpy(v12, __src, 0x890uLL);
    *((_DWORD *)v12 + 548) = *(_DWORD *)(a1 + 16) - 1;
    v14 = *(_QWORD *)(a1 + 56);
    *((_QWORD *)v12 + 275) = v14;
    *((_QWORD *)v12 + 276) = a6;
    *(_QWORD *)(a1 + 56) = v14 + a6;
    return result;
  }
  *(_DWORD *)(a1 + 20) = v10 + 10000;
  v11 = (char *)reallocf(*(void **)(a1 + 24), 2216 * (v10 + 10000));
  *(_QWORD *)(a1 + 24) = v11;
  if (v11)
  {
    v9 = *(_DWORD *)(a1 + 16);
    goto LABEL_5;
  }
  v15 = __error();
  result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Sort.c", (uint64_t)"indexBeginProc", 67, 49, *v15, "malloc", v16, v17, v18);
  *(_DWORD *)a1 = 0;
  return result;
}

uint64_t indexPayloadAndPaddingProc(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(result + 24) + 2216 * *(int *)(result + 16);
  *(_QWORD *)(v3 - 8) += a3;
  *(_QWORD *)(result + 56) += a3;
  return result;
}

uint64_t cmpINode(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a2 + 32);
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  else
    return v3 < v2;
}

uint64_t cmpIndex(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;

  v2 = *(_DWORD *)(a1 + 2192);
  v3 = *(_DWORD *)(a2 + 2192);
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  else
    return v3 < v2;
}

uint64_t cmpSortPath(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(a1 + 144), (const char *)(a2 + 144));
}

_BYTE *toOctal6(_BYTE *result, unint64_t a2)
{
  *result = toOctal6_oct[(a2 >> 15) & 7];
  result[1] = toOctal6_oct[(a2 >> 12) & 7];
  result[2] = toOctal6_oct[(a2 >> 9) & 7];
  result[3] = toOctal6_oct[(a2 >> 6) & 7];
  result[4] = toOctal6_oct[(a2 >> 3) & 7];
  result[5] = toOctal6_oct[a2 & 7];
  return result;
}

_BYTE *toHex8(_BYTE *result, unint64_t a2)
{
  *result = toHex8_hex[a2 >> 28];
  result[1] = toHex8_hex[(a2 >> 24) & 0xF];
  result[2] = toHex8_hex[(a2 >> 20) & 0xF];
  result[3] = toHex8_hex[(a2 >> 16) & 0xF];
  result[4] = toHex8_hex[(unsigned __int16)a2 >> 12];
  result[5] = toHex8_hex[(a2 >> 8) & 0xF];
  result[6] = toHex8_hex[a2 >> 4];
  result[7] = toHex8_hex[a2 & 0xF];
  return result;
}

char *ParallelArchiveOLDWriterCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v9;
  char *v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  int v17;
  uint64_t v19;
  int DefaultNThreads;
  char v21;
  char v22;

  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v21);
  v9 = (char *)calloc(1uLL, 0x608uLL);
  v10 = v9;
  if (!v9)
  {
    v17 = *__error();
    v15 = "malloc";
    v16 = 122;
    goto LABEL_12;
  }
  *((_DWORD *)v9 + 258) = *(_DWORD *)(a1 + 8);
  v11 = strlen(*(const char **)a1);
  *(_QWORD *)v10 = v11;
  if (v11 - 1024 >= 0xFFFFFFFFFFFFFBFFLL)
  {
    __strlcpy_chk();
    *((_QWORD *)v10 + 168) = 0x40000;
    v12 = malloc(0x40000uLL);
    *((_QWORD *)v10 + 171) = v12;
    if (v12)
    {
      if (pthread_mutex_init((pthread_mutex_t *)(v10 + 1464), 0))
      {
        v15 = "pthread_mutex_init";
        v16 = 138;
      }
      else
      {
        *((_DWORD *)v10 + 260) = 0;
        if (pthread_mutex_init((pthread_mutex_t *)(v10 + 1048), 0)
          || pthread_cond_init((pthread_cond_t *)(v10 + 1112), 0))
        {
          v15 = "SemInit";
          v16 = 141;
        }
        else
        {
          *((_DWORD *)v10 + 290) = 0;
          if (pthread_mutex_init((pthread_mutex_t *)(v10 + 1168), 0)
            || pthread_cond_init((pthread_cond_t *)(v10 + 1232), 0))
          {
            v15 = "SemInit";
            v16 = 142;
          }
          else if (pthread_mutex_init((pthread_mutex_t *)v10 + 20, 0))
          {
            v15 = "pthread_mutex_init";
            v16 = 143;
          }
          else
          {
            if (!writerReleaseSem((uint64_t)v10))
            {
              v19 = (uint64_t)(v10 + 1384);
              *((_DWORD *)v10 + 346) = 0;
              DefaultNThreads = *(_DWORD *)(a1 + 16);
              *((_DWORD *)v10 + 348) = *(_DWORD *)(a1 + 12);
              *((_QWORD *)v10 + 176) = writerReceiveData;
              *((_QWORD *)v10 + 178) = v10;
              *((_QWORD *)v10 + 179) = *(_QWORD *)(a1 + 32);
              *((_QWORD *)v10 + 181) = *(_QWORD *)(a1 + 48);
              if (!DefaultNThreads)
              {
                DefaultNThreads = getDefaultNThreads();
                v19 = (uint64_t)(v10 + 1384);
              }
              *((_DWORD *)v10 + 347) = DefaultNThreads;
              *((_QWORD *)v10 + 175) = *(_QWORD *)(a1 + 24);
              if (!createThread((pthread_t *)v10 + 182, (uint64_t)ParallelArchiveEncoderProc, v19, 0))
              {
                if ((leaveThreadErrorContext(0, 0, 0) & 0x80000000) == 0)
                  return v10;
                goto LABEL_14;
              }
              v17 = *__error();
              v15 = "compressor thread";
              v16 = 155;
              goto LABEL_12;
            }
            v15 = "writerReleaseSem";
            v16 = 144;
          }
        }
      }
      v17 = 0;
    }
    else
    {
      v17 = *__error();
      v15 = "malloc";
      v16 = 135;
    }
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterCreate", v16, 47, v17, v15, v13, v14, v22);
  }
  leaveThreadErrorContext(0, 0, 0);
LABEL_14:
  free(*((void **)v10 + 171));
  free(v10);
  return 0;
}

uint64_t writerReleaseSem(uint64_t a1)
{
  int v2;
  uint64_t v3;
  pthread_mutex_t *v4;
  int v5;
  pthread_cond_t *v6;
  int v7;

  v2 = *(_DWORD *)(a1 + 1032);
  v3 = *(_QWORD *)(a1 + 1360) - *(_QWORD *)(a1 + 1352);
  if (v3)
  {
    if (v2 >= 3)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Release bufferReady, buffer size: %zu\n", v3);
    v4 = (pthread_mutex_t *)(a1 + 1168);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1168)))
      return 0xFFFFFFFFLL;
    v7 = *(_DWORD *)(a1 + 1160);
    *(_DWORD *)(a1 + 1160) = v7 + 1;
    if (v7)
      goto LABEL_14;
    v6 = (pthread_cond_t *)(a1 + 1232);
    goto LABEL_12;
  }
  if (v2 >= 3)
    fwrite("Release bufferEmpty\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  v4 = (pthread_mutex_t *)(a1 + 1048);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1048)))
    return 0xFFFFFFFFLL;
  v5 = *(_DWORD *)(a1 + 1040);
  *(_DWORD *)(a1 + 1040) = v5 + 1;
  if (!v5)
  {
    v6 = (pthread_cond_t *)(a1 + 1112);
LABEL_12:
    if (pthread_cond_broadcast(v6))
      return 0xFFFFFFFFLL;
  }
LABEL_14:
  if (pthread_mutex_unlock(v4))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t writerReceiveData(uint64_t a1, void *a2, size_t a3)
{
  int v3;
  size_t v4;
  int v7;
  uint64_t v8;

  v3 = *(_DWORD *)(a1 + 1032);
  if (*(_DWORD *)(a1 + 1376))
  {
    if (v3 >= 3)
      fwrite("writerReceiveData: ZERO (end of stream)\n", 0x28uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    return 0;
  }
  else
  {
    v4 = a3;
    if (v3 >= 3)
      fwrite("Acquire bufferReady\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1168)))
      return -1;
    while (1)
    {
      v7 = *(_DWORD *)(a1 + 1160);
      if (v7 > 0)
        break;
      if (pthread_cond_wait((pthread_cond_t *)(a1 + 1232), (pthread_mutex_t *)(a1 + 1168)))
        return -1;
    }
    *(_DWORD *)(a1 + 1160) = v7 - 1;
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1168)))
      return -1;
    v8 = *(_QWORD *)(a1 + 1352);
    if (*(_QWORD *)(a1 + 1360) - v8 < v4)
      v4 = *(_QWORD *)(a1 + 1360) - v8;
    if (v4)
    {
      memcpy(a2, (const void *)(*(_QWORD *)(a1 + 1368) + v8), v4);
      *(_QWORD *)(a1 + 1352) += v4;
    }
    else
    {
      if (*(int *)(a1 + 1032) >= 3)
        fwrite("end of stream\n", 0xEuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
      *(_DWORD *)(a1 + 1376) = 1;
    }
    if (writerReleaseSem(a1))
    {
      return -1;
    }
    else if (*(int *)(a1 + 1032) >= 3)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "writerReceiveData: %zu\n", v4);
    }
  }
  return v4;
}

uint64_t ParallelArchiveEncoderProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  ParallelCompressionEncode(a1, a2, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t ParallelArchiveOLDWriterAddEntry(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  int v19;
  int v20;
  uint64_t result;
  unsigned int v22;
  int v23;
  ssize_t v24;
  unint64_t st_size;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  char *v36;
  uint64_t v37;
  __darwin_ino64_t *v38;
  int v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  _OWORD *v44;
  __int128 v45;
  uint64_t v46;
  size_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  size_t v51;
  ssize_t v52;
  size_t v53;
  ssize_t v54;
  char v55;
  char st_mode;
  char v57;
  stat v58;
  _BYTE v59[30];
  char __s[1024];
  char v61[1024];
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v55);
  memset(&v58, 0, sizeof(v58));
  bzero(v61, 0x400uLL);
  bzero(__s, 0x400uLL);
  if (!a1 || !a2)
  {
    v17 = "invalid args";
    v18 = 179;
LABEL_10:
    v19 = 0;
LABEL_11:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", v18, 47, v19, v17, v10, v11, st_mode);
    goto LABEL_12;
  }
  v12 = strlen(a2);
  if (*a2 == 47 || (v13 = v12, v12 >= 0x400))
  {
    st_mode = (char)a2;
    v17 = "invalid path: %s";
    v18 = 185;
    goto LABEL_10;
  }
  if (concatPath(v61, 0x400uLL, (char *)(a1 + 8), a2))
  {
LABEL_12:
    v20 = 0;
    goto LABEL_13;
  }
  if (lstat(v61, &v58))
  {
    v14 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 191, 47, v14, "%s", v15, v16, (char)v61);
    goto LABEL_12;
  }
  v20 = 0;
  if (HIWORD(v58.st_uid) || HIWORD(v58.st_gid))
    goto LABEL_13;
  v23 = v58.st_mode & 0xF000;
  if (v23 == 0x4000)
  {
    v26 = 0;
    st_size = 0;
    v27 = -1;
    v28 = 2;
    goto LABEL_48;
  }
  if (v23 == 0x8000)
  {
    st_size = v58.st_size;
    if (v58.st_nlink >= 2u)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1464)))
        goto LABEL_12;
      v29 = *(unsigned int *)(a1 + 1532);
      if ((int)v29 < 1)
      {
        LODWORD(v30) = 0;
      }
      else
      {
        v30 = 0;
        v31 = *(_QWORD **)(a1 + 1536);
        while (*v31 != v58.st_ino)
        {
          v31 += 129;
          if (v29 == ++v30)
            goto LABEL_38;
        }
      }
      if ((_DWORD)v30 != (_DWORD)v29)
      {
        __strlcpy_chk();
        st_size = strlen(__s);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
        v26 = 0;
        v27 = -1;
        v28 = 4;
        goto LABEL_48;
      }
LABEL_38:
      if ((_DWORD)v29 == *(_DWORD *)(a1 + 1528))
      {
        v35 = 2 * v29;
        if (!(_DWORD)v29)
          v35 = 16;
        *(_DWORD *)(a1 + 1528) = v35;
        v36 = (char *)reallocf(*(void **)(a1 + 1536), 1032 * v35);
        *(_QWORD *)(a1 + 1536) = v36;
        if (!v36)
        {
          *(_QWORD *)(a1 + 1528) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
          v19 = *__error();
          v17 = "malloc";
          v18 = 226;
          goto LABEL_11;
        }
      }
      else
      {
        v36 = *(char **)(a1 + 1536);
      }
      v37 = 129 * v29;
      bzero(&v36[8 * v37], 0x408uLL);
      v38 = (__darwin_ino64_t *)(*(_QWORD *)(a1 + 1536) + 8 * v37);
      *v38 = v58.st_ino;
      memcpy(v38 + 1, a2, v13);
      ++*(_DWORD *)(a1 + 1532);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
    }
    v39 = open(v61, 0);
    if (v39 < 0)
    {
      v48 = *__error();
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 261, 47, v48, "%s", v49, v50, (char)v61);
      goto LABEL_12;
    }
    v27 = v39;
    v26 = 1;
    v28 = 1;
    goto LABEL_48;
  }
  if (v23 != 40960)
  {
    st_mode = v58.st_mode;
    v17 = "unsupported entry type %d";
    v18 = 199;
    goto LABEL_10;
  }
  v24 = readlink(v61, __s, 0x3FFuLL);
  if (v24 < 1)
  {
    v32 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 252, 47, v32, "%s", v33, v34, (char)v61);
    goto LABEL_12;
  }
  st_size = v24;
  v26 = 0;
  __s[v24] = 0;
  v27 = -1;
  v28 = 3;
LABEL_48:
  *(_QWORD *)v59 = 0;
  *(_QWORD *)&v59[8] = 0;
  *(_QWORD *)&v59[22] = 0;
  *(_QWORD *)&v59[16] = 0;
  setHeaderFromValues_v10((uint64_t)v59, v28, st_size, v58.st_mtimespec.tv_sec, v58.st_flags, (unsigned __int16)v13, LOWORD(v58.st_uid), LOWORD(v58.st_gid), v58.st_mode);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1280)))
  {
    v40 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/MSUArchive.c", (uint64_t)"ParallelArchiveOLDWriterAddEntry", 295, 47, *v40, "pthread_mutex_lock", v41, v42, v57);
    v20 = 0;
  }
  else
  {
    if (!writerAcquireEmpty(a1))
    {
      *(_OWORD *)(a1 + 1352) = 0u;
      v44 = *(_OWORD **)(a1 + 1368);
      v45 = *(_OWORD *)v59;
      *(_OWORD *)((char *)v44 + 14) = *(_OWORD *)&v59[14];
      *v44 = v45;
      v46 = *(_QWORD *)(a1 + 1360) + 30;
      *(_QWORD *)(a1 + 1360) = v46;
      memcpy((void *)(*(_QWORD *)(a1 + 1368) + v46), a2, v13);
      v47 = *(_QWORD *)(a1 + 1360) + v13;
      *(_QWORD *)(a1 + 1360) = v47;
      if ((v28 - 3) > 1)
      {
        if (v26)
        {
          if (*(_QWORD *)(a1 + 1344) - v47 >= st_size)
            v51 = st_size;
          else
            v51 = *(_QWORD *)(a1 + 1344) - v47;
          v52 = read(v27, (void *)(*(_QWORD *)(a1 + 1368) + v47), v51);
          if (v52 < 0)
            goto LABEL_67;
          *(_QWORD *)(a1 + 1360) += v52;
          st_size -= v52;
        }
        v43 = 1;
      }
      else
      {
        memcpy((void *)(*(_QWORD *)(a1 + 1368) + v47), __s, st_size);
        *(_QWORD *)(a1 + 1360) += st_size;
        v43 = 1;
        st_size = 0;
      }
      while (!writerReleaseSem(a1))
      {
        if (!st_size)
          goto LABEL_52;
        if (writerAcquireEmpty(a1))
          break;
        *(_QWORD *)(a1 + 1352) = 0;
        *(_QWORD *)(a1 + 1360) = 0;
        if (*(_QWORD *)(a1 + 1344) >= st_size)
          v53 = st_size;
        else
          v53 = *(_QWORD *)(a1 + 1344);
        v54 = read(v27, *(void **)(a1 + 1368), v53);
        if (v54 < 0)
        {
LABEL_67:
          v43 = 0;
        }
        else
        {
          *(_QWORD *)(a1 + 1360) += v54;
          st_size -= v54;
        }
      }
    }
    v43 = 0;
LABEL_52:
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1280)))
      v20 = 0;
    else
      v20 = v43;
  }
  if ((v27 & 0x80000000) == 0)
    close(v27);
LABEL_13:
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v20)
    v22 = 0;
  else
    v22 = -1;
  if ((int)result >= 0)
    return v22;
  else
    return result;
}

uint64_t writerAcquireEmpty(uint64_t a1)
{
  int v2;

  if (*(int *)(a1 + 1032) >= 3)
    fwrite("Acquire bufferEmpty\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 1048)))
    return 0xFFFFFFFFLL;
  while (1)
  {
    v2 = *(_DWORD *)(a1 + 1040);
    if (v2 > 0)
      break;
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 1112), (pthread_mutex_t *)(a1 + 1048)))
      return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 1040) = v2 - 1;
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1048)))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t ParallelArchiveOLDWriterDestroy(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;
  _BOOL4 v10;
  _BOOL4 v11;
  int v12;
  int v13;
  _BOOL4 v14;
  _BOOL4 v15;
  unsigned int v16;
  BOOL v17;
  int v18;
  char v19;

  if (result)
  {
    v8 = result;
    enterThreadErrorContext(result, a2, a3, a4, a5, a6, a7, a8, v19);
    if (pthread_mutex_lock((pthread_mutex_t *)(v8 + 1048)))
    {
LABEL_5:
      v10 = 0;
    }
    else
    {
      while (1)
      {
        v9 = *(_DWORD *)(v8 + 1040);
        if (v9 > 0)
          break;
        if (pthread_cond_wait((pthread_cond_t *)(v8 + 1112), (pthread_mutex_t *)(v8 + 1048)))
          goto LABEL_5;
      }
      *(_DWORD *)(v8 + 1040) = v9 - 1;
      v10 = pthread_mutex_unlock((pthread_mutex_t *)(v8 + 1048)) == 0;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(v8 + 1168))
      || (v12 = *(_DWORD *)(v8 + 1160), *(_DWORD *)(v8 + 1160) = v12 + 1, !v12)
      && pthread_cond_broadcast((pthread_cond_t *)(v8 + 1232)))
    {
      v11 = 0;
    }
    else if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 1168)))
    {
      v11 = 0;
    }
    else
    {
      v11 = v10;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(v8 + 1048)))
    {
LABEL_15:
      v14 = 0;
    }
    else
    {
      while (1)
      {
        v13 = *(_DWORD *)(v8 + 1040);
        if (v13 > 0)
          break;
        if (pthread_cond_wait((pthread_cond_t *)(v8 + 1112), (pthread_mutex_t *)(v8 + 1048)))
          goto LABEL_15;
      }
      *(_DWORD *)(v8 + 1040) = v13 - 1;
      if (pthread_mutex_unlock((pthread_mutex_t *)(v8 + 1048)))
        v14 = 0;
      else
        v14 = v11;
    }
    joinThread(*(_opaque_pthread_t **)(v8 + 1456));
    if (pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1048)))
    {
      v15 = 0;
    }
    else if (pthread_cond_destroy((pthread_cond_t *)(v8 + 1112)))
    {
      v15 = 0;
    }
    else
    {
      v15 = v14;
    }
    if (pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1168)))
    {
      v16 = -1;
    }
    else
    {
      if (pthread_cond_destroy((pthread_cond_t *)(v8 + 1232)))
        v17 = 1;
      else
        v17 = !v15;
      v18 = v17;
      v16 = v18 << 31 >> 31;
    }
    pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1464));
    pthread_mutex_destroy((pthread_mutex_t *)(v8 + 1280));
    free(*(void **)(v8 + 1536));
    free(*(void **)(v8 + 1368));
    free((void *)v8);
    LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
    if ((int)result >= 0)
      return v16;
    else
      return result;
  }
  return result;
}

uint64_t forceInPlaceControls(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  unint64_t v8;
  size_t v9;
  _DWORD *v10;
  char *v11;
  char *v12;
  BOOL v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  unint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  unint64_t v44;
  int v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  FILE **v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  int v56;
  uint64_t v57;
  _DWORD *v58;
  uint64_t v59;
  BOOL v60;
  unint64_t v61;
  unint64_t v62;
  int64x2_t v63;
  int64x2_t *v64;
  int64x2_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  int v71;
  unint64_t v72;
  int64x2_t v73;
  unint64_t v74;
  int64x2_t v75;
  uint64_t v76;
  uint64_t v78;
  char v80;
  char *v81;
  uint64_t v82;
  unint64_t v83;
  int64x2_t v84;
  int64x2_t v85;
  unint64_t v86;
  int64x2_t v87;
  int64x2_t v88;

  if (a1 <= a2)
    v8 = a2;
  else
    v8 = a1;
  v9 = ((v8 + 4095) >> 12) + 16;
  if (a5 >= 3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Post-processing ctrl for in-place patching, %u pages\n", v9);
  v10 = calloc(v9, 4uLL);
  v11 = (char *)calloc(v9, 4uLL);
  v12 = v11;
  if (v10)
    v13 = v11 == 0;
  else
    v13 = 1;
  if (!v13)
  {
    if (a4)
    {
      v19 = 0;
      v20 = 0;
      v21 = v9;
      do
      {
        v22 = (unint64_t *)(a3 + 24 * v19);
        v23 = *v22;
        if ((*v22 & 0x8000000000000000) != 0)
          v23 = 0x8000000000000000 - *v22;
        v24 = v22[2];
        if (v24 < 0)
          v24 = 0x8000000000000000 - v24;
        v25 = v20 >> 12;
        if (v23)
          v26 = ((v20 + v23 - 1) >> 12) - (v20 >> 12) + 1;
        else
          v26 = 0;
        v27 = (v26 + v25);
        if (v27 > v25)
        {
          v28 = &v10[v25];
          v29 = v27 - v25;
          do
          {
            v21 = (__PAIR64__(v21, (*v28++)++) - 1) >> 32;
            --v29;
          }
          while (v29);
        }
        v20 += v23 + v24;
        ++v19;
      }
      while (v19 != a4);
    }
    else
    {
      v21 = v9;
    }
    if (a5 > 1)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "After input pages retained, %u free pages\n", v21);
    if (a4)
    {
      v30 = 0;
      v31 = 0;
      v32 = 0;
      v33 = v21;
      do
      {
        v34 = (unint64_t *)(a3 + 24 * v30);
        v35 = v34[1];
        v36 = 0x8000000000000000 - *v34;
        if ((*v34 & 0x8000000000000000) == 0)
          v36 = *v34;
        v37 = 0x8000000000000000 - v35;
        if (v35 >= 0)
          v37 = v34[1];
        v38 = v34[2];
        if (v38 < 0)
          v38 = 0x8000000000000000 - v38;
        if (v36)
        {
          v39 = v36 + v31;
          do
          {
            v40 = (v31 & 0xFFFFFFFFFFFFF000) + 4096;
            if (v40 >= v39)
              v40 = v39;
            v41 = v32 >> 12;
            v42 = v40 - v31;
            if (v40 == v31)
              v43 = 0;
            else
              v43 = ((v32 + v42 - 1) >> 12) - v41 + 1;
            v44 = v31 >> 12;
            v45 = v10[v44] - 1;
            v10[v44] = v45;
            if (!v45)
              ++v21;
            v46 = (v43 + v41);
            if (v46 > v41)
            {
              v47 = &v12[4 * v41];
              v48 = v46 - v41;
              do
              {
                v21 = (__PAIR64__(v21, (*(_DWORD *)v47)++) - 1) >> 32;
                v47 += 4;
                --v48;
              }
              while (v48);
            }
            v32 += v42;
            if (v21 < v33)
              v33 = v21;
            v31 = v40;
            v36 -= v42;
          }
          while (v36);
        }
        else
        {
          v40 = v31;
        }
        v31 = v40 + v38;
        v32 += v37;
        ++v30;
      }
      while (v30 != a4);
    }
    else
    {
      v33 = v21;
    }
    if (a5 > 2)
    {
      v49 = (FILE **)MEMORY[0x24BDAC8D8];
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Free pages after diff controls: %u\n", v21);
      fprintf(*v49, "Min free pages reached: %d\n", v33);
    }
    bzero(v10, 4 * v9);
    if (a4)
    {
      v50 = 0;
      v51 = 0;
      do
      {
        v52 = (unint64_t *)(a3 + 24 * v50);
        v53 = *v52;
        if ((*v52 & 0x8000000000000000) != 0)
          v53 = 0x8000000000000000 - *v52;
        v54 = v52[2];
        if (v54 < 0)
          v54 = 0x8000000000000000 - v54;
        v55 = v51 >> 12;
        if (v53)
          v56 = ((v51 + v53 - 1) >> 12) - (v51 >> 12) + 1;
        else
          v56 = 0;
        v57 = (v56 + v55);
        if (v57 > v55)
        {
          v58 = &v10[v55];
          v59 = v57 - v55;
          do
          {
            ++*v58++;
            --v59;
          }
          while (v59);
        }
        v51 += v53 + v54;
        ++v50;
      }
      while (v50 != a4);
      v60 = v33 < 4;
      v81 = v12;
      if (v33 <= 3)
      {
        v82 = a3;
        v83 = a4;
        v61 = 0;
        v62 = 0;
        v63 = vdupq_n_s64(0x8000000000000000);
        v84 = v63;
        do
        {
          v64 = (int64x2_t *)(v82 + 24 * v61);
          v65 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*v64), (int8x16_t)vsubq_s64(v63, *v64), *(int8x16_t *)v64);
          v66 = v64[1].i64[0];
          if (v66 >= 0)
            v67 = v64[1].i64[0];
          else
            v67 = 0x8000000000000000 - v66;
          if (a5 >= 3)
          {
            v87 = v65;
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ctrl[%zu]: ndiff=%llu nlit=%llu\n", v61, v65.i64[0], v65.i64[1]);
            v65 = v87;
            v63 = v84;
          }
          v68 = v65.i64[0];
          if (v65.i64[0])
          {
            do
            {
              v69 = v65.i64[0] + v62;
              v70 = (v65.i64[0] + v62 - 1) & 0xFFFFFFFFFFFFF000;
              if (v70 <= v62)
                v70 = v62;
              v71 = v10[(v70 >> 12)] - 1;
              v10[(v70 >> 12)] = v71;
              if (!v71)
                ++v33;
              v72 = v69 - v70;
              v73 = vdupq_n_s64(v69 - v70);
              v74 = vsubq_s64(v65, v73).u64[0];
              if (a5 >= 3)
              {
                v88 = v65;
                v85 = v73;
                v86 = v74;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ctrl[%zu]: moving %llu bytes from diff to lit (minFree=%d, ndiff=%llu)\n", v61, v72, v33, v74);
                v73 = v85;
                v74 = v86;
                v65 = v88;
                v63 = v84;
              }
              v75 = vaddq_s64(v65, v73);
              v65.i64[0] = v74;
              v65.i64[1] = v75.i64[1];
              v67 += v72;
              *(int8x16_t *)v64 = vbslq_s8((int8x16_t)vcltzq_s64(v65), (int8x16_t)vsubq_s64(v63, v65), (int8x16_t)v65);
              v76 = 0x8000000000000000 - v67;
              if (v67 >= 0)
                v76 = v67;
              v64[1].i64[0] = v76;
              v68 = v74;
            }
            while (v33 <= 3 && v74 != 0);
          }
          ++v61;
          v60 = v33 < 4;
          if (v61 >= v83)
            break;
          v62 += v68 + v67;
        }
        while (v33 <= 3);
      }
      v12 = v81;
      if (v60)
        goto LABEL_96;
    }
    else if (v33 < 4)
    {
LABEL_96:
      v80 = 4;
      v17 = "Could not reduce minFree to %d, something is wrong";
      v18 = 264;
      v14 = 0;
      goto LABEL_97;
    }
    v78 = 0;
    goto LABEL_100;
  }
  v14 = *__error();
  v17 = "malloc";
  v18 = 139;
LABEL_97:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"forceInPlaceControls", v18, 53, v14, v17, v15, v16, v80);
  v78 = 0xFFFFFFFFLL;
LABEL_100:
  free(v10);
  free(v12);
  return v78;
}

_QWORD *initDiffSegmentVector(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

uint64_t reserveDiffSegmentVector(uint64_t a1, unint64_t a2)
{
  void *v3;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  if (*(_QWORD *)(a1 + 8) >= a2)
    return 0;
  *(_QWORD *)(a1 + 8) = a2;
  v3 = reallocf(*(void **)(a1 + 16), 24 * a2);
  *(_QWORD *)(a1 + 16) = v3;
  if (v3)
    return 0;
  v5 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"reserveDiffSegmentVector", 327, 53, *v5, "reallocf", v6, v7, v8);
  return 0xFFFFFFFFLL;
}

__n128 pushDiffSegment(unint64_t *a1, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  __n128 result;
  unint64_t v8;
  __n128 *v9;

  if (!a2[1].n128_u64[0])
    return result;
  v4 = *a1;
  v5 = a1[1];
  if (*a1 < v5)
  {
LABEL_10:
    v8 = a1[2];
    *a1 = v4 + 1;
    v9 = (__n128 *)(v8 + 24 * v4);
    result = *a2;
    v9[1].n128_u64[0] = a2[1].n128_u64[0];
    *v9 = result;
    return result;
  }
  if (v5)
    v6 = v5 + (v5 >> 1);
  else
    v6 = 64;
  if (!reserveDiffSegmentVector((uint64_t)a1, v6))
  {
    v4 = *a1;
    goto LABEL_10;
  }
  return result;
}

uint64_t pushControls(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v9;
  unint64_t *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  int v19;
  __n128 v21;
  unint64_t v22;

  if (a3)
  {
    v9 = 0;
    v10 = (unint64_t *)(a2 + 16);
    v11 = 1;
    do
    {
      v12 = *(v10 - 2);
      v13 = *(v10 - 1);
      if (v12 >= 0)
        v14 = *(v10 - 2);
      else
        v14 = 0x8000000000000000 - v12;
      if (v13 >= 0)
        v15 = *(v10 - 1);
      else
        v15 = 0x8000000000000000 - v13;
      if ((*v10 & 0x8000000000000000) == 0)
        v16 = *v10;
      else
        v16 = 0x8000000000000000 - *v10;
      v21.n128_u64[0] = a5;
      v21.n128_u64[1] = a4;
      v22 = v14;
      pushDiffSegment(a1, &v21);
      if (v17)
        break;
      v18 = v14 + a5;
      v21.n128_u64[0] = v18;
      v21.n128_u64[1] = -1;
      v22 = v15;
      pushDiffSegment(a1, &v21);
      if (v19)
        break;
      v10 += 3;
      a4 += v14 + v16;
      a5 = v18 + v15;
      v11 = ++v9 < a3;
    }
    while (a3 != v9);
  }
  else
  {
    v11 = 0;
  }
  return (v11 << 31 >> 31);
}

uint64_t mergeDiffSegmentVectors(unint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  size_t v24;
  char *v25;
  size_t v26;
  unint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  size_t v31;
  char *v32;
  int v33;
  int v34;
  char *v35;
  char *v36;
  int v37;
  const char *v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  int v48;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  __n128 v59;
  unint64_t v60;
  __int128 v61;
  void *v62;

  if (!a1)
    return 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v61 = 0uLL;
  v62 = 0;
  do
  {
    v14 = &a2[3 * v13];
    v15 = *v14;
    if (!*v14)
    {
      v38 = "empty segment vector";
      v39 = 429;
LABEL_62:
      v37 = 0;
LABEL_32:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"mergeDiffSegmentVectors", v39, 53, v37, v38, a7, a8, v56);
      goto LABEL_33;
    }
    v16 = (_QWORD *)(v14[2] + 16);
    do
    {
      if (v10 + 4 > v11)
      {
        v11 += 0x4000;
        v12 = (char *)reallocf(v12, 16 * v11);
        if (!v12)
        {
          v37 = *__error();
          v38 = "malloc";
          v39 = 437;
          goto LABEL_32;
        }
      }
      v17 = *(v16 - 2);
      if (*(v16 - 1) == -1)
      {
        v21 = *v16 + v17;
        v20 = v10 + 1;
        v22 = &v12[16 * v10];
        *(_QWORD *)v22 = v17;
        *((_QWORD *)v22 + 1) = 1;
        v19 = &v12[16 * v10 + 16];
        *(_QWORD *)v19 = v21;
        v18 = -1;
      }
      else
      {
        v18 = 0;
        v19 = &v12[16 * v10];
        *(_QWORD *)v19 = v17;
        v20 = v10;
      }
      *((_DWORD *)v19 + 2) = v18;
      *((_DWORD *)v19 + 3) = 0;
      v10 = v20 + 1;
      v16 += 3;
      --v15;
    }
    while (v15);
    ++v13;
  }
  while (v13 != a1);
  v23 = a2[2] + 24 * *a2;
  v24 = v20 + 2;
  v25 = &v12[16 * v10];
  *(_QWORD *)v25 = *(_QWORD *)(v23 - 8) + *(_QWORD *)(v23 - 24);
  *((_QWORD *)v25 + 1) = 0;
  qsort(v12, v24, 0x10uLL, (int (__cdecl *)(const void *, const void *))mergeDiffSegmentEventCompareProc);
  if (v24)
  {
    v26 = 0;
    v27 = 0;
    v28 = 0;
    while (1)
    {
      v29 = 0;
      v30 = *(_QWORD *)&v12[16 * v26];
      if (v24 <= v26 + 1)
        v31 = v26 + 1;
      else
        v31 = v24;
      v32 = &v12[16 * v26 + 8];
      while (*((_QWORD *)v32 - 1) == v30)
      {
        v33 = *(_DWORD *)v32;
        v32 += 16;
        v29 += v33;
        if (v31 == ++v26)
        {
          v26 = v31;
          break;
        }
      }
      if (v29 | v28)
      {
        if (!v29)
          goto LABEL_28;
        if (!v28)
        {
          v36 = &v12[16 * v27];
          *(_QWORD *)v36 = v30;
          *((_DWORD *)v36 + 2) = 1;
          ++v27;
        }
        v28 += v29;
        if (v28)
          goto LABEL_28;
        v34 = -1;
      }
      else
      {
        v34 = 0;
      }
      v28 = 0;
      v35 = &v12[16 * v27];
      *(_QWORD *)v35 = v30;
      *((_DWORD *)v35 + 2) = v34;
      ++v27;
LABEL_28:
      if (v26 >= v24)
        goto LABEL_39;
    }
  }
  v27 = 0;
LABEL_39:
  v42 = 0;
  if (a1 <= 1)
    v43 = 1;
  else
    v43 = a1;
  v56 = v43;
  while (1)
  {
    v44 = &a2[3 * v42];
    v45 = *v44;
    v58 = v44[2];
    if (reserveDiffSegmentVector((uint64_t)&v61, v27))
      break;
    v57 = v42;
    if (v27)
    {
      v46 = 0;
      v47 = 0;
      v48 = 0;
      v49 = 0;
      while (1)
      {
        v50 = (unint64_t *)&v12[16 * v46];
        v51 = *v50;
        if (v49 < v45)
        {
          v52 = (_QWORD *)(v58 + 16 + 24 * v49);
          while (*v52 + *(v52 - 2) < v51)
          {
            v52 += 3;
            if (v45 == ++v49)
              goto LABEL_61;
          }
        }
        if (v49 == v45)
          break;
        if (v46)
        {
          if (v48)
            v53 = -1;
          else
            v53 = *(_QWORD *)(v58 + 24 * v49 + 8) + v47 - *(_QWORD *)(v58 + 24 * v49);
          v59.n128_u64[0] = v47;
          v59.n128_u64[1] = v53;
          v60 = v51 - v47;
          pushDiffSegment((unint64_t *)&v61, &v59);
          v47 = *v50;
        }
        else
        {
          v47 = *v50;
        }
        v48 += *(_DWORD *)&v12[16 * v46++ + 8];
        if (v46 == v27)
          goto LABEL_59;
      }
LABEL_61:
      v38 = "no overlapping segment found";
      v39 = 539;
      goto LABEL_62;
    }
LABEL_59:
    v54 = v61;
    v55 = reallocToFit(v62, 24 * v61);
    *((_QWORD *)&v61 + 1) = v54;
    v62 = v55;
    free((void *)v44[2]);
    *(_OWORD *)v44 = v61;
    v44[2] = (unint64_t)v62;
    v62 = 0;
    v61 = 0uLL;
    v42 = v57 + 1;
    if (v57 + 1 == v56)
    {
      v40 = 0;
      goto LABEL_34;
    }
  }
LABEL_33:
  v40 = 0xFFFFFFFFLL;
LABEL_34:
  free(v12);
  free(v62);
  return v40;
}

uint64_t mergeDiffSegmentEventCompareProc(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)a1 < *(_QWORD *)a2)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)a2 >= *(_QWORD *)a1)
    return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
  return 1;
}

uint64_t getComboControlsFromMergedDiffSegmentVectors(char *a1, uint64_t *a2, _QWORD *a3, uint64_t *a4)
{
  size_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  int v21;
  uint64_t *v22;
  _QWORD *v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  BOOL v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  __int16 v38;
  uint64_t v39;
  char v41;

  if (!a1)
  {
    v16 = 0;
LABEL_39:
    v39 = 0;
    goto LABEL_40;
  }
  v7 = (size_t)a1;
  v8 = *a2;
  v9 = a1 + 2;
  v10 = (char *)calloc((size_t)&v9[(_QWORD)v9 * *a2], 8uLL);
  if (v10)
  {
    v11 = calloc(v7, 8uLL);
    if (v11)
    {
      if (v8)
      {
        v12 = 0;
        v15 = a2[2];
        v14 = a2 + 2;
        v13 = v15;
        v16 = 1;
        while (1)
        {
          v17 = (uint64_t *)&v10[8 * v16 * (_QWORD)v9];
          v18 = (uint64_t *)&v10[8 * (v16 - 1) * (_QWORD)v9];
          v19 = *(_QWORD *)(v13 + 24 * v12 + 16);
          if (*(_QWORD *)(v13 + 24 * v12 + 8) == -1)
          {
            if (v19 < 0)
              v19 = 0x8000000000000000 - v19;
            if (!v18[1])
            {
              v18[1] = v19;
              goto LABEL_25;
            }
            v17[1] = v19;
          }
          else
          {
            v20 = (uint64_t *)&v10[8 * (_QWORD)v9 * (v16 - 1) + 16];
            v21 = 1;
            v22 = v14;
            v23 = v11;
            v24 = v7;
            do
            {
              v25 = *v22;
              v22 += 3;
              v26 = *(_QWORD *)(v25 + 24 * v12 + 8);
              v27 = v26 - *v23;
              if (v26 != *v23)
                v21 = 0;
              *v23++ = v26 + v19;
              v28 = 0x8000000000000000 - v27;
              if (v27 >= 0)
                v28 = v27;
              *v20++ = v28;
              --v24;
            }
            while (v24);
            if (v21)
            {
              v29 = v18[1];
              if (v29 < 0)
                v29 = 0x8000000000000000 - v29;
              if (!v29)
              {
                v31 = *v18;
                if (*v18 < 0)
                  v31 = 0x8000000000000000 - *v18;
                v32 = __OFADD__(v31, v19);
                v33 = v31 + v19;
                if (v33 < 0 != v32)
                  v33 = 0x8000000000000000 - v33;
                *v18 = v33;
                goto LABEL_25;
              }
            }
            v30 = 0x8000000000000000 - v19;
            if (v19 >= 0)
              v30 = v19;
            *v17 = v30;
          }
          ++v16;
LABEL_25:
          if (++v12 == v8)
            goto LABEL_38;
        }
      }
      v16 = 1;
LABEL_38:
      free(v11);
      a1 = (char *)reallocToFit(v10, 8 * (_QWORD)v9 * v16);
      goto LABEL_39;
    }
    v34 = *__error();
    v37 = "calloc ipos";
    v38 = 600;
  }
  else
  {
    v34 = *__error();
    v37 = "calloc controls";
    v38 = 596;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/BXDiffControls.c", (uint64_t)"getComboControlsFromMergedDiffSegmentVectors", v38, 53, v34, v37, v35, v36, v41);
  free(v10);
  a1 = 0;
  v16 = 0;
  v39 = 0xFFFFFFFFLL;
LABEL_40:
  *a3 = a1;
  *a4 = v16;
  return v39;
}

uint64_t rawimg_force_in_place(_QWORD *a1, unint64_t *a2, _QWORD *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  AAByteStream_impl *v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  AAByteStream_impl *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t **v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  AAByteStream_impl *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  int v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t i;
  uint64_t v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t *v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  BOOL v70;
  int v71;
  int v72;
  unint64_t v73;
  int v74;
  uint64_t v75;
  unint64_t v76;
  int64x2_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int8x16_t *v82;
  int64x2_t v83;
  int64x2_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  int64x2_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  int64x2_t v96;
  const char *v97;
  __int16 v98;
  const char *v99;
  __int16 v100;
  const char *v101;
  __int16 v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  const char *v124;
  __int16 v125;
  __int16 v126;
  _QWORD *v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t *v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _QWORD *v135;
  uint64_t v136;
  _QWORD *v137;
  uint64_t v138;
  __int128 v139;
  _QWORD *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  char v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  int64x2_t v150;
  int v151;
  int64x2_t v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  AAByteStream_impl *v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  unint64_t v164;
  int v165;
  unint64_t v166;
  int64x2_t v167;
  AAByteStream_impl *v168;
  uint64_t v169;
  unint64_t *v170;
  _QWORD *v171;

  if (*(_QWORD *)(a4 + 2120) <= a3[265])
    v12 = a3[265];
  else
    v12 = *(_QWORD *)(a4 + 2120);
  v15 = AAFileStreamOpenWithPath(*(const char **)(a4 + 2048), 0, 0);
  if (!v15)
  {
    v99 = "AAFileStreamOpenWithPath";
    v100 = 234;
LABEL_121:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v100, 141, 0, v99, v13, v14, v145);
    v43 = 0;
    v40 = 0;
    v33 = 0;
    v30 = 0;
    v17 = 0;
LABEL_122:
    v110 = 0;
    goto LABEL_123;
  }
  v16 = (unint64_t)(a5 + 0x3FFF) >> 14;
  v17 = (uint64_t *)calloc(1uLL, 0x68uLL);
  v18 = calloc(1uLL, 0x28uLL);
  v21 = v18;
  if ((v16 & 0x80000000) != 0)
  {
    v101 = "too little excess";
    v102 = 184;
LABEL_120:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"aaSimStreamOpen", v102, 141, 0, v101, v19, v20, v145);
    free(v17);
    SimStreamClose((uint64_t)v21, v103, v104, v105, v106, v107, v108, v109);
    v99 = "aaSimStreamOpen";
    v100 = 236;
    goto LABEL_121;
  }
  if (!v17 || !v18)
  {
    v101 = "aaCalloc";
    v102 = 185;
    goto LABEL_120;
  }
  *v18 = v15;
  *((_DWORD *)v18 + 4) = (unint64_t)(v12 + 0x3FFF) >> 14;
  *((_DWORD *)v18 + 8) = v16;
  *((_DWORD *)v18 + 9) = a6;
  if (((v12 + 0x3FFF) & 0x200000000000) != 0)
  {
    *__error() = 12;
    v21[1] = 0;
    goto LABEL_119;
  }
  v22 = calloc(((unint64_t)(v12 + 0x3FFF) >> 14), 5uLL);
  v21[1] = v22;
  if (!v22)
  {
LABEL_119:
    v101 = "aaCalloc";
    v102 = 195;
    goto LABEL_120;
  }
  AACustomByteStreamSetData((AAByteStream)v17, v21);
  AACustomByteStreamSetCloseProc((AAByteStream)v17, (AAByteStreamCloseProc)SimStreamClose);
  AACustomByteStreamSetPReadProc((AAByteStream)v17, (AAByteStreamPReadProc)SimStreamPRead);
  AACustomByteStreamSetPWriteProc((AAByteStream)v17, (AAByteStreamPWriteProc)SimStreamPWrite);
  v17[11] = (uint64_t)SimStreamSimulate;
  v23 = *v17;
  v24 = aaSegmentStreamOpen(v17, a3);
  v30 = (AAByteStream_impl *)v24;
  if (!v24)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 241, 141, 0, "aaSegmentStreamOpen", v28, v29, v145);
    v43 = 0;
    v40 = 0;
    v33 = 0;
    goto LABEL_122;
  }
  v33 = aaForkInputStreamOpen(v24, (uint64_t)a3, 0, v25, v26, v27, v28, v29);
  if (!v33)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 243, 141, 0, "aaForkInputStreamOpen", v31, v32, v145);
    v43 = 0;
    v40 = 0;
    goto LABEL_122;
  }
  v34 = aaSegmentStreamOpen(v17, (_QWORD *)a4);
  v40 = (AAByteStream_impl *)v34;
  if (!v34)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 247, 141, 0, "aaSegmentStreamOpen", v38, v39, v145);
    v43 = 0;
    goto LABEL_122;
  }
  v169 = v23;
  v43 = aaForkInputStreamOpen(v34, a4, 0, v35, v36, v37, v38, v39);
  if (!v43)
  {
    v97 = "aaForkOutputStreamOpen";
    v98 = 249;
LABEL_142:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v98, 141, 0, v97, v41, v42, v145);
    goto LABEL_122;
  }
  v154 = 0;
  v152 = vdupq_n_s64(0x8000000000000000);
  v151 = 1;
  v171 = a1;
  v168 = v40;
  v153 = a6;
  v170 = a2;
  while (2)
  {
    bzero(*(void **)(v169 + 8), 5 * *(int *)(v169 + 16));
    v44 = *(_DWORD *)(v169 + 16);
    *(_QWORD *)(v169 + 24) = 0;
    *(_DWORD *)(v169 + 20) = v44;
    v45 = *a2;
    if (*a2)
    {
      v46 = 0;
      v47 = 0;
      do
      {
        v48 = (unint64_t *)(*a1 + 24 * v47);
        if ((*v48 & 0x8000000000000000) == 0)
          v49 = *v48;
        else
          v49 = 0x8000000000000000 - *v48;
        v50 = v48[2];
        v51 = 0x8000000000000000 - v50;
        if (v50 >= 0)
          v51 = v50;
        if (v49)
        {
          v161 = v51;
          v164 = v47;
          for (i = 0; i < v49; i += v53)
          {
            if (v49 - i >= 0x10000)
              v53 = 0x10000;
            else
              v53 = v49 - i;
            if (v53 != aaByteStreamSimulate(v33))
            {
              v124 = "aaByteStreamSimulate";
              v125 = 270;
              goto LABEL_144;
            }
          }
          a1 = v171;
          v45 = *v170;
          v51 = v161;
          v47 = v164;
        }
        v46 += v49 + v51;
        ++v47;
      }
      while (v47 < v45);
    }
    v54 = 1;
    v55 = v45;
    v156 = v30;
    do
    {
      if (!v55)
        goto LABEL_59;
      v56 = 0;
      v57 = 0;
      v58 = 0;
      v165 = v54;
      do
      {
        v59 = (unint64_t *)(*v171 + 24 * v56);
        v60 = v59[1];
        v61 = 0x8000000000000000 - *v59;
        if ((*v59 & 0x8000000000000000) == 0)
          v61 = *v59;
        if (v60 >= 0)
          v62 = v59[1];
        else
          v62 = 0x8000000000000000 - v60;
        v63 = v59[2];
        if (v63 < 0)
          v63 = 0x8000000000000000 - v63;
        if (v54 == 2)
        {
          v57 += v61;
          if (v57 < *(_QWORD *)(a4 + 2056))
            goto LABEL_57;
        }
        else
        {
          v157 = v63;
          v159 = v62;
          v162 = v56;
          if (v61)
          {
            v64 = 0;
            while (1)
            {
              v65 = v61;
              if (v61 - v64 >= 0x10000)
                v66 = 0x10000;
              else
                v66 = v61 - v64;
              if (v66 != aaByteStreamSimulate(v33))
              {
                v126 = 298;
                goto LABEL_148;
              }
              if (v66 != aaByteStreamSimulate(v43))
                break;
              v58 += v66;
              v57 += v66;
              v64 += v66;
              v61 = v65;
              if (v64 >= v65)
                goto LABEL_52;
            }
            v126 = 299;
LABEL_148:
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v126, 141, 0, "aaByteStreamSimulate", v41, v42, v145);
            v110 = 0;
            v40 = v168;
            v30 = v156;
            goto LABEL_123;
          }
LABEL_52:
          v58 += v157;
          v54 = v165;
          if (v165 == 1)
          {
            v56 = v162;
            v62 = v159;
            v30 = v156;
            if (v57 >= *(_QWORD *)(a4 + 2056))
              goto LABEL_57;
          }
          else
          {
            v56 = v162;
            v62 = v159;
            v30 = v156;
          }
        }
        v67 = aaByteStreamSimulate(v43);
        v54 = v165;
        if (v62 != v67)
        {
          v124 = "aaByteStreamSimulate";
          v125 = 310;
          goto LABEL_144;
        }
LABEL_57:
        v57 += v62;
        ++v56;
        v45 = *v170;
      }
      while (v56 < *v170);
      v55 = *v170;
LABEL_59:
      ++v54;
    }
    while (v54 != 3);
    v68 = *(_DWORD *)(v169 + 28);
    if (v153 >= 3)
    {
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ForceInPlace %d: excess_pages=%d/%d, converted bytes=%llu, %zu controls\n", v151, v68, *(_DWORD *)(v169 + 32), v154, v45);
      v68 = *(_DWORD *)(v169 + 28);
    }
    v69 = *(_DWORD *)(v169 + 32);
    v70 = __OFSUB__(v68, v69);
    v71 = v68 - v69;
    if (!((v71 < 0) ^ v70 | (v71 == 0)))
    {
      v72 = v71 + 1;
      v73 = (uint64_t)(v72 >> 1) << 14;
      if (v72 < 2)
      {
        v74 = 0;
        a2 = v170;
        a1 = v171;
        v75 = v154;
        goto LABEL_112;
      }
      v149 = 0;
      v146 = -1;
      v76 = 1;
      a2 = v170;
      a1 = v171;
      v75 = v154;
      v77 = v152;
      while (2)
      {
        v78 = *(_QWORD *)(a4 + 2080);
        v79 = *a2;
        if (*a2)
        {
          v74 = 0;
          v147 = v76 - 1;
          v148 = v76;
          v80 = 24 * v79;
          while (1)
          {
            v81 = *a1 + v80;
            v82 = (int8x16_t *)(v81 - 24);
            v83 = *(int64x2_t *)(v81 - 24);
            v84 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v83), (int8x16_t)vsubq_s64(v77, v83), (int8x16_t)v83);
            v85 = *(_QWORD *)(v81 - 8);
            v86 = 0x8000000000000000 - v85;
            if (v85 >= 0)
              v86 = *(_QWORD *)(v81 - 8);
            v78 -= vaddvq_s64(v84);
            if (!v73)
              goto LABEL_94;
            v87 = v84.i64[0];
            if (!v84.i64[0])
              goto LABEL_94;
            if ((_DWORD)v76 == 1)
              break;
            if ((_DWORD)v76 != 2)
            {
              if ((_DWORD)v76 != 3)
                goto LABEL_94;
              v88 = *(_QWORD *)(a4 + 2056);
              goto LABEL_78;
            }
            if (v78 >= *(_QWORD *)(a4 + 2072))
            {
              if (v84.i64[0] > v73)
              {
                v89 = v146;
                v90 = v149;
                if (v146 > v84.i64[0])
                  v90 = v81 - 24;
                v149 = v90;
                if (v146 >= v84.i64[0])
                  v89 = v84.i64[0];
                v146 = v89;
                goto LABEL_94;
              }
              goto LABEL_89;
            }
LABEL_94:
            v80 -= 24;
            --v79;
            a1 = v171;
            if (!v79)
              goto LABEL_97;
          }
          if (v78 < *(_QWORD *)(a4 + 2056))
            goto LABEL_94;
          v88 = *(_QWORD *)(a4 + 2072);
LABEL_78:
          if (v78 < v88)
          {
            if (v84.i64[0] >= v73)
              v87 = v73;
LABEL_89:
            if (v153 >= 4)
            {
              v91 = v73;
              v155 = v75;
              v163 = v81;
              v166 = v78;
              v158 = v86;
              v160 = v87;
              v150 = v84;
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Dropping %llu bytes at %llu, needed=%llu bytes, type %s\n", v87, v78, v73, (&rawimg_force_in_place_pass_name)[v147]);
              v84 = v150;
              v86 = v158;
              v87 = v160;
              v81 = v163;
              v78 = v166;
              v76 = v148;
              v75 = v155;
              v73 = v91;
              v77 = v152;
            }
            v83.i64[0] = v87;
            v92.i64[0] = vsubq_s64(v84, v83).u64[0];
            v92.i64[1] = vaddq_s64(v84, vdupq_n_s64(v87)).i64[1];
            *v82 = vbslq_s8((int8x16_t)vcltzq_s64(v92), (int8x16_t)vsubq_s64(v77, v92), (int8x16_t)v92);
            v93 = v87 + v86;
            if ((uint64_t)(v87 + v86) < 0)
              v93 = 0x8000000000000000 - (v87 + v86);
            *(_QWORD *)(v81 - 8) = v93;
            v75 += v87;
            v73 -= v87;
            v74 = 1;
            goto LABEL_94;
          }
          goto LABEL_94;
        }
        v74 = 0;
LABEL_97:
        if (v78)
        {
          v124 = "control sequence broken";
          v125 = 411;
          goto LABEL_144;
        }
        a2 = v170;
        if (v76 != 3 || v74 || !v73 || !v149)
        {
          if (v76 > 2)
            goto LABEL_112;
          if (v74)
            goto LABEL_112;
          ++v76;
          if (!v73)
            goto LABEL_112;
          continue;
        }
        break;
      }
      v94 = v75;
      if (*(uint64_t *)v149 >= 0)
        v95 = *(_QWORD *)v149;
      else
        v95 = 0x8000000000000000 - *(_QWORD *)v149;
      v167 = *(int64x2_t *)(v149 + 8);
      if (v153 >= 4)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Dropping copy fork with %llu bytes, needed=%llu bytesx\n", v95, v73);
      v73 = 0;
      *(_QWORD *)v149 = 0;
      v96 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(v167), (int8x16_t)vsubq_s64(v152, v167), (int8x16_t)v167), vdupq_n_s64(v95));
      *(int8x16_t *)(v149 + 8) = vbslq_s8((int8x16_t)vcltzq_s64(v96), (int8x16_t)vsubq_s64(v152, v96), (int8x16_t)v96);
      v75 = v95 + v94;
      v74 = 1;
      a2 = v170;
      a1 = v171;
LABEL_112:
      v154 = v75;
      ++v151;
      v40 = v168;
      if (!v74 && v73)
      {
        v97 = "no possible conversions";
        v98 = 441;
        goto LABEL_142;
      }
      continue;
    }
    break;
  }
  v127 = (_QWORD *)*v171;
  v128 = *v170;
  if (!*v170)
    goto LABEL_155;
  if (v128 != 1)
  {
    v129 = 0;
    v130 = v127[1] + *v127;
    v131 = v127 + 3;
    v132 = 1;
    while (1)
    {
      v133 = *v131;
      v134 = v131[1];
      if (v130 != *(_QWORD *)(a4 + 2072))
      {
        v135 = &v127[3 * v129];
        v138 = v135[1];
        v137 = v135 + 1;
        v136 = v138;
        if (!v133)
        {
          v141 = v127[3 * v129 + 2];
LABEL_167:
          v127[3 * v129] += v133;
          *v137 = v136 + v134;
          v142 = 0x8000000000000000 - v141;
          if (v141 >= 0)
            v142 = v141;
          v143 = v131[2];
          if (v143 < 0)
            v143 = 0x8000000000000000 - v143;
          v70 = __OFADD__(v143, v142);
          v144 = v143 + v142;
          if (v144 < 0 != v70)
            v144 = 0x8000000000000000 - v144;
          v127[3 * v129 + 2] = v144;
          goto LABEL_174;
        }
        if (!v136)
        {
          v136 = v127[3 * v129 + 2];
          if (!v136)
          {
            v141 = 0;
            goto LABEL_167;
          }
        }
      }
      ++v129;
      v139 = *(_OWORD *)v131;
      v140 = &v127[3 * v129];
      v140[2] = v131[2];
      *(_OWORD *)v140 = v139;
LABEL_174:
      v130 += v134 + v133;
      ++v132;
      v131 += 3;
      if (v132 >= *v170)
        goto LABEL_154;
    }
  }
  v129 = 0;
LABEL_154:
  v128 = v129 + 1;
  *v170 = v128;
LABEL_155:
  *v171 = v127;
  if (v127)
  {
    if (v153 >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ForceInPlace: %zu controls. Dropped %llu bytes to stay within budget.\n", v128, v154);
    v110 = 1;
  }
  else
  {
    v124 = "merge_controls";
    v125 = 447;
LABEL_144:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", v125, 141, 0, v124, v41, v42, v145);
    v110 = 0;
  }
  v40 = v168;
LABEL_123:
  if (AAByteStreamClose((AAByteStream)v33) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 458, 141, 0, "AAByteStreamClose", v111, v112, v145);
    v110 = 0;
  }
  if (AAByteStreamClose(v30) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 459, 141, 0, "AAByteStreamClose", v113, v114, v145);
    v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v43) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 460, 141, 0, "AAByteStreamClose", v115, v116, v145);
    v110 = 0;
  }
  if (AAByteStreamClose(v40) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 461, 141, 0, "AAByteStreamClose", v117, v118, v145);
    v110 = 0;
  }
  if (AAByteStreamClose((AAByteStream)v17) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 462, 141, 0, "AAByteStreamClose", v119, v120, v145);
    v110 = 0;
  }
  if (AAByteStreamClose(v15) < 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"rawimg_force_in_place", 463, 141, 0, "AAByteStreamClose", v121, v122, v145);
    v110 = 0;
  }
  if (v110)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t SimStreamClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  char v17;

  if (!a1)
    return 0;
  v9 = *(_DWORD *)(a1 + 16);
  if (v9 < 1)
    goto LABEL_8;
  v10 = 0;
  v11 = *(int **)(a1 + 8);
  v12 = *(unsigned int *)(a1 + 16);
  do
  {
    v13 = *v11;
    v11 = (int *)((char *)v11 + 5);
    v10 += v13;
    --v12;
  }
  while (v12);
  if (v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 148, 141, 0, "%i dangling reads", a7, a8, v10);
    v9 = *(_DWORD *)(a1 + 16);
    v14 = 0xFFFFFFFFLL;
  }
  else
  {
LABEL_8:
    v14 = 0;
  }
  v15 = *(_DWORD *)(a1 + 24);
  if (*(_DWORD *)(a1 + 28) + v9 != *(_DWORD *)(a1 + 20) + v15)
  {
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 152, 141, "file + excess != written + free", a6, a7, a8, v17);
    v9 = *(_DWORD *)(a1 + 16);
    v15 = *(_DWORD *)(a1 + 24);
  }
  if (v9 < v15)
    pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamClose", 154, 141, "file < written", a6, a7, a8, v17);
  if (*(int *)(a1 + 36) >= 2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "SimStream: pages: %i file, %i written, %i free, %i excess (%iK)\n", *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 28), 16 * *(_DWORD *)(a1 + 28));
  free(*(void **)(a1 + 8));
  free((void *)a1);
  return v14;
}

ssize_t SimStreamPRead(AAByteStream *a1, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*a1, a2, a3, a4);
}

ssize_t SimStreamPWrite(AAByteStream *a1, const void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPWrite(*a1, a2, a3, a4);
}

uint64_t SimStreamSimulate(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  int64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  int v14;
  uint64_t v15;
  _BYTE *v16;
  int v17;
  int v18;
  const char *v20;
  __int16 v21;

  if (a4 < 1)
    return a4;
  if (a2 > 2)
  {
    v20 = "not implemented";
    v21 = 87;
    goto LABEL_20;
  }
  v9 = a5 + a4;
  v10 = *(_QWORD *)(a1 + 8);
  while (1)
  {
    v11 = (int *)(v10 + 5 * (a5 >> 14));
    if (a2)
      break;
    if (!(*v11)++)
    {
      v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 20) = v14 - 1;
      if (!v14)
      {
        v20 = "no free pages";
        v21 = 94;
        goto LABEL_20;
      }
    }
LABEL_17:
    a5 = (a5 & 0xFFFFFFFFFFFFC000) + 0x4000;
    if (a5 >= v9)
      return a4;
  }
  if (a2 != 1)
  {
    v15 = v10 + 5 * (a5 >> 14);
    v17 = *(unsigned __int8 *)(v15 + 4);
    v16 = (_BYTE *)(v15 + 4);
    if (!v17)
    {
      *v16 = 1;
      v18 = *(_DWORD *)(a1 + 20);
      if (v18)
        *(_DWORD *)(a1 + 20) = v18 - 1;
      else
        ++*(_DWORD *)(a1 + 28);
      ++*(_DWORD *)(a1 + 24);
    }
    goto LABEL_17;
  }
  if (*v11 > 0)
  {
    v12 = *v11 - 1;
    *v11 = v12;
    if (!v12)
      ++*(_DWORD *)(a1 + 20);
    goto LABEL_17;
  }
  v20 = "data not locked";
  v21 = 99;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/ImageDiffInPlace.c", (uint64_t)"SimStreamSimulate", v21, 141, 0, v20, a7, a8, v8);
  return -1;
}

uint64_t compare_extents_by_position(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return 1;
}

void rawimg_destroy(uint64_t *a1)
{
  unint64_t v2;
  uint64_t v3;

  if (a1)
  {
    if (a1[270])
    {
      v2 = 0;
      v3 = 384;
      do
      {
        free(*(void **)(a1[268] + v3));
        ++v2;
        v3 += 440;
      }
      while (v2 < a1[270]);
    }
    pc_array_free(a1[267]);
    pc_array_free(a1[268]);
    free(a1);
  }
}

uint64_t rawimg_show(uint64_t result, int a2, int a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  FILE **v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _OWORD v16[4];
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = (_QWORD *)result;
    v17 = 0;
    memset(v16, 0, sizeof(v16));
    v6 = *(_QWORD *)(result + 2160);
    if (v6)
    {
      v7 = 0;
      v8 = 0;
      v9 = (_QWORD *)(*(_QWORD *)(result + 2144) + 400);
      do
      {
        v7 += *v9;
        v8 += *(v9 - 1);
        v9 += 55;
        --v6;
      }
      while (v6);
    }
    else
    {
      v8 = 0;
      v7 = 0;
    }
    result = serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)(result + 2088));
    if (a3 > 1)
    {
      v10 = (FILE **)MEMORY[0x24BDAC8D8];
      v11 = "Output";
      if (!a2)
        v11 = "Input";
      v12 = (const char *)&unk_206434423;
      if (v5[256])
        v12 = (const char *)v5[256];
      result = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s variant <%s> | %llu bytes | %zu extents | %zu forks (%llu/%llu) | digest=%s\n", v11, v12, v5[265], v5[269], v5[270], v7, v8, (const char *)v16);
      if (a3 != 2)
      {
        result = fprintf(*v10, " fork | %64s | algo |       size | compressed | V | C\n", "digest");
        if (v5[270])
        {
          v13 = 0;
          v14 = 0;
          do
          {
            v15 = v5[268] + v13;
            serializeHexString((uint64_t)v16, 0x20u, (unsigned __int8 *)v15);
            result = fprintf(*v10, "%5zu | %s | %4d | %10llu | %10llu | %d | %d\n", ++v14, (const char *)v16, *(unsigned __int8 *)(v15 + 432), *(_QWORD *)(v15 + 392), *(_QWORD *)(v15 + 400), *(_DWORD *)(v15 + 408) & 1, (*(_DWORD *)(v15 + 408) >> 1) & 1);
            v13 += 440;
          }
          while (v14 < v5[270]);
        }
      }
    }
  }
  return result;
}

uint64_t *rawimg_create_with_path(const char *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  int v20;
  const char *v22;
  stat v23;

  v2 = (uint64_t *)calloc(1uLL, 0x878uLL);
  memset(&v23, 0, sizeof(v23));
  if (!v2)
  {
    v20 = *__error();
    v18 = "aaCalloc";
    v19 = 468;
    goto LABEL_17;
  }
  if (lstat(a1, &v23) || (v23.st_mode & 0xF000) != 0x8000)
  {
    v18 = "lstat";
    v19 = 469;
LABEL_15:
    v20 = 0;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_path", v19, 138, v20, v18, v3, v4, v23.st_dev);
    rawimg_destroy(v2);
    return 0;
  }
  v2[256] = (uint64_t)a1;
  v2[265] = v23.st_size;
  v2[267] = (uint64_t)pc_array_init(16);
  v5 = pc_array_init(440);
  v2[268] = (uint64_t)v5;
  if (!v2[267] || !v5)
  {
    v18 = "pc_array_init";
    v19 = 476;
    goto LABEL_15;
  }
  if ((apfs_scan_diskimage(a1, (uint64_t (*)(__int128 *, uint64_t))rawimg_add_fork, (uint64_t)rawimg_add_volume, (uint64_t)v2) & 0x80000000) != 0)
  {
    v18 = "rawimg_query_forks";
    v19 = 479;
    goto LABEL_15;
  }
  v6 = (_QWORD *)v2[268];
  v7 = *(v6 - 8);
  v2[270] = v7;
  v2[269] = *(_QWORD *)(v2[267] - 64);
  if (v7)
  {
    pc_array_sort(v6, (int (__cdecl *)(const void *, const void *))compare_forks_by_extent);
    if ((pc_array_aggregate((char *)v2[268], (unsigned int (*)(char *, char *))compare_forks_by_extent, (uint64_t (*)(char *, char *))aggregate_identical_forks) & 0x80000000) != 0)
    {
      v22 = "rawimg_remove_fork_duplicates";
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_remove_fork_duplicates", 454, 138, 0, "bad duplicate", v8, v9, v23.st_dev);
      v19 = 484;
      goto LABEL_23;
    }
    v6 = (_QWORD *)v2[268];
    v2[270] = *(v6 - 8);
  }
  v2[268] = (uint64_t)pc_array_compact((uint64_t)v6);
  v10 = pc_array_compact(v2[267]);
  v2[267] = (uint64_t)v10;
  if (!v10 || !v2[268])
  {
    v22 = "rawimg_compact";
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_compact", 77, 138, 0, "pc_array_compress", v16, v17, v23.st_dev);
    v19 = 485;
LABEL_23:
    v20 = 0;
    v18 = v22;
    goto LABEL_17;
  }
  if ((rawimg_verify(v2, v11, v12, v13, v14, v15, v16, v17) & 0x80000000) != 0)
  {
    v18 = "rawimg_verify";
    v19 = 486;
    goto LABEL_15;
  }
  qsort_r((void *)v2[268], v2[270], 0x1B8uLL, v2, (int (__cdecl *)(void *, const void *, const void *))compare_forks_by_position);
  return v2;
}

uint64_t rawimg_add_fork(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  const char *v20;
  __int16 v21;
  __int128 v22;
  _OWORD __src[24];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v27 = 0;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  memset(__src, 0, sizeof(__src));
  v8 = *(unsigned int *)(a1 + 20);
  if ((_DWORD)v8 && *(_QWORD *)a1)
  {
    v11 = *(_QWORD *)(a1 + 8);
    *((_QWORD *)&v24 + 1) = *(_QWORD *)a1;
    *(_QWORD *)&v25 = v11;
    *(_QWORD *)&v26 = *(_QWORD *)(*(_QWORD *)(a2 + 2136) - 64);
    *((_QWORD *)&v26 + 1) = v8;
    LOBYTE(v27) = *(_DWORD *)(a1 + 16);
    v12 = pc_array_append(*(_QWORD *)(a2 + 2144), __src, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a2 + 2144) = v12;
    if (v12)
    {
      if (*(int *)(a1 + 20) < 1)
        return 0;
      v17 = 0;
      v18 = *(_QWORD **)(a2 + 2136);
      while (1)
      {
        v22 = 0uLL;
        v22 = *(_OWORD *)(*(_QWORD *)(a1 + 24) + 16 * v17);
        v18 = pc_array_append((uint64_t)v18, &v22, v13, v14, v15, v16, a7, a8);
        *(_QWORD *)(a2 + 2136) = v18;
        if (!v18)
          break;
        if (++v17 >= *(int *)(a1 + 20))
          return 0;
      }
      v20 = "pc_array_append";
      v21 = 440;
    }
    else
    {
      v20 = "pc_array_append";
      v21 = 427;
    }
  }
  else
  {
    v20 = "bad fork";
    v21 = 416;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_add_fork", v21, 138, 0, v20, a7, a8, v22);
  return 0xFFFFFFFFLL;
}

uint64_t rawimg_add_volume()
{
  return 0;
}

uint64_t rawimg_verify(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD **v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  _QWORD *v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  unsigned int v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  const char *v49;
  __int16 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t *v57;
  unsigned int *v58;
  unint64_t v59;
  __int16 v60;
  char v61;

  v8 = a1[270];
  v9 = a1[269];
  if (!v8 || !v9)
  {
    if (!(v8 + v9))
      return 0;
    v26 = "bad variant";
    v27 = 184;
LABEL_22:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v27, 138, 0, v26, a7, a8, v61);
    v28 = 0;
    v17 = 0;
    goto LABEL_23;
  }
  v11 = a1[267];
  v12 = (_QWORD *)(v11 + 8);
  do
  {
    v13 = *(v12 - 1);
    if ((unint64_t)(*v12 + v13) > a1[265])
    {
      v26 = "bad extent";
      v27 = 195;
      goto LABEL_22;
    }
    if ((v13 & 0xFFF) != 0)
    {
      v26 = "bad extent pos";
      v27 = 196;
      goto LABEL_22;
    }
    if ((*v12 & 0xFFFLL) != 0)
    {
      v26 = "bad extent size";
      v27 = 197;
      goto LABEL_22;
    }
    v12 += 2;
    --v9;
  }
  while (v9);
  v14 = pc_array_indirect_sort(v11, compare_extents_by_position);
  v17 = v14;
  if (!v14)
  {
    v23 = "pc_array_indirect_sort";
    v24 = 202;
    goto LABEL_27;
  }
  v18 = 0;
  v19 = a1[269];
  if (v19 <= 1)
    v20 = 1;
  else
    v20 = a1[269];
  v21 = v20 - 1;
  while (v21 != v18)
  {
    v22 = (_QWORD **)&v14[v18++];
    if ((*v22)[1] + **v22 > *v22[1])
    {
      v23 = "extents overlapping";
      v24 = 205;
      goto LABEL_27;
    }
  }
  v30 = a1[270];
  v31 = a1[268];
  if (!v30)
  {
LABEL_42:
    v28 = pc_array_indirect_sort(v31, compare_forks_by_extent);
    if (v28)
    {
      v45 = a1[270];
      if (v45 <= 1)
        v46 = 1;
      else
        v46 = a1[270];
      v47 = 856;
      while (--v46)
      {
        v48 = (_QWORD *)(a1[268] + v47);
        v47 += 440;
        if (*(v48 - 55) == *v48)
        {
          v49 = "duplicate fork";
          v50 = 239;
          goto LABEL_69;
        }
      }
      if (!v45)
      {
LABEL_59:
        v25 = 0;
        goto LABEL_24;
      }
      v51 = 0;
      v52 = a1[268];
      while (1)
      {
        v53 = *(_QWORD *)(v52 + 440 * v51 + 56);
        if (v53)
          break;
LABEL_58:
        if (++v51 == v45)
          goto LABEL_59;
      }
      v54 = 0;
      v55 = v52 + 440 * v51;
      v56 = *(_QWORD *)(v55 + 384);
      v57 = (unint64_t *)(v55 + 400);
      v58 = (unsigned int *)(v56 + 8);
      while (1)
      {
        v59 = *((_QWORD *)v58 - 1);
        if (v59 < v54)
        {
          v49 = "bad chunk order";
          v50 = 256;
          goto LABEL_69;
        }
        v54 = v59 + *v58;
        if (v54 > *v57)
          break;
        v58 += 3;
        if (!--v53)
          goto LABEL_58;
      }
      v49 = "chunk out of bounds";
      v50 = 257;
    }
    else
    {
      v49 = "pc_array_indirect_sort";
      v50 = 236;
    }
LABEL_69:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v50, 138, 0, v49, v43, v44, v61);
    goto LABEL_23;
  }
  v32 = 0;
  while (2)
  {
    v33 = v31 + 440 * v32;
    v35 = *(_QWORD *)(v33 + 416);
    v34 = *(_QWORD *)(v33 + 424);
    if (v34 + v35 > v19)
    {
      v23 = "bad fork";
      v24 = 216;
      goto LABEL_27;
    }
    if (!v34)
    {
      v23 = "no fork extents";
      v24 = 219;
      goto LABEL_27;
    }
    if (!*(_QWORD *)(v31 + 440 * v32 + 392))
    {
      v23 = "bad fork size";
      v24 = 222;
      goto LABEL_27;
    }
    v36 = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
    if (!*(_BYTE *)(v31 + 440 * v32 + 432))
    {
      v60 = 155;
      goto LABEL_66;
    }
    v37 = &a1[*(unsigned __int8 *)(v31 + 440 * v32 + 432)];
    if (*v37)
    {
LABEL_38:
      v40 = 0;
      v41 = (uint64_t *)(a1[267] + 16 * v35 + 8);
      do
      {
        v42 = *v41;
        v41 += 2;
        v40 += v42;
        --v34;
      }
      while (v34);
      if (v40 < *(_QWORD *)(v31 + 440 * v32 + 400))
      {
        v23 = "bad fork size";
        v24 = 231;
        goto LABEL_27;
      }
      if (++v32 == v30)
        goto LABEL_42;
      continue;
    }
    break;
  }
  HIDWORD(v39) = *(unsigned __int8 *)(v31 + 440 * v32 + 432);
  LODWORD(v39) = v36 - 4;
  v38 = v39 >> 1;
  if (v38 < 6 && ((0x35u >> v38) & 1) != 0)
  {
    *v37 = dword_20643F5F0[v38];
    BYTE4(a1[v36]) = 0xFFFFFF06FFFFuLL >> (8 * v38);
    goto LABEL_38;
  }
  v60 = 167;
LABEL_66:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_init_algorithm", v60, 138, 0, "bad algo", v15, v16, v61);
  v24 = 225;
  v23 = "rawimg_init_algorithm";
LABEL_27:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_verify", v24, 138, 0, v23, v15, v16, v61);
  v28 = 0;
LABEL_23:
  v25 = 0xFFFFFFFFLL;
LABEL_24:
  free(v17);
  free(v28);
  return v25;
}

uint64_t rawimg_get_digests(uint64_t a1, signed int a2, int a3, int a4)
{
  unsigned int **v8;
  uint64_t v9;
  uint64_t v10;
  AAByteStream_impl *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD **v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  char *v57;
  size_t v58;
  uint64_t v59;
  size_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  _DWORD *v64;
  unsigned int *v65;
  uint64_t v66;
  size_t v67;
  _DWORD *v68;
  int *v69;
  uint64_t v70;
  int v71;
  unsigned int *v72;
  size_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  unint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t **v80;
  void *v81;
  void *v82;
  uint64_t v83;
  uint64_t **v84;
  uint64_t ***v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int *v93;
  unint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  uint64_t Worker;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  const char *v103;
  __int16 v104;
  const char *v105;
  __int16 v106;
  const char *v107;
  __int16 v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  int *v117;
  uint64_t v118;
  uint64_t v119;
  int *v120;
  uint64_t v121;
  uint64_t v122;
  const char *v123;
  __int16 v124;
  unint64_t v125;
  uint64_t v126;
  size_t v127;
  size_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  uint64_t v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  const char *v143;
  __int16 v144;
  char *v145;
  uint64_t v146;
  unint64_t v147;
  _QWORD *v148;
  uint64_t v149;
  char v150;
  uint64_t v151;
  _QWORD **v152;
  unint64_t v153;
  uint64_t v154;
  _QWORD *v155;
  int v156;
  _QWORD *v157;
  AAByteStream_impl *v158;
  AAByteStream_impl *v159;
  signed int v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  uint64_t v164;
  size_t v165;
  size_t v166;
  CC_SHA256_CTX c;

  memset(&c, 0, sizeof(c));
  v8 = (unsigned int **)AAFileStreamOpenWithPath(*(const char **)(a1 + 2048), 0, 0);
  v11 = (AAByteStream_impl *)v8;
  if (!v8)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 570, 138, 0, "AAFileStreamOpenWithPath", v9, v10, v150);
LABEL_78:
    v79 = 0;
    v82 = 0;
    v80 = 0;
    v93 = 0;
    v76 = 0;
    v20 = 0;
LABEL_95:
    v113 = 0;
    goto LABEL_96;
  }
  if (a4 && (io_set_nocache(v8) & 0x80000000) != 0)
    pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 571, 138, "io_set_nocache %s", v12, v13, v14, *(_QWORD *)(a1 + 2048));
  if (AAByteStreamSeek(v11, 0, 2) != *(_QWORD *)(a1 + 2120))
  {
    if (!a3)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 575, 138, "image size mismatch", v15, v16, v17, v150);
    goto LABEL_78;
  }
  v20 = aaSegmentStreamOpen(v11, (_QWORD *)a1);
  if (!v20)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 581, 138, 0, "aaSegmentStreamOpen", v18, v19, v150);
LABEL_94:
    v79 = 0;
    v82 = 0;
    v80 = 0;
    v93 = 0;
    v76 = 0;
    goto LABEL_95;
  }
  rawimg_free_chunks((_QWORD *)a1);
  if (*(_QWORD *)(a1 + 2160))
  {
    v26 = 0;
    v160 = a2;
    while (1)
    {
      v27 = *(_QWORD *)(a1 + 2144);
      v28 = v27 + 440 * v26;
      v29 = *(_QWORD *)(v28 + 392) + 0xFFFFLL;
      *(_QWORD *)(v28 + 56) = v29 >> 16;
      v30 = (uint64_t *)(v28 + 56);
      if (v29 >= 0x2AAAAAAAB0000)
      {
        *__error() = 12;
        *(_QWORD *)(v27 + 440 * v26 + 384) = 0;
LABEL_102:
        v117 = __error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 307, 138, *v117, "aaCalloc", v118, v119, v150);
        v55 = 0;
        goto LABEL_92;
      }
      v31 = calloc(v29 >> 16, 0xCuLL);
      v34 = v27 + 440 * v26;
      *(_QWORD *)(v34 + 384) = v31;
      if (!v31)
        goto LABEL_102;
      v35 = (_QWORD **)(v34 + 384);
      v36 = *v30;
      v164 = v27;
      if (*(_BYTE *)(v27 + 440 * v26 + 432) == 4)
      {
        v156 = a3;
        v158 = v11;
        v162 = v26;
        v37 = (_QWORD *)(v27 + 440 * v26);
        v38 = v37[5];
        v152 = v35;
        v154 = v37[50];
        v37[51] |= 4uLL;
        if (v20[4])
        {
          v39 = 0;
          v40 = 8 * v36;
          v151 = 8 * v36 + 264;
          v41 = v38 + 264;
          v42 = v27 + 440 * v26 + 64;
          v43 = v38;
          v44 = 264;
          while (1)
          {
            v45 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v42, v44, v43);
            if (v45 < 0)
              break;
            if (v45)
            {
              v42 += v45;
              v39 += v45;
              v43 += v45;
              v44 -= v45;
              if (v44)
                continue;
            }
            if (v39 != 264)
              break;
            if (v20[4])
            {
              v46 = 0;
              v47 = v164 + 440 * v162 + 328;
              v48 = v38 + v154 - 50;
              v49 = 50;
              while (1)
              {
                v50 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t))v20[4])(*v20, v47, v49, v48);
                if (v50 < 0)
                  break;
                if (v50)
                {
                  v47 += v50;
                  v46 += v50;
                  v48 += v50;
                  v49 -= v50;
                  if (v49)
                    continue;
                }
                if (v46 != 50)
                  break;
                if (v40 >= 0x2000000001)
                {
                  v55 = 0;
                  *__error() = 12;
                  goto LABEL_91;
                }
                v51 = (int *)malloc(v40);
                v55 = v51;
                if (!v51)
                  goto LABEL_91;
                if (!v20[4])
                  goto LABEL_111;
                if (v40)
                {
                  v56 = 0;
                  v57 = (char *)v51;
                  v58 = v40;
                  while (1)
                  {
                    v59 = ((uint64_t (*)(uint64_t *, char *, size_t, uint64_t))v20[4])(*v20, v57, v58, v41);
                    if (v59 < 0)
                      break;
                    if (v59)
                    {
                      v57 += v59;
                      v56 += v59;
                      v41 += v59;
                      v58 -= v59;
                      if (v58)
                        continue;
                    }
                    goto LABEL_42;
                  }
                  v56 = v59;
LABEL_42:
                  if (v40 != v56)
                  {
LABEL_111:
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 333, 138, 0, "fork chunks", v53, v54, v150);
                    goto LABEL_91;
                  }
                }
                v61 = *v30;
                v62 = *v152;
                if (!*v30)
                {
                  v63 = 50;
                  v60 = v151;
                  v67 = v151;
                  v11 = v158;
                  a3 = v156;
                  v26 = v162;
                  goto LABEL_53;
                }
                v68 = v62 + 1;
                v69 = v55 + 1;
                v70 = *v30;
                v11 = v158;
                v26 = v162;
                v60 = v151;
                do
                {
                  *((_QWORD *)v68 - 1) = (*(v69 - 1) + 260);
                  v71 = *v69;
                  v69 += 2;
                  *v68 = v71;
                  v68 += 3;
                  --v70;
                }
                while (v70);
                v63 = 50;
                a3 = v156;
                goto LABEL_47;
              }
            }
            v105 = "fork footer";
            v106 = 328;
            goto LABEL_90;
          }
        }
        v105 = "fork header";
        v106 = 325;
LABEL_90:
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v106, 138, 0, v105, v32, v33, v150);
        v55 = 0;
LABEL_91:
        v11 = v158;
        a3 = v156;
        goto LABEL_92;
      }
      v60 = 4 * v36 + 4;
      if (v60 >= 0x2000000001)
      {
        v55 = 0;
        *__error() = 12;
        goto LABEL_92;
      }
      v55 = (int *)malloc(v60);
      if (!v55)
        goto LABEL_92;
      if (v60 != AAByteStreamPRead((AAByteStream)v20, v55, v60, *(_QWORD *)(v164 + 440 * v26 + 40)))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", 351, 138, 0, "fork chunks", v53, v54, v150);
        goto LABEL_92;
      }
      v61 = *v30;
      v62 = *v35;
      v63 = 0;
      if (*v30)
      {
        v64 = v62 + 1;
        do
        {
          v65 = (unsigned int *)&v55[v63];
          v66 = *v65;
          *((_QWORD *)v64 - 1) = v66;
          ++v63;
          *v64 = v65[1] - v66;
          v64 += 3;
        }
        while (v61 != v63);
        v63 = 0;
LABEL_47:
        v72 = (unsigned int *)(v62 + 1);
        v67 = v60;
        while (1)
        {
          v73 = *((_QWORD *)v72 - 1);
          if (v73 < v67)
            break;
          v67 = v73 + *v72;
          if (v67 > *(_QWORD *)(v164 + 440 * v26 + 400))
            break;
          v72 += 3;
          if (!--v61)
            goto LABEL_53;
        }
        if (!a3)
        {
          v103 = "bad chunk";
          v104 = 372;
LABEL_82:
          pc_log_info((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_load_chunks_from_stream", v104, 138, v103, v52, v53, v54, v150);
          goto LABEL_92;
        }
        goto LABEL_92;
      }
      v67 = v60;
LABEL_53:
      if (*v62 != v60 || v67 + v63 != *(_QWORD *)(v164 + 440 * v26 + 400))
        break;
      free(v55);
      ++v26;
      a2 = v160;
      if (v26 >= *(_QWORD *)(a1 + 2160))
        goto LABEL_56;
    }
    if (!a3)
    {
      v103 = "bad index";
      v104 = 381;
      goto LABEL_82;
    }
LABEL_92:
    free(v55);
    rawimg_free_chunks((_QWORD *)a1);
    if (!a3)
      pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 587, 138, "bad chunk info", v110, v111, v112, v150);
    goto LABEL_94;
  }
LABEL_56:
  *(_QWORD *)(a1 + 2128) |= 8uLL;
  v76 = aaForkInputStreamOpen(v20, a1, 1, v21, v22, v23, v24, v25);
  if (!v76)
  {
    v107 = "aaForkInputStreamOpen";
    v108 = 593;
    v109 = 0;
LABEL_87:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v108, 138, v109, v107, v74, v75, v150);
    v79 = 0;
    v82 = 0;
    v80 = 0;
LABEL_88:
    v93 = 0;
    goto LABEL_95;
  }
  v77 = *(_QWORD *)(a1 + 2160) + ((unint64_t)(*(_QWORD *)(a1 + 2080) + 0x7FFFFFLL) >> 23);
  if (!is_mul_ok(v77, 0x38uLL) || 56 * v77 > 0x2000000000)
  {
    *__error() = 12;
    goto LABEL_86;
  }
  v78 = calloc(*(_QWORD *)(a1 + 2160) + ((unint64_t)(*(_QWORD *)(a1 + 2080) + 0x7FFFFFLL) >> 23), 0x38uLL);
  if (!v78)
  {
LABEL_86:
    v109 = *__error();
    v107 = "aaCalloc";
    v108 = 601;
    goto LABEL_87;
  }
  v79 = v78;
  if (a2 < 0)
  {
    *__error() = 12;
    v80 = 0;
    v82 = 0;
    *__error() = 12;
LABEL_104:
    v120 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 606, 138, *v120, "aaCalloc", v121, v122, v150);
    goto LABEL_88;
  }
  v80 = (uint64_t **)calloc(a2, 0x10uLL);
  v81 = calloc(a2, 8uLL);
  v82 = v81;
  if (!v80 || !v81)
    goto LABEL_104;
  if (a2)
  {
    v83 = a2;
    v84 = v80;
    v85 = (uint64_t ***)v81;
    do
    {
      *v85++ = v84;
      *v84 = v76;
      v84 += 2;
      --v83;
    }
    while (v83);
  }
  v93 = ThreadPoolCreate(a2, (uint64_t)v81, (uint64_t)rawimg_digest_worker);
  if (!v93)
  {
    v123 = "ThreadPoolCreate";
    v124 = 613;
    goto LABEL_110;
  }
  v153 = v77;
  v159 = v11;
  v94 = *(_QWORD *)(a1 + 2056);
  if (v94 < *(_QWORD *)(a1 + 2072))
  {
    v165 = 0;
    v95 = -(uint64_t)v94;
    v96 = v79;
    while (1)
    {
      Worker = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
      if (!Worker)
      {
        v143 = "ThreadPoolGetWorker";
        v144 = 622;
        goto LABEL_133;
      }
      *(_QWORD *)(Worker + 8) = v96;
      v96[6] = -1;
      v96[4] = v94;
      v102 = v95 + *(_QWORD *)(a1 + 2072);
      if (v102 >= 0x800000)
        v102 = 0x800000;
      v96[5] = v102;
      if ((ThreadPoolRunWorker((uint64_t)v93, Worker, v98, v99, v100, v101, v91, v92) & 0x80000000) != 0)
        break;
      ++v165;
      v94 += 0x800000;
      v95 -= 0x800000;
      v96 += 7;
      if (v94 >= *(_QWORD *)(a1 + 2072))
        goto LABEL_113;
    }
    v143 = "ThreadPoolRunWorker";
    v144 = 627;
    goto LABEL_133;
  }
  v165 = 0;
LABEL_113:
  v125 = *(_QWORD *)(a1 + 2160);
  if (!v125)
  {
    v11 = v159;
    v127 = v153;
    v128 = v165;
LABEL_127:
    if (v128 <= v127)
    {
      if ((ThreadPoolSync(v93) & 0x80000000) == 0)
      {
        qsort(v79, v128, 0x38uLL, (int (__cdecl *)(const void *, const void *))compare_digest_tasks);
        CC_SHA256_Init(&c);
        if (v128)
        {
          v145 = (char *)v79;
          do
          {
            CC_SHA256_Update(&c, v145, 0x20u);
            v145 += 56;
            --v128;
          }
          while (v128);
        }
        CC_SHA256_Final((unsigned __int8 *)(a1 + 2088), &c);
        if (*(_QWORD *)(a1 + 2160))
        {
          v146 = 0;
          v147 = 0;
          do
          {
            CC_SHA256_Init(&c);
            if (v79[7 * v146 + 6] == v147)
            {
              v148 = &v79[7 * v146];
              do
              {
                CC_SHA256_Update(&c, v148, 0x20u);
                ++v146;
                v149 = v148[13];
                v148 += 7;
              }
              while (v149 == v147);
            }
            CC_SHA256_Final((unsigned __int8 *)(*(_QWORD *)(a1 + 2144) + 440 * v147++), &c);
          }
          while (v147 < *(_QWORD *)(a1 + 2160));
        }
        *(_QWORD *)(a1 + 2128) |= 0x10uLL;
        v113 = 1;
        goto LABEL_134;
      }
      v123 = "ThreadPoolSync";
      v124 = 655;
    }
    else
    {
      v123 = "too many tasks";
      v124 = 649;
    }
LABEL_110:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v124, 138, 0, v123, v91, v92, v150);
    goto LABEL_95;
  }
  v126 = 0;
  v11 = v159;
  v127 = v153;
  v128 = v165;
  while (1)
  {
    v129 = *(_QWORD *)(a1 + 2144);
    v130 = v129 + 440 * v126;
    if (*(_QWORD *)(v130 + 392))
      break;
LABEL_123:
    if (++v126 >= v125)
      goto LABEL_127;
  }
  v131 = 0;
  v132 = 0;
  v133 = (_QWORD *)(v130 + 392);
  v161 = v126;
  v155 = v133;
  v157 = (_QWORD *)(v129 + 440 * v126 + 48);
  v166 = v128;
  v134 = &v79[7 * v128];
  while (1)
  {
    v163 = v131;
    v135 = v132;
    v136 = v133;
    v137 = ThreadPoolGetWorker((uint64_t)v93, v86, v87, v88, v89, v90, v91, v92);
    if (!v137)
    {
      v143 = "ThreadPoolGetWorker";
      v144 = 641;
      goto LABEL_133;
    }
    *(_QWORD *)(v137 + 8) = v134;
    v134[6] = v161;
    v134[4] = v135 + *v157;
    v142 = v163 + *v136;
    if (v142 >= 0x800000)
      v142 = 0x800000;
    v134[5] = v142;
    if ((ThreadPoolRunWorker((uint64_t)v93, v137, v138, v139, v140, v141, v91, v92) & 0x80000000) != 0)
      break;
    ++v166;
    v133 = v155;
    v131 = v163 - 0x800000;
    v134 += 7;
    v132 = v135 + 0x800000;
    if ((unint64_t)(v135 + 0x800000) >= *v155)
    {
      v125 = *(_QWORD *)(a1 + 2160);
      v11 = v159;
      v126 = v161;
      v127 = v153;
      v128 = v166;
      goto LABEL_123;
    }
  }
  v143 = "ThreadPoolRunWorker";
  v144 = 646;
LABEL_133:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", v144, 138, 0, v143, v91, v92, v150);
  v113 = 0;
LABEL_134:
  v11 = v159;
LABEL_96:
  if ((ThreadPoolDestroy((uint64_t)v93) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_get_digests", 683, 138, 0, "ThreadPoolDestroy", v114, v115, v150);
    v113 = 0;
  }
  free(v80);
  free(v82);
  free(v79);
  AAByteStreamClose((AAByteStream)v76);
  AAByteStreamClose((AAByteStream)v20);
  AAByteStreamClose(v11);
  if (v113)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

void rawimg_free_chunks(_QWORD *a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (a1[270])
  {
    v2 = 0;
    v3 = 384;
    do
    {
      v4 = a1[268] + v3;
      free(*(void **)v4);
      *(_QWORD *)v4 = 0;
      *(_QWORD *)(v4 - 328) = 0;
      *(_QWORD *)(v4 + 24) &= ~4uLL;
      ++v2;
      v3 += 440;
    }
    while (v2 < a1[270]);
  }
  a1[266] &= ~8uLL;
}

uint64_t rawimg_digest_worker(_QWORD *a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  const char *v18;
  __int16 v19;
  CC_SHA256_CTX v21;

  v2 = a1[1];
  memset(&v21, 0, sizeof(v21));
  v3 = (char *)malloc(0x10000uLL);
  if (!v3)
  {
    v17 = *__error();
    v18 = "aaMalloc";
    v19 = 530;
LABEL_20:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_digest_worker", v19, 138, v17, v18, v4, v5, v21.count[0]);
    v16 = 0xFFFFFFFFLL;
    goto LABEL_21;
  }
  CC_SHA256_Init(&v21);
  v6 = *(_QWORD *)(v2 + 40);
  if (v6)
  {
    v7 = 0;
    while (1)
    {
      v8 = v6 - v7;
      v9 = v8 >= 0x10000 ? 0x10000 : v8;
      v10 = *a1;
      if (!*(_QWORD *)(*a1 + 32))
        break;
      if (v9)
      {
        v11 = 0;
        v12 = *(_QWORD *)(v2 + 32) + v7;
        v13 = v3;
        v14 = v9;
        while (1)
        {
          v15 = (*(uint64_t (**)(_QWORD, char *, uint64_t, unint64_t))(v10 + 32))(*(_QWORD *)v10, v13, v14, v12);
          if (v15 < 0)
            break;
          if (v15)
          {
            v13 += v15;
            v11 += v15;
            v12 += v15;
            v14 -= v15;
            if (v14)
              continue;
          }
          goto LABEL_15;
        }
        v11 = v15;
LABEL_15:
        if (v9 != v11)
          break;
      }
      CC_SHA256_Update(&v21, v3, v9);
      v7 += 0x10000;
      v6 = *(_QWORD *)(v2 + 40);
      if (v7 >= v6)
        goto LABEL_17;
    }
    v18 = "aaByteStreamPReadExpected";
    v19 = 537;
    v17 = 0;
    goto LABEL_20;
  }
LABEL_17:
  CC_SHA256_Final((unsigned __int8 *)v2, &v21);
  v16 = 0;
LABEL_21:
  free(v3);
  return v16;
}

uint64_t compare_digest_tasks(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a2 + 48);
  v4 = v2 >= v3;
  if (v2 == v3)
    v4 = *(_QWORD *)(a1 + 32) >= *(_QWORD *)(a2 + 32);
  if (!v4)
    return 0xFFFFFFFFLL;
  else
    return 1;
}

uint64_t rawimg_set_fork_types(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  const char *v30;
  __int16 v31;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  if (a2 >= 0x21)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", 751, 138, 0, "too many variants", a7, a8, v41);
    v8 = 0;
    goto LABEL_33;
  }
  if (a2 != 1)
  {
    v8 = pc_array_init(16);
    if (v8)
    {
      if (!a2)
      {
LABEL_18:
        pc_array_sort(v8, (int (__cdecl *)(const void *, const void *))compare_copy_fork_5);
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_4, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        v24 = *(v8 - 8);
        if (v24)
        {
          v25 = v8 + 1;
          do
          {
            if ((*v25 & 1) == 0)
              *(_QWORD *)(*((_QWORD *)v25 - 1) + 408) |= 1uLL;
            v25 += 16;
            --v24;
          }
          while (v24);
        }
        pc_array_aggregate((char *)v8, (unsigned int (*)(char *, char *))compare_copy_fork_3, (uint64_t (*)(char *, char *))aggregate_copy_fork);
        v26 = *(v8 - 8);
        if (v26)
        {
          v27 = 0;
          v28 = 0;
          v29 = v8 + 1;
          do
          {
            if (*v29 == ~(-1 << a2))
            {
              *(_OWORD *)&v8[2 * v28++] = *(_OWORD *)(v29 - 2);
              v26 = *(v8 - 8);
            }
            ++v27;
            v29 += 4;
          }
          while (v27 < v26);
        }
        else
        {
          v28 = 0;
        }
        *(v8 - 8) = v28;
        if (a2)
        {
          v33 = 0;
          do
          {
            v34 = *(_QWORD *)(a1 + 8 * v33);
            if (*(_QWORD *)(v34 + 2160))
            {
              v35 = 0;
              v36 = 408;
              do
              {
                v37 = *(_QWORD *)(v34 + 2144);
                v41 = v37 + v36 - 408;
                v42 = 0;
                v38 = bsearch(&v41, v8, *(v8 - 8), 0x10uLL, (int (__cdecl *)(const void *, const void *))compare_copy_fork_3);
                if (v38)
                  v39 = 1;
                else
                  v39 = v33 == 0;
                if (v39)
                {
                  if (v38)
                    v40 = 2;
                  else
                    v40 = 1;
                  *(_QWORD *)(v37 + v36) |= v40;
                }
                ++v35;
                v36 += 440;
              }
              while (v35 < *(_QWORD *)(v34 + 2160));
            }
            ++v33;
          }
          while (v33 != a2);
        }
        v13 = 0;
        goto LABEL_34;
      }
      v20 = 0;
      while (1)
      {
        v21 = *(_QWORD *)(a1 + 8 * v20);
        if ((*(_BYTE *)(v21 + 2128) & 0x10) == 0)
        {
          v30 = "no digests found";
          v31 = 778;
          goto LABEL_32;
        }
        if (*(_QWORD *)(v21 + 2160))
          break;
LABEL_17:
        if (++v20 == a2)
          goto LABEL_18;
      }
      v22 = 0;
      v23 = 0;
      while (1)
      {
        v41 = *(_QWORD *)(v21 + 2144) + v22;
        v42 = (1 << v20);
        if ((*(_BYTE *)(v41 + 408) & 3) != 0)
        {
          v30 = "bad flags";
          v31 = 789;
          goto LABEL_32;
        }
        v8 = pc_array_append((uint64_t)v8, &v41, v14, v15, v16, v17, v18, v19);
        if (!v8)
          break;
        ++v23;
        v22 += 440;
        if (v23 >= *(_QWORD *)(v21 + 2160))
          goto LABEL_17;
      }
      v30 = "pc_array_append";
      v31 = 793;
    }
    else
    {
      v30 = "pc_array_init";
      v31 = 771;
    }
LABEL_32:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_set_fork_types", v31, 138, 0, v30, v18, v19, v41);
LABEL_33:
    v13 = 0xFFFFFFFFLL;
LABEL_34:
    pc_array_free((uint64_t)v8);
    return v13;
  }
  v11 = *(_QWORD *)(*(_QWORD *)a1 + 2160);
  if (v11)
  {
    v12 = (unint64_t *)(*(_QWORD *)(*(_QWORD *)a1 + 2144) + 408);
    do
    {
      *v12 = *v12 & 0xFFFFFFFFFFFFFFFCLL | 1;
      v12 += 55;
      --v11;
    }
    while (v11);
  }
  return 0;
}

uint64_t compare_copy_fork_5(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;

  result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!(_DWORD)result)
  {
    v5 = *(_DWORD *)(a1 + 8);
    v6 = *(_DWORD *)(a2 + 8);
    result = (v5 - v6);
    if (v5 == v6)
    {
      if (*(_QWORD *)(*(_QWORD *)a1 + 416) < *(_QWORD *)(*(_QWORD *)a2 + 416))
        return 0xFFFFFFFFLL;
      else
        return 1;
    }
  }
  return result;
}

uint64_t compare_copy_fork_4(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = compare_copy_fork_3((unint64_t **)a1, (unint64_t **)a2);
  if (!(_DWORD)result)
    return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
  return result;
}

uint64_t aggregate_copy_fork(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) |= *(_DWORD *)(a2 + 8);
  return 0;
}

uint64_t compare_copy_fork_3(unint64_t **a1, unint64_t **a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;

  v2 = *a1;
  v3 = *a2;
  v4 = bswap64(**a1);
  v5 = bswap64(**a2);
  if (v4 == v5
    && (v4 = bswap64(v2[1]), v5 = bswap64(v3[1]), v4 == v5)
    && (v4 = bswap64(v2[2]), v5 = bswap64(v3[2]), v4 == v5)
    && (v4 = bswap64(v2[3]), v5 = bswap64(v3[3]), v4 == v5))
  {
    v7 = v2[50] - v3[50];
    if (v7)
    {
      if (v7 < 0)
        return 0xFFFFFFFFLL;
      else
        return 1;
    }
    else
    {
      return *((unsigned __int8 *)v2 + 432) - *((unsigned __int8 *)v3 + 432);
    }
  }
  else if (v4 < v5)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t rawimg_save_to_stream(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  __int16 v10;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;
  __n128 v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  __n128 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __n128 v48;
  _OWORD v49[2];
  _OWORD v50[2];
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a2 + 2128);
  if ((v8 & 0x10) != 0)
  {
    if ((v8 & 8) != 0)
    {
      v14 = *(_OWORD *)(a2 + 2104);
      v50[0] = *(_OWORD *)(a2 + 2088);
      v50[1] = v14;
      v15 = 24;
      if (!a3)
        v15 = 16;
      v51 = *(_QWORD *)(a2 + 2120);
      v52 = v15;
      v53 = *(_OWORD *)(a2 + 2152);
      if (a1[3])
      {
        v16 = 0;
        v17 = v50;
        v18 = 64;
        while (1)
        {
          v19 = ((uint64_t (*)(_QWORD, _OWORD *, uint64_t))a1[3])(*a1, v17, v18);
          if (v19 < 1)
            break;
          v17 = (_OWORD *)((char *)v17 + v19);
          v16 += v19;
          v18 -= v19;
          if (!v18)
          {
            if (v16 != 64)
              break;
            if (!a1[3])
              goto LABEL_55;
            v20 = 16 * v53;
            if (16 * (_QWORD)v53)
            {
              v21 = 0;
              v22 = *(_QWORD *)(a2 + 2136);
              v23 = 16 * v53;
              while (1)
              {
                v24 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[3])(*a1, v22, v23);
                if (v24 < 1)
                  break;
                v22 += v24;
                v21 += v24;
                v23 -= v24;
                if (!v23)
                  goto LABEL_21;
              }
              v21 = v24;
LABEL_21:
              if (v20 != v21)
              {
LABEL_55:
                v9 = "aaByteStreamWriteExpected";
                v10 = 893;
                goto LABEL_19;
              }
            }
            if (!*((_QWORD *)&v53 + 1))
              return 0;
            v26 = 0;
            v27 = 0uLL;
LABEL_24:
            v28 = *(_QWORD *)(a2 + 2144);
            *(__n128 *)((char *)v49 + 9) = v27;
            v48 = v27;
            v49[0] = v27;
            v29 = v28 + 440 * v26;
            v48 = *(__n128 *)(v29 + 392);
            v30 = *(_OWORD *)(v29 + 408);
            v49[0] = v30;
            *(_QWORD *)&v49[1] = *(_QWORD *)(v29 + 424);
            BYTE8(v49[1]) = *(_BYTE *)(v29 + 432);
            if ((v30 & 1) == 0)
              *(_QWORD *)&v49[0] = v30 & 0xFFFFFFFFFFFFFFFBLL;
            if (a1[3])
            {
              v31 = 0;
              v32 = &v48;
              v33 = 41;
              while (1)
              {
                v34 = ((uint64_t (*)(_QWORD, __n128 *, uint64_t))a1[3])(*a1, v32, v33);
                if (v34 < 1)
                  break;
                v32 = (__n128 *)((char *)v32 + v34);
                v31 += v34;
                v33 -= v34;
                if (!v33)
                {
                  if (v31 != 41)
                    break;
                  v27 = 0uLL;
                  if (a3 && (v49[0] & 1) != 0)
                  {
                    if (!a1[3])
                      goto LABEL_60;
                    v35 = 12 * *(_QWORD *)(v28 + 440 * v26 + 56);
                    if (v35)
                    {
                      v36 = 0;
                      v37 = *(_QWORD *)(v28 + 440 * v26 + 384);
                      v38 = 12 * *(_QWORD *)(v28 + 440 * v26 + 56);
                      while (1)
                      {
                        v39 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, __n128))a1[3])(*a1, v37, v38, v27);
                        if (v39 < 1)
                          break;
                        v37 += v39;
                        v36 += v39;
                        v38 -= v39;
                        if (!v38)
                          goto LABEL_40;
                      }
                      v36 = v39;
LABEL_40:
                      v27 = 0uLL;
                      if (v35 != v36)
                      {
LABEL_60:
                        v10 = 925;
                        goto LABEL_57;
                      }
                    }
                    if ((v49[0] & 4) != 0)
                    {
                      if (a1[3])
                      {
                        v40 = 0;
                        v41 = v28 + 440 * v26 + 64;
                        v42 = 264;
                        while (1)
                        {
                          v43 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, __n128))a1[3])(*a1, v41, v42, v27);
                          if (v43 < 1)
                            break;
                          v41 += v43;
                          v40 += v43;
                          v42 -= v43;
                          if (!v42)
                          {
                            if (v40 != 264)
                              break;
                            if (a1[3])
                            {
                              v44 = 0;
                              v45 = v28 + 440 * v26 + 328;
                              v46 = 50;
                              while (1)
                              {
                                v47 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[3])(*a1, v45, v46);
                                if (v47 < 1)
                                  break;
                                v45 += v47;
                                v44 += v47;
                                v46 -= v47;
                                if (!v46)
                                {
                                  v27 = 0uLL;
                                  if (v44 == 50)
                                    goto LABEL_42;
                                  break;
                                }
                              }
                            }
                            v10 = 934;
                            goto LABEL_57;
                          }
                        }
                      }
                      v10 = 932;
                      goto LABEL_57;
                    }
                  }
LABEL_42:
                  result = 0;
                  if ((unint64_t)++v26 < *((_QWORD *)&v53 + 1))
                    goto LABEL_24;
                  return result;
                }
              }
            }
            v10 = 917;
LABEL_57:
            v9 = "aaByteStreamWriteExpected";
            goto LABEL_19;
          }
        }
      }
      v9 = "aaByteStreamWriteExpected";
      v10 = 888;
    }
    else
    {
      v9 = "no chunk info";
      v10 = 877;
    }
  }
  else
  {
    v9 = "no digest info";
    v10 = 876;
  }
LABEL_19:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_save_to_stream", v10, 138, 0, v9, a7, a8, v48.n128_i8[0]);
  return 0xFFFFFFFFLL;
}

char *rawimg_create_with_stream(_QWORD *a1, int a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  _OWORD *v9;
  __int128 *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  int v29;
  unint64_t v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  __int128 *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  char v41;
  size_t v42;
  uint64_t v43;
  _QWORD *v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int128 v59;
  _BYTE v60[25];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v4 = (char *)calloc(1uLL, 0x878uLL);
  v7 = v4;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  if (!v4)
  {
    v29 = *__error();
    v27 = "aaCalloc";
    v28 = 953;
    goto LABEL_20;
  }
  if (!a1[2])
    goto LABEL_17;
  v8 = 0;
  v9 = v4 + 2120;
  v10 = &v61;
  v11 = 64;
  do
  {
    v12 = ((uint64_t (*)(_QWORD, __int128 *, uint64_t))a1[2])(*a1, v10, v11);
    if (v12 < 0)
      goto LABEL_17;
    if (!v12)
      break;
    v10 = (__int128 *)((char *)v10 + v12);
    v8 += v12;
    v11 -= v12;
  }
  while (v11);
  if (v8 == 64)
  {
    v13 = v62;
    *(_OWORD *)(v7 + 2088) = v61;
    *(_OWORD *)(v7 + 2104) = v13;
    v14 = v64;
    *v9 = v63;
    *(_OWORD *)(v7 + 2152) = v14;
    *((_QWORD *)v7 + 267) = pc_array_init(16, v14);
    v15 = pc_array_init(440, *((_QWORD *)v7 + 270));
    *((_QWORD *)v7 + 268) = v15;
    v21 = *((_QWORD *)v7 + 267);
    if (v21 && v15)
    {
      v22 = *((_QWORD *)v7 + 269);
      *(_QWORD *)(v21 - 64) = v22;
      *(v15 - 8) = *((_QWORD *)v7 + 270);
      if (!a1[2])
        goto LABEL_62;
      v23 = 16 * v22;
      if (!(16 * v22))
        goto LABEL_25;
      v24 = 0;
      v25 = 16 * v22;
      while (1)
      {
        v26 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[2])(*a1, v21, v25);
        if (v26 < 0)
          break;
        if (v26)
        {
          v21 += v26;
          v24 += v26;
          v25 -= v26;
          if (v25)
            continue;
        }
        goto LABEL_24;
      }
      v24 = v26;
LABEL_24:
      if (v23 == v24)
      {
LABEL_25:
        if (!*((_QWORD *)&v64 + 1))
        {
LABEL_60:
          if ((rawimg_verify(v7, v16, v17, v18, v19, v20, v5, v6) & 0x80000000) == 0)
            return v7;
          v27 = "rawimg_verify";
          v28 = 1023;
          goto LABEL_18;
        }
        v31 = 0;
        v32 = 0uLL;
        while (2)
        {
          v33 = *((_QWORD *)v7 + 268);
          *(_OWORD *)&v60[9] = v32;
          v59 = v32;
          *(_OWORD *)v60 = v32;
          if (a1[2])
          {
            v34 = 0;
            v35 = &v59;
            v36 = 41;
            do
            {
              v37 = ((uint64_t (*)(_QWORD, __int128 *, uint64_t))a1[2])(*a1, v35, v36);
              if (v37 < 0)
                goto LABEL_63;
              if (!v37)
                break;
              v35 = (__int128 *)((char *)v35 + v37);
              v34 += v37;
              v36 -= v37;
            }
            while (v36);
            if (v34 != 41)
              break;
            v38 = v33 + 440 * v31;
            *(_QWORD *)(v38 + 432) = 0;
            *(_OWORD *)(v38 + 400) = 0u;
            *(_OWORD *)(v38 + 416) = 0u;
            *(_OWORD *)(v38 + 368) = 0u;
            *(_OWORD *)(v38 + 384) = 0u;
            *(_OWORD *)(v38 + 336) = 0u;
            *(_OWORD *)(v38 + 352) = 0u;
            *(_OWORD *)(v38 + 304) = 0u;
            *(_OWORD *)(v38 + 320) = 0u;
            *(_OWORD *)(v38 + 272) = 0u;
            *(_OWORD *)(v38 + 288) = 0u;
            *(_OWORD *)(v38 + 240) = 0u;
            *(_OWORD *)(v38 + 256) = 0u;
            *(_OWORD *)(v38 + 208) = 0u;
            *(_OWORD *)(v38 + 224) = 0u;
            *(_OWORD *)(v38 + 176) = 0u;
            *(_OWORD *)(v38 + 192) = 0u;
            *(_OWORD *)(v38 + 144) = 0u;
            *(_OWORD *)(v38 + 160) = 0u;
            *(_OWORD *)(v38 + 112) = 0u;
            *(_OWORD *)(v38 + 128) = 0u;
            *(_OWORD *)(v38 + 80) = 0u;
            *(_OWORD *)(v38 + 96) = 0u;
            *(_OWORD *)(v38 + 48) = 0u;
            *(_OWORD *)(v38 + 64) = 0u;
            *(_OWORD *)(v38 + 16) = 0u;
            *(_OWORD *)(v38 + 32) = 0u;
            *(_OWORD *)v38 = 0u;
            v39 = v59;
            *(_OWORD *)(v38 + 392) = v59;
            v40 = (_BYTE *)(v38 + 408);
            v41 = v60[0];
            *(_OWORD *)(v38 + 408) = *(_OWORD *)v60;
            *(_QWORD *)(v38 + 424) = *(_QWORD *)&v60[16];
            *(_BYTE *)(v38 + 432) = v60[24];
            if (a2 && (v41 & 1) != 0)
            {
              v42 = (unint64_t)(v39 + 0xFFFF) >> 16;
              v43 = v33 + 440 * v31;
              *(_QWORD *)(v43 + 56) = v42;
              v44 = (_QWORD *)(v43 + 56);
              if ((unint64_t)(v39 + 0xFFFF) >= 0x2AAAAAAAB0000)
              {
                *__error() = 12;
                *(_QWORD *)(v33 + 440 * v31 + 384) = 0;
              }
              else
              {
                v45 = (char *)calloc(v42, 0xCuLL);
                *(_QWORD *)(v33 + 440 * v31 + 384) = v45;
                if (v45)
                {
                  if (!a1[2])
                    goto LABEL_66;
                  v46 = 12 * *v44;
                  if (v46)
                  {
                    v47 = v45;
                    v48 = 0;
                    v49 = 12 * *v44;
                    while (1)
                    {
                      v50 = ((uint64_t (*)(_QWORD, char *, uint64_t))a1[2])(*a1, v47, v49);
                      if (v50 < 0)
                        break;
                      if (v50)
                      {
                        v47 += v50;
                        v48 += v50;
                        v49 -= v50;
                        if (v49)
                          continue;
                      }
                      goto LABEL_45;
                    }
                    v48 = v50;
LABEL_45:
                    if (v46 != v48)
                    {
LABEL_66:
                      v27 = "aaByteStreamReadExpected";
                      v28 = 1008;
                      goto LABEL_18;
                    }
                  }
                  if ((*v40 & 4) != 0)
                  {
                    if (a1[2])
                    {
                      v51 = 0;
                      v52 = v33 + 440 * v31 + 64;
                      v53 = 264;
                      while (1)
                      {
                        v54 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[2])(*a1, v52, v53);
                        if (v54 < 0)
                          break;
                        if (v54)
                        {
                          v52 += v54;
                          v51 += v54;
                          v53 -= v54;
                          if (v53)
                            continue;
                        }
                        if (v51 != 264)
                          break;
                        if (a1[2])
                        {
                          v55 = 0;
                          v56 = v33 + 440 * v31 + 328;
                          v57 = 50;
                          while (1)
                          {
                            v58 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[2])(*a1, v56, v57);
                            if (v58 < 0)
                              break;
                            if (v58)
                            {
                              v56 += v58;
                              v55 += v58;
                              v57 -= v58;
                              if (v57)
                                continue;
                            }
                            if (v55 != 50)
                              break;
                            goto LABEL_59;
                          }
                        }
                        v27 = "aaByteStreamReadExpected";
                        v28 = 1017;
                        goto LABEL_18;
                      }
                    }
                    v27 = "aaByteStreamReadExpected";
                    v28 = 1015;
                    goto LABEL_18;
                  }
                  goto LABEL_59;
                }
              }
              v29 = *__error();
              v27 = "aaCalloc";
              v28 = 1003;
              goto LABEL_20;
            }
LABEL_59:
            ++v31;
            v32 = 0uLL;
            if (v31 < *((_QWORD *)&v64 + 1))
              continue;
            goto LABEL_60;
          }
          break;
        }
LABEL_63:
        v27 = "aaByteStreamReadExpected";
        v28 = 986;
      }
      else
      {
LABEL_62:
        v27 = "aaByteStreamReadExpected";
        v28 = 976;
      }
    }
    else
    {
      v27 = "pc_array_init";
      v28 = 969;
    }
  }
  else
  {
LABEL_17:
    v27 = "aaByteStreamReadExpected";
    v28 = 957;
  }
LABEL_18:
  v29 = 0;
LABEL_20:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/ImageDiff/RawImage.c", (uint64_t)"rawimg_create_with_stream", v28, 138, v29, v27, v5, v6, v59);
  rawimg_destroy((uint64_t *)v7);
  return 0;
}

uint64_t compare_forks_by_extent(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_QWORD *)(a1 + 416);
  v3 = *(_QWORD *)(a2 + 416);
  v4 = v2 >= v3;
  v5 = v2 > v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

uint64_t aggregate_identical_forks(const void *a1, const void *a2)
{
  if (!memcmp(a1, a2, 0x1B8uLL))
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t compare_forks_by_position(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 2136) + 16 * *(_QWORD *)(a2 + 416)) < *(_QWORD *)(*(_QWORD *)(a1 + 2136)
                                                                                      + 16 * *(_QWORD *)(a3 + 416)))
    return 0xFFFFFFFFLL;
  else
    return 1;
}

uint64_t BXPatchFile(const char *a1, const char *a2, _QWORD *a3, unint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v14;
  uint64_t v15;
  _BOOL4 v16;
  _BOOL4 v17;
  const char *v18;
  __int16 v19;
  int v20;
  char v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  int v32;
  uint64_t result;
  unsigned int v34;
  size_t v35;
  int v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int16 v48;
  gid_t st_gid;
  int *v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  uint64_t v54;
  uint64_t v55;
  __uint32_t v56;
  int *v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  char v61;
  unint64_t v62;
  void *v63;
  stat v64;
  stat v65;
  char v66[1024];
  timeval v67;
  __darwin_time_t tv_sec;
  int v69;
  uint64_t v70;

  v8 = a7;
  v70 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)a6, a7, a8, v60);
  v62 = 0;
  v63 = 0;
  if (a6)
  {
    v16 = *a6 != 0;
    v17 = a6[1] != 0;
  }
  else
  {
    v16 = 0;
    v17 = 0;
  }
  memset(&v65, 0, sizeof(v65));
  memset(&v64, 0, sizeof(v64));
  if (a4 <= 7)
  {
    v18 = "Invalid patch";
    v19 = 25;
LABEL_6:
    v20 = 0;
LABEL_17:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", v19, 48, v20, v18, v14, v15, v61);
    v31 = 0;
LABEL_18:
    v32 = 0;
    goto LABEL_19;
  }
  if (*a3 == 0x3034464649445342 || *a3 == 0x3034464649445842 || *a3 == 0x3134464649445842)
  {
    v21 = 0;
    v22 = a3[3];
    if (v22 >= 0)
      v23 = a3[3];
    else
      v23 = 0x8000000000000000 - v22;
  }
  else
  {
    if (*a3 != 0x3035464649445842)
    {
      v18 = "Unsupported patch format";
      v19 = 36;
      goto LABEL_6;
    }
    v23 = a3[2];
    v21 = 1;
  }
  if (lstat(a1, &v65))
  {
    v20 = *__error();
    v61 = (char)a1;
    v18 = "%s";
    v19 = 39;
    goto LABEL_17;
  }
  v67.tv_sec = v65.st_atimespec.tv_sec;
  v67.tv_usec = 0;
  tv_sec = v65.st_mtimespec.tv_sec;
  v69 = 0;
  if (loadFileContents(a1, (char **)&v63, (off_t *)&v62, 0))
  {
    v61 = (char)a1;
    v18 = "opening input file: %s";
    v19 = 53;
    goto LABEL_6;
  }
  if (!strcmp(a1, a2))
    unlink(a1);
  bzero(v66, 0x400uLL);
  v35 = strlen(a2);
  __memcpy_chk();
  makePath(v66, v35);
  if (v23)
  {
    if (statIsCompressed(v65.st_flags))
      v36 = 1;
    else
      v36 = v17;
    if (v36)
      v37 = 4;
    else
      v37 = 0;
  }
  else
  {
    v37 = 0;
  }
  if (v16)
    v38 = v37 | 0x2B;
  else
    v38 = v37;
  v31 = OArchiveFileStreamCreate(a2, v23, v38, -1, 0);
  if (!v31)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 81, 48, 0, "OArchiveFileStreamCreate: %s", v39, v40, (char)a2);
    goto LABEL_18;
  }
  if ((v21 & 1) != 0)
  {
    if (BXPatch5((uint64_t)v63, v62, (uint64_t)a3, a4, (uint64_t (*)(uint64_t, void *, uint64_t))OArchiveFileStreamWrite, (uint64_t)v31, v8))
    {
      v48 = 91;
LABEL_48:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", v48, 48, 0, "Patch application", v46, v47, v61);
      goto LABEL_18;
    }
  }
  else if (BXPatch4((uint64_t)v63, v62, (uint64_t)a3, a4, (uint64_t)OArchiveFileStreamWrite, (uint64_t)v31, v39, v40))
  {
    v48 = 87;
    goto LABEL_48;
  }
  OArchiveFileStreamDestroy((unsigned int *)v31, v41, v42, v43, v44, v45, v46, v47);
  if (lstat(a2, &v64))
  {
    v20 = *__error();
    v61 = (char)a2;
    v18 = "%s";
    v19 = 101;
    goto LABEL_17;
  }
  if (v64.st_uid == v65.st_uid)
  {
    st_gid = v65.st_gid;
    if (v64.st_gid == v65.st_gid)
      goto LABEL_57;
  }
  else
  {
    st_gid = v65.st_gid;
  }
  if (!chown(a2, v65.st_uid, st_gid))
  {
LABEL_57:
    v32 = 1;
    goto LABEL_58;
  }
  v50 = __error();
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 106, 48, *v50, "%s", v51, v52, (char)a2);
  v32 = 0;
LABEL_58:
  if (v64.st_mode != v65.st_mode && chmod(a2, v65.st_mode & 0xFFF))
  {
    v53 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 110, 48, *v53, "%s", v54, v55, (char)a2);
    v32 = 0;
  }
  v56 = v65.st_flags & 0xFFFFFFDF | (32 * ((v64.st_flags >> 5) & 1));
  if (v64.st_flags != v56 && chflags(a2, v56))
  {
    v57 = __error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatchFile.c", (uint64_t)"BXPatchFile", 117, 48, *v57, "%s", v58, v59, (char)a2);
    v32 = 0;
  }
  if (utimes(a2, &v67))
  {
    v20 = *__error();
    v61 = (char)a2;
    v18 = "%s";
    v19 = 120;
    goto LABEL_17;
  }
  v31 = 0;
LABEL_19:
  OArchiveFileStreamDestroy((unsigned int *)v31, v24, v25, v26, v27, v28, v29, v30);
  free(v63);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v32)
    v34 = 0;
  else
    v34 = -1;
  if ((int)result >= 0)
    return v34;
  else
    return result;
}

uint64_t BXPatch4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  __int16 v9;
  uint64_t v15;
  int64x2_t v16;
  uint64_t v17;
  uint64_t result;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  BOOL v24;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  size_t v38;
  uint64_t v39;
  int64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  const char *v48;
  __int16 v49;
  int v50;
  const char *v51;
  __int16 v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int64x2_t v61;
  int64_t v62;
  void *data;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  CC_SHA1_CTX c;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned __int8 md[16];
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  if (a4 <= 0x1F)
  {
    v8 = "Invalid patch length";
    v9 = 129;
LABEL_12:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BXPatch4", v9, 51, 0, v8, a7, a8, v61.i8[0]);
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)a3 != 0x3034464649445342
    && *(_QWORD *)a3 != 0x3034464649445842
    && *(_QWORD *)a3 != 0x3134464649445842)
  {
    v8 = "Invalid patch header";
    v9 = 130;
    goto LABEL_12;
  }
  if (*(_QWORD *)a3 == 0x3134464649445842)
    v15 = 20;
  else
    v15 = 0;
  v16 = (int64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(*(int64x2_t *)(a3 + 8)), (int8x16_t)vsubq_s64(vdupq_n_s64(0x8000000000000000), *(int64x2_t *)(a3 + 8)), *(int8x16_t *)(a3 + 8));
  v17 = vaddvq_s64(v16);
  if (v17 + v15 + 32 > a4)
  {
    v8 = "Invalid patch header contents";
    v9 = 144;
    goto LABEL_12;
  }
  v61 = v16;
  v19 = (_QWORD *)(a3 + 32);
  if (*(_QWORD *)a3 == 0x3134464649445842)
    v20 = -20;
  else
    v20 = 0;
  v21 = *(_QWORD *)(a3 + 24);
  v22 = 0x8000000000000000 - v21;
  if (v21 >= 0)
    v22 = *(_QWORD *)(a3 + 24);
  v62 = v22;
  data = (void *)a1;
  if (*(_QWORD *)a3 == 0x3134464649445842)
  {
    memset(&c, 0, sizeof(c));
    CC_SHA1_Deprecated_Init(&c);
    CC_SHA1_Deprecated_Update(&c, data, a2);
    a1 = CC_SHA1_Deprecated_Final(md, &c);
    v24 = *(_QWORD *)md == *v19 && *(_QWORD *)&md[8] == *(_QWORD *)(a3 + 40);
    if (!v24 || v83 != (unint64_t)*(unsigned int *)(a3 + 48))
    {
      v8 = "Input file digest and patch digest do not match";
      v9 = 164;
      goto LABEL_12;
    }
  }
  enterThreadErrorContext(a1, a2, a3, a4, a5, a6, a7, a8, v61.i8[0]);
  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  memset(&c, 0, sizeof(c));
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  *(_OWORD *)md = 0u;
  v83 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v23 = *(_QWORD *)a3 == 0x3034464649445842 || *(_QWORD *)a3 == 0x3134464649445842;
  v26 = (char *)malloc(0x20000uLL);
  if (v26)
  {
    v27 = (uint64_t)v19 + v15;
    v77 = 0u;
    v78 = 0u;
    v28 = a4 + v20;
    v29 = (uint64_t)v19 + v15 + v61.i64[0];
    v75 = 0u;
    v76 = 0u;
    v30 = v28 - v17 - 32;
    memset(&c, 0, sizeof(c));
    *(_OWORD *)md = 0u;
    v83 = 0u;
    v84 = 0u;
    v85 = 0u;
    v86 = 0u;
    v87 = 0u;
    v88 = 0u;
    v89 = 0u;
    v90 = 0u;
    v91 = 0u;
    v72 = 0u;
    v73 = 0u;
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v31 = BufferDecoderInit((uint64_t)&c, v23, v27, v61.i64[0]);
    v32 = BufferDecoderInit((uint64_t)md, v23, v29, v61.i64[1]);
    if (!BufferDecoderInit((uint64_t)&v64, v23, v29 + v61.i64[1], v30) && !v32 && !v31)
    {
      v37 = OBufferedStreamCreate(a5, 0, a6, 0x20000uLL);
      if (v37)
      {
        v38 = BufferDecoderRead((int *)&c, (uint64_t)&v79, 24);
        if ((v38 & 0x8000000000000000) != 0)
        {
LABEL_69:
          v48 = "BufferDecoderRead";
          v49 = 196;
        }
        else
        {
          v39 = 0;
          v40 = 0;
          while (v38 == 24)
          {
            if (v79 >= 0)
              v41 = v79;
            else
              v41 = 0x8000000000000000 - v79;
            if (v80 >= 0)
              v42 = v80;
            else
              v42 = 0x8000000000000000 - v80;
            v43 = v81;
            if (v81 < 0)
              v43 = 0x8000000000000000 - v81;
            v61.i64[0] = v43;
            if (v41)
            {
              while (1)
              {
                if (v41 >= 0x20000)
                  v44 = 0x20000;
                else
                  v44 = v41;
                if (BufferDecoderRead((int *)md, (uint64_t)v26, v44) != v44)
                {
                  v48 = "Truncated add stream";
                  v49 = 208;
                  goto LABEL_74;
                }
                if (v39 < 0)
                {
                  v48 = "invalid patch, input before buffer";
                  v49 = 209;
                  goto LABEL_74;
                }
                if ((uint64_t)(v44 + v39) > a2)
                {
                  v48 = "invalid patch, input after buffer";
                  v49 = 210;
                  goto LABEL_74;
                }
                v40 += v44;
                if (v40 > v62)
                {
                  v48 = "invalid patch, output after buffer";
                  v49 = 211;
                  goto LABEL_74;
                }
                v45 = 0;
                v46 = v44 <= 1 ? 1 : v44;
                do
                {
                  v26[v45] += *((_BYTE *)data + v39 + v45);
                  ++v45;
                }
                while (v46 != v45);
                if (OBufferedStreamWrite((unint64_t **)v37, v26, v44) != v44)
                  break;
                v39 += v44;
                v41 -= v44;
                if (!v41)
                  goto LABEL_60;
              }
              v48 = "Write";
              v49 = 213;
              goto LABEL_74;
            }
LABEL_60:
            if (v42)
            {
              while (1)
              {
                if (v42 >= 0x20000)
                  v47 = 0x20000;
                else
                  v47 = v42;
                if (BufferDecoderRead((int *)&v64, (uint64_t)v26, v47) != v47)
                {
                  v48 = "Truncated lit stream";
                  v49 = 223;
                  goto LABEL_74;
                }
                v40 += v47;
                if (v40 > v62)
                {
                  v48 = "invalid patch, output after buffer";
                  v49 = 224;
                  goto LABEL_74;
                }
                if (OBufferedStreamWrite((unint64_t **)v37, v26, v47) != v47)
                  break;
                v42 -= v47;
                if (!v42)
                  goto LABEL_68;
              }
              v48 = "Write";
              v49 = 225;
              goto LABEL_74;
            }
LABEL_68:
            v39 += v61.i64[0];
            v38 = BufferDecoderRead((int *)&c, (uint64_t)&v79, 24);
            if ((v38 & 0x8000000000000000) != 0)
              goto LABEL_69;
          }
          if (v38)
          {
            v48 = "Truncated control stream";
            v49 = 198;
          }
          else
          {
            if (v40 == v62)
            {
              v53 = 0;
              goto LABEL_76;
            }
            v48 = "Number of written bytes and expected output size do not match";
            v49 = 235;
          }
        }
      }
      else
      {
        v48 = "OBufferedStream creation";
        v49 = 189;
      }
LABEL_74:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BXPatch4", v49, 51, 0, v48, v35, v36, v61.i8[0]);
      goto LABEL_75;
    }
    v51 = "BufferDecoderInit";
    v52 = 186;
    v50 = 0;
  }
  else
  {
    v50 = *__error();
    v51 = "malloc";
    v52 = 177;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BXPatch4", v52, 51, v50, v51, v33, v34, v61.i8[0]);
  v37 = 0;
LABEL_75:
  v53 = -1;
LABEL_76:
  free(v26);
  BufferDecoderDestroy(&c);
  BufferDecoderDestroy(md);
  BufferDecoderDestroy(&v64);
  OBufferedStreamDestroy((void ***)v37, v54, v55, v56, v57, v58, v59, v60);
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if ((int)result >= 0)
    return v53;
  else
    return result;
}

uint64_t BufferDecoderInit(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  bz_stream *v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)a1 = a2;
  v5 = (bz_stream *)(a1 + 24);
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  if (a2)
  {
    if (lzma_auto_decoder())
      return 0xFFFFFFFFLL;
  }
  else if (BZ2_bzDecompressInit(v5, 0, 0))
  {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

size_t BufferDecoderRead(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  bz_stream *v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  size_t result;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *((_QWORD *)a1 + 2);
  if (!v3)
    return 0;
  v7 = *a1;
  v6 = (bz_stream *)(a1 + 6);
  *((_QWORD *)a1 + 6) = a2;
  if (v7)
  {
    *((_QWORD *)a1 + 7) = a3;
    *((_QWORD *)a1 + 3) = *((_QWORD *)a1 + 1);
    *((_QWORD *)a1 + 4) = v3;
    v8 = lzma_code();
    v11 = v8;
    v12 = *((_QWORD *)a1 + 4);
    *((_QWORD *)a1 + 1) = *((_QWORD *)a1 + 3);
    *((_QWORD *)a1 + 2) = v12;
    if (v8 <= 0xA && ((1 << v8) & 0x403) != 0)
      result = *((_QWORD *)a1 + 6) - a2;
    else
      result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BufferDecoderRead", 106, 51, 0, "lzma_code error %d\n", v9, v10, v8);
    if (v11 > 0xA || ((1 << v11) & 0x403) == 0)
      return -1;
  }
  else
  {
    a1[14] = a3;
    *((_QWORD *)a1 + 3) = *((_QWORD *)a1 + 1);
    a1[8] = v3;
    v14 = BZ2_bzDecompress(v6);
    v17 = a1[8];
    *((_QWORD *)a1 + 1) = *((_QWORD *)a1 + 3);
    *((_QWORD *)a1 + 2) = v17;
    if ((v14 & 0xFFFFFFFB) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelPatch/BXPatch4.c", (uint64_t)"BufferDecoderRead", 118, 51, 0, "BZ2_bzDecompress error %d\n", v15, v16, v14);
      return -1;
    }
    return *((_QWORD *)a1 + 6) - a2;
  }
  return result;
}

uint64_t BufferDecoderDestroy(_DWORD *a1)
{
  bz_stream *v1;
  int v2;

  v2 = *a1;
  v1 = (bz_stream *)(a1 + 6);
  if (v2)
    return lzma_end();
  else
    return BZ2_bzDecompressEnd(v1);
}

uint64_t transcodeIThreadProc()
{
  uint64_t v0;
  unsigned int *v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  _DWORD *v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  __int16 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v50;
  char v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  _DWORD v56[34];
  uint64_t v57;
  _BYTE v58[2048];
  uint64_t v59;

  v0 = MEMORY[0x24BDAC7A8]();
  v59 = *MEMORY[0x24BDAC8D0];
  v1 = *(unsigned int **)(v0 + 16);
  v2 = *(_QWORD *)v0;
  v3 = ArchiveTreeSize(v1);
  v4 = *(_DWORD *)(v2 + 16);
  v10 = (unint64_t *)MemBufferCreate(0x10000uLL);
  if (!v10)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeIThreadProc", 47, 65, 0, "creating mem buffer", v8, v9, v50);
    v11 = 0;
    goto LABEL_36;
  }
  if (!v3)
  {
    v52 = 0;
    v11 = 0;
LABEL_25:
    SharedBufferWrite(*(unsigned int **)(v0 + 24), 0, 0, v5, v6, v7, v8, v9);
    if (*(int *)v2 >= 2)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12u archive stream switches\n", v52);
    goto LABEL_37;
  }
  v11 = 0;
  v12 = 0;
  v52 = 0;
  v13 = -1;
  while (1)
  {
    v53 = 0;
    v54 = 0;
    v14 = ArchiveTreeNodeArchiveID((uint64_t)v1, v12);
    if (v14 >= v4)
    {
      v40 = "invalid archive ID";
      v41 = 54;
      goto LABEL_35;
    }
    v15 = v14;
    if ((ArchiveTreeNodeSegment((uint64_t)v1, v12, &v54, &v53) & 0x80000000) != 0)
    {
      v40 = "get entry segment";
      v41 = 55;
      goto LABEL_35;
    }
    v20 = v54;
    if (v54 != -1 && v53 != -1)
      break;
    if (ArchiveTreeNodeEntryType((uint64_t)v1, v12) != 68)
    {
      v40 = "non-directory entry not found in any archive";
      v41 = 60;
      goto LABEL_35;
    }
    bzero(v58, 0x800uLL);
    bzero(v56, 0x888uLL);
    v55 = 0x4400008011;
    v56[3] = 493;
    if (ArchiveTreeNodePath((uint64_t)v1, v12, (uint64_t)&v57, 0x400uLL) < 0)
    {
      v40 = "getting entry path";
      v41 = 71;
      goto LABEL_35;
    }
    v23 = yaa_encodeHeader((uint64_t)v58, 0x800uLL, (int *)&v55, 0, 0, v22, v8, v9);
    if ((v23 & 0x8000000000000000) != 0)
    {
      v40 = "encoding directory entry";
      v41 = 73;
      goto LABEL_35;
    }
    if (SharedBufferWrite(*(unsigned int **)(v0 + 24), (uint64_t)v58, v23, v24, v25, v26, v8, v9) < 0)
    {
      v40 = "writing dir entry";
      v41 = 77;
      goto LABEL_35;
    }
LABEL_21:
    if (v3 == ++v12)
      goto LABEL_25;
  }
  if (v15 == v13)
  {
LABEL_19:
    if (ParallelCompressionFileSeek((uint64_t)v11, v20, 0, v17, v18, v19, v8, v9) < 0)
    {
      v40 = "seeking compressed stream";
      v41 = 93;
      goto LABEL_35;
    }
    if (MemBufferTransmit(v10, v53, (size_t (*)(int, void *, size_t))pcFileRead, (uint64_t)v11, (uint64_t (*)(uint64_t, uint64_t, uint64_t))SharedBufferWrite, *(_QWORD *)(v0 + 24), v8, v9) < 0)
    {
      v40 = "transmitting entry payload";
      v41 = 94;
      goto LABEL_35;
    }
    goto LABEL_21;
  }
  ParallelCompressionFileClose(v11, v54, v16, v17, v18, v19, v8, v9);
  v11 = ParallelCompressionFileOpen(*(const char **)(*(_QWORD *)(v2 + 24) + 24 * v15), "r,c=2", v27, v28, v29, v30, v31, v32);
  if (v11)
  {
    ++v52;
    v20 = v54;
    v13 = v15;
    goto LABEL_19;
  }
  v40 = "creating compressed stream";
  v41 = 88;
LABEL_35:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeIThreadProc", v41, 65, 0, v40, v8, v9, v50);
LABEL_36:
  *(_DWORD *)(v0 + 36) = 0;
  SharedBufferAbort(*(_QWORD *)(v0 + 24), v33, v34, v35, v36, v37, v38, v39, v51);
LABEL_37:
  MemBufferDestroy((void **)v10);
  ParallelCompressionFileClose(v11, v42, v43, v44, v45, v46, v47, v48);
  return v0;
}

size_t transcodeOThreadBeginProc(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t result;
  const char *v14;
  __int16 v15;
  char v16;
  _BYTE __dst[2192];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v8 = *(_DWORD *)(a1 + 32);
  if (v8 >= ArchiveTreeSize(*(unsigned int **)(a1 + 16)))
  {
    v14 = "invalid entry index";
    v15 = 119;
  }
  else
  {
    memcpy(__dst, a2, sizeof(__dst));
    if ((__dst[1] & 0x80) != 0
      && ArchiveTreeNodePath(*(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 32), (uint64_t)&__dst[144], 0x400uLL) < 0)
    {
      v14 = "getting new entry path";
      v15 = 128;
    }
    else
    {
      result = ParallelArchiveWriteEntryHeader(*(_QWORD *)(a1 + 8), (uint64_t)__dst, a3, a4, v11, v12, v9, v10);
      if ((result & 0x80000000) == 0)
        return result;
      v14 = "writing entry header";
      v15 = 133;
    }
  }
  result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeOThreadBeginProc", v15, 65, 0, v14, v9, v10, v16);
  *(_DWORD *)(a1 + 36) = 0;
  return result;
}

uint64_t transcodeOThreadEndProc(uint64_t result)
{
  ++*(_DWORD *)(result + 32);
  return result;
}

size_t transcodeOThreadPayloadProc(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t result;
  uint64_t v10;
  uint64_t v11;
  char v12;

  result = ParallelArchiveWriteEntryData(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) != 0)
  {
    result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeOThreadPayloadProc", 146, 65, 0, "writing entry data", v10, v11, v12);
    *(_DWORD *)(a1 + 36) = 0;
  }
  return result;
}

uint64_t transcodeOThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;
  char v21;
  _QWORD v22[5];
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;

  v23 = 0u;
  v24 = 0u;
  *(_DWORD *)(a1 + 32) = 0;
  v22[0] = 0x100000000;
  v9 = *(_QWORD *)(a1 + 24);
  v22[1] = SharedBufferRead;
  v22[2] = SharedBufferAbort;
  v22[3] = v9;
  v22[4] = transcodeOThreadBeginProc;
  v25 = 0;
  v26 = a1;
  *((_QWORD *)&v24 + 1) = transcodeOThreadEndProc;
  *((_QWORD *)&v23 + 1) = transcodeOThreadPayloadProc;
  if ((ParallelArchiveRead((uint64_t)v22, a2, a3, a4, a5, a6, a7, a8) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"transcodeOThreadProc", 169, 65, 0, "reading aggregated entries", v10, v11, v20);
    *(_DWORD *)(a1 + 36) = 0;
    SharedBufferAbort(*(_QWORD *)(a1 + 24), v12, v13, v14, v15, v16, v17, v18, v21);
  }
  return a1;
}

uint64_t ParallelArchiveCombine()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  unsigned int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  char *v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t i;
  unsigned int v35;
  size_t v36;
  _DWORD *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  __int16 v43;
  int v44;
  uint64_t result;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  FILE **v49;
  size_t j;
  size_t v51;
  char *v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  __int16 v76;
  int v77;
  char v78;
  const char *v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  int *v83;
  uint64_t v84;
  unsigned int v85;
  const char **v86;
  unsigned int *v87;
  char *v88;
  char *v89;
  size_t v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  pthread_t v94;
  pthread_t v95;
  _OWORD v96[65];
  char __s[16];
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  _BYTE v129[2048];
  char v130[2048];
  uint64_t v131;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v3 = v0;
  v131 = *MEMORY[0x24BDAC8D0];
  enterThreadErrorContext(v0, v1, v4, v5, v6, v7, v8, v9, v78);
  v10 = *(_QWORD *)(v2 + 16);
  v94 = 0;
  v95 = 0;
  v93 = 0;
  v91 = 0u;
  v92 = 0u;
  v11 = ArchiveTreeCreateWithRootEntry();
  v14 = v11;
  if (!v11)
  {
    v42 = "empty tree creation";
    v43 = 198;
    goto LABEL_35;
  }
  v80 = v3;
  v81 = v10;
  if (!(_DWORD)v10)
  {
    v17 = 0;
    v16 = 0;
    goto LABEL_44;
  }
  v15 = 0;
  v16 = 0;
  v90 = 0;
  v17 = 0;
  v82 = v10;
  v18 = MEMORY[0x24BDAC740];
  v83 = (int *)v2;
  v84 = (uint64_t)v11;
  do
  {
    v19 = v14;
    v20 = *(_QWORD *)(v2 + 24);
    bzero(__s, 0x800uLL);
    v86 = (const char **)(v20 + 24 * v15);
    v21 = IFileStreamCreateWithFilename(*v86, 0, -1);
    if (!v21)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 207, 65, 0, "opening archive file: %s", v22, v23, (char)*v86);
LABEL_76:
      v14 = v19;
      goto LABEL_36;
    }
    v24 = (char *)v21;
    v88 = v17;
    v25 = ArchiveTreeCreateFromArchive((uint64_t)IFileStreamRead, v21, *(_DWORD *)(v2 + 4));
    IFileStreamDestroy(v24);
    if (!v25)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 211, 65, 0, "reading archive tree: %s", v26, v27, (char)*v86);
      goto LABEL_76;
    }
    if ((ArchiveTreePrune(v25, *(_DWORD *)(v20 + 24 * v15 + 8)) & 0x80000000) != 0)
    {
      v79 = *v86;
      v75 = "pruning entries: %s (%d)";
      v76 = 214;
LABEL_79:
      v77 = 0;
      goto LABEL_80;
    }
    if ((ArchiveTreeInsert((uint64_t)v25, *(char **)(v20 + 24 * v15 + 16)) & 0x80000000) != 0)
    {
      v79 = *v86;
      v75 = "inserting path to entries: %s (%s)";
      v76 = 215;
      goto LABEL_79;
    }
    v30 = ArchiveTreeSize(v25);
    ArchiveTreeYAF((size_t)v25, __s, 0x800uLL);
    v31 = v88;
    if (!v90)
    {
      v90 = (strlen(__s) >> 1) + 1;
      v31 = (char *)calloc(v90, 8uLL);
      if (v31)
      {
        v16 = 0;
        goto LABEL_11;
      }
      v77 = *__error();
      v75 = "malloc";
      v76 = 226;
LABEL_80:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", v76, 65, v77, v75, v28, v29, (char)v79);
      v14 = (unsigned int *)v84;
      goto LABEL_36;
    }
LABEL_11:
    v85 = v30;
    v87 = v25;
    v89 = v31;
    v32 = 0;
    v33 = v31 + 4;
    do
    {
      for (i = 0; ; ++i)
      {
        v35 = __s[v32 + i];
        if ((v35 & 0x80000000) != 0)
          break;
        if ((*(_DWORD *)(v18 + 4 * v35 + 60) & 0x100) == 0)
          goto LABEL_18;
LABEL_17:
        ;
      }
      if (__maskrune(__s[v32 + i], 0x100uLL))
        goto LABEL_17;
LABEL_18:
      if (v15)
      {
        if (v16)
        {
          v36 = v16;
          v37 = v33;
          while (((*(_DWORD *)&__s[v32] ^ *(v37 - 1)) & 0xDFDFDF) != 0)
          {
            v37 += 2;
            if (!--v36)
              goto LABEL_28;
          }
          ++*v37;
        }
      }
      else if (v16 < v90 && i == 3)
      {
        v38 = *(_WORD *)&__s[v32];
        v39 = &v89[8 * v16];
        v39[2] = __s[v32 + 2];
        *(_WORD *)v39 = v38;
        *((_DWORD *)v39 + 1) = 1;
        ++v16;
      }
LABEL_28:
      v32 += i + 1;
    }
    while (v35);
    v2 = (uint64_t)v83;
    if (*v83 >= 1)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12u entries merged from %s\n", v85, *v86);
    v14 = (unsigned int *)v84;
    v17 = v89;
    if ((ArchiveTreeMergeAndDestroy(v84, v87, v15) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 265, 65, 0, "merging archive tree: %s", v40, v41, (char)*v86);
      goto LABEL_36;
    }
    ++v15;
  }
  while (v15 != v82);
LABEL_44:
  v47 = ArchiveTreeSize(v14);
  if (*(int *)v2 >= 1)
  {
    v48 = v47;
    v49 = (FILE **)MEMORY[0x24BDAC8D8];
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12u input archives\n", v81);
    fprintf(*v49, "%12u unique entries\n", v48);
  }
  bzero(v130, 0x800uLL);
  bzero(v129, 0x800uLL);
  v128 = 0u;
  v127 = 0u;
  v126 = 0u;
  v125 = 0u;
  v124 = 0u;
  v123 = 0u;
  v122 = 0u;
  v121 = 0u;
  v120 = 0u;
  v119 = 0u;
  v118 = 0u;
  v117 = 0u;
  v116 = 0u;
  v115 = 0u;
  v114 = 0u;
  v113 = 0u;
  v112 = 0u;
  v111 = 0u;
  v110 = 0u;
  v109 = 0u;
  v108 = 0u;
  v107 = 0u;
  v106 = 0u;
  v105 = 0u;
  v104 = 0u;
  v103 = 0u;
  v102 = 0u;
  v101 = 0u;
  v100 = 0u;
  v99 = 0u;
  v98 = 0u;
  *(_OWORD *)__s = 0u;
  memset(v96, 0, 512);
  for (j = 0; v16; --v16)
  {
    if ((*(_DWORD *)v17 & 0xDFDFDF) == 0x505954 || *((_DWORD *)v17 + 1) == v81)
    {
      if (j - 2045 <= 0xFFFFFFFFFFFFF7FELL)
      {
        v42 = "too many YAF fields";
        v43 = 290;
        goto LABEL_35;
      }
      if (j)
      {
        v51 = j + 1;
        v130[j] = 44;
      }
      else
      {
        v51 = 0;
      }
      v52 = &v130[v51];
      v53 = *(_WORD *)v17;
      v52[2] = v17[2];
      *(_WORD *)v52 = v53;
      j = v51 + 3;
      v130[v51 + 3] = 0;
    }
    v17 += 8;
  }
  bzero(&__s[8], 0x888uLL);
  *(_QWORD *)__s = 0x4D00000001;
  bzero((char *)v96 + 3, 0x405uLL);
  qmemcpy(v96, "YAF", 3);
  DWORD1(v96[0]) = 2;
  *((_QWORD *)&v96[0] + 1) = j;
  v57 = yaa_encodeHeader((uint64_t)v129, 0x800uLL, (int *)__s, (uint64_t)v96, 1uLL, v54, v55, v56);
  if (v57 < 0)
  {
    v42 = "encoding metadata entry";
    v43 = 306;
    goto LABEL_35;
  }
  v58 = v57;
  if (2048 - v57 < j)
  {
    v42 = "encoding metadata entry";
    v43 = 309;
    goto LABEL_35;
  }
  memcpy(&v129[v57], v130, j);
  v63 = v58 + j;
  if (*(int *)v2 >= 1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Output fields: %s\n", v130);
  if ((yaa_writeRawEntryHeader(v80, (uint64_t)v129, v63, 0, v59, v60, v61, v62) & 0x80000000) != 0)
  {
    v42 = "writing metadata entry";
    v43 = 317;
LABEL_35:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", v43, 65, 0, v42, v12, v13, (char)v79);
LABEL_36:
    v44 = 0;
    goto LABEL_37;
  }
  *((_QWORD *)&v92 + 1) = SharedBufferCreate(0x10000uLL, v64, v65, v66, v67, v68, v12, v13);
  if (!*((_QWORD *)&v92 + 1))
  {
    v42 = "allocating shared buffer";
    v43 = 322;
    goto LABEL_35;
  }
  *(_QWORD *)&v91 = v2;
  *((_QWORD *)&v91 + 1) = v80;
  *(_QWORD *)&v92 = v14;
  v44 = 1;
  HIDWORD(v93) = 1;
  if ((createThread(&v95, (uint64_t)transcodeIThreadProc, (uint64_t)&v91, 0) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 329, 65, 0, "running transcoder I thread", v69, v70, (char)v79);
    v44 = 0;
  }
  if ((createThread(&v94, (uint64_t)transcodeOThreadProc, (uint64_t)&v91, 0) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 330, 65, 0, "running transcoder O thread", v71, v72, (char)v79);
    v44 = 0;
  }
  if ((joinThread(v94) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 331, 65, 0, "waiting for O thread", v73, v74, (char)v79);
    v44 = 0;
  }
  if ((joinThread(v95) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelArchive/Combine.c", (uint64_t)"ParallelArchiveCombine", 332, 65, 0, "waiting for I thread", v12, v13, (char)v79);
    v44 = 0;
  }
  if (!HIDWORD(v93))
  {
    v42 = "transcoding";
    v43 = 333;
    goto LABEL_35;
  }
LABEL_37:
  ArchiveTreeDestroy((uint64_t)v14);
  SharedBufferDestroy(*((uint64_t *)&v92 + 1));
  LODWORD(result) = leaveThreadErrorContext(0, 0, 0);
  if (v44)
    v46 = 0;
  else
    v46 = -1;
  if ((int)result >= 0)
    return v46;
  else
    return result;
}

uint64_t MemGateReserve(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  __int16 v7;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  int v21;
  char v22;

  if (!a2)
    return 0;
  if (pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    v6 = "MutexLock";
    v7 = 95;
    goto LABEL_28;
  }
  v9 = *(_DWORD *)(a1 + 212);
  if (v9)
    goto LABEL_6;
  v16 = *(_QWORD *)(a1 + 184);
  v17 = *(_DWORD *)(a1 + 192);
  v18 = v16 < a2;
  v19 = v16 - a2;
  if (!v18)
  {
    v20 = v17 + 1;
LABEL_17:
    v14 = 0;
    *(_QWORD *)(a1 + 184) = v19;
    *(_DWORD *)(a1 + 192) = v20;
    goto LABEL_18;
  }
  if (!v17)
  {
    v20 = 1;
    goto LABEL_17;
  }
LABEL_6:
  v10 = *(_DWORD *)(a1 + 208);
  if (v9 == v10
    || ((*(_DWORD *)(a1 + 212) = v9 + 1, v11 = *(_QWORD *)(a1 + 200), v12 = *(int *)(a1 + 220), (_DWORD)v12 + 1 != v10)
      ? (v13 = v12 + 1)
      : (v13 = 0),
        *(_DWORD *)(a1 + 220) = v13,
        !v11))
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateReserve", 114, 18, 0, "MemGateAllocateRequest", v4, v5, v22);
    v14 = 0;
    v15 = 0;
    goto LABEL_19;
  }
  v14 = v11 + (v12 << 7);
  *(_QWORD *)(v14 + 120) = a2;
LABEL_18:
  v15 = 1;
LABEL_19:
  if (pthread_mutex_unlock((pthread_mutex_t *)a1))
  {
    v6 = "MutexUnlock";
    v7 = 123;
  }
  else
  {
    if (!v14)
      goto LABEL_29;
    if (pthread_mutex_lock((pthread_mutex_t *)(v14 + 8)))
      goto LABEL_27;
    while (*(int *)v14 <= 0)
    {
      if (pthread_cond_wait((pthread_cond_t *)(v14 + 72), (pthread_mutex_t *)(v14 + 8)))
        goto LABEL_27;
    }
    --*(_DWORD *)v14;
    if (pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8)))
    {
LABEL_27:
      v6 = "SemAcquire";
      v7 = 129;
    }
    else
    {
      if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
      {
        v21 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 64) = v21 + 1;
        if ((v21 || !pthread_cond_broadcast((pthread_cond_t *)(a1 + 136)))
          && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72)))
        {
          goto LABEL_29;
        }
      }
      v6 = "SemRelease";
      v7 = 136;
    }
  }
LABEL_28:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateReserve", v7, 18, 0, v6, v4, v5, v22);
  v15 = 0;
LABEL_29:
  if (v15)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t MemGateFree(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  __int16 v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  const char *v26;
  __int16 v27;
  char v28;

  if (!a2)
    return 0;
  if (pthread_mutex_lock((pthread_mutex_t *)a1))
  {
    v6 = "MutexLock";
    v7 = 154;
  }
  else
  {
    *(_QWORD *)(a1 + 184) += a2;
    --*(_DWORD *)(a1 + 192);
    if (*(_DWORD *)(a1 + 212))
    {
      while (1)
      {
        v9 = *(_QWORD *)(a1 + 200);
        if (!v9)
          goto LABEL_26;
        v10 = v9 + ((uint64_t)*(int *)(a1 + 216) << 7);
        v11 = *(_QWORD *)(a1 + 184);
        v12 = *(_QWORD *)(v10 + 120);
        v13 = *(_DWORD *)(a1 + 192);
        v14 = v11 < v12;
        v15 = v11 - v12;
        if (v14 && v13 != 0)
          goto LABEL_26;
        *(_QWORD *)(a1 + 184) = v15;
        *(_DWORD *)(a1 + 192) = v13 + 1;
        if (pthread_mutex_lock((pthread_mutex_t *)(v10 + 8)))
          break;
        if (!(*(_DWORD *)v10)++)
        {
          if (pthread_cond_broadcast((pthread_cond_t *)(v10 + 72)))
            break;
        }
        if (pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8)))
          break;
        if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
          goto LABEL_27;
        while (1)
        {
          v20 = *(_DWORD *)(a1 + 64);
          if (v20 > 0)
            break;
          if (pthread_cond_wait((pthread_cond_t *)(a1 + 136), (pthread_mutex_t *)(a1 + 72)))
            goto LABEL_27;
        }
        *(_DWORD *)(a1 + 64) = v20 - 1;
        if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 72)))
        {
LABEL_27:
          v26 = "SemAcquire";
          v27 = 177;
LABEL_28:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateFree", v27, 18, 0, v26, v17, v18, v28);
          v25 = 0;
          goto LABEL_29;
        }
        v21 = *(_DWORD *)(a1 + 212);
        if (v21)
        {
          v22 = v21 - 1;
          v23 = *(_DWORD *)(a1 + 216);
          v24 = v23 + 1 == *(_DWORD *)(a1 + 208) ? 0 : v23 + 1;
          *(_DWORD *)(a1 + 212) = v22;
          *(_DWORD *)(a1 + 216) = v24;
          if (v22)
            continue;
        }
        goto LABEL_26;
      }
      v26 = "SemRelease";
      v27 = 176;
      goto LABEL_28;
    }
LABEL_26:
    v25 = 1;
LABEL_29:
    if (!pthread_mutex_unlock((pthread_mutex_t *)a1))
      goto LABEL_32;
    v6 = "MutexUnlock";
    v7 = 188;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateFree", v7, 18, 0, v6, v4, v5, v28);
  v25 = 0;
LABEL_32:
  if (v25)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t MemGateDestroy(pthread_mutex_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  pthread_cond_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  char v21;

  v9 = *(void **)a1[3].__opaque;
  if (v9)
  {
    if (*(int *)&a1[3].__opaque[8] < 1)
    {
      v11 = 1;
    }
    else
    {
      v10 = 0;
      v11 = 1;
      v12 = 72;
      do
      {
        v13 = (pthread_cond_t *)(*(_QWORD *)a1[3].__opaque + v12);
        if (pthread_mutex_destroy((pthread_mutex_t *)&v13[-2].__opaque[24]) || pthread_cond_destroy(v13))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 205, 18, 0, "SemDestroy", v14, v15, v21);
          v11 = 0;
        }
        ++v10;
        v12 += 128;
      }
      while (v10 < *(int *)&a1[3].__opaque[8]);
      v9 = *(void **)a1[3].__opaque;
    }
    free(v9);
    *(_QWORD *)a1[3].__opaque = 0;
  }
  else
  {
    v11 = 1;
  }
  if (*(int *)&a1[3].__opaque[8] >= 1)
  {
    if (LODWORD(a1[3].__sig))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 216, 18, 0, "memory leak", a7, a8, v21);
      v11 = 0;
    }
    if (*(_DWORD *)&a1[3].__opaque[12])
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 217, 18, 0, "pending requests", a7, a8, v21);
      v11 = 0;
    }
    if (pthread_mutex_destroy(a1))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 218, 18, 0, "MutexDestroy", v16, v17, v21);
      v11 = 0;
    }
    if (pthread_mutex_destroy((pthread_mutex_t *)((char *)a1 + 72))
      || pthread_cond_destroy((pthread_cond_t *)a1[2].__opaque))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateDestroy", 219, 18, 0, "SemDestroy", v18, v19, v21);
      v11 = 0;
    }
  }
  *(_OWORD *)&a1[3].__sig = 0u;
  *(_OWORD *)&a1[3].__opaque[8] = 0u;
  *(_OWORD *)&a1[2].__opaque[24] = 0u;
  *(_OWORD *)&a1[2].__opaque[40] = 0u;
  *(_OWORD *)&a1[2].__sig = 0u;
  *(_OWORD *)&a1[2].__opaque[8] = 0u;
  *(_OWORD *)&a1[1].__opaque[24] = 0u;
  *(_OWORD *)&a1[1].__opaque[40] = 0u;
  *(_OWORD *)&a1[1].__sig = 0u;
  *(_OWORD *)&a1[1].__opaque[8] = 0u;
  *(_OWORD *)&a1->__opaque[24] = 0u;
  *(_OWORD *)&a1->__opaque[40] = 0u;
  if (v11)
    result = 0;
  else
    result = 0xFFFFFFFFLL;
  *(_OWORD *)&a1->__sig = 0uLL;
  *(_OWORD *)&a1->__opaque[8] = 0uLL;
  return result;
}

uint64_t MemGateInit(pthread_mutex_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v11;
  __int16 v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  void *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char v26;

  *(_OWORD *)&a1[3].__sig = 0u;
  *(_OWORD *)&a1[3].__opaque[8] = 0u;
  *(_OWORD *)&a1[2].__opaque[24] = 0u;
  *(_OWORD *)&a1[2].__opaque[40] = 0u;
  *(_OWORD *)&a1[2].__sig = 0u;
  *(_OWORD *)&a1[2].__opaque[8] = 0u;
  *(_OWORD *)&a1[1].__opaque[24] = 0u;
  *(_OWORD *)&a1[1].__opaque[40] = 0u;
  *(_OWORD *)&a1[1].__sig = 0u;
  *(_OWORD *)&a1[1].__opaque[8] = 0u;
  *(_OWORD *)&a1->__opaque[24] = 0u;
  *(_OWORD *)&a1->__opaque[40] = 0u;
  *(_OWORD *)&a1->__sig = 0u;
  *(_OWORD *)&a1->__opaque[8] = 0u;
  if (a3 <= 0)
  {
    v11 = "bad # of allocation requests";
    v12 = 236;
  }
  else if (pthread_mutex_init(a1, 0))
  {
    v11 = "MutexInit";
    v12 = 239;
  }
  else
  {
    LODWORD(a1[1].__sig) = 0;
    if (pthread_mutex_init((pthread_mutex_t *)((char *)a1 + 72), 0)
      || pthread_cond_init((pthread_cond_t *)a1[2].__opaque, 0))
    {
      v11 = "SemInit";
      v12 = 240;
    }
    else
    {
      *(_QWORD *)&a1[2].__opaque[48] = a2;
      LODWORD(a1[3].__sig) = 0;
      *(_DWORD *)&a1[3].__opaque[8] = a3;
      *(_DWORD *)&a1[3].__opaque[12] = 0;
      *(_QWORD *)&a1[3].__opaque[16] = 0;
      v22 = calloc(a3, 0x80uLL);
      *(_QWORD *)a1[3].__opaque = v22;
      if (!v22)
      {
        v13 = *__error();
        v11 = "calloc";
        v12 = 250;
        goto LABEL_9;
      }
      v23 = 0;
      v24 = (unint64_t)a3 << 7;
      while (1)
      {
        v25 = *(_QWORD *)a1[3].__opaque;
        *(_DWORD *)(v25 + v23) = 0;
        if (pthread_mutex_init((pthread_mutex_t *)(v25 + v23 + 8), 0))
          break;
        result = pthread_cond_init((pthread_cond_t *)(v25 + v23 + 72), 0);
        if ((_DWORD)result)
          break;
        *(_QWORD *)(v25 + v23 + 120) = 0;
        v23 += 128;
        if (v24 == v23)
          return result;
      }
      v11 = "SemInit";
      v12 = 257;
    }
  }
  v13 = 0;
LABEL_9:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"MemGateInit", v12, 18, v13, v11, a7, a8, v26);
  MemGateDestroy(a1, v14, v15, v16, v17, v18, v19, v20);
  return 0xFFFFFFFFLL;
}

uint64_t loadDirectoryThreadProc(uint64_t a1)
{
  _QWORD *v1;
  unint64_t v2;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t FileDiskUsage;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v17[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD **)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 >= v1[1])
    return 0;
  while (1)
  {
    v4 = (const char *)(v1[5] + *(_QWORD *)(v1[2] + 184 * v2));
    if ((concatPath(v17, 0x400uLL, *(char **)a1, v4) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryThreadProc", 1064, 18, 0, "getting full path: %s", v5, v6, (char)v4);
      return 0xFFFFFFFFLL;
    }
    v1 = *(_QWORD **)(a1 + 8);
    if ((*(_DWORD *)(v1[2] + 184 * v2 + 56) - 1) > 2)
      goto LABEL_12;
    v7 = *(unsigned int *)(a1 + 32);
    FileDiskUsage = getFileDiskUsage(v17);
    v11 = FileDiskUsage >= 0 ? (FileDiskUsage + (v7 - 1)) & -v7 : FileDiskUsage;
    v1 = *(_QWORD **)(a1 + 8);
    v12 = v1[2];
    if ((v11 & 0x8000000000000000) == 0)
      break;
    if (*(_DWORD *)(v12 + 184 * v2 + 56) == 1)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryThreadProc", 1078, 18, 0, "getting disk usage: %s", v9, v10, (char)v17);
      return 0xFFFFFFFFLL;
    }
LABEL_12:
    v2 += *(_QWORD *)(a1 + 24);
    if (v2 >= v1[1])
      return 0;
  }
  v13 = v12 + 184 * v2;
  *(_QWORD *)(v13 + 152) = v11;
  if (*(_DWORD *)(v13 + 56) != 1)
    goto LABEL_12;
  if ((getFileSHA1Digest(v17, v12 + 184 * v2 + 128) & 0x80000000) == 0)
  {
    v1 = *(_QWORD **)(a1 + 8);
    goto LABEL_12;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryThreadProc", 1085, 18, 0, "getting SHA1 digest: %s", v14, v15, (char)v17);
  return 0xFFFFFFFFLL;
}

uint64_t InoTableEntryCmpProc(_QWORD *a1, _QWORD *a2)
{
  unint64_t v3;
  unint64_t v4;

  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  if (*a2 < *a1)
    return 1;
  v3 = a1[1];
  v4 = a2[1];
  if (v3 < v4)
    return 0xFFFFFFFFLL;
  else
    return v4 < v3;
}

uint64_t loadDirectory(char *a1, signed int DefaultNThreads, size_t a3)
{
  size_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char *v11;
  char v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  char *v31;
  char v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  unint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t Worker;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  const char *v70;
  __int16 v71;
  unsigned int *v72;
  char v73;
  _QWORD v74[4];
  size_t v75[2];

  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  v6 = strlen(a1);
  do
  {
    v7 = v6;
    if (!v6)
      break;
    --v6;
  }
  while (a1[v7 - 1] == 47);
  v75[0] = v7;
  v75[1] = a3;
  if (!DefaultNThreads)
    DefaultNThreads = getDefaultNThreads();
  if ((loadDirectoryProc(v75, a1) & 0x80000000) != 0)
  {
    v26 = "inserting root dir";
    v27 = 1132;
    goto LABEL_29;
  }
  v74[0] = v75;
  v74[1] = 0;
  v74[2] = 0;
  v74[3] = loadDirectoryProc;
  if ((enumerateTree(v74, a1) & 0x80000000) != 0)
  {
    v73 = (char)a1;
    v26 = "enumerateTree %s";
    v27 = 1139;
LABEL_29:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", v27, 18, 0, v26, v8, v9, v73);
    v11 = 0;
LABEL_30:
    LODWORD(v28) = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    goto LABEL_31;
  }
  qsort_r(*(void **)(a3 + 16), *(_QWORD *)(a3 + 8), 0xB8uLL, (void *)a3, (int (__cdecl *)(void *, const void *, const void *))DirectoryEntryPathCompareProc);
  v10 = 0;
  v11 = 0;
  v12 = 1;
  while (1)
  {
    v13 = *(_QWORD *)(a3 + 8);
    if (!v13)
      goto LABEL_46;
    v14 = 0;
    v15 = 0;
    v16 = -v13;
    v17 = *(_QWORD *)(a3 + 16) + 80;
    while (2)
    {
      v18 = (int *)(v17 + 184 * v15++);
      while (*(v18 - 6) == 1)
      {
        v19 = v15 - 1;
        if ((v12 & 1) == 0)
        {
          if (*(v18 - 14) >= 2)
          {
            if ((v10 & 1) != 0)
            {
              v20 = &v11[16 * v14];
              *(_QWORD *)v20 = *((_QWORD *)v18 - 8);
              *((_QWORD *)v20 + 1) = v19;
            }
LABEL_20:
            ++v14;
          }
          break;
        }
        *((_QWORD *)v18 - 1) = v19;
        *(_QWORD *)v18 = -1;
        *((_QWORD *)v18 + 1) = -1;
        if (*(v18 - 14) >= 2)
          goto LABEL_20;
        ++v15;
        v18 += 46;
        if (v16 + v15 == 1)
          goto LABEL_23;
      }
      if (v16 + v15)
        continue;
      break;
    }
    if ((v12 & 1) == 0)
      break;
LABEL_23:
    if (!v14)
      goto LABEL_46;
    v11 = (char *)calloc(v14, 0x10uLL);
    v12 = 0;
    v10 = 1;
    if (!v11)
    {
      v21 = *__error();
      v24 = "inoTable allocation";
      v25 = 1171;
LABEL_26:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", v25, 18, v21, v24, v22, v23, v73);
      goto LABEL_30;
    }
  }
  if (v14)
  {
    qsort(v11, v14, 0x10uLL, (int (__cdecl *)(const void *, const void *))InoTableEntryCmpProc);
    v38 = 0;
    v39 = 0;
    v40 = *(_QWORD *)(a3 + 8);
    v41 = -1;
    v42 = v11;
    v43 = -1;
    while (1)
    {
      v44 = v42[1];
      if (!v38 || *(v42 - 2) != *v42)
      {
        v39 = 0;
        ++v41;
        v43 = v42[1];
      }
      if (v43 >= v40 || v44 >= v40)
        break;
      v45 = (_QWORD *)(*(_QWORD *)(a3 + 16) + 184 * v44);
      v45[9] = v43;
      v45[10] = v41;
      v45[11] = v39++;
      ++v38;
      v42 += 2;
      if (v14 == v38)
        goto LABEL_46;
    }
    v24 = "Invalid index in ino table";
    v25 = 1187;
    v21 = 0;
    goto LABEL_26;
  }
LABEL_46:
  v46 = DefaultNThreads;
  v31 = (char *)calloc(DefaultNThreads, 0x28uLL);
  v47 = (char *)malloc(8 * DefaultNThreads);
  v30 = v47;
  if (v31 && v47)
  {
    if (DefaultNThreads < 1)
    {
      v72 = ThreadPoolCreate(DefaultNThreads, (uint64_t)v47, (uint64_t)loadDirectoryThreadProc);
      if (v72)
      {
        v29 = (uint64_t)v72;
        v32 = 0;
        LODWORD(v28) = 1;
        goto LABEL_32;
      }
    }
    else
    {
      v48 = 0;
      v49 = DefaultNThreads;
      v50 = v31;
      do
      {
        *(_QWORD *)&v47[v48] = v50;
        v48 += 8;
        v50 += 40;
      }
      while (8 * DefaultNThreads != v48);
      v51 = ThreadPoolCreate(DefaultNThreads, (uint64_t)v47, (uint64_t)loadDirectoryThreadProc);
      if (v51)
      {
        v29 = (uint64_t)v51;
        v59 = 0;
        while (1)
        {
          Worker = ThreadPoolGetWorker(v29, v52, v53, v54, v55, v56, v57, v58);
          v28 = Worker;
          if (!Worker)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", 1208, 18, 0, "ThreadPoolGetWorker", v61, v62, v73);
            goto LABEL_31;
          }
          *(_QWORD *)Worker = a1;
          *(_QWORD *)(Worker + 8) = a3;
          *(_QWORD *)(Worker + 16) = v59;
          *(_QWORD *)(Worker + 24) = v46;
          *(_DWORD *)(Worker + 32) = getFilesystemBlockSize(a1);
          if ((ThreadPoolRunWorker(v29, v28, v63, v64, v65, v66, v67, v68) & 0x80000000) != 0)
            break;
          ++v59;
          LODWORD(v28) = 1;
          if (v49 == v59)
          {
            v32 = 0;
            goto LABEL_32;
          }
        }
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", 1214, 18, 0, "ThreadPoolRunWorker", v57, v58, v73);
        LODWORD(v28) = 0;
        goto LABEL_31;
      }
    }
    v70 = "ThreadPoolCreate";
    v71 = 1201;
    v69 = 0;
  }
  else
  {
    v69 = *__error();
    v70 = "malloc";
    v71 = 1198;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", v71, 18, v69, v70, v57, v58, v73);
  LODWORD(v28) = 0;
  v29 = 0;
LABEL_31:
  v32 = 1;
LABEL_32:
  v33 = ThreadPoolDestroy(v29);
  v36 = v28 & ~(v33 >> 31);
  if ((v32 & 1) == 0 && (v33 & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectory", 1219, 18, 0, "A LoadDirectory thread reported an error", v34, v35, v73);
    v36 = 0;
  }
  free(v31);
  free(v30);
  free(v11);
  if (v36)
    return 0;
  free(*(void **)(a3 + 16));
  BlobBufferFree(a3 + 24);
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  return 0xFFFFFFFFLL;
}

uint64_t loadDirectoryProc(size_t *a1, char *a2)
{
  size_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  size_t v20;
  ssize_t v21;
  uint64_t result;
  uint64_t v23;
  char v24;
  stat v25;
  char v26[1024];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = a1[1];
  if (*(_QWORD *)(v4 + 8) >= *(_QWORD *)v4)
  {
    v5 = *(_QWORD *)v4 + 0x4000;
    *(_QWORD *)v4 = v5;
    v6 = reallocf(*(void **)(v4 + 16), 184 * v5);
    *(_QWORD *)(v4 + 16) = v6;
    if (!v6)
    {
      v9 = *__error();
      v10 = "reallocf";
      v11 = 992;
      goto LABEL_23;
    }
  }
  memset(&v25, 0, sizeof(v25));
  if (lstat(a2, &v25))
  {
    v9 = *__error();
    v24 = (char)a2;
    v10 = "%s";
    v11 = 998;
LABEL_23:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadDirectoryProc", v11, 18, v9, v10, v7, v8, v24);
    return 0xFFFFFFFFLL;
  }
  v12 = v25.st_mode & 0xF000;
  switch(v12)
  {
    case 16384:
      v15 = 0;
      v13 = 0;
      v14 = 2;
      break;
    case 32768:
      v15 = 0;
      v13 = 1;
      v14 = 1;
      break;
    case 40960:
      v13 = 0;
      v14 = 3;
      v15 = 1;
      break;
    default:
      v24 = 0;
      v10 = "Unsupported file type: %07o (%s)";
      v11 = 1006;
      goto LABEL_22;
  }
  v17 = *(_QWORD *)(v4 + 8);
  v16 = *(_QWORD *)(v4 + 16);
  v18 = v16 + 184 * v17;
  *(_QWORD *)(v4 + 8) = v17 + 1;
  *(_QWORD *)(v18 + 176) = 0;
  *(_OWORD *)(v18 + 144) = 0u;
  *(_OWORD *)(v18 + 160) = 0u;
  *(_OWORD *)(v18 + 112) = 0u;
  *(_OWORD *)(v18 + 128) = 0u;
  *(_OWORD *)(v18 + 80) = 0u;
  *(_OWORD *)(v18 + 96) = 0u;
  *(_OWORD *)(v18 + 48) = 0u;
  *(_OWORD *)(v18 + 64) = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(_OWORD *)(v18 + 32) = 0u;
  *(_OWORD *)v18 = 0u;
  if (strlen(a2) > *a1)
    v19 = &a2[*a1 + 1];
  else
    v19 = (const char *)&unk_206434423;
  v20 = strlen(v19);
  if (BlobBufferStore(v4 + 24, v19, v20 + 1, (_QWORD *)(v16 + 184 * v17)))
  {
    v10 = "Storing entry path";
    v11 = 1018;
LABEL_22:
    v9 = 0;
    goto LABEL_23;
  }
  if (v15)
  {
    bzero(v26, 0x400uLL);
    v21 = readlink(a2, v26, 0x3FFuLL);
    if (v21 < 0)
    {
      v9 = *__error();
      v24 = (char)a2;
      v10 = "%s";
      v11 = 1024;
      goto LABEL_23;
    }
    v26[v21] = 0;
    if (BlobBufferStore(v4 + 24, v26, v21 + 1, (_QWORD *)(v16 + 184 * v17 + 96)))
    {
      v10 = "Storing symlink path";
      v11 = 1026;
      goto LABEL_22;
    }
  }
  v23 = v16 + 184 * v17;
  *(_DWORD *)(v23 + 56) = v14;
  *(_QWORD *)(v23 + 72) = -1;
  *(_QWORD *)(v23 + 112) = *(_QWORD *)&v25.st_uid;
  *(_DWORD *)(v23 + 120) = v25.st_mode & 0xFFF;
  *(_QWORD *)(v23 + 160) = 0x7FFFFFFFLL;
  *(_DWORD *)(v23 + 124) = v25.st_flags;
  *(_QWORD *)(v23 + 48) = -1;
  *(_QWORD *)(v23 + 16) = v25.st_ino;
  *(_DWORD *)(v23 + 24) = v25.st_nlink;
  result = 0;
  if (v13)
    *(_QWORD *)(v16 + 184 * v17 + 64) = v25.st_size;
  return result;
}

uint64_t loadManifest(const char *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  const char *v12;
  __int16 v13;
  int v14;
  int v15;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD v55[2];
  void *__ptr[2];
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _QWORD *v63;

  v63 = 0;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v58 = 0u;
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v55[0] = 0;
  *(_OWORD *)__ptr = 0u;
  v57 = 0;
  v55[1] = a2;
  v3 = IFileStreamCreateWithFilename(a1, 0, -1);
  v11 = (char *)v3;
  if (!v3)
  {
    v12 = "IFileStreamCreateWithFilename";
    v13 = 1429;
    goto LABEL_7;
  }
  *(_QWORD *)&v59 = 0;
  *((_QWORD *)&v60 + 1) = 0;
  v61 = 0u;
  v62 = 0u;
  *(_QWORD *)&v58 = 0;
  *((_QWORD *)&v58 + 1) = IFileStreamRead;
  *((_QWORD *)&v59 + 1) = v3;
  *(_QWORD *)&v60 = loadManifestProc;
  v63 = v55;
  if (ParallelArchiveRead((uint64_t)&v58, v4, v5, v6, v7, v8, v9, v10))
  {
    v12 = "ParallelArchiveRead";
    v13 = 1442;
LABEL_7:
    v14 = 0;
LABEL_8:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadManifest", v13, 18, v14, v12, v9, v10, v54);
    v15 = 1;
    goto LABEL_9;
  }
  if (v55[0])
  {
    v12 = "errors during manifest scan";
    v13 = 1445;
    goto LABEL_7;
  }
  v17 = *(_QWORD *)(a2 + 8);
  if (v17)
  {
    v18 = 0;
    v19 = (unint64_t *)(*(_QWORD *)(a2 + 16) + 72);
    do
    {
      if (*((_DWORD *)v19 - 4) == 1)
      {
        *v19 = v18;
        if (*(v19 - 4))
        {
          v20 = *(_QWORD *)(a2 + 40);
          v21 = lookupEntry((_QWORD *)a2, (char *)(v20 + *(v19 - 5)));
          if ((v21 & 0x8000000000000000) != 0)
          {
            v54 = v20 + *(v19 - 9);
            v12 = "resolving hard link %s -> %s";
            v13 = 1464;
            goto LABEL_7;
          }
          if (v21 >= v18)
          {
            v54 = v20 + *(v19 - 9);
            v12 = "hard link resolved to a larger index: %s -> %s";
            v13 = 1465;
            goto LABEL_7;
          }
          *v19 = v21;
        }
      }
      ++v18;
      v19 += 23;
    }
    while (v17 != v18);
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = *(_QWORD *)(a2 + 16);
    v26 = (_QWORD *)(v25 + 80);
    do
    {
      if (*((_DWORD *)v26 - 6) == 1)
      {
        v27 = *(v26 - 1);
        if (v22 != v27)
        {
          if (*v26 == -1)
            ++v23;
          else
            ++v24;
          if (*v26 != *(_QWORD *)(v25 + 184 * v27 + 80))
          {
            v12 = "Inconsistent HLC fields in manifest";
            v13 = 1482;
            goto LABEL_7;
          }
        }
      }
      v26 += 23;
      ++v22;
    }
    while (v17 != v22);
    if (v24 && v23)
    {
      v12 = "Missing some HLC fields in manifest";
      v13 = 1484;
      goto LABEL_7;
    }
    if (!v24)
    {
      v37 = 0;
      v38 = *(_QWORD *)(a2 + 16);
      v39 = (uint64_t *)(v38 + 80);
      do
      {
        if (*((_DWORD *)v39 - 6) == 1)
        {
          v40 = *(v39 - 1);
          if (v24 != v40)
          {
            v41 = v38 + 184 * v40;
            v44 = *(_QWORD *)(v41 + 80);
            v43 = (_QWORD *)(v41 + 80);
            v42 = v44;
            if (v44 == -1)
            {
              *v43 = v37;
              v42 = v37++;
            }
            *v39 = v42;
          }
        }
        v39 += 23;
        ++v24;
      }
      while (v17 != v24);
    }
    v28 = 0;
    v45 = 0;
    v29 = 0;
    v46 = (_QWORD *)(*(_QWORD *)(a2 + 16) + 88);
    do
    {
      if (*((_DWORD *)v46 - 8) == 1)
      {
        v47 = *(v46 - 1);
        if (v47 != -1)
        {
          if (v47 > v28)
            v28 = *(v46 - 1);
          if (*v46 == -1)
            ++v45;
          else
            ++v29;
        }
      }
      v46 += 23;
      --v17;
    }
    while (v17);
    if (v29 && v45)
    {
      v12 = "Missing some HLO fields in manifest";
      v13 = 1516;
      goto LABEL_7;
    }
  }
  else
  {
    v28 = 0;
    v29 = 0;
  }
  if (__ptr[0] <= (void *)v28)
  {
    __ptr[0] = (void *)(v28 + 1);
    __ptr[1] = reallocf(__ptr[1], 8 * (v28 + 1));
    if (!__ptr[1])
    {
      v14 = *__error();
      v12 = "malloc";
      v13 = 1523;
      goto LABEL_8;
    }
  }
  if (v29)
  {
    if (__ptr[0])
      memset(__ptr[1], 255, 8 * (uint64_t)__ptr[0]);
    v30 = *(_QWORD *)(a2 + 8);
    if (v30)
    {
      v31 = 0;
      v32 = __ptr[1];
      v33 = (_QWORD *)(*(_QWORD *)(a2 + 16) + 88);
      do
      {
        if (*((_DWORD *)v33 - 8) == 1)
        {
          v34 = *(v33 - 1);
          if (v34 != -1)
          {
            if (*v33)
            {
              if (*v33 == -1)
              {
                v12 = "Missing HLO field";
                v13 = 1552;
                goto LABEL_7;
              }
            }
            else
            {
              if (v32[v34] != -1)
              {
                v12 = "Multiple HLO = 0 entries for same cluster";
                v13 = 1555;
                goto LABEL_7;
              }
              v32[v34] = v31;
            }
          }
        }
        v33 += 23;
        ++v31;
      }
      while (v30 != v31);
      v35 = __ptr[1];
      v36 = (_QWORD *)(*(_QWORD *)(a2 + 16) + 80);
      do
      {
        if (*((_DWORD *)v36 - 6) == 1 && *v36 != -1)
          *(v36 - 1) = v35[*v36];
        v36 += 23;
        --v30;
      }
      while (v30);
    }
  }
  else
  {
    if (__ptr[0])
      memset_pattern16(__ptr[1], &unk_20643F640, 8 * (uint64_t)__ptr[0]);
    v48 = *(_QWORD *)(a2 + 8);
    if (v48)
    {
      v49 = 0;
      v50 = __ptr[1];
      v51 = (_QWORD *)(*(_QWORD *)(a2 + 16) + 88);
      do
      {
        if (*((_DWORD *)v51 - 8) == 1)
        {
          v52 = *(v51 - 1);
          if (v52 != -1)
          {
            if (v49 == *(v51 - 2))
            {
              v53 = 0;
            }
            else
            {
              v53 = v50[v52];
              v50[v52] = v53 + 1;
            }
            *v51 = v53;
          }
        }
        ++v49;
        v51 += 23;
      }
      while (v48 != v49);
    }
  }
  v15 = 0;
  *(_DWORD *)(a2 + 48) = v57;
LABEL_9:
  IFileStreamDestroy(v11);
  free(__ptr[1]);
  if (v15)
  {
    free(*(void **)(a2 + 16));
    BlobBufferFree(a2 + 24);
    *(_QWORD *)(a2 + 48) = 0;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
  }
  return (v15 << 31 >> 31);
}

unint64_t loadManifestProc(unint64_t result, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  char *v20;
  size_t v21;
  int v22;
  char *v23;
  int v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  size_t v29;
  size_t v30;
  int v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int v37;
  int v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  __int128 v45;
  int v46;
  int v47;
  char *v48;
  _QWORD *v49;
  unint64_t *v50;
  _QWORD *v51;
  int v52;
  uint64_t v53;
  char *v54;
  __int128 v55;
  size_t v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  char __s[1024];
  uint64_t v68;

  v8 = result;
  v68 = *MEMORY[0x24BDAC8D0];
  v9 = a4;
  v12 = *(_QWORD *)(result + 8);
  v13 = 2;
  switch(a2[1])
  {
    case 'D':
      goto LABEL_5;
    case 'F':
    case 'H':
      v13 = 1;
      goto LABEL_5;
    case 'L':
      v13 = 3;
LABEL_5:
      v16 = *(_QWORD *)(v12 + 8);
      if (v16 >= *(_QWORD *)v12)
      {
        v18 = *(_QWORD *)v12 + 0x4000;
        *(_QWORD *)v12 = v18;
        v19 = reallocf(*(void **)(v12 + 16), 184 * v18);
        *(_QWORD *)(v12 + 16) = v19;
        if (!v19)
        {
          v24 = *__error();
          v14 = "reallocf";
          v15 = 1280;
          goto LABEL_108;
        }
        v17 = v19;
        v66 = a3;
        v16 = *(_QWORD *)(v12 + 8);
      }
      else
      {
        v66 = a3;
        v17 = *(_QWORD **)(v12 + 16);
      }
      *(_QWORD *)(v12 + 8) = v16 + 1;
      v20 = (char *)&v17[23 * v16];
      *((_QWORD *)v20 + 22) = 0;
      *((_OWORD *)v20 + 9) = 0u;
      *((_OWORD *)v20 + 10) = 0u;
      *((_OWORD *)v20 + 7) = 0u;
      *((_OWORD *)v20 + 8) = 0u;
      *((_OWORD *)v20 + 5) = 0u;
      *((_OWORD *)v20 + 6) = 0u;
      *((_OWORD *)v20 + 3) = 0u;
      *((_OWORD *)v20 + 4) = 0u;
      *((_OWORD *)v20 + 1) = 0u;
      *((_OWORD *)v20 + 2) = 0u;
      *(_OWORD *)v20 = 0u;
      v21 = strlen((const char *)a2 + 144);
      result = BlobBufferStore(v12 + 24, a2 + 36, v21 + 1, v20);
      if ((_DWORD)result)
      {
        v14 = "Storing path";
        v15 = 1287;
LABEL_107:
        v24 = 0;
        goto LABEL_108;
      }
      v22 = *a2;
      if ((*a2 & 2) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        v14 = "manifest doesn't provide UID for entry %s";
        v15 = 1288;
        goto LABEL_107;
      }
      if ((v22 & 4) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        v14 = "manifest doesn't provide GID for entry %s";
        v15 = 1289;
        goto LABEL_107;
      }
      if ((v22 & 0x10) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        v14 = "manifest doesn't provide MOD for entry %s";
        v15 = 1290;
        goto LABEL_107;
      }
      if ((v22 & 8) == 0)
      {
        LOBYTE(v57) = (_BYTE)a2 - 112;
        v14 = "manifest doesn't provide FLG for entry %s";
        v15 = 1291;
        goto LABEL_107;
      }
      v25 = (char *)&v17[23 * v16];
      *((_QWORD *)v25 + 14) = *((_QWORD *)a2 + 1);
      v26 = a2[4];
      v27 = a2[5] & 0xFFF;
      *((_QWORD *)v25 + 20) = 0x7FFFFFFFLL;
      v25 += 160;
      *((_DWORD *)v25 - 10) = v27;
      *((_DWORD *)v25 - 9) = v26;
      v64 = v25 - 36;
      v65 = v25;
      *((_DWORD *)v25 - 26) = v13;
      *((_QWORD *)v25 - 11) = -1;
      *((_QWORD *)v25 - 14) = -1;
      v28 = a2[1];
      if (v28 == 72)
      {
        v29 = strlen((const char *)a2 + 1168);
        result = BlobBufferStore(v12 + 24, a2 + 292, v29 + 1, &v17[23 * v16 + 4]);
        if ((_DWORD)result)
        {
          v14 = "Storing link path";
          v15 = 1304;
          goto LABEL_107;
        }
        v28 = a2[1];
      }
      if (v28 == 76)
      {
        v30 = strlen((const char *)a2 + 1168);
        result = BlobBufferStore(v12 + 24, a2 + 292, v30 + 1, &v17[23 * v16 + 12]);
        if ((_DWORD)result)
        {
          v14 = "Storing link path";
          v15 = 1309;
          goto LABEL_107;
        }
      }
      if (!v9)
      {
        v17[23 * v16 + 10] = -1;
        goto LABEL_51;
      }
      v31 = 0;
      v32 = 0;
      v33 = 0;
      v34 = 0;
      v35 = (uint64_t *)(v66 + 8);
      v36 = v9;
      do
      {
        v37 = *(_DWORD *)(v35 - 1) & 0xDFDFDF;
        if (v37 == 5196872)
        {
          if (*((_DWORD *)v35 - 1) == 1)
          {
            v34 = *v35;
            v32 = 1;
          }
        }
        else if (v37 == 4410440 && *((_DWORD *)v35 - 1) == 1)
        {
          v33 = *v35;
          v31 = 1;
        }
        v35 += 129;
        --v36;
      }
      while (v36);
      if (v32 && !v31)
      {
        v14 = "Invalid manifest, HLO without HLC";
        v15 = 1323;
        goto LABEL_107;
      }
      if (!v31)
      {
        v17[23 * v16 + 10] = -1;
        if (v32)
          goto LABEL_52;
        goto LABEL_51;
      }
      v39 = *(_QWORD *)(v8 + 16);
      if (v33 < v39)
        goto LABEL_67;
      v40 = *(_QWORD *)(v8 + 16);
      do
      {
        if (v40)
          v40 += v40 >> 1;
        else
          v40 = 16;
      }
      while (v33 >= v40);
      if (v40 <= v39)
      {
LABEL_67:
        result = *(_QWORD *)(v8 + 24);
LABEL_68:
        v42 = *(_QWORD *)(result + 8 * v33);
        if (v42 != -1)
        {
          if (v42 >= *(_QWORD *)(v12 + 8))
          {
            v14 = "invalid hard link index";
            v15 = 1352;
            goto LABEL_107;
          }
          v43 = v33;
          v61 = v32;
          v63 = v34;
          if ((unint64_t)__strlcpy_chk() >= 0x400)
          {
            v14 = "path too long";
            v15 = 1349;
            goto LABEL_107;
          }
          v56 = strlen(__s);
          result = BlobBufferStore(v12 + 24, __s, v56 + 1, &v17[23 * v16 + 4]);
          if ((_DWORD)result)
          {
            v14 = "Storing link path";
            v15 = 1350;
            goto LABEL_107;
          }
          v17[23 * v16 + 10] = v43;
          v34 = v63;
          if (!v61)
            goto LABEL_51;
LABEL_52:
          v17[23 * v16 + 11] = v34;
          v38 = a2[1];
          if (v38 == 70)
          {
            if ((*(_BYTE *)a2 & 0x80) == 0)
            {
              LOBYTE(v57) = (_BYTE)a2 - 112;
              v14 = "manifest doesn't provide SIZ for entry %s";
              v15 = 1361;
              goto LABEL_107;
            }
            v17[23 * v16 + 8] = *((_QWORD *)a2 + 5);
            if ((*((_BYTE *)a2 + 1) & 0x20) == 0)
            {
              LOBYTE(v57) = (_BYTE)a2 - 112;
              v14 = "manifest doesn't provide SH1 for entry %s";
              v15 = 1365;
              goto LABEL_107;
            }
            v44 = (char *)&v17[23 * v16];
            v45 = *(_OWORD *)(a2 + 23);
            *((_DWORD *)v44 + 36) = a2[27];
            *((_OWORD *)v44 + 8) = v45;
            v38 = a2[1];
            if (v38 == 70)
            {
              if ((*v64 & 0x20) == 0)
                *(_QWORD *)v65 = 0xFFFFFFFFLL;
              v38 = 70;
            }
          }
          v46 = *a2;
          if ((*a2 & 0x400) != 0)
          {
            LODWORD(v17[23 * v16 + 22]) = 1;
            v46 = *a2;
          }
          if ((v46 & 0x800) != 0)
            HIDWORD(v17[23 * v16 + 22]) = 1;
          v47 = 0;
          if (v9)
          {
            v48 = (char *)&v17[23 * v16];
            v49 = v48 + 152;
            v50 = (unint64_t *)(v48 + 168);
            v51 = (_QWORD *)(v66 + 8);
            do
            {
              v52 = *((_DWORD *)v51 - 2);
              if ((v52 & 0xDFDFDF) == 0x5A5544)
              {
                *v49 = *v51;
                v52 = *((_DWORD *)v51 - 2);
                v47 = 1;
              }
              if ((v52 & 0xDFDFDF) == 0x544641)
              {
                *(_DWORD *)v65 = *v51;
                v52 = *((_DWORD *)v51 - 2);
              }
              if ((v52 & 0xDFDFDF) == 0x524641)
              {
                *((_DWORD *)v65 + 1) = *v51;
                v52 = *((_DWORD *)v51 - 2);
              }
              result = v52 & 0xDFDFDF;
              if ((_DWORD)result == 4803654)
              {
                result = *(unsigned int *)v51;
                *v50 = result;
              }
              v51 += 129;
              --v9;
            }
            while (v9);
          }
          if (v38 != 70 || v47)
          {
            if (v38 != 72)
              return result;
            result = lookupEntry((_QWORD *)v12, (char *)a2 + 1168);
            if ((result & 0x8000000000000000) == 0)
            {
              v53 = *(_QWORD *)(v12 + 16) + 184 * result;
              v54 = (char *)&v17[23 * v16];
              *((_QWORD *)v54 + 8) = *(_QWORD *)(v53 + 64);
              *((_QWORD *)v54 + 19) = *(_QWORD *)(v53 + 152);
              v55 = *(_OWORD *)(v53 + 128);
              *((_DWORD *)v54 + 36) = *(_DWORD *)(v53 + 144);
              *((_OWORD *)v54 + 8) = v55;
              return result;
            }
            LOBYTE(v57) = (_BYTE)a2 - 112;
            v14 = "link path not found: %s -> %s";
            v15 = 1403;
          }
          else
          {
            LOBYTE(v57) = (_BYTE)a2 - 112;
            v14 = "manifest doesn't provide DUZ for regular file %s";
            v15 = 1396;
          }
          goto LABEL_107;
        }
        *(_QWORD *)(result + 8 * v33) = 0xD37A6F4DE9BD37A7 * ((uint64_t)&v20[-*(_QWORD *)(v12 + 16)] >> 3);
        v17[23 * v16 + 10] = v33;
        if (v32)
          goto LABEL_52;
LABEL_51:
        v34 = -1;
        goto LABEL_52;
      }
      v60 = v32;
      v62 = v34;
      v59 = v33;
      result = (unint64_t)reallocf(*(void **)(v8 + 24), 8 * v40);
      *(_QWORD *)(v8 + 24) = result;
      if (result)
      {
        v41 = *(_QWORD *)(v8 + 16);
        if (v41 < v40)
        {
          v58 = result;
          memset((void *)(result + 8 * v41), 255, 8 * v40 - 8 * v41);
          result = v58;
        }
        *(_QWORD *)(v8 + 16) = v40;
        v34 = v62;
        v32 = v60;
        v33 = v59;
        goto LABEL_68;
      }
      v24 = *__error();
      v14 = "malloc";
      v15 = 1333;
LABEL_108:
      result = pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"loadManifestProc", v15, 18, v24, v14, a7, a8, v57);
      ++*(_QWORD *)v8;
      return result;
    case 'M':
      if (a4)
      {
        v23 = (char *)(a3 + 8);
        do
        {
          if ((*((_DWORD *)v23 - 2) & 0xDFDFDF) == 0x464159 && *((_DWORD *)v23 - 1) == 7)
          {
            result = (unint64_t)strstr(v23, "XAT");
            if (result)
            {
              result = (unint64_t)strstr(v23, "ACL");
              if (result)
              {
                result = (unint64_t)strstr(v23, "AFT");
                if (result)
                {
                  result = (unint64_t)strstr(v23, "AFR");
                  if (result)
                    *(_DWORD *)(v8 + 32) = 1;
                }
              }
            }
          }
          v23 += 1032;
          --v9;
        }
        while (v9);
      }
      return result;
    default:
      v57 = a2[1];
      v14 = "Unsupported file type: %d";
      v15 = 1273;
      goto LABEL_107;
  }
}

unint64_t lookupEntry(_QWORD *a1, char *__s1)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v11;
  int v12;

  v2 = a1[1];
  if (v2)
  {
    v4 = (_QWORD *)a1[2];
    v5 = a1[5];
    v6 = strcmp(__s1, (const char *)(v5 + *v4));
    if ((v6 & 0x80000000) == 0)
    {
      if (!v6)
        return 0;
      v7 = v2 - 1;
      v8 = strcmp(__s1, (const char *)(v5 + v4[23 * v2 - 23]));
      if (v8 <= 0)
      {
        if (!v8)
          return v2 - 1;
        v11 = 0;
        while (v11 + 1 < v7)
        {
          v9 = (v7 + v11) >> 1;
          v12 = strcmp(__s1, (const char *)(v5 + v4[23 * v9]));
          if (v12 < 0)
            v7 = (v7 + v11) >> 1;
          else
            v11 = (v7 + v11) >> 1;
          if (!v12)
            return v9;
        }
      }
    }
  }
  return -1;
}

size_t mergeContents(size_t result, uint64_t a2, void *a3)
{
  size_t v4;
  uint64_t *v5;
  size_t v6;
  uint64_t v7;
  const char **v8;
  const char **v9;
  size_t v10;
  uint64_t i;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  const char *v18;
  size_t v19;
  const char **v20;
  const char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  void *v27;
  uint64_t v28;
  const char **v29;
  size_t v30;
  uint64_t v31;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  size_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  _QWORD *v50;
  const char *v51;
  size_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  uint64_t *v57;

  *(_QWORD *)a3 = result;
  if (result)
  {
    v4 = result;
    result = 0;
    v5 = (uint64_t *)(a2 + 8);
    v6 = v4;
    do
    {
      v7 = *v5;
      v5 += 7;
      result += v7;
      --v6;
    }
    while (v6);
    if (result)
    {
      v8 = (const char **)calloc(result, 8uLL);
      v9 = v8;
      if (v8)
      {
        v10 = 0;
        for (i = 0; i != v4; ++i)
        {
          v12 = *(_QWORD *)(a2 + 56 * i + 8);
          if (v12)
          {
            v13 = 0;
            v14 = 0;
            v15 = a2 + 56 * i;
            v16 = (_QWORD *)(v15 + 16);
            v17 = (_QWORD *)(v15 + 40);
            do
            {
              if (v12 <= v14)
                v18 = 0;
              else
                v18 = (const char *)(*v17 + *(_QWORD *)(*v16 + v13));
              (&v8[v10])[v14++] = v18;
              v13 += 184;
            }
            while (v12 != v14);
            v10 += v14;
          }
        }
        qsort(v8, v10, 8uLL, (int (__cdecl *)(const void *, const void *))stringCompareProc);
        if (v10)
        {
          v19 = 0;
          v20 = v9;
          while (1)
          {
            if (v19)
            {
              v21 = *v20;
              if (!strcmp(v9[v19 - 1], *v20))
                goto LABEL_22;
            }
            else
            {
              v21 = *v20;
            }
            v9[v19++] = v21;
LABEL_22:
            ++v20;
            if (!--v10)
              goto LABEL_26;
          }
        }
        v19 = 0;
LABEL_26:
        *((_QWORD *)a3 + 1) = v19;
        v27 = calloc(v19, 0x4B8uLL);
        *((_QWORD *)a3 + 4) = v27;
        if (v27)
        {
          if (v19)
          {
            v28 = 0;
            v29 = v9;
            v30 = v19;
            while (1)
            {
              v31 = *((_QWORD *)a3 + 4) + v28;
              *(_DWORD *)(v31 + 1200) = -1;
              v32 = strlen(*v29);
              if (BlobBufferStore((uint64_t)a3 + 40, *v29, v32 + 1, (_QWORD *)v31))
                break;
              ++v29;
              v28 += 1208;
              if (!--v30)
                goto LABEL_31;
            }
            v25 = "Storing entry path";
            v26 = 1640;
          }
          else
          {
LABEL_31:
            v33 = 0;
            v53 = (uint64_t)a3 + 40;
            while (1)
            {
              v55 = (_QWORD *)(a2 + 56 * v33 + 8);
              if (*v55)
                break;
LABEL_45:
              *((_DWORD *)a3 + v33 + 153232) = *(_DWORD *)(a2 + 56 * v33 + 48);
              if (++v33 == v4)
              {
                free(v9);
                return 0;
              }
            }
            v34 = 0;
            v35 = 0;
            v36 = a2 + 56 * v33;
            v56 = (_QWORD *)(v36 + 40);
            v57 = (uint64_t *)(v36 + 16);
            v54 = v33;
            while (1)
            {
              v37 = *v57;
              if (v35 < v19)
              {
                v38 = (const char *)(*v56 + *(_QWORD *)(v37 + 184 * v34));
                v39 = *((_QWORD *)a3 + 7);
                v40 = (_QWORD *)(*((_QWORD *)a3 + 4) + 1208 * v35);
                while (strcmp(v38, (const char *)(v39 + *v40)))
                {
                  v40 += 151;
                  if (v19 == ++v35)
                    goto LABEL_48;
                }
              }
              if (v35 == v19)
              {
LABEL_48:
                v25 = "unable to locate path in merged array";
                v26 = 1654;
                goto LABEL_50;
              }
              v41 = v37 + 184 * v34;
              *(_QWORD *)(v41 + 48) = v35;
              v33 = v54;
              v42 = *((_QWORD *)a3 + 4) + 1208 * v35 + 16 + (v54 << 7);
              v43 = *(_OWORD *)(v41 + 120);
              v44 = *(_OWORD *)(v41 + 136);
              v45 = *(_OWORD *)(v41 + 168);
              *(_OWORD *)(v42 + 96) = *(_OWORD *)(v41 + 152);
              *(_OWORD *)(v42 + 112) = v45;
              *(_OWORD *)(v42 + 64) = v43;
              *(_OWORD *)(v42 + 80) = v44;
              v46 = *(_OWORD *)(v41 + 56);
              v47 = *(_OWORD *)(v41 + 72);
              v48 = *(_OWORD *)(v41 + 104);
              *(_OWORD *)(v42 + 32) = *(_OWORD *)(v41 + 88);
              *(_OWORD *)(v42 + 48) = v48;
              *(_OWORD *)v42 = v46;
              *(_OWORD *)(v42 + 16) = v47;
              v49 = *(_QWORD *)(v41 + 72);
              if (v49 != -1)
                v49 = *(_QWORD *)(*v57 + 184 * v49 + 48);
              *(_QWORD *)(v42 + 40) = 0;
              v50 = (_QWORD *)(v42 + 40);
              *(v50 - 3) = v49;
              v50[1] = 0;
              if (*(_QWORD *)(v37 + 184 * v34 + 104))
              {
                v51 = (const char *)(*v56 + *(_QWORD *)(v37 + 184 * v34 + 96));
                v52 = strlen(v51);
                if (BlobBufferStore(v53, v51, v52 + 1, v50))
                  break;
              }
              if ((unint64_t)++v34 >= *v55)
                goto LABEL_45;
            }
            v25 = "Storing slink path";
            v26 = 1678;
          }
LABEL_50:
          v22 = 0;
        }
        else
        {
          v22 = *__error();
          v25 = "malloc";
          v26 = 1633;
        }
      }
      else
      {
        v22 = *__error();
        v25 = "malloc";
        v26 = 1610;
      }
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"mergeContents", v26, 18, v22, v25, v23, v24, v53);
      free(v9);
      free(*((void **)a3 + 4));
      BlobBufferFree((uint64_t)a3 + 40);
      bzero(a3, 0x989F0uLL);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t stringCompareProc(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

uint64_t applyRules(const __CFArray *a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFArray *a5, const __CFArray *a6, const __CFArray *a7, const __CFArray *a8, uint64_t *a9, int a10)
{
  uint64_t v17;
  uint64_t v18;
  unint64_t i;
  uint64_t v20;
  int v21;
  const char *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  unint64_t j;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  const char *v35;
  const char *v36;
  const char *v37;
  const char *v38;
  unsigned int v39;
  int v40;
  const char *v41;
  const char *v42;
  const char *v43;
  const char *v44;
  const char *v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t result;
  uint64_t v52;

  v17 = *a9;
  v52 = a9[1];
  if ((markFilesMatchingPrefixArray(a9, a1, 1, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a2, 2, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a3, 4, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a4, 16, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a5, 32, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a6, 64, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a7, 512, a10) & 0x80000000) != 0
    || (markFilesMatchingPrefixArray(a9, a8, 1024, a10) & 0x80000000) != 0)
  {
    return 0xFFFFFFFFLL;
  }
  if (!v52)
    return 0;
  v18 = 0;
  for (i = 0; i != v52; ++i)
  {
    v20 = a9[4];
    v21 = *(_DWORD *)(v20 + v18 + 1172);
    if ((v21 & 2) != 0 && !*(_DWORD *)(v20 + (v17 << 7) - 112 + v18))
    {
      *(_DWORD *)(v20 + v18 + 1172) = v21 & 0xFFFFFFFD;
      if (a10 >= 2)
      {
        v22 = "???";
        if ((v21 & 4) != 0)
          v22 = "Remove";
        v23 = "Include";
        if ((v21 & 1) != 0)
        {
          v23 = "Exclude";
          v22 = "Exclude";
        }
        if ((v21 & 5) != 0)
          v24 = v22;
        else
          v24 = "None";
        if (a9[1] <= i)
          v25 = 0;
        else
          v25 = (const char *)(a9[7] + *(_QWORD *)(v20 + v18));
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Rules from %s to %s (include not in output): %s\n", v23, v24, v25);
      }
    }
    v18 += 1208;
  }
  v26 = 0;
  for (j = 0; j != v52; ++j)
  {
    v28 = a9[4];
    v29 = v28 + v26;
    v30 = *(_DWORD *)(v28 + v26 + 1172);
    if (v30)
    {
      v31 = v30 & 0xFFFFFFEE;
      if ((v30 & 0x10) == 0)
        v31 = *(_DWORD *)(v28 + v26 + 1172);
      v32 = v31 & 0x20;
      if ((v31 & 0x20) != 0)
        v31 &= 0xFFFFFFDD;
      v33 = *(_DWORD *)(v28 + v26 + 1172) & 0x10 | v32;
      v34 = v31 & 0x40;
      if ((v31 & 0x40) != 0)
        v31 &= 0xFFFFFFBB;
      if (v33 | v34)
        *(_DWORD *)(v29 + 1172) = v31;
      if (a10 >= 2)
      {
        if (v31 != v30)
        {
          v35 = "Remove";
          if ((v30 & 4) == 0)
            v35 = "???";
          if ((v30 & 2) != 0)
            v35 = "Include";
          if ((v30 & 1) != 0)
            v35 = "Exclude";
          if ((v30 & 7) != 0)
            v36 = v35;
          else
            v36 = "None";
          if ((v31 & 7) != 0)
          {
            v37 = "Exclude";
            if ((v31 & 1) == 0)
            {
              v37 = "Remove";
              if ((v31 & 4) == 0)
                v37 = "???";
              if ((v31 & 2) != 0)
                v37 = "Include";
            }
          }
          else
          {
            v37 = "None";
          }
          if (a9[1] <= j)
            v38 = 0;
          else
            v38 = (const char *)(a9[7] + *(_QWORD *)(v28 + v26));
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Rules from %s to %s (no-xxx): %s\n", v36, v37, v38);
          v30 = *(_DWORD *)(v29 + 1172);
        }
      }
      else
      {
        v30 = v31;
      }
      v39 = v30 & 0xFFFFFFFA;
      if ((v30 & 2) == 0)
        v39 = v30;
      v40 = v39 & 1;
      if ((v39 & 1) != 0)
        v39 &= ~4u;
      if (v30 & 2 | v40)
        *(_DWORD *)(v29 + 1172) = v39;
      if (a10 >= 2 && v39 != v30)
      {
        v41 = "Include";
        if ((v30 & 1) != 0)
          v41 = "Exclude";
        v42 = "Remove";
        if ((v30 & 4) == 0)
          v42 = "???";
        if ((v30 & 3) != 0)
          v43 = v41;
        else
          v43 = v42;
        if ((v30 & 7) != 0)
          v44 = v43;
        else
          v44 = "None";
        if ((v39 & 7) != 0)
        {
          v45 = "Exclude";
          if ((v39 & 1) == 0)
          {
            v45 = "Include";
            if ((v39 & 2) == 0)
            {
              v45 = "???";
              if ((v39 & 4) != 0)
                v45 = "Remove";
            }
          }
        }
        else
        {
          v45 = "None";
        }
        if (a9[1] <= j)
          v46 = 0;
        else
          v46 = (const char *)(a9[7] + *(_QWORD *)(a9[4] + v26));
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Rules from %s to %s (priority): %s\n", v44, v45, v46);
      }
    }
    v26 += 1208;
  }
  v47 = 0;
  v48 = 1172;
  do
  {
    v49 = a9[4];
    v50 = *(_DWORD *)(v49 + v48);
    if ((v50 & 0x200) != 0)
    {
      *(_DWORD *)(v49 + v48) = v50 & 0xFFFFFAFF;
      if (a10 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Label PREPARE: %s\n");
    }
    else if ((v50 & 0x400) != 0)
    {
      *(_DWORD *)(v49 + v48) = v50 & 0xFFFFFEFF;
      if (a10 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Label DATA: %s\n");
    }
    else
    {
      *(_DWORD *)(v49 + v48) = v50 | 0x100;
      if (a10 >= 2)
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Label MAIN: %s\n");
    }
    result = 0;
    ++v47;
    v48 += 1208;
  }
  while (v52 != v47);
  return result;
}

CFIndex markFilesMatchingPrefixArray(_QWORD *a1, CFArrayRef theArray, int a3, int a4)
{
  const __CFArray *v5;
  CFIndex result;
  CFIndex v8;
  CFIndex v9;
  const char *v10;
  const char *v11;
  const __CFString *ValueAtIndex;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  size_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  const char *v39;
  char v40;
  CFIndex v41;
  const __CFArray *v42;
  const char *v43;
  int v44;
  int v45;
  char buffer[1024];
  char __s2[1024];
  uint64_t v48;

  v45 = a4;
  v48 = *MEMORY[0x24BDAC8D0];
  if (!theArray)
    return 0;
  v5 = theArray;
  result = CFArrayGetCount(theArray);
  if (!result)
    return result;
  v8 = result;
  if (result < 1)
  {
LABEL_59:
    v36 = a1[1];
    if (v36)
    {
      v37 = 0;
      v38 = (_DWORD *)(a1[4] + 1172);
      do
      {
        if ((*v38 & a3) != 0)
          ++v37;
        v38 += 302;
        --v36;
      }
      while (v36);
    }
    else
    {
      v37 = 0;
    }
    if (v45 > 1)
    {
      if (a3)
      {
        if ((a3 & 1) != 0)
        {
          v39 = "Exclude";
        }
        else if ((a3 & 2) != 0)
        {
          v39 = "Include";
        }
        else if ((a3 & 4) != 0)
        {
          v39 = "Remove";
        }
        else if ((a3 & 0x10) != 0)
        {
          v39 = "NoExclude";
        }
        else if ((a3 & 0x20) != 0)
        {
          v39 = "NoInclude";
        }
        else if ((a3 & 0x40) != 0)
        {
          v39 = "NoRemove";
        }
        else if ((a3 & 0x100) != 0)
        {
          v39 = "Main";
        }
        else if ((a3 & 0x200) != 0)
        {
          v39 = "Prepare";
        }
        else
        {
          v39 = "Data";
          if ((a3 & 0x400) == 0)
            v39 = "???";
        }
      }
      else
      {
        v39 = "None";
      }
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s rules: %zu total entries match\n", v39, v37);
    }
    return 0;
  }
  v9 = 0;
  v10 = "Data";
  if ((a3 & 0x400) == 0)
    v10 = "???";
  v11 = "Include";
  if ((a3 & 1) != 0)
    v11 = "Exclude";
  if ((a3 & 3) == 0)
    v11 = "Remove";
  if ((a3 & 7) == 0)
    v11 = "NoExclude";
  if ((a3 & 0x17) == 0)
    v11 = "NoInclude";
  if ((a3 & 0x37) == 0)
    v11 = "NoRemove";
  if ((a3 & 0x77) == 0)
    v11 = "Main";
  if ((a3 & 0x200) != 0)
    v10 = "Prepare";
  if ((a3 & 0x177) != 0)
    v10 = v11;
  if (!a3)
    v10 = "None";
  v42 = v5;
  v43 = v10;
  v41 = result;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v9);
    if (!ValueAtIndex)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"markFilesMatchingPrefixArray", 2053, 18, 0, "CFArrayGetValueAtIndex(%ld) returned 0", v13, v14, v9);
      return 0xFFFFFFFFLL;
    }
    v15 = ValueAtIndex;
    bzero(buffer, 0x400uLL);
    CFStringGetCString(v15, buffer, 1024, 0x8000100u);
    v16 = strlen(buffer);
    if (!v16)
      goto LABEL_58;
    if (buffer[v16 - 1] == 47)
    {
      buffer[v16 - 1] = 0;
      if (v16 == 1)
        goto LABEL_58;
    }
    v17 = a1[1];
    if (!v17)
      goto LABEL_58;
    bzero(__s2, 0x400uLL);
    v18 = strlen(buffer);
    if (v18 - 1024 <= 0xFFFFFFFFFFFFFC00)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"markFilesMatchingPrefix", 1986, 18, 0, "invalid prefix length", v19, v20, v40);
      break;
    }
    v21 = v18;
    __memcpy_chk();
    v44 = __s2[v21 - 1];
    if (v44 == 36)
      __s2[--v21] = 0;
    v22 = (_QWORD *)a1[4];
    v23 = a1[7];
    if (strcmp((const char *)(v23 + *v22), __s2) < 0)
    {
      if (v17 < 2)
      {
        v30 = 1;
      }
      else
      {
        v26 = 0;
        v27 = v17;
        v28 = v17;
        do
        {
          v29 = v26 + (v27 >> 1);
          if (strcmp((const char *)(v23 + v22[151 * v29]), __s2) >= 0)
            v28 = v29;
          else
            v26 = v29;
          v27 = v28 - v26;
        }
        while (v28 - v26 > 1);
        v30 = v26 + 1;
      }
    }
    else
    {
      v30 = 0;
    }
    if (v30 >= v17)
    {
      v8 = v41;
      v5 = v42;
      goto LABEL_58;
    }
    v31 = 0;
    v32 = 1208 * v30;
    do
    {
      if (a1[1] <= v30)
        break;
      v33 = a1[4];
      v34 = (const char *)(a1[7] + *(_QWORD *)(v33 + v32));
      if (strncmp(v34, __s2, v21))
        break;
      if (v34[v21])
      {
        if (v44 == 36)
          goto LABEL_54;
        if (v34[v21] != 47)
          goto LABEL_54;
        *(_DWORD *)(v33 + v32 + 1172) |= a3;
        ++v31;
        v35 = "%s rule [%s] prefix match: %s\n";
        if (v45 < 2)
          goto LABEL_54;
LABEL_53:
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], v35, v43, __s2, v34);
        goto LABEL_54;
      }
      *(_DWORD *)(v33 + v32 + 1172) |= a3;
      ++v31;
      v35 = "%s rule [%s] exact match: %s\n";
      if (v45 > 1)
        goto LABEL_53;
LABEL_54:
      ++v30;
      v32 += 1208;
    }
    while (v17 != v30);
    v8 = v41;
    v5 = v42;
    if (v31 < 0)
      break;
LABEL_58:
    if (++v9 == v8)
      goto LABEL_59;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"markFilesMatchingPrefixArray", 2061, 18, 0, "markFilesMatchingPrefix failed", v24, v25, v40);
  return 0xFFFFFFFFLL;
}

uint64_t fixOpsForHardLinkClusters(uint64_t *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  char v31;
  char v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  unsigned int *v39;
  _QWORD *v40;
  _QWORD *v41;
  unint64_t v42;
  uint64_t v43;
  int v45;
  const char *v46;
  void **v47;
  void *v48;
  char v50;
  _OWORD v51[4];
  uint64_t v52;
  _OWORD v53[4];
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = a1[1];
  v6 = *a1 - 1;
  v54 = 0;
  memset(v53, 0, sizeof(v53));
  v52 = 0;
  memset(v51, 0, sizeof(v51));
  if (v5)
  {
    v7 = 0;
    v8 = a1[4];
    v9 = (unint64_t *)(v8 + 40);
    do
    {
      if (*(_DWORD *)(v8 + 1208 * v7 + (v6 << 7) + 16) == 1
        && (*(_BYTE *)(v8 + 1208 * v7 + 1168) & 0x14) != 0
        && v6 != 0)
      {
        v11 = (unint64_t *)v53;
        v12 = v9;
        v13 = v6;
        do
        {
          v14 = *v12;
          if (*((_DWORD *)v12 - 6) == 1 && v14 != -1)
          {
            if (v14 <= *v11)
              v14 = *v11;
            *v11 = v14;
          }
          v12 += 16;
          ++v11;
          --v13;
        }
        while (v13);
      }
      ++v7;
      v9 += 151;
    }
    while (v7 != v5);
  }
  if (!v6)
  {
LABEL_24:
    if (v5)
    {
      v22 = 0;
      v23 = a1[4];
      v24 = (_QWORD *)(v23 + 40);
      do
      {
        if (*(_DWORD *)(v23 + 1208 * v22 + (v6 << 7) + 16) == 1
          && (*(_BYTE *)(v23 + 1208 * v22 + 1168) & 0x14) != 0
          && v6 != 0)
        {
          v26 = v51;
          v27 = v24;
          v28 = v6;
          do
          {
            v29 = *v27;
            if (*((_DWORD *)v27 - 6) == 1 && v29 != -1)
              ++*(_DWORD *)(*v26 + 4 * v29);
            v27 += 16;
            ++v26;
            --v28;
          }
          while (v28);
        }
        ++v22;
        v24 += 151;
      }
      while (v22 != v5);
    }
    v31 = 1;
    while (1)
    {
      v32 = v31;
      if (v5)
        break;
LABEL_64:
      v31 = 0;
      v21 = 0;
      if ((v32 & 1) == 0)
      {
        if (!v6)
          return (v21 << 31 >> 31);
        goto LABEL_69;
      }
    }
    v33 = 0;
    v34 = 40;
    while (1)
    {
      v35 = a1[4];
      if (*(_DWORD *)(v35 + 1208 * v33 + (v6 << 7) + 16) == 1)
      {
        v36 = v35 + 1208 * v33;
        v37 = *(_DWORD *)(v36 + 1168);
        if ((v32 & 1) != 0)
        {
          if ((v37 & 4) != 0)
            goto LABEL_47;
        }
        else if ((v37 & 0x10) != 0)
        {
LABEL_47:
          if (v6)
          {
            v38 = 0;
            v39 = (unsigned int *)(v36 + 1168);
            v40 = (_QWORD *)(v35 + v34);
            v41 = v51;
            v42 = v6;
            do
            {
              v43 = *v40;
              if (*((_DWORD *)v40 - 6) == 1 && v43 != -1)
              {
                v45 = *(_DWORD *)(*v41 + 4 * v43);
                if (v45 >= 2)
                {
                  *(_DWORD *)(*v41 + 4 * v43) = v45 - 1;
                  v38 = 1;
                }
              }
              v40 += 16;
              ++v41;
              --v42;
            }
            while (v42);
            if (v38)
            {
              if (a2 >= 2)
              {
                if (a1[1] <= v33)
                  v46 = 0;
                else
                  v46 = (const char *)(a1[7] + *(_QWORD *)(v35 + 1208 * v33));
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE entry with invalid cluster mapping: %s\n", v46);
              }
              *v39 = *v39 & 0xFFFFFFEA | 1;
            }
          }
        }
      }
      ++v33;
      v34 += 1208;
      if (v33 == v5)
        goto LABEL_64;
    }
  }
  *(_QWORD *)&v51[0] = calloc(*(_QWORD *)&v53[0] + 1, 4uLL);
  if (*(_QWORD *)&v51[0])
  {
    v18 = 0;
    v19 = v4 - 2;
    do
    {
      if (v19 == v18)
        goto LABEL_24;
      v20 = calloc(*((_QWORD *)v53 + v18 + 1) + 1, 4uLL);
      *((_QWORD *)v51 + ++v18) = v20;
    }
    while (v20);
    v21 = v18 < v6;
  }
  else
  {
    v21 = 1;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"fixOpsForHardLinkClusters", 2318, 18, 0, "calloc", v16, v17, v50);
LABEL_69:
  v47 = (void **)v51;
  do
  {
    v48 = *v47++;
    free(v48);
    --v6;
  }
  while (v6);
  return (v21 << 31 >> 31);
}

uint64_t initOps(unint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t *a5, int a6)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  int v18;
  int v19;
  int *v20;
  uint64_t v21;
  int v22;
  _QWORD *v23;
  uint64_t v24;
  int v25;
  _BOOL8 v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  int32x4_t v34;
  uint64_t v35;
  _DWORD *v36;
  uint64_t v37;
  int v40;
  int *v41;
  int v42;
  BOOL v43;
  FILE *v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  unint64_t v52;
  int IsCompressed;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v61;
  int v62;
  const char *v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  int v70;
  uint64_t v75;
  uint64_t v76;

  v8 = a5[1];
  v76 = *a5;
  if (v8)
  {
    v9 = 0;
    v10 = v76 - 1;
    v67 = a1 >> 2;
    v11 = 16;
    v12 = 88;
    v13 = 56;
    v14 = 140;
    v15 = 24;
    v75 = a5[1];
    do
    {
      v16 = a5[4];
      if (a5[1] <= v9)
        v17 = 0;
      else
        v17 = (const char *)(a5[7] + *(_QWORD *)(v16 + 1208 * v9));
      v18 = *(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 16);
      if ((v18 | 2) != 3)
        goto LABEL_22;
      v19 = *(_DWORD *)(v16 + 1208 * v9 + 1172);
      if ((v19 & 1) != 0)
      {
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 0x20u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "IGNORE excluded entry present in output: %s\n");
          goto LABEL_21;
        }
      }
      else if (v18 == 1 && *(_QWORD *)(v16 + 1208 * v9 + (v10 << 7) + 32) != v9)
      {
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 8u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "LINK: %s\n");
          goto LABEL_21;
        }
      }
      else if (v76 == 1)
      {
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE full replacement: %s\n");
          goto LABEL_21;
        }
      }
      else
      {
        if (!*(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 140) && !*(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 136))
        {
          if ((v19 & 2) != 0)
          {
            *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
            if (a6 < 2)
              goto LABEL_22;
            fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE include: %s\n");
          }
          else
          {
            v20 = (int *)(v16 + v11);
            v21 = v10;
            do
            {
              v22 = *v20;
              v20 += 32;
              if (v22 != v18)
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2)
                  goto LABEL_22;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE differing types: %s\n");
                goto LABEL_21;
              }
              --v21;
            }
            while (v21);
            if (v18 == 3)
            {
              if (v10)
              {
                v62 = a6;
                v65 = a5[7];
                v63 = v17;
                v64 = (const char *)(v65 + *(_QWORD *)(v16 + 1208 * v9 + (v10 << 7) + 56));
                v23 = (_QWORD *)(v16 + v13);
                v24 = v10;
                while (1)
                {
                  v68 = v23 + 16;
                  v25 = strcmp(v64, (const char *)(v65 + *v23));
                  v26 = v25 == 0;
                  if (v25)
                    goto LABEL_46;
                  --v24;
                  v23 = v68;
                  if (!v24)
                    goto LABEL_43;
                }
              }
LABEL_44:
              v30 = 0;
              v31 = 0;
              v32 = 0;
              v26 = 1;
            }
            else
            {
              if (v18 == 1)
              {
                if (!v10)
                  goto LABEL_44;
                v63 = v17;
                v62 = a6;
                v66 = v16 + 1208 * v9 + (v10 << 7) + 88;
                v27 = v16 + v12;
                v28 = v10;
                while (1)
                {
                  v69 = v27;
                  v29 = sha1cmp(v66, v27);
                  v26 = v29 == 0;
                  if (v29)
                    break;
                  v27 = v69 + 128;
                  if (!--v28)
                  {
LABEL_43:
                    v30 = 0;
                    goto LABEL_47;
                  }
                }
LABEL_46:
                v30 = 1;
LABEL_47:
                a6 = v62;
                v10 = v76 - 1;
                v8 = v75;
                v17 = v63;
              }
              else
              {
                v30 = 0;
                v26 = 1;
              }
              if (v10)
              {
                v32 = 0;
                v33 = v16 + 1208 * v9 + (v10 << 7);
                v34 = *(int32x4_t *)(v33 + 72);
                v35 = *(_QWORD *)(v33 + 128);
                v36 = (_DWORD *)(v16 + v14);
                v37 = v10;
                while (1)
                {
                  if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_s32(v34, *(int32x4_t *)(v36 - 17))), 0xFuLL))) & (v35 == *(_QWORD *)(v36 - 3))) == 0)
                    v32 = 1;
                  if (*v36 || *(v36 - 1))
                    break;
                  v36 += 32;
                  if (!--v37)
                  {
                    v31 = 0;
                    goto LABEL_58;
                  }
                }
                v31 = 1;
              }
              else
              {
                v31 = 0;
                v32 = 0;
              }
            }
LABEL_58:
            if (v18 == 1 && a4 != 0 || v32 == 0)
              v40 = v31;
            else
              v40 = 1;
            if (!(v40 | v30))
            {
              *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 0x10u;
              if (a6 >= 2)
              {
                v44 = (FILE *)*MEMORY[0x24BDAC8D8];
                if (v32)
                  fprintf(v44, "KEEP WITH FIXUP: %s\n", v26);
                else
                  fprintf(v44, "KEEP: %s\n", v26);
                v10 = v76 - 1;
                v8 = v75;
              }
              goto LABEL_22;
            }
            if (v18 == 3)
            {
              v41 = (int *)(v16 + 1208 * v9 + 1168);
              v42 = *v41;
              *v41 |= 1u;
              if (a6 < 2)
              {
                if (v26)
                  *v41 = v42 | 0x101;
                goto LABEL_22;
              }
              v43 = v26;
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE differing symlink: %s\n", v17);
              v10 = v76 - 1;
              v8 = v75;
              if (!v43)
                goto LABEL_22;
              *v41 |= 0x100u;
              fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE_NOREMOVE symlink attribute changes only: %s\n");
            }
            else
            {
              v45 = *a5;
              if (*a5)
              {
                v46 = 0;
                v47 = (unint64_t *)(v16 + v15);
                do
                {
                  v49 = *v47;
                  v47 += 16;
                  v48 = v49;
                  if (v46 <= v49)
                    v46 = v48;
                  --v45;
                }
                while (v45);
              }
              else
              {
                v46 = 0;
              }
              v50 = v16 + 1208 * v9 + (v10 << 7);
              v52 = *(_QWORD *)(v50 + 24);
              v51 = (_QWORD *)(v50 + 24);
              if (v52 < a1 || v46 >= a2)
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2)
                  goto LABEL_22;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE different files, not in patch range: %s\n");
              }
              else if (v46 >= a3
                     && (v70 = v40,
                         IsCompressed = statIsCompressed(*(_DWORD *)(v16 + 1208 * v9 + (v10 << 7) + 84)),
                         v40 = v70,
                         v10 = v76 - 1,
                         v8 = v75,
                         IsCompressed))
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2)
                  goto LABEL_22;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE different files, not in patch range for AFSC-compressed files: %s\n");
              }
              else if (v40)
              {
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                if (a6 < 2)
                  goto LABEL_22;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE different files, attributes differ: %s\n");
              }
              else
              {
                if (v67 <= *v51 >> 3)
                  v55 = *v51 >> 3;
                else
                  v55 = v67;
                v56 = v16;
                v57 = v10;
                if (v10)
                {
                  while (*(_QWORD *)(v56 + v15) >= v55)
                  {
                    v56 += 128;
                    if (!--v57)
                      goto LABEL_106;
                  }
                  *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
                  if (a6 >= 2)
                  {
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE one input is too small: %s\n");
                    goto LABEL_21;
                  }
                  goto LABEL_22;
                }
LABEL_106:
                *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 4u;
                if (a6 < 2)
                  goto LABEL_22;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "PATCH different files: %s\n");
              }
            }
          }
LABEL_21:
          v10 = v76 - 1;
          v8 = v75;
          goto LABEL_22;
        }
        *(_DWORD *)(v16 + 1208 * v9 + 1168) |= 1u;
        if (a6 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE entry with XAT/ACL: %s\n");
          goto LABEL_21;
        }
      }
LABEL_22:
      ++v9;
      v11 += 1208;
      v12 += 1208;
      v13 += 1208;
      v14 += 1208;
      v15 += 1208;
    }
    while (v9 != v8);
  }
  if (v76 == 1 || (fixOpsForHardLinkClusters(a5, a6) & 0x80000000) == 0)
    return 0;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"initOps", 2611, 18, 0, "fixOpsForInPlace", v58, v59, v61);
  return 0xFFFFFFFFLL;
}

uint64_t updateOps(_QWORD *a1, int a2, int a3)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v12;
  int v13;
  int v14;
  BOOL v15;
  const char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  const char *v26;
  unint64_t v27;
  size_t v28;
  size_t v29;
  int v30;
  int v31;
  unint64_t v32;
  uint64_t v33;
  int *v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  BOOL v47;
  int v48;
  int v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _DWORD *v56;
  int v57;
  _DWORD *v58;
  _QWORD *v59;
  _DWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  _DWORD *v66;
  int v67;
  int v68;
  int v69;
  int *v70;
  int v71;
  BOOL v72;
  uint64_t v74;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const char *__s2;
  _QWORD *v80;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;

  v90 = a1[1];
  if (v90)
  {
    v3 = a1;
    v4 = 0;
    v5 = 0;
    v77 = *a1 - 1;
    v6 = *a1 << 7;
    while (1)
    {
      v7 = v3[4];
      if (v3[1] <= v5)
        v8 = 0;
      else
        v8 = v3[7] + *(_QWORD *)(v7 + v4);
      v9 = *(_DWORD *)(v7 + v6 - 112 + v4);
      if (v9 == 2)
        goto LABEL_25;
      v10 = *(_DWORD *)(v7 + v4 + 1172);
      if (v9 || (*(_DWORD *)(v7 + v4 + 1172) & 1) == 0)
        break;
      *(_DWORD *)(v7 + v4 + 1168) |= 0x20u;
      v17 = "IGNORE excluded entry not present in output: %s\n";
      if (a3 > 1)
        goto LABEL_24;
LABEL_25:
      ++v5;
      v4 += 1208;
      if (v90 == v5)
      {
        v18 = 0;
        v19 = 0;
        v74 = v6 - 1320;
        v20 = -1;
        v89 = 16;
        v21 = 140;
        v87 = 1168;
        v86 = 1208;
        v80 = v3;
        v22 = v77;
        while (1)
        {
          v85 = v21;
          v23 = v3[4];
          v24 = (_QWORD *)(v23 + 1208 * v19);
          v83 = v24[16 * v22 + 2];
          v25 = v3[7];
          v26 = (const char *)(v25 + *v24);
          v27 = v19;
          v28 = strlen(v26);
          v88 = v27;
          v84 = v20;
          if (v28)
          {
            v29 = v28;
            v82 = v23;
            __s2 = v26;
            if (v22)
            {
              v30 = 0;
              v31 = 0;
              v32 = v88;
              v33 = v23;
              v34 = (int *)(v23 + v89);
              v35 = 1;
              v36 = v22;
              v37 = v83;
              do
              {
                v39 = *v34;
                v34 += 32;
                v38 = v39;
                v40 = v39 == 2;
                if (v39 == 2)
                  v41 = 1;
                else
                  v41 = v31;
                if (v40)
                  v42 = v35;
                else
                  v42 = 0;
                if (v38)
                {
                  v31 = v41;
                  v35 = v42;
                  v30 = 1;
                }
                --v36;
              }
              while (v36);
            }
            else
            {
              v31 = 0;
              v30 = 0;
              v35 = 1;
              v32 = v88;
              v33 = v23;
              v37 = v83;
            }
            if (v37 != 2 && !v31)
              goto LABEL_94;
            v78 = v18;
            v43 = v32 + 1;
            if (v32 + 1 >= v90)
            {
              v44 = 0;
              v46 = v32 + 1;
            }
            else
            {
              v44 = 0;
              v45 = v33 + v86;
              v76 = v32 + 1;
              v46 = v32 + 1;
              while (strlen((const char *)(v25 + *(_QWORD *)v45)) > v29 && *(_BYTE *)(v25 + *(_QWORD *)v45 + v29) == 47)
              {
                if ((*(_BYTE *)(v45 + 1168) & 1) != 0)
                  v44 = 1;
                ++v46;
                v45 += 1208;
                if (v90 == v46)
                {
                  v46 = v90;
                  break;
                }
              }
              v43 = v76;
              v22 = v77;
              v32 = v88;
              v33 = v82;
              v37 = v83;
            }
            if (v31)
              v47 = v37 == 2;
            else
              v47 = 1;
            if (v47 && v35)
            {
              v48 = *(_DWORD *)(v33 + 1208 * v32 + 1172);
              if ((v48 & 1) != 0)
              {
                *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x20u;
                v18 = v78;
                if (a3 >= 2)
                {
                  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "IGNORE excluded directory: %s\n");
                  goto LABEL_93;
                }
              }
              else
              {
                v49 = *(_DWORD *)(v33 + 1208 * v32 + (v22 << 7) + 84);
                if ((v49 & 0x800000) != 0)
                {
                  if (v46 != v43)
                  {
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "WARNING: firmlink directory is not empty: %s\n", __s2);
                    v33 = v82;
                    v32 = v88;
                  }
                  *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x200u;
                  v18 = v78;
                  if (a3 < 2)
                    goto LABEL_94;
                  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "FIRMLINK directory: %s\n");
                  goto LABEL_93;
                }
                if ((v48 & 2) != 0)
                {
                  *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                  v18 = v78;
                  if (a3 >= 2)
                  {
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE included directory: %s\n");
                    goto LABEL_93;
                  }
                }
                else
                {
                  v18 = v78;
                  if (!*(_DWORD *)(v33 + 1208 * v32 + (v22 << 7) + 140)
                    && !*(_DWORD *)(v33 + 1208 * v32 + (v22 << 7) + 136))
                  {
                    if (v30)
                    {
                      if (v22)
                      {
                        v55 = v33 + 1208 * v32 + (v22 << 7);
                        v56 = (_DWORD *)(v55 + 76);
                        v57 = *(_DWORD *)(v55 + 72);
                        v58 = (_DWORD *)(v55 + 80);
                        v59 = (_QWORD *)(v55 + 128);
                        v60 = (_DWORD *)(v33 + v85);
                        v61 = v22;
                        while (*(v60 - 17) == v57
                             && *(v60 - 16) == *v56
                             && *(v60 - 15) == *v58
                             && *(v60 - 14) == v49
                             && *(_QWORD *)(v60 - 3) == *v59
                             && !*v60
                             && !*(v60 - 1))
                        {
                          v60 += 32;
                          if (!--v61)
                            goto LABEL_107;
                        }
                      }
                      else
                      {
LABEL_107:
                        if (!a2)
                        {
                          *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x10u;
                          if (a3 < 2)
                            goto LABEL_94;
                          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "KEEP dir: %s\n");
                          goto LABEL_93;
                        }
                      }
                      *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                      if (a3 < 2)
                        goto LABEL_94;
                      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE directory with different attributes: %s\n");
                      goto LABEL_93;
                    }
                    while (__s2[v29] != 47)
                    {
                      if (!--v29)
                        goto LABEL_120;
                    }
                    if (!v32)
                    {
LABEL_120:
                      v64 = -1;
                      goto LABEL_125;
                    }
                    v62 = v33 + v78;
                    v63 = v84;
                    while (*(_DWORD *)(v62 + v74) != 2
                         || strlen((const char *)(v25 + *(_QWORD *)(v62 - 1208))) != v29
                         || memcmp((const void *)(v25 + *(_QWORD *)(v62 - 1208)), __s2, v29))
                    {
                      --v63;
                      v62 -= 1208;
                      if (v63 == -1)
                      {
                        v64 = -1;
                        goto LABEL_124;
                      }
                    }
                    v64 = *(_DWORD *)(v62 + v74 + 60);
LABEL_124:
                    v18 = v78;
                    v32 = v88;
                    v33 = v82;
LABEL_125:
                    v65 = v33 + 1208 * v32;
                    v66 = (_DWORD *)(v65 + (v22 << 7));
                    v67 = v66[18];
                    v68 = v66[19];
                    v69 = v66[20];
                    v70 = (int *)(v65 + 1168);
                    v71 = *(_DWORD *)(v65 + 1168);
                    if (!a2 && v44 && !v49 && (!v67 ? (v72 = v68 == v64) : (v72 = 0), v72 && v69 == 493))
                    {
                      *v70 = v71 | 0x40;
                      if (a3 < 2)
                        goto LABEL_94;
                      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "AUTO MKDIR new directory uid=%u gid=%u mode=0%04o parent_gid=%u: %s\n");
                    }
                    else
                    {
                      *v70 = v71 | 1;
                      if (a3 < 2)
                        goto LABEL_94;
                      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE new directory uid=%u gid=%u mode=0%04o flags=0x%08x parent_gid=%u: %s\n");
                    }
LABEL_93:
                    v32 = v88;
                    goto LABEL_94;
                  }
                  *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                  if (a3 >= 2)
                  {
                    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE directory with XAT/ACL: %s\n");
                    goto LABEL_93;
                  }
                }
              }
            }
            else
            {
              v50 = v87;
              v51 = v32;
              if (v32 < v46)
              {
                do
                {
                  v52 = v80[4];
                  v53 = *(_DWORD *)(v52 + v50);
                  if ((v53 & 2) == 0)
                  {
                    v54 = v80[1] <= v51 ? 0 : (const char *)(v80[7] + *(_QWORD *)(v52 + v50 - 1168));
                    if ((*(_BYTE *)(v52 + v50 + 4) & 3) == 0)
                    {
                      *(_DWORD *)(v52 + v50) = v53 | 2;
                      if (a3 >= 2)
                      {
                        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "REMOVE contents of removed directory: %s\n", v54);
                        v33 = v82;
                        v32 = v88;
                      }
                    }
                  }
                  ++v51;
                  v50 += 1208;
                }
                while (v46 != v51);
              }
              v22 = v77;
              v18 = v78;
              if (v37 != 2)
                goto LABEL_94;
              if ((*(_DWORD *)(v33 + 1208 * v32 + 1172) & 1) == 0)
              {
                if (v44 && !(*(_DWORD *)(v33 + 1208 * v32 + 1172) & 2 | a2))
                  goto LABEL_94;
                *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 1u;
                if (a3 < 2)
                  goto LABEL_94;
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE differing types directory: %s\n");
                goto LABEL_93;
              }
              *(_DWORD *)(v33 + 1208 * v32 + 1168) |= 0x20u;
              if (a3 >= 2)
              {
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "IGNORE excluded directory with type change: %s\n");
                goto LABEL_93;
              }
            }
          }
          else
          {
            *(_DWORD *)(v23 + 1208 * v27 + 1168) |= 1u;
            v32 = v27;
            if (a3 >= 2)
            {
              fwrite("ARCHIVE root directory: .\n", 0x1AuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
              goto LABEL_93;
            }
          }
LABEL_94:
          v19 = v32 + 1;
          v89 += 1208;
          v86 += 1208;
          v21 = v85 + 1208;
          v20 = v84 + 1;
          v18 += 1208;
          v87 += 1208;
          v3 = v80;
          if (v19 == v90)
            return 0;
        }
      }
    }
    if ((v10 & 3) != 0)
      goto LABEL_25;
    v12 = v7 + v4;
    v13 = *(_DWORD *)(v12 + 1168);
    if ((v13 & 0x100) != 0)
      goto LABEL_25;
    v14 = v10 & 4;
    v15 = (v13 & 0x209) != 0 || v9 == 0;
    if (!v15 && v14 == 0)
      goto LABEL_25;
    *(_DWORD *)(v12 + 1168) = v13 | 2;
    v17 = "REMOVE archive, links, firmlinks, remove rule: %s\n";
    if (a3 < 2)
      goto LABEL_25;
LABEL_24:
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], v17, v8);
    goto LABEL_25;
  }
  return 0;
}

uint64_t checkOps(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v10;
  int v11;
  uint64_t v12;
  FILE **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;

  v8 = a1[1];
  if (v8)
  {
    v10 = 0;
    v11 = 1;
    v12 = 1168;
    v13 = (FILE **)MEMORY[0x24BDAC8D8];
    while (1)
    {
      v14 = a1[4];
      if (a1[1] <= v10)
        LOBYTE(v15) = 0;
      else
        v15 = a1[7] + *(_QWORD *)(v14 + v12 - 1168);
      v16 = v14 + v12;
      v17 = *(_DWORD *)(v14 + v12);
      if (v17)
      {
        if ((~v17 & 5) != 0)
        {
          if ((~v17 & 6) != 0)
          {
            if ((~v17 & 0x12) != 0)
            {
              v18 = *(_DWORD *)(v16 + 4);
              if ((v17 & 2) != 0 && (v18 & 2) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2904, 18, 0, "entry is labelled REMOVE and matches INCLUDE rule: %s", a7, a8, v15);
              }
              else if ((v17 & 2) != 0 && (v18 & 1) != 0)
              {
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2911, 18, 0, "entry is labelled REMOVE and matches EXCLUDE rule: %s", a7, a8, v15);
              }
              else
              {
                if ((v17 & 2) != 0 || (v18 & 4) == 0)
                  goto LABEL_24;
                pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2918, 18, 0, "entry is not labelled REMOVE and matches REMOVE rule: %s", a7, a8, v15);
              }
            }
            else
            {
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2897, 18, 0, "entry is labelled KEEP + REMOVE: %s", a7, a8, v15);
            }
          }
          else
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2890, 18, 0, "entry is labelled PATCH + REMOVE: %s", a7, a8, v15);
          }
        }
        else
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2883, 18, 0, "entry is labelled PATCH + ARCHIVE: %s", a7, a8, v15);
        }
      }
      else
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"checkOps", 2876, 18, 0, "entry is not labelled: %s", a7, a8, v15);
      }
      dumpContentsEntries(*v13, a1, v10);
      v11 = 0;
LABEL_24:
      ++v10;
      v12 += 1208;
      if (v8 == v10)
        goto LABEL_27;
    }
  }
  v11 = 1;
LABEL_27:
  if (v11)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

FILE *dumpContentsEntries(FILE *result, _QWORD *a2, unint64_t a3)
{
  _QWORD *v3;
  FILE *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  unint64_t v34;
  uint64_t v35;

  v3 = a2;
  v4 = result;
  v5 = *a2;
  if (a3 == -1)
    v6 = 0;
  else
    v6 = a3;
  if (a3 == -1)
  {
    v34 = a2[1];
    if (!v34)
      return result;
  }
  else
  {
    v34 = a3 + 1;
  }
  v7 = 1208 * v6 + 72;
  do
  {
    v8 = v3[4];
    fprintf(v4, "index=%zu", v6);
    v35 = v8;
    v9 = v8 + 1208 * v6;
    v10 = *(_DWORD *)(v9 + 1168);
    fwrite(" ops=", 5uLL, 1uLL, v4);
    if ((v10 & 1) != 0)
      v11 = 65;
    else
      v11 = 45;
    fputc(v11, v4);
    if ((v10 & 2) != 0)
      v12 = 82;
    else
      v12 = 45;
    fputc(v12, v4);
    if ((v10 & 8) != 0)
      v13 = 76;
    else
      v13 = 45;
    fputc(v13, v4);
    if ((v10 & 4) != 0)
      v14 = 80;
    else
      v14 = 45;
    fputc(v14, v4);
    if ((v10 & 0x10) != 0)
      v15 = 75;
    else
      v15 = 45;
    fputc(v15, v4);
    if ((v10 & 0x40) != 0)
      v16 = 77;
    else
      v16 = 45;
    fputc(v16, v4);
    if ((v10 & 0x20) != 0)
      v17 = 73;
    else
      v17 = 45;
    fputc(v17, v4);
    v18 = *(_DWORD *)(v9 + 1172);
    fwrite(" rules=", 7uLL, 1uLL, v4);
    if ((v18 & 1) != 0)
      v19 = 69;
    else
      v19 = 45;
    fputc(v19, v4);
    if ((v18 & 2) != 0)
      v20 = 73;
    else
      v20 = 45;
    fputc(v20, v4);
    if ((v18 & 4) != 0)
      v21 = 82;
    else
      v21 = 45;
    fputc(v21, v4);
    if ((v18 & 0x10) != 0)
      v22 = 101;
    else
      v22 = 45;
    fputc(v22, v4);
    if ((v18 & 0x20) != 0)
      v23 = 105;
    else
      v23 = 45;
    fputc(v23, v4);
    if ((v18 & 0x40) != 0)
      v24 = 114;
    else
      v24 = 45;
    fputc(v24, v4);
    fwrite(" labels=", 8uLL, 1uLL, v4);
    if ((v18 & 0x100) != 0)
      v25 = 77;
    else
      v25 = 45;
    fputc(v25, v4);
    if ((v18 & 0x400) != 0)
      v26 = 68;
    else
      v26 = 45;
    fputc(v26, v4);
    if ((v18 & 0x200) != 0)
      v27 = 80;
    else
      v27 = 45;
    fputc(v27, v4);
    if (v5)
    {
      v28 = 0;
      v29 = v35 + v7;
      do
      {
        fprintf(v4, " V%zu[", v28);
        v30 = *(int *)(v29 - 56);
        if (v30 > 3)
          v31 = 63;
        else
          v31 = dword_20643F650[v30];
        fprintf(v4, "type=%c", v31);
        fprintf(v4, " uid=%u gid=%u mode=0%04o flags=0x%02x duz=%llu size=%llu link=%zu", *(_DWORD *)v29, *(_DWORD *)(v29 + 4), *(_DWORD *)(v29 + 8), *(_DWORD *)(v29 + 12), *(_QWORD *)(v29 + 40), *(_QWORD *)(v29 - 48), *(_QWORD *)(v29 - 40));
        fputc(93, v4);
        ++v28;
        v29 += 128;
      }
      while (v5 != v28);
    }
    v3 = a2;
    if (a2[1] <= v6)
      v32 = 0;
    else
      v32 = (const char *)(a2[7] + *(_QWORD *)(a2[4] + 1208 * v6));
    result = (FILE *)fprintf(v4, " path=%s\n", v32);
    ++v6;
    v7 += 1208;
  }
  while (v6 != v34);
  return result;
}

uint64_t processPatchThreadProc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  const char *v10;
  int v11;
  unsigned int *v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  BOOL v29;
  unint64_t BXDiffMaxMemoryUsage;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  _OWORD *v35;
  char **v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  int v42;
  size_t v43;
  unint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  int v48;
  int v49;
  __int16 v50;
  int v51;
  const char *v52;
  int v53;
  void **v54;
  void *v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int *v59;
  const char *v60;
  __int16 v61;
  char v63;
  _BYTE *v64;
  int v65;
  unint64_t v66;
  int v67;
  uint64_t v68;
  int v69;
  unint64_t v70;
  _OWORD v71[11];
  int v72;
  char __s[1024];
  _OWORD v74[4];
  uint64_t v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v10 = *(const char **)(a1 + 8);
  if (!v10)
  {
    v64 = 0;
    goto LABEL_5;
  }
  v64 = patchCacheOpenFromURL(v10, 0, a3, a4, a5, a6, a7, a8);
  if (v64)
  {
LABEL_5:
    v11 = 1;
    goto LABEL_6;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"processPatchThreadProc", 3093, 18, 0, "patchCacheOpenFromURL: %s (continue without cache)", a7, a8, *(_QWORD *)(a1 + 8));
  v64 = 0;
  v11 = 0;
LABEL_6:
  v12 = *(unsigned int **)a1;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 + 1, v12));
  if ((v13 & 0x80000000) == 0)
  {
    v66 = v9;
    do
    {
      if (v9 <= v13)
        break;
      v14 = v13;
      v15 = *(_QWORD *)(a1 + 48);
      v16 = *(_QWORD *)(v15 + 32);
      if ((*(_BYTE *)(v16 + 1208 * v13 + 1168) & 4) == 0)
        goto LABEL_64;
      if (*(_QWORD *)(a1 + 56))
      {
        v17 = *(_QWORD *)v15;
        v18 = *(_QWORD *)v15 >= 2uLL;
        v19 = *(_QWORD *)v15 - 2;
        if (v18)
        {
          v21 = 0;
          v22 = v17 - 1;
          v23 = *(_QWORD *)(v16 + 1208 * v14 + (v22 << 7) + 24);
          v24 = (unint64_t *)(v16 + 1208 * v14 + 24);
          v25 = v23;
          do
          {
            v27 = *v24;
            v24 += 16;
            v26 = v27;
            v25 += v27;
            if (v21 <= v27)
              v21 = v26;
            --v22;
          }
          while (v22);
          v28 = *(_DWORD *)(a1 + 44);
          if (v21 >> 28)
            v29 = v23 >> 28 == 0;
          else
            v29 = 1;
          if (v29)
            BXDiffMaxMemoryUsage = GetBXDiffMaxMemoryUsage(v21, v23, v28, *(_DWORD *)(a1 + 36));
          else
            BXDiffMaxMemoryUsage = GetLargeFileMaxMemoryUsage(v21, v23, v28);
          v20 = ((unint64_t)((2
                                   * ((3 * v19 * v23) & 0x1FFFFFFFFFFFFFFFLL)
                                   * (unsigned __int128)0x28F5C28F5C28F5C3uLL) >> 64) >> 2)
              + 50 * v19 * v23 / 0x64
              + v25
              + BXDiffMaxMemoryUsage;
        }
        else
        {
          pc_log_warning((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"getPatchMaxMemory", 3039, 18, "too little variants", a6, a7, a8, v63);
          v20 = 0;
        }
        if ((MemGateReserve(*(_QWORD *)(a1 + 56), v20) & 0x80000000) != 0)
        {
          v60 = "MemGateReserve";
          v61 = 3111;
LABEL_70:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"processPatchThreadProc", v61, 18, 0, v60, a7, a8, v63);
LABEL_71:
          v11 = 0;
          break;
        }
        v68 = v20;
        v15 = *(_QWORD *)(a1 + 48);
        v16 = *(_QWORD *)(v15 + 32);
      }
      else
      {
        v68 = 0;
      }
      v69 = v11;
      v70 = v14;
      if (*(_QWORD *)(v15 + 8) <= v14)
        v31 = 0;
      else
        v31 = (const char *)(*(_QWORD *)(v15 + 56) + *(_QWORD *)(v16 + 1208 * v14));
      v67 = *(_DWORD *)(a1 + 16);
      v32 = *(_QWORD *)v15;
      v65 = *(_DWORD *)(a1 + 40);
      v75 = 0;
      memset(v74, 0, sizeof(v74));
      bzero(__s, 0x400uLL);
      v72 = 0;
      memset(v71, 0, sizeof(v71));
      if (v32)
      {
        v33 = v16 + 1208 * v14 + 88;
        v34 = (char *)(v15 + 64);
        v35 = v71;
        v36 = (char **)v74;
        v37 = v32;
        while (1)
        {
          v38 = (char *)malloc(0x400uLL);
          if (!v38)
          {
            v51 = *__error();
            v50 = 2962;
            v52 = "malloc";
            goto LABEL_49;
          }
          *v36 = v38;
          if ((concatPath(v38, 0x400uLL, v34, v31) & 0x80000000) != 0)
            break;
          v41 = *(_OWORD *)v33;
          v42 = *(_DWORD *)(v33 + 16);
          v33 += 128;
          *((_DWORD *)v35 + 4) = v42;
          *v35 = v41;
          v35 = (_OWORD *)((char *)v35 + 20);
          v34 += 1024;
          ++v36;
          if (!--v37)
            goto LABEL_37;
        }
        v63 = (char)v31;
        v50 = 2964;
      }
      else
      {
LABEL_37:
        if ((concatPath(__s, 0x400uLL, (char *)(v15 + 611392), v31) & 0x80000000) == 0)
        {
          v43 = strlen(__s);
          makePath(__s, v43);
          v44 = v70;
          v45 = v16 + 1208 * v70;
          v46 = (_QWORD *)(v45 + 1184);
          v47 = (_QWORD *)(v45 + 1192);
          v48 = BXDiffWithCache(v32, (const char **)v74, (uint64_t)v71, __s, v64, v67, a1 + 36, (_QWORD *)(v45 + 1184), (_QWORD *)(v45 + 1192), (unint64_t *)(v15 + 625056));
          if (v48 < 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"createPatch", 2983, 18, 0, "computing patch: %s", a7, a8, (char)__s);
            v49 = 1;
          }
          else
          {
            if (!v48 || *v46 >= *v47)
            {
              if (v65 >= 2)
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ARCHIVE patch is larger: %s\n", v31);
              *(_DWORD *)(v16 + 1208 * v70 + 1168) = *(_DWORD *)(v16 + 1208 * v70 + 1168) & 0xFFFFFFFA | 1;
              unlink(__s);
            }
            v49 = 0;
          }
          v9 = v66;
          v53 = v69;
          if (!v32)
            goto LABEL_55;
          goto LABEL_53;
        }
        v63 = (char)v31;
        v50 = 2968;
      }
      v51 = 0;
      v52 = "concatPath failed: %s";
LABEL_49:
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"createPatch", v50, 18, v51, v52, v39, v40, v63);
      v49 = 1;
      v9 = v66;
      v53 = v69;
      v44 = v70;
      if (!v32)
        goto LABEL_55;
LABEL_53:
      v54 = (void **)v74;
      do
      {
        v55 = *v54++;
        free(v55);
        --v32;
      }
      while (v32);
LABEL_55:
      if (v49)
      {
        v56 = *(_QWORD **)(a1 + 48);
        if (v56[1] <= v44)
          LOBYTE(v57) = 0;
        else
          v57 = v56[7] + *(_QWORD *)(v56[4] + 1208 * v44);
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"processPatchThreadProc", 3116, 18, 0, "Patching failed %s", a7, a8, v57);
        v53 = 0;
      }
      v58 = *(_QWORD *)(a1 + 56);
      if (v58 && (MemGateFree(v58, v68) & 0x80000000) != 0)
      {
        v60 = "MemGateFree";
        v61 = 3119;
        goto LABEL_70;
      }
      if (!v53)
        goto LABEL_71;
      v11 = 1;
LABEL_64:
      v59 = *(unsigned int **)a1;
      do
        v13 = __ldaxr(v59);
      while (__stlxr(v13 + 1, v59));
    }
    while ((v13 & 0x80000000) == 0);
  }
  patchCacheClose((uint64_t)v64, a2, a3, a4, a5, a6, a7, a8);
  if (v11)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t computePatches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  int v9;
  int v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  void *v19;
  char *v20;
  int v21;
  char *v22;
  uint64_t v23;
  char *v24;
  unsigned int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  pthread_mutex_t *v33;
  uint64_t Worker;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  const char *v41;
  __int16 v42;
  unsigned int *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v58;
  int v59;
  char __str[16];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  pthread_mutex_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;

  v8 = a6;
  v9 = a5;
  v12 = a2;
  v76 = *MEMORY[0x24BDAC8D0];
  v59 = 0;
  v14 = *(_DWORD *)(a4 + 4);
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  memset(&v65, 0, sizeof(v65));
  if (a6)
  {
    if (a6 <= 0x64)
      v8 = getInstalledMemorySize() / 0x64uLL * a6;
    if (v8 <= 0x40000000)
      v8 = 0x40000000;
    if ((MemGateInit(&v65, v8, v9, a4, a5, a6, a7, a8) & 0x80000000) != 0)
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", 3152, 18, 0, "MemGateInit", a7, a8, v58);
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v8 = 1;
      goto LABEL_38;
    }
  }
  if (v14 >= 1)
  {
    v15 = *(_QWORD *)(a3 + 8);
    if (v15)
    {
      v16 = 0;
      v17 = (unsigned int *)(*(_QWORD *)(a3 + 32) + 1168);
      do
      {
        v16 += ((unint64_t)*v17 >> 2) & 1;
        v17 += 302;
        --v15;
      }
      while (v15);
    }
    else
    {
      LOBYTE(v16) = 0;
    }
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    *(_OWORD *)__str = 0u;
    if (v8)
      snprintf(__str, 0x50uLL, "(memoryLimit %llu MB)", v8 >> 20);
    pc_info("Generating patches for %zu entries on %d threads %s\n", a2, a3, a4, a5, a6, a7, a8, v16);
  }
  v20 = (char *)calloc(v9, 0x40uLL);
  v22 = (char *)malloc(8 * v9);
  v19 = v22;
  if (!v20 || !v22)
  {
    v40 = *__error();
    v41 = "malloc";
    v42 = 3171;
LABEL_34:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", v42, 18, v40, v41, v31, v32, v58);
    v18 = 0;
    v21 = 0;
    goto LABEL_38;
  }
  if (v9 < 1)
  {
    v43 = ThreadPoolCreate(v9, (uint64_t)v22, (uint64_t)processPatchThreadProc);
    if (v43)
    {
      v18 = (uint64_t)v43;
      v21 = 1;
      goto LABEL_38;
    }
    goto LABEL_33;
  }
  v23 = 0;
  v24 = v20;
  do
  {
    *(_QWORD *)&v22[v23] = v24;
    v23 += 8;
    v24 += 64;
  }
  while (8 * v9 != v23);
  v25 = ThreadPoolCreate(v9, (uint64_t)v22, (uint64_t)processPatchThreadProc);
  if (!v25)
  {
LABEL_33:
    v41 = "ThreadPoolCreate";
    v42 = 3174;
    v40 = 0;
    goto LABEL_34;
  }
  v18 = (uint64_t)v25;
  if (v8)
    v33 = &v65;
  else
    v33 = 0;
  while (1)
  {
    Worker = ThreadPoolGetWorker(v18, v26, v27, v28, v29, v30, v31, v32);
    if (!Worker)
    {
      v44 = "ThreadPoolGetWorker";
      v45 = 3180;
      goto LABEL_37;
    }
    *(_QWORD *)(Worker + 48) = a3;
    *(_QWORD *)Worker = &v59;
    *(_QWORD *)(Worker + 8) = a1;
    *(_DWORD *)(Worker + 16) = v12;
    v39 = *(_QWORD *)a4;
    *(_DWORD *)(Worker + 44) = *(_DWORD *)(a4 + 8);
    *(_QWORD *)(Worker + 36) = v39;
    *(_QWORD *)(Worker + 56) = v33;
    if ((ThreadPoolRunWorker(v18, Worker, v35, v36, v37, v38, v31, v32) & 0x80000000) != 0)
      break;
    if (!--v9)
    {
      v21 = 1;
      goto LABEL_38;
    }
  }
  v44 = "ThreadPoolRunWorker";
  v45 = 3187;
LABEL_37:
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", v45, 18, 0, v44, v31, v32, v58);
  v21 = 0;
LABEL_38:
  if ((ThreadPoolDestroy(v18) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", 3192, 18, 0, "ThreadPoolDestroy", v46, v47, v58);
    v21 = 0;
  }
  free(v20);
  free(v19);
  if (v8 && (MemGateDestroy(&v65, v48, v49, v50, v51, v52, v53, v54) & 0x80000000) != 0)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"computePatches", 3195, 18, 0, "MemGateDestroy", v55, v56, v58);
    v21 = 0;
  }
  if (v21)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t DirectoryDiff(uint64_t DefaultNThreads, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  FILE **v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char **v27;
  const char **v28;
  uint64_t v29;
  const char **v30;
  FILE **v31;
  int v32;
  const char *v33;
  BOOL v34;
  const char **v35;
  uint64_t v36;
  const char *v37;
  int v38;
  uint64_t v39;
  FILE **v40;
  char *v41;
  char *v42;
  const char *v43;
  const char *v44;
  unint64_t v45;
  unint64_t v46;
  FILE *v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void **v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  size_t v84;
  uint64_t v85;
  _OWORD *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  int v114;
  __int16 v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  int *v125;
  int *v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  FILE **v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unsigned int *v144;
  double RealTime;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t *v153;
  unint64_t *v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  uint64_t v159;
  double v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  FILE **v168;
  FILE *v169;
  unint64_t v170;
  FILE *v171;
  unint64_t v172;
  FILE *v173;
  unint64_t v174;
  FILE *v175;
  unint64_t v176;
  FILE *v177;
  unint64_t v178;
  FILE *v179;
  unint64_t v180;
  FILE *v181;
  unint64_t v182;
  FILE *v183;
  unint64_t v184;
  FILE *v185;
  unint64_t v186;
  FILE *v187;
  unint64_t v188;
  FILE *v189;
  FILE *v190;
  unint64_t v191;
  unint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  int8x16_t *v204;
  int v205;
  uint64_t v206;
  uint64_t v207;
  char v208;
  char v209;
  char v210;
  char v211;
  char v212;
  char v213;
  unint64_t *v214;
  unsigned int v215;
  int v216;
  int8x16_t *v217;
  char *v218;
  uint64_t v219;
  uint64_t v220;
  stat v221;
  stat v222;
  _OWORD v223[31];
  uint64_t v224;
  uint64_t v225;

  v8 = DefaultNThreads;
  v225 = *MEMORY[0x24BDAC8D0];
  v10 = *(unsigned int *)(DefaultNThreads + 84);
  v9 = *(_DWORD *)(DefaultNThreads + 88);
  if (!(_DWORD)v10)
  {
    DefaultNThreads = getDefaultNThreads();
    v10 = DefaultNThreads;
  }
  v11 = *(_QWORD *)v8;
  if (*(_QWORD *)v8 >= 9uLL)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5575, 18, 0, "n > %d not supported", a7, a8, 8);
    return 0xFFFFFFFFLL;
  }
  memset(&v222, 0, sizeof(v222));
  v13 = (FILE **)*(unsigned int *)(v8 + 92);
  enterThreadErrorContext(DefaultNThreads, a2, a3, a4, a5, a6, a7, a8, v208);
  v14 = (char *)malloc(0x989F0uLL);
  v15 = (uint64_t)v14;
  v16 = v14 + 611392;
  if (!v14)
  {
    v48 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5590, 18, v48, "malloc", v49, v50, v209);
    goto LABEL_54;
  }
  v217 = (int8x16_t *)(v14 + 611392);
  v224 = 0;
  v215 = (v13 >> 1) & 1;
  v216 = v9;
  v214 = (unint64_t *)(v14 + 625056);
  memset(v223, 0, sizeof(v223));
  bzero(v14, 0x989F0uLL);
  v24 = 0;
  v25 = v15;
  v26 = 0;
  *(_DWORD *)(v25 + 24) = 1;
  v27 = (const char **)(v8 + 24);
  v219 = v11;
  v220 = v8;
  v28 = (const char **)(v8 + 32);
  v29 = v11 + 1;
  v218 = (char *)v25;
  while (1)
  {
    v30 = v27;
    if (v26 < v11)
      v30 = (const char **)(*(_QWORD *)(v220 + 8) + v24);
    v31 = v13;
    v32 = v13 & 1;
    v33 = *v30;
    if (*v30)
      v34 = 1;
    else
      v34 = v32 == 0;
    if (v34)
    {
      if (!realpath_DARWIN_EXTSN(*v30, (char *)(v25 + 64)))
      {
        v52 = *__error();
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5603, 18, v52, "%s", v53, v54, (char)v33);
LABEL_60:
        v51 = -1;
        v15 = (uint64_t)v218;
        LODWORD(v11) = v219;
        goto LABEL_61;
      }
      v11 = v219;
      if (stat((const char *)(v25 + 64), &v222) || (v222.st_mode & 0xF000) != 0x4000)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5604, 18, 0, "Not a directory: %s", v22, v23, (char)v33);
        goto LABEL_57;
      }
    }
    v35 = v28;
    if (v26 >= v11)
      break;
    v36 = *(_QWORD *)(v220 + 16);
    if (v36)
    {
      v35 = (const char **)(v36 + v24);
      break;
    }
LABEL_24:
    ++v26;
    v25 += 1024;
    v24 += 8;
    v13 = v31;
    if (v29 == v26)
    {
      v8 = v220;
      if (!*(_QWORD *)(v220 + 40))
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5616, 18, 0, "Missing patchFilename", v22, v23, v209);
        v51 = -1;
        v16 = (char *)v217;
        v15 = (uint64_t)v218;
        goto LABEL_63;
      }
      v38 = v216;
      v15 = (uint64_t)v218;
      if (v216 >= 1)
      {
        pc_info("DirectoryDiff:\n", v17, v18, v19, v20, v21, v22, v23, v209);
        if ((int)v11 >= 1)
        {
          v39 = 0;
          v40 = (FILE **)MEMORY[0x24BDAC8D8];
          do
          {
            v41 = &v218[1024 * v39];
            if (v41[64])
              fprintf(*v40, "  input directory %d: %s\n", v39 + 1, v41 + 64);
            ++v39;
            if (v41[9280])
              fprintf(*v40, "  input manifest %d: %s\n", v39, v41 + 9280);
          }
          while (v39 != v219);
        }
        LODWORD(v11) = v219;
        v42 = &v218[1024 * (unint64_t)v219];
        if (v42[64])
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  output directory: %s\n", v42 + 64);
        if (v42[9280])
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  output manifest: %s\n", v42 + 9280);
        v13 = (FILE **)MEMORY[0x24BDAC8D8];
        v43 = "patch file";
        if ((v31 & 1) != 0)
          v43 = "diff list file";
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  %s: %s\n", v43, *(const char **)(v220 + 40));
        if (*(_QWORD *)(v220 + 48))
        {
          fprintf(*v13, "  cache URL: %s\n", *(const char **)(v220 + 48));
          if (*(_DWORD *)(v220 + 56))
            v44 = "yes";
          else
            v44 = "no";
          fprintf(*v13, "  update cache: %s\n", v44);
        }
        v45 = *(_QWORD *)(v220 + 96);
        v38 = v216;
        if (v45)
        {
          if (v45 <= 0x64)
            v45 *= getInstalledMemorySize() / 0x64uLL;
          v46 = 0x40000000;
          if (v45 > 0x40000000)
            v46 = v45;
          fprintf(*v13, "  soft memory limit: %llu MB\n", v46 >> 20);
        }
        v47 = *v13;
        if (*(_DWORD *)(v220 + 80))
          fprintf(v47, "  diff level: %d\n");
        else
          fprintf(v47, "  diff level: default (%d)\n");
        fprintf(*v13, "  worker threads: %d\n", v10);
        fprintf(*v13, "  patch threads: %d\n", v10);
        fprintf(*v13, "  min patch size: %llu B\n", *(_QWORD *)(v220 + 64));
        fprintf(*v13, "  archive block size: %zu B\n", *(_QWORD *)(v220 + 72));
        dumpStringArray((uint64_t)"excludeList", *(CFArrayRef *)(v220 + 104), v60, v61, v62, v63, v64, v65, v210);
        dumpStringArray((uint64_t)"includeList", *(CFArrayRef *)(v220 + 112), v66, v67, v68, v69, v70, v71, v211);
        dumpStringArray((uint64_t)"noExcludeList", *(CFArrayRef *)(v220 + 120), v72, v73, v74, v75, v76, v77, v212);
        dumpStringArray((uint64_t)"noIncludeList", *(CFArrayRef *)(v220 + 128), v78, v79, v80, v81, v82, v83, v213);
        LOBYTE(v13) = (_BYTE)v31;
      }
      v16 = (char *)v217;
      if ((v13 & 1) == 0)
      {
        snprintf(v218 + 611392, 0x400uLL, "%s_tmp_XXXXXX", *(const char **)(v220 + 40));
        v84 = strlen(v218 + 611392);
        makePath(v218 + 611392, v84);
        if (!mkdtemp(v218 + 611392))
        {
          v114 = *__error();
          v115 = 5663;
          v116 = v218 + 611392;
          goto LABEL_159;
        }
      }
      v85 = (v11 + 1);
      v86 = v223;
      v87 = v218;
      while (1)
      {
        getRealTime();
        if (v87[9280])
        {
          if ((loadManifest(v87 + 9280, (uint64_t)v86) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5672, 18, 0, "loading manifest %s", v88, v89, (_BYTE)v87 + 64);
LABEL_95:
            v51 = -1;
            v15 = (uint64_t)v218;
            LODWORD(v11) = v219;
            goto LABEL_62;
          }
          getRealTime();
          if (v38 >= 1)
          {
            pc_info("Loaded manifest:  %s (%.1fs)\n", v90, v91, v92, v93, v94, v95, v96, (_BYTE)v87 + 64);
LABEL_86:
            dumpContentsStats((uint64_t)v86);
          }
        }
        else
        {
          if ((loadDirectory(v87 + 64, v10, (size_t)v86) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5678, 18, 0, "loading directory %s", v97, v98, (_BYTE)v87 + 64);
            goto LABEL_95;
          }
          getRealTime();
          if (v38 >= 1)
          {
            pc_info("Loaded directory: %s (%.1fs)\n", v99, v100, v101, v102, v103, v104, v105, (_BYTE)v87 + 64);
            goto LABEL_86;
          }
        }
        v86 = (_OWORD *)((char *)v86 + 56);
        v87 += 1024;
        if (!--v85)
        {
          v15 = (uint64_t)v218;
          LODWORD(v11) = v219;
          if ((mergeContents(v219 + 1, (uint64_t)v223, v218) & 0x80000000) != 0)
          {
            v116 = "merging contents";
            v115 = 5686;
            goto LABEL_158;
          }
          if (v38 < 1
            || (pc_info("Merged %zu inputs and 1 output\n", v106, v107, v108, v109, v110, v111, v112, *v218 - 1),
                v38 == 1))
          {
            v113 = 0;
            goto LABEL_119;
          }
          v117 = *((_QWORD *)v218 + 1);
          if (v117)
          {
            v118 = 0;
            v119 = 0;
            v11 = 0;
            v120 = 0;
            v121 = 0;
            v122 = *((_QWORD *)v218 + 4);
            v123 = *(_QWORD *)v218;
            v124 = *(_QWORD *)v218 - 1;
            v125 = (int *)(v122 + 144);
            while (1)
            {
              if (*(_DWORD *)(v122 + 1208 * v118 + (v124 << 7) + 16))
              {
                if (*(_QWORD *)v218 == 1)
                  goto LABEL_113;
                if (*(_DWORD *)(v122 + 1208 * v118 + 16))
                {
                  v126 = v125;
                  v127 = 2;
                  do
                  {
                    v128 = v127;
                    if (v123 == v127)
                      break;
                    v129 = *v126;
                    v126 += 32;
                    ++v127;
                  }
                  while (v129);
                  if (v128 - 1 >= v124)
                  {
LABEL_113:
                    ++v119;
                    goto LABEL_115;
                  }
                }
                else
                {
                  v130 = 0;
                  v131 = 2;
                  do
                  {
                    v132 = v131;
                    if (v123 == v131)
                      break;
                    v133 = v125[v130];
                    ++v131;
                    v130 += 32;
                  }
                  while (!v133);
                  if (v132 - 1 >= v124)
                  {
                    ++v120;
                    goto LABEL_115;
                  }
                }
                ++v11;
              }
              else
              {
                ++v121;
              }
LABEL_115:
              ++v118;
              v125 += 302;
              if (v118 == v117)
                goto LABEL_118;
            }
          }
          v121 = 0;
          v120 = 0;
          v11 = 0;
          v119 = 0;
LABEL_118:
          v134 = (FILE **)MEMORY[0x24BDAC8D8];
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu not in the output\n", v121);
          fprintf(*v134, "%12zu in the output, and in all inputs\n", v119);
          fprintf(*v134, "%12zu in the output, and in some but not all inputs\n", v11);
          fprintf(*v134, "%12zu in the output, and not in any inputs\n", v120);
          v113 = 1;
          LODWORD(v11) = v219;
LABEL_119:
          if ((applyRules(*(const __CFArray **)(v220 + 104), *(const __CFArray **)(v220 + 112), 0, *(const __CFArray **)(v220 + 120), *(const __CFArray **)(v220 + 128), 0, 0, 0, (uint64_t *)v218, v38) & 0x80000000) != 0)
          {
            pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5720, 18, 0, "applyRules", v135, v136, v209);
            v51 = -1;
            v8 = v220;
            goto LABEL_63;
          }
          if ((initOps(*(_QWORD *)(v220 + 64), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, v215, (uint64_t *)v218, v38) & 0x80000000) != 0)
          {
            v116 = "initOps";
            v115 = 5723;
            goto LABEL_158;
          }
          if (v113)
          {
            pc_info("Initial labels (regular files / symbolic links)\n", v137, v138, v139, v140, v141, v111, v112, v209);
            dumpContentsStats((uint64_t)v218);
          }
          v142 = *((_QWORD *)v218 + 1);
          if (v142)
          {
            v143 = 0;
            v144 = (unsigned int *)(*((_QWORD *)v218 + 4) + 1168);
            do
            {
              v143 += ((unint64_t)*v144 >> 2) & 1;
              v144 += 302;
              --v142;
            }
            while (v142);
            if ((v31 & 1) == 0)
            {
              if (!v143)
                goto LABEL_148;
              v221.st_dev = *(_DWORD *)(v220 + 80);
              *(_DWORD *)&v221.st_mode = v38;
              LODWORD(v221.st_ino) = v10;
              RealTime = getRealTime();
              if ((computePatches(*(_QWORD *)(v220 + 48), *(unsigned int *)(v220 + 56), (uint64_t)v218, (uint64_t)&v221, v10, *(_QWORD *)(v220 + 96), v146, v147) & 0x80000000) != 0)
              {
                v116 = "computePatches";
                v115 = 5755;
              }
              else
              {
                if (v38 >= 1)
                {
                  v153 = v214;
                  v154 = v214 + 1;
                  v155 = atomic_load(v214 + 1);
                  v156 = atomic_load(v153 + 4);
                  v157 = atomic_load(v153);
                  v158 = atomic_load(v153 + 3);
                  v159 = v158 + v157;
                  v160 = getRealTime() - RealTime;
                  pc_info("Generated patches (%.1f s)\n", v161, v162, v163, v164, v165, v166, v167, SLOBYTE(v160));
                  v168 = (FILE **)MEMORY[0x24BDAC8D8];
                  v169 = (FILE *)*MEMORY[0x24BDAC8D8];
                  v170 = atomic_load(v153);
                  fprintf(v169, "%12lld 1:1 patches cache lookups\n", v170);
                  v171 = *v168;
                  v172 = atomic_load(v154);
                  v38 = v216;
                  fprintf(v171, "%12lld 1:1 patches cache hits\n", v172);
                  v173 = *v168;
                  v174 = atomic_load(v153 + 2);
                  fprintf(v173, "%12lld 1:1 patches cache updates\n", v174);
                  v175 = *v168;
                  v176 = atomic_load(v153 + 6);
                  fprintf(v175, "%12lld 1:1 patches created\n", v176);
                  v177 = *v168;
                  v178 = atomic_load(v153 + 3);
                  fprintf(v177, "%12lld combo patches cache lookups\n", v178);
                  v179 = *v168;
                  v180 = atomic_load(v153 + 4);
                  fprintf(v179, "%12lld combo patches cache hits\n", v180);
                  v181 = *v168;
                  v182 = atomic_load(v153 + 5);
                  fprintf(v181, "%12lld combo patches cache updates\n", v182);
                  v183 = *v168;
                  v184 = atomic_load(v153 + 7);
                  fprintf(v183, "%12lld combo patches created\n", v184);
                  v185 = *v168;
                  v186 = atomic_load(v153 + 8);
                  fprintf(v185, "%12lld cache lookups FAILED\n", v186);
                  v187 = *v168;
                  v188 = atomic_load(v153 + 9);
                  fprintf(v187, "%12lld cache updates FAILED\n", v188);
                  if (v159 >= 1)
                    fprintf(*v168, "%11.0f%% cache hits\n", (double)(uint64_t)(v156 + v155) * 100.0 / (double)v159);
                }
                v15 = (uint64_t)v218;
                if (v113)
                {
                  pc_info("Updated labels after patch generation\n", v148, v149, v150, v151, v152, v111, v112, v209);
                  dumpContentsStats((uint64_t)v218);
                }
                LODWORD(v11) = v219;
LABEL_148:
                updateOps((_QWORD *)v15, 0, v38);
                if (v38 >= 1)
                {
                  pc_info("Final labels (all entries)\n", v195, v196, v197, v198, v199, v200, v201, v209);
                  dumpContentsStats(v15);
                }
                if ((checkOps((_QWORD *)v15, v195, v196, v197, v198, v199, v200, v201) & 0x80000000) == 0)
                {
                  if ((generatePatch() & 0x80000000) != 0)
                  {
                    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5797, 18, 0, "generatePatch", v202, v203, v209);
                    v51 = -1;
                    v8 = v220;
                  }
                  else
                  {
                    v204 = *(int8x16_t **)(v220 + 136);
                    v8 = v220;
                    v51 = 0;
                    if (v204)
                    {
                      *v204 = v217[852];
                      v204[1] = vextq_s8(v217[853], v217[853], 8uLL);
                    }
                  }
                  goto LABEL_63;
                }
                v116 = "checkOps";
                v115 = 5794;
              }
LABEL_158:
              v114 = 0;
LABEL_159:
              pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", v115, 18, v114, v116, v111, v112, v209);
              v51 = -1;
              goto LABEL_62;
            }
          }
          else
          {
            if ((v31 & 1) == 0)
              goto LABEL_148;
            LOBYTE(v143) = 0;
          }
          if (v38 >= 1)
            pc_info("Generating diff list, %zu entries\n", v137, v138, v139, v140, v141, v111, v112, v143);
          v8 = v220;
          v189 = fopen(*(const char **)(v220 + 40), "w");
          if (v189)
          {
            v190 = v189;
            v191 = *((_QWORD *)v218 + 1);
            if (v191)
            {
              v192 = 0;
              v193 = 1168;
              do
              {
                v194 = *((_QWORD *)v218 + 4);
                if ((*(_BYTE *)(v194 + v193) & 4) != 0)
                {
                  fprintf(v190, "%s\n", (const char *)(*((_QWORD *)v218 + 7) + *(_QWORD *)(v194 + v193 - 1168)));
                  v191 = *((_QWORD *)v218 + 1);
                }
                ++v192;
                v193 += 1208;
              }
              while (v192 < v191);
            }
            fclose(v190);
            v51 = 0;
            goto LABEL_62;
          }
          v205 = *__error();
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5740, 18, v205, "%s", v206, v207, *(_QWORD *)(v220 + 40));
LABEL_54:
          v51 = -1;
          goto LABEL_63;
        }
      }
    }
  }
  v37 = *v35;
  if (!*v35)
    goto LABEL_24;
  if (!realpath_DARWIN_EXTSN(*v35, (char *)(v25 + 9280)))
  {
    v55 = *__error();
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5612, 18, v55, "%s", v56, v57, (char)v37);
    goto LABEL_60;
  }
  v11 = v219;
  if (!stat((const char *)(v25 + 9280), &v222) && (v222.st_mode & 0xF000) == 0x8000)
    goto LABEL_24;
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"DirectoryDiff", 5613, 18, 0, "Not a regular file: %s", v22, v23, (char)v37);
LABEL_57:
  v51 = -1;
  v15 = (uint64_t)v218;
LABEL_61:
  v16 = (char *)v217;
LABEL_62:
  v8 = v220;
LABEL_63:
  memset(&v221, 0, sizeof(v221));
  if (*v16 && !stat(v16, &v221) && (v221.st_mode & 0xF000) == 0x4000)
    removeTree(v16);
  if ((v11 & 0x80000000) == 0)
  {
    v58 = (v11 + 1);
    v59 = (void **)&v223[1] + 1;
    do
    {
      free(*(v59 - 1));
      BlobBufferFree((uint64_t)v59);
      v59 += 7;
      --v58;
    }
    while (v58);
  }
  free(*(void **)(v15 + 32));
  BlobBufferFree(v15 + 40);
  free((void *)v15);
  LODWORD(result) = leaveThreadErrorContext(*(__CFError ***)(v8 + 144), 0, 0);
  if ((int)result >= 0)
    return v51;
  else
    return result;
}

uint64_t generatePatch()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  off_t *v14;
  const char *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  off_t Pos;
  _OWORD *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int32x4_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  __int16 v55;
  char *v56;
  unint64_t *v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  off_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  const char *v82;
  uint64_t v83;
  __int128 v84;
  int32x4_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  off_t v104;
  uint64_t v105;
  uint64_t v106;
  FILE **v107;
  const char *v108;
  __int16 v109;
  char v110;
  off_t v111;
  int v112;
  off_t *v113;
  uint64_t v114;
  int v115;
  int *v116;
  off_t v117;
  char *v118;
  _QWORD *v119;
  uint64_t v120;
  uint64_t v121;
  __int128 v122;
  __int128 v123;
  unint64_t v124;
  void *v125;
  char v126[1024];
  _WORD v127[2];
  int v128;
  unint64_t v129;
  uint64_t v130;
  int32x4_t v131[2];
  uint64_t v132;
  uint64_t v133;
  __int128 v134;
  int v135;
  uint64_t __buf;
  _QWORD v137[6];

  v0 = MEMORY[0x24BDAC7A8]();
  v8 = v4;
  v9 = v3;
  v10 = (char *)v2;
  v118 = (char *)v1;
  v11 = (const char *)v0;
  v137[3] = *MEMORY[0x24BDAC8D0];
  v13 = *v2;
  v12 = v2[1];
  v14 = v2 + 78128;
  v124 = 0;
  v125 = 0;
  if ((int)v4 >= 1)
  {
    v15 = "combo delta";
    if (v13 == 2)
      v15 = "delta";
    if (v13 == 1)
      v15 = "full replacement";
    pc_info("Generating %s directory patch\n", v1, (uint64_t)v2, v3, v4, v5, v6, v7, (char)v15);
  }
  v122 = 0u;
  v123 = 0u;
  memset(v137, 0, 20);
  __buf = 0;
  v14[2] = 0;
  v14[3] = 0;
  v16 = v14 + 2;
  v17 = 0;
  if (v12)
  {
    v18 = *((_QWORD *)v10 + 4) - 112;
    v19 = v12;
    do
    {
      if (*(_DWORD *)(v18 + (v13 << 7)) == 1)
        v17 += *(_DWORD *)(v18 + 1280) & 1;
      v18 += 1208;
      --v19;
    }
    while (v19);
  }
  v20 = OFileStreamCreateWithFilename(v11, -1);
  v23 = v20;
  if (!v20)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4502, 18, 0, "creating output file: %s", v21, v22, (char)v11);
LABEL_45:
    v56 = 0;
    v57 = 0;
LABEL_46:
    v58 = 0;
    v59 = 0;
LABEL_47:
    v60 = 0xFFFFFFFFLL;
    goto LABEL_48;
  }
  memset(v137, 0, 20);
  __buf = 0x3031464649444944;
  if (OFileStreamWrite((uint64_t)v20, (char *)&__buf, 0x1CuLL) != 28)
  {
    v54 = "write DIDIFF10 header";
    v55 = 4508;
LABEL_44:
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", v55, 18, 0, v54, v24, v25, v110);
    goto LABEL_45;
  }
  Pos = OFileStreamGetPos(v23);
  *(_QWORD *)&v123 = 0;
  *((_QWORD *)&v123 + 1) = v23;
  *((_QWORD *)&v122 + 1) = OFileStreamWrite;
  *(_QWORD *)&v122 = v8;
  v27 = ParallelArchiveWriterCreateLegacy(&v122);
  if (!v27)
  {
    v54 = "creating YAA writer";
    v55 = 4519;
    goto LABEL_44;
  }
  v112 = v9;
  v113 = v14;
  v114 = v13;
  v111 = Pos;
  v119 = v27;
  v116 = v23;
  v115 = v8;
  v121 = v12;
  if (v12)
  {
    v28 = 0;
    v120 = 0;
    v29 = 0;
    v30 = v114 << 7;
    while (1)
    {
      v31 = *((_QWORD *)v10 + 4);
      if (*((_QWORD *)v10 + 1) <= v29)
        v32 = 0;
      else
        v32 = (const char *)(*((_QWORD *)v10 + 7) + *(_QWORD *)(v31 + v28));
      v33 = *(_DWORD *)(v31 + v30 + v28 - 112);
      if (!v33 || v33 == 1 && (*(_DWORD *)(v31 + v28 + 1168) & 9) == 1)
        goto LABEL_39;
      bzero(&v130, 0x890uLL);
      bzero(v127, 0x408uLL);
      LODWORD(v130) = 1;
      if (v33 != 1)
        break;
      if ((*(_BYTE *)(v31 + v28 + 1168) & 8) != 0)
      {
        v130 = 0x4800010001;
LABEL_31:
        __strlcpy_chk();
        goto LABEL_32;
      }
      v130 = 0x4600002001;
      v36 = v31 + v30 + v28;
      v37 = *(_OWORD *)(v36 - 40);
      v135 = *(_DWORD *)(v36 - 24);
      v134 = v37;
      LODWORD(v130) = 8321;
      v132 = *(_QWORD *)(v36 - 104);
LABEL_32:
      LODWORD(v130) = v130 | 0x8000;
      __strlcpy_chk();
      LODWORD(v130) = v130 | 0x1E;
      v42 = vrev64q_s32(*(int32x4_t *)(v31 + v28 + v30 - 56));
      v42.i64[0] = *(_QWORD *)(v31 + v28 + v30 - 56);
      v131[0] = v42;
      if ((*(_BYTE *)(v31 + v28 + 1168) & 4) != 0)
      {
        bzero(v126, 0x400uLL);
        concatPath(v126, 0x400uLL, v10 + 611392, v32);
        *v16 += *(_QWORD *)(v31 + v30 + v28 - 16);
        if (loadFileContents(v126, (char **)&v125, (off_t *)&v124, 0))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4597, 18, 0, "load patch: %s", v47, v48, (char)v126);
          goto LABEL_84;
        }
        qmemcpy(v127, "BXP", 3);
        v128 = 2;
        v129 = v124;
        if (ParallelArchiveWriteEntryHeader((uint64_t)v119, (uint64_t)&v130, (uint64_t)v127, 1, v45, v46, v47, v48))
        {
LABEL_75:
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4605, 18, 0, "write entry header: %s", v43, v44, (char)v32);
LABEL_84:
          v56 = 0;
          v57 = 0;
          v59 = 0;
          goto LABEL_85;
        }
        if (ParallelArchiveWriteEntryData((uint64_t)v119, (uint64_t)v125, v124, v49, v50, v51, v43, v44))
        {
          pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4608, 18, 0, "write entry data: %s", v52, v53, (char)v32);
          goto LABEL_84;
        }
      }
      else if (ParallelArchiveWriteEntryHeader((uint64_t)v119, (uint64_t)&v130, (uint64_t)v127, 0, v38, v39, v40, v41))
      {
        goto LABEL_75;
      }
      ++v120;
      free(v125);
      v125 = 0;
LABEL_39:
      ++v29;
      v28 += 1208;
      if (v121 == v29)
        goto LABEL_50;
    }
    if (v33 != 3)
    {
      if (v33 != 2)
      {
        pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4574, 18, 0, "invalid entry type: %s", v34, v35, (char)v32);
        goto LABEL_84;
      }
      HIDWORD(v130) = 68;
      goto LABEL_32;
    }
    v130 = 0x4C00010001;
    goto LABEL_31;
  }
  v120 = 0;
LABEL_50:
  ParallelArchiveWriterDestroy(v119);
  v23 = v116;
  v69 = OFileStreamGetPos(v116);
  v70 = v8;
  if (!v17)
  {
    v57 = 0;
    goto LABEL_69;
  }
  v71 = OEncoderStreamCreate((uint64_t)OFileStreamWrite, (uint64_t)OFileStreamAbort, (uint64_t)v116, (unint64_t)v118, 1, (uint64_t)v118, v112);
  v59 = v71;
  if (!v71)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4624, 18, 0, "create archive encoder", v72, v73, v110);
    v56 = 0;
    v57 = 0;
    v58 = 0;
    goto LABEL_47;
  }
  *(_QWORD *)&v123 = 0;
  *((_QWORD *)&v123 + 1) = v71;
  *((_QWORD *)&v122 + 1) = OEncoderStreamWrite;
  *(_QWORD *)&v122 = v8;
  v58 = ParallelArchiveWriterCreateLegacy(&v122);
  if (!v58)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4632, 18, 0, "create YAA writer", v74, v75, v110);
    v56 = 0;
    v57 = 0;
    goto LABEL_47;
  }
  v57 = (unint64_t *)MemBufferCreate(0x100000uLL);
  if (!v57)
  {
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4636, 18, 0, "create DAT buffer", v76, v77, v110);
    v56 = 0;
    goto LABEL_47;
  }
  v117 = v69;
  v119 = v58;
  if (!v121)
  {
LABEL_67:
    ParallelArchiveWriterDestroy(v119);
    OEncoderStreamDestroy(v59, v97, v98, v99, v100, v101, v102, v103);
    v23 = v116;
    v69 = v117;
    v70 = v115;
LABEL_69:
    v104 = OFileStreamGetPos(v23);
    if (OFileStreamSetPos(v23, 0) < 0)
    {
      v108 = "seek to patch beginning";
      v109 = 4700;
    }
    else
    {
      *(_QWORD *)((char *)v137 + 4) = v69 - v111;
      *(_QWORD *)((char *)&v137[1] + 4) = v104 - v69;
      if (OFileStreamWrite((uint64_t)v23, (char *)&__buf, 0x1CuLL) == 28)
      {
        *v113 = v104;
        v113[1] = v104 - v69;
        if (v70 >= 1)
        {
          v107 = (FILE **)MEMORY[0x24BDAC8D8];
          fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12lld header size\n", v111);
          fprintf(*v107, "%12zu entries in diff payload\n", v120);
          fprintf(*v107, "%12lld diff payload size\n", v69 - v111);
          fprintf(*v107, "%12zu entries in archive payload\n", v17);
          fprintf(*v107, "%12llu archive payload size\n", v113[1]);
          fprintf(*v107, "%12llu patch size\n", *v113);
          fprintf(*v107, "%12llu patched files disk usage\n", v113[2]);
          fprintf(*v107, "%12llu archived files disk usage\n", v113[3]);
        }
        v56 = 0;
        v58 = 0;
        v59 = 0;
        v60 = 0;
        goto LABEL_48;
      }
      v108 = "update DIDIFF10 header";
      v109 = 4703;
    }
    pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", v109, 18, 0, v108, v105, v106, v110);
    v56 = 0;
    goto LABEL_46;
  }
  v78 = 0;
  v79 = 0;
  v80 = v114 << 7;
  while (1)
  {
    v81 = *((_QWORD *)v10 + 4);
    if (*((_QWORD *)v10 + 1) <= v79)
      v82 = 0;
    else
      v82 = (const char *)(*((_QWORD *)v10 + 7) + *(_QWORD *)(v81 + v78));
    bzero(v127, 0x400uLL);
    if (*(_DWORD *)(v81 + v80 + v78 - 112) != 1 || (*(_DWORD *)(v81 + v78 + 1168) & 9) != 1)
      goto LABEL_66;
    concatPath((char *)v127, 0x400uLL, &v10[1024 * v114 - 960], v82);
    v83 = v81 + v80 + v78;
    v113[3] += *(_QWORD *)(v83 - 16);
    bzero(v131, 0x888uLL);
    v130 = 0x4600002001;
    v84 = *(_OWORD *)(v83 - 40);
    v135 = *(_DWORD *)(v83 - 24);
    v134 = v84;
    LODWORD(v130) = 8705;
    v133 = *(_QWORD *)(v83 - 104);
    LODWORD(v130) = 41473;
    __strlcpy_chk();
    LODWORD(v130) = v130 | 0x1E;
    v85 = vrev64q_s32(*(int32x4_t *)(v83 - 56));
    v85.i64[0] = *(_QWORD *)(v83 - 56);
    v131[0] = v85;
    if (ParallelArchiveWriteEntryHeader((uint64_t)v119, (uint64_t)&v130, 0, 0, v86, v87, v88, v89))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4679, 18, 0, "write entry header: %s", v90, v91, (char)v82);
      v56 = 0;
      goto LABEL_85;
    }
    v56 = (char *)IFileStreamCreateWithFilename((const char *)v127, 0, -1);
    if (!v56)
      break;
    v94 = MemBufferTransmit(v57, 0xFFFFFFFFFFFFFFFFLL, (size_t (*)(int, void *, size_t))IFileStreamRead, (uint64_t)v56, (uint64_t (*)(uint64_t, uint64_t, uint64_t))parallelArchiveWrite, (uint64_t)v119, v92, v93);
    if (v94 < 0 || v94 != *(_QWORD *)(v83 - 104))
    {
      pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4686, 18, 0, "write DAT blob: %s", v95, v96, (char)v127);
      goto LABEL_85;
    }
    IFileStreamDestroy(v56);
LABEL_66:
    ++v79;
    v78 += 1208;
    if (v121 == v79)
      goto LABEL_67;
  }
  pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"generatePatch", 4683, 18, 0, "open archived file: %s", v92, v93, (char)v127);
LABEL_85:
  v60 = 0xFFFFFFFFLL;
  v23 = v116;
  v58 = v119;
LABEL_48:
  ParallelArchiveWriterDestroy(v58);
  OEncoderStreamDestroy(v59, v61, v62, v63, v64, v65, v66, v67);
  OFileStreamDestroy(v23);
  IFileStreamDestroy(v56);
  MemBufferDestroy((void **)v57);
  free(v125);
  return v60;
}

uint64_t parallelArchiveWrite(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (ParallelArchiveWriteEntryData(a1, a2, a3, a4, a5, a6, a7, a8))
    return -1;
  else
    return a3;
}

uint64_t dumpStringArray(uint64_t result, CFArrayRef theArray, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const char *v10;
  uint64_t v11;
  FILE **v12;
  CFIndex v13;
  const __CFString *ValueAtIndex;
  uint64_t v15;
  uint64_t v16;
  const char *CStringPtr;
  uint64_t v18;
  uint64_t v19;

  if (theArray)
  {
    v10 = (const char *)result;
    result = CFArrayGetCount(theArray);
    if (result)
    {
      v11 = result;
      v12 = (FILE **)MEMORY[0x24BDAC8D8];
      result = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "  %s:\n", v10);
      if (v11 >= 1)
      {
        v13 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v13);
          if (!ValueAtIndex)
            return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"dumpStringArray", 884, 18, 0, "CFArrayGetValueAtIndex(%ld) returned 0", v15, v16, v13);
          CStringPtr = CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
          if (!CStringPtr)
            break;
          result = fprintf(*v12, "  - %s\n", CStringPtr);
          if (v11 == ++v13)
            return result;
        }
        return pc_log_error((uint64_t)"/Library/Caches/com.apple.xbs/Sources/ParallelCompression/ParallelDiff/DirectoryDiff.c", (uint64_t)"dumpStringArray", 886, 18, 0, "CFStringGetCStringPtr returned 0", v18, v19, a9);
      }
    }
  }
  return result;
}

uint64_t dumpContentsStats(uint64_t a1)
{
  FILE **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  uint64_t result;

  v2 = (FILE **)MEMORY[0x24BDAC8D8];
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu entries\n", *(_QWORD *)(a1 + 8));
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 72);
    do
    {
      v11 = *((_DWORD *)v10 - 4);
      switch(v11)
      {
        case 3:
          ++v7;
          break;
        case 2:
          ++v8;
          break;
        case 1:
          if (v4 == *v10)
            ++v9;
          else
            ++v6;
          break;
        default:
          ++v5;
          break;
      }
      v10 += 23;
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    v9 = 0;
    v8 = 0;
    v7 = 0;
    v6 = 0;
    v5 = 0;
  }
  fprintf(*v2, "%12zu regular files\n", v9);
  fprintf(*v2, "%12zu directories\n", v8);
  fprintf(*v2, "%12zu symbolic links\n", v7);
  result = fprintf(*v2, "%12zu hard links\n", v6);
  if (v5)
    return fprintf(*v2, "%12zu invalid entries\n", v5);
  return result;
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  unint64_t v14;
  FILE **v15;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = (_DWORD *)(*(_QWORD *)(a1 + 32) + 1168);
    v13 = *(_QWORD *)(a1 + 8);
    do
    {
      v14 = *v12;
      if (*v12)
        ++v8;
      else
        ++v6;
      v11 += v14 & 1;
      v2 += (v14 >> 2) & 1;
      v10 += (v14 >> 3) & 1;
      v3 += (v14 >> 9) & 1;
      v9 += (v14 >> 4) & 1;
      v7 += (v14 >> 1) & 1;
      v5 += (v14 >> 6) & 1;
      v4 += (v14 >> 5) & 1;
      v12 += 302;
      --v13;
    }
    while (v13);
  }
  else
  {
    v11 = 0;
    v10 = 0;
    v9 = 0;
    v8 = 0;
    v7 = 0;
    v6 = 0;
    v5 = 0;
    v4 = 0;
    v3 = 0;
    v2 = 0;
  }
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu entries\n", v1);
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu resolved entries\n", v8);
  v15 = (FILE **)MEMORY[0x24BDAC8D8];
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%12zu non resolved entries\n", v6);
  fprintf(*v15, "%12zu ARCHIVE\n", v11);
  fprintf(*v15, "%12zu PATCH\n", v2);
  fprintf(*v15, "%12zu LINK\n", v10);
  fprintf(*v15, "%12zu FIRMLINK\n", v3);
  fprintf(*v15, "%12zu KEEP\n", v9);
  fprintf(*v15, "%12zu REMOVE\n", v7);
  fprintf(*v15, "%12zu AUTO MKDIR\n", v5);
  return fprintf(*v15, "%12zu IGNORE\n", v4);
}

uint64_t DirectoryEntryPathCompareProc(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return strcmp((const char *)(*(_QWORD *)(a1 + 40) + *a2), (const char *)(*(_QWORD *)(a1 + 40) + *a3));
}

size_t PCompressLZFSEEncode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_encode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result)
    return -1;
  return result;
}

size_t PCompressLZFSEDecode(uint8_t *a1, size_t a2, const uint8_t *a3, size_t a4)
{
  size_t result;

  result = compression_decode_buffer(a1, a2, a3, a4, 0, COMPRESSION_LZFSE);
  if (!result)
    return -1;
  return result;
}

void pc_log_error_cold_1(uint64_t a1, int a2)
{
  _DWORD v2[2];
  __int16 v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v2[0] = 67109378;
  v2[1] = a2;
  v3 = 2080;
  v4 = a1;
  _os_log_error_impl(&dword_2063DA000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "[0x%08x] %s", (uint8_t *)v2, 0x12u);
}

int BZ2_bzDecompress(bz_stream *strm)
{
  return MEMORY[0x24BEDA940](strm);
}

int BZ2_bzDecompressEnd(bz_stream *strm)
{
  return MEMORY[0x24BEDA948](strm);
}

int BZ2_bzDecompressInit(bz_stream *strm, int verbosity, int small)
{
  return MEMORY[0x24BEDA950](strm, *(_QWORD *)&verbosity, *(_QWORD *)&small);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x24BDAC328](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x24BDAC330](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC338](c, data, *(_QWORD *)&len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC360](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x24BDAC368](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x24BDAC370](c, data, *(_QWORD *)&len);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x24BDBBE70](err);
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  return (CFErrorRef)MEMORY[0x24BDBBE90](allocator, domain, code, userInfoKeys, userInfoValues, numUserInfoValues);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC600](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x24BDBC610](theString, *(_QWORD *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x24BDAC738](aBlock);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x24BDAC838](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x24BDAC858]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x24BDAC908]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x24BDAC910]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC930](*(_QWORD *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC938](*(_QWORD *)&a1);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB80](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

int acl_add_flag_np(acl_flagset_t flagset_d, acl_flag_t flag)
{
  return MEMORY[0x24BDAD040](flagset_d, *(_QWORD *)&flag);
}

int acl_create_entry(acl_t *acl_p, acl_entry_t *entry_p)
{
  return MEMORY[0x24BDAD058](acl_p, entry_p);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x24BDAD060](obj_p);
}

int acl_get_entry(acl_t acl, int entry_id, acl_entry_t *entry_p)
{
  return MEMORY[0x24BDAD070](acl, *(_QWORD *)&entry_id, entry_p);
}

acl_t acl_get_file(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x24BDAD080](path_p, *(_QWORD *)&type);
}

int acl_get_flag_np(acl_flagset_t flagset_d, acl_flag_t flag)
{
  return MEMORY[0x24BDAD088](flagset_d, *(_QWORD *)&flag);
}

int acl_get_flagset_np(void *obj_p, acl_flagset_t *flagset_p)
{
  return MEMORY[0x24BDAD090](obj_p, flagset_p);
}

int acl_get_permset_mask_np(acl_entry_t entry_d, acl_permset_mask_t *mask_p)
{
  return MEMORY[0x24BDAD0A0](entry_d, mask_p);
}

void *__cdecl acl_get_qualifier(acl_entry_t entry_d)
{
  return (void *)MEMORY[0x24BDAD0A8](entry_d);
}

int acl_get_tag_type(acl_entry_t entry_d, acl_tag_t *tag_type_p)
{
  return MEMORY[0x24BDAD0B0](entry_d, tag_type_p);
}

acl_t acl_init(int count)
{
  return (acl_t)MEMORY[0x24BDAD0B8](*(_QWORD *)&count);
}

int acl_set_file(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x24BDAD0D0](path_p, *(_QWORD *)&type, acl);
}

int acl_set_permset_mask_np(acl_entry_t entry_d, acl_permset_mask_t mask)
{
  return MEMORY[0x24BDAD0E0](entry_d, mask);
}

int acl_set_qualifier(acl_entry_t entry_d, const void *tag_qualifier_p)
{
  return MEMORY[0x24BDAD0E8](entry_d, tag_qualifier_p);
}

int acl_set_tag_type(acl_entry_t entry_d, acl_tag_t tag_type)
{
  return MEMORY[0x24BDAD0F0](entry_d, *(_QWORD *)&tag_type);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x24BDAD2C8](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x24BDAD310](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x24BDAD328](__count, __size);
}

int chdir(const char *a1)
{
  return MEMORY[0x24BDAD980](a1);
}

int chflags(const char *a1, __uint32_t a2)
{
  return MEMORY[0x24BDAD988](a1, *(_QWORD *)&a2);
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAD990](a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x24BDAD998](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int clonefile(const char *a1, const char *a2, uint32_t a3)
{
  return MEMORY[0x24BDAD9C8](a1, a2, *(_QWORD *)&a3);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x24BDAD9F0](a1);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB978](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(_QWORD *)&algorithm);
}

size_t compression_decode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB980](*(_QWORD *)&algorithm);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB988](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(_QWORD *)&algorithm);
}

size_t compression_encode_scratch_buffer_size(compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB990](*(_QWORD *)&algorithm);
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  return MEMORY[0x24BEDB998](stream);
}

uint64_t compression_stream_identify_algorithm()
{
  return MEMORY[0x24BEDB9A0]();
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  return MEMORY[0x24BEDB9A8](stream, *(_QWORD *)&operation, *(_QWORD *)&algorithm);
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  return MEMORY[0x24BEDB9B0](stream, *(_QWORD *)&flags);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x24BDADA08](*(_QWORD *)&a1, a2, a3);
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x24BDADC20](a1, a2);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x24BDADD18](flags, block);
}

int fchflags(int a1, __uint32_t a2)
{
  return MEMORY[0x24BDAE2B0](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int fchmod(int a1, mode_t a2)
{
  return MEMORY[0x24BDAE2B8](*(_QWORD *)&a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x24BDAE2C8](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x24BDAE2E8](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int feof(FILE *a1)
{
  return MEMORY[0x24BDAE328](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x24BDAE330](a1);
}

ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x24BDAE388](*(_QWORD *)&fd, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

uint64_t fpathconf(int a1, int a2)
{
  return MEMORY[0x24BDAE420](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x24BDAE438](*(_QWORD *)&a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE448](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int fremovexattr(int fd, const char *name, int options)
{
  return MEMORY[0x24BDAE478](*(_QWORD *)&fd, name, *(_QWORD *)&options);
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x24BDAE4D0](a1, a2, a3, *(_QWORD *)&a4);
}

int fsetattrlist(int a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x24BDAE4E8](*(_QWORD *)&a1, a2, a3, a4, *(_QWORD *)&a5);
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x24BDAE4F8](*(_QWORD *)&fd, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x24BDAE508](*(_QWORD *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x24BDAE528](*(_QWORD *)&a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x24BDAE548](*(_QWORD *)&a1, a2);
}

int futimes(int a1, const timeval *a2)
{
  return MEMORY[0x24BDAE588](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x24BDAE5A8](a1, a2, a3, a4, *(_QWORD *)&a5);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x24BDAE5D8](a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x24BDAE5F0](a1);
}

int getgrgid_r(gid_t a1, group *a2, char *a3, size_t a4, group **a5)
{
  return MEMORY[0x24BDAE620](*(_QWORD *)&a1, a2, a3, a4, a5);
}

int getgrnam_r(const char *a1, group *a2, char *a3, size_t a4, group **a5)
{
  return MEMORY[0x24BDAE630](a1, a2, a3, a4, a5);
}

int getpagesize(void)
{
  return MEMORY[0x24BDAE6B8]();
}

pid_t getpid(void)
{
  return MEMORY[0x24BDAE6D0]();
}

int getpwnam_r(const char *a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x24BDAE718](a1, a2, a3, a4, a5);
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x24BDAE728](*(_QWORD *)&a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x24BDAE798](path, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int issetugid(void)
{
  return MEMORY[0x24BDAE908]();
}

int lchflags(const char *a1, __uint32_t a2)
{
  return MEMORY[0x24BDAEA18](a1, *(_QWORD *)&a2);
}

int lchmod(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAEA20](a1, a2);
}

int lchown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x24BDAEA28](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int link(const char *a1, const char *a2)
{
  return MEMORY[0x24BDAEA70](a1, a2);
}

ssize_t listxattr(const char *path, char *namebuff, size_t size, int options)
{
  return MEMORY[0x24BDAEA80](path, namebuff, size, *(_QWORD *)&options);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x24BDAEB20](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAEB28](a1, a2);
}

uint64_t lzma_auto_decoder()
{
  return MEMORY[0x24BEDC558]();
}

uint64_t lzma_code()
{
  return MEMORY[0x24BEDC560]();
}

uint64_t lzma_end()
{
  return MEMORY[0x24BEDC568]();
}

uint64_t lzma_stream_buffer_bound()
{
  return MEMORY[0x24BEDC570]();
}

uint64_t lzma_stream_decoder()
{
  return MEMORY[0x24BEDC578]();
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x24BDAED08](__size);
}

int mbr_gid_to_uuid(gid_t gid, uuid_t uu)
{
  return MEMORY[0x24BDAEE10](*(_QWORD *)&gid, uu);
}

int mbr_sid_to_string(const nt_sid_t *sid, char *string)
{
  return MEMORY[0x24BDAEE20](sid, string);
}

int mbr_sid_to_uuid(const nt_sid_t *sid, uuid_t uu)
{
  return MEMORY[0x24BDAEE28](sid, uu);
}

int mbr_string_to_sid(const char *string, nt_sid_t *sid)
{
  return MEMORY[0x24BDAEE30](string, sid);
}

int mbr_uid_to_uuid(uid_t uid, uuid_t uu)
{
  return MEMORY[0x24BDAEE38](*(_QWORD *)&uid, uu);
}

int mbr_uuid_to_id(const uuid_t uu, id_t *uid_or_gid, int *id_type)
{
  return MEMORY[0x24BDAEE40](uu, uid_or_gid, id_type);
}

int mbr_uuid_to_sid(const uuid_t uu, nt_sid_t *sid)
{
  return MEMORY[0x24BDAEE48](uu, sid);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
{
  return (void *)MEMORY[0x24BDAEE90](__big, __big_len, __little, __little_len);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x24BDAEEC8](__s, __smax, *(_QWORD *)&__c, __n);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAEF28](a1, a2);
}

char *__cdecl mkdtemp(char *a1)
{
  return (char *)MEMORY[0x24BDAEF38](a1);
}

int mkfifo(const char *a1, mode_t a2)
{
  return MEMORY[0x24BDAEF48](a1, a2);
}

int mknod(const char *a1, mode_t a2, dev_t a3)
{
  return MEMORY[0x24BDAEF50](a1, a2, *(_QWORD *)&a3);
}

int mkostemp(char *path, int oflags)
{
  return MEMORY[0x24BDAEF58](path, *(_QWORD *)&oflags);
}

int mkstemp(char *a1)
{
  return MEMORY[0x24BDAEF70](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x24BDAEFA8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFF0](a1, a2);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x24BDAF230](a1, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x24BDAF258](a1);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

int pclose(FILE *a1)
{
  return MEMORY[0x24BDAF5A0](a1);
}

FILE *__cdecl popen(const char *a1, const char *a2)
{
  return (FILE *)MEMORY[0x24BDAF5E0](a1, a2);
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x24BDAF698](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF778](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x24BDAF790](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x24BDAF798](__attr, *(_QWORD *)&__qos_class, *(_QWORD *)&__relative_priority);
}

int pthread_attr_setstacksize(pthread_attr_t *a1, size_t a2)
{
  return MEMORY[0x24BDAF7C0](a1, a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x24BDAF7C8](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x24BDAF7D0](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x24BDAF7D8](a1, a2);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x24BDAF800](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x24BDAF818](a1, a2, a3, a4);
}

int pthread_get_qos_class_np(pthread_t __pthread, qos_class_t *__qos_class, int *__relative_priority)
{
  return MEMORY[0x24BDAF838](__pthread, __qos_class, __relative_priority);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x24BDAF860](a1);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x24BDAF880](a1, a2);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x24BDAF888](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8C0](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x24BDAF8C8](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x24BDAF910](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x24BDAF978]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x24BDAF9A8](a1, a2);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x24BDAFA00](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

void qsort_r(void *__base, size_t __nel, size_t __width, void *a4, int (__cdecl *__compar)(void *, const void *, const void *))
{
  MEMORY[0x24BDAFA28](__base, __nel, __width, a4, __compar);
}

int rand(void)
{
  return MEMORY[0x24BDAFA38]();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x24BDAFA80](*(_QWORD *)&a1, a2, a3);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x24BDAFA90](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x24BDAFA98](a1, a2, a3);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x24BDAFAB0](__ptr, __size);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x24BDAFAB8](__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x24BDAFAC0](a1, a2);
}

int removexattr(const char *path, const char *name, int options)
{
  return MEMORY[0x24BDAFB68](path, name, *(_QWORD *)&options);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x24BDAFB80](__from, __to, __ec);
}

int rmdir(const char *a1)
{
  return MEMORY[0x24BDAFBB0](a1);
}

int setattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x24BDAFD00](a1, a2, a3, a4, *(_QWORD *)&a5);
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x24BDAFD98](path, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x24BDAFE50](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAFEA8](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x24BDAFEB0](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFEE8](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x24BDAFF10](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF38](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x24BDAFF50](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF70](__dst, __src, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFFA8](__s, *(_QWORD *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x24BDAFFC8](__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0040](__str, __endptr, *(_QWORD *)&__base);
}

int symlink(const char *a1, const char *a2)
{
  return MEMORY[0x24BDB0090](a1, a2);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x24BDB00F0](*(_QWORD *)&a1);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x24BDB0100](a1, a2, a3, a4, a5);
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

int truncate(const char *a1, off_t a2)
{
  return MEMORY[0x24BDB0290](a1, a2);
}

int unlink(const char *a1)
{
  return MEMORY[0x24BDB02B0](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x24BDB02E8](*(_QWORD *)&a1);
}

int utimes(const char *a1, const timeval *a2)
{
  return MEMORY[0x24BDB02F8](a1, a2);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x24BDB0330](in, uu);
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x24BDB0348](uu, out);
}

void *__cdecl valloc(size_t a1)
{
  return (void *)MEMORY[0x24BDB0350](a1);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0370](a1, a2, a3);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

