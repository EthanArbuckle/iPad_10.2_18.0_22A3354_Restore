uint64_t _UIntBuffer.init()()
{
  return 0;
}

uint64_t _UIntBuffer.capacity.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized _UIntBuffer.capacity.getter(a2, a3);
}

uint64_t static UInt32.bitWidth.getter()
{
  return 32;
}

uint64_t _UIntBuffer.append(_:)(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2)
{
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE *v30;
  char v31;
  uint64_t v32;
  uint64_t WitnessTable;
  uint64_t v34;
  void (*v35)(uint64_t, uint64_t);
  uint64_t (*v36)(uint64_t, uint64_t);
  char v37;
  unint64_t v38;
  const char *v39;
  unint64_t AssociatedConformanceWitness;
  _BYTE *v41;
  _BYTE *v42;
  void (*v43)(_BYTE *, uint64_t);
  uint64_t (*v44)(uint64_t, uint64_t);
  uint64_t v45;
  void (*v46)(_BYTE *, _BYTE *, uint64_t);
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  _BYTE *v54;
  _BYTE *v55;
  _BYTE *v56;
  void (*v57)(_BYTE *, uint64_t);
  _BYTE *v58;
  unsigned int v59;
  _BYTE *v60;
  void (*v61)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v62;
  _BYTE *v63;
  char v64;
  _BYTE *v65;
  _BYTE *v66;
  uint64_t (*v67)(uint64_t, uint64_t);
  int v68;
  void (*v69)(_BYTE *, uint64_t);
  uint64_t (*v70)(uint64_t, uint64_t);
  uint64_t (*v71)(uint64_t, uint64_t);
  _BYTE *v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  _BYTE *v76;
  _BYTE *v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v83;
  _BYTE *v84;
  _BYTE *v85;
  char v86;
  _BYTE *v87;
  void (*v88)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v89;
  _BYTE *v90;
  char v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  _BYTE *v95;
  _BYTE *v96;
  _BYTE *v97;
  unsigned int v98;
  _BYTE *v99;
  unsigned int v100;
  BOOL v101;
  _BYTE *v102;
  unsigned int v103;
  int v104;
  char v105;
  uint64_t result;
  _BYTE v107[12];
  unsigned int v108;
  _BYTE *v109;
  _BYTE *v110;
  _BYTE *v111;
  uint64_t v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t (*v114)(uint64_t, uint64_t);
  _BYTE *v115;
  _BYTE *v116;
  _BYTE *v117;
  unint64_t AssociatedTypeWitness;
  const char *v119;
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t (*v121)(uint64_t, uint64_t);
  _BYTE *v122;
  int v123;
  char v124;
  unsigned int v125;
  unsigned int v126;

  v3 = v2;
  v113 = a1;
  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(v6 + 8);
  v119 = *(const char **)(*(_QWORD *)(v7 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v119, v5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v8 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v117 = &v107[-v9];
  v10 = *(_QWORD *)(v5 - 8);
  v11 = MEMORY[0x1E0C80A78](v8);
  v110 = &v107[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v13 = MEMORY[0x1E0C80A78](v11);
  v115 = &v107[-v14];
  v15 = MEMORY[0x1E0C80A78](v13);
  v111 = &v107[-v16];
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = &v107[-v18];
  v20 = MEMORY[0x1E0C80A78](v17);
  v121 = &v107[-v21];
  v22 = MEMORY[0x1E0C80A78](v20);
  v116 = &v107[-v23];
  v24 = MEMORY[0x1E0C80A78](v22);
  v122 = &v107[-v25];
  v26 = MEMORY[0x1E0C80A78](v24);
  v28 = &v107[-v27];
  MEMORY[0x1E0C80A78](v26);
  v30 = &v107[-v29];
  v31 = v2[4];
  v123 = *(_DWORD *)v2;
  v124 = v31;
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, v32);
  v34 = Collection.count.getter(a2, WitnessTable);
  if (__OFADD__(v34, 1))
  {
    __break(1u);
LABEL_39:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
  }
  if (specialized _UIntBuffer.capacity.getter(v5, v6) < v34 + 1)
    goto LABEL_39;
  v109 = v19;
  v35 = *(void (**)(uint64_t, uint64_t))(v6 + 64);
  v112 = v6;
  v35(v5, v6);
  v36 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  v37 = v36(v5, v7);
  v120 = v36;
  if ((v37 & 1) != 0)
  {
    (*(void (**)(_BYTE *, _BYTE *, uint64_t))(v10 + 16))(v28, v30, v5);
    v38 = AssociatedTypeWitness;
    v39 = v119;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v119, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v41 = v117;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v38, AssociatedConformanceWitness);
    v42 = v122;
    (*((void (**)(_BYTE *, uint64_t, const char *))v39 + 3))(v41, v5, v39);
    LOBYTE(v38) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 32))(v28, v42, v5);
    v43 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
    v43(v42, v5);
    if ((v38 & 1) == 0)
      goto LABEL_40;
    v43(v28, v5);
    v36 = v120;
  }
  v44 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 128);
  v45 = v44(v5, v7);
  v114 = v44;
  if (v45 >= 32)
  {
    v46 = *(void (**)(_BYTE *, _BYTE *, uint64_t))(v10 + 16);
    v46(v116, v30, v5);
    v125 = -1;
    v47 = v36(v5, v7);
    v44 = v114;
    v48 = v114(v5, v7);
    if ((v47 & 1) != 0)
    {
      if (v48 < 33)
      {
        v51 = AssociatedTypeWitness;
        v52 = v119;
        v53 = swift_getAssociatedConformanceWitness((uint64_t)v119, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v54 = v117;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v53 + 8))(&unk_1816B7DA8, 256, v51, v53);
        v55 = v122;
        (*((void (**)(_BYTE *, uint64_t, const char *))v52 + 3))(v54, v5, v52);
        v56 = v116;
        LOBYTE(v51) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8)
                                                                           + 40))(v116, v55, v5);
        v57 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
        v57(v55, v5);
        v108 = v125;
        v58 = v109;
        v46(v109, v56, v5);
        if ((v51 & 1) != 0)
        {
          v59 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
          v57(v58, v5);
          v36 = v120;
          v60 = v116;
          v44 = v114;
          if (v108 < v59)
            goto LABEL_34;
        }
        else
        {
          v57(v58, v5);
          v36 = v120;
          v60 = v116;
          v44 = v114;
        }
LABEL_18:
        v57(v60, v5);
        goto LABEL_19;
      }
    }
    else if (v48 <= 32)
    {
      v65 = v122;
      v66 = v116;
      v46(v122, v116, v5);
      v60 = v66;
      LODWORD(v66) = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
      v57 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
      v57(v65, v5);
      v36 = v120;
      if (v125 < v66)
        goto LABEL_34;
      goto LABEL_18;
    }
    v61 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    v62 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v48, v49, v50);
    v63 = v122;
    v61(&v125, &type metadata for UInt32, v62, v5, v7);
    v60 = v116;
    v64 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 16))(v63, v116, v5);
    v57 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
    v57(v63, v5);
    v36 = v120;
    if ((v64 & 1) != 0)
      goto LABEL_34;
    goto LABEL_18;
  }
LABEL_19:
  v67 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 120);
  v68 = v67(v5, v7);
  v69 = *(void (**)(_BYTE *, uint64_t))(v10 + 8);
  v69(v30, v5);
  *(_DWORD *)v3 &= ~(v68 << v3[4]);
  v70 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 16);
  v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
  ((void (*)(uint64_t (*)(uint64_t, uint64_t), uint64_t (*)(uint64_t, uint64_t), uint64_t))v70)((uint64_t (*)(uint64_t, uint64_t))v121, v113, v5);
  if ((v36(v5, v7) & 1) == 0)
    goto LABEL_22;
  v113 = v67;
  v116 = v3;
  v72 = v111;
  ((void (*)(_BYTE *, uint64_t (*)(uint64_t, uint64_t), uint64_t))v70)(v111, v71, v5);
  v73 = AssociatedTypeWitness;
  v74 = v119;
  v75 = swift_getAssociatedConformanceWitness((uint64_t)v119, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v76 = v117;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v75 + 8))(&unk_1816B7DA8, 256, v73, v75);
  v77 = v122;
  (*((void (**)(_BYTE *, uint64_t, const char *))v74 + 3))(v76, v5, v74);
  LOBYTE(v73) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 32))(v72, v77, v5);
  v69(v77, v5);
  if ((v73 & 1) == 0)
LABEL_40:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  v69(v72, v5);
  v3 = v116;
  v36 = v120;
  v67 = v113;
  v44 = v114;
LABEL_22:
  if (v44(v5, v7) >= 32)
  {
    v113 = v70;
    ((void (*)(_BYTE *, uint64_t (*)(uint64_t, uint64_t), uint64_t))v70)(v115, v71, v5);
    v126 = -1;
    v78 = v36(v5, v7);
    v79 = v44(v5, v7);
    if ((v78 & 1) != 0)
    {
      v116 = v3;
      if (v79 >= 33)
      {
        v82 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
        v83 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v79, v80, v81);
        v84 = v122;
        v82(&v126, &type metadata for UInt32, v83, v5, v7);
        v85 = v115;
        v86 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 16))(v84, v115, v5);
        v69(v84, v5);
        v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        v3 = v116;
        if ((v86 & 1) != 0)
          goto LABEL_34;
        goto LABEL_36;
      }
      v92 = AssociatedTypeWitness;
      v93 = v119;
      v94 = swift_getAssociatedConformanceWitness((uint64_t)v119, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v95 = v117;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v94 + 8))(&unk_1816B7DA8, 256, v92, v94);
      v96 = v122;
      (*((void (**)(_BYTE *, uint64_t, const char *))v93 + 3))(v95, v5, v93);
      v97 = v115;
      LOBYTE(v92) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 40))(v115, v96, v5);
      v69(v96, v5);
      v98 = v126;
      v99 = v110;
      ((void (*)(_BYTE *, _BYTE *, uint64_t))v113)(v110, v97, v5);
      if ((v92 & 1) != 0)
      {
        v100 = v67(v5, v7);
        v69(v99, v5);
        v101 = v98 >= v100;
        v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        v85 = v115;
        v3 = v116;
        if (!v101)
LABEL_34:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
      }
      else
      {
        v69(v99, v5);
        v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        v85 = v115;
        v3 = v116;
      }
    }
    else
    {
      v87 = v3;
      if (v79 <= 32)
      {
        v102 = v122;
        v85 = v115;
        ((void (*)(_BYTE *, _BYTE *, uint64_t))v113)(v122, v115, v5);
        v103 = v67(v5, v7);
        v69(v102, v5);
        v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        v3 = v87;
        if (v126 < v103)
          goto LABEL_34;
      }
      else
      {
        v88 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
        v89 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v79, v80, v81);
        v90 = v122;
        v88(&v126, &type metadata for UInt32, v89, v5, v7);
        v85 = v115;
        v91 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 16))(v90, v115, v5);
        v69(v90, v5);
        v71 = (uint64_t (*)(uint64_t, uint64_t))v121;
        v3 = v87;
        if ((v91 & 1) != 0)
          goto LABEL_34;
      }
    }
LABEL_36:
    v69(v85, v5);
  }
  v104 = v67(v5, v7);
  v69(v71, v5);
  v105 = v3[4];
  *(_DWORD *)v3 |= v104 << v105;
  result = (*(uint64_t (**)(uint64_t))(v112 + 56))(v5);
  v3[4] = v105 + result;
  return result;
}

uint64_t _UIntBuffer.removeFirst()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  unsigned int *v4;
  uint64_t WitnessTable;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v14)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v15;
  char v16;
  uint64_t (*v17)(uint64_t, uint64_t);
  uint64_t result;
  unsigned int v19;

  v4 = v3;
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a1, a3);
  v7 = Collection.isEmpty.getter(a1, WitnessTable);
  if ((v7 & 1) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xC8uLL, 0);
  v19 = *v3;
  v10 = v19;
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD *)(a1 + 24);
  v13 = *(_QWORD *)(v12 + 8);
  v14 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v13 + 96);
  v15 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v7, v8, v9);
  v14(&v19, &type metadata for UInt32, v15, v11, v13);
  v16 = *((_BYTE *)v4 + 4);
  v17 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 56);
  *((_BYTE *)v4 + 4) = v16 - v17(v11, v12);
  result = v17(v11, v12);
  *v4 = v10 >> ((result + 1) >> 1) >> (result >> 1);
  return result;
}

uint64_t _UIntBuffer.replaceSubrange<A>(_:with:)(uint64_t a1, uint64_t (*a2)(uint64_t, _QWORD *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  unsigned int v44;
  unint64_t v45;
  unint64_t AssociatedConformanceWitness;
  unint64_t v47;
  char *v48;
  _QWORD *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void (*v55)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, _QWORD *);
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  int v60;
  char v61;
  _QWORD *v62;
  int v63;
  int v64;
  char *v65;
  char *v66;
  int v67;
  uint64_t WitnessTable;
  uint64_t v69;
  uint64_t v70;
  int v71;
  void (*v72)(char *, char *, uint64_t);
  _QWORD *v73;
  _QWORD *v74;
  char *v75;
  unint64_t v76;
  const char *v77;
  unint64_t v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  void (*v83)(char *, uint64_t);
  uint64_t (*v84)(uint64_t, _QWORD *);
  uint64_t v85;
  char *v86;
  _QWORD *v87;
  void (*v88)(char *, char *, uint64_t);
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  const char *v95;
  unint64_t v96;
  char *v97;
  char *v98;
  char *v99;
  _QWORD *v100;
  _QWORD *v101;
  void (*v102)(char *, uint64_t);
  unsigned int v103;
  char *v104;
  unsigned int v105;
  BOOL v106;
  void (*v107)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, _QWORD *);
  unint64_t v108;
  char *v109;
  char v110;
  char *v111;
  unsigned int v112;
  void (*v113)(char *, uint64_t);
  void (*v114)(char *, char *, uint64_t);
  char *v115;
  unint64_t v116;
  const char *v117;
  unint64_t v118;
  char *v119;
  char *v120;
  _QWORD *v121;
  void (*v122)(char *, char *, uint64_t);
  char v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  char *v130;
  char *v131;
  unsigned int v132;
  char *v133;
  unsigned int v134;
  char *v135;
  unsigned int v136;
  uint64_t v137;
  uint64_t (*v138)(uint64_t, uint64_t);
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  uint64_t v145;
  char v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t result;
  uint64_t v158;
  _QWORD *v159;
  uint64_t v160;
  uint64_t v161;
  char *v162;
  char *v163;
  uint64_t v164;
  char *v165;
  char *v166;
  char *v167;
  _QWORD *v168;
  void (*v169)(char *, char *, uint64_t);
  uint64_t (*v170)(char *, uint64_t, uint64_t);
  void (*v171)(unint64_t);
  unint64_t v172;
  char *v173;
  char *v174;
  uint64_t v175;
  char *v176;
  unint64_t v177;
  char *v178;
  unint64_t AssociatedTypeWitness;
  const char *v180;
  char *v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  char *v185;
  char *v186;
  uint64_t (*v187)(uint64_t, _QWORD *);
  uint64_t v188;
  uint64_t (*v189)(uint64_t, _QWORD *);
  unsigned int v190;
  char v191;

  v189 = a2;
  v8 = a1;
  v161 = a1;
  v9 = BYTE1(a1);
  v11 = *(_QWORD *)(a3 + 16);
  v10 = *(_QWORD *)(a3 + 24);
  v175 = a3;
  v188 = v10;
  v12 = *(_QWORD **)(v10 + 8);
  v180 = *(const char **)(v12[3] + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v180, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v13 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v178 = (char *)&v158 - v14;
  v168 = *(_QWORD **)(v11 - 8);
  v15 = MEMORY[0x1E0C80A78](v13);
  v163 = (char *)&v158 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v15);
  v162 = (char *)&v158 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v173 = (char *)&v158 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v165 = (char *)&v158 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v167 = (char *)&v158 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v186 = (char *)&v158 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v166 = (char *)&v158 - v28;
  v29 = MEMORY[0x1E0C80A78](v27);
  v31 = (char *)&v158 - v30;
  MEMORY[0x1E0C80A78](v29);
  v181 = (char *)&v158 - v32;
  v35 = type metadata accessor for Optional(0, v11, v33, v34);
  MEMORY[0x1E0C80A78](v35);
  v174 = (char *)&v158 - v36;
  v37 = *(_QWORD *)(a5 + 8);
  v177 = swift_getAssociatedTypeWitness(0, (const char *)v37, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v38 = MEMORY[0x1E0C80A78](v177);
  v176 = (char *)&v158 - v39;
  MEMORY[0x1E0C80A78](v38);
  v43 = (char *)&v158 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0);
  v164 = v9;
  if (v9 < v8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v160 = v5;
  v44 = *(unsigned __int8 *)(v5 + 4);
  if (v44 < v8 || v44 < v164)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xD4uLL, 0);
  v158 = v41;
  (*(void (**)(char *, uint64_t (*)(uint64_t, _QWORD *), uint64_t))(v40 + 16))(v43, v189, a4);
  (*(void (**)(uint64_t, uint64_t))(v37 + 32))(a4, v37);
  v45 = v177;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v37, a4, v177, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v47 = v45;
  v48 = v174;
  v171 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
  v172 = AssociatedConformanceWitness;
  v171(v47);
  v49 = v168;
  v170 = (uint64_t (*)(char *, uint64_t, uint64_t))v168[6];
  if (v170(v48, 1, v11) != 1)
  {
    v51 = 0;
    v52 = 0;
    v169 = (void (*)(char *, char *, uint64_t))v49[4];
    v185 = v31;
    v53 = v175;
    v159 = v12;
    v169(v181, v48, v11);
    while (1)
    {
      v190 = v51;
      v191 = v52;
      WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, v53, v54);
      v69 = Collection.count.getter(v53, WitnessTable);
      if (__OFADD__(v69, 1))
      {
        __break(1u);
LABEL_52:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      }
      v70 = v188;
      if (specialized _UIntBuffer.capacity.getter(v11, v188) < v69 + 1)
        goto LABEL_52;
      v184 = v52;
      (*(void (**)(uint64_t, uint64_t))(v70 + 64))(v11, v70);
      v189 = (uint64_t (*)(uint64_t, _QWORD *))v12[8];
      if ((v189(v11, v12) & 1) != 0)
      {
        v71 = v51;
        v72 = (void (*)(char *, char *, uint64_t))v49[2];
        v73 = v12;
        v74 = v49;
        v75 = v166;
        v72(v166, v31, v11);
        v76 = AssociatedTypeWitness;
        v77 = v180;
        v78 = swift_getAssociatedConformanceWitness((uint64_t)v180, v11, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v79 = v178;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v78 + 8))(&unk_1816B7DA8, 256, v76, v78);
        v80 = v186;
        v81 = v79;
        v82 = v75;
        v49 = v74;
        v12 = v73;
        (*((void (**)(char *, uint64_t, const char *))v77 + 3))(v81, v11, v77);
        LOBYTE(v76) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v73[4] + 8) + 32))(v82, v80, v11);
        v83 = (void (*)(char *, uint64_t))v49[1];
        v83(v80, v11);
        if ((v76 & 1) == 0)
          goto LABEL_53;
        v83(v82, v11);
        v31 = v185;
        v51 = v71;
      }
      v183 = v51;
      v84 = (uint64_t (*)(uint64_t, _QWORD *))v12[16];
      v85 = v84(v11, v12);
      v86 = v181;
      if (v85 >= 32)
        break;
LABEL_30:
      v187 = (uint64_t (*)(uint64_t, _QWORD *))v12[15];
      v182 = v187(v11, v12);
      v113 = (void (*)(char *, uint64_t))v49[1];
      v113(v31, v11);
      if ((v189(v11, v12) & 1) != 0)
      {
        v114 = (void (*)(char *, char *, uint64_t))v49[2];
        v115 = v165;
        v114(v165, v86, v11);
        v116 = AssociatedTypeWitness;
        v117 = v180;
        v118 = swift_getAssociatedConformanceWitness((uint64_t)v180, v11, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v119 = v178;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v118 + 8))(&unk_1816B7DA8, 256, v116, v118);
        v120 = v186;
        (*((void (**)(char *, uint64_t, const char *))v117 + 3))(v119, v11, v117);
        LOBYTE(v116) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v12[4] + 8) + 32))(v115, v120, v11);
        v113(v120, v11);
        if ((v116 & 1) == 0)
LABEL_53:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
        v113(v115, v11);
        v49 = v168;
        v31 = v185;
        v86 = v181;
      }
      if (v84(v11, v12) >= 32)
      {
        v121 = v49;
        v122 = (void (*)(char *, char *, uint64_t))v49[2];
        v122(v173, v86, v11);
        v190 = -1;
        v123 = v189(v11, v12);
        v124 = v84(v11, v12);
        if ((v123 & 1) != 0)
        {
          if (v124 <= 32)
          {
            v127 = AssociatedTypeWitness;
            v128 = v180;
            v129 = swift_getAssociatedConformanceWitness((uint64_t)v180, v11, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v130 = v178;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v129 + 8))(&unk_1816B7DA8, 256, v127, v129);
            v131 = v186;
            (*((void (**)(char *, uint64_t, const char *))v128 + 3))(v130, v11, v128);
            v58 = v173;
            LOBYTE(v127) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v12[4] + 8) + 40))(v173, v131, v11);
            v113(v131, v11);
            v132 = v190;
            v133 = v162;
            v122(v162, v58, v11);
            if ((v127 & 1) != 0)
            {
              v134 = v187(v11, v12);
              v113(v133, v11);
              v106 = v132 >= v134;
              v49 = v168;
              v86 = v181;
              if (!v106)
                goto LABEL_54;
            }
            else
            {
              v113(v133, v11);
              v49 = v168;
              v86 = v181;
            }
            goto LABEL_9;
          }
        }
        else if (v124 <= 32)
        {
          v135 = v186;
          v58 = v173;
          v122(v186, v173, v11);
          v136 = v187(v11, v12);
          v113(v135, v11);
          v49 = v121;
          if (v190 < v136)
LABEL_54:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
          goto LABEL_9;
        }
        v55 = (void (*)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, _QWORD *))v12[12];
        v56 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v124, v125, v126);
        v57 = v186;
        v55(&v190, &type metadata for UInt32, v56, v11, v12);
        v58 = v173;
        v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v12[4] + 8) + 16))(v57, v173, v11);
        v113(v57, v11);
        v49 = v121;
        if ((v59 & 1) != 0)
          goto LABEL_54;
LABEL_9:
        v113(v58, v11);
        v31 = v185;
      }
      v60 = v184;
      v61 = v184 & 0x1F;
      v62 = v49;
      v63 = v183 & ~((_DWORD)v182 << v184);
      v64 = v187(v11, v12);
      v113(v86, v11);
      v51 = (v64 << v61) | v63;
      v49 = v62;
      v65 = v86;
      v52 = v60 + (*(unsigned int (**)(uint64_t))(v188 + 56))(v11);
      v66 = v174;
      ((void (*)(unint64_t, unint64_t))v171)(v177, v172);
      v67 = v170(v66, 1, v11);
      v53 = v175;
      if (v67 == 1)
      {
        v50 = v52;
        goto LABEL_44;
      }
      v169(v65, v66, v11);
    }
    v87 = v49;
    v88 = (void (*)(char *, char *, uint64_t))v49[2];
    v89 = v167;
    v88(v167, v31, v11);
    v190 = -1;
    v90 = v189(v11, v12);
    v91 = v84(v11, v12);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 32)
      {
        v94 = AssociatedTypeWitness;
        v95 = v180;
        v96 = swift_getAssociatedConformanceWitness((uint64_t)v180, v11, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v97 = v178;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v96 + 8))(&unk_1816B7DA8, 256, v94, v96);
        v98 = v186;
        v99 = v97;
        v100 = v12;
        v101 = v168;
        (*((void (**)(char *, uint64_t, const char *))v95 + 3))(v99, v11, v95);
        LOBYTE(v100) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v100[4] + 8) + 40))(v89, v98, v11);
        v87 = v101;
        v102 = (void (*)(char *, uint64_t))v101[1];
        v102(v98, v11);
        v103 = v190;
        v104 = v163;
        v88(v163, v89, v11);
        if ((v100 & 1) != 0)
        {
          v12 = v159;
          v105 = ((uint64_t (*)(uint64_t, _QWORD *))v159[15])(v11, v159);
          v102(v104, v11);
          v106 = v103 >= v105;
          v89 = v167;
          v86 = v181;
          if (!v106)
            goto LABEL_54;
        }
        else
        {
          v102(v104, v11);
          v89 = v167;
          v86 = v181;
          v12 = v159;
        }
LABEL_29:
        v102(v89, v11);
        v31 = v185;
        v49 = v87;
        goto LABEL_30;
      }
    }
    else if (v91 <= 32)
    {
      v111 = v186;
      v88(v186, v89, v11);
      v112 = ((uint64_t (*)(uint64_t, _QWORD *))v12[15])(v11, v12);
      v102 = (void (*)(char *, uint64_t))v87[1];
      v102(v111, v11);
      if (v190 < v112)
        goto LABEL_54;
      goto LABEL_29;
    }
    v107 = (void (*)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, _QWORD *))v12[12];
    v108 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v91, v92, v93);
    v109 = v186;
    v107(&v190, &type metadata for UInt32, v108, v11, v12);
    v110 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v12[4] + 8) + 16))(v109, v89, v11);
    v102 = (void (*)(char *, uint64_t))v87[1];
    v102(v109, v11);
    if ((v110 & 1) != 0)
      goto LABEL_54;
    goto LABEL_29;
  }
  v50 = 0;
  v51 = 0;
LABEL_44:
  (*(void (**)(char *, unint64_t))(v158 + 8))(v176, v177);
  v137 = v188;
  v138 = *(uint64_t (**)(uint64_t, uint64_t))(v188 + 56);
  v139 = v138(v11, v188);
  v140 = v160;
  if (!v139 || (v141 = v139, (v142 = v138(v11, v137)) == 0))
LABEL_55:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  v144 = v51;
  v145 = v161;
  v146 = *(_BYTE *)(v140 + 4);
  v147 = v50 / v142 - (v164 - v161) / v141;
  v190 = *(_DWORD *)v140;
  v191 = v146;
  v148 = v175;
  v149 = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, v175, v143);
  v150 = Collection.count.getter(v148, v149);
  if (__OFADD__(v150, v147))
  {
    __break(1u);
LABEL_58:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xDDuLL, 0);
  }
  v151 = v188;
  if (specialized _UIntBuffer.capacity.getter(v11, v188) < v150 + v147)
    goto LABEL_58;
  v152 = v138(v11, v151);
  if (!v152)
    goto LABEL_55;
  v153 = v152;
  v154 = v138(v11, v151);
  if (!v154)
    goto LABEL_55;
  v155 = v145 / v153;
  v156 = v164 / v154;
  result = v138(v11, v151);
  *(_DWORD *)v140 = (*(_DWORD *)v140 >> ((result * v156 + 1) >> 1) >> ((result * v156) >> 1) << (result * (v156 + v147))) | (v144 << (result * v155)) | ((1 << ((result * v155 + 1) >> 1) << ((result * v155) >> 1)) - 1) & *(_DWORD *)v140;
  *(_BYTE *)(v140 + 4) += result * v147;
  return result;
}

void protocol witness for RangeReplaceableCollection.init() in conformance _UIntBuffer<A>(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 0;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int *v6;
  unsigned int *v9;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t WitnessTable;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t result;
  uint64_t v40;
  int v41;
  uint64_t (*v42)(uint64_t, uint64_t);
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  char v46;
  int v47;
  char v48;
  int v49;
  char v50;

  v9 = v6;
  v12 = (unsigned __int8 *)MEMORY[0x1E0C80A78](a1);
  v16 = (char *)&v40 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = *v12;
  v18 = v12[1];
  if (v18 < v17)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v19 = *((unsigned __int8 *)v9 + 4);
  if (v17 > v19 || v18 > v19)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xD4uLL, 0);
  v43 = v14;
  v44 = v13;
  (*(void (**)(char *))(v14 + 16))(v16);
  RangeReplaceableCollection.init<A>(_:)((uint64_t)v16, a5, a3, a6, *(_QWORD *)(a4 + 8));
  v21 = v49;
  v22 = v50;
  v23 = *(_QWORD *)(a5 + 16);
  v24 = *(_QWORD *)(a5 + 24);
  v42 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 56);
  v25 = v42(v23, v24);
  if (!v25)
LABEL_14:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  v41 = v21;
  v47 = v21;
  v48 = v22;
  v27 = (v18 - v17) / v25;
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a5, v26);
  v29 = Collection.count.getter(a5, WitnessTable);
  v30 = *((_BYTE *)v9 + 4);
  v45 = *v9;
  v46 = v30;
  v31 = WitnessTable;
  v32 = v29 - v27;
  v33 = Collection.count.getter(a5, v31);
  if (__OFADD__(v33, v32))
  {
    __break(1u);
LABEL_17:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xDDuLL, 0);
  }
  if (_UIntBuffer.capacity.getter(v33, v23, v24) < v33 + v32)
    goto LABEL_17;
  (*(void (**)(uint64_t, uint64_t))(v43 + 8))(v44, a3);
  v34 = v42;
  v35 = v42(v23, v24);
  if (!v35)
    goto LABEL_14;
  v36 = v35;
  v37 = v34(v23, v24);
  if (!v37)
    goto LABEL_14;
  v38 = v18 / v37;
  result = v34(v23, v24);
  *v9 = (*v9 >> ((result * v38 + 1) >> 1) >> ((result * v38) >> 1) << (result * (v38 + v32))) | (v41 << (result * (v17 / v36))) | ((1 << ((result * (v17 / v36) + 1) >> 1) << ((result * (v17 / v36)) >> 1)) - 1) & *v9;
  *((_BYTE *)v9 + 4) += result * v32;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.append(_:) in conformance _UIntBuffer<A>(_BYTE *a1, _QWORD *a2)
{
  int *v2;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;
  char v29;
  uint64_t v30;
  uint64_t WitnessTable;
  uint64_t v32;
  uint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  char v35;
  unint64_t v36;
  const char *v37;
  unint64_t AssociatedConformanceWitness;
  _BYTE *v39;
  _BYTE *v40;
  _BYTE *v41;
  void (*v42)(_BYTE *, uint64_t);
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  _BYTE *v50;
  _BYTE *v51;
  _BYTE *v52;
  _BYTE *v53;
  void (*v54)(_BYTE *, uint64_t);
  _BYTE *v55;
  unsigned int v56;
  _BYTE *v57;
  void (*v58)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v59;
  char v60;
  unsigned int v61;
  int v62;
  void (*v63)(_BYTE *, uint64_t);
  char v64;
  _BYTE *v65;
  _BYTE *v66;
  unint64_t v67;
  const char *v68;
  unint64_t v69;
  _BYTE *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  _BYTE *v72;
  _BYTE *v73;
  char v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  _BYTE *v81;
  unsigned int v82;
  _BYTE *v83;
  unsigned int v84;
  BOOL v85;
  void (*v86)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char v88;
  unsigned int v89;
  int v90;
  char v91;
  uint64_t result;
  _BYTE v93[12];
  unsigned int v94;
  void (*v95)(_BYTE *, _BYTE *, uint64_t);
  _BYTE *v96;
  _BYTE *v97;
  _BYTE *v98;
  _BYTE *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t (*v102)(uint64_t, uint64_t);
  _BYTE *v103;
  _BYTE *v104;
  unint64_t AssociatedTypeWitness;
  const char *v106;
  uint64_t (*v107)(uint64_t, uint64_t);
  _BYTE *v108;
  int v109;
  char v110;
  unsigned int v111;
  unsigned int v112;

  v4 = v2;
  v108 = a1;
  v5 = a2[2];
  v6 = a2[3];
  v7 = *(_QWORD *)(v6 + 8);
  v106 = *(const char **)(*(_QWORD *)(v7 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v106, v5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v8 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v104 = &v93[-v9];
  v10 = *(_BYTE **)(v5 - 8);
  v11 = MEMORY[0x1E0C80A78](v8);
  v96 = &v93[-((v12 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v13 = MEMORY[0x1E0C80A78](v11);
  v98 = &v93[-v14];
  v15 = MEMORY[0x1E0C80A78](v13);
  v99 = &v93[-v16];
  v17 = MEMORY[0x1E0C80A78](v15);
  v97 = &v93[-v18];
  v19 = MEMORY[0x1E0C80A78](v17);
  v103 = &v93[-v20];
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = &v93[-v22];
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = &v93[-v25];
  MEMORY[0x1E0C80A78](v24);
  v28 = &v93[-v27];
  v29 = *((_BYTE *)v2 + 4);
  v109 = *v2;
  v110 = v29;
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, v30);
  v32 = Collection.count.getter((uint64_t)a2, WitnessTable);
  if (__OFADD__(v32, 1))
  {
    __break(1u);
LABEL_37:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
  }
  v33 = a2[4];
  if (_UIntBuffer.capacity.getter(v32, v5, v6) < v32 + 1)
    goto LABEL_37;
  v100 = v33;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v5, v6);
  v34 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 64);
  v35 = v34(v5, v7);
  v101 = v6;
  v102 = v34;
  if ((v35 & 1) != 0)
  {
    (*((void (**)(_BYTE *, _BYTE *, uint64_t))v10 + 2))(v26, v28, v5);
    v36 = AssociatedTypeWitness;
    v37 = v106;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v106, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v39 = v10;
    v40 = v104;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v36, AssociatedConformanceWitness);
    v41 = v40;
    v10 = v39;
    (*((void (**)(_BYTE *, uint64_t, const char *))v37 + 3))(v41, v5, v37);
    LOBYTE(v36) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 32))(v26, v23, v5);
    v42 = (void (*)(_BYTE *, uint64_t))*((_QWORD *)v39 + 1);
    v42(v23, v5);
    if ((v36 & 1) == 0)
      goto LABEL_38;
    v42(v26, v5);
    v34 = v102;
  }
  v107 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 128);
  if (v107(v5, v7) >= 32)
  {
    v95 = (void (*)(_BYTE *, _BYTE *, uint64_t))*((_QWORD *)v10 + 2);
    v95(v103, v28, v5);
    v111 = -1;
    v43 = v34(v5, v7);
    v44 = v107(v5, v7);
    if ((v43 & 1) != 0)
    {
      if (v44 < 33)
      {
        v47 = AssociatedTypeWitness;
        v48 = v106;
        v49 = swift_getAssociatedConformanceWitness((uint64_t)v106, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v50 = v10;
        v51 = v104;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v49 + 8))(&unk_1816B7DA8, 256, v47, v49);
        v52 = v51;
        v10 = v50;
        (*((void (**)(_BYTE *, uint64_t, const char *))v48 + 3))(v52, v5, v48);
        v53 = v103;
        LOBYTE(v47) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8)
                                                                           + 40))(v103, v23, v5);
        v54 = (void (*)(_BYTE *, uint64_t))*((_QWORD *)v50 + 1);
        v54(v23, v5);
        v94 = v111;
        v55 = v97;
        v95(v97, v53, v5);
        if ((v47 & 1) != 0)
        {
          v56 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
          v54(v55, v5);
          v34 = v102;
          v57 = v103;
          if (v94 < v56)
            goto LABEL_32;
        }
        else
        {
          v54(v55, v5);
          v34 = v102;
          v57 = v103;
        }
LABEL_18:
        v54(v57, v5);
        goto LABEL_19;
      }
    }
    else if (v44 <= 32)
    {
      v57 = v103;
      v95(v23, v103, v5);
      v61 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 120))(v5, v7);
      v54 = (void (*)(_BYTE *, uint64_t))*((_QWORD *)v10 + 1);
      v54(v23, v5);
      if (v111 < v61)
        goto LABEL_32;
      goto LABEL_18;
    }
    v58 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    v59 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v44, v45, v46);
    v58(&v111, &type metadata for UInt32, v59, v5, v7);
    v57 = v103;
    v60 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 16))(v23, v103, v5);
    v54 = (void (*)(_BYTE *, uint64_t))*((_QWORD *)v10 + 1);
    v54(v23, v5);
    if ((v60 & 1) != 0)
      goto LABEL_32;
    goto LABEL_18;
  }
LABEL_19:
  v103 = *(_BYTE **)(v7 + 120);
  v62 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
  v63 = (void (*)(_BYTE *, uint64_t))*((_QWORD *)v10 + 1);
  v63(v28, v5);
  *v4 &= ~(v62 << *((_BYTE *)v4 + 4));
  v64 = v34(v5, v7);
  v65 = v108;
  if ((v64 & 1) == 0)
    goto LABEL_22;
  v97 = v10;
  v66 = v99;
  (*((void (**)(_BYTE *, _BYTE *, uint64_t))v10 + 2))(v99, v108, v5);
  v67 = AssociatedTypeWitness;
  v68 = v106;
  v69 = swift_getAssociatedConformanceWitness((uint64_t)v106, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v70 = v104;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v69 + 8))(&unk_1816B7DA8, 256, v67, v69);
  (*((void (**)(_BYTE *, uint64_t, const char *))v68 + 3))(v70, v5, v68);
  LOBYTE(v67) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 32))(v66, v23, v5);
  v63(v23, v5);
  if ((v67 & 1) == 0)
LABEL_38:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  v63(v66, v5);
  v10 = v97;
  v34 = v102;
LABEL_22:
  v71 = v107;
  if (v107(v5, v7) >= 32)
  {
    v72 = (_BYTE *)*((_QWORD *)v10 + 2);
    v73 = v98;
    v99 = v72;
    ((void (*)(_BYTE *, _BYTE *, uint64_t))v72)(v98, v65, v5);
    v112 = -1;
    v74 = v34(v5, v7);
    v75 = v71(v5, v7);
    if ((v74 & 1) != 0)
    {
      if (v75 < 33)
      {
        v78 = AssociatedTypeWitness;
        v79 = v106;
        v80 = swift_getAssociatedConformanceWitness((uint64_t)v106, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v81 = v104;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v80 + 8))(&unk_1816B7DA8, 256, v78, v80);
        (*((void (**)(_BYTE *, uint64_t, const char *))v79 + 3))(v81, v5, v79);
        LOBYTE(v78) = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8)
                                                                           + 40))(v73, v23, v5);
        v63(v23, v5);
        v82 = v112;
        v83 = v96;
        ((void (*)(_BYTE *, _BYTE *, uint64_t))v99)(v96, v73, v5);
        if ((v78 & 1) != 0)
        {
          v84 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
          v63(v83, v5);
          v85 = v82 >= v84;
          goto LABEL_31;
        }
        v63(v83, v5);
        v65 = v108;
LABEL_34:
        v63(v73, v5);
        goto LABEL_35;
      }
    }
    else if (v75 <= 32)
    {
      ((void (*)(_BYTE *, _BYTE *, uint64_t))v99)(v23, v73, v5);
      v89 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
      v63(v23, v5);
      v85 = v112 >= v89;
LABEL_31:
      v65 = v108;
      if (!v85)
        goto LABEL_32;
      goto LABEL_34;
    }
    v86 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v7 + 96);
    v87 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v75, v76, v77);
    v86(&v112, &type metadata for UInt32, v87, v5, v7);
    v88 = (*(uint64_t (**)(_BYTE *, _BYTE *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8) + 16))(v23, v73, v5);
    v63(v23, v5);
    v65 = v108;
    if ((v88 & 1) == 0)
      goto LABEL_34;
LABEL_32:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  }
LABEL_35:
  v90 = ((uint64_t (*)(uint64_t, uint64_t))v103)(v5, v7);
  v63(v65, v5);
  v91 = *((_BYTE *)v4 + 4);
  *v4 |= v90 << v91;
  result = specialized _UIntBuffer._elementWidth.getter(v5, v101);
  *((_BYTE *)v4 + 4) = result + v91;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.removeFirst() in conformance _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  unsigned int *v5;
  uint64_t WitnessTable;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v14)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v15;
  char v16;
  uint64_t (*v17)(uint64_t, uint64_t);
  uint64_t result;
  unsigned int v19;

  v5 = v3;
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a1, a3);
  v7 = Collection.isEmpty.getter(a1, WitnessTable);
  if ((v7 & 1) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xC8uLL, 0);
  v19 = *v3;
  v10 = v19;
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(_QWORD *)(a1 + 24);
  v13 = *(_QWORD *)(v12 + 8);
  v14 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v13 + 96);
  v15 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v7, v8, v9);
  v14(&v19, &type metadata for UInt32, v15, v11, v13);
  v16 = *((_BYTE *)v5 + 4);
  v17 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 56);
  *((_BYTE *)v5 + 4) = v16 - v17(v11, v12);
  result = v17(v11, v12);
  *v5 = v10 >> ((result + 1) >> 1) >> (result >> 1);
  return result;
}

uint64_t static _UnicodeEncoding.transcode<A>(_:from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return static _UnicodeEncoding.transcode<A>(_:from:)(a1, a2, a5, a3, a6, a4);
}

{
  uint64_t v8;

  v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a6 + 88))(a1, a4, a6);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 96))(v8, a3, a5);
}

uint64_t specialized static _UnicodeEncoding.transcode<A>(_:from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a4 + 88))(a1, a3, a4);
}

uint64_t static _UnicodeEncoding._isScalar(_:)()
{
  return 0;
}

uint64_t static _UnicodeEncoding._encode(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v20;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a3, a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  v11 = type metadata accessor for Optional(0, AssociatedTypeWitness, v9, v10);
  v12 = *(_QWORD *)(v11 - 8);
  v13 = MEMORY[0x1E0C80A78](v11);
  v15 = (char *)&v20 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v20 - v16;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 96))(a1, a2, a3);
  (*(void (**)(char *, char *, uint64_t))(v12 + 32))(v15, v17, v11);
  v18 = *(_QWORD *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v18 + 48))(v15, 1, AssociatedTypeWitness) != 1)
    return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v18 + 32))(a4, v15, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(a3 + 80))(a2, a3);
  return (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v15, v11);
}

uint64_t static _UnicodeEncoding._transcode<A>(_:from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;

  v22 = a5;
  v23 = a6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  v13 = type metadata accessor for Optional(0, AssociatedTypeWitness, v11, v12);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v22 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v22 - v18;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 104))(a1, a3, a3, v22, a2, a4);
  (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v17, v19, v13);
  v20 = *(_QWORD *)(AssociatedTypeWitness - 8);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v20 + 48))(v17, 1, AssociatedTypeWitness) != 1)
    return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v20 + 32))(v23, v17, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(a4 + 80))(a2, a4);
  return (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v17, v13);
}

uint64_t static _UnicodeEncoding._transcode<A, B>(_:from:into:)(void (*a1)(char *, uint64_t, unint64_t, unint64_t, unint64_t), uint64_t a2, void (*a3)(char *), uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, const char *a8, const char *a9, const char *a10)
{
  const char *v10;
  unint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  void (*v40)(unint64_t, unint64_t);
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  int EnumCaseMultiPayload;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, uint64_t, uint64_t, const char *, uint64_t, const char *);
  const char *v55;
  char *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v61;
  const char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 *v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  char *v75;
  const char *v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  void (*v80)(char *);
  uint64_t v81;
  unint64_t v82;
  void (*v83)(char *, uint64_t, unint64_t, unint64_t, unint64_t);
  unint64_t v84;
  unint64_t AssociatedConformanceWitness;
  char *v86;
  unint64_t v87;
  uint64_t v88;

  v10 = a8;
  v81 = a4;
  v82 = a6;
  v80 = a3;
  v83 = a1;
  v62 = a9;
  v88 = a5;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a8, a5, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  v84 = AssociatedTypeWitness;
  v15 = type metadata accessor for Optional(0, AssociatedTypeWitness, v13, v14);
  v16 = *(_QWORD *)(v15 - 8);
  v17 = MEMORY[0x1E0C80A78](v15);
  v75 = (char *)&v61 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v74 = (char *)&v61 - v20;
  v21 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v22 = MEMORY[0x1E0C80A78](v19);
  v73 = (char *)&v61 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v72 = (char *)&v61 - v24;
  v25 = swift_getAssociatedTypeWitness(0, a10, a7, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  v70 = *(_QWORD *)(v25 - 8);
  MEMORY[0x1E0C80A78](v25);
  v69 = (char *)&v61 - v26;
  v71 = v27;
  v30 = type metadata accessor for Unicode.ParseResult(0, v27, v28, v29);
  v31 = MEMORY[0x1E0C80A78](v30);
  v33 = (unsigned __int8 *)&v61 - v32;
  v64 = *(_QWORD *)(v82 - 8);
  MEMORY[0x1E0C80A78](v31);
  v63 = (char *)&v61 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
  v78 = swift_getAssociatedTypeWitness(0, a9, v35, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v66 = *(_QWORD *)(v78 - 8);
  MEMORY[0x1E0C80A78](v78);
  v79 = (char *)&v61 - v36;
  v37 = swift_getAssociatedTypeWitness(0, a10, a7, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.ForwardParser);
  v65 = *(_QWORD *)(v37 - 8);
  MEMORY[0x1E0C80A78](v37);
  v39 = (char *)&v61 - v38;
  v76 = a10;
  v77 = a7;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a10, a7, v37, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  v86 = v39;
  v40 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  v87 = v37;
  v40(v37, AssociatedConformanceWitness);
  v41 = v84;
  v42 = v82;
  (*(void (**)(char *, void (*)(char *, uint64_t, unint64_t, unint64_t, unint64_t), unint64_t))(v64 + 16))(v63, v83, v82);
  v43 = v78;
  v44 = v42;
  v45 = (uint64_t)v62;
  (*((void (**)(unint64_t))v62 + 4))(v44);
  v83 = *(void (**)(char *, uint64_t, unint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 32);
  v46 = v45;
  v47 = v79;
  v82 = swift_getAssociatedConformanceWitness(v46, v82, v43, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v68 = v30;
  v67 = v33;
  while (1)
  {
    v83(v47, v43, v82, v87, AssociatedConformanceWitness);
    EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v33, v30);
    if (EnumCaseMultiPayload)
      break;
    v52 = v69;
    v51 = v70;
    v53 = v71;
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(v70 + 32))(v69, v33, v71);
    v54 = (void (*)(char *, uint64_t, uint64_t, const char *, uint64_t, const char *))*((_QWORD *)v10 + 13);
    v55 = v10;
    v56 = v74;
    v54(v52, v77, v77, v76, v88, v55);
    (*(void (**)(char *, uint64_t))(v51 + 8))(v52, v53);
    v57 = v75;
    v58 = v56;
    v59 = v41;
    (*(void (**)(char *, char *, uint64_t))(v16 + 32))(v75, v58, v15);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v21 + 48))(v57, 1, v41) == 1)
    {
      v48 = v72;
      (*((void (**)(uint64_t, const char *))v55 + 10))(v88, v55);
      (*(void (**)(char *, uint64_t))(v16 + 8))(v57, v15);
    }
    else
    {
      v48 = v72;
      (*(void (**)(char *, char *, unint64_t))(v21 + 32))(v72, v57, v59);
    }
    v10 = v55;
    v30 = v68;
    v33 = v67;
    v43 = v78;
    v47 = v79;
LABEL_4:
    v80(v48);
    v49 = v48;
    v41 = v84;
    (*(void (**)(char *, unint64_t))(v21 + 8))(v49, v84);
  }
  if (EnumCaseMultiPayload == 1)
  {
    v48 = v73;
    (*((void (**)(uint64_t, const char *))v10 + 10))(v88, v10);
    goto LABEL_4;
  }
  (*(void (**)(char *, uint64_t))(v66 + 8))(v47, v43);
  return (*(uint64_t (**)(char *, unint64_t))(v65 + 8))(v86, v87);
}

unint64_t Unicode._GraphemeBreakProperty.init(from:)(unsigned int a1)
{
  uint64_t v2;
  unsigned int GraphemeBreakProperty;
  unint64_t v4;

  if (a1 < 0x20)
    return 1;
  if (a1 < 0x7F)
    return 0;
  if (a1 == 8205)
    return 12;
  v2 = 4;
  if (a1 - 4448 > 0xFFFFFF9F)
    return v2;
  if (a1 - 43389 > 0xFFFFFFE2)
    return v2;
  v2 = 11;
  if (a1 - 4520 > 0xFFFFFFB7)
    return v2;
  if (a1 - 55239 > 0xFFFFFFE8)
    return v2;
  v2 = 10;
  if (a1 - 4608 > 0xFFFFFFA7 || a1 - 55292 > 0xFFFFFFCE)
    return v2;
  if (a1 - 55204 >= 0xFFFFD45C)
  {
    HIDWORD(v4) = -1227133513 * ((unsigned __int16)a1 - 16);
    LODWORD(v4) = HIDWORD(v4);
    if ((v4 >> 2) < 0x9249249)
      return 5;
    else
      return 6;
  }
  else if (a1 - 127488 > 0xFFFFFFE5)
  {
    return 8;
  }
  else
  {
    if (a1 - 131070 <= 0xFFFFFC01)
    {
      if (a1 - 921600 <= 0xFFFFF1EF)
      {
        GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(a1);
        if (GraphemeBreakProperty <= 5)
          return 0x30309070201uLL >> (8 * GraphemeBreakProperty);
        return 0;
      }
      return 1;
    }
    return 3;
  }
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:)(Swift::UInt8 a1)
{
  Swift::Unicode::Scalar result;

  *(_DWORD *)&a1 = a1;
  LOBYTE(result._value) = a1;
  return result;
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:)(Swift::UInt8 a1, Swift::UInt8 a2)
{
  return (Swift::Unicode::Scalar)(a2 & 0x3F | ((a1 & 0x1F) << 6));
}

Swift::UInt32 __swiftcall _continuationPayload(_:)(Swift::UInt8 a1)
{
  return a1 & 0x3F;
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:_:)(Swift::UInt8 a1, Swift::UInt8 a2, Swift::UInt8 a3)
{
  return (Swift::Unicode::Scalar)(((a1 & 0xF) << 12) | ((a2 & 0x3F) << 6) | a3 & 0x3F);
}

Swift::Unicode::Scalar __swiftcall _decodeUTF8(_:_:_:_:)(Swift::UInt8 a1, Swift::UInt8 a2, Swift::UInt8 a3, Swift::UInt8 a4)
{
  return (Swift::Unicode::Scalar)(((a1 & 0xF) << 18) | ((a2 & 0x3F) << 12) | ((a3 & 0x3F) << 6) | a4 & 0x3F);
}

Swift::String::Index __swiftcall _StringGuts.scalarAlignSlow(_:)(Swift::String::Index result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  Swift::UInt64 v5;
  _BYTE *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  Swift::UInt64 v10;
  int v11;
  Swift::UInt64 v12;
  _QWORD v13[4];

  if ((result._rawBits & 0xC000) != 0)
    return (Swift::String::Index)(result._rawBits & 0xFFFFFFFFFFFF0000);
  v5 = result._rawBits >> 16;
  if (!(result._rawBits >> 16))
    return (Swift::String::Index)(result._rawBits & 0xFFFFFFFFFFFF0000);
  if ((v2 & 0x1000000000000000) == 0)
  {
    v13[2] = v3;
    v13[3] = v4;
    if ((v2 & 0x2000000000000000) != 0)
    {
      v13[0] = v1;
      v13[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (v5 != (HIBYTE(v2) & 0xF) && (*((_BYTE *)v13 + v5) & 0xC0) == 0x80)
      {
        do
        {
          v10 = v5 - 1;
          v11 = *((_BYTE *)&v12 + v5-- + 7) & 0xC0;
        }
        while (v11 == 128);
        v5 = v10;
      }
      return (Swift::String::Index)(v5 << 16);
    }
    if ((v1 & 0x1000000000000000) != 0)
    {
      v6 = (_BYTE *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (v5 != (v1 & 0xFFFFFFFFFFFFLL))
      {
        do
LABEL_8:
          v7 = v6[v5--] & 0xC0;
        while (v7 == 128);
        ++v5;
      }
    }
    else
    {
      v12 = result._rawBits >> 16;
      v6 = _StringObject.sharedUTF8.getter(v1, v2);
      v5 = v12;
      if (v12 != v9)
        goto LABEL_8;
    }
    return (Swift::String::Index)(v5 << 16);
  }
  v8 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000) == 0)
    v8 = v1 & 0xFFFFFFFFFFFFLL;
  if (v5 != v8)
    return _StringGuts.foreignScalarAlign(_:)(result);
  return result;
}

Swift::String::Index __swiftcall _StringGuts.foreignScalarAlign(_:)(Swift::String::Index a1)
{
  uint64_t v1;
  unint64_t v2;
  Swift::UInt64 rawBits;
  uint64_t v4;

  rawBits = a1._rawBits;
  v4 = HIBYTE(v2) & 0xF;
  if ((v2 & 0x2000000000000000) == 0)
    v4 = v1 & 0xFFFFFFFFFFFFLL;
  if (v4 != a1._rawBits >> 16 && _StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:)(a1) >> 10 == 55)
    rawBits = (rawBits & 0xFFFFFFFFFFFF0000) - 0x10000;
  return (Swift::String::Index)(rawBits | 1);
}

uint64_t closure #1 in _StringGuts.fastUTF8ScalarLength(endingAt:)@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;

  v4 = 1;
  v5 = a3 - 1;
  while (1)
  {
    if (v5 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
    if (a3 - 1 >= a2)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
    if ((*(_BYTE *)(result + v5) & 0xC0) != 0x80)
      break;
    --v5;
    if (__OFADD__(v4++, 1))
    {
      __break(1u);
      break;
    }
  }
  *a4 = v4;
  return result;
}

uint64_t static Unicode.UTF16._decodeSurrogates(_:_:)(__int16 a1, __int16 a2)
{
  return (a2 & 0x3FF | ((unsigned __int16)(a1 & 0x3FF) << 10)) + 0x10000;
}

uint64_t static Unicode.UTF16._replacementCodeUnit.getter()
{
  return 65533;
}

Swift::String __swiftcall _StringGuts.foreignErrorCorrectedGrapheme(startingAt:endingAt:)(Swift::Int startingAt, Swift::Int endingAt)
{
  uint64_t v2;
  char v3;
  uint64_t v4;
  Swift::Int v5;
  int64_t v6;
  BOOL v7;
  Swift::UInt32 value;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  Swift::String::Index v16;
  Swift::UInt64 rawBits;
  unint64_t v18;
  unint64_t v19;
  Swift::Int v20;
  uint64_t v21;
  char *v22;
  uint8x16_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  Swift::String::Index v33;
  Swift::UInt64 v34;
  void *v35;
  void *v36;
  uint8x16_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  Swift::String::Index v47;
  Swift::UInt64 v48;
  uint64_t v49;
  void *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  Swift::String result;
  uint64_t v57[2];

  v4 = v2;
  v5 = startingAt;
  v57[1] = *MEMORY[0x1E0C80C00];
  v6 = endingAt - startingAt;
  v7 = __OFSUB__(endingAt, startingAt);
  if (startingAt - endingAt == 1)
  {
    value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(startingAt << 16))._0._value;
    v9 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(value);
    if ((v10 & 0x2000000000000000) != 0)
      v13 = HIBYTE(v10) & 0xF;
    else
      v13 = v9 & 0xFFFFFFFFFFFFLL;
    if (!v13)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from an empty String", 43, 2, "Swift/Character.swift", 21, 2, 0xAFuLL, 0);
    v14 = v9;
    v15 = v10;
    swift_bridgeObjectRetain(v10, v10, v11, v12);
    v16._rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15)._rawBits;
    rawBits = String._uncheckedIndex(after:)(v16)._rawBits;
    swift_bridgeObjectRelease(v15);
    if (rawBits >> 14 == 4 * v13)
    {
      if (!(v15 & 0x2000000000000000 | v14 & 0x1000000000000000))
      {
        v14 = specialized static String._copying(_:)(v14, v15);
        v19 = v18;
        swift_bridgeObjectRelease(v15);
        v15 = v19;
      }
      goto LABEL_35;
    }
LABEL_36:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from a String containing more than one extended grapheme cluster", 87, 2, "Swift/Character.swift", 21, 2, 0xB1uLL, 0);
  }
  if (v6 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Allocation capacity must be greater than or equal to zero", 57, 2, "Swift/TemporaryAllocation.swift", 31, 2, 0x29uLL, 0);
  if (v6 + 0x4000000000000000 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Allocation byte count too large", 31, 2, "Swift/TemporaryAllocation.swift", 31, 2, 0x2EuLL, 0);
  v20 = endingAt;
  if (2 * v6 <= 1024 || (startingAt = swift_stdlib_isStackAllocationSafe(), (startingAt & 1) != 0))
  {
    MEMORY[0x1E0C80A78](startingAt);
    v22 = (char *)v57 - v21;
    if (v5 <= v20)
    {
      if (v7)
      {
        __break(1u);
      }
      else
      {
        objc_msgSend((id)(v4 & 0xFFFFFFFFFFFFFFFLL), sel_getCharacters_range_, v22, v5, v6);
        v57[0] = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v6, 0, (uint64_t)&_swiftEmptyArrayStorage);
        specialized transcode<A, B, C>(_:from:to:stoppingOnError:into:)((uint64_t)v22, (uint64_t)&v22[2 * v6], 0, v57);
        v23 = (uint8x16_t *)v57[0];
        v24 = *(_QWORD *)(v57[0] + 16);
        swift_bridgeObjectRetain(v57[0], v25, v26, v27);
        v14 = specialized static String._uncheckedFromUTF8(_:)(v23 + 2, v24);
        v15 = v28;
        LOBYTE(v20) = 2;
        swift_bridgeObjectRelease_n((uint64_t)v23, 2);
        if ((v15 & 0x2000000000000000) != 0)
          v32 = HIBYTE(v15) & 0xF;
        else
          v32 = v14 & 0xFFFFFFFFFFFFLL;
        if (v32)
        {
          swift_bridgeObjectRetain(v15, v29, v30, v31);
          v33._rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15)._rawBits;
          v34 = String._uncheckedIndex(after:)(v33)._rawBits;
          swift_bridgeObjectRelease(v15);
          if (v34 >> 14 != 4 * v32)
            goto LABEL_36;
          if (!(v15 & 0x2000000000000000 | v14 & 0x1000000000000000))
          {
            v14 = specialized static String._copying(_:)(v14, v15);
            v52 = v51;
            swift_bridgeObjectRelease(v15);
            v15 = v52;
          }
          goto LABEL_35;
        }
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from an empty String", 43, 2, "Swift/Character.swift", 21, v20, 0xAFuLL, 0);
    }
LABEL_38:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  v35 = swift_slowAlloc(2 * v6, 0xFFFFFFFFFFFFFFFFLL);
  if (v5 > v20)
    goto LABEL_38;
  if (v7)
  {
    __break(1u);
    goto LABEL_45;
  }
  v36 = v35;
  objc_msgSend((id)(v4 & 0xFFFFFFFFFFFFFFFLL), sel_getCharacters_range_, v35, v5, v6);
  v57[0] = (uint64_t)specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v6, 0, (uint64_t)&_swiftEmptyArrayStorage);
  specialized transcode<A, B, C>(_:from:to:stoppingOnError:into:)((uint64_t)v36, (uint64_t)v36 + 2 * v6, 0, v57);
  v37 = (uint8x16_t *)v57[0];
  v38 = *(_QWORD *)(v57[0] + 16);
  swift_bridgeObjectRetain(v57[0], v39, v40, v41);
  v14 = specialized static String._uncheckedFromUTF8(_:)(v37 + 2, v38);
  v15 = v42;
  v3 = 2;
  swift_bridgeObjectRelease_n((uint64_t)v37, 2);
  if ((v15 & 0x2000000000000000) != 0)
    v46 = HIBYTE(v15) & 0xF;
  else
    v46 = v14 & 0xFFFFFFFFFFFFLL;
  if (!v46)
LABEL_45:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't form a Character from an empty String", 43, 2, "Swift/Character.swift", 21, v3, 0xAFuLL, 0);
  swift_bridgeObjectRetain(v15, v43, v44, v45);
  v47._rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)15)._rawBits;
  v48 = String._uncheckedIndex(after:)(v47)._rawBits;
  swift_bridgeObjectRelease(v15);
  if (v48 >> 14 != 4 * v46)
    goto LABEL_36;
  if (!(v15 & 0x2000000000000000 | v14 & 0x1000000000000000))
  {
    v14 = specialized static String._copying(_:)(v14, v15);
    v54 = v53;
    swift_bridgeObjectRelease(v15);
    v15 = v54;
  }
  swift_slowDealloc(v36);
LABEL_35:
  v49 = v14;
  v50 = (void *)v15;
  result._object = v50;
  result._countAndFlagsBits = v49;
  return result;
}

uint64_t Unicode.ParseResult._valid.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = *(_QWORD *)(a1 - 8);
  MEMORY[0x1E0C80A78](a1);
  v6 = (unsigned __int8 *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *))(v4 + 16))(v6);
  if (swift_getEnumCaseMultiPayload(v6, a1))
  {
    (*(void (**)(unsigned __int8 *, uint64_t))(v4 + 8))(v6, a1);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 16) - 8) + 56))(a2, 1, 1, *(_QWORD *)(a1 + 16));
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(_QWORD *)(v8 - 8);
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(v9 + 32))(a2, v6, v8);
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v9 + 56))(a2, 0, 1, v8);
  }
}

uint64_t Unicode.ParseResult._error.getter(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 - 8);
  MEMORY[0x1E0C80A78](a1);
  v4 = (unsigned __int8 *)&v6 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *))(v2 + 16))(v4);
  if (swift_getEnumCaseMultiPayload(v4, a1) == 1)
    return *(_QWORD *)v4;
  (*(void (**)(unsigned __int8 *, uint64_t))(v2 + 8))(v4, a1);
  return 0;
}

uint64_t Unicode.Scalar.Properties._scalar.getter()
{
  unsigned int *v0;

  return *v0;
}

uint64_t (*Unicode.Scalar.Properties._scalar.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t Unicode.Scalar.Properties.isAlphabetic.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 7) & 1;
}

unint64_t Unicode.Scalar.Properties.isASCIIHexDigit.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 6) & 1;
}

unint64_t Unicode.Scalar.Properties.isBidiControl.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 8) & 1;
}

unint64_t Unicode.Scalar.Properties.isBidiMirrored.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 9) & 1;
}

unint64_t Unicode.Scalar.Properties.isDash.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 12) & 1;
}

unint64_t Unicode.Scalar.Properties.isDefaultIgnorableCodePoint.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 13) & 1;
}

unint64_t Unicode.Scalar.Properties.isDeprecated.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 14) & 1;
}

unint64_t Unicode.Scalar.Properties.isDiacritic.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 15) & 1;
}

unint64_t Unicode.Scalar.Properties.isExtender.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 20) & 1;
}

unint64_t Unicode.Scalar.Properties.isFullCompositionExclusion.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 21) & 1;
}

unint64_t Unicode.Scalar.Properties.isGraphemeBase.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 22) & 1;
}

unint64_t Unicode.Scalar.Properties.isGraphemeExtend.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 23) & 1;
}

unint64_t Unicode.Scalar.Properties.isHexDigit.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 24) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDContinue.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 25) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDStart.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 28) & 1;
}

unint64_t Unicode.Scalar.Properties.isIdeographic.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 29) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDSBinaryOperator.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 26) & 1;
}

unint64_t Unicode.Scalar.Properties.isIDSTrinaryOperator.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 27) & 1;
}

unint64_t Unicode.Scalar.Properties.isJoinControl.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 30) & 1;
}

unint64_t Unicode.Scalar.Properties.isLogicalOrderException.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 31) & 1;
}

unint64_t Unicode.Scalar.Properties.isLowercase.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 32) & 1;
}

unint64_t Unicode.Scalar.Properties.isMath.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 33) & 1;
}

unint64_t Unicode.Scalar.Properties.isNoncharacterCodePoint.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 34) & 1;
}

unint64_t Unicode.Scalar.Properties.isQuotationMark.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 37) & 1;
}

unint64_t Unicode.Scalar.Properties.isRadical.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 38) & 1;
}

unint64_t Unicode.Scalar.Properties.isSoftDotted.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 40) & 1;
}

unint64_t Unicode.Scalar.Properties.isTerminalPunctuation.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 41) & 1;
}

unint64_t Unicode.Scalar.Properties.isUnifiedIdeograph.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 42) & 1;
}

unint64_t Unicode.Scalar.Properties.isUppercase.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 43) & 1;
}

unint64_t Unicode.Scalar.Properties.isWhitespace.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 45) & 1;
}

unint64_t Unicode.Scalar.Properties.isXIDContinue.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 46) & 1;
}

unint64_t Unicode.Scalar.Properties.isXIDStart.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 47) & 1;
}

unint64_t Unicode.Scalar.Properties.isSentenceTerminal.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 39) & 1;
}

unint64_t Unicode.Scalar.Properties.isVariationSelector.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 44) & 1;
}

unint64_t Unicode.Scalar.Properties.isPatternSyntax.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 35) & 1;
}

unint64_t Unicode.Scalar.Properties.isPatternWhitespace.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 36) & 1;
}

unint64_t Unicode.Scalar.Properties.isCased.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 11) & 1;
}

unint64_t Unicode.Scalar.Properties.isCaseIgnorable.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 10) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenLowercased.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 2) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenUppercased.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 5) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenTitlecased.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 4) & 1;
}

uint64_t Unicode.Scalar.Properties.changesWhenCaseFolded.getter()
{
  unsigned int *v0;

  return _swift_stdlib_getBinaryProperties(*v0) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenCaseMapped.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 1) & 1;
}

unint64_t Unicode.Scalar.Properties.changesWhenNFKCCaseFolded.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 3) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmoji.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 16) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiPresentation.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 19) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiModifier.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 17) & 1;
}

unint64_t Unicode.Scalar.Properties.isEmojiModifierBase.getter()
{
  unsigned int *v0;

  return ((unint64_t)_swift_stdlib_getBinaryProperties(*v0) >> 18) & 1;
}

uint64_t Unicode.Scalar.Properties._getMapping(_:)(unsigned __int8 a1)
{
  unsigned int *v1;
  uint64_t v2;
  int v3;
  uint8x16_t *SpecialMapping;
  int Mapping;
  uint64_t v7;
  uint64_t v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = *v1;
  v8[0] = 0;
  v3 = a1;
  SpecialMapping = (uint8x16_t *)_swift_stdlib_getSpecialMapping(v2, a1, v8);
  if (SpecialMapping && v8[0])
  {
    if (v8[0] < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(SpecialMapping, v8[0], 0);
  }
  else
  {
    Mapping = _swift_stdlib_getMapping(v2, v3);
    if (Mapping)
    {
      v7 = v2 + Mapping;
      if (v7 < 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
      if (HIDWORD(v7))
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    }
    else
    {
      LODWORD(v7) = v2;
    }
    return specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v7);
  }
}

uint64_t Unicode.Scalar.Properties.titlecaseMapping.getter()
{
  return Unicode.Scalar.Properties._getMapping(_:)(2u);
}

uint64_t Unicode.Scalar.Properties.age.getter()
{
  unsigned int *v0;
  uint64_t result;

  LODWORD(result) = _swift_stdlib_getAge(*v0);
  if ((_DWORD)result == 0xFFFF)
    return 0;
  else
    return result;
}

Swift::Unicode::GeneralCategory __swiftcall Unicode.GeneralCategory.init(rawValue:)(Swift::Unicode::GeneralCategory rawValue)
{
  Swift::Unicode::GeneralCategory *v1;
  Swift::Unicode::GeneralCategory v2;
  unint64_t countAndFlagsBits;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t object;
  unint64_t v9;
  unint64_t v10;
  char v11;
  unint64_t v12;
  Swift::String v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  void *v19;
  char v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  char *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  Swift::String v29;

  if (rawValue >= Swift_Unicode_GeneralCategory_unknownDefault)
  {
    v2 = rawValue;
    countAndFlagsBits = 0xD000000000000019;
    v4 = specialized static String._createEmpty(withInitialCapacity:)(27);
    v6 = v5;
    v29._countAndFlagsBits = v4;
    v29._object = (void *)v5;
    v7 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000) == 0)
      v7 = v4 & 0xFFFFFFFFFFFFLL;
    if (v7 || (v4 & ~v5 & 0x2000000000000000) != 0)
    {
      if ((v5 & 0x2000000000000000) == 0
        || (0x8000000181766FE0 & 0x2000000000000000) == 0
        || (v9 = specialized _SmallString.init(_:appending:)(v4, v5, 0xD000000000000019, 0x8000000181766FE0 | 0x8000000000000000), (v11 & 1) != 0))
      {
        if ((0x8000000181766FE0 & 0x2000000000000000) != 0)
          v12 = (0x8000000181766FE0 >> 56) & 0xF;
        else
          v12 = 25;
        _StringGuts.append(_:)(0xD000000000000019, 0x8000000181766FE0 | 0x8000000000000000, 0, v12);
        swift_bridgeObjectRelease(0x8000000181766FE0 | 0x8000000000000000);
        object = (unint64_t)v29._object;
        countAndFlagsBits = v29._countAndFlagsBits;
LABEL_17:
        v13 = _uint64ToString(_:radix:uppercase:)(v2, 10, 0);
        v14 = v13._countAndFlagsBits;
        v15 = (unint64_t)v13._object;
        v16 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000) == 0)
          v16 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (!v16 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(object);
          v29 = v13;
          goto LABEL_31;
        }
        if ((object & 0x2000000000000000) != 0)
        {
          if (((uint64_t)v13._object & 0x2000000000000000) != 0)
          {
            v18 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v13._countAndFlagsBits, (unint64_t)v13._object);
            if ((v20 & 1) == 0)
            {
              v21 = v18;
              v22 = v19;
              swift_bridgeObjectRelease(object);
              swift_bridgeObjectRelease((uint64_t)v13._object);
              v29._countAndFlagsBits = v21;
              v29._object = v22;
              v15 = (unint64_t)v22;
              v14 = v21;
              goto LABEL_31;
            }
            goto LABEL_29;
          }
        }
        else if (((uint64_t)v13._object & 0x2000000000000000) != 0)
        {
LABEL_29:
          v17 = ((unint64_t)v13._object >> 56) & 0xF;
          goto LABEL_30;
        }
        v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_30:
        _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
        swift_bridgeObjectRelease((uint64_t)v13._object);
        v15 = (unint64_t)v29._object;
        v14 = v29._countAndFlagsBits;
LABEL_31:
        v23 = HIBYTE(v15) & 0xF;
        if ((v15 & 0x2000000000000000) == 0)
          v23 = v14 & 0xFFFFFFFFFFFFLL;
        if (v23 || (v14 & ~v15 & 0x2000000000000000) != 0)
        {
          if ((v15 & 0x2000000000000000) == 0
            || (v26 = specialized _SmallString.init(_:appending:)(v14, v15, 0, 0xE000000000000000), (v28 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            v25 = (unint64_t)v29._object;
            v24 = (char *)v29._countAndFlagsBits;
          }
          else
          {
            v24 = (char *)v26;
            v25 = v27;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(0xE000000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v15);
          v24 = 0;
          v25 = 0xE000000000000000;
        }
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v24, v25, "Swift/UnicodeScalarProperties.swift", 35, 2, 0x45EuLL, 0);
      }
      countAndFlagsBits = v9;
      object = v10;
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x8000000181766FE0 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v5);
      object = 0x8000000181766FE0 | 0x8000000000000000;
    }
    v29._countAndFlagsBits = countAndFlagsBits;
    v29._object = (void *)object;
    goto LABEL_17;
  }
  *v1 = rawValue;
  return rawValue;
}

uint64_t Unicode.Scalar.Properties.generalCategory.getter()
{
  unsigned int *v0;
  Swift::UInt8 GeneralCategory;

  GeneralCategory = _swift_stdlib_getGeneralCategory(*v0);
  return Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
}

Swift::String __swiftcall Unicode.Scalar.Properties._hangulName()()
{
  int *v0;
  uint64_t v1;
  _QWORD *inited;
  _QWORD *v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  void *v55;
  Swift::String result;
  int v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60[46];
  uint64_t v61[43];

  v57 = *v0;
  v1 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>();
  inited = swift_initStackObject(v1, v61);
  *((_OWORD *)inited + 1) = xmmword_1816ABE10;
  inited[4] = 71;
  inited[5] = 0xE100000000000000;
  inited[6] = 18247;
  inited[7] = 0xE200000000000000;
  inited[8] = 78;
  inited[9] = 0xE100000000000000;
  inited[10] = 68;
  inited[11] = 0xE100000000000000;
  inited[12] = 17476;
  inited[13] = 0xE200000000000000;
  inited[14] = 82;
  inited[15] = 0xE100000000000000;
  inited[16] = 77;
  inited[17] = 0xE100000000000000;
  inited[18] = 66;
  inited[19] = 0xE100000000000000;
  inited[20] = 16962;
  inited[21] = 0xE200000000000000;
  inited[22] = 83;
  inited[23] = 0xE100000000000000;
  inited[24] = 21331;
  inited[25] = 0xE200000000000000;
  inited[26] = 0;
  inited[27] = 0xE000000000000000;
  inited[28] = 74;
  inited[29] = 0xE100000000000000;
  inited[30] = 19018;
  inited[31] = 0xE200000000000000;
  inited[32] = 67;
  inited[33] = 0xE100000000000000;
  inited[34] = 75;
  inited[35] = 0xE100000000000000;
  inited[36] = 84;
  inited[37] = 0xE100000000000000;
  inited[38] = 80;
  inited[39] = 0xE100000000000000;
  inited[40] = 72;
  inited[41] = 0xE100000000000000;
  v3 = swift_initStackObject(v1, v60);
  *((_OWORD *)v3 + 1) = xmmword_1816ABE20;
  v3[4] = 65;
  v3[5] = 0xE100000000000000;
  v3[6] = 17729;
  v3[7] = 0xE200000000000000;
  v3[8] = 16729;
  v3[9] = 0xE200000000000000;
  v3[10] = 4538713;
  v3[11] = 0xE300000000000000;
  v3[12] = 20293;
  v3[13] = 0xE200000000000000;
  v3[14] = 69;
  v3[15] = 0xE100000000000000;
  v3[16] = 5195097;
  v3[17] = 0xE300000000000000;
  v3[18] = 17753;
  v3[19] = 0xE200000000000000;
  v3[20] = 79;
  v3[21] = 0xE100000000000000;
  v3[22] = 16727;
  v3[23] = 0xE200000000000000;
  v3[24] = 4538711;
  v3[25] = 0xE300000000000000;
  v3[26] = 17743;
  v3[27] = 0xE200000000000000;
  v3[28] = 20313;
  v3[29] = 0xE200000000000000;
  v3[30] = 85;
  v3[31] = 0xE100000000000000;
  v3[32] = 5195095;
  v3[33] = 0xE300000000000000;
  v3[34] = 17751;
  v3[35] = 0xE200000000000000;
  v3[36] = 18775;
  v3[37] = 0xE200000000000000;
  v3[38] = 21849;
  v3[39] = 0xE200000000000000;
  v3[40] = 21829;
  v3[41] = 0xE200000000000000;
  v3[42] = 18777;
  v3[43] = 0xE200000000000000;
  v3[44] = 73;
  v3[45] = 0xE100000000000000;
  v4 = swift_allocObject(v1, 0x1E0uLL, 7uLL);
  *((_OWORD *)v4 + 1) = xmmword_1816ABE30;
  v4[4] = 0;
  v4[5] = 0xE000000000000000;
  v4[6] = 71;
  v4[7] = 0xE100000000000000;
  v4[8] = 18247;
  v4[9] = 0xE200000000000000;
  v4[10] = 21319;
  v4[11] = 0xE200000000000000;
  v4[12] = 78;
  v4[13] = 0xE100000000000000;
  v4[14] = 19022;
  v4[15] = 0xE200000000000000;
  v4[16] = 18510;
  v4[17] = 0xE200000000000000;
  v4[18] = 68;
  v4[19] = 0xE100000000000000;
  v4[20] = 76;
  v4[21] = 0xE100000000000000;
  v4[22] = 18252;
  v4[23] = 0xE200000000000000;
  v4[24] = 19788;
  v4[25] = 0xE200000000000000;
  v4[26] = 16972;
  v4[27] = 0xE200000000000000;
  v4[28] = 21324;
  v4[29] = 0xE200000000000000;
  v4[30] = 21580;
  v4[31] = 0xE200000000000000;
  v4[32] = 20556;
  v4[33] = 0xE200000000000000;
  v4[34] = 18508;
  v4[35] = 0xE200000000000000;
  v4[36] = 77;
  v4[37] = 0xE100000000000000;
  v4[38] = 66;
  v4[39] = 0xE100000000000000;
  v4[40] = 21314;
  v4[41] = 0xE200000000000000;
  v4[42] = 83;
  v4[43] = 0xE100000000000000;
  v4[44] = 21331;
  v4[45] = 0xE200000000000000;
  v4[46] = 18254;
  v4[47] = 0xE200000000000000;
  v4[48] = 74;
  v4[49] = 0xE100000000000000;
  v4[50] = 67;
  v4[51] = 0xE100000000000000;
  v4[52] = 75;
  v4[53] = 0xE100000000000000;
  v4[54] = 84;
  v5 = (v57 - 44032) % 0x24Cu / 0x1C;
  v4[55] = 0xE100000000000000;
  v4[56] = 80;
  v4[57] = 0xE100000000000000;
  v4[58] = 72;
  v6 = (v57 - 44032) % 0x1Cu;
  v4[59] = 0xE100000000000000;
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)((v57 - 44032) / 0x24CuLL, 1, (uint64_t)inited);
  v7 = &inited[2 * ((v57 - 44032) / 0x24CuLL) + 4];
  v8 = *v7;
  v9 = v7[1];
  swift_bridgeObjectRetain(v9, v10, v11, v12);
  swift_bridgeObjectRelease((uint64_t)inited);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v5, 1, (uint64_t)v3);
  v13 = &v3[2 * v5 + 4];
  v14 = *v13;
  v15 = v13[1];
  swift_bridgeObjectRetain(v15, v16, v17, v18);
  swift_bridgeObjectRelease((uint64_t)v3);
  v19 = specialized static String.+ infix(_:_:)(v8, v9, v14, v15);
  v21 = v20;
  swift_bridgeObjectRelease(v15);
  swift_bridgeObjectRelease(v9);
  specialized Array._checkSubscript(_:wasNativeTypeChecked:)(v6, 1, (uint64_t)v4);
  v22 = &v4[2 * v6 + 4];
  v23 = *v22;
  v24 = v22[1];
  swift_setDeallocating((uint64_t)v4);
  swift_bridgeObjectRetain(v24, v25, v26, v27);
  swift_arrayDestroy((uint64_t)(v4 + 4), 28, (uint64_t)&type metadata for String);
  swift_deallocClassInstance((uint64_t)v4);
  v28 = specialized static String.+ infix(_:_:)(v19, v21, v23, v24);
  v30 = v29;
  swift_bridgeObjectRelease(v24);
  swift_bridgeObjectRelease(v21);
  v31 = specialized static String._createEmpty(withInitialCapacity:)(18);
  v33 = v32;
  v58 = v31;
  v59 = v32;
  v34 = HIBYTE(v32) & 0xF;
  if ((v32 & 0x2000000000000000) == 0)
    v34 = v31 & 0xFFFFFFFFFFFFLL;
  if (!v34 && (v31 & ~v32 & 0x2000000000000000) == 0)
  {
    v38 = 0xD000000000000010;
    swift_bridgeObjectRelease(v32);
    v39 = 0x8000000181766FC0 | 0x8000000000000000;
    goto LABEL_14;
  }
  if ((v32 & 0x2000000000000000) != 0 && (0x8000000181766FC0 & 0x2000000000000000) != 0)
  {
    v35 = specialized _SmallString.init(_:appending:)(v31, v32, 0xD000000000000010, 0x8000000181766FC0 | 0x8000000000000000);
    if ((v37 & 1) == 0)
    {
      v38 = v35;
      v39 = v36;
      swift_bridgeObjectRelease(v33);
      swift_bridgeObjectRelease(0x8000000181766FC0 | 0x8000000000000000);
LABEL_14:
      v58 = v38;
      v59 = v39;
      goto LABEL_15;
    }
  }
  if ((0x8000000181766FC0 & 0x2000000000000000) != 0)
    v40 = (0x8000000181766FC0 >> 56) & 0xF;
  else
    v40 = 16;
  _StringGuts.append(_:)(0xD000000000000010, 0x8000000181766FC0 | 0x8000000000000000, 0, v40);
  swift_bridgeObjectRelease(0x8000000181766FC0 | 0x8000000000000000);
  v38 = v58;
  v39 = v59;
LABEL_15:
  v41 = HIBYTE(v39) & 0xF;
  if ((v39 & 0x2000000000000000) == 0)
    v41 = v38 & 0xFFFFFFFFFFFFLL;
  if (v41 || (v38 & ~v39 & 0x2000000000000000) != 0)
  {
    if ((v39 & 0x2000000000000000) != 0)
    {
      if ((v30 & 0x2000000000000000) != 0)
      {
        v43 = specialized _SmallString.init(_:appending:)(v38, v39, v28, v30);
        if ((v45 & 1) == 0)
        {
          v46 = v43;
          v47 = v44;
          swift_bridgeObjectRelease(v39);
          swift_bridgeObjectRelease(v30);
          v58 = v46;
          v59 = v47;
          v30 = v47;
          v28 = v46;
          goto LABEL_28;
        }
        goto LABEL_26;
      }
    }
    else if ((v30 & 0x2000000000000000) != 0)
    {
LABEL_26:
      v42 = HIBYTE(v30) & 0xF;
      goto LABEL_27;
    }
    v42 = v28 & 0xFFFFFFFFFFFFLL;
LABEL_27:
    _StringGuts.append(_:)(v28, v30, 0, v42);
    swift_bridgeObjectRelease(v30);
    v28 = v58;
    v30 = v59;
    goto LABEL_28;
  }
  swift_bridgeObjectRelease(v39);
  v58 = v28;
  v59 = v30;
LABEL_28:
  v48 = HIBYTE(v30) & 0xF;
  if ((v30 & 0x2000000000000000) == 0)
    v48 = v28 & 0xFFFFFFFFFFFFLL;
  if (v48 || (v28 & ~v30 & 0x2000000000000000) != 0)
  {
    if ((v30 & 0x2000000000000000) == 0
      || (v49 = specialized _SmallString.init(_:appending:)(v28, v30, 0, 0xE000000000000000), (v51 & 1) != 0))
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      swift_bridgeObjectRelease(0xE000000000000000);
      v52 = v58;
      v53 = v59;
    }
    else
    {
      v52 = v49;
      v53 = v50;
      swift_bridgeObjectRelease(v30);
      swift_bridgeObjectRelease(0xE000000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v30);
    v52 = 0;
    v53 = 0xE000000000000000;
  }
  v54 = v52;
  v55 = (void *)v53;
  result._object = v55;
  result._countAndFlagsBits = v54;
  return result;
}

Swift::String_optional __swiftcall Unicode.Scalar.Properties._fastScalarName()()
{
  unsigned int *v0;
  unsigned int v1;
  Swift::String v2;
  unint64_t object;
  uint64_t v4;
  int32x4_t v5;
  uint64_t countAndFlagsBits;
  void *v7;
  Swift::String v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char v34;
  unint64_t v35;
  Swift::String v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  unint64_t v44;
  unint64_t v45;
  char v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  char v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  void *v61;
  char v62;
  unint64_t v63;
  void *v64;
  uint64_t v65;
  unint64_t v66;
  void *v67;
  char v68;
  uint64_t v69;
  void *v70;
  const char *v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  void *v82;
  char v83;
  unint64_t v84;
  void *v85;
  uint64_t v86;
  Swift::String_optional result;
  Swift::String v88;

  v1 = *v0;
  v2 = _uint64ToString(_:radix:uppercase:)(*v0, 16, 1);
  object = (unint64_t)v2._object;
  if (v1 - 55204 >= 0xFFFFD45C)
  {
    swift_bridgeObjectRelease((uint64_t)v2._object);
    v8 = Unicode.Scalar.Properties._hangulName()();
    countAndFlagsBits = v8._countAndFlagsBits;
    v7 = v8._object;
    goto LABEL_118;
  }
  if (v1 - 918000 >= 0xFFFFFF10)
  {
    swift_bridgeObjectRelease((uint64_t)v2._object);
    v9 = specialized static String._createEmpty(withInitialCapacity:)(21);
    v11 = v10;
    v88._countAndFlagsBits = v9;
    v88._object = (void *)v10;
    v12 = HIBYTE(v10) & 0xF;
    if ((v10 & 0x2000000000000000) == 0)
      v12 = v9 & 0xFFFFFFFFFFFFLL;
    if (v12 || (v9 & ~v10 & 0x2000000000000000) != 0)
    {
      if ((v10 & 0x2000000000000000) == 0
        || (0x8000000181766F00 & 0x2000000000000000) == 0
        || (v13 = specialized _SmallString.init(_:appending:)(v9, v10, 0xD000000000000013, 0x8000000181766F00 | 0x8000000000000000), (v15 & 1) != 0))
      {
        if ((0x8000000181766F00 & 0x2000000000000000) != 0)
          v18 = (0x8000000181766F00 >> 56) & 0xF;
        else
          v18 = 19;
        _StringGuts.append(_:)(0xD000000000000013, 0x8000000181766F00 | 0x8000000000000000, 0, v18);
        swift_bridgeObjectRelease(0x8000000181766F00 | 0x8000000000000000);
        v17 = (unint64_t)v88._object;
        v16 = v88._countAndFlagsBits;
LABEL_53:
        v36 = _uint64ToString(_:radix:uppercase:)(v1 - 917743, 10, 0);
        v4 = v36._countAndFlagsBits;
        object = (unint64_t)v36._object;
        v37 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000) == 0)
          v37 = v16 & 0xFFFFFFFFFFFFLL;
        if (v37 || (v16 & ~v17 & 0x2000000000000000) != 0)
        {
          if ((v17 & 0x2000000000000000) == 0)
            goto LABEL_99;
          if (((uint64_t)v36._object & 0x2000000000000000) == 0)
            goto LABEL_102;
          v38 = v16;
          goto LABEL_105;
        }
        goto LABEL_103;
      }
      v16 = v13;
      v17 = v14;
      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(0x8000000181766F00 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v10);
      v16 = 0xD000000000000013;
      v17 = 0x8000000181766F00 | 0x8000000000000000;
    }
    v88._countAndFlagsBits = v16;
    v88._object = (void *)v17;
    goto LABEL_53;
  }
  v4 = v2._countAndFlagsBits;
  v5 = vdupq_n_s32(v1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v5, (int32x4_t)xmmword_1816ABE40), (uint32x4_t)xmmword_1816ABE60), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v5, (int32x4_t)xmmword_1816ABE50), (uint32x4_t)xmmword_1816ABE70)))) & 1) != 0|| v1 - 205744 >= 0xFFFFEFA0)
  {
    v19 = specialized static String._createEmpty(withInitialCapacity:)(24);
    v21 = v20;
    v88._countAndFlagsBits = v19;
    v88._object = (void *)v20;
    v22 = HIBYTE(v20) & 0xF;
    if ((v20 & 0x2000000000000000) == 0)
      v22 = v19 & 0xFFFFFFFFFFFFLL;
    if (v22 || (v19 & ~v20 & 0x2000000000000000) != 0)
    {
      if ((v20 & 0x2000000000000000) == 0
        || (0x8000000181766F20 & 0x2000000000000000) == 0
        || (v23 = specialized _SmallString.init(_:appending:)(v19, v20, 0xD000000000000016, 0x8000000181766F20 | 0x8000000000000000), (v25 & 1) != 0))
      {
        if ((0x8000000181766F20 & 0x2000000000000000) != 0)
          v27 = (0x8000000181766F20 >> 56) & 0xF;
        else
          v27 = 22;
        _StringGuts.append(_:)(0xD000000000000016, 0x8000000181766F20 | 0x8000000000000000, 0, v27);
        swift_bridgeObjectRelease(0x8000000181766F20 | 0x8000000000000000);
        v17 = (unint64_t)v88._object;
        v26 = v88._countAndFlagsBits;
LABEL_73:
        v50 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000) == 0)
          v50 = v26 & 0xFFFFFFFFFFFFLL;
        if (v50 || (v26 & ~v17 & 0x2000000000000000) != 0)
          goto LABEL_98;
        goto LABEL_103;
      }
      v26 = v23;
      v17 = v24;
      swift_bridgeObjectRelease(v21);
      swift_bridgeObjectRelease(0x8000000181766F20 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v20);
      v26 = 0xD000000000000016;
      v17 = 0x8000000181766F20 | 0x8000000000000000;
    }
    v88._countAndFlagsBits = v26;
    v88._object = (void *)v17;
    goto LABEL_73;
  }
  if (v1 - 64110 > 0xFFFFFE91 || v1 - 64218 > 0xFFFFFF95 || v1 - 195102 >= 0xFFFFFDE2)
  {
    v28 = specialized static String._createEmpty(withInitialCapacity:)(30);
    v30 = v29;
    v88._countAndFlagsBits = v28;
    v88._object = (void *)v29;
    v31 = HIBYTE(v29) & 0xF;
    if ((v29 & 0x2000000000000000) == 0)
      v31 = v28 & 0xFFFFFFFFFFFFLL;
    if (v31 || (v28 & ~v29 & 0x2000000000000000) != 0)
    {
      if ((v29 & 0x2000000000000000) == 0
        || (0x8000000181766F40 & 0x2000000000000000) == 0
        || (v32 = specialized _SmallString.init(_:appending:)(v28, v29, 0xD00000000000001CLL, 0x8000000181766F40 | 0x8000000000000000), (v34 & 1) != 0))
      {
        if ((0x8000000181766F40 & 0x2000000000000000) != 0)
          v35 = (0x8000000181766F40 >> 56) & 0xF;
        else
          v35 = 28;
        _StringGuts.append(_:)(0xD00000000000001CLL, 0x8000000181766F40 | 0x8000000000000000, 0, v35);
        swift_bridgeObjectRelease(0x8000000181766F40 | 0x8000000000000000);
        v17 = (unint64_t)v88._object;
        v26 = v88._countAndFlagsBits;
LABEL_94:
        v58 = HIBYTE(v17) & 0xF;
        if ((v17 & 0x2000000000000000) == 0)
          v58 = v26 & 0xFFFFFFFFFFFFLL;
        if (v58 || (v26 & ~v17 & 0x2000000000000000) != 0)
        {
LABEL_98:
          if ((v17 & 0x2000000000000000) == 0)
          {
LABEL_99:
            if ((object & 0x2000000000000000) != 0)
            {
LABEL_107:
              v59 = HIBYTE(object) & 0xF;
              goto LABEL_108;
            }
LABEL_102:
            v59 = v4 & 0xFFFFFFFFFFFFLL;
LABEL_108:
            _StringGuts.append(_:)(v4, object, 0, v59);
            swift_bridgeObjectRelease(object);
            object = (unint64_t)v88._object;
            v4 = v88._countAndFlagsBits;
LABEL_109:
            v65 = HIBYTE(object) & 0xF;
            if ((object & 0x2000000000000000) == 0)
              v65 = v4 & 0xFFFFFFFFFFFFLL;
            if (v65 || (v4 & ~object & 0x2000000000000000) != 0)
            {
              if ((object & 0x2000000000000000) != 0)
              {
                v66 = specialized _SmallString.init(_:appending:)(v4, object, 0, 0xE000000000000000);
                if ((v68 & 1) == 0)
                {
                  countAndFlagsBits = v66;
                  v7 = v67;
                  swift_bridgeObjectRelease(0xE000000000000000);
                  swift_bridgeObjectRelease(object);
                  goto LABEL_118;
                }
              }
              _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
LABEL_117:
              swift_bridgeObjectRelease(0xE000000000000000);
              v7 = v88._object;
              countAndFlagsBits = v88._countAndFlagsBits;
              goto LABEL_118;
            }
LABEL_154:
            swift_bridgeObjectRelease(object);
            countAndFlagsBits = 0;
            v7 = (void *)0xE000000000000000;
            goto LABEL_118;
          }
          if (((uint64_t)v2._object & 0x2000000000000000) == 0)
            goto LABEL_102;
          v38 = v26;
LABEL_105:
          v60 = specialized _SmallString.init(_:appending:)(v38, v17, v4, object);
          if ((v62 & 1) == 0)
          {
            v63 = v60;
            v64 = v61;
            swift_bridgeObjectRelease(v17);
            swift_bridgeObjectRelease(object);
            v88._countAndFlagsBits = v63;
            v88._object = v64;
            object = (unint64_t)v64;
            v4 = v63;
            goto LABEL_109;
          }
          goto LABEL_107;
        }
LABEL_103:
        swift_bridgeObjectRelease(v17);
        v88._countAndFlagsBits = v4;
        v88._object = (void *)object;
        goto LABEL_109;
      }
      v26 = v32;
      v17 = v33;
      swift_bridgeObjectRelease(0x8000000181766F40 | 0x8000000000000000);
      swift_bridgeObjectRelease(v30);
    }
    else
    {
      swift_bridgeObjectRelease(v29);
      v26 = 0xD00000000000001CLL;
      v17 = 0x8000000181766F40 | 0x8000000000000000;
    }
    v88._countAndFlagsBits = v26;
    v88._object = (void *)v17;
    goto LABEL_94;
  }
  if (v1 - 100344 > 0xFFFFE807 || v1 - 101641 >= 0xFFFFFFF7)
  {
    v39 = specialized static String._createEmpty(withInitialCapacity:)(19);
    v41 = v40;
    v88._countAndFlagsBits = v39;
    v88._object = (void *)v40;
    v42 = HIBYTE(v40) & 0xF;
    if ((v40 & 0x2000000000000000) == 0)
      v42 = v39 & 0xFFFFFFFFFFFFLL;
    if (v42 || (v39 & ~v40 & 0x2000000000000000) != 0)
    {
      v43 = "TANGUT IDEOGRAPH-";
      if ((v40 & 0x2000000000000000) == 0
        || (0x8000000181766F60 & 0x2000000000000000) == 0
        || (v44 = specialized _SmallString.init(_:appending:)(v39, v40, 0xD000000000000011, 0x8000000181766F60 | 0x8000000000000000), (v46 & 1) != 0))
      {
        v47 = 0x8000000181766F60 | 0x8000000000000000;
        if ((0x8000000181766F60 & 0x2000000000000000) != 0)
          v48 = (0x8000000181766F60 >> 56) & 0xF;
        else
          v48 = 17;
        v49 = 0xD000000000000011;
        goto LABEL_91;
      }
      goto LABEL_85;
    }
    swift_bridgeObjectRelease(v40);
    v71 = "TANGUT IDEOGRAPH-";
    v55 = 0xD000000000000011;
LABEL_133:
    v78 = (unint64_t)(v71 + 0x7FFFFFFFFFFFFFE0);
    goto LABEL_134;
  }
  if (v1 - 101590 >= 0xFFFFFE2A)
  {
    v51 = specialized static String._createEmpty(withInitialCapacity:)(32);
    v41 = v52;
    v88._countAndFlagsBits = v51;
    v88._object = (void *)v52;
    v53 = HIBYTE(v52) & 0xF;
    if ((v52 & 0x2000000000000000) == 0)
      v53 = v51 & 0xFFFFFFFFFFFFLL;
    if (v53 || (v51 & ~v52 & 0x2000000000000000) != 0)
    {
      v43 = "KHITAN SMALL SCRIPT CHARACTER-";
      if ((v52 & 0x2000000000000000) == 0
        || (0x8000000181766F80 & 0x2000000000000000) == 0
        || (v44 = specialized _SmallString.init(_:appending:)(v51, v52, 0xD00000000000001ELL, 0x8000000181766F80 | 0x8000000000000000), (v54 & 1) != 0))
      {
        v47 = 0x8000000181766F80 | 0x8000000000000000;
        if ((0x8000000181766F80 & 0x2000000000000000) != 0)
          v48 = (0x8000000181766F80 >> 56) & 0xF;
        else
          v48 = 30;
        v49 = 0xD00000000000001ELL;
        goto LABEL_91;
      }
LABEL_85:
      v55 = v44;
      v56 = v45;
      v57 = (unint64_t)(v43 + 0x7FFFFFFFFFFFFFE0);
LABEL_86:
      swift_bridgeObjectRelease(v57 | 0x8000000000000000);
      swift_bridgeObjectRelease(v41);
LABEL_135:
      v88._countAndFlagsBits = v55;
      v88._object = (void *)v56;
LABEL_136:
      v79 = HIBYTE(v56) & 0xF;
      if ((v56 & 0x2000000000000000) == 0)
        v79 = v55 & 0xFFFFFFFFFFFFLL;
      if (!v79 && (v55 & ~v56 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v56);
        v88 = v2;
LABEL_149:
        v86 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000) == 0)
          v86 = v4 & 0xFFFFFFFFFFFFLL;
        if (v86 || (v4 & ~object & 0x2000000000000000) != 0)
        {
          _StringGuts.append(_:)(0, 0xE000000000000000);
          goto LABEL_117;
        }
        goto LABEL_154;
      }
      if ((v56 & 0x2000000000000000) != 0)
      {
        if (((uint64_t)v2._object & 0x2000000000000000) != 0)
        {
          v81 = specialized _SmallString.init(_:appending:)(v55, v56, v2._countAndFlagsBits, (unint64_t)v2._object);
          if ((v83 & 1) == 0)
          {
            v84 = v81;
            v85 = v82;
            swift_bridgeObjectRelease(v56);
            swift_bridgeObjectRelease((uint64_t)v2._object);
            v88._countAndFlagsBits = v84;
            v88._object = v85;
            object = (unint64_t)v85;
            v4 = v84;
            goto LABEL_149;
          }
          goto LABEL_147;
        }
      }
      else if (((uint64_t)v2._object & 0x2000000000000000) != 0)
      {
LABEL_147:
        v80 = ((unint64_t)v2._object >> 56) & 0xF;
        goto LABEL_148;
      }
      v80 = v2._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_148:
      _StringGuts.append(_:)(v2._countAndFlagsBits, (unint64_t)v2._object, 0, v80);
      swift_bridgeObjectRelease((uint64_t)v2._object);
      object = (unint64_t)v88._object;
      v4 = v88._countAndFlagsBits;
      goto LABEL_149;
    }
    swift_bridgeObjectRelease(v52);
    v71 = "KHITAN SMALL SCRIPT CHARACTER-";
    v55 = 0xD00000000000001ELL;
    goto LABEL_133;
  }
  if (v1 >= 0x1B170 && v1 <= 0x1B2FB)
  {
    v72 = specialized static String._createEmpty(withInitialCapacity:)(18);
    v41 = v73;
    v88._countAndFlagsBits = v72;
    v88._object = (void *)v73;
    v74 = HIBYTE(v73) & 0xF;
    if ((v73 & 0x2000000000000000) == 0)
      v74 = v72 & 0xFFFFFFFFFFFFLL;
    if (v74 || (v72 & ~v73 & 0x2000000000000000) != 0)
    {
      if ((v73 & 0x2000000000000000) != 0 && (0x8000000181766FA0 & 0x2000000000000000) != 0)
      {
        v75 = specialized _SmallString.init(_:appending:)(v72, v73, 0xD000000000000010, 0x8000000181766FA0 | 0x8000000000000000);
        if ((v77 & 1) == 0)
        {
          v55 = v75;
          v56 = v76;
          v57 = 0x8000000181766FA0;
          goto LABEL_86;
        }
      }
      v47 = 0x8000000181766FA0 | 0x8000000000000000;
      if ((0x8000000181766FA0 & 0x2000000000000000) != 0)
        v48 = (0x8000000181766FA0 >> 56) & 0xF;
      else
        v48 = 16;
      v49 = 0xD000000000000010;
LABEL_91:
      _StringGuts.append(_:)(v49, v47, 0, v48);
      swift_bridgeObjectRelease(v47);
      v56 = (unint64_t)v88._object;
      v55 = v88._countAndFlagsBits;
      goto LABEL_136;
    }
    v55 = 0xD000000000000010;
    swift_bridgeObjectRelease(v73);
    v78 = 0x8000000181766FA0;
LABEL_134:
    v56 = v78 | 0x8000000000000000;
    goto LABEL_135;
  }
  swift_bridgeObjectRelease((uint64_t)v2._object);
  countAndFlagsBits = 0;
  v7 = 0;
LABEL_118:
  v69 = countAndFlagsBits;
  v70 = v7;
  result.value._object = v70;
  result.value._countAndFlagsBits = v69;
  return result;
}

uint64_t Unicode.Scalar.Properties.name.getter()
{
  unsigned int *v0;
  unsigned int v1;
  uint64_t result;
  Swift::String_optional v3;
  unint64_t v4;
  uint64_t v5;

  v1 = *v0;
  v3 = Unicode.Scalar.Properties._fastScalarName()();
  result = v3.value._countAndFlagsBits;
  if (!v3.value._object)
  {
    result = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(88, v1);
    v5 = HIBYTE(v4) & 0xF;
    if ((v4 & 0x2000000000000000) == 0)
      v5 = result & 0xFFFFFFFFFFFFLL;
    if (!v5)
    {
      swift_bridgeObjectRelease(v4);
      return 0;
    }
  }
  return result;
}

char *Unicode.Scalar.Properties.nameAlias.getter()
{
  unsigned int *v0;
  char *result;
  uint64_t *v2;
  size_t v3;

  result = _swift_stdlib_getNameAlias(*v0);
  if (result)
  {
    v2 = (uint64_t *)result;
    v3 = _swift_stdlib_strlen(result);
    if ((v3 & 0x8000000000000000) != 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    return (char *)_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFs4Int8V_s5UInt8Vs5NeverOSSTgm5019_sSS7cStringSSSPys4f14VG_tcfcSSSRys5G7VGXEfU_Tf1cn_n(v2, v3);
  }
  return result;
}

Swift::Unicode::CanonicalCombiningClass __swiftcall Unicode.CanonicalCombiningClass.init(rawValue:)(Swift::Unicode::CanonicalCombiningClass rawValue)
{
  Swift::Unicode::CanonicalCombiningClass *v1;

  v1->rawValue = rawValue.rawValue;
  return rawValue;
}

void static Unicode.CanonicalCombiningClass.notReordered.getter(_BYTE *a1@<X8>)
{
  *a1 = 0;
}

void static Unicode.CanonicalCombiningClass.overlay.getter(_BYTE *a1@<X8>)
{
  *a1 = 1;
}

void static Unicode.CanonicalCombiningClass.nukta.getter(_BYTE *a1@<X8>)
{
  *a1 = 7;
}

void static Unicode.CanonicalCombiningClass.kanaVoicing.getter(_BYTE *a1@<X8>)
{
  *a1 = 8;
}

void static Unicode.CanonicalCombiningClass.virama.getter(_BYTE *a1@<X8>)
{
  *a1 = 9;
}

void static Unicode.CanonicalCombiningClass.attachedBelowLeft.getter(_BYTE *a1@<X8>)
{
  *a1 = -56;
}

void static Unicode.CanonicalCombiningClass.attachedBelow.getter(_BYTE *a1@<X8>)
{
  *a1 = -54;
}

void static Unicode.CanonicalCombiningClass.attachedAbove.getter(_BYTE *a1@<X8>)
{
  *a1 = -42;
}

void static Unicode.CanonicalCombiningClass.attachedAboveRight.getter(_BYTE *a1@<X8>)
{
  *a1 = -40;
}

void static Unicode.CanonicalCombiningClass.belowLeft.getter(_BYTE *a1@<X8>)
{
  *a1 = -38;
}

void static Unicode.CanonicalCombiningClass.below.getter(_BYTE *a1@<X8>)
{
  *a1 = -36;
}

void static Unicode.CanonicalCombiningClass.belowRight.getter(_BYTE *a1@<X8>)
{
  *a1 = -34;
}

void static Unicode.CanonicalCombiningClass.left.getter(_BYTE *a1@<X8>)
{
  *a1 = -32;
}

void static Unicode.CanonicalCombiningClass.right.getter(_BYTE *a1@<X8>)
{
  *a1 = -30;
}

void static Unicode.CanonicalCombiningClass.aboveLeft.getter(_BYTE *a1@<X8>)
{
  *a1 = -28;
}

void static Unicode.CanonicalCombiningClass.above.getter(_BYTE *a1@<X8>)
{
  *a1 = -26;
}

void static Unicode.CanonicalCombiningClass.aboveRight.getter(_BYTE *a1@<X8>)
{
  *a1 = -24;
}

void static Unicode.CanonicalCombiningClass.doubleBelow.getter(_BYTE *a1@<X8>)
{
  *a1 = -23;
}

void static Unicode.CanonicalCombiningClass.doubleAbove.getter(_BYTE *a1@<X8>)
{
  *a1 = -22;
}

void static Unicode.CanonicalCombiningClass.iotaSubscript.getter(_BYTE *a1@<X8>)
{
  *a1 = -16;
}

uint64_t Unicode.CanonicalCombiningClass.rawValue.getter()
{
  unsigned __int8 *v0;

  return *v0;
}

BOOL static Unicode.CanonicalCombiningClass.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

BOOL static Unicode.CanonicalCombiningClass.< infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

uint64_t Unicode.CanonicalCombiningClass.hashValue.getter()
{
  unsigned __int8 *v0;

  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 1);
}

uint64_t UInt8.hashValue.getter(unsigned __int8 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 1);
}

void Unicode.CanonicalCombiningClass.hash(into:)()
{
  Swift::UInt8 *v0;

  Hasher._combine(_:)(*v0);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Unicode.CanonicalCombiningClass(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a2 < *a1;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Unicode.CanonicalCombiningClass()
{
  unsigned __int8 *v0;

  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Unicode.CanonicalCombiningClass()
{
  return Hasher._finalize()();
}

unsigned __int8 *protocol witness for RawRepresentable.init(rawValue:) in conformance Unicode.CanonicalCombiningClass@<X0>(unsigned __int8 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance Unicode.CanonicalCombiningClass(_BYTE *a1@<X8>)
{
  _BYTE *v1;

  *a1 = *v1;
}

uint64_t Unicode.Scalar.Properties.canonicalCombiningClass.getter@<X0>(_BYTE *a1@<X8>)
{
  unsigned int *v1;
  uint64_t result;
  unsigned int v4;

  result = *v1;
  if (result >= 0xC0)
  {
    result = _swift_stdlib_getNormData(result);
    v4 = result >> 3;
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  *a1 = v4;
  return result;
}

Swift::Unicode::NumericType __swiftcall Unicode.NumericType.init(rawValue:)(Swift::Unicode::NumericType rawValue)
{
  _BYTE *v1;
  Swift::Unicode::NumericType v2;
  unint64_t countAndFlagsBits;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t object;
  unint64_t v9;
  unint64_t v10;
  char v11;
  unint64_t v12;
  Swift::String v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  void *v19;
  char v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  char *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  Swift::String v29;

  if (rawValue >= Swift_Unicode_NumericType_unknownDefault)
  {
    v2 = rawValue;
    countAndFlagsBits = 0xD000000000000015;
    v4 = specialized static String._createEmpty(withInitialCapacity:)(23);
    v6 = v5;
    v29._countAndFlagsBits = v4;
    v29._object = (void *)v5;
    v7 = HIBYTE(v5) & 0xF;
    if ((v5 & 0x2000000000000000) == 0)
      v7 = v4 & 0xFFFFFFFFFFFFLL;
    if (v7 || (v4 & ~v5 & 0x2000000000000000) != 0)
    {
      if ((v5 & 0x2000000000000000) == 0
        || (0x8000000181766EB0 & 0x2000000000000000) == 0
        || (v9 = specialized _SmallString.init(_:appending:)(v4, v5, 0xD000000000000015, 0x8000000181766EB0 | 0x8000000000000000), (v11 & 1) != 0))
      {
        if ((0x8000000181766EB0 & 0x2000000000000000) != 0)
          v12 = (0x8000000181766EB0 >> 56) & 0xF;
        else
          v12 = 21;
        _StringGuts.append(_:)(0xD000000000000015, 0x8000000181766EB0 | 0x8000000000000000, 0, v12);
        swift_bridgeObjectRelease(0x8000000181766EB0 | 0x8000000000000000);
        object = (unint64_t)v29._object;
        countAndFlagsBits = v29._countAndFlagsBits;
LABEL_17:
        v13 = _uint64ToString(_:radix:uppercase:)(v2, 10, 0);
        v14 = v13._countAndFlagsBits;
        v15 = (unint64_t)v13._object;
        v16 = HIBYTE(object) & 0xF;
        if ((object & 0x2000000000000000) == 0)
          v16 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (!v16 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(object);
          v29 = v13;
          goto LABEL_31;
        }
        if ((object & 0x2000000000000000) != 0)
        {
          if (((uint64_t)v13._object & 0x2000000000000000) != 0)
          {
            v18 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v13._countAndFlagsBits, (unint64_t)v13._object);
            if ((v20 & 1) == 0)
            {
              v21 = v18;
              v22 = v19;
              swift_bridgeObjectRelease(object);
              swift_bridgeObjectRelease((uint64_t)v13._object);
              v29._countAndFlagsBits = v21;
              v29._object = v22;
              v15 = (unint64_t)v22;
              v14 = v21;
              goto LABEL_31;
            }
            goto LABEL_29;
          }
        }
        else if (((uint64_t)v13._object & 0x2000000000000000) != 0)
        {
LABEL_29:
          v17 = ((unint64_t)v13._object >> 56) & 0xF;
          goto LABEL_30;
        }
        v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_30:
        _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
        swift_bridgeObjectRelease((uint64_t)v13._object);
        v15 = (unint64_t)v29._object;
        v14 = v29._countAndFlagsBits;
LABEL_31:
        v23 = HIBYTE(v15) & 0xF;
        if ((v15 & 0x2000000000000000) == 0)
          v23 = v14 & 0xFFFFFFFFFFFFLL;
        if (v23 || (v14 & ~v15 & 0x2000000000000000) != 0)
        {
          if ((v15 & 0x2000000000000000) == 0
            || (v26 = specialized _SmallString.init(_:appending:)(v14, v15, 0, 0xE000000000000000), (v28 & 1) != 0))
          {
            _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
            swift_bridgeObjectRelease(0xE000000000000000);
            v25 = (unint64_t)v29._object;
            v24 = (char *)v29._countAndFlagsBits;
          }
          else
          {
            v24 = (char *)v26;
            v25 = v27;
            swift_bridgeObjectRelease(v15);
            swift_bridgeObjectRelease(0xE000000000000000);
          }
        }
        else
        {
          swift_bridgeObjectRelease(v15);
          v24 = 0;
          v25 = 0xE000000000000000;
        }
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v24, v25, "Swift/UnicodeScalarProperties.swift", 35, 2, 0x5D0uLL, 0);
      }
      countAndFlagsBits = v9;
      object = v10;
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0x8000000181766EB0 | 0x8000000000000000);
    }
    else
    {
      swift_bridgeObjectRelease(v5);
      object = 0x8000000181766EB0 | 0x8000000000000000;
    }
    v29._countAndFlagsBits = countAndFlagsBits;
    v29._object = (void *)object;
    goto LABEL_17;
  }
  *v1 = 2 - rawValue;
  return rawValue;
}

uint64_t Unicode.Scalar.Properties.numericType.getter@<X0>(char *a1@<X8>)
{
  unsigned int *v1;
  uint64_t result;
  char v4;
  char v5;

  result = _swift_stdlib_getNumericType(*v1);
  if ((_DWORD)result == 255)
  {
    v4 = 3;
  }
  else
  {
    result = Unicode.NumericType.init(rawValue:)(result);
    v4 = v5;
  }
  *a1 = v4;
  return result;
}

uint64_t Unicode.Scalar.Properties.numericValue.getter()
{
  unsigned int *v0;
  unsigned int v1;
  int NumericType;

  v1 = *v0;
  NumericType = _swift_stdlib_getNumericType(v1);
  if (NumericType == 255)
    return 0;
  Unicode.NumericType.init(rawValue:)(NumericType);
  return _swift_stdlib_getNumericValue(v1);
}

unint64_t Character._firstScalar.getter(uint64_t a1, unint64_t a2)
{
  unint64_t result;

  result = specialized Collection.first.getter(a1, a2);
  if ((result & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  return result;
}

BOOL Character._isSingleScalar.getter(uint64_t a1, unint64_t a2)
{
  Swift::String::Index v4;
  Swift::UInt64 v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  unsigned int v9;
  Swift::UInt64 rawBits;
  uint64_t v11;
  _QWORD v13[2];

  v4._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)15)._rawBits;
  if ((a2 & 0x1000000000000000) != 0)
  {
    rawBits = String.UnicodeScalarView._foreignIndex(after:)(v4)._rawBits;
  }
  else
  {
    v5 = v4._rawBits >> 16;
    if ((a2 & 0x2000000000000000) != 0)
    {
      v13[0] = a1;
      v13[1] = a2 & 0xFFFFFFFFFFFFFFLL;
      v7 = *((unsigned __int8 *)v13 + v5);
    }
    else
    {
      if ((a1 & 0x1000000000000000) != 0)
        v6 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      else
        v6 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
      v7 = v6[v5];
    }
    v8 = (char)v7;
    v9 = __clz(v7 ^ 0xFF) - 24;
    if (v8 >= 0)
      LOBYTE(v9) = 1;
    rawBits = ((v5 + v9) << 16) | 5;
  }
  v11 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v11 = a1 & 0xFFFFFFFFFFFFLL;
  return rawBits >> 14 == 4 * v11;
}

BOOL Character.isASCII.getter(uint64_t a1, unint64_t a2)
{
  return (Character.asciiValue.getter(a1, a2) & 0x100) == 0;
}

uint64_t Character.asciiValue.getter(uint64_t a1, unint64_t a2)
{
  int v4;
  unint64_t v5;
  unint64_t v6;

  if (a1 == 2573 && a2 == 0xE200000000000000
    || (~a2 & 0x6000000000000000) != 0
    && (_stringCompareInternal(_:_:expecting:)(a1, a2, 2573, 0xE200000000000000, 0) & 1) != 0)
  {
    v4 = 0;
    LOBYTE(v5) = 10;
    return v5 | (v4 << 8);
  }
  if (!Character._isSingleScalar.getter(a1, a2))
    goto LABEL_12;
  v6 = specialized Collection.first.getter(a1, a2);
  if ((v6 & 0x100000000) != 0)
    goto LABEL_15;
  if ((v6 & 0xFFFFFF80) != 0)
  {
LABEL_12:
    LOBYTE(v5) = 0;
    v4 = 1;
    return v5 | (v4 << 8);
  }
  v5 = specialized Collection.first.getter(a1, a2);
  if ((v5 & 0x100000000) != 0)
LABEL_15:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  if ((v5 & 0xFFFFFF00) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  v4 = 0;
  return v5 | (v4 << 8);
}

unint64_t Character.isWhitespace.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 45) & 1;
}

uint64_t Character.isNewline.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  _BOOL4 v3;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  v3 = (v2 - 8232) < 2 || v2 == 133;
  return (v2 - 14) >= 0xFFFFFFFC || v3;
}

BOOL Character.isNumber.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  int NumericType;
  int v4;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  NumericType = _swift_stdlib_getNumericType(v2);
  v4 = NumericType;
  if (NumericType != 255)
    Unicode.NumericType.init(rawValue:)(NumericType);
  return v4 != 255;
}

BOOL Character.isWholeNumber.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  int v5;
  int NumericType;
  double NumericValue;
  _BOOL4 v8;

  if (!Character._isSingleScalar.getter(a1, a2))
    return 0;
  v4 = specialized Collection.first.getter(a1, a2);
  if ((v4 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  v5 = v4;
  NumericType = _swift_stdlib_getNumericType(v4);
  if (NumericType == 255)
    return 0;
  Unicode.NumericType.init(rawValue:)(NumericType);
  NumericValue = _swift_stdlib_getNumericValue(v5);
  v8 = NumericValue > -9.22337204e18;
  if (NumericValue >= 9.22337204e18)
    v8 = 0;
  return NumericValue == trunc(NumericValue) && v8;
}

uint64_t Character.wholeNumberValue.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  int v5;
  int NumericType;
  double NumericValue;
  BOOL v8;

  if (!Character._isSingleScalar.getter(a1, a2))
    return 0;
  v4 = specialized Collection.first.getter(a1, a2);
  if ((v4 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  v5 = v4;
  NumericType = _swift_stdlib_getNumericType(v4);
  if (NumericType == 255)
    return 0;
  Unicode.NumericType.init(rawValue:)(NumericType);
  NumericValue = _swift_stdlib_getNumericValue(v5);
  v8 = NumericValue > -9.22337204e18;
  if (NumericValue >= 9.22337204e18)
    v8 = 0;
  if ((v8 & (NumericValue == trunc(NumericValue))) != 0)
    return (uint64_t)NumericValue;
  else
    return 0;
}

Swift::Int_optional __swiftcall Int.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  int v2;
  Swift::Int v3;
  char v4;
  Swift::Int_optional result;

  v1 = exactly > -9.22337204e18;
  if (exactly >= 9.22337204e18)
    v1 = 0;
  v2 = v1 & (trunc(exactly) == exactly);
  if (v2)
    v3 = (uint64_t)exactly;
  else
    v3 = 0;
  v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

BOOL Character.isHexDigit.getter(uint64_t a1, unint64_t a2)
{
  char v2;

  Character.hexDigitValue.getter(a1, a2);
  return (v2 & 1) == 0;
}

uint64_t Character.hexDigitValue.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (Character._isSingleScalar.getter(a1, a2))
  {
    v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    if ((v4 - 58) >= 0xFFFFFFF6)
    {
      return (v4 - 48);
    }
    else if ((v4 - 71) >= 0xFFFFFFFA)
    {
      return (v4 - 55);
    }
    else if ((v4 - 103) >= 0xFFFFFFFA)
    {
      return (v4 - 87);
    }
    else
    {
      v5 = v4 - 65335;
      if ((v4 - 65351) < 0xFFFFFFFA)
        v5 = 0;
      if ((v4 - 65319) >= 0xFFFFFFFA)
        v6 = v4 - 65303;
      else
        v6 = v5;
      if ((v4 - 65306) >= 0xFFFFFFF6)
        return (v4 - 65296);
      else
        return v6;
    }
  }
  else
  {
    return 0;
  }
}

unint64_t Character.isLetter.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 7) & 1;
}

uint64_t Character._isUppercased.getter(uint64_t a1, unint64_t a2)
{
  return Character._isUppercased.getter(a1, a2, (uint64_t (*)(void))String.uppercased());
}

uint64_t Character._isLowercased.getter(uint64_t a1, unint64_t a2)
{
  return Character._isUppercased.getter(a1, a2, (uint64_t (*)(void))String.lowercased());
}

uint64_t Character._isUppercased.getter(uint64_t a1, unint64_t a2, uint64_t (*a3)(void))
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v6 = a3();
  v7 = v5;
  if (v6 == a1 && v5 == a2)
  {
    v8 = 1;
    v7 = a2;
  }
  else if ((~a2 & 0x6000000000000000) == 0 && (v5 & 0x2000000000000000) != 0 && (v5 & 0x4000000000000000) != 0)
  {
    v8 = 0;
  }
  else
  {
    v8 = _stringCompareInternal(_:_:expecting:)(a1, a2, v6, v5, 0);
  }
  swift_bridgeObjectRelease(v7);
  return v8 & 1;
}

uint64_t Character.isUppercase.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v4;

  if (Character._isSingleScalar.getter(a1, a2))
  {
    v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x80000000000) != 0)
      return 1;
  }
  if ((Character._isUppercased.getter(a1, a2) & 1) != 0)
    return Character.isCased.getter(a1, a2);
  return 0;
}

uint64_t Character.isCased.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  char v5;

  if (Character._isSingleScalar.getter(a1, a2))
  {
    v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x800) != 0)
      goto LABEL_6;
  }
  if ((Character._isUppercased.getter(a1, a2) & 1) == 0)
LABEL_6:
    v5 = 1;
  else
    v5 = Character._isLowercased.getter(a1, a2) ^ 1;
  return v5 & 1;
}

uint64_t Character.isLowercase.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v4;

  if (Character._isSingleScalar.getter(a1, a2))
  {
    v4 = specialized Collection.first.getter(a1, a2);
    if ((v4 & 0x100000000) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
    if ((_swift_stdlib_getBinaryProperties(v4) & 0x100000000) != 0)
      return 1;
  }
  if ((Character._isLowercased.getter(a1, a2) & 1) != 0)
    return Character.isCased.getter(a1, a2);
  return 0;
}

BOOL Character.isSymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  Swift::UInt8 GeneralCategory;
  unsigned __int8 v5;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 - 18 < 4;
}

unint64_t Character.isMathSymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  return ((unint64_t)_swift_stdlib_getBinaryProperties(v2) >> 33) & 1;
}

BOOL Character.isCurrencySymbol.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  Swift::UInt8 GeneralCategory;
  char v5;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 == 19;
}

BOOL Character.isPunctuation.getter(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  Swift::UInt8 GeneralCategory;
  unsigned __int8 v5;

  v2 = specialized Collection.first.getter(a1, a2);
  if ((v2 & 0x100000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/CharacterProperties.swift", 31, 2, 0x10uLL, 0);
  GeneralCategory = _swift_stdlib_getGeneralCategory(v2);
  Unicode.GeneralCategory.init(rawValue:)(GeneralCategory);
  return v5 - 11 < 7;
}

Swift::Unicode::Scalar_optional __swiftcall Unicode._NFD.Iterator.next()()
{
  unint64_t v0;
  uint64_t v1;

  v0 = specialized Unicode._InternalNFD.Iterator.next()();
  v1 = v0;
  if ((v0 & 0x1000000000000) != 0)
    v1 = 0;
  return (Swift::Unicode::Scalar_optional)(v1 | ((HIWORD(v0) & 1) << 32));
}

unint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._NFD.Iterator@<X0>(uint64_t a1@<X8>)
{
  unint64_t result;
  int v3;

  result = specialized Unicode._InternalNFD.Iterator.next()();
  if ((result & 0x1000000000000) != 0)
    v3 = 0;
  else
    v3 = result;
  *(_DWORD *)a1 = v3;
  *(_BYTE *)(a1 + 4) = BYTE6(result) & 1;
  return result;
}

unint64_t Unicode._NFD.makeIterator()@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 *v4;
  unint64_t v5;
  uint64_t v6;
  __int128 v7;

  v6 = *((_QWORD *)v4 + 2);
  v5 = *((_QWORD *)v4 + 3);
  *(_QWORD *)a4 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a4 + 8) = 0;
  v7 = *v4;
  *(_QWORD *)(a4 + 16) = *(_QWORD *)v4;
  *(_OWORD *)(a4 + 24) = v7;
  *(_QWORD *)(a4 + 40) = v6;
  *(_QWORD *)(a4 + 48) = v5;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

__n128 protocol witness for Sequence.makeIterator() in conformance Unicode._NFD@<Q0>(uint64_t a1@<X8>)
{
  __n128 *v1;
  unint64_t v2;
  unint64_t v3;
  __n128 result;

  v2 = v1[1].n128_u64[0];
  v3 = v1[1].n128_u64[1];
  *(_QWORD *)a1 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a1 + 8) = 0;
  result = *v1;
  *(_QWORD *)(a1 + 16) = v1->n128_u64[0];
  *(__n128 *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 40) = v2;
  *(_QWORD *)(a1 + 48) = v3;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFD(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, uint64_t))specialized _copySequenceToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFD(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized Sequence._copySequenceContents(initializing:));
}

Swift::Unicode::Scalar_optional __swiftcall Unicode._NFC.Iterator.next()()
{
  unint64_t v0;

  v0 = specialized Unicode._InternalNFC.Iterator.next()();
  return (Swift::Unicode::Scalar_optional)(v0 | ((HIDWORD(v0) & 1) << 32));
}

unint64_t protocol witness for IteratorProtocol.next() in conformance Unicode._NFC.Iterator@<X0>(uint64_t a1@<X8>)
{
  unint64_t result;

  result = specialized Unicode._InternalNFC.Iterator.next()();
  *(_DWORD *)a1 = result;
  *(_BYTE *)(a1 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t Unicode._NFC.makeIterator()@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 *v4;
  unint64_t v5;
  uint64_t v6;
  __int128 v7;

  v6 = *((_QWORD *)v4 + 2);
  v5 = *((_QWORD *)v4 + 3);
  *(_QWORD *)a4 = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 12) = 0;
  *(_BYTE *)(a4 + 16) = 1;
  *(_QWORD *)(a4 + 24) = &_swiftEmptyArrayStorage;
  *(_BYTE *)(a4 + 32) = 0;
  v7 = *v4;
  *(_QWORD *)(a4 + 40) = *(_QWORD *)v4;
  *(_OWORD *)(a4 + 48) = v7;
  *(_QWORD *)(a4 + 64) = v6;
  *(_QWORD *)(a4 + 72) = v5;
  return swift_bridgeObjectRetain(v5, a1, a2, a3);
}

__n128 protocol witness for Sequence.makeIterator() in conformance Unicode._NFC@<Q0>(__n128 *a1@<X8>)
{
  __n128 *v1;
  unint64_t v2;
  unint64_t v3;
  __n128 result;

  v2 = v1[1].n128_u64[0];
  v3 = v1[1].n128_u64[1];
  a1->n128_u64[0] = (unint64_t)&_swiftEmptyArrayStorage;
  a1->n128_u8[8] = 0;
  a1->n128_u32[3] = 0;
  a1[1].n128_u8[0] = 1;
  a1[1].n128_u64[1] = (unint64_t)&_swiftEmptyArrayStorage;
  a1[2].n128_u8[0] = 0;
  result = *v1;
  a1[2].n128_u64[1] = v1->n128_u64[0];
  a1[3] = result;
  a1[4].n128_u64[0] = v2;
  a1[4].n128_u64[1] = v3;
  return result;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance Unicode._NFC(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance Substring(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, uint64_t))specialized _copySequenceToContiguousArray<A>(_:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Unicode._NFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance Substring(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized Sequence._copySequenceContents(initializing:));
}

unint64_t String._nfd.getter@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, Swift::UInt64 *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;

  *a3 = specialized Collection.subscript.getter(a1, a2);
  a3[1] = v4;
  a3[2] = v5;
  a3[3] = (Swift::UInt64)v6;
  return swift_bridgeObjectRetain((unint64_t)v6, v4, v5, v6);
}

unint64_t Substring._nfd.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, _QWORD *a5@<X8>)
{
  *a5 = a1;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return swift_bridgeObjectRetain((unint64_t)a4, a2, a3, a4);
}

uint64_t Unicode.Scalar.Properties._script.getter()
{
  unsigned int *v0;

  return _swift_stdlib_getScript(*v0);
}

_QWORD *Unicode.Scalar.Properties._scriptExtensions.getter()
{
  unsigned int *v0;
  unsigned int v1;
  char *ScriptExtensions;
  char *v3;
  uint64_t v4;
  __objc2_class **v5;
  _QWORD *v6;
  __objc2_class *v7;
  char v8;
  char v9;
  unint64_t v10;
  uint64_t v11;
  unsigned __int8 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v1 = *v0;
  v13 = 0;
  ScriptExtensions = _swift_stdlib_getScriptExtensions(v1, &v13);
  if (ScriptExtensions)
  {
    v3 = ScriptExtensions;
    v4 = v13;
    v5 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, v13, 0, (uint64_t)&_swiftEmptyArrayStorage);
    v6 = v5;
    if (v4)
    {
      v7 = v5[2];
      do
      {
        v9 = *v3++;
        v8 = v9;
        v10 = v6[3];
        if ((unint64_t)v7 >= v10 >> 1)
          v6 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v10 > 1), (int64_t)&v7->isa + 1, 1, (uint64_t)v6);
        v6[2] = (char *)&v7->isa + 1;
        *((_BYTE *)&v7->info + (_QWORD)v6) = v8;
        v7 = (__objc2_class *)((char *)v7 + 1);
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    v11 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>();
    v6 = swift_allocObject(v11, 0x21uLL, 7uLL);
    *((_OWORD *)v6 + 1) = xmmword_1816ABBA0;
    *((_BYTE *)v6 + 32) = _swift_stdlib_getScript(v1);
  }
  return v6;
}

unint64_t Unicode.Scalar.Properties._caseFolded.getter()
{
  int *v0;
  int v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unsigned int v5;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  unint64_t v14;
  uint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = *v0;
  v16 = -1;
  v17 = -1;
  _swift_stdlib_getCaseMapping(v1, (int *)&v16);
  v2 = 0;
  v3 = 0;
  v4 = 0xE000000000000000;
  do
  {
    v5 = *(_DWORD *)((char *)&v16 + v2);
    if (v5 == -1)
      break;
    if (HIWORD(v5) > 0x10u || (v5 & 0xFFFFF800) == 55296)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnicodeSPI.swift", 22, 2, 0xCFuLL, 0);
    v18 = v3;
    v19 = v4;
    v8 = specialized Unicode.Scalar.withUTF8CodeUnits<A>(_:)(v5);
    v9 = v7;
    if ((v4 & 0x2000000000000000) == 0)
    {
      if ((v7 & 0x2000000000000000) != 0)
LABEL_14:
        v10 = HIBYTE(v9) & 0xF;
      else
LABEL_11:
        v10 = v8 & 0xFFFFFFFFFFFFLL;
      _StringGuts.append(_:)(v8, v9, 0, v10);
      swift_bridgeObjectRelease(v9);
      v3 = v18;
      v4 = v19;
      goto LABEL_16;
    }
    if ((v7 & 0x2000000000000000) == 0)
      goto LABEL_11;
    v11 = specialized _SmallString.init(_:appending:)(v3, v4, v8, v7);
    if ((v13 & 1) != 0)
      goto LABEL_14;
    v3 = v11;
    v14 = v12;
    swift_bridgeObjectRelease(v9);
    swift_bridgeObjectRelease(v4);
    v4 = v14;
LABEL_16:
    v2 += 4;
    swift_bridgeObjectRelease(0xE000000000000000);
  }
  while (v2 != 12);
  return v3;
}

Swift::String::Index __swiftcall String._wordIndex(after:)(Swift::String::Index after)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v3 = _StringGuts.validateWordIndex(_:)(after._rawBits, v1, v2, (uint64_t (*)(void))_StringGuts.validateSubscalarIndex(_:));
  return (Swift::String::Index)(_StringGuts.nextWordIndex(startingAt:)(v3 >> 16) << 16);
}

Swift::String::Index __swiftcall String._wordIndex(before:)(Swift::String::Index before)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v3 = _StringGuts.validateWordIndex(_:)(before._rawBits, v1, v2, (uint64_t (*)(void))_StringGuts.validateInclusiveSubscalarIndex(_:));
  if (!(v3 >> 14))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/UnicodeSPI.swift", 22, 2, 0xEAuLL, 0);
  return (Swift::String::Index)(_StringGuts.previousWordIndex(endingAt:)(v3 >> 16) << 16);
}

Swift::String::Index __swiftcall String._nearestWordIndex(atOrBelow:)(Swift::String::Index atOrBelow)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  Swift::String::Index v5;
  Swift::UInt64 rawBits;
  Swift::UInt64 v7;
  uint64_t v8;
  Swift::Int v9;

  v3 = v2;
  v4 = v1;
  v5._rawBits = _StringGuts.validateInclusiveSubscalarIndex(_:)(atOrBelow)._rawBits;
  rawBits = v5._rawBits;
  if ((v5._rawBits & 1) != 0)
  {
    if (v5._rawBits < 0x10000)
      return (Swift::String::Index)rawBits;
  }
  else
  {
    rawBits = v5._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(v5)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (rawBits < 0x10000)
      return (Swift::String::Index)rawBits;
  }
  v7 = rawBits >> 16;
  v8 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0)
    v8 = v4 & 0xFFFFFFFFFFFFLL;
  if (v7 != v8)
  {
    v9 = _StringGuts.previousWordIndex(endingAt:)(rawBits >> 16);
    if (v7 != _StringGuts.nextWordIndex(startingAt:)(v9))
      return (Swift::String::Index)(v9 << 16);
  }
  return (Swift::String::Index)rawBits;
}

id key path getter for Unmanaged._value : <A>Unmanaged<A>@<X0>(void **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, _QWORD *a5@<X8>)
{
  void *v5;

  v5 = *a1;
  *a5 = v5;
  return swift_unknownObjectRetain(v5, a2, a3, a4);
}

void Unmanaged._value.setter(void *a1)
{
  _QWORD *v1;

  swift_unknownObjectRelease(a1);
  *v1 = a1;
}

void (*Unmanaged._value.modify(void **a1, uint64_t a2, uint64_t a3, char *a4))(uint64_t a1)
{
  void **v4;
  void *v6;

  v6 = *v4;
  *a1 = *v4;
  a1[1] = v4;
  swift_unknownObjectRetain(v6, a2, a3, a4);
  return Unmanaged._value.modify;
}

void Unmanaged._value.modify(uint64_t a1)
{
  id v1;
  _QWORD *v2;

  v1 = *(id *)a1;
  v2 = *(_QWORD **)(a1 + 8);
  swift_unknownObjectRelease(*(id *)a1);
  *v2 = v1;
}

void *Unmanaged.init(_private:)(void *a1)
{
  swift_unknownObjectRelease(a1);
  return a1;
}

id Unmanaged.autorelease()(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  id v4;

  v4 = swift_unknownObjectRetain(a1, a2, a3, a4);
  swift_unknownObjectRelease(v4);
  return v4;
}

Swift::Int UnsafePointer.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter(a1, a2, (uint64_t (*)(_QWORD))type metadata accessor for UnsafePointer, (uint64_t)&protocol conformance descriptor for UnsafePointer<A>);
}

Swift::Int _sSPyxGSHsRi_zrlSH9hashValueSivgTW(uint64_t a1)
{
  uint64_t *v1;

  return UnsafePointer.hashValue.getter(*v1, *(_QWORD *)(a1 + 16));
}

void _sSPyxGSHsRi_zrlSH4hash4intoys6HasherVz_tFTW(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafePointer<A>, a2, a3);
  _Pointer.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int _sSPyxGSHsRi_zrlSH13_rawHashValue4seedS2i_tFTW(Swift::Int a1, uint64_t a2, uint64_t a3)
{
  swift_getWitnessTable(&protocol conformance descriptor for UnsafePointer<A>, a2, a3);
  return _Pointer._rawHashValue(seed:)(a1);
}

uint64_t _sSPyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafePointer<A>, a1, a3);
  return _Pointer.debugDescription.getter(a1, WitnessTable);
}

uint64_t _sSPyxGs17CustomReflectablesRi_zrlsABP12customMirrors0D0VvgTW@<X0>(Class *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  swift_getWitnessTable(&protocol conformance descriptor for UnsafePointer<A>, a1, a2);
  return _Pointer.customMirror.getter(a1, a3);
}

uint64_t UnsafePointer.pointee.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 16))(a3, a1);
}

uint64_t UnsafePointer.subscript.unsafeAddressor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 + *(_QWORD *)(*(_QWORD *)(a3 - 8) + 72) * a1;
}

uint64_t UnsafePointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 16))(a4, a2 + *(_QWORD *)(*(_QWORD *)(a3 - 8) + 72) * a1);
}

uint64_t UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5)
{
  return UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(a1, a2, a3, a4, a5);
}

{
  return a3(a5);
}

uint64_t static UnsafePointer._max.getter(uint64_t a1)
{
  return -*(_QWORD *)(*(_QWORD *)(a1 - 8) + 72);
}

Swift::Int UnsafeMutablePointer.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return AutoreleasingUnsafeMutablePointer.hashValue.getter(a1, a2, (uint64_t (*)(_QWORD))type metadata accessor for UnsafeMutablePointer, (uint64_t)&protocol conformance descriptor for UnsafeMutablePointer<A>);
}

Swift::Int AutoreleasingUnsafeMutablePointer.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t (*a3)(_QWORD), uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = a3(0);
  swift_getWitnessTable(a4, v5, v6);
  return _Pointer._rawHashValue(seed:)(0);
}

Swift::Int _sSpyxGSHsRi_zrlSH9hashValueSivgTW(uint64_t a1)
{
  uint64_t *v1;

  return UnsafeMutablePointer.hashValue.getter(*v1, *(_QWORD *)(a1 + 16));
}

void _sSpyxGSHsRi_zrlSH4hash4intoys6HasherVz_tFTW(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutablePointer<A>, a2, a3);
  _Pointer.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int _sSpyxGSHsRi_zrlSH13_rawHashValue4seedS2i_tFTW(Swift::Int a1, uint64_t a2, uint64_t a3)
{
  swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutablePointer<A>, a2, a3);
  return _Pointer._rawHashValue(seed:)(a1);
}

uint64_t _sSpyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutablePointer<A>, a1, a3);
  return _Pointer.debugDescription.getter(a1, WitnessTable);
}

uint64_t _sSpyxGs17CustomReflectablesRi_zrlsABP12customMirrors0D0VvgTW@<X0>(Class *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutablePointer<A>, a1, a2);
  return _Pointer.customMirror.getter(a1, a3);
}

uint64_t key path getter for UnsafeMutablePointer.pointee : <A>UnsafeMutablePointer<A>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(a3 + a2 - 8) - 8) + 16))(a4, *a1);
}

uint64_t key path setter for UnsafeMutablePointer.pointee : <A>UnsafeMutablePointer<A>(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + a3 - 8) - 8) + 24))(*a2, a1);
}

uint64_t UnsafeMutablePointer.pointee.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 40))(a2, a1);
}

uint64_t (*UnsafeMutablePointer.pointee.modify())()
{
  return EnumeratedSequence._base.modify;
}

void *specialized UnsafeMutablePointer.initialize(repeating:count:)(void *__c, size_t __len, void *__b)
{
  if ((__len & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize(repeating:count:): negative count", 65, 2, "Swift/UnsafePointer.swift", 25, 2, 0x371uLL, 0);
  if (__len)
    return memset(__b, (int)__c, __len);
  return __c;
}

uint64_t UnsafeMutablePointer.initialize(repeating:count:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t);

  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize(repeating:count:): negative count", 65, 2, "Swift/UnsafePointer.swift", 25, 2, 0x371uLL, 0);
  v4 = a2;
  if (a2)
  {
    v7 = result;
    v8 = *(_QWORD *)(a4 - 8);
    v9 = *(_QWORD *)(v8 + 72);
    v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 16);
    do
    {
      result = v10(a3, v7, a4);
      a3 += v9;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t UnsafeMutablePointer.initialize(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 16))(a2, a1);
}

char *UnsafeMutablePointer.moveAssign(from:count:)(char *__src, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  char *v6;

  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.moveUpdate(from:) with negative count", 58, 2, "Swift/UnsafePointer.swift", 25, 2, 0x46AuLL, 0);
  v4 = *(_QWORD *)(*(_QWORD *)(a4 - 8) + 72) * a2;
  v5 = &__dst[v4];
  v6 = &__src[v4];
  if (v5 > __src && v6 > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "moveUpdate overlapping range", 28, 2, "Swift/UnsafePointer.swift", 25, 2, 0x46CuLL, 0);
  return swift_arrayAssignWithTake(__dst, __src, a2, a4);
}

uint64_t UnsafeMutablePointer.withMemoryRebound<A, B>(to:capacity:_:)(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5)
{
  return UnsafePointer.withMemoryRebound<A, B>(to:capacity:_:)(a1, a2, a3, a4, a5);
}

uint64_t key path getter for UnsafeMutablePointer.subscript(_:) : <A>UnsafeMutablePointer<A>A@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;

  v4 = *(_QWORD *)(*(_QWORD *)((char *)a2 + a3 - 8) - 8);
  return (*(uint64_t (**)(uint64_t, _QWORD))(v4 + 16))(a4, *a1 + *(_QWORD *)(v4 + 72) * *a2);
}

uint64_t key path setter for UnsafeMutablePointer.subscript(_:) : <A>UnsafeMutablePointer<A>A(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)((char *)a3 + a4 - 8) - 8) + 24))(*a2 + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)((char *)a3 + a4 - 8) - 8) + 72) * *a3, a1, *(_QWORD *)((char *)a3 + a4 - 8));
}

uint64_t UnsafeMutablePointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 40))(a3 + *(_QWORD *)(*(_QWORD *)(a4 - 8) + 72) * a2, a1, a4);
}

uint64_t (*UnsafeMutablePointer.subscript.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawPointer.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0, a1);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeRawPointer()
{
  Builtin::RawPointer *v0;

  return _rawPointerToString(_:)(*v0)._countAndFlagsBits;
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UnsafeRawPointer@<X0>(uint64_t a1@<X8>)
{
  uint64_t *v1;

  return specialized _Pointer.customMirror.getter(*v1, (swift *)&type metadata for UnsafeRawPointer, a1);
}

Swift::Void __swiftcall UnsafeRawPointer.deallocate()()
{
  void *v0;

  swift_slowDealloc(v0);
}

_QWORD *protocol witness for Strideable.distance(to:) in conformance UnsafeRawPointer@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  *a2 = *result - *v2;
  return result;
}

_QWORD *protocol witness for Strideable.advanced(by:) in conformance UnsafeRawPointer@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  *a2 = *v2 + *result;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UnsafeRawPointer(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, _QWORD *a6)
{
  *a1 = *a4 + *a6;
  return 0;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeMutableRawPointer()
{
  Swift::UInt64 *v0;

  return specialized _Pointer.debugDescription.getter(*v0);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance UnsafeMutableRawPointer@<X0>(uint64_t a1@<X8>)
{
  uint64_t *v1;

  return specialized _Pointer.customMirror.getter(*v1, (swift *)&type metadata for UnsafeMutableRawPointer, a1);
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t);
  uint64_t v11;

  if (a3 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.initializeMemory: negative count", 56, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x456uLL, 0);
  v6 = a3;
  if (a3)
  {
    v9 = *(_QWORD *)(a5 - 8);
    v10 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 16);
    v11 = a4;
    do
    {
      v10(v11, a2, a5);
      v11 += *(_QWORD *)(v9 + 72);
      --v6;
    }
    while (v6);
  }
  return a4;
}

char *UnsafeMutableRawPointer.moveInitializeMemory<A>(as:from:count:)(int a1, char *a2, uint64_t a3, char *__dst, uint64_t a5)
{
  if (a3 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.moveInitializeMemory with negative count", 64, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4C8uLL, 0);
  if (__dst < a2 || &a2[*(_QWORD *)(*(_QWORD *)(a5 - 8) + 72) * a3] <= __dst)
    swift_arrayInitWithTakeFrontToBack(__dst, a2, a3, a5);
  else
    swift_arrayInitWithTakeBackToFront(__dst, a2, a3, a5);
  return __dst;
}

void *UnsafeMutableRawPointer.storeBytes<A>(of:toByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(a1, a2, a5, a4, a5);
}

void *UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a5 - 8);
  v7 = *(_QWORD *)(v6 + 64);
  MEMORY[0x1E0C80A78](a1);
  v11 = (void *)(v10 + v9);
  if ((*(_BYTE *)(v6 + 80) & (v10 + v9)) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "storeBytes to misaligned raw pointer", 36, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x5DEuLL, 0);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))((char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v8, a5);
  (*(void (**)(char *, uint64_t))(v6 + 8))((char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), a5);
  if ((v7 & 0x8000000000000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  return memcpy(v11, (char *)v13 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
}

void _UTFParser<>.parseScalar<A>(from:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _QWORD *a7@<X8>)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  const char *AssociatedConformanceWitness;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t (*v54)(uint64_t, uint64_t);
  uint64_t (*v55)(uint64_t, uint64_t);
  uint64_t v56;
  uint64_t (*v57)(uint64_t, uint64_t);
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  size_t v61;
  _BYTE *v62;
  unsigned int v63;
  void (*v64)(uint64_t (*)(uint64_t, uint64_t), char *, unint64_t);
  unint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void (*v69)(uint64_t, void (*)(_QWORD, _QWORD), uint64_t, unint64_t, uint64_t);
  void (*v70)(_QWORD, _QWORD);
  uint64_t v71;
  uint64_t v72;
  _BYTE *v73;
  void (*v74)(_QWORD, _QWORD);
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  void (*v81)(int *, _QWORD);
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  char v97;
  uint64_t v98;
  char *v99;
  char *v100;
  char *v101;
  const char *v102;
  unint64_t v103;
  unint64_t v104;
  char *v105;
  void (*v106)(char *, uint64_t);
  uint64_t (*v107)(uint64_t, uint64_t);
  void (*v108)(char *, char *, uint64_t);
  char v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  const char *v113;
  unint64_t v114;
  unint64_t v115;
  char *v116;
  char *v117;
  char *v118;
  void (*v119)(char *, uint64_t);
  char *v120;
  unsigned int v121;
  char *v122;
  void (*v123)(unsigned int *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  unint64_t v124;
  char v125;
  unsigned int v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  int v128;
  void (*v129)(char *, uint64_t);
  void (*v130)(char *, char *, uint64_t);
  char *v131;
  char *v132;
  const char *v133;
  unint64_t v134;
  unint64_t v135;
  char *v136;
  void (*v137)(char *, uint64_t, const char *);
  char *v138;
  const char *v139;
  char *v140;
  char *v141;
  char v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  const char *v146;
  unint64_t v147;
  unint64_t v148;
  char *v149;
  char *v150;
  void (*v151)(char *, uint64_t);
  unsigned int v152;
  char *v153;
  unsigned int v154;
  BOOL v155;
  void (*v156)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v157;
  char v158;
  char *v159;
  unsigned int v160;
  char *v161;
  int v162;
  char v163;
  unint64_t v164;
  uint64_t (*v165)(uint64_t, unint64_t);
  uint64_t v166;
  uint64_t v167;
  void (*v168)(uint64_t, uint64_t);
  unsigned __int8 v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  void (*v177)(char *, uint64_t, uint64_t);
  char *v178;
  unsigned int v179;
  char v180;
  uint64_t v181;
  void (*v182)(char *, uint64_t);
  void (*v183)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v184)(uint64_t, uint64_t);
  unsigned int v185;
  unint64_t v186;
  uint64_t (*v187)(int *, uint64_t, uint64_t);
  void (*v188)(int *, _QWORD);
  _DWORD *v189;
  void (*v190)(int *, _QWORD);
  uint64_t v191;
  _BYTE *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  unint64_t v196;
  unint64_t *v197;
  uint64_t v198;
  void (*v199)(int *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  uint64_t v200;
  uint64_t v201;
  unint64_t v202;
  char *v203;
  uint64_t v204;
  uint64_t (*v205)(char *, unint64_t *, const char *);
  char v206;
  uint64_t v207;
  void (*v208)(uint64_t, uint64_t);
  void (*v209)(int *, _QWORD);
  unint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t WitnessTable;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  void (*v217)(uint64_t, void (*)(_QWORD, _QWORD), uint64_t, unint64_t, uint64_t);
  void (*v218)(_QWORD, _QWORD);
  uint64_t v219;
  uint64_t v220;
  _BYTE *v221;
  void (*v222)(_QWORD, _QWORD);
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  unsigned int v226;
  char *v227;
  unint64_t v228;
  unsigned __int8 v229;
  unsigned __int8 v230;
  char *v231;
  uint64_t v232;
  uint64_t v233;
  _BYTE *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  unint64_t v238;
  void (*v239)(int *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  uint64_t v240;
  char *v241;
  uint64_t v242;
  char *v243;
  char *v244;
  uint64_t v245;
  uint64_t v246;
  unint64_t v247;
  _QWORD *v248;
  char *v249;
  char *v250;
  char *v251;
  uint64_t v252;
  void (*v253)(uint64_t, uint64_t);
  unint64_t *v254;
  char *v255;
  uint64_t v256;
  char *v257;
  char *v258;
  unint64_t v259;
  const char *v260;
  char *v261;
  unint64_t v262;
  const char *v263;
  uint64_t v264;
  uint64_t v265;
  char *v266;
  uint64_t v267;
  unint64_t v268;
  void (*v269)(_QWORD, _QWORD);
  char *v270;
  unint64_t v271;
  uint64_t v272;
  uint64_t v273;
  char *v274;
  uint64_t v275;
  uint64_t v276;
  void (*v277)(char *, unint64_t);
  char *v278;
  unsigned int v279;
  char v280;
  int v281;

  v276 = a6;
  v267 = a5;
  v264 = a1;
  v265 = a3;
  v248 = a7;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a2, (uint64_t)&protocol requirements base descriptor for _UTFParser, associated type descriptor for _UTFParser.Encoding);
  AssociatedConformanceWitness = (const char *)swift_getAssociatedConformanceWitness(a4, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UTFParser, (uint64_t)&associated conformance descriptor for _UTFParser._UTFParser.Encoding: _UnicodeEncoding);
  v247 = swift_getAssociatedTypeWitness(0, AssociatedConformanceWitness, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  v242 = *(_QWORD *)(v247 - 8);
  v12 = MEMORY[0x1E0C80A78](v247);
  v257 = (char *)&v237 - v13;
  v240 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](v12);
  v241 = (char *)&v237 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = swift_getAssociatedTypeWitness(255, AssociatedConformanceWitness, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.CodeUnit);
  v260 = AssociatedConformanceWitness;
  v259 = AssociatedTypeWitness;
  v271 = swift_getAssociatedConformanceWitness((uint64_t)AssociatedConformanceWitness, AssociatedTypeWitness, v15, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger);
  v16 = *(_QWORD *)(v271 + 8);
  v263 = *(const char **)(*(_QWORD *)(v16 + 24) + 16);
  v262 = swift_getAssociatedTypeWitness(0, v263, v15, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v262);
  v261 = (char *)&v237 - v17;
  v269 = (void (*)(_QWORD, _QWORD))type metadata accessor for CollectionOfOne(0, v15, v18, v19);
  MEMORY[0x1E0C80A78](v269);
  v268 = (unint64_t)&v237 - v20;
  v246 = type metadata accessor for Optional(0, v15, v21, v22);
  v245 = *(_QWORD *)(v246 - 8);
  v23 = MEMORY[0x1E0C80A78](v246);
  v255 = (char *)&v237 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  v25 = MEMORY[0x1E0C80A78](v23);
  v27 = (char *)&v237 - v26;
  v28 = *(_QWORD *)(v15 - 8);
  v29 = MEMORY[0x1E0C80A78](v25);
  v244 = (char *)&v237 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
  v31 = MEMORY[0x1E0C80A78](v29);
  v243 = (char *)&v237 - v32;
  v33 = MEMORY[0x1E0C80A78](v31);
  v249 = (char *)&v237 - v34;
  v35 = MEMORY[0x1E0C80A78](v33);
  v250 = (char *)&v237 - v36;
  v37 = MEMORY[0x1E0C80A78](v35);
  v270 = (char *)&v237 - v38;
  v39 = MEMORY[0x1E0C80A78](v37);
  v258 = (char *)&v237 - v40;
  v41 = MEMORY[0x1E0C80A78](v39);
  v251 = (char *)&v237 - v42;
  v43 = MEMORY[0x1E0C80A78](v41);
  v45 = (char *)&v237 - v44;
  v46 = MEMORY[0x1E0C80A78](v43);
  v278 = (char *)&v237 - v47;
  v48 = MEMORY[0x1E0C80A78](v46);
  v50 = (char *)&v237 - v49;
  v51 = MEMORY[0x1E0C80A78](v48);
  v274 = (char *)&v237 - v52;
  MEMORY[0x1E0C80A78](v51);
  v54 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v237 - v53);
  v55 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 40);
  v272 = v7;
  v273 = a2;
  v56 = a2;
  v57 = v55;
  v256 = a4;
  v58 = v55(v56, a4);
  v275 = v28;
  if ((v58 & 0xFF00000000) != 0)
  {
    v266 = v50;
    v197 = swift_checkMetadataState(0, v259);
    v78 = v256;
    v198 = v57(v273, v256);
    v281 = v198;
    v253 = (void (*)(uint64_t, uint64_t))v57;
    v199 = *(void (**)(int *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v16 + 96);
    v202 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v198, v200, v201);
    v203 = v274;
    v238 = v202;
    v239 = v199;
    ((void (*)(int *, ValueMetadata *))v199)(&v281, &type metadata for UInt32);
    v204 = (uint64_t)v260;
    v205 = (uint64_t (*)(char *, unint64_t *, const char *))*((_QWORD *)v260 + 14);
    v254 = v197;
    v206 = v205(v203, v197, v260);
    v277 = *(void (**)(char *, unint64_t))(v28 + 8);
    v277(v203, v15);
    if ((v206 & 1) != 0)
    {
      v207 = v273;
      v208 = v253;
      v281 = ((uint64_t (*)(uint64_t, uint64_t))v253)(v273, v78);
      v239(&v281, &type metadata for UInt32, v238, v15, v16);
      v208(v207, v78);
      LOBYTE(v279) = 0;
      v209 = (void (*)(int *, _QWORD))(*(uint64_t (**)(int *, uint64_t, uint64_t))(v78 + 56))(&v281, v207, v78);
      v210 = swift_getAssociatedConformanceWitness(v204, (uint64_t)v254, v15, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
      v211 = type metadata accessor for _UIntBuffer(0, v15, v271, v210);
      WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, v211, v212);
      v214 = (uint64_t)v266;
      RangeReplaceableCollection.remove(at:)((uint64_t)&v279, v211, WitnessTable, (uint64_t)v266);
      v277((char *)v214, v15);
      v209(&v281, 0);
      v215 = v268;
      (*(void (**)(unint64_t, char *, unint64_t))(v28 + 32))(v268, v203, v15);
      v216 = v276;
      v217 = *(void (**)(uint64_t, void (*)(_QWORD, _QWORD), uint64_t, unint64_t, uint64_t))(v276 + 56);
      v218 = v269;
      v220 = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v269, v219);
      v221 = v248;
      v222 = v218;
      v223 = v247;
      v217(v215, v222, v220, v247, v216);
      v61 = type metadata accessor for Unicode.ParseResult(0, v223, v224, v225);
      v62 = v221;
LABEL_51:
      v63 = 0;
      goto LABEL_52;
    }
    v254 = *(unint64_t **)(v267 + 16);
    v83 = v271;
  }
  else
  {
    v254 = *(unint64_t **)(v267 + 16);
    ((void (*)(uint64_t))v254)(v265);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v28 + 48))(v27, 1, v15) == 1)
    {
      (*(void (**)(char *, uint64_t))(v245 + 8))(v27, v246);
LABEL_4:
      v61 = type metadata accessor for Unicode.ParseResult(0, v247, v59, v60);
      v62 = v248;
      v63 = 2;
      goto LABEL_52;
    }
    v253 = (void (*)(uint64_t, uint64_t))v57;
    v64 = *(void (**)(uint64_t (*)(uint64_t, uint64_t), char *, unint64_t))(v28 + 32);
    v64(v54, v27, v15);
    v65 = swift_checkMetadataState(0, v259);
    v66 = (uint64_t)v260;
    if (((*((uint64_t (**)(uint64_t (*)(uint64_t, uint64_t), unint64_t *, const char *))v260
           + 14))(v54, v65, v260) & 1) != 0)
    {
      v67 = v268;
      v64((uint64_t (*)(uint64_t, uint64_t))v268, (char *)v54, v15);
      v68 = v276;
      v69 = *(void (**)(uint64_t, void (*)(_QWORD, _QWORD), uint64_t, unint64_t, uint64_t))(v276 + 56);
      v70 = v269;
      v72 = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v269, v71);
      v73 = v248;
      v74 = v70;
      v75 = v247;
      v69(v67, v74, v72, v247, v68);
      v61 = type metadata accessor for Unicode.ParseResult(0, v75, v76, v77);
      v62 = v73;
      goto LABEL_51;
    }
    v78 = v256;
    v79 = (*(uint64_t (**)(int *, uint64_t, uint64_t))(v256 + 56))(&v281, v273, v256);
    v80 = v66;
    v81 = (void (*)(int *, _QWORD))v79;
    v82 = swift_getAssociatedConformanceWitness(v80, (uint64_t)v65, v15, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
    v83 = v271;
    v84 = type metadata accessor for _UIntBuffer(0, v15, v271, v82);
    _UIntBuffer.append(_:)(v54, v84);
    v277 = *(void (**)(char *, unint64_t))(v28 + 8);
    v277((char *)v54, v15);
    v81(&v281, 0);
  }
  v85 = v15;
  v86 = v274;
  v87 = v255;
  v266 = v45;
  v268 = v15;
  v252 = v16;
  while (1)
  {
    ((void (*)(uint64_t, uint64_t))v254)(v265, v267);
    v88 = v275;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v275 + 48))(v87, 1, v85) == 1)
      break;
    (*(void (**)(char *, char *, uint64_t))(v88 + 32))(v278, v87, v85);
    v269 = (void (*)(_QWORD, _QWORD))(*(uint64_t (**)(int *, uint64_t, uint64_t))(v78 + 56))(&v281, v273, v78);
    v90 = v89;
    v91 = *(_BYTE *)(v89 + 4);
    v279 = *(_DWORD *)v89;
    v280 = v91;
    v92 = swift_getAssociatedConformanceWitness((uint64_t)v260, v259, v85, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: UnsignedInteger);
    v93 = type metadata accessor for _UIntBuffer(0, v85, v83, v92);
    v95 = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, v93, v94);
    v96 = Collection.count.getter(v93, v95);
    if (__OFADD__(v96, 1))
    {
      __break(1u);
LABEL_56:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    }
    if (specialized _UIntBuffer.capacity.getter(v85, v83) < v96 + 1)
      goto LABEL_56;
    (*(void (**)(uint64_t, uint64_t))(v83 + 64))(v85, v83);
    v276 = *(_QWORD *)(v16 + 64);
    v97 = ((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16);
    v98 = v275;
    v99 = v258;
    if ((v97 & 1) != 0)
    {
      v100 = v45;
      v101 = v251;
      (*(void (**)(char *, char *, uint64_t))(v275 + 16))(v251, v100, v85);
      v102 = v263;
      v103 = v262;
      v104 = swift_getAssociatedConformanceWitness((uint64_t)v263, v85, v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v105 = v261;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v104 + 8))(&unk_1816B7DA8, 256, v103, v104);
      (*((void (**)(char *, uint64_t, const char *))v102 + 3))(v105, v85, v102);
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v16 + 32) + 8) + 32))(v101, v86, v85);
      v106 = (void (*)(char *, uint64_t))v277;
      v277(v86, v85);
      if ((v103 & 1) == 0)
        goto LABEL_57;
      v106(v101, v85);
      v45 = v266;
    }
    v107 = *(uint64_t (**)(uint64_t, uint64_t))(v16 + 128);
    if (v107(v85, v16) >= 32)
    {
      v108 = *(void (**)(char *, char *, uint64_t))(v98 + 16);
      v108(v99, v45, v85);
      v279 = -1;
      v109 = ((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16);
      v110 = v107(v85, v16);
      if ((v109 & 1) != 0)
      {
        if (v110 <= 32)
        {
          v113 = v263;
          v85 = v268;
          v114 = v262;
          v115 = swift_getAssociatedConformanceWitness((uint64_t)v263, v268, v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v116 = v261;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v115 + 8))(&unk_1816B7DA8, 256, v114, v115);
          v117 = v116;
          v86 = v274;
          (*((void (**)(char *, uint64_t, const char *))v113 + 3))(v117, v85, v113);
          LODWORD(v239) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v16 + 32) + 8)
                                                                             + 40))(v99, v86, v85);
          v118 = v99;
          v119 = (void (*)(char *, uint64_t))v277;
          v277(v86, v85);
          LODWORD(v238) = v279;
          v120 = v244;
          v108(v244, v118, v85);
          if ((v239 & 1) != 0)
          {
            v121 = (*(uint64_t (**)(uint64_t, uint64_t))(v16 + 120))(v85, v16);
            v119(v120, v85);
            v155 = v238 >= v121;
            v98 = v275;
            v122 = v258;
            if (!v155)
              goto LABEL_58;
          }
          else
          {
            v119(v120, v85);
            v98 = v275;
            v122 = v258;
          }
LABEL_27:
          v119(v122, v85);
          goto LABEL_28;
        }
      }
      else if (v110 <= 32)
      {
        v85 = v268;
        v108(v86, v99, v268);
        v126 = (*(uint64_t (**)(uint64_t, uint64_t))(v16 + 120))(v85, v16);
        v122 = v99;
        v119 = (void (*)(char *, uint64_t))v277;
        v277(v86, v85);
        v98 = v275;
        if (v279 < v126)
          goto LABEL_58;
        goto LABEL_27;
      }
      v123 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v16 + 96);
      v124 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v110, v111, v112);
      v85 = v268;
      v123(&v279, &type metadata for UInt32, v124, v268, v16);
      v125 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v16 + 32) + 8) + 16))(v86, v99, v85);
      v122 = v99;
      v119 = (void (*)(char *, uint64_t))v277;
      v277(v86, v85);
      v98 = v275;
      if ((v125 & 1) != 0)
        goto LABEL_58;
      goto LABEL_27;
    }
LABEL_28:
    v127 = *(uint64_t (**)(uint64_t, uint64_t))(v16 + 120);
    v128 = v127(v85, v16);
    v129 = (void (*)(char *, uint64_t))v277;
    v277(v45, v85);
    *(_DWORD *)v90 &= ~(v128 << *(_BYTE *)(v90 + 4));
    v130 = *(void (**)(char *, char *, uint64_t))(v98 + 16);
    v131 = v270;
    v130(v270, v278, v85);
    if ((((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16) & 1) != 0)
    {
      v132 = v250;
      v130(v250, v131, v85);
      v133 = v263;
      v134 = v262;
      v135 = swift_getAssociatedConformanceWitness((uint64_t)v263, v85, v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v136 = v261;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v135 + 8))(&unk_1816B7DA8, 256, v134, v135);
      v137 = (void (*)(char *, uint64_t, const char *))*((_QWORD *)v133 + 3);
      v138 = v136;
      v86 = v274;
      v139 = v133;
      v140 = v132;
      v129 = (void (*)(char *, uint64_t))v277;
      v137(v138, v85, v139);
      LOBYTE(v134) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v16 + 32) + 8) + 32))(v140, v86, v85);
      v129(v86, v85);
      if ((v134 & 1) == 0)
LABEL_57:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
      v129(v140, v85);
      v131 = v270;
    }
    if (v107(v85, v16) >= 32)
    {
      v141 = v249;
      v130(v249, v131, v85);
      v279 = -1;
      v142 = ((uint64_t (*)(uint64_t, uint64_t))v276)(v85, v16);
      v143 = v107(v85, v16);
      if ((v142 & 1) != 0)
      {
        if (v143 <= 32)
        {
          v146 = v263;
          v147 = v262;
          v148 = swift_getAssociatedConformanceWitness((uint64_t)v263, v85, v262, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v149 = v261;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v148 + 8))(&unk_1816B7DA8, 256, v147, v148);
          (*((void (**)(char *, uint64_t, const char *))v146 + 3))(v149, v85, v146);
          LOBYTE(v147) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v16 + 32) + 8)
                                                                            + 40))(v141, v86, v85);
          v150 = v86;
          v151 = (void (*)(char *, uint64_t))v277;
          v277(v150, v85);
          v152 = v279;
          v153 = v243;
          v130(v243, v141, v85);
          if ((v147 & 1) != 0)
          {
            v154 = v127(v85, v16);
            v151(v153, v85);
            v155 = v152 >= v154;
LABEL_40:
            v131 = v270;
            if (!v155)
LABEL_58:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
          }
          else
          {
            v151(v153, v85);
            v131 = v270;
          }
LABEL_43:
          v151(v141, v85);
          v129 = v151;
          goto LABEL_44;
        }
      }
      else if (v143 <= 32)
      {
        v130(v86, v141, v85);
        v160 = v127(v85, v16);
        v161 = v86;
        v151 = (void (*)(char *, uint64_t))v277;
        v277(v161, v85);
        v155 = v279 >= v160;
        goto LABEL_40;
      }
      v156 = *(void (**)(unsigned int *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v16 + 96);
      v157 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v143, v144, v145);
      v156(&v279, &type metadata for UInt32, v157, v85, v16);
      v158 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v16 + 32) + 8) + 16))(v86, v141, v85);
      v159 = v86;
      v151 = (void (*)(char *, uint64_t))v277;
      v277(v159, v85);
      v131 = v270;
      if ((v158 & 1) != 0)
        goto LABEL_58;
      goto LABEL_43;
    }
LABEL_44:
    v129(v278, v85);
    v162 = v127(v85, v16);
    v129(v131, v85);
    v163 = *(_BYTE *)(v90 + 4);
    *(_DWORD *)v90 |= v162 << v163;
    v164 = v271;
    v165 = *(uint64_t (**)(uint64_t, unint64_t))(v271 + 56);
    *(_BYTE *)(v90 + 4) = v163 + v165(v85, v271);
    v269(&v281, 0);
    v166 = v273;
    v167 = v256;
    v168 = v253;
    v169 = (unint64_t)((uint64_t (*)(uint64_t, uint64_t))v253)(v273, v256) >> 32;
    v170 = v165(v85, v164);
    if (!v170 || (v171 = v170, v78 = v167, v168(v166, v167), (v172 = v165(v85, v164)) == 0))
    {
      v196 = 14377;
      goto LABEL_54;
    }
    v173 = v169 / v171;
    v83 = v271;
    v16 = v252;
    v86 = v274;
    v87 = v255;
    v45 = v266;
    v85 = v268;
    if (v173 >= 32 / v172)
      goto LABEL_49;
  }
  (*(void (**)(char *, uint64_t))(v245 + 8))(v87, v246);
  if ((((uint64_t (*)(uint64_t, uint64_t))v253)(v273, v78) & 0xFF00000000) == 0)
    goto LABEL_4;
LABEL_49:
  v175 = v272;
  v174 = v273;
  v176 = v240;
  v177 = *(void (**)(char *, uint64_t, uint64_t))(v240 + 16);
  v178 = v241;
  v177(v241, v272, v273);
  v179 = (*(uint64_t (**)(uint64_t, uint64_t))(v78 + 24))(v174, v78);
  v180 = v179;
  v278 = (char *)(v179 >> 8);
  v181 = BYTE1(v179);
  v182 = *(void (**)(char *, uint64_t))(v176 + 8);
  v182(v178, v174);
  v177(v178, v175, v174);
  v183 = *(void (**)(uint64_t, uint64_t, uint64_t))(v78 + 32);
  LODWORD(v277) = v181;
  v183(v181, v174, v78);
  v182(v178, v174);
  v184 = (uint64_t (*)(uint64_t, uint64_t))v253;
  v185 = ((uint64_t (*)(uint64_t, uint64_t))v253)(v174, v78);
  LOBYTE(v181) = (_BYTE)v278;
  v186 = (unint64_t)v185 >> (char)v278;
  v187 = *(uint64_t (**)(int *, uint64_t, uint64_t))(v78 + 56);
  v188 = (void (*)(int *, _QWORD))v187(&v281, v174, v78);
  *v189 = v186;
  v188(&v281, 0);
  LOBYTE(v181) = ((unint64_t)v184(v174, v78) >> 32) - v181;
  v190 = (void (*)(int *, _QWORD))v187(&v281, v174, v78);
  *(_BYTE *)(v191 + 4) = v181;
  v190(&v281, 0);
  if ((v180 & 1) != 0)
  {
    v192 = v248;
    v193 = v247;
    (*(void (**)(_QWORD *, char *, unint64_t))(v242 + 32))(v248, v257, v247);
    v61 = type metadata accessor for Unicode.ParseResult(0, v193, v194, v195);
    v62 = v192;
    goto LABEL_51;
  }
  v226 = v277;
  v227 = v257;
  v228 = (*(uint64_t (**)(uint64_t))(v271 + 56))(v85);
  v229 = specialized numericCast<A, B>(_:)(v228);
  if (!v229)
  {
    v196 = 480;
LABEL_54:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, v196, 0);
  }
  v230 = v229;
  v231 = v227;
  v232 = v247;
  (*(void (**)(char *, unint64_t))(v242 + 8))(v231, v247);
  v233 = v226 / v230;
  v234 = v248;
  *v248 = v233;
  v61 = type metadata accessor for Unicode.ParseResult(0, v232, v235, v236);
  v62 = v234;
  v63 = 1;
LABEL_52:
  swift_storeEnumTagMultiPayload(v62, v61, v63);
}

uint64_t static UInt8.% infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  return a1 % a2;
}

uint64_t static UInt8./ infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  return a1 / a2;
}

uint64_t static Unicode.UTF8.encodedReplacementCharacter.getter()
{
  return 12501232;
}

uint64_t static _ValidUTF8Buffer.encodedReplacementCharacter.getter()
{
  return 12501232;
}

BOOL static Unicode.UTF8._isScalar(_:)(char a1)
{
  return (a1 & 0x80) == 0;
}

uint64_t static Unicode.UTF8.decode(_:)(unsigned int a1)
{
  uint64_t v1;
  unsigned int v2;

  v1 = 4 - (__clz(a1) >> 3);
  v2 = a1 - 1;
  if (v1 != 1)
    v2 = ((a1 - 16843009) >> 10) & 0xFC0 | ((a1 - 16843009) >> 24) & 0x3F | ((((a1 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((a1 - 16843009) & 7) << 18);
  if (v1 == 2)
    v2 = (((a1 - 257) & 0x1F) << 6) | ((a1 - 257) >> 8) & 0x3F;
  if (v1 == 3)
    return ((a1 - 65793) >> 2) & 0xFC0 | ((a1 - 65793) >> 16) & 0x3F | (((a1 - 65793) & 0xF) << 12);
  else
    return v2;
}

uint64_t static UInt32.&>> infix(_:_:)(unsigned int a1, char a2)
{
  return a1 >> a2;
}

Swift::_ValidUTF8Buffer __swiftcall _ValidUTF8Buffer.init(_containing:)(Swift::UInt8 _containing)
{
  return (Swift::_ValidUTF8Buffer)(_containing + 1);
}

_DWORD *static UInt32.&>>= infix(_:_:)(_DWORD *result, char a2)
{
  *result >>= a2;
  return result;
}

uint64_t static Unicode.UTF8.transcode<A>(_:from:)(unsigned int *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;

  if (a3 != &type metadata for Unicode.UTF16)
  {
    if (a3 != &type metadata for Unicode.UTF8)
      goto LABEL_15;
    if ((ValueMetadata *)swift_getAssociatedTypeWitness(0, (const char *)a4, (uint64_t)&type metadata for Unicode.UTF8, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar) == &type metadata for _ValidUTF8Buffer)return *a1;
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
  }
  v7 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
  if (swift_getAssociatedTypeWitness(0, (const char *)a4, (uint64_t)&type metadata for Unicode.UTF16, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar) != v7)goto LABEL_9;
  v8 = *a1;
  v9 = (unsigned __int16)*a1;
  if (v9 <= 0x7F)
    return (v8 + 1);
  v12 = (*a1 & 0x3F) << 8;
  if (v9 <= 0x7FF)
  {
    v13 = v12 | (v9 >> 6);
    return (v13 + 33217);
  }
  if ((*a1 & 0xF800) != 0xD800)
    return (((v12 | (v9 >> 6) & 0x3F) << 8) | ((unsigned __int16)v8 >> 12)) + 8487393;
LABEL_15:
  v14 = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a4 + 88))(a1, a3, a4);
  if (v14 <= 0x7F)
    return v14 + 1;
  v15 = (v14 & 0x3F) << 8;
  if (v14 <= 0x7FF)
  {
    v13 = v15 | (v14 >> 6);
    return (v13 + 33217);
  }
  v16 = (v15 | (v14 >> 6) & 0x3F) << 8;
  v17 = (((v16 | (v14 >> 12) & 0x3F) << 8) | (v14 >> 18)) - 2122219023;
  v10 = (v16 | (v14 >> 12)) + 8487393;
  if (HIWORD(v14))
    return v17;
  return v10;
}

BOOL static UInt16.< infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a1 < a2;
}

_WORD *static UInt16.&>>= infix(_:_:)(_WORD *result, char a2)
{
  *result = (unsigned __int16)*result >> (a2 & 0xF);
  return result;
}

uint64_t static UInt16.&>> infix(_:_:)(unsigned __int16 a1, char a2)
{
  return a1 >> (a2 & 0xF);
}

uint64_t Unicode.UTF8.ForwardParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t Unicode.UTF8.ForwardParser._buffer.setter(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)v1 = result;
  *(_BYTE *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t (*Unicode.UTF8.ForwardParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.UTF8.ForwardParser.init()()
{
  return 0;
}

uint64_t Unicode.UTF8.ReverseParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF8.ReverseParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF8(_DWORD *a1@<X8>)
{
  *a1 = 12501232;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF8(unsigned int *a1)
{
  uint64_t v1;
  unsigned int v2;

  v1 = 4 - (__clz(*a1) >> 3);
  v2 = *a1 - 1;
  if (v1 != 1)
    v2 = ((*a1 - 16843009) >> 10) & 0xFC0 | ((*a1 - 16843009) >> 24) & 0x3F | ((((*a1 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((*a1 - 16843009) & 7) << 18);
  if (v1 == 2)
    v2 = (((*a1 - 257) & 0x1F) << 6) | ((*a1 - 257) >> 8) & 0x3F;
  if (v1 == 3)
    return ((*a1 - 65793) >> 2) & 0xFC0 | ((*a1 - 65793) >> 16) & 0x3F | (((*a1 - 65793) & 0xF) << 12);
  else
    return v2;
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF8@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;

  if (result > 0x7F)
  {
    v3 = (result & 0x3F) << 8;
    if (result >= 0x800)
    {
      v4 = (v3 | (result >> 6) & 0x3F) << 8;
      v5 = (((v4 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
      v2 = (v4 | (result >> 12)) + 8487393;
      if (WORD1(result))
        v2 = v5;
    }
    else
    {
      v2 = (v3 | (result >> 6)) + 33217;
    }
  }
  else
  {
    v2 = result + 1;
  }
  *(_DWORD *)a2 = v2;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

unint64_t protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF8@<X0>(int *a1@<X0>, ValueMetadata *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  ValueMetadata *v4;
  uint64_t v9;
  unint64_t result;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;

  if (a2 != &type metadata for Unicode.UTF16)
  {
    if (a2 != v4)
      goto LABEL_15;
    result = swift_getAssociatedTypeWitness(0, (const char *)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if ((ValueMetadata *)result == &type metadata for _ValidUTF8Buffer)
    {
      v13 = *a1;
      goto LABEL_5;
    }
LABEL_9:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
  }
  v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _UIntBuffer<UInt16>);
  result = swift_getAssociatedTypeWitness(0, (const char *)a3, (uint64_t)&type metadata for Unicode.UTF16, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  if (result != v9)
    goto LABEL_9;
  v11 = *a1;
  v12 = (unsigned __int16)*a1;
  if (v12 <= 0x7F)
  {
    v13 = (v11 + 1);
    goto LABEL_5;
  }
  v14 = (*a1 & 0x3F) << 8;
  if (v12 < 0x800)
  {
    v15 = v14 | (v12 >> 6);
LABEL_12:
    v13 = v15 + 33217;
    goto LABEL_5;
  }
  if ((*a1 & 0xF800) != 0xD800)
  {
    v13 = (((v14 | (v12 >> 6) & 0x3F) << 8) | ((unsigned __int16)v11 >> 12)) + 8487393;
    goto LABEL_5;
  }
LABEL_15:
  result = (*(uint64_t (**)(int *, ValueMetadata *, uint64_t))(a3 + 88))(a1, a2, a3);
  if (result <= 0x7F)
  {
    v13 = result + 1;
    goto LABEL_5;
  }
  v16 = (result & 0x3F) << 8;
  if (result <= 0x7FF)
  {
    v15 = v16 | (result >> 6);
    goto LABEL_12;
  }
  v17 = (v16 | (result >> 6) & 0x3F) << 8;
  v18 = (((v17 | (result >> 12) & 0x3F) << 8) | (result >> 18)) - 2122219023;
  v13 = (v17 | (result >> 12)) + 8487393;
  if (WORD1(result))
    v13 = v18;
LABEL_5:
  *(_DWORD *)a4 = v13;
  *(_BYTE *)(a4 + 4) = 0;
  return result;
}

uint64_t protocol witness for static _UnicodeEncoding._isScalar(_:) in conformance Unicode.UTF8(unsigned __int8 *a1)
{
  return (*a1 >> 7) ^ 1u;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF8.ReverseParser._parseMultipleCodeUnits()()
{
  int v0;
  Swift::UInt8 v1;
  Swift::Bool v2;
  Swift::tuple_isValid_Bool_bitCount_UInt8 result;

  if ((v0 & 0xE0C0) == 0xC080)
  {
    if ((v0 & 0x1E00) != 0)
    {
LABEL_11:
      v2 = 1;
      goto LABEL_12;
    }
  }
  else if ((v0 & 0xF0C0C0) == 0xE08080)
  {
    if ((v0 & 0xF2000) != 0 && (v0 & 0xF2000) != 0xD2000)
      goto LABEL_11;
  }
  else if ((v0 & 0xF8C0C0C0) == 0xF0808080 && ((v0 & 0x7300000u) - 67108865) >> 26 == 63)
  {
    goto LABEL_11;
  }
  Unicode.UTF8.ReverseParser._invalidLength()();
  v2 = 0;
LABEL_12:
  result.bitCount = v1;
  result.isValid = v2;
  return result;
}

uint64_t static UInt8.* infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result;

  result = a1 * a2;
  if ((result & 0xFF00) != 0)
    __break(1u);
  return result;
}

Swift::UInt8 __swiftcall Unicode.UTF8.ReverseParser._invalidLength()()
{
  int v0;

  if ((v0 & 0xF0C0) != 0xE080)
  {
    if ((v0 & 0xF8C0) == 0xF080)
    {
      if ((v0 & 0x730u) - 1025 >= 0xFFFFFC00)
        return 2;
    }
    else if ((v0 & 0xF8C0C0) == 0xF08080 && (v0 & 0x73000u) - 262145 > 0xFFFBFFFF)
    {
      return 3;
    }
    return 1;
  }
  if ((v0 & 0xF20) == 0xD20 || (v0 & 0xF20) == 0)
    return 1;
  else
    return 2;
}

Swift::_ValidUTF8Buffer __swiftcall Unicode.UTF8.ReverseParser._bufferedScalar(bitCount:)(Swift::UInt8 bitCount)
{
  unsigned int v1;

  return (Swift::_ValidUTF8Buffer)((bswap32(v1) + 16843009) >> -bitCount);
}

uint64_t UInt32.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1);
}

_QWORD *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF8.ReverseParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *(*v9)(_QWORD *__return_ptr, uint64_t, uint64_t);
  _QWORD *result;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  char v17;
  Swift::UInt8 v18;
  unsigned __int8 v19;
  unsigned int v20;
  uint64_t (*v21)();
  _QWORD v22[4];

  v5 = v4;
  if (*(_BYTE *)(v4 + 4))
  {
    v20 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0x80) != 0)
    {
      v9 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      result = v9(v22, a2, a3);
      goto LABEL_9;
    }
    lazy protocol witness table accessor for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser(a1, a2, a3);
    v21 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    result = (_QWORD *)((uint64_t (*)(_QWORD *, _QWORD))v21)(v22, 0);
    v12 = 0;
    v11 = (v20 + 1);
  }
  else
  {
    v9 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    result = v9(v22, a2, a3);
    if ((v22[0] & 0x100) != 0)
    {
LABEL_3:
      v11 = 0;
      v12 = 2;
      goto LABEL_27;
    }
    if ((v22[0] & 0x80) == 0)
    {
      v12 = 0;
      v11 = LOBYTE(v22[0]) + 1;
      goto LABEL_27;
    }
    v13 = *(unsigned __int8 *)(v4 + 4);
    if (v13 >= 0x20)
LABEL_29:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    *(_DWORD *)v4 = *(_DWORD *)v4 & ((-255 << v13) - 1) | (LOBYTE(v22[0]) << v13);
    *(_BYTE *)(v4 + 4) = v13 + 8;
    while (1)
    {
      result = v9(v22, a2, a3);
LABEL_9:
      if ((v22[0] & 0x100) != 0)
        break;
      v14 = *(unsigned __int8 *)(v4 + 4);
      if (v14 > 0x1F)
        goto LABEL_29;
      v15 = *(_DWORD *)v4 & ((-255 << v14) - 1) | (LOBYTE(v22[0]) << v14);
      *(_DWORD *)v4 = v15;
      v16 = v14 + 8;
      *(_BYTE *)(v4 + 4) = v14 + 8;
      if (v14 >= 0x18)
        goto LABEL_15;
    }
    v16 = *(_BYTE *)(v4 + 4);
    if (!v16)
      goto LABEL_3;
    v15 = *(_DWORD *)v4;
LABEL_15:
    if ((v15 & 0xE0C0) == 0xC080)
    {
      if ((v15 & 0x1E00) != 0)
      {
        v17 = 16;
LABEL_18:
        v12 = 0;
        *(_DWORD *)v4 = (unint64_t)v15 >> v17;
        *(_BYTE *)(v4 + 4) = v16 - v17;
        v11 = (bswap32(v15) + 16843009) >> (-v17 & 0x18);
        goto LABEL_27;
      }
    }
    else if ((v15 & 0xF0C0C0) == 0xE08080)
    {
      if ((v15 & 0xF2000) != 0 && (v15 & 0xF2000) != 0xD2000)
      {
        v17 = 24;
        goto LABEL_18;
      }
    }
    else if ((v15 & 0xF8C0C0C0) == 0xF0808080 && ((v15 & 0x7300000) - 67108865) >> 26 == 63)
    {
      v17 = 32;
      goto LABEL_18;
    }
    v18 = Unicode.UTF8.ReverseParser._invalidLength()();
    v19 = 8 * v18;
    *(_DWORD *)v5 = v15 >> (8 * (v18 & 0x1F));
    *(_BYTE *)(v5 + 4) = v16 - 8 * v18;
    result = (_QWORD *)specialized numericCast<A, B>(_:)(8uLL);
    if (!(_BYTE)result)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
    v12 = 1;
    v11 = v19 / result;
  }
LABEL_27:
  *(_QWORD *)a4 = v11;
  *(_BYTE *)(a4 + 8) = v12;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF8.ReverseParser()
{
  int *v0;
  int v1;
  int v2;
  int v3;
  int v4;

  v1 = *v0;
  if ((*v0 & 0xE0C0) != 0xC080)
  {
    if ((v1 & 0xF0C0C0) == 0xE08080)
    {
      if ((v1 & 0xF2000) != 0 && (v1 & 0xF2000) != 0xD2000)
      {
        v2 = 24;
        v3 = 1;
        return v3 | (v2 << 8);
      }
    }
    else if ((v1 & 0xF8C0C0C0) == 0xF0808080 && ((v1 & 0x7300000u) - 67108865) >> 26 == 63)
    {
      v2 = 32;
      v3 = 1;
      return v3 | (v2 << 8);
    }
LABEL_10:
    v4 = Unicode.UTF8.ReverseParser._invalidLength()();
    v3 = 0;
    v2 = 8 * v4;
    return v3 | (v2 << 8);
  }
  if ((v1 & 0x1E00) == 0)
    goto LABEL_10;
  v2 = 16;
  v3 = 1;
  return v3 | (v2 << 8);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF8.ReverseParser@<X0>(uint64_t result@<X0>, unsigned int *a2@<X8>)
{
  unsigned int *v2;

  *a2 = (bswap32(*v2) + 16843009) >> -(char)result;
  return result;
}

uint64_t (*protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser())()
{
  return EnumeratedSequence._base.modify;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF8.ForwardParser._parseMultipleCodeUnits()()
{
  int v0;
  Swift::Bool v1;
  Swift::UInt8 v2;
  Swift::tuple_isValid_Bool_bitCount_UInt8 result;

  if ((v0 & 0xC0E0) != 0x80C0)
  {
    if ((v0 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v0 & 0x200F) != 0 && (v0 & 0x200F) != 0x200D)
        goto LABEL_3;
    }
    else if ((v0 & 0xC0C0C0F8) == 0x808080F0 && (v0 & 0x3007) != 0 && __rev16(v0 & 0x3007) < 0x401)
    {
      goto LABEL_3;
    }
LABEL_11:
    Unicode.UTF8.ForwardParser._invalidLength()();
    v1 = 0;
    goto LABEL_12;
  }
  if ((v0 & 0x1E) == 0)
    goto LABEL_11;
LABEL_3:
  v1 = 1;
LABEL_12:
  result.bitCount = v2;
  result.isValid = v1;
  return result;
}

Swift::UInt8 __swiftcall Unicode.UTF8.ForwardParser._invalidLength()()
{
  int v0;
  int v1;
  Swift::UInt8 result;
  unsigned int v4;
  Swift::UInt8 v5;

  v1 = v0;
  if ((v0 & 0xC0F0) == 0x80E0)
  {
    if ((v0 & 0x200F) == 0x200D || (v0 & 0x200F) == 0)
      return 1;
    else
      return 2;
  }
  else if ((v0 & 0xC0F8) == 0x80F0)
  {
    result = 1;
    if ((v1 & 0x3007) != 0)
    {
      v4 = __rev16(v1 & 0x3007);
      if ((v1 & 0xC00000) == 0x800000)
        v5 = 3;
      else
        v5 = 2;
      if (v4 <= 0x400)
        return v5;
      else
        return 1;
    }
  }
  else
  {
    return 1;
  }
  return result;
}

Swift::_ValidUTF8Buffer __swiftcall Unicode.UTF8.ForwardParser._bufferedScalar(bitCount:)(Swift::UInt8 bitCount)
{
  int v1;

  return (Swift::_ValidUTF8Buffer)(((1 << ((bitCount + 1) >> 1) << (bitCount >> 1)) - 1) & (v1 + 16843009));
}

_QWORD *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF8.ForwardParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *(*v9)(_QWORD *__return_ptr, uint64_t, uint64_t);
  _QWORD *result;
  uint64_t v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  unsigned int v17;
  Swift::UInt8 v18;
  unsigned __int8 v19;
  unsigned int v20;
  uint64_t (*v21)();
  _QWORD v22[4];

  v5 = v4;
  if (*(_BYTE *)(v4 + 4))
  {
    v20 = *(_DWORD *)v4;
    if ((*(_DWORD *)v4 & 0x80) != 0)
    {
      v9 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      result = v9(v22, a2, a3);
      goto LABEL_9;
    }
    lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(a1, a2, a3);
    v21 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    result = (_QWORD *)((uint64_t (*)(_QWORD *, _QWORD))v21)(v22, 0);
    v12 = 0;
    v11 = (v20 + 1);
  }
  else
  {
    v9 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    result = v9(v22, a2, a3);
    if ((v22[0] & 0x100) != 0)
    {
LABEL_3:
      v11 = 0;
      v12 = 2;
      goto LABEL_29;
    }
    if ((v22[0] & 0x80) == 0)
    {
      v12 = 0;
      v11 = LOBYTE(v22[0]) + 1;
      goto LABEL_29;
    }
    v13 = *(unsigned __int8 *)(v4 + 4);
    if (v13 >= 0x20)
LABEL_30:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    *(_DWORD *)v4 = *(_DWORD *)v4 & ((-255 << v13) - 1) | (LOBYTE(v22[0]) << v13);
    *(_BYTE *)(v4 + 4) = v13 + 8;
    while (1)
    {
      result = v9(v22, a2, a3);
LABEL_9:
      if ((v22[0] & 0x100) != 0)
        break;
      v14 = *(unsigned __int8 *)(v4 + 4);
      if (v14 > 0x1F)
        goto LABEL_30;
      v15 = *(_DWORD *)v4 & ((-255 << v14) - 1) | (LOBYTE(v22[0]) << v14);
      *(_DWORD *)v4 = v15;
      v16 = v14 + 8;
      *(_BYTE *)(v4 + 4) = v14 + 8;
      if (v14 >= 0x18)
        goto LABEL_15;
    }
    v16 = *(_BYTE *)(v4 + 4);
    if (!v16)
      goto LABEL_3;
    v15 = *(_DWORD *)v4;
LABEL_15:
    if ((v15 & 0xC0E0) == 0x80C0)
    {
      if ((v15 & 0x1E) != 0)
      {
        v17 = 16;
LABEL_18:
        v12 = 0;
        *(_DWORD *)v4 = (unint64_t)v15 >> v17;
        *(_BYTE *)(v4 + 4) = v16 - v17;
        v11 = ((1 << (v17 >> 1) << (v17 >> 1)) - 1) & (v15 + 16843009);
        goto LABEL_29;
      }
    }
    else if ((v15 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v15 & 0x200F) != 0 && (v15 & 0x200F) != 0x200D)
      {
        v17 = 24;
        goto LABEL_18;
      }
    }
    else if ((v15 & 0xC0C0C0F8) == 0x808080F0 && (v15 & 0x3007) != 0 && __rev16(v15 & 0x3007) <= 0x400)
    {
      v17 = 32;
      goto LABEL_18;
    }
    v18 = Unicode.UTF8.ForwardParser._invalidLength()();
    v19 = 8 * v18;
    *(_DWORD *)v5 = v15 >> (8 * (v18 & 0x1F));
    *(_BYTE *)(v5 + 4) = v16 - 8 * v18;
    result = (_QWORD *)specialized numericCast<A, B>(_:)(8uLL);
    if (!(_BYTE)result)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
    v12 = 1;
    v11 = v19 / result;
  }
LABEL_29:
  *(_QWORD *)a4 = v11;
  *(_BYTE *)(a4 + 8) = v12;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF8.ForwardParser()
{
  int *v0;
  int v1;
  int v2;
  int v3;
  int v4;

  v1 = *v0;
  if ((*v0 & 0xC0E0) != 0x80C0)
  {
    if ((v1 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v1 & 0x200F) != 0 && (*v0 & 0x200F) != 0x200D)
      {
        v2 = 24;
        v3 = 1;
        return v3 | (v2 << 8);
      }
    }
    else if ((v1 & 0xC0C0C0F8) == 0x808080F0 && (v1 & 0x3007) != 0 && __rev16(*v0 & 0x3007) <= 0x400)
    {
      v2 = 32;
      v3 = 1;
      return v3 | (v2 << 8);
    }
LABEL_12:
    v4 = Unicode.UTF8.ForwardParser._invalidLength()();
    v3 = 0;
    v2 = 8 * v4;
    return v3 | (v2 << 8);
  }
  if ((v1 & 0x1E) == 0)
    goto LABEL_12;
  v2 = 16;
  v3 = 1;
  return v3 | (v2 << 8);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF8.ForwardParser@<X0>(uint64_t result@<X0>, int *a2@<X8>)
{
  _DWORD *v2;

  *a2 = (*v2 + 16843009) & ((1 << ((result + 1) >> 1) << (result >> 1)) - 1);
  return result;
}

unint64_t protocol witness for _UTFParser._buffer.getter in conformance Unicode.UTF8.ForwardParser()
{
  unsigned int *v0;

  return *v0 | ((unint64_t)*((unsigned __int8 *)v0 + 4) << 32);
}

uint64_t protocol witness for _UTFParser._buffer.setter in conformance Unicode.UTF8.ForwardParser(uint64_t result)
{
  uint64_t v1;

  *(_DWORD *)v1 = result;
  *(_BYTE *)(v1 + 4) = BYTE4(result);
  return result;
}

uint64_t static UInt16.+ infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result;

  result = a1 + a2;
  if ((result & 0x10000) != 0)
    __break(1u);
  return result;
}

void *static Unicode.UTF16._copy<A, B>(source:destination:count:)(char *a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  void *result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, char *, uint64_t);
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v7 = a1;
  v8 = *(_QWORD *)(a5 - 8);
  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = (char *)&v27 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  result = (void *)MEMORY[0x1E0C80A78](v9);
  v19 = (char *)&v27 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v20 = *(_QWORD *)(v17 + 72);
  v21 = *(_QWORD *)(v8 + 72);
  if (v20 == v21)
  {
    if ((a3 & 0x8000000000000000) != 0 || (v20 & 0x8000000000000000) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    if (is_mul_ok(a3, v20))
      return memcpy(a2, v7, a3 * v20);
    __break(1u);
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((a3 & 0x8000000000000000) != 0)
    goto LABEL_13;
  v31 = v16;
  v32 = v17;
  if (a3)
  {
    v22 = v13;
    v23 = v15;
    v24 = v14;
    v28 = *(void (**)(char *, char *, uint64_t))(v32 + 16);
    v29 = v21;
    v30 = v20;
    do
    {
      v28(v19, v7, v22);
      v25 = v8;
      v26 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v23 + 8))(v19, v22, v23);
      (*(void (**)(char *, uint64_t))(v32 + 8))(v19, v22);
      (*(void (**)(uint64_t, uint64_t))(v31 + 16))(v26, v24);
      v8 = v25;
      result = (void *)(*(uint64_t (**)(char *, char *, uint64_t))(v25 + 40))(a2, v11, v24);
      a2 += v29;
      v7 += v30;
      --a3;
    }
    while (a3);
  }
  return result;
}

unint64_t static UInt.* infix(_:_:)(unint64_t result, unint64_t a2)
{
  if (is_mul_ok(result, a2))
    result *= a2;
  else
    __break(1u);
  return result;
}

uint64_t static Unicode.UTF16.transcodedLength<A, B>(of:decodedAs:repairingIllFormedSequences:)(ValueMetadata *a1, ValueMetadata *a2, int a3, uint64_t a4, uint64_t a5, ValueMetadata *a6, const char *a7)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  void (*v55)(void);
  unint64_t AssociatedConformanceWitness;
  void (*v57)(unint64_t, unint64_t);
  uint64_t v58;
  ValueMetadata *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int8 *v63;
  char *v64;
  unint64_t v65;
  void (*v66)(unsigned __int8 *, char *, uint64_t);
  void (*v67)(unsigned __int8 *, uint64_t);
  char *v68;
  uint64_t v69;
  void (*v70)(char *, unsigned __int8 *, ValueMetadata *);
  unsigned __int8 *v71;
  char *v72;
  ValueMetadata *v73;
  void (*v74)(char *, _QWORD, uint64_t, ValueMetadata *);
  unsigned __int8 *v75;
  unsigned __int8 *v76;
  BOOL v77;
  char *v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  uint64_t v83;
  int v84;
  unsigned int v85;
  int v86;
  char *v87;
  int v88;
  const char *v89;
  unint64_t v90;
  unint64_t v91;
  void (*v92)(void *, uint64_t);
  char *v93;
  void (*v94)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v95;
  uint64_t v96;
  ValueMetadata *v97;
  char *v98;
  _QWORD *v99;
  void (*v100)(char *, unint64_t);
  char *v101;
  void (*v102)(char *, char *, unint64_t);
  void (*v103)(char *, char *, unint64_t);
  uint64_t (*v104)(unint64_t, uint64_t);
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char v108;
  void (*v109)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  unint64_t v110;
  char *v111;
  char v112;
  char *v113;
  void (*v114)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  unint64_t v115;
  char *v116;
  char *v117;
  char *v118;
  char v119;
  char *v120;
  uint64_t v121;
  char *v122;
  uint64_t v123;
  uint64_t (*v124)(unint64_t, uint64_t);
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  void (*v130)(char *, unint64_t);
  char v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  void (*v135)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  unint64_t v136;
  char *v137;
  char v138;
  char *v139;
  void (*v140)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  unint64_t v141;
  char v142;
  uint64_t v143;
  uint64_t v144;
  char *v145;
  char *v146;
  uint64_t v147;
  char *v148;
  unint64_t v149;
  char *v150;
  unsigned __int8 v152;
  int v153;
  uint64_t v154;
  char *v155;
  uint64_t v156;
  unint64_t v157;
  const char *v158;
  uint64_t v159;
  char *v160;
  char *v161;
  void (*v162)(char *, unint64_t, const char *);
  void (*v163)(void *, uint64_t);
  unint64_t v164;
  uint64_t v165;
  uint64_t v166;
  void (*v167)(char *, char *, unint64_t);
  char *v168;
  char *v169;
  unint64_t v170;
  const char *v171;
  char *v172;
  ValueMetadata *v173;
  char *v174;
  char *v175;
  unsigned __int8 *v176;
  uint64_t v177;
  void (*Kind)(uint64_t, ValueMetadata *);
  char *v179;
  uint64_t v180;
  void (*v181)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v182;
  uint64_t v183;
  int v184;
  unsigned __int8 *v185;
  void (*v186)(char *, uint64_t, ValueMetadata *, ValueMetadata *, unint64_t);
  char *v187;
  uint64_t v188;
  ValueMetadata *v189;
  unsigned __int8 *v190;
  char *v191;
  char *v192;
  ValueMetadata *v193;
  uint64_t v194;
  ValueMetadata *v195;
  char *v196;
  uint64_t v197;
  uint64_t v198;

  v197 = a4;
  v184 = a3;
  v195 = a2;
  v193 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a7, a5, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
  v194 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v12 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v172 = (char *)&v156 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v159 = v13;
  MEMORY[0x1E0C80A78](v12);
  v174 = (char *)&v156 - v14;
  v177 = type metadata accessor for Optional(0, AssociatedTypeWitness, v15, v16);
  v188 = *(_QWORD *)(v177 - 8);
  MEMORY[0x1E0C80A78](v177);
  v187 = (char *)&v156 - v17;
  v189 = (ValueMetadata *)AssociatedTypeWitness;
  v20 = type metadata accessor for Unicode.ParseResult(0, AssociatedTypeWitness, v18, v19);
  v183 = *(_QWORD *)(v20 - 8);
  v21 = MEMORY[0x1E0C80A78](v20);
  v185 = (unsigned __int8 *)&v156 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v176 = (unsigned __int8 *)&v156 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v190 = (unsigned __int8 *)&v156 - v26;
  MEMORY[0x1E0C80A78](v25);
  v191 = (char *)&v156 - v27;
  v28 = swift_getAssociatedTypeWitness(255, (const char *)a6, a4, (uint64_t)&protocol requirements base descriptor for IteratorProtocol, associated type descriptor for IteratorProtocol.Element);
  v31 = type metadata accessor for Optional(0, v28, v29, v30);
  v180 = *(_QWORD *)(v31 - 8);
  v181 = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v31;
  MEMORY[0x1E0C80A78](v31);
  v179 = (char *)&v156 - v32;
  v33 = *(_QWORD *)(swift_getAssociatedConformanceWitness((uint64_t)a7, a5, v28, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)+ 8);
  v171 = *(const char **)(*(_QWORD *)(v33 + 24) + 16);
  v170 = swift_getAssociatedTypeWitness(0, v171, v28, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v34 = MEMORY[0x1E0C80A78](v170);
  v169 = (char *)&v156 - v35;
  v182 = *(_QWORD *)(v28 - 8);
  v36 = MEMORY[0x1E0C80A78](v34);
  v160 = (char *)&v156 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  v38 = MEMORY[0x1E0C80A78](v36);
  v161 = (char *)&v156 - v39;
  v40 = MEMORY[0x1E0C80A78](v38);
  v168 = (char *)&v156 - v41;
  v42 = MEMORY[0x1E0C80A78](v40);
  v175 = (char *)&v156 - v43;
  v44 = MEMORY[0x1E0C80A78](v42);
  v46 = (char *)&v156 - v45;
  MEMORY[0x1E0C80A78](v44);
  v186 = (void (*)(char *, uint64_t, ValueMetadata *, ValueMetadata *, unint64_t))((char *)&v156 - v47);
  v48 = swift_getAssociatedTypeWitness(0, a7, a5, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.ForwardParser);
  v166 = *(_QWORD *)(v48 - 8);
  v49 = MEMORY[0x1E0C80A78](v48);
  v51 = (char *)&v156 - v50;
  MEMORY[0x1E0C80A78](v49);
  v53 = (char *)&v156 - ((v52 + 15) & 0xFFFFFFFFFFFFFFF0);
  v165 = v54;
  v55 = *(void (**)(void))(v54 + 16);
  v196 = v53;
  v55();
  v158 = a7;
  v173 = (ValueMetadata *)a5;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a7, a5, v48, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.ForwardParser: _UnicodeParser);
  v57 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  v192 = v51;
  v193 = (ValueMetadata *)v48;
  v57(v48, AssociatedConformanceWitness);
  v58 = 0;
  v59 = v195;
  v195 = a6;
  if (v59 != &type metadata for Unicode.UTF8)
  {
LABEL_2:
    v60 = 0;
    v186 = *(void (**)(char *, uint64_t, ValueMetadata *, ValueMetadata *, unint64_t))(AssociatedConformanceWitness + 32);
    v61 = v177;
    v62 = v183;
    v63 = v190;
    v64 = v191;
    while (1)
    {
      while (1)
      {
        v65 = AssociatedConformanceWitness;
        v186(v196, v197, v195, v193, AssociatedConformanceWitness);
        v66 = *(void (**)(unsigned __int8 *, char *, uint64_t))(v62 + 16);
        v66(v63, v64, v20);
        if (swift_getEnumCaseMultiPayload(v63, v20))
        {
          v67 = *(void (**)(unsigned __int8 *, uint64_t))(v62 + 8);
          v67(v63, v20);
          v68 = v187;
          (*(void (**)(char *, uint64_t, uint64_t, ValueMetadata *))(v194 + 56))(v187, 1, 1, v189);
          (*(void (**)(char *, uint64_t))(v188 + 8))(v68, v61);
          goto LABEL_8;
        }
        v69 = v194;
        v70 = *(void (**)(char *, unsigned __int8 *, ValueMetadata *))(v194 + 32);
        v71 = v63;
        v72 = v187;
        v73 = v189;
        v70(v187, v71, v189);
        v74 = *(void (**)(char *, _QWORD, uint64_t, ValueMetadata *))(v69 + 56);
        v61 = v177;
        v74(v72, 0, 1, v73);
        (*(void (**)(char *, uint64_t))(v188 + 8))(v72, v61);
        v75 = v176;
        v66(v176, v64, v20);
        if (!swift_getEnumCaseMultiPayload(v75, v20))
          break;
        v62 = v183;
        v67 = *(void (**)(unsigned __int8 *, uint64_t))(v183 + 8);
        v67(v75, v20);
LABEL_8:
        v76 = v185;
        v64 = v191;
        (*(void (**)(unsigned __int8 *, char *, uint64_t))(v62 + 32))(v185, v191, v20);
        if (swift_getEnumCaseMultiPayload(v76, v20) != 1)
        {
          v67(v185, v20);
          (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, v193);
          (*(void (**)(char *, uint64_t))(v165 + 8))(v196, v197);
          return v58;
        }
        if ((v184 & 1) == 0)
        {
          (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, v193);
          (*(void (**)(char *, uint64_t))(v165 + 8))(v196, v197);
          return 0;
        }
        v77 = __OFADD__(v58++, 1);
        if (v77)
        {
          __break(1u);
LABEL_78:
          __break(1u);
LABEL_79:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
        }
        AssociatedConformanceWitness = v65;
        v60 |= 0xFFFDu;
        v63 = v190;
      }
      v78 = v172;
      v70(v172, v75, v73);
      (*(void (**)(char *, uint64_t))(v183 + 8))(v64, v20);
      v70(v174, (unsigned __int8 *)v78, v73);
      if (v173 == &type metadata for Unicode.UTF8)
        break;
      v63 = v190;
      if (v173 != &type metadata for Unicode.UTF16)
      {
        v87 = v174;
        v81 = (*((uint64_t (**)(char *))v158 + 11))(v174);
        (*(void (**)(char *, ValueMetadata *))(v194 + 8))(v87, v189);
        if (v81 < 0x10000)
        {
          v82 = 16;
        }
        else
        {
          v81 = ((v81 + 983040) >> 10) & 0x3FF | ((v81 & 0x3FF) << 16) | 0xDC00D800;
          v82 = 32;
        }
        goto LABEL_16;
      }
      v62 = v183;
      if (v159 != 5)
        goto LABEL_81;
      v81 = *(_DWORD *)v174;
      v82 = v174[4];
      (*(void (**)(void))(v194 + 8))();
LABEL_17:
      v83 = v82 >> 4;
      v77 = __OFADD__(v58, v83);
      v58 += v83;
      if (v77)
      {
        __break(1u);
LABEL_81:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
      if (v82)
      {
        do
        {
          v84 = (unsigned __int16)v81;
          v81 >>= 16;
          v82 -= 16;
          v60 |= v84;
        }
        while ((_BYTE)v82);
      }
      v64 = v191;
      AssociatedConformanceWitness = v65;
    }
    v63 = v190;
    if (v73 != &type metadata for _ValidUTF8Buffer)
      goto LABEL_79;
    v79 = *(_DWORD *)v174;
    (*(void (**)(void))(v194 + 8))();
    v80 = __clz(v79) >> 3;
    if (v80 == 3)
    {
      v81 = (v79 - 1) & 0x7F;
      v82 = 16;
LABEL_16:
      v62 = v183;
      goto LABEL_17;
    }
    v85 = v79 - 16843009;
    v86 = (v85 << 6) | (v85 >> 8) & 0x3F;
    v62 = v183;
    if (v80 == 2)
    {
      v81 = (v85 << 6) & 0x7FF | (v85 >> 8) & 0x3F;
      v82 = 16;
      goto LABEL_17;
    }
    v88 = HIWORD(v85) & 0x3F | (v86 << 6);
    if (v80 == 1)
    {
      v81 = ((v79 - 16843009) >> 16) & 0x3F | (unsigned __int16)((_WORD)v86 << 6);
    }
    else
    {
      v81 = (v88 << 6) & 0x1FFFC0 | HIBYTE(v85) & 0x3F;
      if (v81 >= 0x10000)
      {
        v81 = (((v88 << 6) & 0x3C0 | HIBYTE(v85) & 0x3F) << 16) | (((v88 << 6) + 983040) >> 10) & 0x3FF | 0xDC00D800;
        v82 = 32;
        goto LABEL_32;
      }
    }
    v82 = 16;
LABEL_32:
    v61 = v177;
    v62 = v183;
    v63 = v190;
    goto LABEL_17;
  }
  v157 = AssociatedConformanceWitness;
  v89 = v171;
  v90 = v170;
  v91 = swift_getAssociatedConformanceWitness((uint64_t)v171, v28, v170, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v92 = *(void (**)(void *, uint64_t))(v91 + 8);
  v93 = v169;
  v164 = v91;
  v163 = v92;
  ((void (*)(void *, uint64_t, unint64_t))v92)(&unk_1816B7DA8, 256, v90);
  v162 = (void (*)(char *, unint64_t, const char *))*((_QWORD *)v89 + 3);
  v162(v93, v28, v89);
  v58 = 0;
  Kind = (void (*)(uint64_t, ValueMetadata *))a6[1].Kind;
  v95 = v180;
  v94 = v181;
  while (1)
  {
    v97 = a6;
    v98 = v179;
    Kind(v197, v97);
    v99 = (_QWORD *)v182;
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v182 + 48))(v98, 1, v28) == 1)
      break;
    v100 = (void (*)(char *, unint64_t))v99[1];
    v101 = (char *)v186;
    v100((char *)v186, v28);
    v102 = (void (*)(char *, char *, unint64_t))v99[4];
    v102(v101, v98, v28);
    v103 = (void (*)(char *, char *, unint64_t))v99[2];
    v103(v46, v101, v28);
    v104 = *(uint64_t (**)(unint64_t, uint64_t))(v33 + 64);
    if ((v104(v28, v33) & 1) != 0)
    {
      v105 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
      if (v105 < 64)
        goto LABEL_37;
LABEL_45:
      v198 = 128;
      v109 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
      v110 = lazy protocol witness table accessor for type Int and conformance Int(v105, v106, v107);
      v111 = v175;
      v109(&v198, &type metadata for Int, v110, v28, v33);
      v112 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v33 + 32) + 8)
                                                                         + 16))(v46, v111, v28);
      v100(v111, v28);
      v113 = v46;
LABEL_48:
      v100(v113, v28);
      a6 = v195;
      v95 = v180;
      v94 = v181;
      if ((v112 & 1) == 0)
        goto LABEL_55;
      goto LABEL_38;
    }
    v108 = v104(v28, v33);
    v105 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
    if ((v108 & 1) == 0)
    {
      if (v105 < 64)
      {
LABEL_37:
        v96 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
        v100(v46, v28);
        a6 = v195;
        v95 = v180;
        v94 = v181;
        if (v96 >= 128)
          goto LABEL_55;
        goto LABEL_38;
      }
      v198 = 128;
      v114 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
      v115 = lazy protocol witness table accessor for type Int and conformance Int(v105, v106, v107);
      v116 = v175;
      v114(&v198, &type metadata for Int, v115, v28, v33);
      v112 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v33 + 32) + 8)
                                                                         + 16))(v46, v116, v28);
      v100(v46, v28);
      v113 = v116;
      goto LABEL_48;
    }
    if (v105 > 64)
      goto LABEL_45;
    v167 = v103;
    v117 = v169;
    v163(&unk_1816B7DA8, 256);
    v118 = v175;
    v162(v117, v28, v171);
    v119 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v33 + 32) + 8) + 16))(v46, v118, v28);
    v100(v118, v28);
    v120 = v168;
    v102(v168, v46, v28);
    a6 = v195;
    if ((v119 & 1) != 0)
    {
      v100(v120, v28);
      v95 = v180;
      v94 = v181;
    }
    else
    {
      v121 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
      v100(v120, v28);
      v95 = v180;
      v94 = v181;
      v103 = v167;
      if (v121 >= 128)
        goto LABEL_55;
    }
LABEL_38:
    v77 = __OFADD__(v58++, 1);
    if (v77)
      goto LABEL_78;
  }
  (*(void (**)(char *, void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD)))(v95 + 8))(v98, v94);
  v103 = (void (*)(char *, char *, unint64_t))v99[2];
LABEL_55:
  v122 = v161;
  v123 = (uint64_t)v186;
  v103(v161, (char *)v186, v28);
  v124 = *(uint64_t (**)(unint64_t, uint64_t))(v33 + 64);
  if ((v124(v28, v33) & 1) == 0)
  {
    v131 = v124(v28, v33);
    v132 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
    if ((v131 & 1) != 0)
    {
      AssociatedConformanceWitness = v157;
      if (v132 > 64)
      {
        v198 = 128;
        v135 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
        v136 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
        v137 = v175;
        v135(&v198, &type metadata for Int, v136, v28, v33);
        v138 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v33 + 32) + 8)
                                                                           + 16))(v122, v137, v28);
        v130 = *(void (**)(char *, unint64_t))(v182 + 8);
        v130(v137, v28);
        v139 = v122;
        goto LABEL_69;
      }
      v145 = v169;
      v163(&unk_1816B7DA8, 256);
      v146 = v175;
      v162(v145, v28, v171);
      LODWORD(v181) = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v33 + 32)
                                                                                              + 8)
                                                                                  + 16))(v122, v146, v28);
      v147 = v182;
      v130 = *(void (**)(char *, unint64_t))(v182 + 8);
      v130(v146, v28);
      v148 = v160;
      (*(void (**)(char *, char *, unint64_t))(v147 + 32))(v160, v122, v28);
      if ((v181 & 1) != 0)
      {
        v130(v148, v28);
        goto LABEL_70;
      }
      v144 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
      v130(v148, v28);
    }
    else
    {
      AssociatedConformanceWitness = v157;
      v143 = v182;
      if (v132 >= 64)
      {
        v198 = 128;
        v181 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v33 + 96);
        v149 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
        v150 = v175;
        v181(&v198, &type metadata for Int, v149, v28, v33);
        v138 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v33 + 32) + 8)
                                                                           + 16))(v122, v150, v28);
        v130 = *(void (**)(char *, unint64_t))(v143 + 8);
        v130(v122, v28);
        v139 = v150;
LABEL_69:
        v130(v139, v28);
        if ((v138 & 1) == 0)
          goto LABEL_74;
        goto LABEL_70;
      }
      v144 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
      v130 = *(void (**)(char *, unint64_t))(v143 + 8);
      v130(v122, v28);
    }
    if (v144 >= 128)
      goto LABEL_74;
    goto LABEL_70;
  }
  v125 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 128))(v28, v33);
  v128 = v175;
  if (v125 >= 64)
  {
    v198 = 128;
    v140 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v33 + 96);
    v141 = lazy protocol witness table accessor for type Int and conformance Int(v125, v126, v127);
    v140(&v198, &type metadata for Int, v141, v28, v33);
    v142 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v33 + 32) + 8) + 16))(v122, v128, v28);
    v130 = *(void (**)(char *, unint64_t))(v182 + 8);
    v130(v128, v28);
    v130(v122, v28);
    AssociatedConformanceWitness = v157;
    if ((v142 & 1) != 0)
      goto LABEL_70;
LABEL_74:
    v152 = specialized numericCast<A, B>(_:)(v123, v28, v33);
    if (v193 != &type metadata for Unicode.UTF8.ForwardParser)
      goto LABEL_79;
    v153 = v152;
    v130((char *)v123, v28);
    v154 = v166;
    v155 = v192;
    (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, &type metadata for Unicode.UTF8.ForwardParser);
    LODWORD(v198) = v153;
    BYTE4(v198) = 8;
    (*(void (**)(char *, uint64_t *, ValueMetadata *))(v154 + 16))(v155, &v198, &type metadata for Unicode.UTF8.ForwardParser);
    goto LABEL_2;
  }
  v129 = (*(uint64_t (**)(unint64_t, uint64_t))(v33 + 120))(v28, v33);
  v130 = *(void (**)(char *, unint64_t))(v182 + 8);
  v130(v122, v28);
  AssociatedConformanceWitness = v157;
  if (v129 >= 128)
    goto LABEL_74;
LABEL_70:
  v130((char *)v123, v28);
  (*(void (**)(char *, ValueMetadata *))(v166 + 8))(v192, v193);
  (*(void (**)(char *, uint64_t))(v165 + 8))(v196, v197);
  return v58;
}

unint64_t static Unicode.UTF16.transcode<A>(_:from:)(unsigned int *a1, uint64_t a2, ValueMetadata *a3, uint64_t a4)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  unsigned int v16;

  if (a3 == &type metadata for Unicode.UTF8)
  {
    if ((ValueMetadata *)swift_getAssociatedTypeWitness(0, (const char *)a4, (uint64_t)&type metadata for Unicode.UTF8, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar) != &type metadata for _ValidUTF8Buffer)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
    v5 = *a1;
    v6 = __clz(*a1) >> 3;
    if (v6 == 3)
      return ((_BYTE)v5 - 1) & 0x7F | 0x1000000000;
    v9 = v5 - 16843009;
    v10 = (v9 << 6) | (v9 >> 8) & 0x3F;
    v11 = HIWORD(v9) & 0x3F | (v10 << 6);
    if (((v11 << 6) & 0x1F0000) != 0)
      v12 = (((v11 << 6) + 983040) >> 10) & 0x3FF | (((v11 << 6) & 0x3C0 | HIBYTE(v9) & 0x3F) << 16) | 0x20DC00D800;
    else
      v12 = (v11 << 6) & 0x1FFFC0 | HIBYTE(v9) & 0x3F | 0x1000000000;
    v13 = (unsigned __int16)v11 | 0x1000000000;
    if (v6 == 1)
      v12 = v13;
    v14 = v10 & 0x7FF | 0x1000000000;
    v15 = v6 == 2;
    goto LABEL_16;
  }
  if (a3 != &type metadata for Unicode.UTF16)
  {
    v16 = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a4 + 88))(a1, a3, a4);
    v12 = ((v16 & 0x3FF) << 16) | ((v16 + 983040) >> 10) & 0x3FF | 0x20DC00D800;
    v14 = v16 | 0x1000000000;
    v15 = HIWORD(v16) == 0;
LABEL_16:
    if (v15)
      return v14;
    else
      return v12;
  }
  if (*(_QWORD *)(*(_QWORD *)(swift_getAssociatedTypeWitness(0, (const char *)a4, (uint64_t)&type metadata for Unicode.UTF16, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar)- 8)+ 64) != 5)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  return *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32);
}

uint64_t static Unicode.UTF16.encodedReplacementCharacter.getter()
{
  return 0x100000FFFDLL;
}

BOOL static Unicode.UTF16._isScalar(_:)(unsigned __int16 a1)
{
  return a1 >> 11 != 27;
}

uint64_t static Unicode.UTF16.decode(_:)(uint64_t result)
{
  if ((result & 0xFF00000000) == 0x1000000000)
    return (unsigned __int16)result;
  else
    return (WORD1(result) & 0x3FF | ((result & 0x3FF) << 10)) + 0x10000;
}

uint64_t static Unicode.UTF16.encode(_:)(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = 0x1000000000;
  LODWORD(v2) = ((a1 & 0x3FF) << 16) | ((a1 + 983040) >> 10) & 0x3FF;
  if (a1 >= 0x10000)
    v2 = v2;
  else
    v2 = a1;
  if (a1 >= 0x10000)
    v1 = 0x20DC00D800;
  return v1 | v2;
}

uint64_t Unicode.UTF16.ForwardParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF16.ForwardParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Unicode.UTF16.ReverseParser._buffer.getter(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFLL;
}

uint64_t (*Unicode.UTF16.ReverseParser._buffer.modify())()
{
  return EnumeratedSequence._base.modify;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF16(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 65533;
  *(_BYTE *)(a1 + 4) = 16;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF16(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 4) == 16)
    return (unsigned __int16)*(_DWORD *)a1;
  else
    return (HIWORD(*(_DWORD *)a1) & 0x3FF | ((*(_DWORD *)a1 & 0x3FFu) << 10)) + 0x10000;
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF16@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  int v3;

  v2 = 0x1000000000;
  v3 = ((result & 0x3FF) << 16) | ((result + 983040) >> 10) & 0x3FF;
  if (result >= 0x10000)
    v2 = 0x20DC00D800;
  else
    v3 = result;
  *(_BYTE *)(a2 + 4) = BYTE4(v2);
  *(_DWORD *)a2 = v2 | v3;
  *(_BYTE *)(a2 + 5) = 0;
  return result;
}

unint64_t protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF16@<X0>(unsigned int *a1@<X0>, ValueMetadata *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  ValueMetadata *v4;
  unint64_t result;
  unsigned int v8;
  unsigned int v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  if (a2 == &type metadata for Unicode.UTF8)
  {
    result = swift_getAssociatedTypeWitness(0, (const char *)a3, (uint64_t)&type metadata for Unicode.UTF8, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if ((ValueMetadata *)result != &type metadata for _ValidUTF8Buffer)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "_identityCast to wrong type", 27, 2, "Swift/Builtin.swift", 19, 2, 0x6CuLL, 0);
    v8 = *a1;
    v9 = __clz(*a1) >> 3;
    if (v9 == 3)
    {
      v10 = ((_BYTE)v8 - 1) & 0x7F | 0x1000000000;
    }
    else
    {
      v11 = v8 - 16843009;
      v12 = (v11 << 6) & 0x7FF | (v11 >> 8) & 0x3F | 0x1000000000;
      v13 = HIWORD(v11) & 0x3F | (((v11 << 6) | (v11 >> 8) & 0x3F) << 6);
      if (((v13 << 6) & 0x1F0000) != 0)
        v14 = (((v13 << 6) + 983040) >> 10) & 0x3FF | (((v13 << 6) & 0x3C0 | HIBYTE(v11) & 0x3F) << 16) | 0x20DC00D800;
      else
        v14 = (v13 << 6) & 0x1FFFC0 | HIBYTE(v11) & 0x3F | 0x1000000000;
      if (v9 == 1)
        v14 = (unsigned __int16)v13 | 0x1000000000;
      if (v9 == 2)
        v10 = v12;
      else
        v10 = v14;
    }
  }
  else if (a2 == v4)
  {
    result = swift_getAssociatedTypeWitness(0, (const char *)a3, (uint64_t)a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.EncodedScalar);
    if (*(_QWORD *)(*(_QWORD *)(result - 8) + 64) != 5)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
    v10 = *a1 | ((unint64_t)*((unsigned __int8 *)a1 + 4) << 32);
  }
  else
  {
    result = (*(uint64_t (**)(unsigned int *, ValueMetadata *, uint64_t))(a3 + 88))(a1, a2, a3);
    v10 = result | 0x1000000000;
    if (result >= 0x10000)
      v10 = ((result & 0x3FF) << 16) | ((result + 983040) >> 10) & 0x3FF | 0x20DC00D800;
  }
  *(_DWORD *)a4 = v10;
  *(_WORD *)(a4 + 4) = BYTE4(v10);
  return result;
}

BOOL protocol witness for static _UnicodeEncoding._isScalar(_:) in conformance Unicode.UTF16(_WORD *a1)
{
  return (*a1 & 0xF800) != 55296;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF16.ReverseParser._parseMultipleCodeUnits()()
{
  int v0;
  Swift::Bool v1;
  Swift::tuple_isValid_Bool_bitCount_UInt8 result;

  v1 = (v0 & 0xFC00FC00) == 3623934976;
  result.isValid = v1;
  return result;
}

unint64_t Unicode.UTF16.ReverseParser._bufferedScalar(bitCount:)(unint64_t result, int a2)
{
  int v2;
  unint64_t v3;

  v2 = 32 - result;
  if ((v2 & 0xFFFFFF00) != 0)
  {
    __break(1u);
  }
  else
  {
    HIDWORD(v3) = a2;
    LODWORD(v3) = a2;
    return ((v3 >> 16) >> v2) | ((unint64_t)result << 32);
  }
  return result;
}

uint64_t static UInt8.- infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result;

  result = a1 - a2;
  if ((result & 0xFFFFFF00) != 0)
    __break(1u);
  return result;
}

_QWORD *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF16.ReverseParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  _QWORD *(*v8)(_QWORD *__return_ptr, uint64_t, uint64_t);
  _QWORD *result;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  BOOL v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t (*v22)();
  _QWORD v23[4];

  if (*(_BYTE *)(v4 + 4))
  {
    if ((*(_DWORD *)v4 & 0xF800) == 0xD800)
    {
      v8 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      result = v8(v23, a2, a3);
      goto LABEL_8;
    }
    v21 = (unsigned __int16)*(_DWORD *)v4;
    lazy protocol witness table accessor for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser(a1, a2, a3);
    v22 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    result = (_QWORD *)((uint64_t (*)(_QWORD *, _QWORD))v22)(v23, 0);
    v11 = 0;
    v10 = v21 | 0x1000000000;
  }
  else
  {
    v8 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    result = v8(v23, a2, a3);
    if ((v23[0] & 0x10000) != 0)
    {
LABEL_3:
      v10 = 0;
      v11 = 2;
    }
    else if ((v23[0] & 0xF800) == 0xD800)
    {
      v12 = *(unsigned __int8 *)(v4 + 4);
      if (v12 >= 0x20)
LABEL_25:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      *(_DWORD *)v4 = *(_DWORD *)v4 & ((-65535 << v12) - 1) | (LOWORD(v23[0]) << v12);
      *(_BYTE *)(v4 + 4) = v12 + 16;
      while (1)
      {
        result = v8(v23, a2, a3);
LABEL_8:
        if ((v23[0] & 0x10000) != 0)
          break;
        v13 = *(unsigned __int8 *)(v4 + 4);
        if (v13 > 0x1F)
          goto LABEL_25;
        v14 = *(_DWORD *)v4 & ((-65535 << v13) - 1) | (LOWORD(v23[0]) << v13);
        *(_DWORD *)v4 = v14;
        v15 = v13 + 16;
        *(_BYTE *)(v4 + 4) = v13 + 16;
        if (v13 >= 0x10)
          goto LABEL_15;
      }
      v15 = *(_BYTE *)(v4 + 4);
      if (!v15)
        goto LABEL_3;
      v14 = *(_DWORD *)v4;
LABEL_15:
      v16 = v14 & 0xFC00FC00;
      if ((v14 & 0xFC00FC00) == 0xD800DC00)
        v17 = 32;
      else
        v17 = 16;
      *(_BYTE *)(v4 + 4) = v15 - v17;
      v18 = v16 == -671032320;
      if (v16 == -671032320)
        v19 = 32;
      else
        v19 = 16;
      *(_DWORD *)v4 = (unint64_t)v14 >> v19;
      if (v18)
      {
        v11 = 0;
        HIDWORD(v20) = v14;
        LODWORD(v20) = v14;
        v10 = (v20 >> 16) | (unint64_t)(v19 << 32);
      }
      else
      {
        result = (_QWORD *)specialized numericCast<A, B>(_:)(0x10uLL);
        if (!(_BYTE)result)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
        v11 = 1;
        v10 = 0x10u / result;
      }
    }
    else
    {
      v11 = 0;
      v10 = LOWORD(v23[0]) | 0x1000000000;
    }
  }
  *(_QWORD *)a4 = v10;
  *(_BYTE *)(a4 + 8) = v11;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF16.ReverseParser()
{
  _DWORD *v0;
  int v1;

  if ((*v0 & 0xFC00FC00) == 0xD800DC00)
    v1 = 0x2000;
  else
    v1 = 4096;
  return v1 | ((*v0 & 0xFC00FC00) == -671032320);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF16.ReverseParser@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  _DWORD *v2;
  int v3;
  unint64_t v4;

  v3 = 32 - result;
  if ((v3 & 0xFFFFFF00) != 0)
  {
    __break(1u);
  }
  else
  {
    HIDWORD(v4) = *v2;
    LODWORD(v4) = *v2;
    *(_DWORD *)a2 = (v4 >> 16) >> v3;
    *(_BYTE *)(a2 + 4) = result;
  }
  return result;
}

Swift::tuple_isValid_Bool_bitCount_UInt8 __swiftcall Unicode.UTF16.ForwardParser._parseMultipleCodeUnits()()
{
  int v0;
  Swift::Bool v1;
  Swift::tuple_isValid_Bool_bitCount_UInt8 result;

  v1 = (v0 & 0xFC00FC00) == 3691042816;
  result.isValid = v1;
  return result;
}

unint64_t Unicode.UTF16.ForwardParser._bufferedScalar(bitCount:)(unsigned __int8 a1, unsigned int a2)
{
  return a2 | ((unint64_t)a1 << 32);
}

_QWORD *protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF16.ForwardParser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  _QWORD *(*v8)(_QWORD *__return_ptr, uint64_t, uint64_t);
  _QWORD *result;
  uint64_t v10;
  char v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  char v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)();
  _QWORD v24[4];

  if (*(_BYTE *)(v4 + 4))
  {
    if ((*(_DWORD *)v4 & 0xF800) == 0xD800)
    {
      v8 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
      result = v8(v24, a2, a3);
      goto LABEL_8;
    }
    v22 = (unsigned __int16)*(_DWORD *)v4;
    lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser(a1, a2, a3);
    v23 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
    specialized RangeReplaceableCollection.remove(at:)(0);
    result = (_QWORD *)((uint64_t (*)(_QWORD *, _QWORD))v23)(v24, 0);
    v11 = 0;
    v10 = v22 | 0x1000000000;
  }
  else
  {
    v8 = *(_QWORD *(**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    result = v8(v24, a2, a3);
    if ((v24[0] & 0x10000) != 0)
    {
LABEL_3:
      v10 = 0;
      v11 = 2;
    }
    else if ((v24[0] & 0xF800) == 0xD800)
    {
      v12 = *(unsigned __int8 *)(v4 + 4);
      if (v12 >= 0x20)
LABEL_25:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      *(_DWORD *)v4 = *(_DWORD *)v4 & ((-65535 << v12) - 1) | (LOWORD(v24[0]) << v12);
      *(_BYTE *)(v4 + 4) = v12 + 16;
      while (1)
      {
        result = v8(v24, a2, a3);
LABEL_8:
        if ((v24[0] & 0x10000) != 0)
          break;
        v13 = *(unsigned __int8 *)(v4 + 4);
        if (v13 > 0x1F)
          goto LABEL_25;
        v14 = *(_DWORD *)v4 & ((-65535 << v13) - 1) | (LOWORD(v24[0]) << v13);
        *(_DWORD *)v4 = v14;
        v15 = v13 + 16;
        *(_BYTE *)(v4 + 4) = v13 + 16;
        if (v13 >= 0x10)
          goto LABEL_15;
      }
      v15 = *(_BYTE *)(v4 + 4);
      if (!v15)
        goto LABEL_3;
      v14 = *(_DWORD *)v4;
LABEL_15:
      v16 = v14 & 0xFC00FC00;
      if ((v14 & 0xFC00FC00) == 0xDC00D800)
        v17 = 32;
      else
        v17 = 16;
      v18 = v15 - v17;
      v19 = v14;
      *(_BYTE *)(v4 + 4) = v18;
      v20 = v16 == -603924480;
      if (v16 == -603924480)
        v21 = 32;
      else
        v21 = 16;
      *(_DWORD *)v4 = (unint64_t)v14 >> v21;
      if (v20)
      {
        v11 = 0;
        v10 = v19 | (v21 << 32);
      }
      else
      {
        result = (_QWORD *)specialized numericCast<A, B>(_:)(0x10uLL);
        if (!(_BYTE)result)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
        v11 = 1;
        v10 = 0x10u / result;
      }
    }
    else
    {
      v11 = 0;
      v10 = LOWORD(v24[0]) | 0x1000000000;
    }
  }
  *(_QWORD *)a4 = v10;
  *(_BYTE *)(a4 + 8) = v11;
  return result;
}

uint64_t protocol witness for _UTFParser._parseMultipleCodeUnits() in conformance Unicode.UTF16.ForwardParser()
{
  _DWORD *v0;
  int v1;

  if ((*v0 & 0xFC00FC00) == 0xDC00D800)
    v1 = 0x2000;
  else
    v1 = 4096;
  return v1 | ((*v0 & 0xFC00FC00) == -603924480);
}

uint64_t protocol witness for _UTFParser._bufferedScalar(bitCount:) in conformance Unicode.UTF16.ForwardParser@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  _DWORD *v2;

  *(_DWORD *)a2 = *v2;
  *(_BYTE *)(a2 + 4) = result;
  return result;
}

Swift::Int _MergeError.hashValue.getter()
{
  Hasher._combine(_:)(0);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance _MergeError()
{
  Hasher._combine(_:)(0);
  return Hasher._finalize()();
}

uint64_t static Unicode.UTF32.encodedReplacementCharacter.getter()
{
  return 65533;
}

uint64_t static Unicode.UTF32._isScalar(_:)()
{
  return 1;
}

uint64_t static Unicode.UTF32.encode(_:)(uint64_t result)
{
  return result;
}

void protocol witness for static _UnicodeEncoding.encodedReplacementCharacter.getter in conformance Unicode.UTF32(_DWORD *a1@<X8>)
{
  *a1 = 65533;
}

uint64_t protocol witness for static _UnicodeEncoding.decode(_:) in conformance Unicode.UTF32(unsigned int *a1)
{
  return *a1;
}

uint64_t protocol witness for static _UnicodeEncoding.encode(_:) in conformance Unicode.UTF32@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = result;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

uint64_t protocol witness for static _UnicodeEncoding.transcode<A>(_:from:) in conformance Unicode.UTF32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result;

  result = specialized static _UnicodeEncoding.transcode<A>(_:from:)(a1, a2, a3, a4);
  *(_DWORD *)a5 = result;
  *(_BYTE *)(a5 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t Unicode.UTF32.Parser.parseScalar<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a3 + 16))(&v5, a2, a3);
  if ((v5 & 0x100000000) != 0)
    return 0;
  if (WORD1(v5) > 0x10u || v5 >> 11 == 27)
    return 1;
  else
    return v5;
}

uint64_t protocol witness for _UnicodeParser.parseScalar<A>(from:) in conformance Unicode.UTF32.Parser@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;
  char v6;

  result = Unicode.UTF32.Parser.parseScalar<A>(from:)(a1, a2, a3);
  *(_QWORD *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6;
  return result;
}

uint64_t static UnicodeDecodingResult.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  _BOOL4 v3;
  unsigned int v4;

  v3 = (a2 & 0x100000000) == 0 && (_DWORD)a1 == (_DWORD)a2;
  v4 = BYTE4(a2) & ((_DWORD)a2 != 0);
  if (!(_DWORD)a1)
    v4 = BYTE4(a2) & ((_DWORD)a2 == 0);
  if ((a1 & 0x100000000) != 0)
    return v4;
  else
    return v3;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance UnicodeDecodingResult(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(unsigned __int8 *)(a2 + 4);
  v3 = (*(_DWORD *)a1 == *(_DWORD *)a2) & ~v2;
  if (*(_DWORD *)a2)
    v4 = 0;
  else
    v4 = *(unsigned __int8 *)(a2 + 4);
  if (!*(_DWORD *)a2)
    v2 = 0;
  if (*(_DWORD *)a1)
    v5 = v2;
  else
    v5 = v4;
  if (*(_BYTE *)(a1 + 4) == 1)
    return v5;
  else
    return v3;
}

uint64_t static UnicodeCodec._nullCodeUnitOffset(in:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return static UnicodeCodec._nullCodeUnitOffset(in:)(a1, a2, a3);
}

{
  const char *v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t (*v20)(_QWORD, _QWORD);
  void (*v21)(char *, uint64_t, unint64_t *);
  uint64_t v22;
  uint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  void (*v29)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v30;
  char v31;
  void (*v32)(char *, unint64_t *);
  char *v33;
  uint64_t v34;
  unint64_t v35;
  const char *v36;
  unint64_t AssociatedConformanceWitness;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, unint64_t *);
  void (*v43)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  const char *v48;
  uint64_t (*v49)(_QWORD, _QWORD);
  uint64_t v50;
  void (*v51)(char *, uint64_t, unint64_t *);
  uint64_t v52;

  v5 = *(const char **)(a3 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, a2, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, associated type descriptor for _UnicodeEncoding.CodeUnit);
  v7 = *(_QWORD *)(swift_getAssociatedConformanceWitness((uint64_t)v5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for _UnicodeEncoding, (uint64_t)&associated conformance descriptor for _UnicodeEncoding._UnicodeEncoding.CodeUnit: FixedWidthInteger)+ 8);
  v48 = *(const char **)(*(_QWORD *)(v7 + 24) + 16);
  v47 = swift_getAssociatedTypeWitness(0, v48, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v47);
  v46 = (char *)&v45 - v8;
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v10 = *(v9 - 1);
  v11 = MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v45 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v45 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v45 - v17;
  v19 = 0;
  v20 = *(uint64_t (**)(_QWORD, _QWORD))(v7 + 64);
  v21 = *(void (**)(char *, uint64_t, unint64_t *))(v10 + 16);
  v50 = *(_QWORD *)(v10 + 72);
  v51 = v21;
  v49 = v20;
  v45 = v13;
  v21((char *)&v45 - v17, a1, v9);
  while (1)
  {
    if ((v20(v9, v7) & 1) != 0)
    {
      v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v9, v7);
      if (v25 < 64)
      {
        v22 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v9, v7);
        result = (*(uint64_t (**)(char *, unint64_t *))(v10 + 8))(v18, v9);
        if (!v22)
          return v19;
        goto LABEL_3;
      }
      goto LABEL_10;
    }
    v28 = v20(v9, v7);
    v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v9, v7);
    if ((v28 & 1) != 0)
    {
      if (v25 > 64)
      {
LABEL_10:
        v52 = 0;
        v29 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v7 + 96);
        v30 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
        v29(&v52, &type metadata for Int, v30, v9, v7);
        v31 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v7 + 16) + 8)
                                                                            + 8))(v18, v16, v9);
        v32 = *(void (**)(char *, unint64_t *))(v10 + 8);
        v32(v16, v9);
        v33 = v18;
        goto LABEL_18;
      }
      v35 = v47;
      v36 = v48;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v48, (uint64_t)v9, v47, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v38 = v10;
      v39 = v46;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v35, AssociatedConformanceWitness);
      v40 = v39;
      v10 = v38;
      v41 = v45;
      (*((void (**)(char *, unint64_t *, const char *))v36 + 3))(v40, v9, v36);
      LOBYTE(v35) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v7 + 32)
                                                                                              + 8)
                                                                                  + 32))(v18, v16, v9);
      v42 = *(void (**)(char *, unint64_t *))(v10 + 8);
      v42(v16, v9);
      (*(void (**)(char *, char *, unint64_t *))(v10 + 32))(v41, v18, v9);
      if ((v35 & 1) == 0)
      {
        result = ((uint64_t (*)(char *, unint64_t *))v42)(v41, v9);
        v20 = v49;
        goto LABEL_3;
      }
      v34 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v9, v7);
      result = ((uint64_t (*)(char *, unint64_t *))v42)(v41, v9);
LABEL_16:
      v20 = v49;
      if (!v34)
        return v19;
      goto LABEL_3;
    }
    if (v25 < 64)
    {
      v34 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v9, v7);
      result = (*(uint64_t (**)(char *, unint64_t *))(v10 + 8))(v18, v9);
      goto LABEL_16;
    }
    v52 = 0;
    v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v7 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
    v43(&v52, &type metadata for Int, v44, v9, v7);
    v31 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v7 + 16) + 8) + 8))(v18, v16, v9);
    v32 = *(void (**)(char *, unint64_t *))(v10 + 8);
    v32(v18, v9);
    v33 = v16;
LABEL_18:
    result = ((uint64_t (*)(char *, unint64_t *))v32)(v33, v9);
    v20 = v49;
    if ((v31 & 1) != 0)
      return v19;
LABEL_3:
    a1 += v50;
    if (__OFADD__(v19++, 1))
      break;
    v51(v18, a1, v9);
  }
  __break(1u);
  return result;
}

uint64_t Unicode.UTF8.init()()
{
  return 0;
}

unint64_t Unicode.UTF8.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int *v3;
  unint64_t v6;
  unsigned int v7;
  void (*v8)(_QWORD *__return_ptr, uint64_t, uint64_t);
  char v9;
  unsigned int v10;
  unsigned __int8 v11;
  unsigned int v12;
  unsigned int v13;
  char v14;
  unsigned int v15;
  char v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t (*v23)();
  _QWORD v24[4];
  int v25;
  char v26;

  LODWORD(v6) = *v3;
  v7 = *((unsigned __int8 *)v3 + 4);
  v25 = *v3;
  v26 = v7;
  if (v7)
  {
    if ((v6 & 0x80) == 0)
    {
      lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(a1, a2, a3);
      v23 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(_QWORD *, _QWORD))v23)(v24, 0);
      v12 = (v6 + 1);
      goto LABEL_31;
    }
    v8 = *(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v24, a2, a3);
LABEL_7:
    if ((v24[0] & 0x100) != 0)
    {
      v13 = v6;
      v14 = v7;
    }
    else
    {
      if (v7 >= 0x20)
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
      v13 = v6 & ((-255 << v7) - 1) | (LOBYTE(v24[0]) << v7);
      v14 = v7 + 8;
      if (v7 <= 0x17)
      {
        v8(v24, a2, a3);
        if ((v24[0] & 0x100) == 0)
        {
          v13 = v13 & ((-65280 << v7) - 1) | (LOBYTE(v24[0]) << v14);
          v14 = v7 + 16;
          if (v7 <= 0xF)
          {
            v8(v24, a2, a3);
            if ((v24[0] & 0x100) == 0)
            {
              v13 = v13 & ((-16711680 << v7) - 1) | (LOBYTE(v24[0]) << v14);
              v14 = v7 + 24;
              if (v7 <= 7)
              {
                v8(v24, a2, a3);
                if ((v24[0] & 0x100) == 0)
                {
                  v13 = v13 & ((0x1000000 << v7) - 1) | (LOBYTE(v24[0]) << v14);
                  v14 = v7 + 32;
                }
              }
            }
          }
        }
      }
    }
    if ((v13 & 0xC0E0) == 0x80C0)
    {
      if ((v13 & 0x1E) != 0)
      {
        v15 = 16;
        v16 = 1;
LABEL_29:
        v10 = 1;
        v6 = (unint64_t)v13 >> (v15 & 0x38);
        v25 = v6;
        v9 = v14 - v15;
        v26 = v14 - v15;
        if ((v16 & 1) == 0)
        {
          v11 = 1;
          goto LABEL_38;
        }
        v12 = ((1 << ((v15 >> 1) & 0x1C) << ((v15 >> 1) & 0x1C)) - 1) & (v13 + 16843009);
        goto LABEL_31;
      }
    }
    else if ((v13 & 0xC0C0F0) == 0x8080E0)
    {
      if ((v13 & 0x200F) != 0 && (v13 & 0x200F) != 0x200D)
      {
        v15 = 24;
        v16 = 1;
        goto LABEL_29;
      }
    }
    else if ((v13 & 0xC0C0C0F8) == 0x808080F0 && (v13 & 0x3007) != 0 && __rev16(v13 & 0x3007) <= 0x400)
    {
      v15 = 32;
      v16 = 1;
      goto LABEL_29;
    }
    v17 = Unicode.UTF8.ForwardParser._invalidLength()();
    v16 = 0;
    v15 = 8 * v17;
    goto LABEL_29;
  }
  v8 = *(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
  v8(v24, a2, a3);
  if ((v24[0] & 0x100) != 0)
  {
    v9 = 0;
    v10 = 0;
    v11 = 1;
    goto LABEL_38;
  }
  if ((v24[0] & 0x80) != 0)
  {
    LODWORD(v6) = v6 & 0xFFFFFF00 | LOBYTE(v24[0]);
    v7 = 8;
    v8(v24, a2, a3);
    goto LABEL_7;
  }
  v12 = LOBYTE(v24[0]) + 1;
LABEL_31:
  v11 = 0;
  v18 = 4 - (__clz(v12) >> 3);
  v19 = ((v12 - 65793) >> 2) & 0xFC0 | ((v12 - 65793) >> 16) & 0x3F | (((v12 - 65793) & 0xF) << 12);
  v20 = (((v12 - 257) & 0x1F) << 6) | ((v12 - 257) >> 8) & 0x3F;
  v21 = ((v12 - 16843009) >> 10) & 0xFC0 | ((v12 - 16843009) >> 24) & 0x3F | ((((v12 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v12 - 16843009) & 7) << 18);
  v10 = v12 - 1;
  if (v18 != 1)
    v10 = v21;
  if (v18 == 2)
    v10 = v20;
  if (v18 == 3)
    v10 = v19;
  LODWORD(v6) = v25;
  v9 = v26;
LABEL_38:
  *v3 = v6;
  *((_BYTE *)v3 + 4) = v9;
  LOBYTE(v24[0]) = v11;
  return v10 | ((unint64_t)v11 << 32);
}

unint64_t static Unicode.UTF8._decodeOne(_:)(int a1)
{
  unsigned __int8 v2;
  unsigned int v3;
  uint64_t v4;
  char v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  if ((a1 & 0x80) == 0)
  {
    v2 = 0;
    v3 = a1;
    LOBYTE(v4) = 1;
    return ((unint64_t)v4 << 40) | ((unint64_t)v2 << 32) | v3;
  }
  if ((a1 & 0xC0E0) == 0x80C0)
  {
    if ((a1 & 0x1E) != 0)
    {
      LODWORD(v4) = 16;
      v5 = 1;
      goto LABEL_15;
    }
  }
  else if ((a1 & 0xC0C0F0) == 0x8080E0)
  {
    if ((a1 & 0x200F) != 0 && (a1 & 0x200F) != 0x200D)
    {
      LODWORD(v4) = 24;
      v5 = 1;
      goto LABEL_15;
    }
  }
  else if ((a1 & 0xC0C0C0F8) == 0x808080F0 && (a1 & 0x3007) != 0 && __rev16(a1 & 0x3007) <= 0x400)
  {
    LODWORD(v4) = 32;
    v5 = 1;
    goto LABEL_15;
  }
  v6 = Unicode.UTF8.ForwardParser._invalidLength()();
  v5 = 0;
  LODWORD(v4) = 8 * v6;
LABEL_15:
  if ((v5 & 1) != 0)
  {
    v2 = 0;
    v7 = ((1 << ((v4 >> 1) & 0x1C) << ((v4 >> 1) & 0x1C)) - 1) & (a1 + 16843009);
    v4 = 4 - (__clz(v7) >> 3);
    v8 = ((v7 - 65793) >> 2) & 0xFC0 | ((v7 - 65793) >> 16) & 0x3F | (((v7 - 65793) & 0xF) << 12);
    v9 = (((v7 - 257) & 0x1F) << 6) | ((v7 - 257) >> 8) & 0x3F;
    v10 = ((v7 - 16843009) >> 10) & 0xFC0 | ((v7 - 16843009) >> 24) & 0x3F | ((((v7 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v7 - 16843009) & 7) << 18);
    v3 = v7 - 1;
    if (v4 != 1)
      v3 = v10;
    if (v4 == 2)
      v3 = v9;
    if (v4 == 3)
      v3 = v8;
  }
  else
  {
    v3 = 0;
    LOBYTE(v4) = v4 >> 3;
    v2 = 1;
  }
  return ((unint64_t)v4 << 40) | ((unint64_t)v2 << 32) | v3;
}

uint64_t static Unicode.UTF8.encode(_:into:)(unsigned int a1, uint64_t (*a2)(void))
{
  uint64_t result;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;

  if (a1 < 0x80)
    return a2();
  v4 = (a1 & 0x3F) << 8;
  v5 = (v4 | (a1 >> 6) & 0x3F) << 8;
  v6 = (((v5 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
  v7 = (v5 | (a1 >> 12)) + 8487393;
  if (HIWORD(a1))
    v7 = v6;
  v8 = a1 <= 0x7FF ? (v4 | (a1 >> 6)) + 33217 : v7;
  ((void (*)(_QWORD))a2)(v8 - 1);
  result = ((uint64_t (*)(_QWORD))a2)((v8 >> 8) - 1);
  if (v8 >= 0x10000)
  {
    result = ((uint64_t (*)(_QWORD))a2)(HIWORD(v8) - 1);
    if (HIBYTE(v8))
      return a2();
  }
  return result;
}

unint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int *v3;
  int *v4;
  unint64_t v7;
  unsigned int v8;
  void (*v9)(_QWORD *__return_ptr, uint64_t, uint64_t);
  char v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  unsigned int v16;
  char v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t (*v24)();
  _QWORD v25[4];
  int v26;
  char v27;

  v4 = v3;
  LODWORD(v7) = *v3;
  v8 = *((unsigned __int8 *)v3 + 4);
  v26 = *v3;
  v27 = v8;
  if (v8)
  {
    if ((v7 & 0x80) == 0)
    {
      lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(a1, a2, a3);
      v24 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(_QWORD *, _QWORD))v24)(v25, 0);
      v13 = (v7 + 1);
      goto LABEL_31;
    }
    v9 = *(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v9(v25, a2, a3);
  }
  else
  {
    v9 = *(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v9(v25, a2, a3);
    if ((v25[0] & 0x100) != 0)
    {
      v10 = 0;
      v11 = 0;
      v12 = 1;
      goto LABEL_38;
    }
    if ((v25[0] & 0x80) == 0)
    {
      v13 = LOBYTE(v25[0]) + 1;
LABEL_31:
      v12 = 0;
      v19 = 4 - (__clz(v13) >> 3);
      v20 = ((v13 - 65793) >> 2) & 0xFC0 | ((v13 - 65793) >> 16) & 0x3F | (((v13 - 65793) & 0xF) << 12);
      v21 = (((v13 - 257) & 0x1F) << 6) | ((v13 - 257) >> 8) & 0x3F;
      v22 = ((v13 - 16843009) >> 10) & 0xFC0 | ((v13 - 16843009) >> 24) & 0x3F | ((((v13 - 16843009) >> 8) & 0x3F) << 12) & 0xFFE3FFFF | (((v13 - 16843009) & 7) << 18);
      v11 = v13 - 1;
      if (v19 != 1)
        v11 = v22;
      if (v19 == 2)
        v11 = v21;
      if (v19 == 3)
        v11 = v20;
      LODWORD(v7) = v26;
      v10 = v27;
      goto LABEL_38;
    }
    LODWORD(v7) = v7 & 0xFFFFFF00 | LOBYTE(v25[0]);
    v8 = 8;
    v9(v25, a2, a3);
  }
  if ((v25[0] & 0x100) != 0)
  {
    v14 = v7;
    v15 = v8;
  }
  else
  {
    if (v8 >= 0x20)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    v14 = v7 & ((-255 << v8) - 1) | (LOBYTE(v25[0]) << v8);
    v15 = v8 + 8;
    if (v8 <= 0x17)
    {
      v9(v25, a2, a3);
      if ((v25[0] & 0x100) == 0)
      {
        v14 = v14 & ((-65280 << v8) - 1) | (LOBYTE(v25[0]) << v15);
        v15 = v8 + 16;
        if (v8 <= 0xF)
        {
          v9(v25, a2, a3);
          if ((v25[0] & 0x100) == 0)
          {
            v14 = v14 & ((-16711680 << v8) - 1) | (LOBYTE(v25[0]) << v15);
            v15 = v8 + 24;
            if (v8 <= 7)
            {
              v9(v25, a2, a3);
              if ((v25[0] & 0x100) == 0)
              {
                v14 = v14 & ((0x1000000 << v8) - 1) | (LOBYTE(v25[0]) << v15);
                v15 = v8 + 32;
              }
            }
          }
        }
      }
    }
  }
  if ((v14 & 0xC0E0) == 0x80C0)
  {
    if ((v14 & 0x1E) != 0)
    {
      v16 = 16;
      v17 = 1;
      goto LABEL_29;
    }
  }
  else if ((v14 & 0xC0C0F0) == 0x8080E0)
  {
    if ((v14 & 0x200F) != 0 && (v14 & 0x200F) != 0x200D)
    {
      v16 = 24;
      v17 = 1;
      goto LABEL_29;
    }
  }
  else if ((v14 & 0xC0C0C0F8) == 0x808080F0 && (v14 & 0x3007) != 0 && __rev16(v14 & 0x3007) <= 0x400)
  {
    v16 = 32;
    v17 = 1;
    goto LABEL_29;
  }
  v18 = Unicode.UTF8.ForwardParser._invalidLength()();
  v17 = 0;
  v16 = 8 * v18;
LABEL_29:
  v7 = (unint64_t)v14 >> (v16 & 0x38);
  v26 = v7;
  v10 = v15 - v16;
  v27 = v15 - v16;
  if ((v17 & 1) != 0)
  {
    v13 = ((1 << ((v16 >> 1) & 0x1C) << ((v16 >> 1) & 0x1C)) - 1) & (v14 + 16843009);
    goto LABEL_31;
  }
  if (!specialized numericCast<A, B>(_:)(8uLL))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  v11 = 1;
  v12 = 1;
LABEL_38:
  *v4 = v7;
  *((_BYTE *)v4 + 4) = v10;
  LOBYTE(v25[0]) = v12;
  return v11 | ((unint64_t)v12 << 32);
}

uint64_t protocol witness for static UnicodeCodec.encode(_:into:) in conformance Unicode.UTF8(unsigned int a1, uint64_t (*a2)(char *))
{
  unsigned int v3;
  uint64_t result;
  int v5;
  int v6;
  int v7;
  int v8;
  char v9;
  char v10;
  char v11;
  char v12;

  if (a1 >= 0x80)
  {
    v5 = (a1 & 0x3F) << 8;
    if (a1 >= 0x800)
    {
      v6 = (v5 | (a1 >> 6) & 0x3F) << 8;
      v7 = (((v6 | (a1 >> 12) & 0x3F) << 8) | (a1 >> 18)) - 2122219023;
      v8 = (v6 | (a1 >> 12)) + 8487393;
      if (HIWORD(a1))
        v3 = v7;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v5 | (a1 >> 6)) + 33217;
    }
  }
  else
  {
    v3 = a1 + 1;
  }
  v12 = v3 - 1;
  result = a2(&v12);
  if (v3 >= 0x100)
  {
    v11 = BYTE1(v3) - 1;
    result = a2(&v11);
    if (HIWORD(v3))
    {
      v10 = BYTE2(v3) - 1;
      result = a2(&v10);
      if (HIBYTE(v3))
      {
        v9 = HIBYTE(v3) - 1;
        return a2(&v9);
      }
    }
  }
  return result;
}

uint64_t Unicode.UTF16.init()()
{
  return 0;
}

unint64_t Unicode.UTF16.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v6;
  unsigned int v7;
  void (*v8)(_QWORD *__return_ptr, uint64_t, uint64_t);
  char v9;
  unsigned int v10;
  unsigned __int8 v11;
  char v12;
  unsigned int v13;
  char v14;
  BOOL v15;
  char v16;
  unint64_t v17;
  uint64_t (*v19)();
  _QWORD v20[4];
  unsigned int v21;
  char v22;

  v6 = *(_DWORD *)v3;
  v7 = *(unsigned __int8 *)(v3 + 4);
  v21 = *(_DWORD *)v3;
  v22 = v7;
  if (v7)
  {
    if ((v6 & 0xF800) != 0xD800)
    {
      lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser(a1, a2, a3);
      v19 = protocol witness for _UTFParser._buffer.modify in conformance Unicode.UTF8.ReverseParser();
      specialized RangeReplaceableCollection.remove(at:)(0);
      ((void (*)(_QWORD *, _QWORD))v19)(v20, 0);
      v11 = 0;
      v10 = (unsigned __int16)v6;
      v6 = v21;
      v9 = v22;
      goto LABEL_23;
    }
    v8 = *(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v20, a2, a3);
  }
  else
  {
    v8 = *(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t))(a3 + 16);
    v8(v20, a2, a3);
    if ((v20[0] & 0x10000) != 0)
    {
      v9 = 0;
      v10 = 0;
      v11 = 1;
      goto LABEL_23;
    }
    v10 = LOWORD(v20[0]);
    if ((v20[0] & 0xF800) != 0xD800)
    {
      v9 = 0;
      v11 = 0;
      goto LABEL_23;
    }
    v6 = v6 & 0xFFFF0000 | LOWORD(v20[0]);
    v7 = 16;
    v8(v20, a2, a3);
  }
  if ((v20[0] & 0x10000) != 0)
  {
    v12 = v7;
  }
  else
  {
    if (v7 >= 0x20)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UIntBuffer.swift", 22, 2, 0xBEuLL, 0);
    v6 = v6 & ((-65535 << v7) - 1) | (LOWORD(v20[0]) << v7);
    v12 = v7 + 16;
    if (v7 <= 0xF)
    {
      v8(v20, a2, a3);
      if ((v20[0] & 0x10000) == 0)
      {
        v6 = v6 & ((0x10000 << v7) - 1) | (LOWORD(v20[0]) << v12);
        v12 = v7 + 32;
      }
    }
  }
  v13 = v6 & 0xFC00FC00;
  if ((v6 & 0xFC00FC00) == 0xDC00D800)
    v14 = 32;
  else
    v14 = 16;
  v9 = v12 - v14;
  v15 = v13 == -603924480;
  if (v13 == -603924480)
    v16 = 32;
  else
    v16 = 16;
  v17 = (unint64_t)v6 >> v16;
  v10 = (HIWORD(v6) & 0x3FF | ((v6 & 0x3FF) << 10)) + 0x10000;
  if (v15)
  {
    v11 = 0;
  }
  else
  {
    v10 = 1;
    v11 = 1;
  }
  v6 = v17;
LABEL_23:
  *(_DWORD *)v3 = v6;
  *(_BYTE *)(v3 + 4) = v9;
  LOBYTE(v20[0]) = v11;
  return v10 | ((unint64_t)v11 << 32);
}

uint64_t Unicode.UTF16._decodeOne<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;

  v3 = Unicode.UTF16.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t static Unicode.UTF16.encode(_:into:)(unsigned int a1, uint64_t (*a2)(void))
{
  if (a1 >= 0x10000)
    ((void (*)(_QWORD))a2)(((a1 + 983040) >> 10) & 0x3FF | ((a1 & 0x3FF) << 16) | 0xDC00D800);
  return a2();
}

uint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;

  v3 = Unicode.UTF16.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

_WORD *protocol witness for static UnicodeCodec._nullCodeUnitOffset(in:) in conformance Unicode.UTF16(_WORD *result)
{
  uint64_t i;
  uint64_t v2;

  if (!*result)
    return 0;
  for (i = 0; ; ++i)
  {
    v2 = i + 1;
    if (__OFADD__(i, 1))
      break;
    if (!result[v2])
      return (_WORD *)v2;
  }
  __break(1u);
  return result;
}

unint64_t Unicode.UTF32.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v8;

  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(a3 + 16))(&v8, a2, a3);
  v3 = v8;
  v4 = WORD1(v8) > 0x10u || v8 >> 11 == 27;
  v5 = v4;
  if (v4)
    v3 = 1;
  if ((v8 & 0x100000000) != 0)
  {
    v3 = 0;
    v6 = 1;
  }
  else
  {
    v6 = v5;
  }
  return v3 | ((unint64_t)v6 << 32);
}

uint64_t static Unicode.UTF32.encode(_:into:)(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

uint64_t protocol witness for UnicodeCodec.decode<A>(_:) in conformance Unicode.UTF32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;

  v3 = Unicode.UTF32.decode<A>(_:)(a1, a2, a3);
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

uint64_t protocol witness for static UnicodeCodec.encode(_:into:) in conformance Unicode.UTF32(int a1, uint64_t (*a2)(int *))
{
  int v3;

  v3 = a1;
  return a2(&v3);
}

_DWORD *protocol witness for static UnicodeCodec._nullCodeUnitOffset(in:) in conformance Unicode.UTF32(_DWORD *result)
{
  uint64_t i;
  uint64_t v2;

  if (!*result)
    return 0;
  for (i = 0; ; ++i)
  {
    v2 = i + 1;
    if (__OFADD__(i, 1))
      break;
    if (!result[v2])
      return (_DWORD *)v2;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static _StringElement._toUTF16CodeUnit(_:) in conformance UInt16(unsigned __int16 *a1)
{
  return *a1;
}

uint64_t protocol witness for static _StringElement._fromUTF16CodeUnit(_:) in conformance UInt16@<X0>(uint64_t result@<X0>, _WORD *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t static UInt8._toUTF16CodeUnit(_:)(uint64_t result)
{
  return result;
}

BOOL hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(unsigned int a1)
{
  int32x4_t v1;
  uint64_t v2;

  v1 = vdupq_n_s32(a1);
  v2 = 1;
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v1, (int32x4_t)xmmword_1816ABE80), (uint32x4_t)xmmword_1816ABEA0), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v1, (int32x4_t)xmmword_1816ABE90), (uint32x4_t)xmmword_1816ABEB0)))) & 1) == 0)return a1 < 0x300 || a1 - 65281 < 0x9D;
  return v2;
}

Swift::String::Index __swiftcall _StringGuts._slowRoundDownToNearestCharacter(_:)(Swift::String::Index a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  int64_t v6;
  char *v7;
  char *v8;
  Swift::Int v9;
  int v10;
  char *v12;
  uint64_t v13;
  int v14;
  int v15;
  Swift::Int v17;
  int64_t v18;
  Swift::Int v19;
  Swift::Int v20;
  Swift::Int v22;
  uint64_t v23;
  uint64_t v24;

  v3 = v2;
  v4 = v1;
  v6 = a1._rawBits >> 16;
  if (a1._rawBits < 0x20000)
  {
    v9 = 0;
    goto LABEL_15;
  }
  if ((v2 & 0x1000000000000000) != 0)
    goto LABEL_43;
  if ((v2 & 0x2000000000000000) != 0)
  {
    v23 = v1;
    v24 = v2 & 0xFFFFFFFFFFFFFFLL;
    v8 = (char *)&v23 + v6;
  }
  else
  {
    if ((v1 & 0x1000000000000000) != 0)
    {
      v7 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v7 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
      if (!v7)
LABEL_48:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
    }
    v8 = &v7[v6];
  }
  v10 = *((unsigned __int16 *)v8 - 1);
  if (v10 != 2573 && (v10 & 0x80808080) == 0)
  {
    v9 = v6 - 1;
    if (__OFSUB__(v6, 1))
      goto LABEL_45;
    goto LABEL_15;
  }
  while (1)
  {
LABEL_43:
    v22 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v6);
    v9 = v6 - v22;
    if (__OFSUB__(v6, v22))
    {
LABEL_45:
      __break(1u);
      goto LABEL_46;
    }
LABEL_15:
    if ((v3 & 0x1000000000000000) != 0)
      goto LABEL_40;
    if ((v3 & 0x2000000000000000) == 0)
      break;
    v23 = v4;
    v24 = v3 & 0xFFFFFFFFFFFFFFLL;
    if (v9 + 1 != (HIBYTE(v3) & 0xF))
    {
      v15 = *(unsigned __int16 *)((char *)&v23 + v9);
      if (v15 == 2573 || (v15 & 0x80808080) != 0)
        goto LABEL_40;
    }
LABEL_30:
    v17 = 1;
    v18 = v9 + 1;
    if (!__OFADD__(v9, 1))
      goto LABEL_31;
LABEL_42:
    __break(1u);
  }
  if ((v4 & 0x1000000000000000) != 0)
  {
    v12 = (char *)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    v13 = v4 & 0xFFFFFFFFFFFFLL;
    goto LABEL_19;
  }
LABEL_46:
  v12 = (char *)_StringObject.sharedUTF8.getter(v4, v3);
LABEL_19:
  if (v9 + 1 == v13)
    goto LABEL_30;
  if (!v12)
    goto LABEL_48;
  v14 = *(unsigned __int16 *)&v12[v9];
  if (v14 != 2573 && (v14 & 0x80808080) == 0)
    goto LABEL_30;
LABEL_40:
  v17 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9);
  v18 = v9 + v17;
  if (__OFADD__(v9, v17))
    goto LABEL_42;
LABEL_31:
  if (v6 >= v18)
    return (Swift::String::Index)(a1._rawBits | 3);
  v19 = v17 << 8;
  if (v17 > 63)
    v19 = 0;
  v20 = v19 | (v9 << 16);
  if ((v3 & 0x1000000000000000) == 0 || (v4 & 0x800000000000000) != 0)
    return (Swift::String::Index)(v20 | 7);
  else
    return (Swift::String::Index)(v20 | 0xB);
}

uint64_t _StringGuts._slowRoundDownToNearestCharacter(_:in:)(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  char v7;
  unint64_t v8;
  Swift::Int v9;
  uint64_t v10;
  Swift::Int v11;
  char *v12;
  uint64_t v13;
  int v14;
  Swift::Int v16;
  Swift::Int v17;
  Swift::Int v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD v22[2];

  v7 = a2;
  v8 = a1;
  v9 = a1 >> 16;
  v10 = _StringGuts._opaqueCharacterStride(endingAt:in:)(a1 >> 16, a2 >> 16, a3, a4, a5);
  v11 = v9 - v10;
  if (__OFSUB__(v9, v10))
    goto LABEL_29;
  if ((a5 & 0x1000000000000000) != 0)
    goto LABEL_26;
  if ((a5 & 0x2000000000000000) != 0)
  {
    v22[0] = a4;
    v22[1] = a5 & 0xFFFFFFFFFFFFFFLL;
    if (v11 + 1 != (HIBYTE(a5) & 0xF))
    {
      v14 = *(unsigned __int16 *)((char *)v22 + v11);
      goto LABEL_11;
    }
    goto LABEL_16;
  }
  if ((a4 & 0x1000000000000000) == 0)
    goto LABEL_30;
  v12 = (char *)((a5 & 0xFFFFFFFFFFFFFFFLL) + 32);
  v13 = a4 & 0xFFFFFFFFFFFFLL;
  while (1)
  {
    if (v11 + 1 != v13)
    {
      if (!v12)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
      v14 = *(unsigned __int16 *)&v12[v11];
LABEL_11:
      if (v14 == 2573 || (v14 & 0x8080) != 0)
        break;
    }
LABEL_16:
    v16 = 1;
    v17 = v11 + 1;
    if (!__OFADD__(v11, 1))
      goto LABEL_17;
LABEL_28:
    __break(1u);
LABEL_29:
    __break(1u);
LABEL_30:
    v12 = (char *)_StringObject.sharedUTF8.getter(a4, a5);
  }
LABEL_26:
  v16 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v11);
  v17 = v11 + v16;
  if (__OFADD__(v11, v16))
    goto LABEL_28;
LABEL_17:
  if (v9 < v17)
  {
    v18 = v16 << 8;
    if (v16 > 63)
      v18 = 0;
    v19 = v7 & 2 | (unint64_t)(v11 << 16) | v18;
    if ((a5 & 0x1000000000000000) == 0 || (a4 & 0x800000000000000) != 0)
      v20 = 5;
    else
      v20 = 9;
    return v19 | v20;
  }
  return v8;
}

Swift::Int __swiftcall _StringGuts._opaqueComplexCharacterStride(startingAt:)(Swift::Int startingAt)
{
  uint64_t v1;
  unint64_t v2;
  unsigned __int8 *v4;
  Swift::Int v5;
  Swift::Unicode::Scalar v6;
  uint64_t v7;
  Swift::Int i;
  Swift::UInt32 v9;
  Swift::Int v10;
  Swift::Unicode::Scalar v11;
  uint64_t v12;
  Swift::UInt32 v13;
  _QWORD v15[2];

  if ((v2 & 0x1000000000000000) == 0)
  {
    if ((v2 & 0x2000000000000000) != 0)
    {
      v10 = HIBYTE(v2) & 0xF;
      v15[0] = v1;
      v15[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (v10 > startingAt)
      {
        v11._value = _decodeScalar(_:startingAt:)((uint64_t)v15, v1, startingAt);
        for (i = v12 + startingAt; i < v10; v11._value = v13)
        {
          v13 = *((unsigned __int8 *)v15 + i);
          if (*((char *)v15 + i) < 0)
            __asm { BR              X9 }
          if (_GraphemeBreakingState.shouldBreak(between:and:)(v11, (Swift::Unicode::Scalar)*((unsigned __int8 *)v15 + i)))
          {
            break;
          }
          ++i;
        }
        return i - startingAt;
      }
    }
    else
    {
      if ((v1 & 0x1000000000000000) != 0)
      {
        v4 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v5 = v1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v4 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v1, v2);
        v5 = v1;
      }
      LODWORD(v15[0]) = 0;
      if (v5 > startingAt)
      {
        v6._value = _decodeScalar(_:startingAt:)((uint64_t)v4, v1, startingAt);
        for (i = v7 + startingAt; i < v5; v6._value = v9)
        {
          v9 = v4[i];
          if ((char)v4[i] < 0)
            __asm { BR              X9 }
          if (_GraphemeBreakingState.shouldBreak(between:and:)(v6, (Swift::Unicode::Scalar)v4[i]))
            break;
          ++i;
        }
        return i - startingAt;
      }
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGraphemeBreaking.swift", 34, 2, 0x280uLL, 0);
  }
  return _StringGuts._foreignOpaqueCharacterStride(startingAt:)(startingAt, v1, v2);
}

Swift::UInt64 _StringGuts._foreignOpaqueCharacterStride(startingAt:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  Swift::String::Index v7;
  Swift::String::Index v8;
  Swift::String::Index v9;
  Swift::UInt64 v10;
  id v11;
  Swift::Unicode::Scalar v12;
  Swift::String::Index v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  unsigned int v17;
  Swift::UInt64 rawBits;
  Swift::Unicode::Scalar v19;
  Swift::String::Index v20;
  Swift::Bool v21;
  Swift::UInt64 v22;
  Swift::String::Index v23;
  Swift::String::Index v24;
  Swift::UInt64 v25;
  id v26;
  Swift::String::Index v27;
  unsigned __int8 *v28;
  Swift::UInt64 v29;
  int v30;
  int v31;
  unsigned int v32;
  Swift::String::Index v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;

  if ((a3 & 0x2000000000000000) != 0)
    v3 = HIBYTE(a3) & 0xF;
  else
    v3 = a2 & 0xFFFFFFFFFFFFLL;
  v38 = 0;
  if (v3 <= a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGraphemeBreaking.swift", 34, 2, 0x280uLL, 0);
  v7._rawBits = a1 << 16;
  v8._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  v35 = a1;
  if ((a3 & 0x1000000000000000) != 0)
  {
    v12._value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v8._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
    v34._rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits;
    rawBits = String.UnicodeScalarView._foreignIndex(after:)(v34)._rawBits;
  }
  else
  {
    v10 = v8._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      v36 = a2;
      v37 = a3 & 0xFFFFFFFFFFFFFFLL;
      v12._value = _decodeScalar(_:startingAt:)((uint64_t)&v36, v9._rawBits, v10);
      v13._rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits >> 16;
      v36 = a2;
      v37 = a3 & 0xFFFFFFFFFFFFFFLL;
      v15 = *((unsigned __int8 *)&v36 + v13._rawBits);
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0)
        v11 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      else
        v11 = _StringObject.sharedUTF8.getter(a2, a3);
      v12._value = _decodeScalar(_:startingAt:)((uint64_t)v11, v9._rawBits, v10);
      v13._rawBits = _StringGuts.validateScalarIndex(_:)(v7)._rawBits >> 16;
      if ((a2 & 0x1000000000000000) != 0)
        v14 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      else
        v14 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
      v15 = v14[v13._rawBits];
    }
    v16 = (char)v15;
    v17 = __clz(v15 ^ 0xFF) - 24;
    if (v16 >= 0)
      LOBYTE(v17) = 1;
    rawBits = ((v13._rawBits + v17) << 16) | 5;
  }
  do
  {
    v22 = rawBits >> 16;
    if (rawBits >> 16 >= v3)
      break;
    v23._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits;
    if ((a3 & 0x1000000000000000) != 0)
    {
      v19._value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v23._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
      v20._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits;
      rawBits = String.UnicodeScalarView._foreignIndex(after:)(v20)._rawBits;
    }
    else
    {
      v25 = v23._rawBits >> 16;
      if ((a3 & 0x2000000000000000) != 0)
      {
        v36 = a2;
        v37 = a3 & 0xFFFFFFFFFFFFFFLL;
        v19._value = _decodeScalar(_:startingAt:)((uint64_t)&v36, v24._rawBits, v25);
        v29 = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits >> 16;
        v36 = a2;
        v37 = a3 & 0xFFFFFFFFFFFFFFLL;
        v30 = *((unsigned __int8 *)&v36 + v29);
      }
      else
      {
        v26 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a2 & 0x1000000000000000) == 0)
          v26 = _StringObject.sharedUTF8.getter(a2, a3);
        v19._value = _decodeScalar(_:startingAt:)((uint64_t)v26, v24._rawBits, v25);
        v27._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)(rawBits & 0xFFFFFFFFFFFF0000))._rawBits;
        v28 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a2 & 0x1000000000000000) == 0)
          v28 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
        v29 = v27._rawBits >> 16;
        v30 = v28[v27._rawBits >> 16];
      }
      v31 = (char)v30;
      v32 = __clz(v30 ^ 0xFF) - 24;
      if (v31 >= 0)
        LOBYTE(v32) = 1;
      rawBits = ((v29 + v32) << 16) | 5;
    }
    v21 = _GraphemeBreakingState.shouldBreak(between:and:)(v12, v19);
    v12._value = v19._value;
  }
  while (!v21);
  return v22 - v35;
}

Swift::Int __swiftcall _StringGuts._opaqueComplexCharacterStride(endingAt:)(Swift::Int endingAt)
{
  uint64_t v1;
  unint64_t v2;
  char *v3;
  char *v5;
  Swift::Int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  Swift::Int v12;
  Swift::Int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  Swift::Int v19;
  _BYTE v21[2];
  _QWORD v22[2];

  if ((v2 & 0x1000000000000000) == 0)
  {
    if ((v2 & 0x2000000000000000) != 0)
    {
      v22[0] = v1;
      v22[1] = v2 & 0xFFFFFFFFFFFFFFLL;
      if (endingAt > 0)
      {
        v6 = endingAt - 1;
        if ((*((_BYTE *)v22 + endingAt - 1) & 0xC0) == 0x80)
        {
          v13 = endingAt;
          do
            v14 = v21[v13--] & 0xC0;
          while (v14 == 128);
          v6 = v13 - 1;
        }
        v15 = _decodeScalar(_:startingAt:)((uint64_t)v22, v1, v6);
        if (v6 >= 1)
        {
          v16 = v15;
          do
          {
            v17 = v6 - 1;
            v18 = *((unsigned __int8 *)v22 + v6 - 1);
            if ((v18 & 0xC0) == 0x80)
            {
              v19 = v6;
              do
                v18 = v21[v19--];
              while ((v18 & 0xC0) == 0x80);
              v17 = v19 - 1;
            }
            if ((v18 & 0x80) != 0)
              __asm { BR              X9 }
            if ((specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(v18, v16, v6, (uint64_t)v22) & 1) != 0)
              break;
            v6 = v17;
            v16 = v18;
          }
          while (v17 > 0);
        }
        return endingAt - v6;
      }
    }
    else if ((v1 & 0x1000000000000000) != 0)
    {
      v5 = (char *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      if (endingAt >= 1)
      {
LABEL_5:
        v6 = endingAt;
        do
          v7 = v5[--v6] & 0xC0;
        while (v7 == 128);
        v8 = _decodeScalar(_:startingAt:)((uint64_t)v5, v1, v6);
        if (v6 >= 1)
        {
          v9 = v8;
          do
          {
            v10 = v6 - 1;
            v11 = v5[v6 - 1];
            if ((v11 & 0xC0) == 0x80)
            {
              v12 = v6;
              do
                v11 = v5[v12-- - 2];
              while ((v11 & 0xC0) == 0x80);
              v10 = v12 - 1;
            }
            if ((v11 & 0x80) != 0)
              __asm { BR              X9 }
            if ((specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(v11, v9, v6, (uint64_t)v5) & 1) != 0)
              break;
            v6 = v10;
            v9 = v11;
          }
          while (v10 > 0);
        }
        return endingAt - v6;
      }
    }
    else
    {
      v5 = (char *)_StringObject.sharedUTF8.getter(v1, v2);
      if (endingAt >= 1)
        goto LABEL_5;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGraphemeBreaking.swift", 34, 2, 0x2A1uLL, 0);
  }
  return _StringGuts._foreignOpaqueCharacterStride(endingAt:)(endingAt, v1, v2, v3);
}

Swift::UInt64 _StringGuts._foreignOpaqueCharacterStride(endingAt:)(uint64_t a1, uint64_t a2, unint64_t a3, char *a4)
{
  unint64_t v4;
  Swift::String::Index v8;
  Swift::String::Index v9;
  Swift::UInt64 rawBits;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  int v18;
  Swift::String::Index v19;
  _QWORD *v20;
  unsigned int value;
  unsigned int v22;
  Swift::String::Index v24;
  char *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  Swift::String::Index v29;
  Swift::String::Index v30;
  unsigned int v31;
  Swift::Int scalarLength;
  uint64_t v33;
  char *v34;
  Swift::tuple_Unicode_Scalar_scalarLength_Int v35;
  uint64_t v36;
  int v37;
  Swift::String::Index v38;
  Swift::String::Index v39;
  _QWORD *v40;
  unsigned int v41;
  char v42;
  Swift::String::Index v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;

  if (a1 < 1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGraphemeBreaking.swift", 34, 2, 0x2A1uLL, 0);
  v8._rawBits = a1 << 16;
  swift_bridgeObjectRetain(a3, a2, a3, a4);
  v9._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)(v8)._rawBits;
  if (!(v9._rawBits >> 14))
    goto LABEL_46;
  rawBits = v9._rawBits;
  if ((a3 & 0x1000000000000000) == 0)
  {
    if ((a3 & 0x2000000000000000) != 0)
    {
      v45 = a2;
      v46 = a3 & 0xFFFFFFFFFFFFFFLL;
      v15 = (char *)&v45 + (v9._rawBits >> 16);
      if ((*(v15 - 1) & 0xC0) == 0x80)
      {
        v16 = 0;
        v17 = v15 - 2;
        do
          v18 = v17[v16--] & 0xC0;
        while (v18 == 128);
        v14 = 1 - v16;
      }
      else
      {
        v14 = 1;
      }
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0)
      {
        v11 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        v11 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
        if (!v11)
        {
LABEL_49:
          swift_bridgeObjectRelease(a3);
          __break(1u);
          goto LABEL_50;
        }
      }
      v12 = 0;
      do
        v13 = v11[(rawBits >> 16) - 1 + v12--] & 0xC0;
      while (v13 == 128);
      v14 = -v12;
    }
    v4 = (rawBits - (v14 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
    rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)v4)._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      v45 = a2;
      v46 = a3 & 0xFFFFFFFFFFFFFFLL;
      v20 = &v45;
      goto LABEL_19;
    }
    if ((a2 & 0x1000000000000000) != 0)
    {
      v20 = (_QWORD *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
LABEL_19:
      value = _decodeScalar(_:startingAt:)((uint64_t)v20, v19._rawBits, rawBits);
      goto LABEL_20;
    }
LABEL_50:
    v20 = _StringObject.sharedUTF8.getter(a2, a3);
    goto LABEL_19;
  }
  v4 = String.UnicodeScalarView._foreignIndex(before:)(v9)._rawBits;
  v43._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)v4)._rawBits;
  value = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v43._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
LABEL_20:
  v22 = value;
  rawBits = v4 >> 16;
  if (v4 >= 0x10000)
  {
    v44 = (char *)&v44 + 6;
    while (1)
    {
      v24._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(rawBits << 16))._rawBits;
      if (!(v24._rawBits >> 14))
        break;
      v4 = v24._rawBits;
      if ((a3 & 0x1000000000000000) != 0)
      {
        v29._rawBits = String.UnicodeScalarView._foreignIndex(before:)(v24)._rawBits;
        v30._rawBits = _StringGuts.validateScalarIndex(_:)(v29)._rawBits;
        v35 = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v30._rawBits & 0xFFFFFFFFFFFF0000));
        scalarLength = v35.scalarLength;
        v31 = v35._0._value;
      }
      else
      {
        if ((a3 & 0x2000000000000000) != 0)
        {
          v45 = a2;
          v46 = a3 & 0xFFFFFFFFFFFFFFLL;
          if ((*((_BYTE *)&v45 + (v24._rawBits >> 16) - 1) & 0xC0) == 0x80)
          {
            v36 = 0;
            do
              v37 = v44[(v24._rawBits >> 16) + v36--] & 0xC0;
            while (v37 == 128);
            v28 = 1 - v36;
          }
          else
          {
            v28 = 1;
          }
        }
        else
        {
          v25 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a2 & 0x1000000000000000) == 0)
          {
            v25 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
            if (!v25)
              goto LABEL_49;
          }
          v26 = 0;
          do
            v27 = v25[(v4 >> 16) - 1 + v26--] & 0xC0;
          while (v27 == 128);
          v28 = -v26;
        }
        v29._rawBits = (v4 - (v28 << 16)) & 0xFFFFFFFFFFFF0000 | 5;
        v39._rawBits = _StringGuts.validateScalarIndex(_:)(v29)._rawBits >> 16;
        if ((a3 & 0x2000000000000000) != 0)
        {
          v45 = a2;
          v46 = a3 & 0xFFFFFFFFFFFFFFLL;
          v40 = &v45;
        }
        else
        {
          v40 = (_QWORD *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
          if ((a2 & 0x1000000000000000) == 0)
            v40 = _StringObject.sharedUTF8.getter(a2, a3);
        }
        v31 = _decodeScalar(_:startingAt:)((uint64_t)v40, v38._rawBits, v39._rawBits);
      }
      v41 = v31;
      swift_bridgeObjectRetain(a3, scalarLength, v33, v34);
      v42 = specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(v41, v22, rawBits, (char *)a2, a3);
      swift_bridgeObjectRelease(a3);
      if ((v42 & 1) == 0)
      {
        rawBits = v29._rawBits >> 16;
        v22 = v41;
        if (v29._rawBits >> 16)
          continue;
      }
      goto LABEL_21;
    }
LABEL_46:
    swift_bridgeObjectRelease(a3);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
LABEL_21:
  swift_bridgeObjectRelease(a3);
  return a1 - rawBits;
}

uint64_t closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Swift::String::Index v5;
  id v6;
  uint64_t v7;
  Swift::UInt64 v8;
  int v9;
  uint64_t v10;
  uint64_t result;
  char *v12;
  uint64_t v13;
  char *v14;
  int v15;
  Swift::String::Index v16;
  Swift::String::Index v17;
  _QWORD *v18;
  Swift::UInt64 rawBits;
  Swift::String::Index v20;
  Swift::UInt64 v21;
  uint64_t v22;
  Swift::UInt64 v23;
  uint64_t v24;
  uint64_t v25;

  if (a1 < 1)
    return 0;
  v5._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  if (!(v5._rawBits >> 14))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  if ((a3 & 0x1000000000000000) != 0)
  {
    rawBits = String.UnicodeScalarView._foreignIndex(before:)(v5)._rawBits;
    v20._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)rawBits)._rawBits;
    LODWORD(result) = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v20._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
  }
  else
  {
    if ((a3 & 0x2000000000000000) != 0)
    {
      v24 = a2;
      v25 = a3 & 0xFFFFFFFFFFFFFFLL;
      v12 = (char *)&v24 + (v5._rawBits >> 16);
      if ((*(v12 - 1) & 0xC0) == 0x80)
      {
        v13 = 0;
        v14 = v12 - 2;
        do
          v15 = v14[v13--] & 0xC0;
        while (v15 == 128);
        v10 = 1 - v13;
      }
      else
      {
        v10 = 1;
      }
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0)
      {
        v6 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        v21 = v5._rawBits;
        v6 = _StringObject.sharedUTF8.getter(a2, a3);
        v5._rawBits = v21;
      }
      v7 = 0;
      v8 = (Swift::UInt64)v6 + (v5._rawBits >> 16) - 1;
      do
        v9 = *(_BYTE *)(v8 + v7--) & 0xC0;
      while (v9 == 128);
      v10 = -v7;
    }
    v17._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)((v5._rawBits - (v10 << 16)) & 0xFFFFFFFFFFFF0000 | 5))._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      v24 = a2;
      v25 = a3 & 0xFFFFFFFFFFFFFFLL;
      v18 = &v24;
    }
    else if ((a2 & 0x1000000000000000) != 0)
    {
      v18 = (_QWORD *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v22 = a3;
      v23 = v17._rawBits;
      v18 = _StringObject.sharedUTF8.getter(a2, v22);
      v17._rawBits = v23;
    }
    LODWORD(result) = _decodeScalar(_:startingAt:)((uint64_t)v18, v16._rawBits, v17._rawBits);
  }
  return result;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance _GraphemeBreakingState(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2 | a1[1] ^ a2[1] | a1[2] ^ a2[2] | a2[3] ^ a1[3]) & 1) == 0;
}

uint64_t _GraphemeBreakingState.description.getter(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  int64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  BOOL v27;
  int64_t v28;
  char v29;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  Swift::String::Index v38;
  Swift::String::Index v39;
  Swift::String::Index v40;
  Swift::String::Index v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  char v50;
  uint64_t v51;
  char *v52;
  size_t v53;
  uint64_t v54;
  int64_t v55;
  char *v56;
  size_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int64_t v61;
  int64_t v62;
  char v63;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  Swift::String::Index v72;
  Swift::String::Index v73;
  Swift::String::Index v74;
  Swift::String::Index v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  char v83;
  char *v84;
  size_t v85;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  Swift::String::Index v95;
  Swift::String::Index v96;
  Swift::String::Index v97;
  Swift::String::Index v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  char v107;
  unint64_t v108;
  uint64_t v109;
  Swift::Int v110;
  Swift::Int v111;
  Swift::Int v112;
  unint64_t v113;
  __int128 v114;
  uint64_t v115;
  unint64_t v116;

  LODWORD(v4) = a1;
  v5 = 91;
  v6 = 0xE100000000000000;
  v115 = 91;
  v116 = 0xE100000000000000;
  if ((a1 & 1) == 0)
  {
    if ((a1 & 0x100) == 0)
      goto LABEL_3;
LABEL_6:
    v7 = HIBYTE(v6) & 3;
    if (v7)
    {
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0xE100000000000000);
      v5 = (69 << (8 * v7)) | ((-255 << (8 * v7)) - 1) & v5;
      v6 = (v7 << 56) - 0x1F00000000000000;
      v115 = v5;
      v116 = v6;
      if ((v4 & 0x10000) == 0)
        goto LABEL_14;
    }
    else
    {
      v5 = 69;
      v115 = 69;
      v116 = 0xE100000000000000;
      swift_bridgeObjectRelease(v6);
      v6 = 0xE100000000000000;
      if ((v4 & 0x10000) == 0)
        goto LABEL_14;
    }
    goto LABEL_10;
  }
  swift_bridgeObjectRelease_n(0xE100000000000000, 2);
  v5 = 22107;
  v6 = 0xE200000000000000;
  v115 = 22107;
  v116 = 0xE200000000000000;
  if ((v4 & 0x100) != 0)
    goto LABEL_6;
LABEL_3:
  if ((v4 & 0x10000) == 0)
    goto LABEL_14;
LABEL_10:
  v8 = HIBYTE(v6) & 0xF;
  if (!v8 && (v6 & 0x2000000000000000) != 0)
  {
    v115 = 73;
    v116 = 0xE100000000000000;
    v9 = v6;
    goto LABEL_13;
  }
  if ((v6 & 0x2000000000000000) == 0 || v8 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6, a3, a4);
    if ((v6 & 0x1000000000000000) != 0)
      goto LABEL_110;
    if ((v6 & 0x2000000000000000) != 0)
      v54 = HIBYTE(v6) & 0xF;
    else
      v54 = v5;
    v27 = __OFADD__(v54, 1);
    v55 = v54 + 1;
    if (!v27)
      goto LABEL_65;
LABEL_112:
    __break(1u);
    goto LABEL_113;
  }
  v20 = 8 * (HIBYTE(v6) & 7);
  v21 = (-255 << v20) - 1;
  v22 = 73 << v20;
  v23 = v22 | v21 & v6;
  v24 = v22 | v21 & v5;
  if (v8 >= 8)
    v25 = v23;
  else
    v25 = v6;
  if (v8 < 8)
    v5 = v24;
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE100000000000000);
  v26 = 0xA000000000000000;
  if (((v5 | v25) & 0x80808080808080) == 0)
    v26 = 0xE000000000000000;
  v115 = v5;
  v116 = (v26 & 0xFF00000000000000 | (v8 << 56) | v25 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
  v10 = v116;
  if ((v4 & 0x1000000) != 0)
    goto LABEL_15;
  while (1)
  {
LABEL_68:
    v58 = HIBYTE(v10) & 0xF;
    if ((v10 & 0x2000000000000000) != 0)
      v59 = HIBYTE(v10) & 0xF;
    else
      v59 = v5 & 0xFFFFFFFFFFFFLL;
    if (!v59 && (v5 & ~v10 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v10);
      return 93;
    }
    if ((v10 & 0x2000000000000000) != 0 && v58 != 15)
      break;
    swift_bridgeObjectRetain_n(0xE100000000000000, 6, a3, a4);
    if ((v10 & 0x1000000000000000) != 0)
    {
      v110 = String.UTF8View._foreignCount()();
      v61 = v110 + 1;
      if (!__OFADD__(v110, 1))
      {
LABEL_81:
        if ((v5 & ~v10 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
        {
          v62 = _StringGuts.nativeUnusedCapacity.getter(v5, v10);
          if ((v63 & 1) != 0)
          {
LABEL_114:
            v113 = 258;
            goto LABEL_115;
          }
          v65 = (v10 & 0x2000000000000000) == 0 && v62 > 0;
          if (v61 <= 15 && !v65)
          {
LABEL_92:
            swift_bridgeObjectRelease_n(0xE100000000000000, 5);
            swift_bridgeObjectRetain(v10, v66, v67, v68);
            v69 = _StringGuts._convertedToSmall()(v5, v10);
            v71 = v70;
            swift_bridgeObjectRelease(v10);
            v72._rawBits = 1;
            v73._rawBits = 65537;
            v74._rawBits = _StringGuts.validateScalarRange(_:)(v72, v73, 0x5DuLL, 0xE100000000000000);
            if (v74._rawBits < 0x10000)
              v74._rawBits |= 3;
            v76 = specialized String.init(_:)(v74, v75, 0x5DuLL, 0xE100000000000000);
            v78 = v77;
            swift_bridgeObjectRelease(0xE100000000000000);
            v79 = _StringGuts._convertedToSmall()(v76, v78);
            v81 = v80;
            swift_bridgeObjectRelease(v78);
            v82 = specialized _SmallString.init(_:appending:)(v69, v71, v79, v81);
            if ((v83 & 1) == 0)
            {
              v60 = v82;
              swift_bridgeObjectRelease(0xE100000000000000);
              swift_bridgeObjectRelease(v116);
              return v60;
            }
LABEL_113:
            v113 = 266;
LABEL_115:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v113, 0);
          }
        }
        else if (v61 <= 15)
        {
          goto LABEL_92;
        }
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v61, 1);
        swift_bridgeObjectRelease_n(0xE100000000000000, 6);
        v114 = xmmword_1816ABBC0;
        v84 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v114, 1);
        _StringGuts.appendInPlace(_:isASCII:)(v84, v85, 1);
        swift_bridgeObjectRelease(0xE100000000000000);
        return v115;
      }
    }
    else
    {
      v27 = __OFADD__(v59, 1);
      v61 = v59 + 1;
      if (!v27)
        goto LABEL_81;
    }
    __break(1u);
LABEL_107:
    v111 = String.UTF8View._foreignCount()();
    v4 = v111 + 1;
    if (__OFADD__(v111, 1))
    {
      while (1)
      {
        __break(1u);
LABEL_110:
        v112 = String.UTF8View._foreignCount()();
        v27 = __OFADD__(v112, 1);
        v55 = v112 + 1;
        if (v27)
          goto LABEL_112;
LABEL_65:
        if (v55 <= 15)
        {
          v87 = v116;
          swift_bridgeObjectRelease_n(0xE100000000000000, 5);
          v88 = v115;
          swift_bridgeObjectRetain(v87, v89, v90, v91);
          v92 = _StringGuts._convertedToSmall()(v88, v87);
          v94 = v93;
          swift_bridgeObjectRelease(v87);
          v95._rawBits = 1;
          v96._rawBits = 65537;
          v97._rawBits = _StringGuts.validateScalarRange(_:)(v95, v96, 0x49uLL, 0xE100000000000000);
          if (v97._rawBits < 0x10000)
            v97._rawBits |= 3;
          v99 = specialized String.init(_:)(v97, v98, 0x49uLL, 0xE100000000000000);
          v101 = v100;
          swift_bridgeObjectRelease(0xE100000000000000);
          v102 = _StringGuts._convertedToSmall()(v99, v101);
          v104 = v103;
          swift_bridgeObjectRelease(v101);
          v105 = specialized _SmallString.init(_:appending:)(v92, v94, v102, v104);
          if ((v107 & 1) != 0)
            goto LABEL_113;
          v108 = v105;
          v109 = v106;
          swift_bridgeObjectRelease(0xE100000000000000);
          v9 = v116;
          v115 = v108;
          v116 = v109;
        }
        else
        {
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v55, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          v114 = xmmword_1816ABEC0;
          v56 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v114, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v56, v57, 1);
          v9 = 0xE100000000000000;
        }
LABEL_13:
        swift_bridgeObjectRelease(v9);
LABEL_14:
        v5 = v115;
        v10 = v116;
        if ((v4 & 0x1000000) == 0)
          goto LABEL_68;
LABEL_15:
        v11 = HIBYTE(v10) & 0xF;
        if ((v10 & 0x2000000000000000) != 0)
          v12 = HIBYTE(v10) & 0xF;
        else
          v12 = v5 & 0xFFFFFFFFFFFFLL;
        if (!v12 && (v5 & ~v10 & 0x2000000000000000) == 0)
        {
          v5 = 82;
          v115 = 82;
          v116 = 0xE100000000000000;
          swift_bridgeObjectRelease(v10);
          v10 = 0xE100000000000000;
          goto LABEL_68;
        }
        if ((v10 & 0x2000000000000000) != 0 && v11 != 15)
          break;
        swift_bridgeObjectRetain_n(0xE100000000000000, 6, a3, a4);
        if ((v10 & 0x1000000000000000) != 0)
          goto LABEL_107;
        v27 = __OFADD__(v12, 1);
        v4 = v12 + 1;
        if (!v27)
          goto LABEL_43;
      }
      v13 = 8 * (HIBYTE(v10) & 7);
      v14 = (-255 << v13) - 1;
      v15 = 82 << v13;
      v16 = v15 | v14 & v10;
      v17 = v15 | v14 & v5;
      if (v11 >= 8)
        v18 = v16;
      else
        v18 = v10;
      if (v11 < 8)
        v5 = v17;
      swift_bridgeObjectRelease(v10);
      swift_bridgeObjectRelease(0xE100000000000000);
      v19 = 0xA000000000000000;
      if (!(v5 & 0x8080808080808080 | v18 & 0x80808080808080))
        v19 = 0xE000000000000000;
      v10 = (v19 & 0xFF00000000000000 | (v11 << 56) | v18 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
      v115 = v5;
      v116 = v10;
    }
    else
    {
LABEL_43:
      if ((v5 & ~v10 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
      {
        v28 = _StringGuts.nativeUnusedCapacity.getter(v5, v10);
        if ((v29 & 1) != 0)
          goto LABEL_114;
        v31 = (v10 & 0x2000000000000000) == 0 && v28 > 0;
        if (v4 > 15 || v31)
          goto LABEL_59;
LABEL_54:
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        swift_bridgeObjectRetain(v10, v32, v33, v34);
        v35 = _StringGuts._convertedToSmall()(v5, v10);
        v37 = v36;
        swift_bridgeObjectRelease(v10);
        v38._rawBits = 1;
        v39._rawBits = 65537;
        v40._rawBits = _StringGuts.validateScalarRange(_:)(v38, v39, 0x52uLL, 0xE100000000000000);
        if (v40._rawBits < 0x10000)
          v40._rawBits |= 3;
        v42 = specialized String.init(_:)(v40, v41, 0x52uLL, 0xE100000000000000);
        v44 = v43;
        swift_bridgeObjectRelease(0xE100000000000000);
        v45 = _StringGuts._convertedToSmall()(v42, v44);
        v47 = v46;
        swift_bridgeObjectRelease(v44);
        v48 = specialized _SmallString.init(_:appending:)(v35, v37, v45, v47);
        if ((v50 & 1) != 0)
          goto LABEL_113;
        v5 = v48;
        v10 = v49;
        swift_bridgeObjectRelease(0xE100000000000000);
        v51 = v116;
        v115 = v5;
        v116 = v10;
        swift_bridgeObjectRelease(v51);
      }
      else
      {
        if (v4 <= 15)
          goto LABEL_54;
LABEL_59:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v4, 1);
        swift_bridgeObjectRelease_n(0xE100000000000000, 6);
        v114 = xmmword_1816ABED0;
        v52 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v114, 1);
        _StringGuts.appendInPlace(_:isASCII:)(v52, v53, 1);
        swift_bridgeObjectRelease(0xE100000000000000);
        v5 = v115;
        v10 = v116;
      }
    }
  }
  if (v58 >= 8)
    v60 = v5;
  else
    v60 = (93 << (8 * (HIBYTE(v10) & 7u))) | ((-255 << (8 * (HIBYTE(v10) & 7u))) - 1) & v5;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v60;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _GraphemeBreakingState(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unsigned __int8 *v4;
  int v5;
  int v6;
  int v7;

  if (v4[3])
    v5 = 0x1000000;
  else
    v5 = 0;
  if (v4[2])
    v6 = 0x10000;
  else
    v6 = 0;
  if (v4[1])
    v7 = 256;
  else
    v7 = 0;
  return _GraphemeBreakingState.description.getter(v7 | *v4 | v6 | v5, a2, a3, a4);
}

uint64_t static Unicode._CharacterRecognizer.quickBreak(between:and:)(unsigned int a1, unsigned int a2)
{
  if (a1 == 13 && a2 == 10)
    return 0;
  if (hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(a1)
    && hasBreakWhenPaired #1 (_:) in _hasGraphemeBreakBetween(_:_:)(a2))
  {
    return 1;
  }
  return 2;
}

Swift::Unicode::_CharacterRecognizer __swiftcall Unicode._CharacterRecognizer.init()()
{
  _QWORD *v0;
  Swift::Unicode::_CharacterRecognizer result;

  *v0 = 0;
  return result;
}

Swift::Bool __swiftcall Unicode._CharacterRecognizer.hasBreak(before:)(Swift::Unicode::Scalar before)
{
  Swift::Unicode::Scalar *v1;
  Swift::Unicode::Scalar *v2;
  Swift::Unicode::Scalar *v4;
  Swift::Unicode::Scalar v5;
  Swift::Bool v6;

  v2 = v1;
  v5._value = v1->_value;
  v4 = v1 + 1;
  v6 = _GraphemeBreakingState.shouldBreak(between:and:)(v5, before);
  if (v6)
    v4->_value = 0;
  v2->_value = before._value;
  return v6;
}

uint64_t Unicode._CharacterRecognizer._firstBreak(inUncheckedUnsafeUTF8Buffer:startingAt:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Swift::UInt32 *v3;
  uint64_t v4;
  Swift::Unicode::Scalar v7;
  Swift::UInt32 v8;

  if (a3 >= a2)
    return 0;
  v4 = a3;
  v7._value = *v3;
  while (1)
  {
    v8 = *(unsigned __int8 *)(a1 + v4);
    if (*(char *)(a1 + v4) < 0)
      __asm { BR              X9 }
    if (_GraphemeBreakingState.shouldBreak(between:and:)(v7, (Swift::Unicode::Scalar)*(unsigned __int8 *)(a1 + v4)))
      break;
    ++v4;
    v7._value = v8;
    if (v4 >= a2)
    {
      v4 = 0;
      *v3 = v8;
      return v4;
    }
  }
  *v3 = v8;
  v3[1] = 0;
  return v4;
}

uint64_t Unicode._CharacterRecognizer.description.getter()
{
  unsigned __int8 *v0;
  uint64_t v1;
  Swift::Int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  Swift::Int v14;
  unint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unsigned __int8 *v20;
  unint64_t v21;
  unint64_t v22;
  Swift::String::Index v23;
  Swift::String::Index v24;
  Swift::String::Index v25;
  Swift::String::Index v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  void *v34;
  char v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  unint64_t v42;
  char *v43;
  size_t v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t countAndFlagsBits;
  unint64_t object;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  Swift::Int v64;
  int64_t v65;
  uint64_t v66;
  unint64_t v67;
  int64_t v68;
  char v69;
  char *v70;
  size_t v71;
  uint64_t v72;
  char *v73;
  unint64_t v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  Swift::String::Index v82;
  Swift::String::Index v83;
  Swift::String::Index v84;
  Swift::String::Index v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  void *v93;
  char v94;
  uint64_t v95;
  void *v96;
  void *v97;
  char v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  char v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  void *v110;
  id v111;
  uint64_t v112;
  char *v113;
  size_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  char v122;
  Swift::UInt64 v123;
  BOOL v124;
  int64_t v125;
  unint64_t v126;
  int64_t v127;
  char v128;
  char *v129;
  size_t v130;
  uint64_t v131;
  unint64_t v132;
  void *v133;
  uint64_t v134;
  uint64_t v135;
  char *v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  Swift::String::Index v140;
  Swift::String::Index v141;
  Swift::String::Index v142;
  Swift::String::Index v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  void *v151;
  char v152;
  uint64_t v153;
  void *v154;
  unint64_t v155;
  void *v156;
  uint64_t v157;
  char *v158;
  Swift::String v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  char *v168;
  Swift::Int v169;
  uint64_t v170;
  int64_t v171;
  char v172;
  int64_t v173;
  char v174;
  BOOL v175;
  uint64_t v176;
  uint64_t v177;
  char *v178;
  unint64_t v179;
  uint64_t v180;
  Swift::String::Index v181;
  Swift::String::Index v182;
  Swift::String::Index v183;
  Swift::String::Index v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  char v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  char v197;
  uint64_t v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  uint64_t v203;
  uint64_t v204;
  char v205;
  uint64_t v206;
  uint64_t v207;
  char *v208;
  size_t v209;
  uint64_t v210;
  char *v211;
  char v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  char v218;
  uint64_t v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  void *v224;
  id v225;
  uint64_t v226;
  char *v227;
  size_t v228;
  unint64_t v229;
  Swift::Int v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  char v234;
  char *v235;
  size_t v236;
  uint64_t v237;
  unint64_t v238;
  void *v239;
  Swift::String::Index v240;
  Swift::String::Index v241;
  Swift::String::Index v242;
  Swift::String::Index v243;
  Swift::Int v244;
  Swift::String::Index v245;
  Swift::String::Index v246;
  Swift::String::Index v247;
  Swift::String::Index v248;
  Swift::Int v249;
  Swift::Int v250;
  unint64_t v251;
  void *v252;
  uint64_t v253;
  uint64_t v254;
  char *v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  Swift::String::Index v259;
  Swift::String::Index v260;
  Swift::String::Index v261;
  Swift::String::Index v262;
  unint64_t v263;
  unint64_t v264;
  unint64_t v265;
  unint64_t v266;
  unint64_t v267;
  unint64_t v268;
  unint64_t v269;
  void *v270;
  char v271;
  uint64_t v272;
  void *v273;
  unsigned __int8 *v275;
  uint64_t v276;
  unsigned __int8 *v277;
  uint64_t v278;
  unint64_t v279;
  uint64_t v280;
  uint64_t v281;
  unint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  Swift::UInt64 _;
  __int128 v287;
  Swift::String v288;

  _ = *(unsigned int *)v0;
  LODWORD(v1) = v0[4];
  LODWORD(v2) = v0[5];
  v3 = v0[6];
  LODWORD(v4) = v0[7];
  v5 = specialized static String._createEmpty(withInitialCapacity:)(6);
  v9 = v5;
  v10 = v6;
  v288._countAndFlagsBits = v5;
  v288._object = (void *)v6;
  v11 = HIBYTE(v6) & 0xF;
  v12 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000) != 0)
    v13 = HIBYTE(v6) & 0xF;
  else
    v13 = v5 & 0xFFFFFFFFFFFFLL;
  if (v13 || (v5 & ~v6 & 0x2000000000000000) != 0)
  {
    if ((v6 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v6);
      swift_bridgeObjectRelease(0xE000000000000000);
      v42 = 0xA000000000000000;
      if (!(v10 & 0x80808080808080 | v9 & 0x8080808080808080))
        v42 = 0xE000000000000000;
      v288._countAndFlagsBits = v9;
      v288._object = (void *)(v42 & 0xFF00000000000000 | (v11 << 56) | v10 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_29;
    }
    swift_bridgeObjectRetain_n(0xE000000000000000, 6, v7, v8);
    v14 = v12;
    if ((v10 & 0x1000000000000000) != 0)
    {
      v14 = String.UTF8View._foreignCount()();
      if ((v9 & ~v10 & 0x2000000000000000) == 0)
        goto LABEL_26;
    }
    else if ((v9 & ~v10 & 0x2000000000000000) == 0)
    {
      goto LABEL_26;
    }
    if (swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
    {
      v15 = _StringGuts.nativeUnusedCapacity.getter(v9, v10);
      if ((v16 & 1) == 0)
      {
        if (v14 <= 15 && (v15 & 0x8000000000000000) != 0)
        {
LABEL_13:
          swift_bridgeObjectRelease_n(0xE000000000000000, 5);
          if ((v10 & 0x1000000000000000) == 0)
          {
            if ((v9 & 0x1000000000000000) != 0)
            {
              v20 = (unsigned __int8 *)((v10 & 0xFFFFFFFFFFFFFFFLL) + 32);
            }
            else
            {
              v20 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, v10);
              v12 = v17;
            }
            swift_bridgeObjectRetain(v10, v17, v18, v19);
            closure #1 in _StringGuts._convertedToSmall()(v20, v12, &v287);
            swift_bridgeObjectRelease(v10);
            v22 = *((_QWORD *)&v287 + 1);
            v21 = v287;
            goto LABEL_17;
          }
          goto LABEL_255;
        }
LABEL_27:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v14, 0);
        swift_bridgeObjectRelease_n(0xE000000000000000, 6);
        v287 = 0uLL;
        v43 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v287, 0);
        _StringGuts.appendInPlace(_:isASCII:)(v43, v44, 1);
        v38 = 0xE000000000000000;
        goto LABEL_28;
      }
      goto LABEL_262;
    }
LABEL_26:
    if (v14 <= 15)
      goto LABEL_13;
    goto LABEL_27;
  }
  v288._countAndFlagsBits = 0;
  v288._object = (void *)0xE000000000000000;
  v38 = v6;
  while (1)
  {
LABEL_28:
    swift_bridgeObjectRelease(v38);
LABEL_29:
    if ((_DWORD)v4)
      v45 = 0x1000000;
    else
      v45 = 0;
    if (v3)
      v46 = 0x10000;
    else
      v46 = 0;
    if ((_DWORD)v2)
      v47 = 256;
    else
      v47 = 0;
    v48 = _GraphemeBreakingState.description.getter(v47 | v1 | v46 | v45, v39, v40, v41);
    v52 = v48;
    v53 = v49;
    countAndFlagsBits = v288._countAndFlagsBits;
    object = (unint64_t)v288._object;
    v56 = ((unint64_t)v288._object >> 56) & 0xF;
    v57 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v288._object & 0x2000000000000000) != 0)
      v57 = ((unint64_t)v288._object >> 56) & 0xF;
    if (!v57 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000) == 0)
    {
      v288._countAndFlagsBits = v48;
      v288._object = (void *)v49;
      swift_bridgeObjectRelease(object);
      goto LABEL_88;
    }
    v58 = v49 & 0x2000000000000000;
    v59 = HIBYTE(v49) & 0xF;
    if (((uint64_t)v288._object & 0x2000000000000000) != 0 && v58)
    {
      v60 = v56 + v59;
      if (v56 + v59 <= 0xF)
      {
        if (v59)
        {
          v98 = 0;
          v99 = 0;
          do
          {
            v100 = v56 + v99;
            v101 = v99 + 1;
            if (v99 >= 8)
              v102 = v49;
            else
              v102 = v48;
            v103 = v102 >> (v98 & 0x38);
            v104 = (8 * v56 + v98) & 0x38;
            v105 = (-255 << v104) - 1;
            v106 = (unint64_t)v103 << v104;
            v107 = v106 | v105 & object;
            v108 = v106 | v105 & countAndFlagsBits;
            if (v100 < 8)
              countAndFlagsBits = v108;
            else
              object = v107;
            v98 += 8;
            v99 = v101;
          }
          while (v59 != v101);
        }
        swift_bridgeObjectRelease(v49);
        v109 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | object & 0x80808080808080))
          v109 = 0xE000000000000000;
        v110 = (void *)(v109 & 0xFF00000000000000 | (v60 << 56) | object & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v288._object);
        v288._countAndFlagsBits = countAndFlagsBits;
        v288._object = v110;
        goto LABEL_88;
      }
      v58 = 1;
    }
    if (v58)
      v61 = HIBYTE(v49) & 0xF;
    else
      v61 = v48 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v49, 2, v50, v51);
    if ((v53 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(v53, 5, v62, v63);
      v240._rawBits = 1;
      v241._rawBits = (v61 << 16) | 1;
      v242._rawBits = _StringGuts.validateScalarRange(_:)(v240, v241, v52, v53);
      if (v242._rawBits < 0x10000)
        v242._rawBits |= 3;
      v64 = specialized Collection.count.getter(v242, v243, v52, v53);
      swift_bridgeObjectRelease(v53);
      countAndFlagsBits = v288._countAndFlagsBits;
      object = (unint64_t)v288._object;
      if (((uint64_t)v288._object & 0x1000000000000000) != 0)
      {
LABEL_226:
        v244 = String.UTF8View._foreignCount()();
        v65 = v244 + v64;
        if (!__OFADD__(v244, v64))
          goto LABEL_56;
        goto LABEL_54;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(v53, 4, v62, v63);
      v64 = v61;
      if ((object & 0x1000000000000000) != 0)
        goto LABEL_226;
    }
    if ((object & 0x2000000000000000) == 0)
    {
      v65 = (countAndFlagsBits & 0xFFFFFFFFFFFFLL) + v64;
      if (!__OFADD__(countAndFlagsBits & 0xFFFFFFFFFFFFLL, v64))
        goto LABEL_56;
      goto LABEL_54;
    }
    while (1)
    {
      v66 = HIBYTE(object) & 0xF;
      v65 = v66 + v64;
      if (!__OFADD__(v66, v64))
        break;
LABEL_54:
      __break(1u);
    }
LABEL_56:
    if ((countAndFlagsBits & ~object & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      v67 = (unint64_t)v288._object;
      v68 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
      if ((v69 & 1) != 0)
        goto LABEL_262;
      if (v65 <= 15 && ((v67 & 0x2000000000000000) != 0 || v68 < v64))
      {
LABEL_66:
        swift_bridgeObjectRelease_n(v53, 5);
        v74 = v288._countAndFlagsBits;
        v75 = v288._object;
        swift_bridgeObjectRetain((unint64_t)v288._object, v76, v77, v78);
        v79 = _StringGuts._convertedToSmall()(v74, (unint64_t)v75);
        v81 = v80;
        swift_bridgeObjectRelease((uint64_t)v75);
        v82._rawBits = (v61 << 16) | 1;
        v83._rawBits = 1;
        v84._rawBits = _StringGuts.validateScalarRange(_:)(v83, v82, v52, v53);
        if (v84._rawBits < 0x10000)
          v84._rawBits |= 3;
        v86 = specialized String.init(_:)(v84, v85, v52, v53);
        v88 = v87;
        swift_bridgeObjectRelease(v53);
        v89 = _StringGuts._convertedToSmall()(v86, v88);
        v91 = v90;
        swift_bridgeObjectRelease(v88);
        v92 = specialized _SmallString.init(_:appending:)(v79, v81, v89, v91);
        if ((v94 & 1) != 0)
          goto LABEL_261;
        v95 = v92;
        v96 = v93;
        swift_bridgeObjectRelease(v53);
        v97 = v288._object;
        v288._countAndFlagsBits = v95;
        v288._object = v96;
        swift_bridgeObjectRelease((uint64_t)v97);
        goto LABEL_88;
      }
    }
    else if (v65 <= 15)
    {
      goto LABEL_66;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v65, v64);
    swift_bridgeObjectRelease_n(v53, 4);
    if ((v53 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v53);
      _StringGuts._foreignAppendInPlace(_:)(v52, v53, 0, v61);
    }
    else
    {
      if (v58)
      {
        swift_bridgeObjectRelease_n(v53, 2);
        *(_QWORD *)&v287 = v52;
        *((_QWORD *)&v287 + 1) = v53 & 0xFFFFFFFFFFFFFFLL;
        v70 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v53) & 0xF, (uint64_t)&v287, HIBYTE(v53) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v70, v71, (v53 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(v53);
        goto LABEL_88;
      }
      if ((v52 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v53);
        v111 = (id)((v53 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v112 = v52 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v111 = _StringObject.sharedUTF8.getter(v52, v53);
        v112 = v280;
        swift_bridgeObjectRelease(v53);
        if (v112 < (v52 & 0xFFFFFFFFFFFFLL))
          goto LABEL_260;
      }
      v113 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v52 & 0xFFFFFFFFFFFFLL, (uint64_t)v111, v112);
      _StringGuts.appendInPlace(_:isASCII:)(v113, v114, v52 < 0);
    }
    swift_bridgeObjectRelease_n(v53, 2);
LABEL_88:
    v116 = v288._countAndFlagsBits;
    v115 = (uint64_t)v288._object;
    v117 = ((unint64_t)v288._object >> 56) & 0xF;
    if (((uint64_t)v288._object & 0x2000000000000000) != 0)
      v118 = ((unint64_t)v288._object >> 56) & 0xF;
    else
      v118 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v118 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000) == 0)
    {
      v288._countAndFlagsBits = 11093;
      v288._object = (void *)0xE200000000000000;
      v131 = v115;
      goto LABEL_115;
    }
    if (((uint64_t)v288._object & 0x2000000000000000) == 0 || v117 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000, 6, v72, v73);
      if ((v115 & 0x1000000000000000) != 0)
      {
        v250 = String.UTF8View._foreignCount()();
        v125 = v250 + 2;
        if (__OFADD__(v250, 2))
        {
LABEL_237:
          __break(1u);
LABEL_238:
          v230 = String.UTF8View._foreignCount()();
          if ((v116 & ~v115 & 0x2000000000000000) == 0)
            goto LABEL_239;
LABEL_213:
          if (!swift_isUniquelyReferenced_nonNull_native(v115 & 0xFFFFFFFFFFFFFFFLL))
            goto LABEL_239;
          v232 = (unint64_t)v288._object;
          v233 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
          if ((v234 & 1) != 0)
          {
LABEL_262:
            v282 = 258;
LABEL_263:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v282, 0);
          }
          if (v230 <= 15 && ((v232 & 0x2000000000000000) != 0 || (v233 & 0x8000000000000000) != 0))
            goto LABEL_240;
LABEL_218:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v230, 0);
          swift_bridgeObjectRelease_n(0xE000000000000000, 6);
          v287 = 0uLL;
          v235 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v287, 0);
          _StringGuts.appendInPlace(_:isASCII:)(v235, v236, 1);
          v237 = 0xE000000000000000;
          goto LABEL_244;
        }
      }
      else
      {
        v124 = __OFADD__(v118, 2);
        v125 = v118 + 2;
        if (v124)
          goto LABEL_237;
      }
      if ((v116 & ~v115 & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(v115 & 0xFFFFFFFFFFFFFFFLL))
      {
        v126 = (unint64_t)v288._object;
        v127 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
        if ((v128 & 1) != 0)
          goto LABEL_262;
        if (v125 > 15 || (v126 & 0x2000000000000000) == 0 && v127 > 1)
          goto LABEL_106;
      }
      else if (v125 > 15)
      {
LABEL_106:
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v125, 2);
        swift_bridgeObjectRelease_n(0xE200000000000000, 6);
        v287 = xmmword_1816ABEE0;
        v129 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v287, 2);
        _StringGuts.appendInPlace(_:isASCII:)(v129, v130, 1);
        v131 = 0xE200000000000000;
LABEL_115:
        swift_bridgeObjectRelease(v131);
        v123 = _;
        goto LABEL_120;
      }
      swift_bridgeObjectRelease_n(0xE200000000000000, 5);
      v132 = v288._countAndFlagsBits;
      v133 = v288._object;
      swift_bridgeObjectRetain((unint64_t)v288._object, v134, v135, v136);
      v137 = _StringGuts._convertedToSmall()(v132, (unint64_t)v133);
      v139 = v138;
      swift_bridgeObjectRelease((uint64_t)v133);
      v140._rawBits = 1;
      v141._rawBits = 131073;
      v142._rawBits = _StringGuts.validateScalarRange(_:)(v140, v141, 0x2B55uLL, 0xE200000000000000);
      if (v142._rawBits < 0x10000)
        v142._rawBits |= 3;
      v144 = specialized String.init(_:)(v142, v143, 0x2B55uLL, 0xE200000000000000);
      v146 = v145;
      swift_bridgeObjectRelease(0xE200000000000000);
      v147 = _StringGuts._convertedToSmall()(v144, v146);
      v149 = v148;
      swift_bridgeObjectRelease(v146);
      v150 = specialized _SmallString.init(_:appending:)(v137, v139, v147, v149);
      if ((v152 & 1) != 0)
        goto LABEL_261;
      v153 = v150;
      v154 = v151;
      swift_bridgeObjectRelease(0xE200000000000000);
      v131 = (uint64_t)v288._object;
      v288._countAndFlagsBits = v153;
      v288._object = v154;
      goto LABEL_115;
    }
    v119 = 8 * (((unint64_t)v288._object >> 56) & 7);
    v120 = (-255 << v119) - 1;
    v121 = 85 << v119;
    v122 = v117 + 1;
    if (v117 >= 8)
    {
      v115 = v121 | v120 & (uint64_t)v288._object;
      v123 = _;
    }
    else
    {
      v116 = v121 | v120 & v288._countAndFlagsBits;
      v123 = _;
      if (v117 != 7)
      {
        v116 = (43 << (8 * (v122 & 7u))) | ((-255 << (8 * (v122 & 7u))) - 1) & v116;
        goto LABEL_117;
      }
      v122 = 8;
    }
    v115 = (43 << (8 * (v122 & 7u))) | ((-255 << (8 * (v122 & 7u))) - 1) & v115;
LABEL_117:
    swift_bridgeObjectRelease(0xE200000000000000);
    v155 = 0xA000000000000000;
    if (!(v116 & 0x8080808080808080 | v115 & 0x80808080808080))
      v155 = 0xE000000000000000;
    v156 = (void *)((v155 & 0xFF00000000000000 | (v117 << 56) | v115 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000);
    swift_bridgeObjectRelease((uint64_t)v288._object);
    v288._countAndFlagsBits = v116;
    v288._object = v156;
LABEL_120:
    v159 = _uint64ToString(_:radix:uppercase:)(v123, 16, 1);
    v9 = v159._countAndFlagsBits;
    v160 = v288._countAndFlagsBits;
    v161 = (unint64_t)v288._object;
    v162 = ((unint64_t)v288._object >> 56) & 0xF;
    v163 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v288._object & 0x2000000000000000) != 0)
      v163 = ((unint64_t)v288._object >> 56) & 0xF;
    if (!v163 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000) == 0)
    {
      v288 = v159;
      v203 = v161;
LABEL_188:
      swift_bridgeObjectRelease(v203);
      goto LABEL_205;
    }
    v4 = (uint64_t)v159._object & 0x2000000000000000;
    v164 = ((unint64_t)v159._object >> 56) & 0xF;
    if (((uint64_t)v288._object & 0x2000000000000000) != 0 && v4)
    {
      v165 = v162 + v164;
      if (v162 + v164 <= 0xF)
      {
        if (v164)
        {
          v212 = 0;
          v213 = 0;
          do
          {
            v214 = v162 + v213;
            v215 = v213 + 1;
            if (v213 >= 8)
              v216 = (unint64_t)v159._object;
            else
              v216 = v159._countAndFlagsBits;
            v217 = v216 >> (v212 & 0x38);
            v218 = (8 * v162 + v212) & 0x38;
            v219 = (-255 << v218) - 1;
            v220 = (unint64_t)v217 << v218;
            v221 = v220 | v219 & v161;
            v222 = v220 | v219 & v160;
            if (v214 < 8)
              v160 = v222;
            else
              v161 = v221;
            v212 += 8;
            v213 = v215;
          }
          while (v164 != v215);
        }
        swift_bridgeObjectRelease((uint64_t)v159._object);
        v223 = 0xA000000000000000;
        if (!(v160 & 0x8080808080808080 | v161 & 0x80808080808080))
          v223 = 0xE000000000000000;
        v224 = (void *)(v223 & 0xFF00000000000000 | (v165 << 56) | v161 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v288._object);
        v288._countAndFlagsBits = v160;
        v288._object = v224;
        goto LABEL_205;
      }
      v4 = 1;
    }
    if (v4)
      v166 = ((unint64_t)v159._object >> 56) & 0xF;
    else
      v166 = v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v159._object, 2, v157, v158);
    if (((uint64_t)v159._object & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v159._object, 5, v167, v168);
      v245._rawBits = 1;
      v246._rawBits = (v166 << 16) | 1;
      v247._rawBits = _StringGuts.validateScalarRange(_:)(v245, v246, v159._countAndFlagsBits, (unint64_t)v159._object);
      if (v247._rawBits < 0x10000)
        v247._rawBits |= 3;
      v169 = specialized Collection.count.getter(v247, v248, v159._countAndFlagsBits, (unint64_t)v159._object);
      swift_bridgeObjectRelease((uint64_t)v159._object);
      v160 = v288._countAndFlagsBits;
      v161 = (unint64_t)v288._object;
      if (((uint64_t)v288._object & 0x1000000000000000) != 0)
      {
LABEL_232:
        v249 = String.UTF8View._foreignCount()();
        v2 = v249 + v169;
        if (!__OFADD__(v249, v169))
          goto LABEL_138;
        goto LABEL_136;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v159._object, 4, v167, v168);
      v169 = v166;
      if ((v161 & 0x1000000000000000) != 0)
        goto LABEL_232;
    }
    if ((v161 & 0x2000000000000000) == 0)
    {
      v2 = (v160 & 0xFFFFFFFFFFFFLL) + v169;
      if (!__OFADD__(v160 & 0xFFFFFFFFFFFFLL, v169))
        goto LABEL_138;
      goto LABEL_136;
    }
    while (1)
    {
      v170 = HIBYTE(v161) & 0xF;
      v2 = v170 + v169;
      if (!__OFADD__(v170, v169))
        break;
LABEL_136:
      __break(1u);
    }
LABEL_138:
    if ((v160 & ~v161 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v161 & 0xFFFFFFFFFFFFFFFLL))
    {
      v1 = v288._countAndFlagsBits;
      v10 = (unint64_t)v288._object;
      v171 = _StringGuts.nativeUnusedCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
      if ((v172 & 1) != 0)
        goto LABEL_262;
      if (v2 <= 15 && ((v10 & 0x2000000000000000) != 0 || v171 < v169))
      {
LABEL_157:
        swift_bridgeObjectRelease_n((uint64_t)v159._object, 5);
        v180 = v288._countAndFlagsBits;
        v179 = (unint64_t)v288._object;
        if (((uint64_t)v288._object & 0x2000000000000000) == 0)
        {
          if (((uint64_t)v288._object & 0x1000000000000000) != 0)
          {
            v180 = _StringGuts._foreignConvertedToSmall()(v288._countAndFlagsBits, (unint64_t)v288._object);
            v179 = v283;
          }
          else
          {
            if ((v288._countAndFlagsBits & 0x1000000000000000) != 0)
            {
              v275 = (unsigned __int8 *)(((uint64_t)v288._object & 0xFFFFFFFFFFFFFFFLL) + 32);
              v276 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              v275 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
              v276 = v176;
            }
            swift_bridgeObjectRetain(v179, v176, v177, v178);
            closure #1 in _StringGuts._convertedToSmall()(v275, v276, &v287);
            swift_bridgeObjectRelease(v179);
            v179 = *((_QWORD *)&v287 + 1);
            v180 = v287;
          }
        }
        v181._rawBits = (v166 << 16) | 1;
        v182._rawBits = 1;
        v183._rawBits = _StringGuts.validateScalarRange(_:)(v182, v181, v159._countAndFlagsBits, (unint64_t)v159._object);
        if (v183._rawBits < 0x10000)
          v183._rawBits |= 3;
        v185 = specialized String.init(_:)(v183, v184, v159._countAndFlagsBits, (unint64_t)v159._object);
        v187 = v186;
        swift_bridgeObjectRelease((uint64_t)v159._object);
        if ((v187 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease(v187);
        }
        else if ((v187 & 0x1000000000000000) != 0)
        {
          v185 = _StringGuts._foreignConvertedToSmall()(v185, v187);
          v285 = v284;
          swift_bridgeObjectRelease(v187);
          v187 = v285;
        }
        else
        {
          if ((v185 & 0x1000000000000000) != 0)
          {
            v277 = (unsigned __int8 *)((v187 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v278 = v185 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            v277 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v185, v187);
          }
          closure #1 in _StringGuts._convertedToSmall()(v277, v278, &v287);
          swift_bridgeObjectRelease(v187);
          v187 = *((_QWORD *)&v287 + 1);
          v185 = v287;
        }
        v188 = HIBYTE(v179) & 0xF;
        v189 = HIBYTE(v187) & 0xF;
        v190 = v189 + v188;
        if ((unint64_t)(v189 + v188) <= 0xF)
        {
          if (v189)
          {
            v191 = 0;
            v192 = 0;
            do
            {
              v193 = v188 + v192;
              v194 = v192 + 1;
              if (v192 >= 8)
                v195 = v187;
              else
                v195 = v185;
              v196 = v195 >> (v191 & 0x38);
              v197 = (8 * v188 + v191) & 0x38;
              v198 = (-255 << v197) - 1;
              v199 = (unint64_t)v196 << v197;
              v200 = v199 | v198 & v179;
              v201 = v199 | v198 & v180;
              if (v193 < 8)
                v180 = v201;
              else
                v179 = v200;
              v191 += 8;
              v192 = v194;
            }
            while (v189 != v194);
          }
          swift_bridgeObjectRelease((uint64_t)v159._object);
          v202 = 0xA000000000000000;
          if (!(v180 & 0x8080808080808080 | v179 & 0x80808080808080))
            v202 = 0xE000000000000000;
          v203 = (uint64_t)v288._object;
          v288._countAndFlagsBits = v180;
          v288._object = (void *)(v202 & 0xFF00000000000000 | (v190 << 56) | v179 & 0xFFFFFFFFFFFFFFLL);
          goto LABEL_188;
        }
LABEL_261:
        v282 = 266;
        goto LABEL_263;
      }
    }
    else
    {
      if (v2 < 16)
        goto LABEL_157;
      v1 = v288._countAndFlagsBits;
      v10 = (unint64_t)v288._object;
    }
    v173 = _StringGuts.nativeUnusedCapacity.getter(v1, v10);
    v175 = (v174 & 1) != 0 || v173 < v169;
    v3 = !v175;
    if ((v1 & ~v10 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v3 & 1) != 0)
        goto LABEL_183;
    }
    else if ((v3 & 1) != 0)
    {
      goto LABEL_182;
    }
    v204 = _StringGuts.nativeCapacity.getter(v288._countAndFlagsBits, (uint64_t)v288._object);
    v206 = (v205 & 1) != 0 ? 0 : v204;
    if (v206 + 0x4000000000000000 >= 0)
      break;
    __break(1u);
LABEL_255:
    v21 = _StringGuts._foreignConvertedToSmall()(v9, v10);
    v22 = v279;
LABEL_17:
    v23._rawBits = 1;
    v24._rawBits = 1;
    v25._rawBits = _StringGuts.validateScalarRange(_:)(v23, v24, 0, 0xE000000000000000);
    if (v25._rawBits < 0x10000)
      v25._rawBits |= 3;
    v27 = specialized String.init(_:)(v25, v26, 0, 0xE000000000000000);
    v29 = v28;
    swift_bridgeObjectRelease(0xE000000000000000);
    v30 = _StringGuts._convertedToSmall()(v27, v29);
    v32 = v31;
    swift_bridgeObjectRelease(v29);
    v33 = specialized _SmallString.init(_:appending:)(v21, v22, v30, v32);
    if ((v35 & 1) != 0)
      goto LABEL_261;
    v36 = v33;
    v37 = v34;
    swift_bridgeObjectRelease(0xE000000000000000);
    v38 = (uint64_t)v288._object;
    v288._countAndFlagsBits = v36;
    v288._object = v37;
  }
  v207 = 2 * v206;
  if (v207 > v2)
    v2 = v207;
LABEL_182:
  _StringGuts.grow(_:)(v2);
LABEL_183:
  swift_bridgeObjectRelease_n((uint64_t)v159._object, 4);
  if (((uint64_t)v159._object & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v159._object);
    _StringGuts._foreignAppendInPlace(_:)(v159._countAndFlagsBits, (unint64_t)v159._object, 0, v166);
  }
  else
  {
    if (v4)
    {
      swift_bridgeObjectRelease_n((uint64_t)v159._object, 2);
      *(_QWORD *)&v287 = v159._countAndFlagsBits;
      *((_QWORD *)&v287 + 1) = (uint64_t)v159._object & 0xFFFFFFFFFFFFFFLL;
      v208 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v159._object >> 56) & 0xF, (uint64_t)&v287, ((unint64_t)v159._object >> 56) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v208, v209, ((uint64_t)v159._object & 0x4000000000000000) != 0);
      v203 = (uint64_t)v159._object;
      goto LABEL_188;
    }
    if ((v159._countAndFlagsBits & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v159._object);
      v225 = (id)(((uint64_t)v159._object & 0xFFFFFFFFFFFFFFFLL) + 32);
      v226 = v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      v225 = _StringObject.sharedUTF8.getter(v159._countAndFlagsBits, (uint64_t)v159._object);
      v226 = v281;
      swift_bridgeObjectRelease((uint64_t)v159._object);
      if (v226 < (v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL))
LABEL_260:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    v227 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v159._countAndFlagsBits & 0xFFFFFFFFFFFFLL, (uint64_t)v225, v226);
    _StringGuts.appendInPlace(_:isASCII:)(v227, v228, v159._countAndFlagsBits < 0);
  }
  swift_bridgeObjectRelease_n((uint64_t)v159._object, 2);
LABEL_205:
  v116 = v288._countAndFlagsBits;
  v115 = (uint64_t)v288._object;
  v229 = ((unint64_t)v288._object >> 56) & 0xF;
  v230 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v288._object & 0x2000000000000000) != 0)
    v231 = ((unint64_t)v288._object >> 56) & 0xF;
  else
    v231 = v288._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v231 && (v288._countAndFlagsBits & ~(uint64_t)v288._object & 0x2000000000000000) == 0)
  {
    v288._countAndFlagsBits = 0;
    v288._object = (void *)0xE000000000000000;
    v237 = v115;
    goto LABEL_244;
  }
  if (((uint64_t)v288._object & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(0xE000000000000000);
    v238 = 0xA000000000000000;
    if (!(v115 & 0x80808080808080 | v116 & 0x8080808080808080))
      v238 = 0xE000000000000000;
    v239 = (void *)(v238 & 0xFF00000000000000 | (v229 << 56) | v115 & 0xFFFFFFFFFFFFFFLL);
    swift_bridgeObjectRelease((uint64_t)v288._object);
    v288._countAndFlagsBits = v116;
    v288._object = v239;
    return v288._countAndFlagsBits;
  }
  swift_bridgeObjectRetain_n(0xE000000000000000, 6, v210, v211);
  if ((v115 & 0x1000000000000000) != 0)
    goto LABEL_238;
  if ((v116 & ~v115 & 0x2000000000000000) != 0)
    goto LABEL_213;
LABEL_239:
  if (v230 > 15)
    goto LABEL_218;
LABEL_240:
  swift_bridgeObjectRelease_n(0xE000000000000000, 5);
  v251 = v288._countAndFlagsBits;
  v252 = v288._object;
  swift_bridgeObjectRetain((unint64_t)v288._object, v253, v254, v255);
  v256 = _StringGuts._convertedToSmall()(v251, (unint64_t)v252);
  v258 = v257;
  swift_bridgeObjectRelease((uint64_t)v252);
  v259._rawBits = 1;
  v260._rawBits = 1;
  v261._rawBits = _StringGuts.validateScalarRange(_:)(v259, v260, 0, 0xE000000000000000);
  if (v261._rawBits < 0x10000)
    v261._rawBits |= 3;
  v263 = specialized String.init(_:)(v261, v262, 0, 0xE000000000000000);
  v265 = v264;
  swift_bridgeObjectRelease(0xE000000000000000);
  v266 = _StringGuts._convertedToSmall()(v263, v265);
  v268 = v267;
  swift_bridgeObjectRelease(v265);
  v269 = specialized _SmallString.init(_:appending:)(v256, v258, v266, v268);
  if ((v271 & 1) != 0)
    goto LABEL_261;
  v272 = v269;
  v273 = v270;
  swift_bridgeObjectRelease(0xE000000000000000);
  v237 = (uint64_t)v288._object;
  v288._countAndFlagsBits = v272;
  v288._object = v273;
LABEL_244:
  swift_bridgeObjectRelease(v237);
  return v288._countAndFlagsBits;
}

uint64_t _ValidUTF8Buffer._biasedBits.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _ValidUTF8Buffer.Iterator._biasedBits.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer.Iterator._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt8_optional __swiftcall _ValidUTF8Buffer.Iterator.next()()
{
  unsigned int *v0;
  unsigned int v1;
  unsigned __int8 v2;

  v1 = *v0;
  if (*v0)
  {
    v2 = v1 - 1;
    *v0 = v1 >> 8;
  }
  else
  {
    v2 = 0;
  }
  return (Swift::UInt8_optional)(v2 | ((v1 == 0) << 8));
}

void protocol witness for IteratorProtocol.next() in conformance _ValidUTF8Buffer.Iterator(_BYTE *a1@<X8>)
{
  unsigned int *v1;
  unsigned int v2;
  char v3;

  v2 = *v1;
  if (*v1)
  {
    v3 = v2 - 1;
    *v1 = v2 >> 8;
  }
  else
  {
    v3 = 0;
  }
  *a1 = v3;
  a1[1] = v2 == 0;
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _ValidUTF8Buffer.Iterator()
{
  unsigned int *v0;

  return specialized _copySequenceToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _ValidUTF8Buffer.Iterator(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _ValidUTF8Buffer.Iterator@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5(a1, a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _ValidUTF8Buffer()
{
  unsigned int *v0;

  return 4 - (__clz(*v0) >> 3);
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance _ValidUTF8Buffer()
{
  unsigned int *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t _ValidUTF8Buffer.Index._biasedBits.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*_ValidUTF8Buffer.Index._biasedBits.modify())()
{
  return EnumeratedSequence._base.modify;
}

BOOL static _ValidUTF8Buffer.Index.== infix(_:_:)(int a1, int a2)
{
  return a1 == a2;
}

BOOL static _ValidUTF8Buffer.Index.< infix(_:_:)(unsigned int a1, unsigned int a2)
{
  return a2 < a1;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _ValidUTF8Buffer.Index(_DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _ValidUTF8Buffer.Index(_DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _ValidUTF8Buffer.Index(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

uint64_t _ValidUTF8Buffer.endIndex.getter()
{
  return 0;
}

uint64_t static Int.&>> infix(_:_:)(uint64_t a1, char a2)
{
  return a1 >> a2;
}

BOOL _ValidUTF8Buffer.isEmpty.getter(int a1)
{
  return a1 == 0;
}

Swift::_ValidUTF8Buffer::Index __swiftcall _ValidUTF8Buffer.index(after:)(Swift::_ValidUTF8Buffer::Index after)
{
  if (!after._biasedBits)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x69uLL, 0);
  return (Swift::_ValidUTF8Buffer::Index)(after._biasedBits >> 8);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _ValidUTF8Buffer(_BYTE *a1, _BYTE *a2))()
{
  *a1 = *a2 - 1;
  return EnumeratedSequence._base.modify;
}

_DWORD *protocol witness for Collection.subscript.getter in conformance _ValidUTF8Buffer@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int *v2;
  int v3;
  int v4;

  v3 = *v2;
  if (*v2 < *result)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  v4 = result[1];
  *a2 = *result;
  a2[1] = v4;
  a2[2] = v3;
  return result;
}

void protocol witness for Collection.indices.getter in conformance _ValidUTF8Buffer(uint64_t a1@<X8>)
{
  unsigned int *v1;
  unsigned int v2;

  v2 = *v1;
  *(_DWORD *)a1 = *v1;
  *(_QWORD *)(a1 + 4) = v2;
}

void protocol witness for Collection._customIndexOfEquatableElement(_:) in conformance _ValidUTF8Buffer(uint64_t a1@<X8>)
{
  *(_WORD *)(a1 + 4) = 256;
  *(_DWORD *)a1 = 0;
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer(a1, a2, (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, a3);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer(a1, a2, a3, a4, (uint64_t)closure #1 in Sequence<>.contains(_:)specialized partial apply, (unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply);
}

Swift::Int __swiftcall _ValidUTF8Buffer.distance(from:to:)(Swift::_ValidUTF8Buffer::Index from, Swift::_ValidUTF8Buffer::Index to)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;

  if (from._biasedBits)
  {
    if (!v2)
LABEL_6:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x82uLL, 0);
    v3 = v2;
    while (v3 != from._biasedBits)
    {
      v4 = v3 >= 0x100;
      v3 >>= 8;
      if (!v4)
        goto LABEL_6;
    }
  }
  if (to._biasedBits)
  {
    if (!v2)
LABEL_11:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x83uLL, 0);
    while (v2 != to._biasedBits)
    {
      v4 = v2 >= 0x100;
      v2 >>= 8;
      if (!v4)
        goto LABEL_11;
    }
  }
  return (uint64_t)(__clz(from._biasedBits) - (unint64_t)__clz(to._biasedBits)) >> 3;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance _ValidUTF8Buffer(unsigned int *a1, uint64_t *a2)
{
  return specialized Collection._failEarlyRangeCheck(_:bounds:)(*a1, *a2);
}

_DWORD *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance _ValidUTF8Buffer(_DWORD *result, _DWORD *a2)
{
  if (*a2 < *result || *result < a2[1])
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  return result;
}

{
  if (*a2 < *result || result[1] < a2[1])
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  return result;
}

_DWORD *protocol witness for Collection.index(after:) in conformance _ValidUTF8Buffer@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  if (!*result)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x69uLL, 0);
  *a2 = *result >> 8;
  return result;
}

_DWORD *protocol witness for Collection.formIndex(after:) in conformance _ValidUTF8Buffer(_DWORD *result)
{
  if (!*result)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x69uLL, 0);
  *result >>= 8;
  return result;
}

Swift::_ValidUTF8Buffer::Index __swiftcall _ValidUTF8Buffer.index(before:)(Swift::_ValidUTF8Buffer::Index before)
{
  unsigned int v1;
  char v2;

  v2 = __clz(before._biasedBits);
  if ((v2 & 0x38) == 0x20)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x77uLL, 0);
  return (Swift::_ValidUTF8Buffer::Index)(v1 >> (~v2 & 0x18));
}

Swift::_ValidUTF8Buffer::Index protocol witness for BidirectionalCollection.index(before:) in conformance _ValidUTF8Buffer@<W0>(Swift::_ValidUTF8Buffer::Index *a1@<X0>, Swift::_ValidUTF8Buffer::Index *a2@<X8>)
{
  Swift::_ValidUTF8Buffer::Index result;

  result._biasedBits = _ValidUTF8Buffer.index(before:)((Swift::_ValidUTF8Buffer::Index)a1->_biasedBits)._biasedBits;
  a2->_biasedBits = result._biasedBits;
  return result;
}

unsigned int *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _ValidUTF8Buffer(unsigned int *result)
{
  _DWORD *v1;
  char v2;

  v2 = __clz(*result);
  if ((v2 & 0x38) == 0x20)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0x77uLL, 0);
  *result = *v1 >> (~v2 & 0x18);
  return result;
}

Swift::Bool __swiftcall _ValidUTF8Buffer._isValid(_:)(Swift::_ValidUTF8Buffer::Index a1)
{
  unsigned int v1;
  Swift::Bool result;
  BOOL v4;

  if (a1._biasedBits)
  {
    if (v1)
    {
      do
      {
        result = v1 == a1._biasedBits;
        if (v1 == a1._biasedBits)
          break;
        v4 = v1 > 0xFF;
        v1 >>= 8;
      }
      while (v4);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
  return result;
}

uint64_t protocol witness for Collection.index(_:offsetBy:) in conformance _ValidUTF8Buffer@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, unsigned int (*a3)(int *)@<X5>, unsigned int *a4@<X8>)
{
  unsigned int *v4;
  unsigned int v8;
  uint64_t v9;
  unsigned int (*v10)(int *);
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  char v16[8];
  unsigned int *v17;
  unsigned int v18;

  v8 = *(_DWORD *)result;
  v9 = *v4;
  if ((_DWORD)v9)
  {
    v18 = v9;
    MEMORY[0x1E0C80A78](result);
    v17 = &v18;
    result = specialized Sequence.contains(where:)(v10, (uint64_t)v16, v9 | (v9 << 32), 0);
    if ((result & 1) == 0)
    {
      LODWORD(v17) = 0;
      v15 = 130;
      goto LABEL_14;
    }
  }
  if (v8)
  {
    v18 = v8;
    MEMORY[0x1E0C80A78](result);
    v17 = &v18;
    result = specialized Sequence.contains(where:)(a3, (uint64_t)v16, v9 | (v9 << 32), 0);
    if ((result & 1) == 0)
    {
      LODWORD(v17) = 0;
      v15 = 131;
LABEL_14:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v15, (int)v17);
    }
  }
  v11 = __clz(v9);
  v12 = __clz(v8);
  v13 = __OFADD__(a2, (uint64_t)(v11 - v12) >> 3);
  v14 = a2 + ((uint64_t)(v11 - v12) >> 3);
  if (v13)
  {
    __break(1u);
    goto LABEL_10;
  }
  if ((v14 & 0x8000000000000000) != 0)
  {
LABEL_10:
    LODWORD(v17) = 0;
    v15 = 142;
    goto LABEL_14;
  }
  if (4 - (v11 >> 3) < v14)
  {
    LODWORD(v17) = 0;
    v15 = 143;
    goto LABEL_14;
  }
  *a4 = v9 >> (4 * (v14 & 7)) >> (4 * (v14 & 7));
  return result;
}

unint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance _ValidUTF8Buffer@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int *v4;
  unint64_t result;

  result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3, *v4);
  *(_DWORD *)a4 = result;
  *(_BYTE *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance _ValidUTF8Buffer(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int (*a6)(int *))
{
  unsigned int *v6;
  unsigned int v8;
  unsigned int v9;
  unint64_t v10;
  unsigned int (*v11)(int *);
  unint64_t v13;
  char v14[8];
  unsigned int *v15;
  unsigned int v16;

  v8 = *(_DWORD *)a1;
  v9 = *a2;
  v10 = *v6 | ((unint64_t)*v6 << 32);
  if (*(_DWORD *)a1)
  {
    v16 = *(_DWORD *)a1;
    MEMORY[0x1E0C80A78](a1);
    v15 = &v16;
    a1 = specialized Sequence.contains(where:)(v11, (uint64_t)v14, v10, 0);
    if ((a1 & 1) == 0)
    {
      LODWORD(v15) = 0;
      v13 = 130;
      goto LABEL_8;
    }
  }
  if (v9)
  {
    v16 = v9;
    MEMORY[0x1E0C80A78](a1);
    v15 = &v16;
    if ((specialized Sequence.contains(where:)(a6, (uint64_t)v14, v10, 0) & 1) == 0)
    {
      LODWORD(v15) = 0;
      v13 = 131;
LABEL_8:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v13, (int)v15);
    }
  }
  return (uint64_t)(__clz(v8) - (unint64_t)__clz(v9)) >> 3;
}

Swift::_ValidUTF8Buffer __swiftcall _ValidUTF8Buffer.init()()
{
  return 0;
}

uint64_t _ValidUTF8Buffer.capacity.getter()
{
  return 4;
}

uint64_t static _ValidUTF8Buffer.capacity.getter()
{
  return 4;
}

uint64_t static UInt8.bitWidth.getter()
{
  return 8;
}

Swift::Void __swiftcall _ValidUTF8Buffer.append(_:)(Swift::UInt8 a1)
{
  unsigned int *v1;

  if (HIBYTE(*v1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
  *v1 |= (a1 + 1) << (-(__clz(*v1) & 0x18) & 0x18);
}

Swift::UInt8 __swiftcall _ValidUTF8Buffer.removeFirst()()
{
  unsigned int *v0;
  unsigned int v1;
  Swift::UInt8 result;

  v1 = *v0;
  if (!*v0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xB1uLL, 0);
  result = v1 - 1;
  *v0 = v1 >> 8;
  return result;
}

uint64_t _ValidUTF8Buffer.replaceSubrange<A>(_:with:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  unsigned int *v4;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t AssociatedTypeWitness;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unsigned int v18;
  BOOL v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t AssociatedConformanceWitness;
  void (*v25)(uint64_t *__return_ptr, unint64_t, unint64_t);
  char v26;
  uint64_t result;
  unint64_t v28;
  BOOL v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;

  v4 = v3;
  v8 = *(_QWORD *)(a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v10 = (char *)&v31 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = *(_QWORD *)(v11 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v12, v13, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v17 = (char *)&v31 - v16;
  if ((_DWORD)a1)
  {
    v18 = *v4;
    if (!*v4)
LABEL_5:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xC1uLL, 0);
    while (v18 != (_DWORD)a1)
    {
      v19 = v18 >= 0x100;
      v18 >>= 8;
      if (!v19)
        goto LABEL_5;
    }
  }
  if (HIDWORD(a1))
  {
    v20 = *v4;
    if (!*v4)
LABEL_10:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xC2uLL, 0);
    while (v20 != HIDWORD(a1))
    {
      v19 = v20 >= 0x100;
      v20 >>= 8;
      if (!v19)
        goto LABEL_10;
    }
  }
  v21 = *v4;
  if (*v4 < a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v22 = a2;
  v31 = v15;
  v23 = 0;
  if (v21 != (_DWORD)a1)
  {
    v30 = v21;
    while (v21 >= v30 && v30 > a1)
    {
      if (HIBYTE(v23))
        goto LABEL_31;
      v23 |= v30 << (-(__clz(v23) & 0x18) & 0x18);
      v30 >>= 8;
      if (v30 == (_DWORD)a1)
        goto LABEL_14;
    }
LABEL_30:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
LABEL_14:
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 16))(v10, v22, a3);
  (*(void (**)(uint64_t, uint64_t))(v12 + 32))(a3, v12);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v12, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v25 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v25(&v32, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v32 & 0x100) == 0)
  {
    v26 = v32;
    while (!HIBYTE(v23))
    {
      v23 |= (v26 + 1) << (-(__clz(v23) & 0x18) & 0x18);
      v25(&v32, AssociatedTypeWitness, AssociatedConformanceWitness);
      v26 = v32;
      if (BYTE1(v32) == 1)
        goto LABEL_18;
    }
LABEL_31:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
  }
LABEL_18:
  result = (*(uint64_t (**)(char *, unint64_t))(v31 + 8))(v17, AssociatedTypeWitness);
  if (*v4 < HIDWORD(a1))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  if (HIDWORD(a1))
  {
    v28 = HIDWORD(a1);
    while (v28 <= HIDWORD(a1))
    {
      if (HIBYTE(v23))
        goto LABEL_31;
      v23 |= v28 << (-(__clz(v23) & 0x18) & 0x18);
      v29 = v28 > 0xFF;
      LODWORD(v28) = v28 >> 8;
      if (!v29)
        goto LABEL_24;
    }
    goto LABEL_30;
  }
LABEL_24:
  *v4 = v23;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.replaceSubrange<A>(_:with:) in conformance _ValidUTF8Buffer(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t AssociatedConformanceWitness;
  void (*v24)(uint64_t *__return_ptr, unint64_t, unint64_t);
  char v25;
  uint64_t result;
  unsigned int *v27;
  unsigned int v28;
  BOOL v29;
  unint64_t v30;
  char v31[8];
  uint64_t *v32;
  uint64_t v33;
  unsigned int *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v36 = a2;
  v38 = *(_QWORD *)(a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v35 = (char *)&v33 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *(_QWORD *)(v6 + 8);
  v37 = v8;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v33 - v12;
  v15 = *a1;
  v14 = a1[1];
  v16 = *v3 | ((unint64_t)*v3 << 32);
  if ((_DWORD)v15)
  {
    LODWORD(v39) = v15;
    MEMORY[0x1E0C80A78](v11);
    v32 = &v39;
    v11 = specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v31, v16, 0);
    if ((v11 & 1) == 0)
    {
      LODWORD(v32) = 0;
      v30 = 193;
      goto LABEL_23;
    }
  }
  if ((_DWORD)v14)
  {
    LODWORD(v39) = v14;
    MEMORY[0x1E0C80A78](v11);
    v32 = &v39;
    if ((specialized Sequence.contains(where:)((unsigned int (*)(int *))closure #1 in Sequence<>.contains(_:)specialized partial apply, (uint64_t)v31, v16, 0) & 1) == 0)
    {
      LODWORD(v32) = 0;
      v30 = 194;
      goto LABEL_23;
    }
  }
  v17 = *v3;
  if (v17 < v15)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v33 = v10;
  v34 = v3;
  v18 = 0;
  if ((_DWORD)v17 != (_DWORD)v15)
  {
    v19 = v17;
    while (1)
    {
      v20 = specialized Slice.subscript.getter(v19, v17 | (v15 << 32));
      if (!v19)
        break;
      if (HIBYTE(v18))
        goto LABEL_21;
      v19 >>= 8;
      v18 |= (v20 + 1) << (-(__clz(v18) & 0x18) & 0x18);
      if (v19 == (_DWORD)v15)
        goto LABEL_11;
    }
    LODWORD(v32) = 0;
    v30 = 105;
LABEL_23:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, v30, (int)v32);
  }
LABEL_11:
  v21 = v37;
  v22 = v36;
  (*(void (**)(char *, uint64_t, uint64_t))(v38 + 16))(v35, v36, v37);
  (*(void (**)(uint64_t, uint64_t))(v7 + 32))(v21, v7);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v24 = *(void (**)(uint64_t *__return_ptr, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 16);
  v24(&v39, AssociatedTypeWitness, AssociatedConformanceWitness);
  if ((v39 & 0x100) == 0)
  {
    v25 = v39;
    while (!HIBYTE(v18))
    {
      v18 |= (v25 + 1) << (-(__clz(v18) & 0x18) & 0x18);
      v24(&v39, AssociatedTypeWitness, AssociatedConformanceWitness);
      v25 = v39;
      if (BYTE1(v39) == 1)
        goto LABEL_15;
    }
    goto LABEL_21;
  }
LABEL_15:
  (*(void (**)(uint64_t, uint64_t))(v38 + 8))(v22, v21);
  result = (*(uint64_t (**)(char *, unint64_t))(v33 + 8))(v13, AssociatedTypeWitness);
  v27 = v34;
  if (*v34 < v14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  if ((_DWORD)v14)
  {
    v28 = v14;
    while (1)
    {
      result = specialized Slice.subscript.getter(v28, v14);
      if (HIBYTE(v18))
        break;
      v18 |= (result + 1) << (-(__clz(v18) & 0x18) & 0x18);
      v29 = v28 > 0xFF;
      v28 >>= 8;
      if (!v29)
        goto LABEL_20;
    }
LABEL_21:
    LODWORD(v32) = 0;
    v30 = 167;
    goto LABEL_23;
  }
LABEL_20:
  *v27 = v18;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init(repeating:count:) in conformance _ValidUTF8Buffer@<X0>(char *a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t result;

  result = specialized RangeReplaceableCollection.init(repeating:count:)(*a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.init<A>(_:) in conformance _ValidUTF8Buffer@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  uint64_t result;

  result = specialized RangeReplaceableCollection.init<A>(_:)(a1, a2, a3);
  *a4 = result;
  return result;
}

_BYTE *protocol witness for RangeReplaceableCollection.append(_:) in conformance _ValidUTF8Buffer(_BYTE *result)
{
  unsigned int *v1;

  if (HIBYTE(*v1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
  *v1 |= (*result + 1) << (-(__clz(*v1) & 0x18) & 0x18);
  return result;
}

uint64_t protocol witness for RangeReplaceableCollection.insert(_:at:) in conformance _ValidUTF8Buffer(unsigned __int8 *a1, unsigned int *a2)
{
  return specialized RangeReplaceableCollection.insert(_:at:)(*a1, *a2);
}

uint64_t protocol witness for RangeReplaceableCollection.insert<A>(contentsOf:at:) in conformance _ValidUTF8Buffer(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(a1, *a2, a3);
}

uint64_t protocol witness for RangeReplaceableCollection.remove(at:) in conformance _ValidUTF8Buffer@<X0>(unsigned int *a1@<X0>, _BYTE *a2@<X8>)
{
  uint64_t result;

  result = specialized RangeReplaceableCollection.remove(at:)(*a1);
  *a2 = result;
  return result;
}

unint64_t protocol witness for RangeReplaceableCollection.removeSubrange(_:) in conformance _ValidUTF8Buffer(unint64_t *a1)
{
  return specialized RangeReplaceableCollection.removeSubrange(_:)(*a1);
}

void protocol witness for RangeReplaceableCollection._customRemoveLast() in conformance _ValidUTF8Buffer(_WORD *a1@<X8>)
{
  *a1 = 256;
}

void protocol witness for RangeReplaceableCollection.removeFirst() in conformance _ValidUTF8Buffer(_BYTE *a1@<X8>)
{
  unsigned int *v1;
  unsigned int v2;

  v2 = *v1;
  if (!*v1)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xB1uLL, 0);
  *v1 = v2 >> 8;
  *a1 = v2 - 1;
}

uint64_t protocol witness for RangeReplaceableCollection.removeAll(where:) in conformance _ValidUTF8Buffer(uint64_t a1)
{
  return specialized RangeReplaceableCollection.removeAll(where:)(a1);
}

Swift::Void __swiftcall _ValidUTF8Buffer.append(contentsOf:)(Swift::_ValidUTF8Buffer contentsOf)
{
  unsigned int *v1;
  unint64_t v2;

  v2 = 4 - (__clz(*v1) >> 3);
  if (v2 > __clz(contentsOf._biasedBits) >> 3)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xCFuLL, 0);
  *v1 |= contentsOf._biasedBits << (8 * (v2 & 3));
}

uint64_t Range<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(_:)(a1, a2, a3, (uint64_t (*)(_QWORD, uint64_t, _QWORD))type metadata accessor for Range, a4);
}

uint64_t ClosedRange<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return Range<>.init(_:)(a1, a2, a3, (uint64_t (*)(_QWORD, uint64_t, _QWORD))type metadata accessor for ClosedRange, a4);
}

uint64_t Range<>.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t (*a4)(_QWORD, uint64_t, _QWORD)@<X4>, uint64_t a5@<X8>)
{
  uint64_t v7;

  v7 = a4(0, a2, *(_QWORD *)(a3 + 8));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 32))(a5, a1, v7);
}

void String.characters.setter(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  swift_bridgeObjectRelease(v2[1]);
  *v2 = a1;
  v2[1] = a2;
}

void (*String.characters.modify(_QWORD *a1, uint64_t a2, uint64_t a3, char *a4))(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  _QWORD *v4;
  unint64_t v6;

  a1[2] = v4;
  v6 = v4[1];
  *a1 = *v4;
  a1[1] = v6;
  swift_bridgeObjectRetain(v6, a2, a3, a4);
  return String.utf16.modify;
}

uint64_t String.withMutableCharacters<A>(_:)(uint64_t (*a1)(uint64_t))
{
  uint64_t v1;

  return a1(v1);
}

uint64_t Substring.characters.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  swift_bridgeObjectRetain((unint64_t)a4, a2, a3, a4);
  return a1;
}

unint64_t key path getter for Substring.utf8 : Substring@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v5;
  uint64_t v6;

  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  *(_OWORD *)a5 = *(_OWORD *)a1;
  *(_QWORD *)(a5 + 16) = v6;
  *(_QWORD *)(a5 + 24) = v5;
  return swift_bridgeObjectRetain(v5, a2, a3, a4);
}

__n128 key path setter for Substring.characters : Substring(__n128 *a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __n128 result;
  __n128 v9;

  v9 = *a1;
  v6 = a1[1].n128_u64[0];
  v5 = a1[1].n128_u64[1];
  v7 = *(_QWORD *)(a2 + 24);
  swift_bridgeObjectRetain(v5, a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  result = v9;
  *(__n128 *)a2 = v9;
  *(_QWORD *)(a2 + 16) = v6;
  *(_QWORD *)(a2 + 24) = v5;
  return result;
}

void Substring.unicodeScalars.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;

  swift_bridgeObjectRelease(v4[3]);
  *v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  v4[3] = a4;
}

void (*Substring.characters.modify(_QWORD *a1))(uint64_t **a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v1;
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;

  v3 = malloc(0x28uLL);
  *a1 = v3;
  v3[4] = v1;
  v5 = *(_QWORD *)(v1 + 16);
  v4 = *(_QWORD *)(v1 + 24);
  *(_OWORD *)v3 = *(_OWORD *)v1;
  v3[2] = v5;
  v3[3] = v4;
  swift_bridgeObjectRetain(v4, v6, v7, v8);
  return Substring.unicodeScalars.modify;
}

uint64_t Substring.withMutableCharacters<A>(_:)(uint64_t (*a1)(uint64_t))
{
  uint64_t v1;

  return a1(v1);
}

uint64_t Substring.customPlaygroundQuickLook.getter@<X0>(Swift::String::Index a1@<X0>, Swift::String::Index a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t result;
  uint64_t v7;

  result = specialized String.init(_:)(a1, a2, a3, a4);
  *(_QWORD *)a5 = result;
  *(_QWORD *)(a5 + 8) = v7;
  *(_BYTE *)(a5 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance Substring@<X0>(uint64_t a1@<X8>)
{
  Swift::UInt64 *v1;
  Swift::String::Index v3;
  Swift::String::Index v4;
  uint64_t result;
  uint64_t v6;

  v3._rawBits = *v1;
  v4._rawBits = v1[1];
  result = specialized String.init(_:)(v3, v4, v1[2], v1[3]);
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = v6;
  *(_BYTE *)(a1 + 32) = 0;
  return result;
}

uint64_t Collection.index<A>(_:offsetBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  void (*v31)(char *, uint64_t, uint64_t);
  uint64_t v32;
  void (*v33)(char *, uint64_t);
  char *v34;
  uint64_t (*v35)(uint64_t, uint64_t);
  uint64_t (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char *v48;
  char v49;
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  char *v54;
  uint64_t v55;
  BOOL v56;
  const char *v57;
  unint64_t AssociatedConformanceWitness;
  char *v59;
  const char *v60;
  void (*v61)(char *, uint64_t, const char *);
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  void (*v73)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  char *v77;
  char *v78;
  char v79;
  uint64_t v80;
  uint64_t v82;
  char *v83;
  char *v84;
  const char *v85;
  uint64_t (*v86)(uint64_t, uint64_t);
  char *v87;
  char *v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t (*v94)(uint64_t, uint64_t);
  uint64_t v95;
  uint64_t v96;

  v93 = a5;
  v91 = a1;
  v92 = a3;
  v90 = a7;
  v85 = *(const char **)(*(_QWORD *)(a6 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v85, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v84 = (char *)&v82 - v12;
  v13 = *(_QWORD *)(a4 - 8);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v82 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v14);
  v88 = (char *)&v82 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v82 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v89 = (char *)&v82 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v87 = (char *)&v82 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v82 - v27;
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v82 - v29;
  v31 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v31((char *)&v82 - v29, a2, a4);
  v94 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  LOBYTE(a2) = v94(a4, a6);
  v31(v28, (uint64_t)v30, a4);
  if ((a2 & 1) == 0)
  {
    v33 = *(void (**)(char *, uint64_t))(v13 + 8);
    v33(v28, a4);
    v36 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    v35 = v94;
    v41 = v36(a4, a6);
    goto LABEL_25;
  }
  v86 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
  v32 = v86(a4, a6);
  v33 = *(void (**)(char *, uint64_t))(v13 + 8);
  v33(v28, a4);
  if (v32 <= 64)
  {
    v35 = v94;
    v36 = v86;
    v41 = v86(a4, a6);
    goto LABEL_25;
  }
  v83 = v16;
  v34 = v87;
  v31(v87, (uint64_t)v30, a4);
  v96 = 0x8000000000000000;
  v35 = v94;
  if ((v94(a4, a6) & 1) != 0)
  {
    v36 = v86;
    v37 = v86(a4, a6);
    if (v37 < 64)
    {
      v40 = v89;
      v31(v89, (uint64_t)v34, a4);
      v85 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v33(v40, a4);
      if ((uint64_t)v85 < v96)
        goto LABEL_41;
      goto LABEL_24;
    }
    v85 = *(const char **)(a6 + 96);
    v50 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
    v51 = v89;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v85)(&v96, &type metadata for Int, v50, a4, a6);
    v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v34, v51, a4);
    v53 = v51;
    v35 = v94;
    v33(v53, a4);
    if ((v52 & 1) != 0)
LABEL_41:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  else
  {
    v42 = v35(a4, a6);
    v43 = v86(a4, a6);
    if ((v42 & 1) != 0)
    {
      if (v43 <= 64)
      {
        v57 = v85;
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v85, a4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v59 = v84;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
        v60 = v57;
        v61 = (void (*)(char *, uint64_t, const char *))*((_QWORD *)v57 + 3);
        v62 = v89;
        v61(v59, a4, v60);
        v63 = v87;
        LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v87, v62, a4);
        v33(v62, a4);
        v64 = v83;
        v31(v83, (uint64_t)v63, a4);
        if ((v59 & 1) != 0)
        {
          v33(v64, a4);
          goto LABEL_41;
        }
        v65 = v96;
        v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
        v33(v64, a4);
        v56 = v66 < v65;
        v35 = v94;
        v36 = v86;
        v34 = v87;
        if (v56)
          goto LABEL_41;
      }
      else
      {
        v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        v47 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
        v48 = v89;
        v46(&v96, &type metadata for Int, v47, a4, a6);
        v34 = v87;
        v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v87, v48, a4);
        v33(v48, a4);
        v35 = v94;
        v36 = v86;
        if ((v49 & 1) != 0)
          goto LABEL_41;
      }
    }
    else if (v43 < 64)
    {
      v54 = v89;
      v34 = v87;
      v31(v89, (uint64_t)v87, a4);
      v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v33(v54, a4);
      v56 = v55 < v96;
      v35 = v94;
      v36 = v86;
      if (v56)
        goto LABEL_41;
    }
    else
    {
      v35 = v94;
      v36 = v86;
      v34 = v87;
    }
  }
LABEL_24:
  v33(v34, a4);
  v41 = v36(a4, a6);
LABEL_25:
  v67 = v41;
  v31(v21, (uint64_t)v30, a4);
  if (v67 >= 65)
  {
    v33(v21, a4);
    goto LABEL_27;
  }
  v76 = v36(a4, a6);
  v33(v21, a4);
  if (v76 == 64 && (v35(a4, a6) & 1) == 0)
  {
LABEL_27:
    v68 = v88;
    v31(v88, (uint64_t)v30, a4);
    v96 = 0x7FFFFFFFFFFFFFFFLL;
    v69 = v35(a4, a6);
    v70 = v36(a4, a6);
    if ((v69 & 1) != 0)
    {
      if (v70 > 64)
      {
        v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
        v75 = &v96;
        goto LABEL_36;
      }
    }
    else if (v70 > 63)
    {
      v95 = 0x7FFFFFFFFFFFFFFFLL;
      v73 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
      v75 = &v95;
LABEL_36:
      v78 = v89;
      v73(v75, &type metadata for Int, v74, a4, a6);
      v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v78, v68, a4);
      v33(v78, a4);
      if ((v79 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_37;
    }
    v77 = v89;
    v31(v89, (uint64_t)v68, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    v33(v77, a4);
LABEL_37:
    v33(v68, a4);
  }
  v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
  v33(v30, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v93 + 136))(v91, v80, v92);
}

uint64_t Collection.formIndex<A>(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  char *v33;
  void (*v34)(char *, uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t, uint64_t);
  uint64_t v36;
  void (*v37)(char *, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  char *v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v51;
  char *v52;
  char *v53;
  char v54;
  char *v55;
  void (*v56)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v57;
  char *v58;
  char *v59;
  uint64_t v60;
  char *v61;
  const char *v62;
  unint64_t AssociatedConformanceWitness;
  const char *v64;
  void (*v65)(char *, uint64_t, const char *);
  char *v66;
  char *v67;
  char *v68;
  int64_t v69;
  uint64_t v70;
  BOOL v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void (*v77)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v78;
  int64_t *v79;
  uint64_t v80;
  char *v81;
  char *v82;
  char v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  unint64_t v87;
  uint64_t v88;
  char *v90;
  const char *v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  const char *v99;
  uint64_t v100;
  char *v101;
  uint64_t (*v102)(uint64_t, uint64_t);
  uint64_t v103;
  int64_t v104;

  v100 = a1;
  v91 = *(const char **)(*(_QWORD *)(a6 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v91, a4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v92 = (char *)&v90 - v12;
  v99 = a5;
  v98 = a3;
  v13 = swift_getAssociatedTypeWitness(0, a5, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v96 = *(_QWORD *)(v13 - 8);
  v97 = v13;
  v14 = MEMORY[0x1E0C80A78](v13);
  v95 = (char *)&v90 - v15;
  v16 = *(_QWORD *)(a4 - 8);
  v17 = MEMORY[0x1E0C80A78](v14);
  v90 = (char *)&v90 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v101 = (char *)&v90 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v90 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v94 = (char *)&v90 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v90 - v27;
  v29 = MEMORY[0x1E0C80A78](v26);
  v31 = (char *)&v90 - v30;
  MEMORY[0x1E0C80A78](v29);
  v33 = (char *)&v90 - v32;
  v34 = *(void (**)(char *, uint64_t, uint64_t))(v16 + 16);
  v34((char *)&v90 - v32, a2, a4);
  v102 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 64);
  LOBYTE(a2) = v102(a4, a6);
  v34(v31, (uint64_t)v33, a4);
  if ((a2 & 1) == 0)
  {
    v37 = *(void (**)(char *, uint64_t))(v16 + 8);
    v37(v31, a4);
    v35 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
    goto LABEL_8;
  }
  v93 = v28;
  v35 = *(uint64_t (**)(uint64_t, uint64_t))(a6 + 128);
  v36 = v35(a4, a6);
  v37 = *(void (**)(char *, uint64_t))(v16 + 8);
  v37(v31, a4);
  if (v36 <= 64)
  {
LABEL_8:
    v45 = v101;
    goto LABEL_24;
  }
  v34(v93, (uint64_t)v33, a4);
  v104 = 0x8000000000000000;
  v38 = v102;
  if ((v102(a4, a6) & 1) == 0)
  {
    v46 = v38(a4, a6);
    v47 = v35(a4, a6);
    if ((v46 & 1) != 0)
    {
      if (v47 > 64)
      {
        v50 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        v51 = lazy protocol witness table accessor for type Int and conformance Int(v47, v48, v49);
        v52 = v94;
        v50(&v104, &type metadata for Int, v51, a4, a6);
        v53 = v93;
        v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v93, v52, a4);
        v55 = v52;
        v39 = v53;
        goto LABEL_13;
      }
      v62 = v91;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v91, a4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v64 = v62;
      v65 = (void (*)(char *, uint64_t, const char *))*((_QWORD *)v62 + 3);
      v66 = v94;
      v65(v92, a4, v64);
      v67 = v93;
      LODWORD(v92) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v93, v66, a4);
      v37(v66, a4);
      v68 = v90;
      v34(v90, (uint64_t)v67, a4);
      if ((v92 & 1) != 0)
      {
        v37(v68, a4);
        goto LABEL_40;
      }
      v69 = v104;
      v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v37(v68, a4);
      v71 = v70 < v69;
      v45 = v101;
      v39 = v93;
      if (!v71)
        goto LABEL_23;
    }
    else
    {
      v45 = v101;
      if (v47 >= 64)
      {
        v39 = v93;
        goto LABEL_23;
      }
      v59 = v94;
      v34(v94, (uint64_t)v93, a4);
      v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
      v61 = v59;
      v39 = v93;
      v37(v61, a4);
      if (v60 >= v104)
        goto LABEL_23;
    }
LABEL_40:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v39 = v93;
  v40 = v35(a4, a6);
  if (v40 < 64)
  {
    v43 = v94;
    v34(v94, (uint64_t)v39, a4);
    v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    v37(v43, a4);
    v45 = v101;
    if (v44 < v104)
      goto LABEL_40;
    goto LABEL_23;
  }
  v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
  v57 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
  v58 = v94;
  v56(&v104, &type metadata for Int, v57, a4, a6);
  v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v93, v58, a4);
  v55 = v58;
  v39 = v93;
LABEL_13:
  v37(v55, a4);
  v45 = v101;
  if ((v54 & 1) != 0)
    goto LABEL_40;
LABEL_23:
  v37(v39, a4);
LABEL_24:
  v72 = v35(a4, a6);
  v34(v23, (uint64_t)v33, a4);
  if (v72 >= 65)
  {
    v37(v23, a4);
    goto LABEL_26;
  }
  v80 = v35(a4, a6);
  v37(v23, a4);
  if (v80 == 64 && (v102(a4, a6) & 1) == 0)
  {
LABEL_26:
    v34(v45, (uint64_t)v33, a4);
    v104 = 0x7FFFFFFFFFFFFFFFLL;
    v73 = v102(a4, a6);
    v74 = v35(a4, a6);
    if ((v73 & 1) != 0)
    {
      if (v74 > 64)
      {
        v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
        v78 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
        v79 = &v104;
        goto LABEL_35;
      }
    }
    else if (v74 > 63)
    {
      v103 = 0x7FFFFFFFFFFFFFFFLL;
      v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 96);
      v78 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      v79 = &v103;
LABEL_35:
      v82 = v94;
      v77(v79, &type metadata for Int, v78, a4, a6);
      v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a6 + 32) + 8) + 16))(v82, v45, a4);
      v37(v82, a4);
      if ((v83 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_36;
    }
    v81 = v94;
    v34(v94, (uint64_t)v45, a4);
    (*(void (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
    v37(v81, a4);
LABEL_36:
    v37(v45, a4);
  }
  v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 120))(a4, a6);
  v37(v33, a4);
  v85 = v100;
  v86 = v95;
  (*((void (**)(uint64_t, uint64_t, uint64_t))v99 + 17))(v100, v84, v98);
  v88 = v96;
  v87 = v97;
  (*(void (**)(uint64_t, unint64_t))(v96 + 8))(v85, v97);
  return (*(uint64_t (**)(uint64_t, char *, unint64_t))(v88 + 32))(v85, v86, v87);
}

uint64_t Collection.index<A>(_:offsetBy:limitedBy:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  void (*v32)(char *, uint64_t, uint64_t);
  uint64_t v33;
  void (*v34)(char *, uint64_t);
  char *v35;
  uint64_t (*v36)(uint64_t, uint64_t);
  uint64_t (*v37)(uint64_t, uint64_t);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v48;
  char *v49;
  char v50;
  unint64_t v51;
  char *v52;
  char v53;
  char *v54;
  char *v55;
  uint64_t v56;
  BOOL v57;
  const char *v58;
  unint64_t AssociatedConformanceWitness;
  char *v60;
  const char *v61;
  void (*v62)(char *, uint64_t, const char *);
  char *v63;
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  char v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void (*v74)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  char *v78;
  char *v79;
  char v80;
  uint64_t v81;
  char *v83;
  char *v84;
  const char *v85;
  uint64_t (*v86)(uint64_t, uint64_t);
  char *v87;
  char *v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t (*v95)(uint64_t, uint64_t);
  uint64_t v96;
  uint64_t v97;

  v94 = a6;
  v92 = a3;
  v93 = a4;
  v90 = a8;
  v91 = a1;
  v85 = *(const char **)(*(_QWORD *)(a7 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v85, a5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v12 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v84 = (char *)&v83 - v13;
  v14 = *(_QWORD *)(a5 - 8);
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v83 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v18 = MEMORY[0x1E0C80A78](v15);
  v88 = (char *)&v83 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v83 - v21;
  v23 = MEMORY[0x1E0C80A78](v20);
  v89 = (char *)&v83 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v87 = (char *)&v83 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v29 = (char *)&v83 - v28;
  MEMORY[0x1E0C80A78](v27);
  v31 = (char *)&v83 - v30;
  v32 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  v32((char *)&v83 - v30, a2, a5);
  v95 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 64);
  LOBYTE(a2) = v95(a5, a7);
  v32(v29, (uint64_t)v31, a5);
  if ((a2 & 1) == 0)
  {
    v34 = *(void (**)(char *, uint64_t))(v14 + 8);
    v34(v29, a5);
    v37 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
    v36 = v95;
    v42 = v37(a5, a7);
    goto LABEL_25;
  }
  v86 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
  v33 = v86(a5, a7);
  v34 = *(void (**)(char *, uint64_t))(v14 + 8);
  v34(v29, a5);
  if (v33 <= 64)
  {
    v36 = v95;
    v37 = v86;
    v42 = v86(a5, a7);
    goto LABEL_25;
  }
  v83 = v17;
  v35 = v87;
  v32(v87, (uint64_t)v31, a5);
  v97 = 0x8000000000000000;
  v36 = v95;
  if ((v95(a5, a7) & 1) != 0)
  {
    v37 = v86;
    v38 = v86(a5, a7);
    if (v38 < 64)
    {
      v41 = v89;
      v32(v89, (uint64_t)v35, a5);
      v85 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      v34(v41, a5);
      if ((uint64_t)v85 < v97)
        goto LABEL_41;
      goto LABEL_24;
    }
    v85 = *(const char **)(a7 + 96);
    v51 = lazy protocol witness table accessor for type Int and conformance Int(v38, v39, v40);
    v52 = v89;
    ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v85)(&v97, &type metadata for Int, v51, a5, a7);
    v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v35, v52, a5);
    v54 = v52;
    v36 = v95;
    v34(v54, a5);
    if ((v53 & 1) != 0)
LABEL_41:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  else
  {
    v43 = v36(a5, a7);
    v44 = v86(a5, a7);
    if ((v43 & 1) != 0)
    {
      if (v44 <= 64)
      {
        v58 = v85;
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v85, a5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v60 = v84;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
        v61 = v58;
        v62 = (void (*)(char *, uint64_t, const char *))*((_QWORD *)v58 + 3);
        v63 = v89;
        v62(v60, a5, v61);
        v64 = v87;
        LOBYTE(v60) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v87, v63, a5);
        v34(v63, a5);
        v65 = v83;
        v32(v83, (uint64_t)v64, a5);
        if ((v60 & 1) != 0)
        {
          v34(v65, a5);
          goto LABEL_41;
        }
        v66 = v97;
        v67 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
        v34(v65, a5);
        v57 = v67 < v66;
        v36 = v95;
        v37 = v86;
        v35 = v87;
        if (v57)
          goto LABEL_41;
      }
      else
      {
        v47 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
        v48 = lazy protocol witness table accessor for type Int and conformance Int(v44, v45, v46);
        v49 = v89;
        v47(&v97, &type metadata for Int, v48, a5, a7);
        v35 = v87;
        v50 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v87, v49, a5);
        v34(v49, a5);
        v36 = v95;
        v37 = v86;
        if ((v50 & 1) != 0)
          goto LABEL_41;
      }
    }
    else if (v44 < 64)
    {
      v55 = v89;
      v35 = v87;
      v32(v89, (uint64_t)v87, a5);
      v56 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      v34(v55, a5);
      v57 = v56 < v97;
      v36 = v95;
      v37 = v86;
      if (v57)
        goto LABEL_41;
    }
    else
    {
      v36 = v95;
      v37 = v86;
      v35 = v87;
    }
  }
LABEL_24:
  v34(v35, a5);
  v42 = v37(a5, a7);
LABEL_25:
  v68 = v42;
  v32(v22, (uint64_t)v31, a5);
  if (v68 >= 65)
  {
    v34(v22, a5);
    goto LABEL_27;
  }
  v77 = v37(a5, a7);
  v34(v22, a5);
  if (v77 == 64 && (v36(a5, a7) & 1) == 0)
  {
LABEL_27:
    v69 = v88;
    v32(v88, (uint64_t)v31, a5);
    v97 = 0x7FFFFFFFFFFFFFFFLL;
    v70 = v36(a5, a7);
    v71 = v37(a5, a7);
    if ((v70 & 1) != 0)
    {
      if (v71 > 64)
      {
        v74 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
        v75 = lazy protocol witness table accessor for type Int and conformance Int(v71, v72, v73);
        v76 = &v97;
        goto LABEL_36;
      }
    }
    else if (v71 > 63)
    {
      v96 = 0x7FFFFFFFFFFFFFFFLL;
      v74 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
      v75 = lazy protocol witness table accessor for type Int and conformance Int(v71, v72, v73);
      v76 = &v96;
LABEL_36:
      v79 = v89;
      v74(v76, &type metadata for Int, v75, a5, a7);
      v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v79, v69, a5);
      v34(v79, a5);
      if ((v80 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_37;
    }
    v78 = v89;
    v32(v89, (uint64_t)v69, a5);
    (*(void (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
    v34(v78, a5);
LABEL_37:
    v34(v69, a5);
  }
  v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v34(v31, a5);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v94 + 144))(v91, v81, v92, v93);
}

BOOL Collection.formIndex<A>(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  void (*v37)(char *, uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  void (*v40)(char *, uint64_t);
  uint64_t (*v41)(uint64_t, uint64_t);
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  char *v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v54;
  char *v55;
  char *v56;
  char v57;
  char *v58;
  void (*v59)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  const char *v65;
  unint64_t AssociatedConformanceWitness;
  const char *v67;
  void (*v68)(char *, uint64_t, const char *);
  char *v69;
  char *v70;
  char *v71;
  int64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  char v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  void (*v80)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v81;
  int64_t *v82;
  uint64_t v83;
  char *v84;
  char *v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  char *v95;
  const char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  char *v101;
  char *v102;
  uint64_t v103;
  unint64_t v104;
  const char *v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  uint64_t (*v109)(uint64_t, uint64_t);
  uint64_t v110;
  int64_t v111;

  v106 = a3;
  v107 = a1;
  v96 = *(const char **)(*(_QWORD *)(a7 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v96, a5, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v97 = (char *)&v95 - v13;
  v105 = a6;
  v103 = a4;
  v104 = swift_getAssociatedTypeWitness(255, a6, a4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v16 = type metadata accessor for Optional(0, v104, v14, v15);
  v99 = *(_QWORD *)(v16 - 8);
  v100 = v16;
  v17 = MEMORY[0x1E0C80A78](v16);
  v102 = (char *)&v95 - v18;
  v19 = *(_QWORD *)(a5 - 8);
  v20 = MEMORY[0x1E0C80A78](v17);
  v95 = (char *)&v95 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v20);
  v108 = (char *)&v95 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v95 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v101 = (char *)&v95 - v28;
  v29 = MEMORY[0x1E0C80A78](v27);
  v31 = (char *)&v95 - v30;
  v32 = MEMORY[0x1E0C80A78](v29);
  v34 = (char *)&v95 - v33;
  MEMORY[0x1E0C80A78](v32);
  v36 = (char *)&v95 - v35;
  v37 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v37((char *)&v95 - v35, a2, a5);
  v109 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 64);
  LOBYTE(a2) = v109(a5, a7);
  v37(v34, (uint64_t)v36, a5);
  if ((a2 & 1) == 0)
  {
    v40 = *(void (**)(char *, uint64_t))(v19 + 8);
    v40(v34, a5);
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
    goto LABEL_8;
  }
  v98 = v31;
  v38 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 128);
  v39 = v38(a5, a7);
  v40 = *(void (**)(char *, uint64_t))(v19 + 8);
  v40(v34, a5);
  if (v39 <= 64)
  {
LABEL_8:
    v48 = v108;
    goto LABEL_24;
  }
  v37(v98, (uint64_t)v36, a5);
  v111 = 0x8000000000000000;
  v41 = v109;
  if ((v109(a5, a7) & 1) == 0)
  {
    v49 = v41(a5, a7);
    v50 = v38(a5, a7);
    if ((v49 & 1) != 0)
    {
      if (v50 > 64)
      {
        v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
        v54 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
        v55 = v101;
        v53(&v111, &type metadata for Int, v54, a5, a7);
        v56 = v98;
        v57 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v98, v55, a5);
        v58 = v55;
        v42 = v56;
        goto LABEL_13;
      }
      v65 = v96;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v96, a5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v67 = v65;
      v68 = (void (*)(char *, uint64_t, const char *))*((_QWORD *)v65 + 3);
      v69 = v101;
      v68(v97, a5, v67);
      v70 = v98;
      LODWORD(v97) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v98, v69, a5);
      v40(v69, a5);
      v71 = v95;
      v37(v95, (uint64_t)v70, a5);
      if ((v97 & 1) != 0)
      {
        v40(v71, a5);
        goto LABEL_43;
      }
      v72 = v111;
      v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      v40(v71, a5);
      v74 = v73 < v72;
      v48 = v108;
      v42 = v98;
      if (!v74)
        goto LABEL_23;
    }
    else
    {
      v48 = v108;
      if (v50 >= 64)
      {
        v42 = v98;
        goto LABEL_23;
      }
      v62 = v101;
      v37(v101, (uint64_t)v98, a5);
      v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
      v64 = v62;
      v42 = v98;
      v40(v64, a5);
      if (v63 >= v111)
        goto LABEL_23;
    }
LABEL_43:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v42 = v98;
  v43 = v38(a5, a7);
  if (v43 < 64)
  {
    v46 = v101;
    v37(v101, (uint64_t)v42, a5);
    v47 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
    v40(v46, a5);
    v48 = v108;
    if (v47 < v111)
      goto LABEL_43;
    goto LABEL_23;
  }
  v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
  v60 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
  v61 = v101;
  v59(&v111, &type metadata for Int, v60, a5, a7);
  v57 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v98, v61, a5);
  v58 = v61;
  v42 = v98;
LABEL_13:
  v40(v58, a5);
  v48 = v108;
  if ((v57 & 1) != 0)
    goto LABEL_43;
LABEL_23:
  v40(v42, a5);
LABEL_24:
  v75 = v38(a5, a7);
  v37(v26, (uint64_t)v36, a5);
  if (v75 < 65)
  {
    v83 = v38(a5, a7);
    v40(v26, a5);
    if (v83 != 64 || (v109(a5, a7) & 1) != 0)
      goto LABEL_37;
  }
  else
  {
    v40(v26, a5);
  }
  v37(v48, (uint64_t)v36, a5);
  v111 = 0x7FFFFFFFFFFFFFFFLL;
  v76 = v109(a5, a7);
  v77 = v38(a5, a7);
  if ((v76 & 1) != 0)
  {
    if (v77 > 64)
    {
      v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
      v81 = lazy protocol witness table accessor for type Int and conformance Int(v77, v78, v79);
      v82 = &v111;
      goto LABEL_35;
    }
  }
  else if (v77 > 63)
  {
    v110 = 0x7FFFFFFFFFFFFFFFLL;
    v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a7 + 96);
    v81 = lazy protocol witness table accessor for type Int and conformance Int(v77, v78, v79);
    v82 = &v110;
LABEL_35:
    v85 = v101;
    v80(v82, &type metadata for Int, v81, a5, a7);
    v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a7 + 32) + 8) + 16))(v85, v48, a5);
    v40(v85, a5);
    if ((v86 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_36;
  }
  v84 = v101;
  v37(v101, (uint64_t)v48, a5);
  (*(void (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v40(v84, a5);
LABEL_36:
  v40(v48, a5);
LABEL_37:
  v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a7 + 120))(a5, a7);
  v40(v36, a5);
  v88 = v106;
  v89 = v102;
  v90 = v107;
  (*((void (**)(uint64_t, uint64_t, uint64_t, uint64_t))v105 + 18))(v107, v87, v106, v103);
  v91 = v104;
  v92 = *(_QWORD *)(v104 - 8);
  (*(void (**)(uint64_t, unint64_t))(v92 + 8))(v90, v104);
  v93 = (*(uint64_t (**)(char *, uint64_t, unint64_t))(v92 + 48))(v89, 1, v91);
  if (v93 == 1)
  {
    (*(void (**)(char *, uint64_t))(v99 + 8))(v89, v100);
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v92 + 16))(v90, v88, v91);
  }
  else
  {
    (*(void (**)(uint64_t, char *, unint64_t))(v92 + 32))(v90, v89, v91);
  }
  return v93 != 1;
}

uint64_t Collection.distance<A>(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t (*v8)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v13;

  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 152))(a1, a2, a3, a5);
  v8 = *(uint64_t (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a6 + 88);
  v11 = lazy protocol witness table accessor for type Int and conformance Int(v13, v9, v10);
  return v8(&v13, &type metadata for Int, v11, a4, a6);
}

Swift::UnsafeMutableRawPointer __swiftcall UnsafeMutablePointer.deinitialize()()
{
  uint64_t v0;
  uint64_t v1;
  Swift::UnsafeMutableRawPointer v2;

  v2._rawValue = (Builtin::RawPointer)v0;
  swift_arrayDestroy(v0, 1, v1);
  return v2;
}

Swift::Void __swiftcall UnsafeMutablePointer.deallocate(capacity:)(Swift::Int capacity)
{
  void *v1;

  swift_slowDealloc(v1);
}

uint64_t UnsafeMutablePointer.initialize<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t AssociatedConformanceWitness;
  int v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v27 = a2;
  v9 = type metadata accessor for Optional(0, a3, a3, a4);
  v28 = *(_QWORD *)(v9 - 8);
  v29 = v9;
  v10 = MEMORY[0x1E0C80A78](v9);
  v12 = (char *)&v26 - v11;
  v13 = *(_QWORD *)(a4 - 8);
  MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = *(_QWORD *)(a5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v16, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v26 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v19 = (char *)&v26 - v18;
  v20 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 112))(a4, a5);
  if (v20 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  v21 = v20;
  (*(void (**)(char *, uint64_t, uint64_t))(v13 + 16))(v15, a1, a4);
  v22 = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v16 + 64))(v19, v27, v21, a4, v16);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v16, a4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v24 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 48))(v12, 1, a3);
  (*(void (**)(char *, uint64_t))(v28 + 8))(v12, v29);
  if (v24 != 1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "rhs underreported its count", 27, 2, "Swift/MigrationSupport.swift", 28, 2, 0x17BuLL, 0);
  if (v22 != v21)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "rhs overreported its count", 26, 2, "Swift/MigrationSupport.swift", 28, 2, 0x17CuLL, 0);
  return (*(uint64_t (**)(char *, unint64_t))(v26 + 8))(v19, AssociatedTypeWitness);
}

uint64_t UnsafeRawPointer.summary.getter(Swift::UInt64 a1)
{
  unint64_t v1;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  Swift::String v13;
  unint64_t countAndFlagsBits;
  unint64_t object;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  uint64_t v27;
  unint64_t v28;

  v1 = 0xD000000000000013;
  if (!a1)
    return 0xD000000000000015;
  v3 = specialized static String._createEmpty(withInitialCapacity:)(22);
  v5 = v4;
  v27 = v3;
  v28 = v4;
  v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0)
    v6 = v3 & 0xFFFFFFFFFFFFLL;
  if (!v6 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v4);
    v10 = 0x8000000181766E20;
    goto LABEL_16;
  }
  if ((v4 & 0x2000000000000000) != 0
    && ((unint64_t)"UnsafeMutableRawPointer(nil)" & 0x2000000000000000) != 0)
  {
    v7 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD000000000000013, 0x8000000181766E20);
    if ((v9 & 1) == 0)
    {
      v1 = v7;
      v10 = v8;
      swift_bridgeObjectRelease(v5);
LABEL_16:
      v27 = v1;
      v28 = v10;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"UnsafeMutableRawPointer(nil)" & 0x2000000000000000) != 0)
    v11 = (0x8000000181766E20 >> 56) & 0xF;
  else
    v11 = 19;
  _StringGuts.append(_:)(0xD000000000000013, 0x8000000181766E20, 0, v11);
  v1 = v27;
  v10 = v28;
LABEL_17:
  v13 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  countAndFlagsBits = v13._countAndFlagsBits;
  object = (unint64_t)v13._object;
  v16 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000) == 0)
    v16 = v1 & 0xFFFFFFFFFFFFLL;
  if (!v16 && (v1 & ~v10 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v10);
    v27 = v13._countAndFlagsBits;
    goto LABEL_30;
  }
  if ((v10 & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v13._object & 0x2000000000000000) != 0)
      goto LABEL_28;
LABEL_25:
    v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
    swift_bridgeObjectRelease((uint64_t)v13._object);
    countAndFlagsBits = v27;
    object = v28;
    goto LABEL_30;
  }
  if (((uint64_t)v13._object & 0x2000000000000000) == 0)
    goto LABEL_25;
  v18 = specialized _SmallString.init(_:appending:)(v1, v10, v13._countAndFlagsBits, (unint64_t)v13._object);
  if ((v20 & 1) != 0)
  {
LABEL_28:
    v17 = ((unint64_t)v13._object >> 56) & 0xF;
    goto LABEL_29;
  }
  v21 = v18;
  v22 = v19;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease((uint64_t)v13._object);
  v27 = v21;
  object = v22;
  countAndFlagsBits = v21;
LABEL_30:
  v23 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0)
    v23 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v23 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (v24 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x29uLL, 0xE100000000000000),
          (v25 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      return v27;
    }
    else
    {
      v12 = v24;
      swift_bridgeObjectRelease(object);
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    return 41;
  }
  return v12;
}

uint64_t UnsafeRawPointer.customPlaygroundQuickLook.getter@<X0>(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  uint64_t v4;

  result = UnsafeRawPointer.summary.getter(a1);
  *(_QWORD *)a2 = result;
  *(_QWORD *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer(UnsafeRawPointer.summary.getter, a1);
}

uint64_t UnsafeMutableRawPointer.summary.getter(Swift::UInt64 a1)
{
  unint64_t v1;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  Swift::String v13;
  unint64_t countAndFlagsBits;
  unint64_t object;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  uint64_t v27;
  unint64_t v28;

  v1 = 0xD00000000000001ALL;
  if (!a1)
    return 0xD00000000000001CLL;
  v3 = specialized static String._createEmpty(withInitialCapacity:)(29);
  v5 = v4;
  v27 = v3;
  v28 = v4;
  v6 = HIBYTE(v4) & 0xF;
  if ((v4 & 0x2000000000000000) == 0)
    v6 = v3 & 0xFFFFFFFFFFFFLL;
  if (!v6 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v4);
    v10 = 0x8000000181766DE0;
    goto LABEL_16;
  }
  if ((v4 & 0x2000000000000000) != 0 && ((unint64_t)"UnsafePointer(nil)" & 0x2000000000000000) != 0)
  {
    v7 = specialized _SmallString.init(_:appending:)(v3, v4, 0xD00000000000001ALL, 0x8000000181766DE0);
    if ((v9 & 1) == 0)
    {
      v1 = v7;
      v10 = v8;
      swift_bridgeObjectRelease(v5);
LABEL_16:
      v27 = v1;
      v28 = v10;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"UnsafePointer(nil)" & 0x2000000000000000) != 0)
    v11 = (0x8000000181766DE0 >> 56) & 0xF;
  else
    v11 = 26;
  _StringGuts.append(_:)(0xD00000000000001ALL, 0x8000000181766DE0, 0, v11);
  v1 = v27;
  v10 = v28;
LABEL_17:
  v13 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  countAndFlagsBits = v13._countAndFlagsBits;
  object = (unint64_t)v13._object;
  v16 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000) == 0)
    v16 = v1 & 0xFFFFFFFFFFFFLL;
  if (!v16 && (v1 & ~v10 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v10);
    v27 = v13._countAndFlagsBits;
    goto LABEL_30;
  }
  if ((v10 & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v13._object & 0x2000000000000000) != 0)
      goto LABEL_28;
LABEL_25:
    v17 = v13._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v13._countAndFlagsBits, (unint64_t)v13._object, 0, v17);
    swift_bridgeObjectRelease((uint64_t)v13._object);
    countAndFlagsBits = v27;
    object = v28;
    goto LABEL_30;
  }
  if (((uint64_t)v13._object & 0x2000000000000000) == 0)
    goto LABEL_25;
  v18 = specialized _SmallString.init(_:appending:)(v1, v10, v13._countAndFlagsBits, (unint64_t)v13._object);
  if ((v20 & 1) != 0)
  {
LABEL_28:
    v17 = ((unint64_t)v13._object >> 56) & 0xF;
    goto LABEL_29;
  }
  v21 = v18;
  v22 = v19;
  swift_bridgeObjectRelease(v10);
  swift_bridgeObjectRelease((uint64_t)v13._object);
  v27 = v21;
  object = v22;
  countAndFlagsBits = v21;
LABEL_30:
  v23 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0)
    v23 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v23 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (v24 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x29uLL, 0xE100000000000000),
          (v25 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      return v27;
    }
    else
    {
      v12 = v24;
      swift_bridgeObjectRelease(object);
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    return 41;
  }
  return v12;
}

uint64_t UnsafeMutableRawPointer.customPlaygroundQuickLook.getter@<X0>(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result;
  uint64_t v4;

  result = UnsafeMutableRawPointer.summary.getter(a1);
  *(_QWORD *)a2 = result;
  *(_QWORD *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeMutableRawPointer@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer(UnsafeMutableRawPointer.summary.getter, a1);
}

uint64_t protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeRawPointer@<X0>(uint64_t (*a1)(_QWORD)@<X2>, uint64_t a2@<X8>)
{
  _QWORD *v2;
  uint64_t result;
  uint64_t v5;

  result = a1(*v2);
  *(_QWORD *)a2 = result;
  *(_QWORD *)(a2 + 8) = v5;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

void UnsafePointer.customPlaygroundQuickLook.getter(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t countAndFlagsBits;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  unint64_t object;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  Swift::String v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  void *v22;
  char v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char v29;
  Swift::String v30;

  countAndFlagsBits = 0xD000000000000010;
  if (!a1)
  {
    v14 = 0xD000000000000012;
    v15 = 0x8000000181766DC0;
    goto LABEL_38;
  }
  v5 = specialized static String._createEmpty(withInitialCapacity:)(19);
  v7 = v6;
  v30._countAndFlagsBits = v5;
  v30._object = (void *)v6;
  v8 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000) == 0)
    v8 = v5 & 0xFFFFFFFFFFFFLL;
  if (!v8 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    object = 0x8000000181766DA0;
    goto LABEL_16;
  }
  if ((v6 & 0x2000000000000000) != 0 && ((unint64_t)"UnsafeMutablePointer(nil)" & 0x2000000000000000) != 0)
  {
    v9 = specialized _SmallString.init(_:appending:)(v5, v6, 0xD000000000000010, 0x8000000181766DA0);
    if ((v11 & 1) == 0)
    {
      countAndFlagsBits = v9;
      object = v10;
      swift_bridgeObjectRelease(v7);
LABEL_16:
      v30._countAndFlagsBits = countAndFlagsBits;
      v30._object = (void *)object;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"UnsafeMutablePointer(nil)" & 0x2000000000000000) != 0)
    v13 = (0x8000000181766DA0 >> 56) & 0xF;
  else
    v13 = 16;
  _StringGuts.append(_:)(0xD000000000000010, 0x8000000181766DA0, 0, v13);
  object = (unint64_t)v30._object;
  countAndFlagsBits = v30._countAndFlagsBits;
LABEL_17:
  v16 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  v17 = v16._countAndFlagsBits;
  v18 = (unint64_t)v16._object;
  v19 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0)
    v19 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v19 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(object);
    v30 = v16;
    goto LABEL_30;
  }
  if ((object & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v16._object & 0x2000000000000000) != 0)
      goto LABEL_28;
LABEL_25:
    v20 = v16._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v16._countAndFlagsBits, (unint64_t)v16._object, 0, v20);
    swift_bridgeObjectRelease((uint64_t)v16._object);
    v18 = (unint64_t)v30._object;
    v17 = v30._countAndFlagsBits;
    goto LABEL_30;
  }
  if (((uint64_t)v16._object & 0x2000000000000000) == 0)
    goto LABEL_25;
  v21 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v16._countAndFlagsBits, (unint64_t)v16._object);
  if ((v23 & 1) != 0)
  {
LABEL_28:
    v20 = ((unint64_t)v16._object >> 56) & 0xF;
    goto LABEL_29;
  }
  v24 = v21;
  v25 = v22;
  swift_bridgeObjectRelease((uint64_t)v16._object);
  swift_bridgeObjectRelease(object);
  v30._countAndFlagsBits = v24;
  v30._object = v25;
  v18 = (unint64_t)v25;
  v17 = v24;
LABEL_30:
  v26 = HIBYTE(v18) & 0xF;
  if ((v18 & 0x2000000000000000) == 0)
    v26 = v17 & 0xFFFFFFFFFFFFLL;
  if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
  {
    if ((v18 & 0x2000000000000000) == 0
      || (v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0x29uLL, 0xE100000000000000), (v29 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      v15 = (unint64_t)v30._object;
      v14 = v30._countAndFlagsBits;
    }
    else
    {
      v14 = v27;
      v15 = v28;
      swift_bridgeObjectRelease(v18);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v18);
    v15 = 0xE100000000000000;
    v14 = 41;
  }
LABEL_38:
  *(_QWORD *)a2 = v14;
  *(_QWORD *)(a2 + 8) = v15;
  *(_BYTE *)(a2 + 32) = 0;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafePointer<A>(uint64_t a1@<X8>)
{
  Swift::UInt64 *v1;

  UnsafePointer.customPlaygroundQuickLook.getter(*v1, a1);
}

void UnsafeMutablePointer.customPlaygroundQuickLook.getter(Swift::UInt64 a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t countAndFlagsBits;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char v11;
  unint64_t object;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  Swift::String v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  void *v22;
  char v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char v29;
  Swift::String v30;

  countAndFlagsBits = 0xD000000000000017;
  if (!a1)
  {
    v14 = 0xD000000000000019;
    v15 = 0x8000000181766D80;
    goto LABEL_38;
  }
  v5 = specialized static String._createEmpty(withInitialCapacity:)(26);
  v7 = v6;
  v30._countAndFlagsBits = v5;
  v30._object = (void *)v6;
  v8 = HIBYTE(v6) & 0xF;
  if ((v6 & 0x2000000000000000) == 0)
    v8 = v5 & 0xFFFFFFFFFFFFLL;
  if (!v8 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    object = 0x8000000181766D60;
    goto LABEL_16;
  }
  if ((v6 & 0x2000000000000000) != 0 && ((unint64_t)"Swift/Diffing.swift" & 0x2000000000000000) != 0)
  {
    v9 = specialized _SmallString.init(_:appending:)(v5, v6, 0xD000000000000017, 0x8000000181766D60);
    if ((v11 & 1) == 0)
    {
      countAndFlagsBits = v9;
      object = v10;
      swift_bridgeObjectRelease(v7);
LABEL_16:
      v30._countAndFlagsBits = countAndFlagsBits;
      v30._object = (void *)object;
      goto LABEL_17;
    }
  }
  if (((unint64_t)"Swift/Diffing.swift" & 0x2000000000000000) != 0)
    v13 = (0x8000000181766D60 >> 56) & 0xF;
  else
    v13 = 23;
  _StringGuts.append(_:)(0xD000000000000017, 0x8000000181766D60, 0, v13);
  object = (unint64_t)v30._object;
  countAndFlagsBits = v30._countAndFlagsBits;
LABEL_17:
  v16 = _uint64ToString(_:radix:uppercase:)(a1, 16, 1);
  v17 = v16._countAndFlagsBits;
  v18 = (unint64_t)v16._object;
  v19 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0)
    v19 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v19 && (countAndFlagsBits & ~object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(object);
    v30 = v16;
    goto LABEL_30;
  }
  if ((object & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v16._object & 0x2000000000000000) != 0)
      goto LABEL_28;
LABEL_25:
    v20 = v16._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_29:
    _StringGuts.append(_:)(v16._countAndFlagsBits, (unint64_t)v16._object, 0, v20);
    swift_bridgeObjectRelease((uint64_t)v16._object);
    v18 = (unint64_t)v30._object;
    v17 = v30._countAndFlagsBits;
    goto LABEL_30;
  }
  if (((uint64_t)v16._object & 0x2000000000000000) == 0)
    goto LABEL_25;
  v21 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, v16._countAndFlagsBits, (unint64_t)v16._object);
  if ((v23 & 1) != 0)
  {
LABEL_28:
    v20 = ((unint64_t)v16._object >> 56) & 0xF;
    goto LABEL_29;
  }
  v24 = v21;
  v25 = v22;
  swift_bridgeObjectRelease((uint64_t)v16._object);
  swift_bridgeObjectRelease(object);
  v30._countAndFlagsBits = v24;
  v30._object = v25;
  v18 = (unint64_t)v25;
  v17 = v24;
LABEL_30:
  v26 = HIBYTE(v18) & 0xF;
  if ((v18 & 0x2000000000000000) == 0)
    v26 = v17 & 0xFFFFFFFFFFFFLL;
  if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
  {
    if ((v18 & 0x2000000000000000) == 0
      || (v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0x29uLL, 0xE100000000000000), (v29 & 1) != 0))
    {
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      v15 = (unint64_t)v30._object;
      v14 = v30._countAndFlagsBits;
    }
    else
    {
      v14 = v27;
      v15 = v28;
      swift_bridgeObjectRelease(v18);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v18);
    v15 = 0xE100000000000000;
    v14 = 41;
  }
LABEL_38:
  *(_QWORD *)a2 = v14;
  *(_QWORD *)(a2 + 8) = v15;
  *(_BYTE *)(a2 + 32) = 0;
}

void protocol witness for _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter in conformance UnsafeMutablePointer<A>(uint64_t a1@<X8>)
{
  Swift::UInt64 *v1;

  UnsafeMutablePointer.customPlaygroundQuickLook.getter(*v1, a1);
}

void *static UnsafeMutableRawPointer.allocate(bytes:alignedTo:)(size_t a1, uint64_t a2)
{
  unint64_t v2;

  if (a2 <= 16)
    v2 = -1;
  else
    v2 = a2 - 1;
  return swift_slowAlloc(a1, v2);
}

Swift::Void __swiftcall UnsafeMutableRawPointer.deallocate(bytes:alignedTo:)(Swift::Int bytes, Swift::Int alignedTo)
{
  void *v2;

  swift_slowDealloc(v2);
}

Swift::Void __swiftcall UnsafeMutableRawPointer.copyBytes(from:count:)(Swift::UnsafeRawPointer from, Swift::Int count)
{
  void *v2;

  if (count < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
  memmove(v2, from._rawValue, count);
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:at:count:to:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;

  v6 = *(_QWORD *)(*(_QWORD *)(a6 - 8) + 72);
  if ((unsigned __int128)(a2 * (__int128)v6) >> 64 == (a2 * v6) >> 63)
    return UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)(result, a4, a3, a5 + a2 * v6, a6);
  __break(1u);
  return result;
}

uint64_t UnsafeMutableRawPointer.initializeMemory<A>(as:from:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  unint64_t AssociatedConformanceWitness;
  void (*v24)(unint64_t, unint64_t);
  unsigned int (*v25)(char *, uint64_t, unint64_t);
  void (*v26)(char *, char *, unint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;

  v31 = a3;
  v33 = a2;
  v6 = *(_QWORD *)(a5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v10 = (char *)&v30 - v9;
  v13 = type metadata accessor for Optional(0, AssociatedTypeWitness, v11, v12);
  v14 = MEMORY[0x1E0C80A78](v13);
  v16 = (char *)&v30 - v15;
  v17 = *(_QWORD *)(a4 - 8);
  MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v30 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v20 = swift_getAssociatedTypeWitness(0, (const char *)v6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v30 = *(_QWORD *)(v20 - 8);
  MEMORY[0x1E0C80A78](v20);
  v22 = (char *)&v30 - v21;
  (*(void (**)(char *, char *, uint64_t))(v17 + 16))(v19, v33, a4);
  (*(void (**)(uint64_t, uint64_t))(v6 + 32))(a4, v6);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a4, v20, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v24 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v32 = v20;
  v33 = v22;
  v24(v20, AssociatedConformanceWitness);
  v25 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v8 + 48);
  if (v25(v16, 1, AssociatedTypeWitness) != 1)
  {
    v26 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
    v27 = v31;
    do
    {
      v26(v10, v16, AssociatedTypeWitness);
      (*(void (**)(uint64_t, char *, unint64_t))(v8 + 16))(v27, v10, AssociatedTypeWitness);
      v28 = *(_QWORD *)(v8 + 72);
      (*(void (**)(char *, unint64_t))(v8 + 8))(v10, AssociatedTypeWitness);
      v27 += v28;
      v24(v32, AssociatedConformanceWitness);
    }
    while (v25(v16, 1, AssociatedTypeWitness) != 1);
  }
  (*(void (**)(char *, unint64_t))(v30 + 8))(v33, v32);
  return v31;
}

void *static UnsafeMutableRawBufferPointer.allocate(count:)(size_t a1)
{
  void *result;

  result = swift_slowAlloc(a1, 0xFFFFFFFFFFFFFFFFLL);
  if ((a1 & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  return result;
}

void *static UnsafeMutableRawBufferPointer.allocate(byteCount:alignment:)(size_t a1, uint64_t a2)
{
  unint64_t v3;
  void *result;

  if (a2 <= 16)
    v3 = -1;
  else
    v3 = a2 - 1;
  result = swift_slowAlloc(a1, v3);
  if ((a1 & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  return result;
}

Swift::Void __swiftcall UnsafeMutableRawBufferPointer.copyMemory(from:)(Swift::UnsafeRawBufferPointer from)
{
  void *v1;
  uint64_t v2;
  int64_t v3;

  if (from._position.value._rawValue)
    v3 = (char *)from._end.value._rawValue - (char *)from._position.value._rawValue;
  else
    v3 = 0;
  if (!v1)
  {
    if (v3 < 1)
      return;
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.copyMemory source has too many elements", 69, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1E7uLL, 0);
  }
  if (v2 - (uint64_t)v1 < v3)
    goto LABEL_10;
  if (from._position.value._rawValue)
    memmove(v1, from._position.value._rawValue, (char *)from._end.value._rawValue - (char *)from._position.value._rawValue);
}

void Sequence.flatMap<A>(_:)(void (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t *a4, const char *a5)
{
  Sequence.compactMap<A>(_:)(a1, a2, a3, a4, a5);
}

__objc2_class **Collection.flatMap(_:)(uint64_t (*a1)(char *), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t AssociatedConformanceWitness;
  void (*v21)(unint64_t, unint64_t);
  uint64_t v22;
  unsigned int (*v23)(char *, uint64_t, unint64_t);
  __objc2_class **v24;
  unint64_t v25;
  void (*v26)(unint64_t, unint64_t);
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  __objc2_class *v32;
  uint64_t v33;
  __objc2_class *v34;
  unint64_t v35;
  unint64_t v36;
  __objc2_class *v37;
  __objc2_class **v38;
  __objc2_class **v39;
  __objc2_class *v41;
  uint64_t v42;
  unsigned int (*v43)(char *, uint64_t, unint64_t);
  void (*v44)(char *, char *, unint64_t);
  char *v45;
  uint64_t (*v46)(char *);
  uint64_t v47;
  char *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v46 = a1;
  v47 = a2;
  v5 = *(_QWORD *)(a4 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v50 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v45 = (char *)&v41 - v7;
  v10 = type metadata accessor for Optional(0, AssociatedTypeWitness, v8, v9);
  v11 = MEMORY[0x1E0C80A78](v10);
  v13 = (char *)&v41 - v12;
  v14 = *(_QWORD *)(a3 - 8);
  MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v41 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = swift_getAssociatedTypeWitness(0, (const char *)v5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v42 = *(_QWORD *)(v17 - 8);
  MEMORY[0x1E0C80A78](v17);
  v19 = (char *)&v41 - v18;
  (*(void (**)(char *, unint64_t, uint64_t))(v14 + 16))(v16, v49, a3);
  (*(void (**)(uint64_t, uint64_t))(v5 + 32))(a3, v5);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a3, v17, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v21 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v48 = v19;
  v49 = v17;
  v21(v17, AssociatedConformanceWitness);
  v22 = v50;
  v23 = *(unsigned int (**)(char *, uint64_t, unint64_t))(v50 + 48);
  if (v23(v13, 1, AssociatedTypeWitness) == 1)
  {
    v24 = &_swiftEmptyArrayStorage;
LABEL_3:
    (*(void (**)(char *, unint64_t))(v42 + 8))(v48, v49);
  }
  else
  {
    v44 = *(void (**)(char *, char *, unint64_t))(v22 + 32);
    v24 = &_swiftEmptyArrayStorage;
    v43 = v23;
    while (1)
    {
      v26 = v21;
      v27 = (uint64_t)v24;
      v28 = AssociatedConformanceWitness;
      v29 = v45;
      v44(v45, v13, AssociatedTypeWitness);
      v30 = v51;
      v31 = v46(v29);
      if (v30)
        break;
      v33 = v31;
      v34 = v32;
      (*(void (**)(char *, unint64_t))(v50 + 8))(v29, AssociatedTypeWitness);
      v51 = 0;
      if (v34)
      {
        v24 = (__objc2_class **)v27;
        if (!swift_isUniquelyReferenced_nonNull_native(v27))
          v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, *(_QWORD *)(v27 + 16) + 1, 1, v27);
        v36 = (unint64_t)v24[2];
        v35 = (unint64_t)v24[3];
        v37 = (__objc2_class *)(v36 + 1);
        if (v36 >= v35 >> 1)
        {
          v41 = (__objc2_class *)(v36 + 1);
          v39 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v35 > 1), v36 + 1, 1, (uint64_t)v24);
          v37 = v41;
          v24 = v39;
        }
        v24[2] = v37;
        v38 = &v24[2 * v36];
        v38[4] = (__objc2_class *)v33;
        v38[5] = v34;
      }
      else
      {
        v24 = (__objc2_class **)v27;
      }
      AssociatedConformanceWitness = v28;
      v25 = v28;
      v21 = v26;
      v26(v49, v25);
      if (v43(v13, 1, AssociatedTypeWitness) == 1)
        goto LABEL_3;
    }
    (*(void (**)(char *, unint64_t))(v50 + 8))(v29, AssociatedTypeWitness);
    (*(void (**)(char *, unint64_t))(v42 + 8))(v48, v49);
    v24 = (__objc2_class **)v27;
    swift_bridgeObjectRelease(v27);
  }
  return v24;
}

uint64_t Collection.index(where:)@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return Collection.firstIndex(where:)(a1, a2, a3, a4, a5);
}

uint64_t _PlaygroundQuickLook.init(reflecting:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  Class *v4;
  Class *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  id v9;
  uint64_t v10;
  char *v11;
  void *v12;
  char *v13;
  unsigned __int8 v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  unsigned __int8 v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char v27;
  char *v28;
  unsigned __int8 v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  unsigned __int8 v34;
  Swift::String v35;
  uint64_t v36;
  char *v37;
  char *v38;
  unsigned __int8 v39;
  Swift::String v40;
  uint64_t v41;
  char *v42;
  char *v43;
  unsigned __int8 v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  unsigned __int8 v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  unsigned __int8 v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  int v58;
  int v59;
  id v60;
  id v61;
  uint64_t v62;
  char *v63;
  unsigned __int8 v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  unsigned __int8 v69;
  Swift::String v70;
  uint64_t v71;
  char *v72;
  char *v73;
  unsigned __int8 v74;
  Swift::String v75;
  uint64_t v76;
  char *v77;
  char *v78;
  unsigned __int8 v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  char *v83;
  unsigned __int8 v84;
  __int128 v85;
  __int128 v86;
  uint64_t v87;
  uint64_t v88[4];
  __int128 v89;
  __int128 v90;
  uint64_t v91;

  outlined init with copy of Any((uint64_t)a1, (uint64_t)v88);
  v4 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _CustomPlaygroundQuickLookable);
  if ((swift_dynamicCast((char *)&v85, v88, qword_1E0EB1338, v4, 6uLL) & 1) != 0
    || (v87 = 0,
        v85 = 0u,
        v86 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v85, &demangling cache variable for type metadata for _CustomPlaygroundQuickLookable?), outlined init with copy of Any((uint64_t)a1, (uint64_t)v88), v5 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for __DefaultCustomPlaygroundQuickLookable), (swift_dynamicCast((char *)&v85, v88, qword_1E0EB1338, v5, 6uLL) & 1) != 0))
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    outlined init with take of MirrorPath(&v85, (uint64_t)&v89);
    v6 = *((_QWORD *)&v90 + 1);
    v7 = v91;
    __swift_project_boxed_opaque_existential_0Tm(&v89, *((uint64_t *)&v90 + 1));
    (*(void (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v89);
  }
  v87 = 0;
  v85 = 0u;
  v86 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v85, &demangling cache variable for type metadata for __DefaultCustomPlaygroundQuickLookable?);
  v9 = swift_reflectionMirror_quickLookObject((swift::SwiftError **)a1, (void **)qword_1E0EB1338);
  if (!v9)
  {
    v89 = 0u;
    v90 = 0u;
    LOBYTE(v91) = -1;
    goto LABEL_29;
  }
  v12 = v9;
  swift_unknownObjectRetain_n((uint64_t)v9, 2, v10, v11);
  v14 = specialized String.withCString<A>(_:)(0x7265626D754E534EuLL, 0xE800000000000000, v12, v13);
  swift_bridgeObjectRelease(0xE800000000000000);
  swift_unknownObjectRelease(v12);
  swift_unknownObjectRetain(v12, v15, v16, v17);
  if ((v14 & 1) == 0)
  {
    v23 = specialized String.withCString<A>(_:)(0xD000000000000012, 0x8000000181763AA0 | 0x8000000000000000, v12, v18);
    swift_bridgeObjectRelease(0x8000000181763AA0 | 0x8000000000000000);
    swift_unknownObjectRelease(v12);
    if ((v23 & 1) != 0)
    {
      *((_QWORD *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
      *(_QWORD *)&v89 = v12;
      v27 = 9;
    }
    else
    {
      swift_unknownObjectRetain(v12, v24, v25, v26);
      v29 = specialized String.withCString<A>(_:)(0x6567616D49534EuLL, 0xE700000000000000, v12, v28);
      swift_bridgeObjectRelease(0xE700000000000000);
      swift_unknownObjectRelease(v12);
      if ((v29 & 1) != 0)
        goto LABEL_20;
      swift_unknownObjectRetain(v12, v30, v31, v32);
      v34 = specialized String.withCString<A>(_:)(0x6567616D494955uLL, 0xE700000000000000, v12, v33);
      swift_bridgeObjectRelease(0xE700000000000000);
      swift_unknownObjectRelease(v12);
      if ((v34 & 1) != 0)
        goto LABEL_20;
      v35 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NSImageView", 0xBuLL, 1);
      swift_unknownObjectRetain(v12, (uint64_t)v35._object, v36, v37);
      v39 = specialized String.withCString<A>(_:)(v35._countAndFlagsBits, (unint64_t)v35._object, v12, v38);
      swift_bridgeObjectRelease((uint64_t)v35._object);
      swift_unknownObjectRelease(v12);
      if ((v39 & 1) != 0)
        goto LABEL_20;
      v40 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UIImageView", 0xBuLL, 1);
      swift_unknownObjectRetain(v12, (uint64_t)v40._object, v41, v42);
      v44 = specialized String.withCString<A>(_:)(v40._countAndFlagsBits, (unint64_t)v40._object, v12, v43);
      swift_bridgeObjectRelease((uint64_t)v40._object);
      swift_unknownObjectRelease(v12);
      if ((v44 & 1) != 0)
        goto LABEL_20;
      swift_unknownObjectRetain(v12, v45, v46, v47);
      v49 = specialized String.withCString<A>(_:)(0x6567616D494943uLL, 0xE700000000000000, v12, v48);
      swift_bridgeObjectRelease(0xE700000000000000);
      swift_unknownObjectRelease(v12);
      if ((v49 & 1) != 0
        || (swift_unknownObjectRetain(v12, v50, v51, v52),
            v54 = specialized String.withCString<A>(_:)(0xD000000000000010, 0x8000000181763AD0 | 0x8000000000000000, v12, v53), swift_bridgeObjectRelease(0x8000000181763AD0 | 0x8000000000000000), swift_unknownObjectRelease(v12), (v54 & 1) != 0))
      {
LABEL_20:
        *((_QWORD *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
        *(_QWORD *)&v89 = v12;
        v27 = 5;
      }
      else
      {
        swift_unknownObjectRetain(v12, v55, v56, v57);
        v64 = specialized String.withCString<A>(_:)(0x726F6C6F43534EuLL, 0xE700000000000000, v12, v63);
        swift_bridgeObjectRelease(0xE700000000000000);
        swift_unknownObjectRelease(v12);
        if ((v64 & 1) != 0
          || (swift_unknownObjectRetain(v12, v65, v66, v67),
              v69 = specialized String.withCString<A>(_:)(0x726F6C6F434955uLL, 0xE700000000000000, v12, v68), swift_bridgeObjectRelease(0xE700000000000000), swift_unknownObjectRelease(v12), (v69 & 1) != 0))
        {
          *((_QWORD *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
          *(_QWORD *)&v89 = v12;
          v27 = 7;
        }
        else
        {
          v70 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NSBezierPath", 0xCuLL, 1);
          swift_unknownObjectRetain(v12, (uint64_t)v70._object, v71, v72);
          v74 = specialized String.withCString<A>(_:)(v70._countAndFlagsBits, (unint64_t)v70._object, v12, v73);
          swift_bridgeObjectRelease((uint64_t)v70._object);
          swift_unknownObjectRelease(v12);
          if ((v74 & 1) == 0)
          {
            v75 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UIBezierPath", 0xCuLL, 1);
            swift_unknownObjectRetain(v12, (uint64_t)v75._object, v76, v77);
            v79 = specialized String.withCString<A>(_:)(v75._countAndFlagsBits, (unint64_t)v75._object, v12, v78);
            swift_bridgeObjectRelease((uint64_t)v75._object);
            swift_unknownObjectRelease(v12);
            if ((v79 & 1) == 0)
            {
              swift_unknownObjectRetain(v12, v80, v81, v82);
              v84 = specialized String.withCString<A>(_:)(0x676E69727453534EuLL, 0xE800000000000000, v12, v83);
              swift_bridgeObjectRelease(0xE800000000000000);
              swift_unknownObjectRelease(v12);
              if ((v84 & 1) != 0)
              {
                v85 = 0uLL;
                _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)((swift *)v12, (uint64_t)&type metadata for String, (uint64_t *)&v85);
                if (!*((_QWORD *)&v85 + 1))
                  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0xFCuLL, 0);
                v89 = v85;
                LOBYTE(v91) = 0;
              }
              else
              {
                v89 = 0u;
                v90 = 0u;
                LOBYTE(v91) = -1;
              }
              swift_unknownObjectRelease(v12);
              goto LABEL_22;
            }
          }
          *((_QWORD *)&v90 + 1) = swift_getObjectType((unint64_t)v12);
          *(_QWORD *)&v89 = v12;
          v27 = 8;
        }
      }
    }
    LOBYTE(v91) = v27;
LABEL_22:
    swift_unknownObjectRelease(v12);
    goto LABEL_27;
  }
  v19 = *(unsigned __int8 *)objc_msgSend(v12, sel_objCType);
  if ((v19 & 0x80) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  switch(v19)
  {
    case 'Q':
      v60 = objc_msgSend(v12, sel_unsignedLongLongValue);
      swift_unknownObjectRelease(v12);
      *(_QWORD *)&v89 = v60;
      v22 = 2;
      break;
    case 'f':
      objc_msgSend(v12, sel_floatValue);
      v59 = v58;
      swift_unknownObjectRelease(v12);
      LODWORD(v89) = v59;
      v22 = 3;
      break;
    case 'd':
      objc_msgSend(v12, sel_doubleValue);
      v21 = v20;
      swift_unknownObjectRelease(v12);
      *(_QWORD *)&v89 = v21;
      v22 = 4;
      break;
    default:
      v61 = objc_msgSend(v12, sel_longLongValue);
      swift_unknownObjectRelease(v12);
      *(_QWORD *)&v89 = v61;
      v22 = 1;
      break;
  }
  LOBYTE(v91) = v22;
  swift_unknownObjectRelease_n((uint64_t)v12, 2);
LABEL_27:
  if (v91 != 255)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    return outlined init with take of _PlaygroundQuickLook(&v89, a2);
  }
LABEL_29:
  outlined destroy of _PlaygroundQuickLook?((uint64_t)&v89);
  *(_QWORD *)&v89 = 0;
  *((_QWORD *)&v89 + 1) = 0xE000000000000000;
  _debugPrint_unlocked<A, B>(_:_:)((uint64_t)a1, (uint64_t)&v89, qword_1E0EB1338, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
  result = __swift_destroy_boxed_opaque_existential_1Tm(a1);
  v62 = *((_QWORD *)&v89 + 1);
  *(_QWORD *)a2 = v89;
  *(_QWORD *)(a2 + 8) = v62;
  *(_BYTE *)(a2 + 32) = 0;
  return result;
}

uint64_t _availabilityNextMajorVersion.getter()
{
  return 14;
}

uint64_t static _SwiftStdlibVersion.current.getter()
{
  return 393216;
}

uint64_t _SwiftStdlibVersion.description.getter(unsigned int a1)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  unint64_t countAndFlagsBits;
  unint64_t object;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  unsigned __int8 *v19;
  unint64_t v20;
  unint64_t v21;
  Swift::String::Index v22;
  Swift::String::Index v23;
  Swift::String::Index v24;
  Swift::String::Index v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  char v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int64_t v46;
  char v47;
  uint64_t v49;
  uint64_t v50;
  char v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  size_t v55;
  uint64_t v56;
  char *v57;
  Swift::String v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  Swift::Int v69;
  int64_t v70;
  uint64_t v71;
  unint64_t v72;
  int64_t v73;
  char v74;
  char *v75;
  size_t v76;
  void *v77;
  unint64_t v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  Swift::String::Index v86;
  Swift::String::Index v87;
  Swift::String::Index v88;
  Swift::String::Index v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  void *v97;
  char v98;
  uint64_t v99;
  void *v100;
  uint64_t v101;
  char *v102;
  char v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  void *v115;
  id v116;
  uint64_t v117;
  char *v118;
  size_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  void *v128;
  BOOL v129;
  int64_t v130;
  unint64_t v131;
  int64_t v132;
  char v133;
  char *v134;
  size_t v135;
  uint64_t v136;
  unint64_t v137;
  void *v138;
  uint64_t v139;
  uint64_t v140;
  char *v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  Swift::String::Index v145;
  Swift::String::Index v146;
  Swift::String::Index v147;
  Swift::String::Index v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  void *v156;
  char v157;
  uint64_t v158;
  void *v159;
  uint64_t v160;
  char *v161;
  Swift::String v162;
  uint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  uint64_t v167;
  unint64_t v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  char *v172;
  Swift::Int v173;
  int64_t v174;
  uint64_t v175;
  unint64_t v176;
  int64_t v177;
  char v178;
  char *v179;
  size_t v180;
  void *v181;
  unint64_t v182;
  void *v183;
  uint64_t v184;
  uint64_t v185;
  char *v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  Swift::String::Index v190;
  Swift::String::Index v191;
  Swift::String::Index v192;
  Swift::String::Index v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  unint64_t v200;
  void *v201;
  char v202;
  uint64_t v203;
  void *v204;
  uint64_t v205;
  char *v206;
  char v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t v212;
  char v213;
  uint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  void *v219;
  id v220;
  uint64_t v221;
  char *v222;
  size_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  unint64_t v231;
  void *v232;
  int64_t v233;
  unint64_t v234;
  int64_t v235;
  char v236;
  char *v237;
  size_t v238;
  uint64_t v239;
  unint64_t v240;
  void *v241;
  uint64_t v242;
  uint64_t v243;
  char *v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  Swift::String::Index v248;
  Swift::String::Index v249;
  Swift::String::Index v250;
  Swift::String::Index v251;
  unint64_t v252;
  unint64_t v253;
  unint64_t v254;
  unint64_t v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  void *v259;
  char v260;
  uint64_t v261;
  void *v262;
  Swift::String v263;
  unint64_t v264;
  uint64_t v265;
  unint64_t v266;
  unint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  char *v271;
  void *v272;
  unint64_t v273;
  unint64_t v274;
  uint64_t v275;
  void *v276;
  unint64_t v278;
  char v279;
  unint64_t v280;
  unint64_t v281;
  unint64_t v282;
  unint64_t v283;
  unint64_t v284;
  char v285;
  uint64_t v286;
  unint64_t v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  void *v291;
  Swift::String::Index v292;
  Swift::String::Index v293;
  Swift::String::Index v294;
  Swift::String::Index v295;
  Swift::Int v296;
  Swift::String::Index v297;
  Swift::String::Index v298;
  Swift::String::Index v299;
  Swift::String::Index v300;
  Swift::Int v301;
  Swift::Int v302;
  Swift::Int v303;
  unint64_t v304;
  unint64_t v305;
  unsigned __int8 *v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  unint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unsigned int v313;
  __int128 v314;
  Swift::String v315;

  v3 = specialized static String._createEmpty(withInitialCapacity:)(8);
  countAndFlagsBits = v3;
  object = v4;
  v315._countAndFlagsBits = v3;
  v315._object = (void *)v4;
  v9 = HIBYTE(v4) & 0xF;
  v10 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v4 & 0x2000000000000000) != 0)
    v11 = HIBYTE(v4) & 0xF;
  else
    v11 = v3 & 0xFFFFFFFFFFFFLL;
  v313 = a1;
  if (!v11 && (v3 & ~v4 & 0x2000000000000000) == 0)
  {
    v315._countAndFlagsBits = 0;
    v315._object = (void *)0xE000000000000000;
    v44 = v4;
    goto LABEL_59;
  }
  if ((v4 & 0x2000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v4);
    swift_bridgeObjectRelease(0xE000000000000000);
    v45 = 0xA000000000000000;
    if (!(object & 0x80808080808080 | countAndFlagsBits & 0x8080808080808080))
      v45 = 0xE000000000000000;
    v315._countAndFlagsBits = countAndFlagsBits;
    v315._object = (void *)(v45 & 0xFF00000000000000 | (v9 << 56) | object & 0xFFFFFFFFFFFFFFLL);
    goto LABEL_60;
  }
  swift_bridgeObjectRetain_n(0xE000000000000000, 6, v5, v6);
  v12 = v10;
  if ((object & 0x1000000000000000) != 0)
  {
    v12 = String.UTF8View._foreignCount()();
    v13 = countAndFlagsBits & ~object;
    if ((v13 & 0x2000000000000000) == 0)
    {
LABEL_39:
      if (v12 <= 15)
        goto LABEL_13;
      goto LABEL_40;
    }
  }
  else
  {
    v13 = countAndFlagsBits & ~object;
    if ((v13 & 0x2000000000000000) == 0)
      goto LABEL_39;
  }
  if (!swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    goto LABEL_39;
  v14 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
  if ((v15 & 1) != 0)
    goto LABEL_284;
  if (v12 <= 15 && (v14 & 0x8000000000000000) != 0)
  {
LABEL_13:
    swift_bridgeObjectRelease_n(0xE000000000000000, 5);
    if ((object & 0x1000000000000000) == 0)
    {
      if ((countAndFlagsBits & 0x1000000000000000) != 0)
      {
        v19 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        v19 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(countAndFlagsBits, object);
        v10 = v16;
      }
      swift_bridgeObjectRetain(object, v16, v17, v18);
      closure #1 in _StringGuts._convertedToSmall()(v19, v10, &v314);
      swift_bridgeObjectRelease(object);
      v21 = *((_QWORD *)&v314 + 1);
      v20 = v314;
      goto LABEL_17;
    }
    goto LABEL_271;
  }
LABEL_40:
  v46 = _StringGuts.nativeUnusedCapacity.getter(countAndFlagsBits, object);
  v49 = (v47 & 1) == 0 && v46 >= 0;
  if ((v13 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
  {
    if ((v49 & 1) != 0)
      goto LABEL_58;
  }
  else if ((v49 & 1) != 0)
  {
LABEL_57:
    _StringGuts.grow(_:)(v12);
LABEL_58:
    swift_bridgeObjectRelease_n(0xE000000000000000, 6);
    v314 = 0uLL;
    v54 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v314, 0);
    _StringGuts.appendInPlace(_:isASCII:)(v54, v55, 1);
    v44 = 0xE000000000000000;
    goto LABEL_59;
  }
  v50 = _StringGuts.nativeCapacity.getter(countAndFlagsBits, object);
  if ((v51 & 1) != 0)
    v52 = 0;
  else
    v52 = v50;
  if (v52 + 0x4000000000000000 >= 0)
  {
    v53 = 2 * v52;
    if (v53 > v12)
      v12 = v53;
    goto LABEL_57;
  }
  __break(1u);
LABEL_279:
  v116 = _StringObject.sharedUTF8.getter(v49, countAndFlagsBits);
  v117 = v308;
  swift_bridgeObjectRelease(countAndFlagsBits);
  if (v117 < v1)
    goto LABEL_282;
LABEL_109:
  a1 = v313;
  v118 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v1, (uint64_t)v116, v117);
  _StringGuts.appendInPlace(_:isASCII:)(v118, v119, v49 < 0);
  swift_bridgeObjectRelease_n(countAndFlagsBits, 2);
  while (1)
  {
    countAndFlagsBits = v315._countAndFlagsBits;
    object = (unint64_t)v315._object;
    v120 = ((unint64_t)v315._object >> 56) & 0xF;
    if (((uint64_t)v315._object & 0x2000000000000000) != 0)
      v121 = ((unint64_t)v315._object >> 56) & 0xF;
    else
      v121 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v121 && (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000) == 0)
    {
      v315._countAndFlagsBits = 46;
      v315._object = (void *)0xE100000000000000;
      v136 = object;
      goto LABEL_138;
    }
    if (((uint64_t)v315._object & 0x2000000000000000) == 0 || v120 == 15)
    {
      swift_bridgeObjectRetain_n(0xE100000000000000, 6, v101, v102);
      if ((object & 0x1000000000000000) == 0)
      {
        v129 = __OFADD__(v121, 1);
        v130 = v121 + 1;
        if (v129)
          goto LABEL_267;
LABEL_125:
        if ((countAndFlagsBits & ~object & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
        {
          v131 = (unint64_t)v315._object;
          v132 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
          if ((v133 & 1) != 0)
            goto LABEL_284;
          if (v130 > 15 || (v131 & 0x2000000000000000) == 0 && v132 > 0)
            goto LABEL_131;
        }
        else if (v130 > 15)
        {
LABEL_131:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v130, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          v314 = xmmword_1816ABEF0;
          v134 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v314, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v134, v135, 1);
          v136 = 0xE100000000000000;
LABEL_138:
          swift_bridgeObjectRelease(v136);
          goto LABEL_139;
        }
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        v137 = v315._countAndFlagsBits;
        v138 = v315._object;
        swift_bridgeObjectRetain((unint64_t)v315._object, v139, v140, v141);
        v142 = _StringGuts._convertedToSmall()(v137, (unint64_t)v138);
        v144 = v143;
        swift_bridgeObjectRelease((uint64_t)v138);
        v145._rawBits = 1;
        v146._rawBits = 65537;
        v147._rawBits = _StringGuts.validateScalarRange(_:)(v145, v146, 0x2EuLL, 0xE100000000000000);
        if (v147._rawBits < 0x10000)
          v147._rawBits |= 3;
        v149 = specialized String.init(_:)(v147, v148, 0x2EuLL, 0xE100000000000000);
        v151 = v150;
        swift_bridgeObjectRelease(0xE100000000000000);
        v152 = _StringGuts._convertedToSmall()(v149, v151);
        v154 = v153;
        swift_bridgeObjectRelease(v151);
        v155 = specialized _SmallString.init(_:appending:)(v142, v144, v152, v154);
        if ((v157 & 1) != 0)
          goto LABEL_283;
        v158 = v155;
        v159 = v156;
        swift_bridgeObjectRelease(0xE100000000000000);
        v136 = (uint64_t)v315._object;
        v315._countAndFlagsBits = v158;
        v315._object = v159;
        goto LABEL_138;
      }
      v302 = String.UTF8View._foreignCount()();
      v130 = v302 + 1;
      if (!__OFADD__(v302, 1))
        goto LABEL_125;
LABEL_267:
      __break(1u);
LABEL_268:
      v303 = String.UTF8View._foreignCount()();
      v233 = v303 + 1;
      if (__OFADD__(v303, 1))
        goto LABEL_270;
LABEL_204:
      if ((countAndFlagsBits & ~object & 0x2000000000000000) != 0
        && swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
      {
        v234 = (unint64_t)v315._object;
        v235 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
        if ((v236 & 1) == 0)
        {
          if (v233 > 15 || (v234 & 0x2000000000000000) == 0 && v235 > 0)
            goto LABEL_210;
          goto LABEL_212;
        }
LABEL_284:
        v310 = 258;
      }
      else
      {
        if (v233 > 15)
        {
LABEL_210:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v233, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          v314 = xmmword_1816ABEF0;
          v237 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v314, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v237, v238, 1);
          v239 = 0xE100000000000000;
          goto LABEL_217;
        }
LABEL_212:
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        v240 = v315._countAndFlagsBits;
        v241 = v315._object;
        swift_bridgeObjectRetain((unint64_t)v315._object, v242, v243, v244);
        v245 = _StringGuts._convertedToSmall()(v240, (unint64_t)v241);
        v247 = v246;
        swift_bridgeObjectRelease((uint64_t)v241);
        v248._rawBits = 1;
        v249._rawBits = 65537;
        v250._rawBits = _StringGuts.validateScalarRange(_:)(v248, v249, 0x2EuLL, 0xE100000000000000);
        if (v250._rawBits < 0x10000)
          v250._rawBits |= 3;
        v252 = specialized String.init(_:)(v250, v251, 0x2EuLL, 0xE100000000000000);
        v254 = v253;
        swift_bridgeObjectRelease(0xE100000000000000);
        v255 = _StringGuts._convertedToSmall()(v252, v254);
        v257 = v256;
        swift_bridgeObjectRelease(v254);
        v258 = specialized _SmallString.init(_:appending:)(v245, v247, v255, v257);
        if ((v260 & 1) == 0)
        {
          v261 = v258;
          v262 = v259;
          swift_bridgeObjectRelease(0xE100000000000000);
          v239 = (uint64_t)v315._object;
          v315._countAndFlagsBits = v261;
          v315._object = v262;
          goto LABEL_217;
        }
LABEL_283:
        v310 = 266;
      }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v310, 0);
    }
    v122 = 8 * (((unint64_t)v315._object >> 56) & 7);
    v123 = (-255 << v122) - 1;
    v124 = 46 << v122;
    v125 = v124 | v123 & (uint64_t)v315._object;
    v126 = v124 | v123 & v315._countAndFlagsBits;
    if (v120 < 8)
      countAndFlagsBits = v126;
    else
      object = v125;
    swift_bridgeObjectRelease(0xE100000000000000);
    v127 = 0xA000000000000000;
    if (!(countAndFlagsBits & 0x8080808080808080 | object & 0x80808080808080))
      v127 = 0xE000000000000000;
    v128 = (void *)((v127 & 0xFF00000000000000 | (v120 << 56) | object & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000);
    swift_bridgeObjectRelease((uint64_t)v315._object);
    v315._countAndFlagsBits = countAndFlagsBits;
    v315._object = v128;
LABEL_139:
    v162 = _uint64ToString(_:radix:uppercase:)(BYTE1(a1), 10, 0);
    v163 = v315._countAndFlagsBits;
    v164 = (unint64_t)v315._object;
    v165 = ((unint64_t)v315._object >> 56) & 0xF;
    v166 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v315._object & 0x2000000000000000) != 0)
      v166 = ((unint64_t)v315._object >> 56) & 0xF;
    if (!v166 && (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000) == 0)
    {
      v315 = v162;
      swift_bridgeObjectRelease(v164);
      goto LABEL_189;
    }
    v167 = (uint64_t)v162._object & 0x2000000000000000;
    v168 = ((unint64_t)v162._object >> 56) & 0xF;
    if (((uint64_t)v315._object & 0x2000000000000000) != 0 && v167)
    {
      v169 = v165 + v168;
      if (v165 + v168 <= 0xF)
      {
        if (v168)
        {
          v207 = 0;
          v208 = 0;
          do
          {
            v209 = v165 + v208;
            v210 = v208 + 1;
            if (v208 >= 8)
              v211 = (unint64_t)v162._object;
            else
              v211 = v162._countAndFlagsBits;
            v212 = v211 >> (v207 & 0x38);
            v213 = (8 * v165 + v207) & 0x38;
            v214 = (-255 << v213) - 1;
            v215 = (unint64_t)v212 << v213;
            v216 = v215 | v214 & v164;
            v217 = v215 | v214 & v163;
            if (v209 < 8)
              v163 = v217;
            else
              v164 = v216;
            v207 += 8;
            v208 = v210;
          }
          while (v168 != v210);
        }
        swift_bridgeObjectRelease((uint64_t)v162._object);
        v218 = 0xA000000000000000;
        if (!(v163 & 0x8080808080808080 | v164 & 0x80808080808080))
          v218 = 0xE000000000000000;
        v219 = (void *)(v218 & 0xFF00000000000000 | (v169 << 56) | v164 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v315._object);
        v315._countAndFlagsBits = v163;
        v315._object = v219;
        goto LABEL_189;
      }
      v167 = 1;
    }
    v170 = v167 ? ((unint64_t)v162._object >> 56) & 0xF : v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v162._object, 2, v160, v161);
    if (((uint64_t)v162._object & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n((uint64_t)v162._object, 5, v171, v172);
      v297._rawBits = 1;
      v298._rawBits = (v170 << 16) | 1;
      v299._rawBits = _StringGuts.validateScalarRange(_:)(v297, v298, v162._countAndFlagsBits, (unint64_t)v162._object);
      if (v299._rawBits < 0x10000)
        v299._rawBits |= 3;
      v173 = specialized Collection.count.getter(v299, v300, v162._countAndFlagsBits, (unint64_t)v162._object);
      swift_bridgeObjectRelease((uint64_t)v162._object);
      v163 = v315._countAndFlagsBits;
      v164 = (unint64_t)v315._object;
      if (((uint64_t)v315._object & 0x1000000000000000) != 0)
      {
LABEL_262:
        v301 = String.UTF8View._foreignCount()();
        v174 = v301 + v173;
        if (__OFADD__(v301, v173))
          goto LABEL_155;
        goto LABEL_157;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n((uint64_t)v162._object, 4, v171, v172);
      v173 = v170;
      if ((v164 & 0x1000000000000000) != 0)
        goto LABEL_262;
    }
    if ((v164 & 0x2000000000000000) != 0)
      goto LABEL_156;
    v174 = (v163 & 0xFFFFFFFFFFFFLL) + v173;
    if (__OFADD__(v163 & 0xFFFFFFFFFFFFLL, v173))
    {
      do
      {
LABEL_155:
        __break(1u);
LABEL_156:
        v175 = HIBYTE(v164) & 0xF;
        v174 = v175 + v173;
      }
      while (__OFADD__(v175, v173));
    }
LABEL_157:
    if ((v163 & ~v164 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v164 & 0xFFFFFFFFFFFFFFFLL))
    {
      v176 = (unint64_t)v315._object;
      v177 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
      if ((v178 & 1) != 0)
        goto LABEL_284;
      if (v174 <= 15 && ((v176 & 0x2000000000000000) != 0 || v177 < v173))
      {
LABEL_167:
        swift_bridgeObjectRelease_n((uint64_t)v162._object, 5);
        v182 = v315._countAndFlagsBits;
        v183 = v315._object;
        swift_bridgeObjectRetain((unint64_t)v315._object, v184, v185, v186);
        v187 = _StringGuts._convertedToSmall()(v182, (unint64_t)v183);
        v189 = v188;
        swift_bridgeObjectRelease((uint64_t)v183);
        v190._rawBits = (v170 << 16) | 1;
        v191._rawBits = 1;
        v192._rawBits = _StringGuts.validateScalarRange(_:)(v191, v190, v162._countAndFlagsBits, (unint64_t)v162._object);
        if (v192._rawBits < 0x10000)
          v192._rawBits |= 3;
        v194 = specialized String.init(_:)(v192, v193, v162._countAndFlagsBits, (unint64_t)v162._object);
        v196 = v195;
        swift_bridgeObjectRelease((uint64_t)v162._object);
        v197 = _StringGuts._convertedToSmall()(v194, v196);
        v199 = v198;
        swift_bridgeObjectRelease(v196);
        v200 = specialized _SmallString.init(_:appending:)(v187, v189, v197, v199);
        if ((v202 & 1) != 0)
          goto LABEL_283;
        v203 = v200;
        v204 = v201;
        swift_bridgeObjectRelease((uint64_t)v162._object);
        v181 = v315._object;
        v315._countAndFlagsBits = v203;
        v315._object = v204;
        goto LABEL_171;
      }
    }
    else if (v174 <= 15)
    {
      goto LABEL_167;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v174, v173);
    swift_bridgeObjectRelease_n((uint64_t)v162._object, 4);
    if (((uint64_t)v162._object & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v162._object);
      _StringGuts._foreignAppendInPlace(_:)(v162._countAndFlagsBits, (unint64_t)v162._object, 0, v170);
      swift_bridgeObjectRelease_n((uint64_t)v162._object, 2);
      a1 = v313;
    }
    else
    {
      if (v167)
      {
        swift_bridgeObjectRelease_n((uint64_t)v162._object, 2);
        *(_QWORD *)&v314 = v162._countAndFlagsBits;
        *((_QWORD *)&v314 + 1) = (uint64_t)v162._object & 0xFFFFFFFFFFFFFFLL;
        v179 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v162._object >> 56) & 0xF, (uint64_t)&v314, ((unint64_t)v162._object >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v179, v180, ((uint64_t)v162._object & 0x4000000000000000) != 0);
        v181 = v162._object;
LABEL_171:
        swift_bridgeObjectRelease((uint64_t)v181);
        a1 = v313;
        goto LABEL_189;
      }
      if ((v162._countAndFlagsBits & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease((uint64_t)v162._object);
        v220 = (id)(((uint64_t)v162._object & 0xFFFFFFFFFFFFFFFLL) + 32);
        v221 = v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v220 = _StringObject.sharedUTF8.getter(v162._countAndFlagsBits, (uint64_t)v162._object);
        v221 = v309;
        swift_bridgeObjectRelease((uint64_t)v162._object);
        if (v221 < (v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL))
LABEL_282:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
      }
      a1 = v313;
      v222 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v162._countAndFlagsBits & 0xFFFFFFFFFFFFLL, (uint64_t)v220, v221);
      _StringGuts.appendInPlace(_:isASCII:)(v222, v223, v162._countAndFlagsBits < 0);
      swift_bridgeObjectRelease_n((uint64_t)v162._object, 2);
    }
LABEL_189:
    countAndFlagsBits = v315._countAndFlagsBits;
    object = (unint64_t)v315._object;
    v224 = ((unint64_t)v315._object >> 56) & 0xF;
    v225 = ((uint64_t)v315._object & 0x2000000000000000) != 0
         ? ((unint64_t)v315._object >> 56) & 0xF
         : v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v225 && (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000) == 0)
      break;
    if (((uint64_t)v315._object & 0x2000000000000000) != 0 && v224 != 15)
    {
      v226 = 8 * (((unint64_t)v315._object >> 56) & 7);
      v227 = (-255 << v226) - 1;
      v228 = 46 << v226;
      v229 = v228 | v227 & (uint64_t)v315._object;
      v230 = v228 | v227 & v315._countAndFlagsBits;
      if (v224 < 8)
        countAndFlagsBits = v230;
      else
        object = v229;
      swift_bridgeObjectRelease(0xE100000000000000);
      v231 = 0xA000000000000000;
      if (!(countAndFlagsBits & 0x8080808080808080 | object & 0x80808080808080))
        v231 = 0xE000000000000000;
      v232 = (void *)((v231 & 0xFF00000000000000 | (v224 << 56) | object & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000);
      swift_bridgeObjectRelease((uint64_t)v315._object);
      v315._countAndFlagsBits = countAndFlagsBits;
      v315._object = v232;
      goto LABEL_218;
    }
    swift_bridgeObjectRetain_n(0xE100000000000000, 6, v205, v206);
    if ((object & 0x1000000000000000) != 0)
      goto LABEL_268;
    v129 = __OFADD__(v225, 1);
    v233 = v225 + 1;
    if (!v129)
      goto LABEL_204;
LABEL_270:
    __break(1u);
LABEL_271:
    v20 = _StringGuts._foreignConvertedToSmall()(countAndFlagsBits, object);
    v21 = v304;
LABEL_17:
    v22._rawBits = 1;
    v23._rawBits = 1;
    v24._rawBits = _StringGuts.validateScalarRange(_:)(v22, v23, 0, 0xE000000000000000);
    if (v24._rawBits < 0x10000)
      v24._rawBits |= 3;
    v26 = specialized String.init(_:)(v24, v25, 0, 0xE000000000000000);
    v28 = v27;
    swift_bridgeObjectRelease(0xE000000000000000);
    if ((v28 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v28);
    }
    else
    {
      v305 = v20;
      if ((v28 & 0x1000000000000000) != 0)
      {
        v26 = _StringGuts._foreignConvertedToSmall()(v26, v28);
        v312 = v311;
        swift_bridgeObjectRelease(v28);
        v28 = v312;
      }
      else
      {
        if ((v26 & 0x1000000000000000) != 0)
        {
          v306 = (unsigned __int8 *)((v28 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v307 = v26 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v306 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v26, v28);
        }
        closure #1 in _StringGuts._convertedToSmall()(v306, v307, &v314);
        swift_bridgeObjectRelease(v28);
        v28 = *((_QWORD *)&v314 + 1);
        v26 = v314;
      }
      v20 = v305;
      a1 = v313;
    }
    v29 = HIBYTE(v21) & 0xF;
    v30 = HIBYTE(v28) & 0xF;
    v31 = v30 + v29;
    if ((unint64_t)(v30 + v29) > 0xF)
      goto LABEL_283;
    if (v30)
    {
      v32 = 0;
      v33 = 0;
      do
      {
        v34 = v29 + v33;
        v35 = v33 + 1;
        if (v33 >= 8)
          v36 = v28;
        else
          v36 = v26;
        v37 = v36 >> (v32 & 0x38);
        v38 = (8 * v29 + v32) & 0x38;
        v39 = (-255 << v38) - 1;
        v40 = (unint64_t)v37 << v38;
        v41 = v40 | v39 & v21;
        v42 = v40 | v39 & v20;
        if (v34 < 8)
          v20 = v42;
        else
          v21 = v41;
        v32 += 8;
        v33 = v35;
      }
      while (v30 != v35);
    }
    swift_bridgeObjectRelease(0xE000000000000000);
    v43 = 0xA000000000000000;
    if (!(v20 & 0x8080808080808080 | v21 & 0x80808080808080))
      v43 = 0xE000000000000000;
    v44 = (uint64_t)v315._object;
    v315._countAndFlagsBits = v20;
    v315._object = (void *)(v43 & 0xFF00000000000000 | (v31 << 56) | v21 & 0xFFFFFFFFFFFFFFLL);
LABEL_59:
    swift_bridgeObjectRelease(v44);
LABEL_60:
    v58 = _uint64ToString(_:radix:uppercase:)(HIWORD(a1), 10, 0);
    v49 = v58._countAndFlagsBits;
    countAndFlagsBits = (unint64_t)v58._object;
    v59 = v315._countAndFlagsBits;
    v60 = (unint64_t)v315._object;
    v61 = ((unint64_t)v315._object >> 56) & 0xF;
    v62 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v315._object & 0x2000000000000000) != 0)
      v62 = ((unint64_t)v315._object >> 56) & 0xF;
    if (v62 || (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000) != 0)
    {
      v63 = (uint64_t)v58._object & 0x2000000000000000;
      v64 = ((unint64_t)v58._object >> 56) & 0xF;
      if (((uint64_t)v315._object & 0x2000000000000000) == 0 || !v63)
        goto LABEL_68;
      v65 = v61 + v64;
      if (v61 + v64 <= 0xF)
      {
        if (v64)
        {
          v103 = 0;
          v104 = 0;
          do
          {
            v105 = v61 + v104;
            v106 = v104 + 1;
            if (v104 >= 8)
              v107 = (unint64_t)v58._object;
            else
              v107 = v58._countAndFlagsBits;
            v108 = v107 >> (v103 & 0x38);
            v109 = (8 * v61 + v103) & 0x38;
            v110 = (-255 << v109) - 1;
            v111 = (unint64_t)v108 << v109;
            v112 = v111 | v110 & v60;
            v113 = v111 | v110 & v59;
            if (v105 < 8)
              v59 = v113;
            else
              v60 = v112;
            v103 += 8;
            v104 = v106;
          }
          while (v64 != v106);
        }
        swift_bridgeObjectRelease((uint64_t)v58._object);
        v114 = 0xA000000000000000;
        if (!(v59 & 0x8080808080808080 | v60 & 0x80808080808080))
          v114 = 0xE000000000000000;
        v115 = (void *)(v114 & 0xFF00000000000000 | (v65 << 56) | v60 & 0xFFFFFFFFFFFFFFLL);
        swift_bridgeObjectRelease((uint64_t)v315._object);
        v315._countAndFlagsBits = v59;
        v315._object = v115;
      }
      else
      {
        v63 = 1;
LABEL_68:
        v1 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        if (v63)
          v66 = ((unint64_t)v58._object >> 56) & 0xF;
        else
          v66 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        swift_bridgeObjectRetain_n((uint64_t)v58._object, 2, v56, v57);
        if (((uint64_t)v58._object & 0x1000000000000000) != 0)
        {
          swift_bridgeObjectRetain_n((uint64_t)v58._object, 5, v67, v68);
          v292._rawBits = 1;
          v293._rawBits = (v66 << 16) | 1;
          v294._rawBits = _StringGuts.validateScalarRange(_:)(v292, v293, v58._countAndFlagsBits, (unint64_t)v58._object);
          if (v294._rawBits < 0x10000)
            v294._rawBits |= 3;
          v69 = specialized Collection.count.getter(v294, v295, v58._countAndFlagsBits, (unint64_t)v58._object);
          swift_bridgeObjectRelease((uint64_t)v58._object);
          v59 = v315._countAndFlagsBits;
          v60 = (unint64_t)v315._object;
          if (((uint64_t)v315._object & 0x1000000000000000) != 0)
          {
LABEL_256:
            v296 = String.UTF8View._foreignCount()();
            v70 = v296 + v69;
            if (!__OFADD__(v296, v69))
              goto LABEL_78;
            goto LABEL_76;
          }
        }
        else
        {
          swift_bridgeObjectRetain_n((uint64_t)v58._object, 4, v67, v68);
          v69 = v66;
          if ((v60 & 0x1000000000000000) != 0)
            goto LABEL_256;
        }
        if ((v60 & 0x2000000000000000) == 0)
        {
          v70 = (v59 & 0xFFFFFFFFFFFFLL) + v69;
          if (!__OFADD__(v59 & 0xFFFFFFFFFFFFLL, v69))
            goto LABEL_78;
          goto LABEL_76;
        }
        while (1)
        {
          v71 = HIBYTE(v60) & 0xF;
          v70 = v71 + v69;
          if (!__OFADD__(v71, v69))
            break;
LABEL_76:
          __break(1u);
        }
LABEL_78:
        if ((v59 & ~v60 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v60 & 0xFFFFFFFFFFFFFFFLL))
        {
          v72 = (unint64_t)v315._object;
          v73 = _StringGuts.nativeUnusedCapacity.getter(v315._countAndFlagsBits, (uint64_t)v315._object);
          if ((v74 & 1) != 0)
            goto LABEL_284;
          if (v70 <= 15 && ((v72 & 0x2000000000000000) != 0 || v73 < v69))
            goto LABEL_88;
LABEL_84:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v70, v69);
          swift_bridgeObjectRelease_n((uint64_t)v58._object, 4);
          if (((uint64_t)v58._object & 0x1000000000000000) == 0)
          {
            if (v63)
            {
              swift_bridgeObjectRelease_n((uint64_t)v58._object, 2);
              *(_QWORD *)&v314 = v58._countAndFlagsBits;
              *((_QWORD *)&v314 + 1) = (uint64_t)v58._object & 0xFFFFFFFFFFFFFFLL;
              v75 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v58._object >> 56) & 0xF, (uint64_t)&v314, ((unint64_t)v58._object >> 56) & 0xF);
              _StringGuts.appendInPlace(_:isASCII:)(v75, v76, ((uint64_t)v58._object & 0x4000000000000000) != 0);
              v77 = v58._object;
              goto LABEL_92;
            }
            if ((v58._countAndFlagsBits & 0x1000000000000000) == 0)
              goto LABEL_279;
            swift_bridgeObjectRelease((uint64_t)v58._object);
            v116 = (id)(((uint64_t)v58._object & 0xFFFFFFFFFFFFFFFLL) + 32);
            v117 = v58._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
            goto LABEL_109;
          }
          swift_bridgeObjectRelease((uint64_t)v58._object);
          _StringGuts._foreignAppendInPlace(_:)(v58._countAndFlagsBits, (unint64_t)v58._object, 0, v66);
          swift_bridgeObjectRelease_n((uint64_t)v58._object, 2);
          a1 = v313;
        }
        else
        {
          if (v70 > 15)
            goto LABEL_84;
LABEL_88:
          swift_bridgeObjectRelease_n((uint64_t)v58._object, 5);
          v78 = v315._countAndFlagsBits;
          v79 = v315._object;
          swift_bridgeObjectRetain((unint64_t)v315._object, v80, v81, v82);
          v83 = _StringGuts._convertedToSmall()(v78, (unint64_t)v79);
          v85 = v84;
          swift_bridgeObjectRelease((uint64_t)v79);
          v86._rawBits = (v66 << 16) | 1;
          v87._rawBits = 1;
          v88._rawBits = _StringGuts.validateScalarRange(_:)(v87, v86, v58._countAndFlagsBits, (unint64_t)v58._object);
          if (v88._rawBits < 0x10000)
            v88._rawBits |= 3;
          v90 = specialized String.init(_:)(v88, v89, v58._countAndFlagsBits, (unint64_t)v58._object);
          v92 = v91;
          swift_bridgeObjectRelease((uint64_t)v58._object);
          v93 = _StringGuts._convertedToSmall()(v90, v92);
          v95 = v94;
          swift_bridgeObjectRelease(v92);
          v96 = specialized _SmallString.init(_:appending:)(v83, v85, v93, v95);
          if ((v98 & 1) != 0)
            goto LABEL_283;
          v99 = v96;
          v100 = v97;
          swift_bridgeObjectRelease((uint64_t)v58._object);
          v77 = v315._object;
          v315._countAndFlagsBits = v99;
          v315._object = v100;
LABEL_92:
          swift_bridgeObjectRelease((uint64_t)v77);
          a1 = v313;
        }
      }
    }
    else
    {
      v315 = v58;
      swift_bridgeObjectRelease(v60);
    }
  }
  v315._countAndFlagsBits = 46;
  v315._object = (void *)0xE100000000000000;
  v239 = object;
LABEL_217:
  swift_bridgeObjectRelease(v239);
LABEL_218:
  v263 = _uint64ToString(_:radix:uppercase:)(a1, 10, 0);
  v265 = v315._countAndFlagsBits;
  v264 = (unint64_t)v315._object;
  v266 = ((unint64_t)v315._object >> 56) & 0xF;
  v267 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v315._object & 0x2000000000000000) != 0)
    v267 = ((unint64_t)v315._object >> 56) & 0xF;
  if (!v267 && (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000) == 0)
  {
    v315 = v263;
    v269 = v264;
    goto LABEL_228;
  }
  if (((uint64_t)v315._object & 0x2000000000000000) == 0)
  {
    if (((uint64_t)v263._object & 0x2000000000000000) != 0)
    {
      v268 = ((unint64_t)v263._object >> 56) & 0xF;
      goto LABEL_227;
    }
LABEL_226:
    v268 = v263._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_227;
  }
  if (((uint64_t)v263._object & 0x2000000000000000) == 0)
    goto LABEL_226;
  v268 = ((unint64_t)v263._object >> 56) & 0xF;
  v278 = v266 + v268;
  if (v266 + v268 > 0xF)
  {
LABEL_227:
    _StringGuts.append(_:)(v263._countAndFlagsBits, (unint64_t)v263._object, 0, v268);
    v269 = (uint64_t)v263._object;
LABEL_228:
    swift_bridgeObjectRelease(v269);
    goto LABEL_229;
  }
  if (v268)
  {
    v279 = 0;
    v280 = 0;
    do
    {
      v281 = v266 + v280;
      v282 = v280 + 1;
      if (v280 >= 8)
        v283 = (unint64_t)v263._object;
      else
        v283 = v263._countAndFlagsBits;
      v284 = v283 >> (v279 & 0x38);
      v285 = (8 * v266 + v279) & 0x38;
      v286 = (-255 << v285) - 1;
      v287 = (unint64_t)v284 << v285;
      v288 = v287 | v286 & v264;
      v289 = v287 | v286 & v265;
      if (v281 < 8)
        v265 = v289;
      else
        v264 = v288;
      v279 += 8;
      v280 = v282;
    }
    while (v268 != v282);
  }
  swift_bridgeObjectRelease((uint64_t)v263._object);
  v290 = 0xA000000000000000;
  if (!(v265 & 0x8080808080808080 | v264 & 0x80808080808080))
    v290 = 0xE000000000000000;
  v291 = (void *)(v290 & 0xFF00000000000000 | (v278 << 56) | v264 & 0xFFFFFFFFFFFFFFLL);
  swift_bridgeObjectRelease((uint64_t)v315._object);
  v315._countAndFlagsBits = v265;
  v315._object = v291;
LABEL_229:
  v272 = v315._object;
  v273 = ((unint64_t)v315._object >> 56) & 0xF;
  if (((uint64_t)v315._object & 0x2000000000000000) == 0)
    v273 = v315._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v273 || (v315._countAndFlagsBits & ~(uint64_t)v315._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v315._object & 0x2000000000000000) == 0
      || (v274 = specialized _SmallString.init(_:appending:)(v315._countAndFlagsBits, (unint64_t)v315._object, 0, 0xE000000000000000), (v270 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE000000000000000, (uint64_t)v272, v270, v271);
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      swift_bridgeObjectRelease_n(0xE000000000000000, 2);
    }
    else
    {
      v275 = v274;
      v276 = v272;
      swift_bridgeObjectRelease(0xE000000000000000);
      swift_bridgeObjectRelease((uint64_t)v315._object);
      v315._countAndFlagsBits = v275;
      v315._object = v276;
    }
  }
  else
  {
    v315._countAndFlagsBits = 0;
    v315._object = (void *)0xE000000000000000;
    swift_bridgeObjectRelease((uint64_t)v272);
  }
  return v315._countAndFlagsBits;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _SwiftStdlibVersion()
{
  unsigned int *v0;

  return _SwiftStdlibVersion.description.getter(*v0);
}

unint64_t CollectionDifference.insertions.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t *v4;

  return swift_bridgeObjectRetain(*v4, a2, a3, a4);
}

unint64_t CollectionDifference.removals.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;

  return swift_bridgeObjectRetain(*(_QWORD *)(v4 + 8), a2, a3, a4);
}

void CollectionDifference.init<A>(_:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  __int128 v10;
  __int128 v11;

  if ((static CollectionDifference._validateChanges<A>(_:)(a1, a2, a3, a4) & 1) != 0)
  {
    CollectionDifference.init<A>(_validatedChanges:)(a1, a2, a3, a4, (__objc2_class ***)&v11);
    v10 = v11;
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 8))(a1, a3);
    v10 = 0uLL;
  }
  *a5 = v10;
}

uint64_t static CollectionDifference._validateChanges<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  unint64_t AssociatedTypeWitness;
  uint64_t v28;
  char *v29;
  char v30;
  unint64_t AssociatedConformanceWitness;
  char *v32;
  uint64_t v33;
  unsigned int (*v34)(char *, uint64_t, uint64_t);
  __objc2_class **v35;
  __objc2_class **v36;
  char *v37;
  void (*v38)(unsigned __int8 *, char *, uint64_t);
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  void (*v43)(uint64_t *, char *, uint64_t);
  uint64_t *v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  void (*v49)(char *, uint64_t);
  void (*v50)(unsigned __int8 *, uint64_t);
  void (*v51)(uint64_t *, char *, uint64_t);
  unsigned __int8 *v52;
  int EnumCaseMultiPayload;
  unsigned __int8 *v54;
  __objc2_class **v55;
  void (*v56)(unsigned __int8 *, uint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  __objc2_class **v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  char *v67;
  unint64_t *TupleTypeMetadata3;
  char *v69;
  char *v70;
  uint64_t v71;
  unsigned __int8 *v72;
  int v73;
  unsigned __int8 *v74;
  __objc2_class **v75;
  char v76;
  uint64_t v77;
  char isUniquelyReferenced_nonNull_native;
  char v79;
  unint64_t v80;
  __objc2_class *v81;
  _BOOL8 v82;
  uint64_t v83;
  char v84;
  unint64_t v85;
  char v86;
  __objc2_class **v87;
  __objc2_class **v88;
  __objc2_class **v89;
  char v90;
  char v91;
  uint64_t v92;
  char v93;
  unint64_t v94;
  __objc2_class *v95;
  _BOOL8 v96;
  uint64_t v97;
  char v98;
  unint64_t v99;
  char v100;
  __objc2_class **v101;
  __objc2_class **v102;
  uint64_t v103;
  __objc2_class *v104;
  BOOL v105;
  __objc2_class *v106;
  uint64_t v107;
  __objc2_class *v108;
  __objc2_class *v109;
  __objc2_class **v110;
  uint64_t v112;
  char *v113;
  uint64_t v114;
  unint64_t v115;
  char *v116;
  unsigned int (*v117)(char *, uint64_t, uint64_t);
  void (*v118)(unint64_t);
  unint64_t v119;
  uint64_t v120;
  unsigned __int8 *v121;
  uint64_t v122;
  __objc2_class **v123;
  void (*v124)(unsigned __int8 *, char *, uint64_t);
  void (*v125)(char *, char *, uint64_t);
  char *v126;
  unsigned __int8 *v127;
  __objc2_class **v128;
  uint64_t *v129;
  uint64_t v130;
  char *v131;
  __objc2_class **v132;
  __objc2_class **v133;
  __objc2_class **v134;

  v120 = a2;
  v7 = type metadata accessor for CollectionDifference.Change(0, a2, a3, a4);
  v130 = *(_QWORD *)(v7 - 8);
  v8 = MEMORY[0x1E0C80A78](v7);
  v121 = (unsigned __int8 *)&v112 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = MEMORY[0x1E0C80A78](v8);
  v126 = (char *)&v112 - v11;
  v12 = MEMORY[0x1E0C80A78](v10);
  v127 = (unsigned __int8 *)&v112 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v129 = (uint64_t *)((char *)&v112 - v15);
  MEMORY[0x1E0C80A78](v14);
  v131 = (char *)&v112 - v16;
  v19 = type metadata accessor for Optional(0, v7, v17, v18);
  v20 = MEMORY[0x1E0C80A78](v19);
  v22 = (char *)&v112 - v21;
  v23 = *(_QWORD *)(a3 - 8);
  MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v112 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  v26 = *(_QWORD *)(a4 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v26, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v122 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v29 = (char *)&v112 - v28;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 104))(a3, a4) & 1) != 0)
  {
    v30 = 1;
    return v30 & 1;
  }
  v133 = &_swiftEmptySetSingleton;
  v134 = &_swiftEmptySetSingleton;
  (*(void (**)(char *, uint64_t, uint64_t))(v23 + 16))(v25, a1, a3);
  (*(void (**)(uint64_t, uint64_t))(v26 + 32))(a3, v26);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v26, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v32 = v29;
  v118 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 16);
  v119 = AssociatedConformanceWitness;
  v118(AssociatedTypeWitness);
  v33 = v130;
  v34 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v130 + 48);
  v114 = v7;
  v117 = v34;
  if (v34(v22, 1, v7) == 1)
  {
    v123 = &_swiftEmptyDictionarySingleton;
    v128 = &_swiftEmptyDictionarySingleton;
LABEL_5:
    (*(void (**)(char *, unint64_t))(v122 + 8))(v32, AssociatedTypeWitness);
    swift_bridgeObjectRelease((uint64_t)v133);
    swift_bridgeObjectRelease((uint64_t)v134);
    v35 = v123;
    v36 = v128;
    v30 = specialized static Dictionary<>.== infix(_:_:)((unint64_t)v123, (uint64_t)v128);
    swift_bridgeObjectRelease((uint64_t)v36);
    swift_bridgeObjectRelease((uint64_t)v35);
    return v30 & 1;
  }
  v37 = v22;
  v38 = *(void (**)(unsigned __int8 *, char *, uint64_t))(v33 + 32);
  v123 = &_swiftEmptyDictionarySingleton;
  v124 = v38;
  v128 = &_swiftEmptyDictionarySingleton;
  v39 = v131;
  v40 = v120;
  v41 = v114;
  v116 = v32;
  v113 = v37;
  v115 = AssociatedTypeWitness;
  v38((unsigned __int8 *)v131, v37, v114);
  while (1)
  {
    v43 = *(void (**)(uint64_t *, char *, uint64_t))(v33 + 16);
    v44 = v129;
    v43(v129, v39, v41);
    v45 = *v44;
    v46 = (char *)v44
        + *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v40, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12);
    v47 = v39;
    v48 = v40;
    v49 = *(void (**)(char *, uint64_t))(*(_QWORD *)(v40 - 8) + 8);
    v49(v46, v48);
    if (v45 < 0)
    {
      (*(void (**)(char *, uint64_t))(v33 + 8))(v47, v41);
LABEL_60:
      (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
      swift_bridgeObjectRelease((uint64_t)v133);
      swift_bridgeObjectRelease((uint64_t)v134);
      goto LABEL_55;
    }
    v50 = (void (*)(unsigned __int8 *, uint64_t))v49;
    v51 = v43;
    v52 = v127;
    v125 = (void (*)(char *, char *, uint64_t))v51;
    v51((uint64_t *)v127, v47, v41);
    EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v52, v41);
    v40 = v48;
    v54 = &v52[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v48, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12)];
    if (EnumCaseMultiPayload == 1)
    {
      v55 = v133;
      v56 = v50;
      v57 = v45;
      if (v133[2])
      {
        v58 = specialized static Hasher._hash(seed:_:)((uint64_t)v133[5], v45);
        v59 = -1 << *((_BYTE *)v55 + 32);
        v60 = v58 & ~v59;
        if (((*(unint64_t *)((char *)v55 + ((v60 >> 3) & 0xFFFFFFFFFFFFF8) + 56) >> v60) & 1) != 0)
        {
          v61 = ~v59;
          while (*((_QWORD *)&v55[6]->isa + v60) != v45)
          {
            v60 = (v60 + 1) & v61;
            if (((*(unint64_t *)((char *)v55 + ((v60 >> 3) & 0xFFFFFFFFFFFFF8) + 56) >> v60) & 1) == 0)
              goto LABEL_23;
          }
          goto LABEL_54;
        }
      }
    }
    else
    {
      v62 = v134;
      v56 = v50;
      v57 = v45;
      if (v134[2])
      {
        v63 = specialized static Hasher._hash(seed:_:)((uint64_t)v134[5], v45);
        v64 = -1 << *((_BYTE *)v62 + 32);
        v65 = v63 & ~v64;
        if (((*(unint64_t *)((char *)v62 + ((v65 >> 3) & 0xFFFFFFFFFFFFF8) + 56) >> v65) & 1) != 0)
        {
          v66 = ~v64;
          while (*((_QWORD *)&v62[6]->isa + v65) != v45)
          {
            v65 = (v65 + 1) & v66;
            if (((*(unint64_t *)((char *)v62 + ((v65 >> 3) & 0xFFFFFFFFFFFFF8) + 56) >> v65) & 1) == 0)
              goto LABEL_23;
          }
LABEL_54:
          (*(void (**)(char *, uint64_t))(v130 + 8))(v131, v41);
          (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
          swift_bridgeObjectRelease((uint64_t)v133);
          swift_bridgeObjectRelease((uint64_t)v134);
          v56(v54, v40);
LABEL_55:
          swift_bridgeObjectRelease((uint64_t)v128);
          v110 = v123;
          goto LABEL_56;
        }
      }
    }
LABEL_23:
    specialized Set._Variant.insert(_:)((uint64_t *)&v132, v57);
    v56(v54, v40);
    v67 = v126;
    v39 = v131;
    v125(v126, v131, v41);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v40, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v69 = &v67[*((int *)TupleTypeMetadata3 + 12)];
    v70 = &v67[*((int *)TupleTypeMetadata3 + 16)];
    v71 = *(_QWORD *)v70;
    LODWORD(v67) = v70[8];
    v56((unsigned __int8 *)v69, v40);
    if ((_DWORD)v67 == 1)
    {
      v33 = v130;
      (*(void (**)(char *, uint64_t))(v130 + 8))(v39, v41);
      AssociatedTypeWitness = v115;
      v42 = v113;
      goto LABEL_8;
    }
    if (v71 < 0)
    {
      (*(void (**)(char *, uint64_t))(v130 + 8))(v39, v41);
      goto LABEL_60;
    }
    v72 = v121;
    v124(v121, v39, v41);
    v73 = swift_getEnumCaseMultiPayload(v72, v41);
    v74 = &v72[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v40, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12)];
    if (v73 != 1)
      break;
    v75 = v123;
    if (v123[2])
    {
      specialized __RawDictionaryStorage.find<A>(_:)(v57);
      if ((v76 & 1) != 0)
      {
        (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
        swift_bridgeObjectRelease((uint64_t)v133);
        swift_bridgeObjectRelease((uint64_t)v134);
        v56(v74, v40);
        swift_bridgeObjectRelease((uint64_t)v128);
        v110 = v75;
        goto LABEL_56;
      }
    }
    v77 = v71;
    isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v75);
    v132 = v75;
    v80 = specialized __RawDictionaryStorage.find<A>(_:)(v57);
    v81 = v75[2];
    v82 = (v79 & 1) == 0;
    v83 = (uint64_t)v81 + v82;
    if (__OFADD__(v81, v82))
    {
      __break(1u);
LABEL_64:
      __break(1u);
LABEL_65:
      __break(1u);
LABEL_66:
      __break(1u);
LABEL_67:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)&type metadata for Int);
    }
    v84 = v79;
    if ((uint64_t)v75[3] >= v83)
    {
      if ((isUniquelyReferenced_nonNull_native & 1) != 0)
      {
        v39 = v131;
        v87 = v132;
        if ((v79 & 1) == 0)
          goto LABEL_50;
      }
      else
      {
        specialized _NativeDictionary.copy()((uint64_t (*)(_QWORD))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
        v39 = v131;
        v87 = v132;
        if ((v84 & 1) == 0)
          goto LABEL_50;
      }
    }
    else
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v83, isUniquelyReferenced_nonNull_native);
      v85 = specialized __RawDictionaryStorage.find<A>(_:)(v57);
      if ((v84 & 1) != (v86 & 1))
        goto LABEL_67;
      v80 = v85;
      v39 = v131;
      v87 = v132;
      if ((v84 & 1) == 0)
      {
LABEL_50:
        v87[(v80 >> 6) + 8] = (__objc2_class *)((unint64_t)v87[(v80 >> 6) + 8] | (1 << v80));
        v107 = 8 * v80;
        *(__objc2_class **)((char *)&v87[6]->isa + v107) = (__objc2_class *)v57;
        *(__objc2_class **)((char *)&v87[7]->isa + v107) = (__objc2_class *)v77;
        v108 = v87[2];
        v105 = __OFADD__(v108, 1);
        v109 = (__objc2_class *)((char *)&v108->isa + 1);
        if (v105)
          goto LABEL_66;
        v101 = v87;
        v87[2] = v109;
        goto LABEL_52;
      }
    }
    v101 = v87;
    *((_QWORD *)&v87[7]->isa + v80) = v77;
LABEL_52:
    v33 = v130;
    AssociatedTypeWitness = v115;
    v42 = v113;
    v123 = v101;
LABEL_53:
    swift_bridgeObjectRelease(0x8000000000000000);
    v56(v74, v40);
    v41 = v114;
LABEL_8:
    v32 = v116;
    ((void (*)(unint64_t, unint64_t))v118)(AssociatedTypeWitness, v119);
    if (v117(v42, 1, v41) == 1)
      goto LABEL_5;
    v124((unsigned __int8 *)v39, v42, v41);
  }
  v88 = v128;
  v89 = v123;
  if (!v128[2] || (specialized __RawDictionaryStorage.find<A>(_:)(v71), v88 = v128, (v90 & 1) == 0))
  {
    v91 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v88);
    v132 = v88;
    v92 = v71;
    v94 = specialized __RawDictionaryStorage.find<A>(_:)(v71);
    v95 = v128[2];
    v96 = (v93 & 1) == 0;
    v97 = (uint64_t)v95 + v96;
    if (__OFADD__(v95, v96))
      goto LABEL_64;
    v98 = v93;
    if ((uint64_t)v128[3] >= v97)
    {
      if ((v91 & 1) == 0)
        specialized _NativeDictionary.copy()((uint64_t (*)(_QWORD))canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>);
    }
    else
    {
      specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v97, v91);
      v99 = specialized __RawDictionaryStorage.find<A>(_:)(v92);
      if ((v98 & 1) != (v100 & 1))
        goto LABEL_67;
      v94 = v99;
    }
    v39 = v131;
    v102 = v132;
    v128 = v132;
    if ((v98 & 1) != 0)
    {
      *((_QWORD *)&v132[7]->isa + v94) = v57;
    }
    else
    {
      v132[(v94 >> 6) + 8] = (__objc2_class *)((unint64_t)v132[(v94 >> 6) + 8] | (1 << v94));
      v103 = 8 * v94;
      *(__objc2_class **)((char *)&v102[6]->isa + v103) = (__objc2_class *)v92;
      *(__objc2_class **)((char *)&v102[7]->isa + v103) = (__objc2_class *)v57;
      v104 = v102[2];
      v105 = __OFADD__(v104, 1);
      v106 = (__objc2_class *)((char *)&v104->isa + 1);
      if (v105)
        goto LABEL_65;
      v102[2] = v106;
    }
    v33 = v130;
    AssociatedTypeWitness = v115;
    v42 = v113;
    goto LABEL_53;
  }
  (*(void (**)(char *, unint64_t))(v122 + 8))(v116, v115);
  swift_bridgeObjectRelease((uint64_t)v133);
  swift_bridgeObjectRelease((uint64_t)v134);
  v56(v74, v40);
  swift_bridgeObjectRelease((uint64_t)v88);
  v110 = v89;
LABEL_56:
  swift_bridgeObjectRelease((uint64_t)v110);
  v30 = 0;
  return v30 & 1;
}

void CollectionDifference.init<A>(_validatedChanges:)(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, __objc2_class ***a5@<X8>)
{
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t WitnessTable;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  Swift::Int v25;
  Swift::Int v26;
  uint64_t v27;
  unint64_t *TupleTypeMetadata3;
  uint64_t v29;
  char v30;
  id v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __objc2_class **v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  __objc2_class **v51;
  __objc2_class *v52;
  void *v53;
  Swift::Int v54;
  Swift::Int v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  __objc2_class **v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  __objc2_class **v73;
  __objc2_class *v74;
  uint64_t v75;
  uint64_t v76;
  __objc2_class ***v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char v82[16];
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;

  v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, a2, a3, a4);
  v11 = *(v10 - 1);
  v78 = *(_QWORD *)(v11 + 64);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (unsigned __int8 *)&v76 - v13;
  MEMORY[0x1E0C80A78](v12);
  v83 = a2;
  v84 = a3;
  v85 = a4;
  v79 = v16;
  (*(void (**)(char *, uint64_t, uint64_t))(v16 + 16))((char *)&v76 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a3);
  v86 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a4 + 8) + 56))(a3);
  v19 = type metadata accessor for ContiguousArray(0, (uint64_t)v10, v17, v18);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v19, v20);
  v23 = (void *)swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v19, v22);
  MutableCollection<>.sort(by:)(partial apply for closure #1 in CollectionDifference.init<A>(_validatedChanges:), (uint64_t)v82, v19, WitnessTable, v23);
  v24 = v86;
  v80 = a1;
  v81 = a3;
  if (Array._getCount()())
  {
    v25 = Array._getCount()();
    if (v25 < 0)
LABEL_36:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
    v26 = v25;
    if (v25)
    {
      v77 = a5;
      v27 = 0;
      do
      {
        if (__OFADD__(v27, v26))
        {
          __break(1u);
          goto LABEL_38;
        }
        v29 = (v27 + v26) / 2;
        v30 = ((v24 & 0xC000000000000001) == 0) | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v29, v30 & 1);
        if ((v30 & 1) != 0)
        {
          (*(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v11 + 16))(v14, v24+ ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80))+ *(_QWORD *)(v11 + 72) * v29, v10);
        }
        else
        {
          v31 = _ArrayBuffer._getElementSlowPath(_:)(v29, v24, v10);
          v32 = v31;
          if (v78 != 8)
          {
            swift_unknownObjectRelease(v31);
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
          }
          v86 = (uint64_t)v31;
          (*(void (**)(unsigned __int8 *, uint64_t *, uint64_t *))(v11 + 16))(v14, &v86, v10);
          swift_unknownObjectRelease(v32);
        }
        if (swift_getEnumCaseMultiPayload(v14, (uint64_t)v10) == 1)
        {
          if (v26 <= v29)
            goto LABEL_36;
          v27 = v29 + 1;
        }
        else
        {
          v26 = (v27 + v26) / 2;
          if (v29 < v27)
            goto LABEL_36;
        }
        TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a2, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
        (*(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(&v14[*((int *)TupleTypeMetadata3 + 12)], a2);
      }
      while (v27 != v26);
      a5 = v77;
      if (v26 < 0)
LABEL_38:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
  }
  else
  {
    v26 = 0;
  }
  Array._checkIndex(_:)(0);
  Array._checkIndex(_:)(v26);
  swift_retain((unint64_t *)v24, v33, v34, v35);
  v38 = (void *)_ArrayBuffer.subscript.getter(0, v26, v24, v10);
  v40 = v39;
  v41 = v36;
  v42 = v37;
  if ((v37 & 1) == 0)
    goto LABEL_19;
  v47 = type metadata accessor for __ContiguousArrayStorageBase();
  v50 = swift_unknownObjectRetain_n((uint64_t)v38, 2, v48, v49);
  v51 = (__objc2_class **)swift_dynamicCastClass(v50, v47);
  if (!v51)
  {
    swift_unknownObjectRelease(v38);
    v51 = &_swiftEmptyArrayStorage;
  }
  v52 = v51[2];
  v53 = (void *)swift_release((uint64_t)v51);
  if (__OFSUB__(v42 >> 1, v41))
  {
    __break(1u);
    goto LABEL_40;
  }
  v53 = v38;
  if (v52 != (__objc2_class *)((v42 >> 1) - v41))
  {
LABEL_40:
    swift_unknownObjectRelease(v53);
LABEL_19:
    v86 = (uint64_t)v38;
    v87 = v40;
    v88 = v41;
    v89 = v42;
    v43 = type metadata accessor for ArraySlice(0, (uint64_t)v10, v36, v37);
    v45 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v43, v44);
    v46 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v86, v43, v45);
    swift_unknownObjectRelease(v38);
    goto LABEL_26;
  }
  v46 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v38, v47);
  swift_unknownObjectRelease(v38);
  if (!v46)
  {
    swift_unknownObjectRelease(v38);
    v46 = &_swiftEmptyArrayStorage;
  }
LABEL_26:
  v54 = Array._getCount()();
  if (v54 < v26)
    goto LABEL_38;
  v55 = v54;
  (*(void (**)(uint64_t, uint64_t))(v79 + 8))(v80, v81);
  Array._checkIndex(_:)(v55);
  swift_release(v24);
  v56 = (void *)_ArrayBuffer.subscript.getter(v26, v55, v24, v10);
  v58 = v57;
  v60 = v59;
  v62 = v61;
  swift_release(v24);
  if ((v62 & 1) == 0)
    goto LABEL_28;
  v69 = type metadata accessor for __ContiguousArrayStorageBase();
  v72 = swift_unknownObjectRetain_n((uint64_t)v56, 3, v70, v71);
  v73 = (__objc2_class **)swift_dynamicCastClass(v72, v69);
  if (!v73)
  {
    swift_unknownObjectRelease(v56);
    v73 = &_swiftEmptyArrayStorage;
  }
  v74 = v73[2];
  v75 = swift_release((uint64_t)v73);
  if (__OFSUB__(v62 >> 1, v60))
  {
    __break(1u);
    goto LABEL_42;
  }
  v75 = (uint64_t)v56;
  if (v74 != (__objc2_class *)((v62 >> 1) - v60))
  {
LABEL_42:
    swift_unknownObjectRelease_n(v75, 2);
LABEL_28:
    v86 = (uint64_t)v56;
    v87 = v58;
    v88 = v60;
    v89 = v62;
    v65 = type metadata accessor for ArraySlice(0, (uint64_t)v10, v63, v64);
    v67 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v65, v66);
    v68 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v86, v65, v67);
    swift_unknownObjectRelease(v56);
    goto LABEL_35;
  }
  v68 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v56, v69);
  swift_unknownObjectRelease_n((uint64_t)v56, 2);
  if (!v68)
  {
    swift_unknownObjectRelease(v56);
    v68 = &_swiftEmptyArrayStorage;
  }
LABEL_35:
  *a5 = v68;
  a5[1] = v46;
}

BOOL closure #1 in CollectionDifference.init<A>(_validatedChanges:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  unint64_t *TupleTypeMetadata2;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  void (*v23)(char *, uint64_t, uint64_t);
  uint64_t v24;
  char *v25;
  void (*v26)(unsigned __int8 *, uint64_t);
  _BOOL8 v27;
  uint64_t v28;
  void (*v29)(unsigned __int8 *, uint64_t);
  void (*v30)(char *, uint64_t);
  char *v31;
  uint64_t v32;
  unint64_t *TupleTypeMetadata3;
  char *v34;
  uint64_t v35;
  unint64_t *v36;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;

  v7 = type metadata accessor for CollectionDifference.Change(0, a3, a3, a4);
  v8 = *(_QWORD *)(v7 - 8);
  v9 = MEMORY[0x1E0C80A78](v7);
  v42 = (char *)&v38 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = MEMORY[0x1E0C80A78](v9);
  v38 = (char *)&v38 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v15 = (char *)&v38 - v14;
  MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v38 - v16;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v7, v7, 0, 0);
  v40 = *(TupleTypeMetadata2 - 1);
  v19 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v21 = (unsigned __int8 *)&v38 - v20;
  v41 = v19;
  v22 = (unsigned __int8 *)&v38 + *(int *)(v19 + 48) - v20;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 16);
  v39 = a1;
  v23((char *)&v38 - v20, a1, v7);
  v43 = a2;
  v23((char *)v22, a2, v7);
  if (swift_getEnumCaseMultiPayload(v21, v7) != 1)
  {
    v23(v15, (uint64_t)v21, v7);
    v28 = *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12);
    v25 = &v15[v28];
    if (swift_getEnumCaseMultiPayload(v22, v7) == 1)
    {
      v29 = *(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)(a3 - 8) + 8);
      v29(&v22[v28], a3);
      v29((unsigned __int8 *)&v15[v28], a3);
      v27 = 0;
      goto LABEL_7;
    }
LABEL_6:
    v30 = *(void (**)(char *, uint64_t))(*(_QWORD *)(a3 - 8) + 8);
    v30(v25, a3);
    v31 = v38;
    v23(v38, v39, v7);
    v32 = *(_QWORD *)v31;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v30(&v31[*((int *)TupleTypeMetadata3 + 12)], a3);
    v34 = v42;
    v23(v42, v43, v7);
    v35 = *(_QWORD *)v34;
    v36 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v30(&v34[*((int *)v36 + 12)], a3);
    v27 = v32 < v35;
    v8 = v40;
    v7 = v41;
    goto LABEL_7;
  }
  v23(v17, (uint64_t)v21, v7);
  v24 = *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12);
  v25 = &v17[v24];
  if (swift_getEnumCaseMultiPayload(v22, v7) == 1)
    goto LABEL_6;
  v26 = *(void (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)(a3 - 8) + 8);
  v26(&v22[v24], a3);
  v26((unsigned __int8 *)v25, a3);
  v27 = 1;
LABEL_7:
  (*(void (**)(unsigned __int8 *, uint64_t))(v8 + 8))(v21, v7);
  return v27;
}

void CollectionDifference.inverse()(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, __objc2_class ***a4@<X8>)
{
  _QWORD *v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  Swift::Int v16;
  Swift::Int v17;
  uint64_t v18;
  uint64_t v19;
  Swift::Int v20;
  uint64_t v21;
  uint64_t v22;
  Swift::Int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  uint64_t v30;
  unint64_t *TupleTypeMetadata3;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  char *v36;
  void (*v37)(char *, uint64_t *);
  uint64_t v38;
  uint64_t WitnessTable;
  uint64_t v40;
  uint64_t v41;
  __objc2_class **v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __objc2_class ***v46;
  Swift::Int v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  unsigned __int8 *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  Swift::Int v55;
  Swift::Int v56;
  __objc2_class **v57;
  _QWORD v58[2];

  v53 = a1;
  v54 = *(_QWORD *)(a1 + 16);
  v6 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v54, a2, a3);
  v52 = *(v6 - 1);
  v7 = MEMORY[0x1E0C80A78](v6);
  v51 = (unsigned __int8 *)&v46 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = MEMORY[0x1E0C80A78](v7);
  v50 = (char *)&v46 - v10;
  v11 = MEMORY[0x1E0C80A78](v9);
  v49 = (uint64_t)&v46 - v12;
  MEMORY[0x1E0C80A78](v11);
  v14 = (char *)&v46 - v13;
  v15 = v4[1];
  v58[0] = *v4;
  v58[1] = v15;
  v16 = Array._getCount()();
  v17 = Array._getCount()();
  v20 = v16 + v17;
  if (__OFADD__(v16, v17))
  {
    __break(1u);
    goto LABEL_12;
  }
  v46 = a4;
  if (!v20)
  {
    _swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
    v42 = &_swiftEmptyArrayStorage;
    goto LABEL_10;
  }
  v57 = &_swiftEmptyArrayStorage;
  v48 = type metadata accessor for ContiguousArray(0, (uint64_t)v6, v18, v19);
  ContiguousArray.reserveCapacity(_:)(v20);
  if (v20 < 0)
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v23 = 0;
  v47 = v20;
  v24 = v50;
  v25 = v54;
  while (v20 != v23)
  {
    v55 = v23 + 1;
    v26 = v49;
    CollectionDifference.subscript.getter(v23, v53, v21, v22, v49);
    v27 = v52;
    (*(void (**)(char *, uint64_t, uint64_t *))(v52 + 32))(v24, v26, v6);
    v28 = v51;
    (*(void (**)(unsigned __int8 *, char *, uint64_t *))(v27 + 16))(v51, v24, v6);
    v29 = swift_getEnumCaseMultiPayload(v28, (uint64_t)v6) != 1;
    v30 = *(_QWORD *)v28;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v25, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v32 = *((int *)TupleTypeMetadata3 + 12);
    v33 = &v28[v32];
    v34 = &v28[*((int *)TupleTypeMetadata3 + 16)];
    v35 = *(_QWORD *)v34;
    LOBYTE(v28) = v34[8];
    (*(void (**)(char *, unsigned __int8 *, uint64_t))(*(_QWORD *)(v25 - 8) + 32))(&v14[v32], v33, v25);
    v36 = &v14[*((int *)TupleTypeMetadata3 + 16)];
    *(_QWORD *)v14 = v30;
    *(_QWORD *)v36 = v35;
    v36[8] = (char)v28;
    swift_storeEnumTagMultiPayload(v14, (size_t)v6, v29);
    v37 = *(void (**)(char *, uint64_t *))(v27 + 8);
    v20 = v47;
    v37(v24, v6);
    ContiguousArray.append(_:)((uint64_t)v14, v48);
    v23 = v55;
    if (v55 == 0x8000000000000000)
    {
      __break(1u);
      break;
    }
  }
  v56 = v20;
  v38 = v53;
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, v53, v21);
  _expectEnd<A>(of:is:)((uint64_t)v58, (uint64_t)&v56, v38, WitnessTable);
  v42 = v57;
LABEL_10:
  v58[0] = v42;
  v43 = type metadata accessor for Array(0, (uint64_t)v6, v40, v41);
  v45 = swift_getWitnessTable(&protocol conformance descriptor for [A], v43, v44);
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)v58, v54, v43, v45, v46);
}

BOOL static CollectionDifference.CodingKeys.== infix(_:_:)(int a1, int a2)
{
  return ((a2 ^ a1) & 1) == 0;
}

void CollectionDifference.CodingKeys.hash(into:)(uint64_t a1, char a2)
{
  Hasher._combine(_:)(a2 & 1);
}

uint64_t CollectionDifference.CodingKeys.init(stringValue:)(uint64_t a1, unint64_t a2)
{
  char v6;

  if (a1 == 0x6F69747265736E69 && a2 == 0xEA0000000000736ELL)
    goto LABEL_10;
  if ((~a2 & 0x6000000000000000) == 0)
  {
    if (a1 != 0x736C61766F6D6572 || a2 != 0xE800000000000000)
    {
      swift_bridgeObjectRelease(a2);
      swift_bridgeObjectRelease(0xE800000000000000);
      return 2;
    }
    goto LABEL_13;
  }
  if ((_stringCompareInternal(_:_:expecting:)(0x6F69747265736E69, 0xEA0000000000736ELL, a1, a2, 0) & 1) != 0)
  {
LABEL_10:
    swift_bridgeObjectRelease(a2);
    return 0;
  }
  if (a1 == 0x736C61766F6D6572 && a2 == 0xE800000000000000)
  {
LABEL_13:
    swift_bridgeObjectRelease_n(0xE800000000000000, 2);
    return 1;
  }
  v6 = _stringCompareInternal(_:_:expecting:)(0x736C61766F6D6572, 0xE800000000000000, a1, a2, 0);
  swift_bridgeObjectRelease(a2);
  swift_bridgeObjectRelease(0xE800000000000000);
  if ((v6 & 1) != 0)
    return 1;
  else
    return 2;
}

Swift::Int CollectionDifference.CodingKeys.hashValue.getter(char a1)
{
  Hasher._combine(_:)(a1 & 1);
  return Hasher._finalize()();
}

uint64_t CollectionDifference.CodingKeys.stringValue.getter(char a1)
{
  if ((a1 & 1) != 0)
    return 0x736C61766F6D6572;
  else
    return 0x6F69747265736E69;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.CodingKeys(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return static CollectionDifference.CodingKeys.== infix(_:_:)(*a1, *a2);
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  char *v0;

  return CollectionDifference.CodingKeys.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.CodingKeys(uint64_t a1)
{
  char *v1;

  CollectionDifference.CodingKeys.hash(into:)(a1, *v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance CollectionDifference<A>.CodingKeys(uint64_t a1)
{
  char *v1;
  _QWORD v3[5];
  __int128 v4;
  __int128 v5;

  v3[0] = 0;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v3[2] = unk_1ECD25520 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v3[4] = unk_1ECD25520 ^ 0x7465646279746573;
  v4 = 0u;
  v5 = 0u;
  CollectionDifference.CodingKeys.hash(into:)((uint64_t)v3, *v1);
  return Hasher._finalize()();
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  char *v0;

  return CollectionDifference.CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance CollectionDifference<A>.CodingKeys@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = CollectionDifference.CodingKeys.init(stringValue:)(a1, a2);
  *a3 = result;
  return result;
}

uint64_t protocol witness for CodingKey.intValue.getter in conformance CollectionDifference<A>.CodingKeys()
{
  return 0;
}

void protocol witness for CodingKey.init(intValue:) in conformance CollectionDifference<A>.CodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance CollectionDifference<A>.CodingKeys(uint64_t *a1)
{
  return CodingKey.description.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.CodingKeys);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance CollectionDifference<A>.CodingKeys(uint64_t a1)
{
  return CodingKey.debugDescription.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.CodingKeys);
}

uint64_t CollectionDifference.startIndex.getter()
{
  return protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
}

Swift::Int CollectionDifference.endIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  Swift::Int v4;
  Swift::Int v5;
  BOOL v6;
  Swift::Int result;

  type metadata accessor for CollectionDifference.Change(0, *(_QWORD *)(a1 + 16), a3, a4);
  v4 = Array._getCount()();
  v5 = Array._getCount()();
  v6 = __OFADD__(v4, v5);
  result = v4 + v5;
  if (v6)
    __break(1u);
  return result;
}

uint64_t CollectionDifference.index(after:)(uint64_t a1)
{
  return specialized CollectionDifference.index(after:)(a1);
}

void CollectionDifference.subscript.getter(Swift::Int a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  Swift::Int *v5;
  Swift::Int v8;
  Swift::Int v9;
  uint64_t *v10;
  Swift::Int v11;
  char isClassOrObjCExistentialType;
  char v13;
  uint64_t v14;
  unint64_t v15;
  char v16;
  char v17;
  unint64_t v18;
  uint64_t v19;
  id v20;
  void *v21;
  uint64_t v22;
  id v23;

  v8 = *v5;
  v9 = v5[1];
  v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, *(_QWORD *)(a2 + 16), a3, a4);
  v11 = Array._getCount()();
  if (v11 > a1)
  {
    v8 = v11 - (a1 + 1);
    if (!__OFSUB__(v11, a1 + 1))
    {
      isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      v13 = ((v9 & 0xC000000000000001) == 0) | ~isClassOrObjCExistentialType;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v8, (v9 & 0xC000000000000001) == 0 || (isClassOrObjCExistentialType & 1) == 0);
      if ((v13 & 1) != 0)
      {
        v14 = *(v10 - 1);
        v15 = v9
            + ((*(unsigned __int8 *)(v14 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80))
            + *(_QWORD *)(v14 + 72) * v8;
LABEL_8:
        (*(void (**)(uint64_t, unint64_t, uint64_t *))(v14 + 16))(a5, v15, v10);
        return;
      }
      goto LABEL_11;
    }
    __break(1u);
LABEL_10:
    __break(1u);
LABEL_11:
    v18 = v8;
    v19 = v9;
    goto LABEL_13;
  }
  v9 = a1 - v11;
  if (__OFSUB__(a1, v11))
    goto LABEL_10;
  v16 = _swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
  v17 = ((v8 & 0xC000000000000001) == 0) | ~v16;
  Array._checkSubscript(_:wasNativeTypeChecked:)(v9, (v8 & 0xC000000000000001) == 0 || (v16 & 1) == 0);
  if ((v17 & 1) != 0)
  {
    v14 = *(v10 - 1);
    v15 = v8
        + ((*(unsigned __int8 *)(v14 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80))
        + *(_QWORD *)(v14 + 72) * v9;
    goto LABEL_8;
  }
  v18 = v9;
  v19 = v8;
LABEL_13:
  v20 = _ArrayBuffer._getElementSlowPath(_:)(v18, v19, v10);
  v21 = v20;
  v22 = *(v10 - 1);
  if (*(_QWORD *)(v22 + 64) != 8)
  {
    swift_unknownObjectRelease(v20);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  }
  v23 = v20;
  (*(void (**)(uint64_t, id *, uint64_t *))(v22 + 16))(a5, &v23, v10);
  swift_unknownObjectRelease(v21);
}

uint64_t CollectionDifference.index(before:)(uint64_t a1)
{
  BOOL v1;
  uint64_t result;

  v1 = __OFSUB__(a1, 1);
  result = a1 - 1;
  if (v1)
    __break(1u);
  return result;
}

_QWORD *CollectionDifference.formIndex(_:offsetBy:)(_QWORD *result, uint64_t a2)
{
  if (__OFADD__(*result, a2))
    __break(1u);
  else
    *result += a2;
  return result;
}

uint64_t CollectionDifference.distance(from:to:)(uint64_t a1, uint64_t a2)
{
  return Array.distance(from:to:)(a1, a2);
}

uint64_t protocol witness for Collection.startIndex.getter in conformance CollectionDifference<A>@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result;

  result = protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
  *a1 = result;
  return result;
}

Swift::Int protocol witness for Collection.endIndex.getter in conformance CollectionDifference<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, Swift::Int *a5@<X8>)
{
  Swift::Int result;

  result = CollectionDifference.endIndex.getter(a1, a2, a3, a4);
  *a5 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance CollectionDifference<A>(uint64_t **a1, Swift::Int *a2, uint64_t a3))()
{
  uint64_t *v6;
  uint64_t v7;

  v6 = (uint64_t *)malloc(0x28uLL);
  *a1 = v6;
  v6[4] = (uint64_t)CollectionDifference.subscript.read(v6, *a2, a3, v7);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*CollectionDifference.subscript.read(uint64_t *a1, Swift::Int a2, uint64_t a3, uint64_t a4))()
{
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;

  v7 = type metadata accessor for CollectionDifference.Change(0, *(_QWORD *)(a3 + 16), a3, a4);
  *a1 = v7;
  v8 = *(_QWORD *)(v7 - 8);
  a1[1] = v8;
  v9 = malloc(*(_QWORD *)(v8 + 64));
  a1[2] = (uint64_t)v9;
  CollectionDifference.subscript.getter(a2, a3, v10, v11, (uint64_t)v9);
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance CollectionDifference<A>(uint64_t *a1, uint64_t *a2)
{
  return Array.distance(from:to:)(*a1, *a2);
}

uint64_t protocol witness for Collection.index(after:) in conformance CollectionDifference<A>@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result;

  result = specialized CollectionDifference.index(after:)(*a1);
  *a2 = result;
  return result;
}

uint64_t protocol witness for Collection.formIndex(after:) in conformance CollectionDifference<A>(uint64_t *a1)
{
  uint64_t result;

  result = specialized CollectionDifference.index(after:)(*a1);
  *a1 = result;
  return result;
}

__n128 protocol witness for Sequence.makeIterator() in conformance CollectionDifference<A>@<Q0>(__n128 *a1@<X8>)
{
  __n128 *v1;
  uint64_t v3;
  __n128 result;

  v3 = protocol witness for Sequence.underestimatedCount.getter in conformance EnumeratedSequence<A>.Iterator();
  result = *v1;
  *a1 = *v1;
  a1[1].n128_u64[0] = v3;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

BOOL static CollectionDifference.Index.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.Index(uint64_t *a1, uint64_t *a2)
{
  return static CollectionDifference.Index.== infix(_:_:)(*a1, *a2);
}

BOOL static CollectionDifference.Index.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance CollectionDifference<A>.Index(uint64_t *a1, uint64_t *a2)
{
  return static CollectionDifference.Index.< infix(_:_:)(*a1, *a2);
}

void CollectionDifference.Index.hash(into:)(int a1, Swift::UInt a2)
{
  Hasher._combine(_:)(a2);
}

Swift::Int CollectionDifference.Index.hashValue.getter(Swift::UInt a1)
{
  Hasher._combine(_:)(a1);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance CollectionDifference<A>.Index()
{
  Swift::UInt *v0;

  return CollectionDifference.Index.hashValue.getter(*v0);
}

void protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.Index(int a1)
{
  Swift::UInt *v1;

  CollectionDifference.Index.hash(into:)(a1, *v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance CollectionDifference<A>.Index(uint64_t a1)
{
  Swift::UInt *v1;
  _QWORD v3[5];
  __int128 v4;
  __int128 v5;

  v3[0] = 0;
  v3[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v3[2] = unk_1ECD25520 ^ 0x646F72616E646F6DLL;
  v3[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v3[4] = unk_1ECD25520 ^ 0x7465646279746573;
  v4 = 0u;
  v5 = 0u;
  CollectionDifference.Index.hash(into:)((int)v3, *v1);
  return Hasher._finalize()();
}

uint64_t static CollectionDifference.Change<A>.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  unint64_t *TupleTypeMetadata2;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  void (*v29)(unsigned __int8 *, unsigned __int8 *, uint64_t);
  unint64_t *TupleTypeMetadata3;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 *v38;
  uint64_t v39;
  void (*v40)(unsigned __int8 *, char *, uint64_t);
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  char v44;
  char v45;
  unsigned __int8 *v46;
  void (*v47)(unsigned __int8 *, uint64_t);
  uint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  _BYTE *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int8 *v59;
  char v60;
  uint64_t v61;
  void (*v62)(_BYTE *, char *, uint64_t);
  unsigned __int8 *v63;
  unsigned __int8 *v64;
  char v65;
  unsigned __int8 *v66;
  void (*v67)(_BYTE *, uint64_t);
  void (*v68)(unsigned __int8 *, uint64_t);
  void (*v69)(_BYTE *, uint64_t);
  char v70;
  char v71;
  _BYTE v73[12];
  int v74;
  uint64_t v75;
  unsigned __int8 *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned __int8 *v81;
  unsigned __int8 *v82;

  v75 = a4;
  v81 = a1;
  v82 = a2;
  v80 = *(_QWORD *)(a3 - 8);
  v5 = MEMORY[0x1E0C80A78](a1);
  v76 = &v73[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v7 = MEMORY[0x1E0C80A78](v5);
  v9 = &v73[-v8];
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = &v73[-v11];
  MEMORY[0x1E0C80A78](v10);
  v14 = &v73[-v13];
  v17 = type metadata accessor for CollectionDifference.Change(0, v15, v15, v16);
  v18 = *(_QWORD *)(v17 - 8);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (uint64_t *)&v73[-((v20 + 15) & 0xFFFFFFFFFFFFFFF0)];
  MEMORY[0x1E0C80A78](v19);
  v23 = (uint64_t *)&v73[-v22];
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v17, v17, 0, 0);
  v78 = *(TupleTypeMetadata2 - 1);
  v25 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v27 = &v73[-v26];
  v79 = v25;
  v28 = &v73[*(int *)(v25 + 48) - v26];
  v77 = v18;
  v29 = *(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v18 + 16);
  v29(&v73[-v26], v81, v17);
  v29(v28, v82, v17);
  if (swift_getEnumCaseMultiPayload(v27, v17) == 1)
  {
    v82 = v9;
    v29((unsigned __int8 *)v21, v27, v17);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v31 = *((int *)TupleTypeMetadata3 + 12);
    v32 = (char *)v21 + v31;
    v33 = *((int *)TupleTypeMetadata3 + 16);
    v81 = *(unsigned __int8 **)((char *)v21 + v33);
    v34 = *((unsigned __int8 *)v21 + v33 + 8);
    v35 = a3;
    if (swift_getEnumCaseMultiPayload(v28, v17) == 1)
    {
      v74 = v34;
      v36 = *v21;
      v37 = *(_QWORD *)v28;
      v38 = &v28[v31];
      v79 = *(_QWORD *)&v28[v33];
      LODWORD(v78) = v28[v33 + 8];
      v39 = v80;
      v40 = *(void (**)(unsigned __int8 *, char *, uint64_t))(v80 + 32);
      v41 = v82;
      v40(v82, v32, v35);
      v42 = v76;
      v40(v76, (char *)v38, v35);
      if (v36 == v37)
      {
        v43 = (unsigned __int8 *)v79;
        v44 = v78;
        v45 = (*(uint64_t (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v75 + 8))(v41, v42, v35);
        v46 = v42;
        v47 = *(void (**)(unsigned __int8 *, uint64_t))(v39 + 8);
        v47(v46, v35);
        v47(v41, v35);
        if ((v45 & 1) != 0)
        {
          if ((v74 & 1) != 0)
          {
            v48 = v77;
            if ((v44 & 1) != 0)
              goto LABEL_30;
          }
          else
          {
            if (v81 == v43)
              v70 = v44;
            else
              v70 = 1;
            v48 = v77;
            if ((v70 & 1) == 0)
              goto LABEL_30;
          }
LABEL_16:
          v56 = 0;
          goto LABEL_31;
        }
      }
      else
      {
        v68 = *(void (**)(unsigned __int8 *, uint64_t))(v39 + 8);
        v68(v42, v35);
        v68(v41, v35);
      }
      v56 = 0;
      v48 = v77;
      goto LABEL_31;
    }
    v54 = v80;
  }
  else
  {
    v81 = v12;
    v82 = v27;
    v29((unsigned __int8 *)v23, v27, v17);
    v49 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a3, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v50 = *((int *)v49 + 12);
    v32 = (char *)v23 + v50;
    v51 = *((int *)v49 + 16);
    v52 = *(_BYTE **)((char *)v23 + v51);
    v53 = *((unsigned __int8 *)v23 + v51 + 8);
    if (swift_getEnumCaseMultiPayload(v28, v17) != 1)
    {
      LODWORD(v78) = v53;
      v76 = v52;
      v57 = *v23;
      v58 = *(_QWORD *)v28;
      v59 = &v28[v50];
      v79 = *(_QWORD *)&v28[v51];
      v60 = v28[v51 + 8];
      v61 = v80;
      v62 = *(void (**)(_BYTE *, char *, uint64_t))(v80 + 32);
      v62(v14, v32, a3);
      v63 = v81;
      v62(v81, (char *)v59, a3);
      if (v57 == v58)
      {
        v64 = (_BYTE *)v79;
        v65 = (*(uint64_t (**)(_BYTE *, unsigned __int8 *, uint64_t))(v75 + 8))(v14, v63, a3);
        v66 = v63;
        v67 = *(void (**)(_BYTE *, uint64_t))(v61 + 8);
        v67(v66, a3);
        v67(v14, a3);
        if ((v65 & 1) != 0)
        {
          if ((v78 & 1) != 0)
          {
            v48 = v77;
            v27 = v82;
            if ((v60 & 1) != 0)
            {
LABEL_30:
              v56 = 1;
              goto LABEL_31;
            }
          }
          else
          {
            v48 = v77;
            if (v76 == v64)
              v71 = v60;
            else
              v71 = 1;
            v27 = v82;
            if ((v71 & 1) == 0)
              goto LABEL_30;
          }
          goto LABEL_16;
        }
      }
      else
      {
        v69 = *(void (**)(_BYTE *, uint64_t))(v61 + 8);
        v69(v63, a3);
        v69(v14, a3);
      }
      v56 = 0;
      v48 = v77;
      v27 = v82;
      goto LABEL_31;
    }
    v54 = v80;
    v27 = v82;
    v35 = a3;
  }
  v55 = v78;
  v17 = v79;
  (*(void (**)(char *, uint64_t))(v54 + 8))(v32, v35);
  v56 = 0;
  v48 = v55;
LABEL_31:
  (*(void (**)(unsigned __int8 *, uint64_t))(v48 + 8))(v27, v17);
  return v56;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> CollectionDifference<A>.Change(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  return static CollectionDifference.Change<A>.== infix(_:_:)(a1, a2, *(_QWORD *)(a3 + 16), *(_QWORD *)(a4 - 8));
}

uint64_t static CollectionDifference<A>.== infix(_:_:)(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  Swift::Int v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v24;
  char v25;
  void (*v26)(unsigned __int8 *, unint64_t, uint64_t *);
  BOOL v27;
  char v28;
  char v29;
  void (*v30)(unsigned __int8 *, uint64_t *);
  id v31;
  void *v32;
  id v33;
  uint64_t v34;
  Swift::Int v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unsigned __int8 *v39;
  _BOOL8 v40;
  BOOL v41;
  char v42;
  void (*v43)(unsigned __int8 *, unint64_t, uint64_t *);
  uint64_t v44;
  char v45;
  unsigned __int8 *v46;
  char v47;
  void (*v48)(unsigned __int8 *, uint64_t *);
  id v49;
  void *v50;
  id v51;
  void *v53;
  uint64_t v54;
  unsigned __int8 *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int8 *v60;
  uint64_t v61;
  uint64_t v62;
  id v63;

  v61 = a3;
  v62 = a4;
  v6 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, a3, a3, a4);
  v7 = *(v6 - 1);
  v8 = *(_QWORD *)(v7 + 64);
  v9 = MEMORY[0x1E0C80A78](v6);
  v55 = (unsigned __int8 *)&v54 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = MEMORY[0x1E0C80A78](v9);
  v60 = (unsigned __int8 *)&v54 - v11;
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (unsigned __int8 *)&v54 - v13;
  MEMORY[0x1E0C80A78](v12);
  v16 = (unsigned __int8 *)&v54 - v15;
  v18 = *a1;
  v17 = a1[1];
  v20 = *a2;
  v19 = a2[1];
  v21 = Array._getCount()();
  if (v21 != Array._getCount()())
    return 0;
  v56 = v17;
  v57 = v19;
  v54 = v8;
  if (v21)
  {
    v22 = _ArrayBuffer.identity.getter(v18, v6);
    if (v22 != _ArrayBuffer.identity.getter(v20, v6))
    {
      if (v21 < 0)
        goto LABEL_36;
      v23 = 0;
      v58 = v20 & 0xC000000000000001;
      v59 = v18 & 0xC000000000000001;
      while (v21 != v23)
      {
        v24 = v59 == 0;
        v25 = v24 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v23, v25 & 1);
        if ((v25 & 1) != 0)
        {
          v26 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
          v26(v16, v18+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(_QWORD *)(v7 + 72) * v23, v6);
        }
        else
        {
          v31 = _ArrayBuffer._getElementSlowPath(_:)(v23, v18, v6);
          v32 = v31;
          if (v54 != 8)
            goto LABEL_37;
          v63 = v31;
          v26 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
          v26(v16, (unint64_t)&v63, v6);
          swift_unknownObjectRelease(v32);
        }
        v27 = v58 == 0;
        v28 = v27 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
        Array._checkSubscript(_:wasNativeTypeChecked:)(v23, v28 & 1);
        if ((v28 & 1) != 0)
        {
          v26(v14, v20+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(_QWORD *)(v7 + 72) * v23, v6);
        }
        else
        {
          v33 = _ArrayBuffer._getElementSlowPath(_:)(v23, v20, v6);
          v32 = v33;
          if (v54 != 8)
          {
LABEL_37:
            v53 = v32;
            goto LABEL_39;
          }
          v63 = v33;
          v26(v14, (unint64_t)&v63, v6);
          swift_unknownObjectRelease(v32);
        }
        v29 = static CollectionDifference.Change<A>.== infix(_:_:)(v16, v14, v61, v62);
        v30 = *(void (**)(unsigned __int8 *, uint64_t *))(v7 + 8);
        v30(v14, v6);
        v30(v16, v6);
        ++v23;
        if ((v29 & 1) == 0)
          return 0;
      }
    }
  }
  v34 = v56;
  v35 = Array._getCount()();
  if (v35 != Array._getCount()())
    return 0;
  if (v35)
  {
    v36 = _ArrayBuffer.identity.getter(v34, v6);
    if (v36 != _ArrayBuffer.identity.getter(v57, v6))
    {
      if ((v35 & 0x8000000000000000) == 0)
      {
        v37 = 0;
        v59 = v34 & 0xC000000000000001;
        v38 = v57 & 0xC000000000000001;
        v39 = v55;
        while (1)
        {
          v40 = v35 == v37;
          if (v35 == v37)
            return v40;
          v41 = v59 == 0;
          v42 = v41 | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
          Array._checkSubscript(_:wasNativeTypeChecked:)(v37, v42 & 1);
          if ((v42 & 1) != 0)
          {
            v43 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
            v43(v60, v34+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(_QWORD *)(v7 + 72) * v37, v6);
          }
          else
          {
            v49 = _ArrayBuffer._getElementSlowPath(_:)(v37, v34, v6);
            v50 = v49;
            if (v54 != 8)
              goto LABEL_38;
            v63 = v49;
            v43 = *(void (**)(unsigned __int8 *, unint64_t, uint64_t *))(v7 + 16);
            v43(v60, (unint64_t)&v63, v6);
            swift_unknownObjectRelease(v50);
          }
          v44 = v57;
          v45 = (v38 == 0) | ~_swift_isClassOrObjCExistentialType((uint64_t)v6, v6);
          Array._checkSubscript(_:wasNativeTypeChecked:)(v37, v45 & 1);
          if ((v45 & 1) != 0)
          {
            v43(v39, v44+ ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))+ *(_QWORD *)(v7 + 72) * v37, v6);
          }
          else
          {
            v51 = _ArrayBuffer._getElementSlowPath(_:)(v37, v44, v6);
            v50 = v51;
            if (v54 != 8)
            {
LABEL_38:
              v53 = v50;
LABEL_39:
              swift_unknownObjectRelease(v53);
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
            }
            v63 = v51;
            v43(v39, (unint64_t)&v63, v6);
            swift_unknownObjectRelease(v50);
          }
          v46 = v60;
          v47 = static CollectionDifference.Change<A>.== infix(_:_:)(v60, v39, v61, v62);
          v48 = *(void (**)(unsigned __int8 *, uint64_t *))(v7 + 8);
          v48(v39, v6);
          v48(v46, v6);
          ++v37;
          v34 = v56;
          if ((v47 & 1) == 0)
            return v40;
        }
      }
LABEL_36:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
  }
  return 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance <A> CollectionDifference<A>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return static CollectionDifference<A>.== infix(_:_:)(a1, a2, *(_QWORD *)(a3 + 16), *(_QWORD *)(a4 - 8));
}

void CollectionDifference.Change<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  int EnumCaseMultiPayload;
  Swift::UInt v19;
  unint64_t *TupleTypeMetadata3;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  Swift::UInt v23;
  int v24;
  void (*v25)(char *, unsigned __int8 *, uint64_t);
  uint64_t v26;

  v7 = *(_QWORD *)(a2 + 16);
  v8 = *(_QWORD *)(v7 - 8);
  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = (char *)&v26 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v26 - v13;
  MEMORY[0x1E0C80A78](v12);
  v16 = (unsigned __int8 *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unsigned __int8 *, uint64_t, uint64_t))(v17 + 16))(v16, v3, a2);
  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v16, a2);
  v19 = *(_QWORD *)v16;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
  v21 = &v16[*((int *)TupleTypeMetadata3 + 12)];
  v22 = &v16[*((int *)TupleTypeMetadata3 + 16)];
  v23 = *(_QWORD *)v22;
  v24 = v22[8];
  v25 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v8 + 32);
  if (EnumCaseMultiPayload == 1)
  {
    v25(v11, v21, v7);
    Hasher._combine(_:)(1uLL);
    Hasher._combine(_:)(v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v7, a3);
    (*(void (**)(char *, uint64_t))(v8 + 8))(v11, v7);
  }
  else
  {
    v25(v14, v21, v7);
    Hasher._combine(_:)(0);
    Hasher._combine(_:)(v19);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 24))(a1, v7, a3);
    (*(void (**)(char *, uint64_t))(v8 + 8))(v14, v7);
  }
  if (v24)
  {
    Hasher._combine(_:)(0);
  }
  else
  {
    Hasher._combine(_:)(1u);
    Hasher._combine(_:)(v23);
  }
}

Swift::Int CollectionDifference.Change<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return DiscontiguousSlice<>.hashValue.getter(a1, a2, (void (*)(_QWORD *, uint64_t, uint64_t))CollectionDifference.Change<A>.hash(into:));
}

Swift::Int DiscontiguousSlice<>.hashValue.getter(uint64_t a1, uint64_t a2, void (*a3)(_QWORD *, uint64_t, uint64_t))
{
  _QWORD v4[5];
  __int128 v5;
  __int128 v6;

  v4[0] = 0;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v4[2] = unk_1ECD25520 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v4[4] = unk_1ECD25520 ^ 0x7465646279746573;
  v5 = 0u;
  v6 = 0u;
  a3(v4, a1, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2)
{
  return CollectionDifference.Change<A>.hashValue.getter(a1, *(_QWORD *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CollectionDifference.Change<A>.hash(into:)(a1, a2, *(_QWORD *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance <> ClosedRange<A><>.Index(a1, a2, a3, (void (*)(_QWORD *, uint64_t, uint64_t))CollectionDifference.Change<A>.hash(into:));
}

void CollectionDifference<A>.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  Swift::UInt v32;
  Swift::Int v33;
  unint64_t v34;
  BOOL v35;
  char v36;
  unint64_t v37;
  void (*v38)(char *, char *, uint64_t *);
  char *v39;
  unsigned __int8 *v40;
  Swift::UInt v41;
  unint64_t *TupleTypeMetadata3;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  int v45;
  uint64_t v46;
  void (*v47)(char *, unsigned __int8 *, uint64_t);
  char *v48;
  Swift::UInt v49;
  id v50;
  void *v51;
  Swift::UInt v52;
  Swift::Int v53;
  uint64_t v54;
  unint64_t v55;
  BOOL v56;
  char v57;
  char *v58;
  void (*v59)(char *, char *, uint64_t *);
  char *v60;
  unsigned __int8 *v61;
  Swift::UInt v62;
  unint64_t *v63;
  unsigned __int8 *v64;
  unsigned __int8 *v65;
  int v66;
  void (*v67)(char *, unsigned __int8 *, uint64_t);
  char *v68;
  Swift::UInt v69;
  id v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  char *v77;
  unint64_t v78;
  char *v79;
  unsigned __int8 *v80;
  Swift::Int v81;
  char *v82;
  unsigned __int8 *v83;
  uint64_t v84;
  Swift::UInt v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD v91[2];

  v90 = a3;
  v5 = *(_QWORD *)(a2 + 16);
  v84 = *(_QWORD *)(v5 - 8);
  v6 = MEMORY[0x1E0C80A78](a1);
  v73 = (char *)&v71 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = MEMORY[0x1E0C80A78](v6);
  v72 = (char *)&v71 - v9;
  v10 = MEMORY[0x1E0C80A78](v8);
  v75 = (char *)&v71 - v11;
  MEMORY[0x1E0C80A78](v10);
  v74 = (char *)&v71 - v12;
  v15 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v5, v13, v14);
  v16 = *(v15 - 1);
  v17 = MEMORY[0x1E0C80A78](v15);
  v80 = (unsigned __int8 *)&v71 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v86 = (char *)&v71 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v79 = (char *)&v71 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v83 = (unsigned __int8 *)&v71 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v27 = (char *)&v71 - v26;
  v71 = v28;
  MEMORY[0x1E0C80A78](v25);
  v82 = (char *)&v71 - v29;
  v31 = *v3;
  v30 = v3[1];
  v32 = Array._getCount()();
  Hasher._combine(_:)(v32);
  v33 = Array._getCount()();
  v88 = v16;
  v89 = v5;
  v87 = v30;
  v81 = v33;
  if (v33)
  {
    v34 = 0;
    v77 = v27;
    v78 = v31 & 0xC000000000000001;
    v76 = v31;
    do
    {
      v35 = v78 == 0;
      v36 = v35 | ~_swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v34, v36 & 1);
      if ((v36 & 1) != 0)
      {
        (*(void (**)(char *, unint64_t, uint64_t *))(v16 + 16))(v27, v31+ ((*(unsigned __int8 *)(v16 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80))+ *(_QWORD *)(v16 + 72) * v34, v15);
        v37 = v34 + 1;
        if (__OFADD__(v34, 1))
          goto LABEL_15;
      }
      else
      {
        v50 = _ArrayBuffer._getElementSlowPath(_:)(v34, v31, v15);
        v51 = v50;
        if (v71 != 8)
        {
LABEL_32:
          swift_unknownObjectRelease(v51);
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        v91[0] = v50;
        (*(void (**)(char *, _QWORD *, uint64_t *))(v16 + 16))(v27, v91, v15);
        swift_unknownObjectRelease(v51);
        v37 = v34 + 1;
        if (__OFADD__(v34, 1))
        {
LABEL_15:
          __break(1u);
          break;
        }
      }
      v38 = *(void (**)(char *, char *, uint64_t *))(v16 + 32);
      v39 = v82;
      v38(v82, v27, v15);
      v40 = v83;
      v38((char *)v83, v39, v15);
      LODWORD(v38) = swift_getEnumCaseMultiPayload(v40, (uint64_t)v15);
      v41 = *(_QWORD *)v40;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
      v43 = &v40[*((int *)TupleTypeMetadata3 + 12)];
      v44 = &v40[*((int *)TupleTypeMetadata3 + 16)];
      v85 = *(_QWORD *)v44;
      v45 = v44[8];
      v46 = v84;
      v47 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v84 + 32);
      if ((_DWORD)v38 == 1)
      {
        v48 = v75;
        v47(v75, v43, v5);
        v49 = 1;
      }
      else
      {
        v48 = v74;
        v47(v74, v43, v5);
        v49 = 0;
      }
      Hasher._combine(_:)(v49);
      Hasher._combine(_:)(v41);
      (*(void (**)(uint64_t, uint64_t))(v90 + 24))(a1, v5);
      (*(void (**)(char *, uint64_t))(v46 + 8))(v48, v5);
      if (v45)
      {
        Hasher._combine(_:)(0);
      }
      else
      {
        Hasher._combine(_:)(1u);
        Hasher._combine(_:)(v85);
      }
      v30 = v87;
      v16 = v88;
      v31 = v76;
      v27 = v77;
      ++v34;
      v5 = v89;
    }
    while (v37 != v81);
  }
  v52 = Array._getCount()();
  Hasher._combine(_:)(v52);
  v53 = Array._getCount()();
  v54 = v84;
  v83 = (unsigned __int8 *)v53;
  if (!v53)
    return;
  v55 = 0;
  v82 = (char *)(v30 & 0xC000000000000001);
  while (1)
  {
    v56 = v82 == 0;
    v57 = v56 | ~_swift_isClassOrObjCExistentialType((uint64_t)v15, v15);
    Array._checkSubscript(_:wasNativeTypeChecked:)(v55, v57 & 1);
    if ((v57 & 1) == 0)
      break;
    (*(void (**)(char *, unint64_t, uint64_t *))(v16 + 16))(v86, v30+ ((*(unsigned __int8 *)(v16 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80))+ *(_QWORD *)(v16 + 72) * v55, v15);
    v58 = (char *)(v55 + 1);
    if (__OFADD__(v55, 1))
      goto LABEL_30;
LABEL_22:
    v59 = *(void (**)(char *, char *, uint64_t *))(v16 + 32);
    v60 = v79;
    v59(v79, v86, v15);
    v61 = v80;
    v59((char *)v80, v60, v15);
    LODWORD(v59) = swift_getEnumCaseMultiPayload(v61, (uint64_t)v15);
    v62 = *(_QWORD *)v61;
    v63 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v64 = &v61[*((int *)v63 + 12)];
    v65 = &v61[*((int *)v63 + 16)];
    v85 = *(_QWORD *)v65;
    v66 = v65[8];
    v67 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v54 + 32);
    if ((_DWORD)v59 == 1)
    {
      v68 = v73;
      v67(v73, v64, v5);
      v69 = 1;
    }
    else
    {
      v68 = v72;
      v67(v72, v64, v5);
      v69 = 0;
    }
    Hasher._combine(_:)(v69);
    Hasher._combine(_:)(v62);
    (*(void (**)(uint64_t, uint64_t))(v90 + 24))(a1, v5);
    (*(void (**)(char *, uint64_t))(v54 + 8))(v68, v5);
    if (v66)
    {
      Hasher._combine(_:)(0);
    }
    else
    {
      Hasher._combine(_:)(1u);
      Hasher._combine(_:)(v85);
    }
    v30 = v87;
    v16 = v88;
    ++v55;
    v5 = v89;
    if (v58 == (char *)v83)
      return;
  }
  v70 = _ArrayBuffer._getElementSlowPath(_:)(v55, v30, v15);
  v51 = v70;
  if (v71 != 8)
    goto LABEL_32;
  v91[0] = v70;
  (*(void (**)(char *, _QWORD *, uint64_t *))(v16 + 16))(v86, v91, v15);
  swift_unknownObjectRelease(v51);
  v58 = (char *)(v55 + 1);
  if (!__OFADD__(v55, 1))
    goto LABEL_22;
LABEL_30:
  __break(1u);
}

Swift::Int CollectionDifference<A>.hashValue.getter(uint64_t a1, uint64_t a2)
{
  __int128 *v2;
  _QWORD v4[5];
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v7 = *v2;
  v4[0] = 0;
  v4[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v4[2] = unk_1ECD25520 ^ 0x646F72616E646F6DLL;
  v4[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v4[4] = unk_1ECD25520 ^ 0x7465646279746573;
  v5 = 0u;
  v6 = 0u;
  CollectionDifference<A>.hash(into:)((uint64_t)v4, a1, a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance <A> CollectionDifference<A>(uint64_t a1, uint64_t a2)
{
  return CollectionDifference<A>.hashValue.getter(a1, *(_QWORD *)(a2 - 8));
}

void protocol witness for Hashable.hash(into:) in conformance <A> CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CollectionDifference<A>.hash(into:)(a1, a2, *(_QWORD *)(a3 - 8));
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance <A> CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v5[5];
  __int128 v6;
  __int128 v7;

  v3 = *(_QWORD *)(a3 - 8);
  v5[0] = 0;
  v5[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v5[2] = unk_1ECD25520 ^ 0x646F72616E646F6DLL;
  v5[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v5[4] = unk_1ECD25520 ^ 0x7465646279746573;
  v6 = 0u;
  v7 = 0u;
  CollectionDifference<A>.hash(into:)((uint64_t)v5, a2, v3);
  return Hasher._finalize()();
}

void CollectionDifference<A>.inferringMoves()(uint64_t a1@<X0>, uint64_t a2@<X1>, __objc2_class ***a3@<X8>)
{
  uint64_t *v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __objc2_class **v10;
  __objc2_class **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t WitnessTable;
  __objc2_class **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[6];
  _QWORD v24[2];

  v8 = *v3;
  v7 = v3[1];
  v9 = *(_QWORD *)(a1 + 16);
  v10 = closure #1 in CollectionDifference<A>.inferringMoves()(v8, v7, v9, a2);
  v11 = closure #2 in CollectionDifference<A>.inferringMoves()(v8, v7, v9, a2);
  v24[0] = v8;
  v24[1] = v7;
  v23[2] = v9;
  v23[3] = a2;
  v23[4] = v10;
  v23[5] = v11;
  v14 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v9, v12, v13);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a1, v15);
  v17 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOqd__Isgnrzr_xAbGSlRzAGRsd_0_r_0_lIetMgnozo_Tp5((void (*)(char *))partial apply for closure #3 in CollectionDifference<A>.inferringMoves(), (uint64_t)v23, a1, v14, WitnessTable);
  swift_bridgeObjectRelease((uint64_t)v11);
  swift_bridgeObjectRelease((uint64_t)v10);
  v24[0] = v17;
  v20 = type metadata accessor for Array(0, (uint64_t)v14, v18, v19);
  v22 = swift_getWitnessTable(&protocol conformance descriptor for [A], v20, v21);
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)v24, v9, v20, v22, a3);
}

__objc2_class **closure #1 in CollectionDifference<A>.inferringMoves()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  Swift::Int v22;
  Swift::Int v23;
  __objc2_class **v24;
  __objc2_class **v25;
  Swift::Int v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  BOOL v30;
  char v31;
  uint64_t v32;
  void (*v33)(char *, unint64_t, uint64_t *);
  void (*v34)(char *, char *, uint64_t *);
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char v39;
  _BOOL4 isUniquelyReferenced_nonNull_native;
  unint64_t v41;
  char v42;
  __objc2_class *v43;
  _BOOL8 v44;
  uint64_t v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  unint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  unint64_t *TupleTypeMetadata3;
  uint64_t v57;
  void (*v58)(char *, uint64_t);
  _BOOL4 v59;
  unint64_t v60;
  char v61;
  __objc2_class *v62;
  _BOOL8 v63;
  uint64_t v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char v70;
  unint64_t v71;
  uint64_t v72;
  __objc2_class *v73;
  BOOL v74;
  __objc2_class *v75;
  uint64_t v76;
  id v77;
  id v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  __objc2_class *v83;
  __objc2_class *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  __objc2_class **v90;
  uint64_t v92;
  __objc2_class **v93;
  uint64_t (*v94)();
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  uint64_t *v101;
  unint64_t v102;
  Swift::Int v103;
  char *v104;
  unint64_t v105;
  uint64_t v106;
  void (*v107)(uint64_t, char *, uint64_t);
  __objc2_class **v108;
  unint64_t v109;
  char *v110;
  uint64_t v111;
  char *v112;
  __objc2_class **v113;

  v5 = a3;
  v111 = *(_QWORD *)(a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v112 = (char *)&v96 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v8, v8, v9);
  v106 = *(v10 - 1);
  v11 = *(_QWORD *)(v106 + 64);
  v12 = MEMORY[0x1E0C80A78](v10);
  v98 = (char *)&v96 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v12);
  v104 = (char *)&v96 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v110 = (char *)&v96 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v96 - v18;
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v96 - v20;
  v22 = Array._getCount()();
  v23 = Array._getCount()();
  if (v23 >= v22)
    v23 = v22;
  v24 = (__objc2_class **)a4;
  if (v23)
    v25 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v23, v5, a4);
  else
    v25 = &_swiftEmptyDictionarySingleton;
  v26 = Array._getCount()();
  v103 = v26;
  if (v26)
  {
    v96 = v11;
    v97 = a2;
    v27 = 0;
    v101 = v10;
    v102 = a2 & 0xC000000000000001;
    v108 = v24;
    v105 = v5;
    v99 = v21;
    v100 = v19;
    do
    {
      v30 = v102 == 0;
      v31 = v30 | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v31 & 1);
      if ((v31 & 1) != 0)
      {
        v32 = v106;
        v33 = *(void (**)(char *, unint64_t, uint64_t *))(v106 + 16);
        v33(v19, a2+ ((*(unsigned __int8 *)(v32 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v32 + 80))+ *(_QWORD *)(v106 + 72) * v27, v10);
      }
      else
      {
        v77 = _ArrayBuffer._getElementSlowPath(_:)(v27, a2, v10);
        v78 = v77;
        if (v96 != 8)
        {
          swift_unknownObjectRelease(v77);
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        v113 = (__objc2_class **)v77;
        v33 = *(void (**)(char *, unint64_t, uint64_t *))(v106 + 16);
        v33(v19, (unint64_t)&v113, v10);
        v79 = v78;
        v32 = v106;
        swift_unknownObjectRelease(v79);
      }
      v34 = *(void (**)(char *, char *, uint64_t *))(v32 + 32);
      v34(v21, v19, v10);
      if (__OFADD__(v27, 1))
      {
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v105);
      }
      v109 = v27 + 1;
      v35 = v21;
      v36 = v110;
      v34(v110, v35, v10);
      v37 = v104;
      v33(v104, (unint64_t)v36, v10);
      v38 = &v37[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12)];
      v107 = *(void (**)(uint64_t, char *, uint64_t))(v111 + 32);
      v107((uint64_t)v112, v38, v5);
      if (v25[2])
      {
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v5, (uint64_t)v24);
        if ((v39 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t *))(v106 + 8))(v110, v10);
          isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v25);
          v113 = v25;
          v41 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v5, (uint64_t)v24);
          v43 = v25[2];
          v44 = (v42 & 1) == 0;
          v45 = (uint64_t)v43 + v44;
          if (__OFADD__(v43, v44))
            goto LABEL_45;
          v46 = v42;
          if ((uint64_t)v25[3] >= v45)
          {
            v53 = v41;
            if (isUniquelyReferenced_nonNull_native)
            {
              if ((v42 & 1) == 0)
                goto LABEL_38;
            }
            else
            {
              v81 = type metadata accessor for _NativeDictionary(0, v5, (uint64_t)&unk_1E0EACF60, (uint64_t)v108);
              specialized _NativeDictionary.copy()(v81);
              if ((v46 & 1) == 0)
                goto LABEL_38;
            }
          }
          else
          {
            v47 = v5;
            v48 = v5;
            v49 = (uint64_t)v108;
            v50 = type metadata accessor for _NativeDictionary(0, v47, (uint64_t)&unk_1E0EACF60, (uint64_t)v108);
            specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v45, isUniquelyReferenced_nonNull_native, v50);
            v51 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v48, v49);
            if ((v46 & 1) != (v52 & 1))
              goto LABEL_47;
            v53 = v51;
            v5 = v105;
            if ((v46 & 1) == 0)
            {
LABEL_38:
              v25 = v113;
              v113[(v53 >> 6) + 8] = (__objc2_class *)((unint64_t)v113[(v53 >> 6) + 8] | (1 << v53));
              v107((uint64_t)v25[6] + *(_QWORD *)(v111 + 72) * v53, v112, v5);
              v82 = (uint64_t)v25[7] + 16 * v53;
              *(_QWORD *)v82 = 0;
              *(_BYTE *)(v82 + 8) = 1;
              v83 = v25[2];
              v74 = __OFADD__(v83, 1);
              v84 = (__objc2_class *)((char *)&v83->isa + 1);
              if (v74)
                goto LABEL_46;
              v25[2] = v84;
              goto LABEL_40;
            }
          }
          (*(void (**)(char *, uint64_t))(v111 + 8))(v112, v5);
          v25 = v113;
          v76 = (uint64_t)v113[7] + 16 * v53;
          *(_QWORD *)v76 = 0;
          *(_BYTE *)(v76 + 8) = 1;
LABEL_40:
          swift_bridgeObjectRelease(0x8000000000000000);
          v24 = v108;
          goto LABEL_10;
        }
      }
      v54 = (uint64_t *)v98;
      v34(v98, v110, v10);
      v55 = *v54;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
      v57 = v5;
      v58 = *(void (**)(char *, uint64_t))(v111 + 8);
      v58((char *)v54 + *((int *)TupleTypeMetadata3 + 12), v57);
      v59 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v25);
      v113 = v25;
      v60 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v57, (uint64_t)v24);
      v62 = v25[2];
      v63 = (v61 & 1) == 0;
      v64 = (uint64_t)v62 + v63;
      if (__OFADD__(v62, v63))
        goto LABEL_43;
      v65 = v61;
      if ((uint64_t)v25[3] >= v64)
      {
        v71 = v60;
        if (v59)
        {
          if ((v61 & 1) == 0)
            goto LABEL_28;
        }
        else
        {
          v80 = type metadata accessor for _NativeDictionary(0, v105, (uint64_t)&unk_1E0EACF60, (uint64_t)v108);
          specialized _NativeDictionary.copy()(v80);
          if ((v65 & 1) == 0)
            goto LABEL_28;
        }
      }
      else
      {
        v66 = v105;
        v67 = (uint64_t)v108;
        v68 = type metadata accessor for _NativeDictionary(0, v105, (uint64_t)&unk_1E0EACF60, (uint64_t)v108);
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v64, v59, v68);
        v69 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v112, v66, v67);
        if ((v65 & 1) != (v70 & 1))
          goto LABEL_47;
        v71 = v69;
        if ((v65 & 1) == 0)
        {
LABEL_28:
          v25 = v113;
          v113[(v71 >> 6) + 8] = (__objc2_class *)((unint64_t)v113[(v71 >> 6) + 8] | (1 << v71));
          v5 = v105;
          v107((uint64_t)v25[6] + *(_QWORD *)(v111 + 72) * v71, v112, v105);
          v72 = (uint64_t)v25[7] + 16 * v71;
          *(_QWORD *)v72 = v55;
          *(_BYTE *)(v72 + 8) = 0;
          v73 = v25[2];
          v74 = __OFADD__(v73, 1);
          v75 = (__objc2_class *)((char *)&v73->isa + 1);
          if (v74)
            goto LABEL_44;
          v25[2] = v75;
          goto LABEL_9;
        }
      }
      v28 = v105;
      v58(v112, v105);
      v5 = v28;
      v25 = v113;
      v29 = (uint64_t)v113[7] + 16 * v71;
      *(_QWORD *)v29 = v55;
      *(_BYTE *)(v29 + 8) = 0;
LABEL_9:
      swift_bridgeObjectRelease(0x8000000000000000);
      v24 = v108;
      a2 = v97;
LABEL_10:
      v19 = v100;
      v10 = v101;
      v21 = v99;
      ++v27;
    }
    while (v109 != v103);
  }
  v85 = MEMORY[0x1E0C80A78](v26);
  MEMORY[0x1E0C80A78](v85);
  v92 = v5;
  v93 = v24;
  v94 = partial apply for closure #1 in closure #1 in CollectionDifference<A>.inferringMoves();
  v95 = v86;
  swift_bridgeObjectRetain((unint64_t)v25, v87, v88, v89);
  v90 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5((uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool), (uint64_t)(&v96 - 6), (uint64_t)v25, v5, v24);
  swift_bridgeObjectRelease((uint64_t)v25);
  swift_bridgeObjectRelease((uint64_t)v25);
  return v90;
}

__objc2_class **closure #2 in CollectionDifference<A>.inferringMoves()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  Swift::Int v23;
  Swift::Int v24;
  __objc2_class **v25;
  __objc2_class **v26;
  Swift::Int v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  BOOL v31;
  char v32;
  uint64_t v33;
  void (*v34)(char *, unint64_t, uint64_t *);
  void (*v35)(char *, char *, uint64_t *);
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char v40;
  _BOOL4 isUniquelyReferenced_nonNull_native;
  unint64_t v42;
  char v43;
  __objc2_class *v44;
  _BOOL8 v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char v53;
  unint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  unint64_t *TupleTypeMetadata3;
  uint64_t v58;
  void (*v59)(char *, uint64_t);
  _BOOL4 v60;
  unint64_t v61;
  char v62;
  __objc2_class *v63;
  _BOOL8 v64;
  uint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char v71;
  unint64_t v72;
  uint64_t v73;
  __objc2_class *v74;
  BOOL v75;
  __objc2_class *v76;
  uint64_t v77;
  id v78;
  id v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __objc2_class *v84;
  __objc2_class *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  __objc2_class **v91;
  uint64_t v93;
  __objc2_class **v94;
  BOOL (*v95)(uint64_t, uint64_t, char);
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  char *v100;
  char *v101;
  uint64_t *v102;
  unint64_t v103;
  Swift::Int v104;
  char *v105;
  unint64_t v106;
  uint64_t v107;
  void (*v108)(uint64_t, char *, uint64_t);
  __objc2_class **v109;
  unint64_t v110;
  char *v111;
  uint64_t v112;
  char *v113;
  __objc2_class **v114;

  v5 = a3;
  v6 = a1;
  v112 = *(_QWORD *)(a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v113 = (char *)&v97 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v8, v8, v9);
  v11 = *(v10 - 1);
  v12 = *(_QWORD *)(v11 + 64);
  v13 = MEMORY[0x1E0C80A78](v10);
  v99 = (char *)&v97 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v13);
  v105 = (char *)&v97 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v111 = (char *)&v97 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v97 - v19;
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v97 - v21;
  v23 = Array._getCount()();
  v24 = Array._getCount()();
  if (v24 >= v23)
    v24 = v23;
  v25 = (__objc2_class **)a4;
  if (v24)
    v26 = (__objc2_class **)specialized static _DictionaryStorage.allocate(capacity:)(v24, v5, a4);
  else
    v26 = &_swiftEmptyDictionarySingleton;
  v27 = Array._getCount()();
  v104 = v27;
  if (v27)
  {
    v97 = v12;
    v98 = v6;
    v106 = v5;
    v107 = v11;
    v28 = 0;
    v102 = v10;
    v103 = v6 & 0xC000000000000001;
    v109 = v25;
    v100 = v22;
    v101 = v20;
    do
    {
      v31 = v103 == 0;
      v32 = v31 | ~_swift_isClassOrObjCExistentialType((uint64_t)v10, v10);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v28, v32 & 1);
      if ((v32 & 1) != 0)
      {
        v33 = v107;
        v34 = *(void (**)(char *, unint64_t, uint64_t *))(v107 + 16);
        v34(v20, v6+ ((*(unsigned __int8 *)(v33 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v33 + 80))+ *(_QWORD *)(v107 + 72) * v28, v10);
      }
      else
      {
        v78 = _ArrayBuffer._getElementSlowPath(_:)(v28, v6, v10);
        v79 = v78;
        if (v97 != 8)
        {
          swift_unknownObjectRelease(v78);
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
        }
        v114 = (__objc2_class **)v78;
        v34 = *(void (**)(char *, unint64_t, uint64_t *))(v107 + 16);
        v34(v20, (unint64_t)&v114, v10);
        v80 = v79;
        v33 = v107;
        swift_unknownObjectRelease(v80);
      }
      v35 = *(void (**)(char *, char *, uint64_t *))(v33 + 32);
      v35(v22, v20, v10);
      if (__OFADD__(v28, 1))
      {
        __break(1u);
LABEL_43:
        __break(1u);
LABEL_44:
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v106);
      }
      v110 = v28 + 1;
      v36 = v22;
      v37 = v111;
      v35(v111, v36, v10);
      v38 = v105;
      v34(v105, (unint64_t)v37, v10);
      v39 = &v38[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12)];
      v108 = *(void (**)(uint64_t, char *, uint64_t))(v112 + 32);
      v108((uint64_t)v113, v39, v5);
      if (v26[2])
      {
        __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v5, (uint64_t)v25);
        if ((v40 & 1) != 0)
        {
          (*(void (**)(char *, uint64_t *))(v107 + 8))(v111, v10);
          isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native((uint64_t)v26);
          v114 = v26;
          v42 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v5, (uint64_t)v25);
          v44 = v26[2];
          v45 = (v43 & 1) == 0;
          v46 = (uint64_t)v44 + v45;
          if (__OFADD__(v44, v45))
            goto LABEL_45;
          v47 = v43;
          if ((uint64_t)v26[3] >= v46)
          {
            v54 = v42;
            if (isUniquelyReferenced_nonNull_native)
            {
              if ((v43 & 1) == 0)
                goto LABEL_38;
            }
            else
            {
              v82 = type metadata accessor for _NativeDictionary(0, v5, (uint64_t)&unk_1E0EACF60, (uint64_t)v109);
              specialized _NativeDictionary.copy()(v82);
              if ((v47 & 1) == 0)
                goto LABEL_38;
            }
          }
          else
          {
            v48 = v5;
            v49 = v5;
            v50 = (uint64_t)v109;
            v51 = type metadata accessor for _NativeDictionary(0, v48, (uint64_t)&unk_1E0EACF60, (uint64_t)v109);
            specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v46, isUniquelyReferenced_nonNull_native, v51);
            v52 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v49, v50);
            if ((v47 & 1) != (v53 & 1))
              goto LABEL_47;
            v54 = v52;
            v5 = v106;
            if ((v47 & 1) == 0)
            {
LABEL_38:
              v26 = v114;
              v114[(v54 >> 6) + 8] = (__objc2_class *)((unint64_t)v114[(v54 >> 6) + 8] | (1 << v54));
              v108((uint64_t)v26[6] + *(_QWORD *)(v112 + 72) * v54, v113, v5);
              v83 = (uint64_t)v26[7] + 16 * v54;
              *(_QWORD *)v83 = 0;
              *(_BYTE *)(v83 + 8) = 1;
              v84 = v26[2];
              v75 = __OFADD__(v84, 1);
              v85 = (__objc2_class *)((char *)&v84->isa + 1);
              if (v75)
                goto LABEL_46;
              v26[2] = v85;
              goto LABEL_40;
            }
          }
          (*(void (**)(char *, uint64_t))(v112 + 8))(v113, v5);
          v26 = v114;
          v77 = (uint64_t)v114[7] + 16 * v54;
          *(_QWORD *)v77 = 0;
          *(_BYTE *)(v77 + 8) = 1;
LABEL_40:
          swift_bridgeObjectRelease(0x8000000000000000);
          v25 = v109;
          goto LABEL_10;
        }
      }
      v55 = (uint64_t *)v99;
      v35(v99, v111, v10);
      v56 = *v55;
      TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v5, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
      v58 = v5;
      v59 = *(void (**)(char *, uint64_t))(v112 + 8);
      v59((char *)v55 + *((int *)TupleTypeMetadata3 + 12), v58);
      v60 = swift_isUniquelyReferenced_nonNull_native((uint64_t)v26);
      v114 = v26;
      v61 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v58, (uint64_t)v25);
      v63 = v26[2];
      v64 = (v62 & 1) == 0;
      v65 = (uint64_t)v63 + v64;
      if (__OFADD__(v63, v64))
        goto LABEL_43;
      v66 = v62;
      if ((uint64_t)v26[3] >= v65)
      {
        v72 = v61;
        if (v60)
        {
          if ((v62 & 1) == 0)
            goto LABEL_28;
        }
        else
        {
          v81 = type metadata accessor for _NativeDictionary(0, v106, (uint64_t)&unk_1E0EACF60, (uint64_t)v109);
          specialized _NativeDictionary.copy()(v81);
          if ((v66 & 1) == 0)
            goto LABEL_28;
        }
      }
      else
      {
        v67 = v106;
        v68 = (uint64_t)v109;
        v69 = type metadata accessor for _NativeDictionary(0, v106, (uint64_t)&unk_1E0EACF60, (uint64_t)v109);
        specialized _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v65, v60, v69);
        v70 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, v67, v68);
        if ((v66 & 1) != (v71 & 1))
          goto LABEL_47;
        v72 = v70;
        if ((v66 & 1) == 0)
        {
LABEL_28:
          v26 = v114;
          v114[(v72 >> 6) + 8] = (__objc2_class *)((unint64_t)v114[(v72 >> 6) + 8] | (1 << v72));
          v5 = v106;
          v108((uint64_t)v26[6] + *(_QWORD *)(v112 + 72) * v72, v113, v106);
          v73 = (uint64_t)v26[7] + 16 * v72;
          *(_QWORD *)v73 = v56;
          *(_BYTE *)(v73 + 8) = 0;
          v74 = v26[2];
          v75 = __OFADD__(v74, 1);
          v76 = (__objc2_class *)((char *)&v74->isa + 1);
          if (v75)
            goto LABEL_44;
          v26[2] = v76;
          goto LABEL_9;
        }
      }
      v29 = v106;
      v59(v113, v106);
      v5 = v29;
      v26 = v114;
      v30 = (uint64_t)v114[7] + 16 * v72;
      *(_QWORD *)v30 = v56;
      *(_BYTE *)(v30 + 8) = 0;
LABEL_9:
      swift_bridgeObjectRelease(0x8000000000000000);
      v25 = v109;
      v6 = v98;
LABEL_10:
      v20 = v101;
      v10 = v102;
      v22 = v100;
      ++v28;
    }
    while (v110 != v104);
  }
  v86 = MEMORY[0x1E0C80A78](v27);
  MEMORY[0x1E0C80A78](v86);
  v93 = v5;
  v94 = v25;
  v95 = partial apply for closure #1 in closure #2 in CollectionDifference<A>.inferringMoves();
  v96 = v87;
  swift_bridgeObjectRetain((unint64_t)v26, v88, v89, v90);
  v91 = _ss17_NativeDictionaryV6filteryAByxq_GSbx3key_q_5valuet_tKXEKFxq_Sbs5Error_pRi_zRi0_zRi__Ri0__r0_lyxSiSgIsgnndzo_AByxAHGAIsAG_pSHRzAHRs_r0_lIetMggozo_Tp5((uint64_t)partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool), (uint64_t)(&v97 - 6), (uint64_t)v26, v5, v25);
  swift_bridgeObjectRelease((uint64_t)v26);
  swift_bridgeObjectRelease((uint64_t)v26);
  return v91;
}

void closure #3 in CollectionDifference<A>.inferringMoves()(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _QWORD *a6@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  int EnumCaseMultiPayload;
  unint64_t *TupleTypeMetadata3;
  unsigned __int8 *v24;
  void (*v25)(char *, unsigned __int8 *, uint64_t);
  void (*v26)(char *, char *, uint64_t);
  char v27;
  unint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  _BYTE *v33;
  char *v34;
  char *v35;
  _BYTE *v36;
  size_t v37;
  unsigned int v38;
  void (*v39)(char *, char *, uint64_t);
  char v40;
  unint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  _BYTE *v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  void (*v51)(char *, uint64_t, uint64_t);
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void (*v55)(char *, uint64_t, uint64_t);
  uint64_t v56;
  _QWORD *v57;

  v54 = a5;
  v57 = a6;
  v10 = *(_QWORD *)(a4 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v11);
  v15 = (char *)&v52 - v14;
  v18 = type metadata accessor for CollectionDifference.Change(0, v17, v16, v17);
  MEMORY[0x1E0C80A78](v18);
  v20 = (unsigned __int8 *)&v52 - v19;
  v55 = *(void (**)(char *, uint64_t, uint64_t))(v21 + 16);
  v56 = a1;
  v55((char *)&v52 - v19, a1, v18);
  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v20, v18);
  v53 = *(_QWORD *)v20;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, a4, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
  v24 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v25 = *(void (**)(char *, unsigned __int8 *, uint64_t))(v10 + 32);
  if (EnumCaseMultiPayload != 1)
  {
    v39 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
    v25(v13, v24, a4);
    if (*(_QWORD *)(a3 + 16))
    {
      __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, a4, v54);
      if ((v40 & 1) != 0)
      {
        if (*(_QWORD *)(a2 + 16))
        {
          v41 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v13, a4, v54);
          if ((v42 & 1) != 0)
          {
            v43 = *(_QWORD *)(a2 + 56) + 16 * v41;
            v44 = *(_QWORD *)v43;
            v45 = *(_BYTE *)(v43 + 8);
            v46 = v57;
            v47 = (char *)v57 + *((int *)TupleTypeMetadata3 + 12);
            v48 = (char *)v57 + *((int *)TupleTypeMetadata3 + 16);
            *v57 = v53;
            v39(v47, v13, a4);
            *(_QWORD *)v48 = v44;
            v48[8] = v45;
            v36 = v46;
            v37 = v18;
            v38 = 0;
            goto LABEL_12;
          }
        }
        goto LABEL_17;
      }
    }
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a4);
LABEL_15:
    v55((char *)v57, v56, v18);
    return;
  }
  v26 = *(void (**)(char *, char *, uint64_t))(v10 + 32);
  v25(v15, v24, a4);
  if (!*(_QWORD *)(a2 + 16) || (__RawDictionaryStorage.find<A>(_:)((uint64_t)v15, a4, v54), (v27 & 1) == 0))
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, a4);
    goto LABEL_15;
  }
  if (*(_QWORD *)(a3 + 16))
  {
    v28 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v15, a4, v54);
    if ((v29 & 1) != 0)
    {
      v30 = *(_QWORD *)(a3 + 56) + 16 * v28;
      v31 = *(_QWORD *)v30;
      v32 = *(_BYTE *)(v30 + 8);
      v33 = v57;
      v34 = (char *)v57 + *((int *)TupleTypeMetadata3 + 12);
      v35 = (char *)v57 + *((int *)TupleTypeMetadata3 + 16);
      *v57 = v53;
      v26(v34, v15, a4);
      *(_QWORD *)v35 = v31;
      v35[8] = v32;
      v36 = v33;
      v37 = v18;
      v38 = 1;
LABEL_12:
      swift_storeEnumTagMultiPayload(v36, v37, v38);
      return;
    }
  }
  v13 = v15;
LABEL_17:
  v50 = v56;
  v49 = (char *)v57;
  v51 = v55;
  (*(void (**)(char *, uint64_t))(v10 + 8))(v13, a4);
  v51(v49, v50, v18);
}

unint64_t CollectionDifference.Change<A>._CodingKeys.init(rawValue:)(Swift::String string)
{
  void *object;
  Swift::String v2;
  unint64_t v3;

  object = string._object;
  v2._countAndFlagsBits = string._countAndFlagsBits;
  v2._object = object;
  v3 = _findStringSwitchCase(cases:string:)((Swift::OpaquePointer)&outlined read-only object #0 of CollectionDifference.Change<A>._CodingKeys.init(rawValue:), v2);
  swift_bridgeObjectRelease((uint64_t)object);
  if (v3 >= 4)
    return 4;
  else
    return v3;
}

uint64_t CollectionDifference.Change<A>._CodingKeys.rawValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_1814EA400 + 4 * byte_1816AC106[a1]))(0xD000000000000010, 0x8000000181760410);
}

uint64_t sub_1814EA400()
{
  return 0x74657366666FLL;
}

uint64_t sub_1814EA414()
{
  return 0x746E656D656C65;
}

uint64_t sub_1814EA42C()
{
  return 0x65766F6D65527369;
}

uint64_t CollectionDifference.Change<A>._CodingKeys.stringValue.getter(unsigned __int8 a1)
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_1814EA47C + 4 * byte_1816AC10A[a1]))(0xD000000000000010, 0x8000000181760410);
}

uint64_t sub_1814EA47C()
{
  return 0x74657366666FLL;
}

uint64_t sub_1814EA490()
{
  return 0x746E656D656C65;
}

uint64_t sub_1814EA4A8()
{
  return 0x65766F6D65527369;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return == infix<A>(_:_:)(a1, a2, a3, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, (uint64_t)&protocol witness table for String);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return RawRepresentable<>.hash(into:)(a1, a2, a3, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, (uint64_t)&protocol witness table for String);
}

unint64_t protocol witness for RawRepresentable.init(rawValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>(Swift::String *a1@<X0>, _BYTE *a2@<X8>)
{
  unint64_t result;

  result = CollectionDifference.Change<A>._CodingKeys.init(rawValue:)(*a1);
  *a2 = result;
  return result;
}

uint64_t protocol witness for RawRepresentable.rawValue.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>(uint64_t *a1@<X8>)
{
  unsigned __int8 *v1;
  uint64_t result;
  uint64_t v4;

  result = CollectionDifference.Change<A>._CodingKeys.rawValue.getter(*v1);
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for CodingKey.stringValue.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys()
{
  unsigned __int8 *v0;

  return CollectionDifference.Change<A>._CodingKeys.stringValue.getter(*v0);
}

uint64_t protocol witness for CodingKey.init(stringValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys@<X0>(_BYTE *a1@<X8>)
{
  uint64_t result;

  result = CollectionDifference.Change<A>._CodingKeys.init(stringValue:)();
  *a1 = result;
  return result;
}

void protocol witness for CodingKey.init(intValue:) in conformance CollectionDifference<A>.Change<A>._CodingKeys(_BYTE *a1@<X8>)
{
  *a1 = 4;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t *a1)
{
  return CodingKey.description.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance CollectionDifference<A>.Change<A>._CodingKeys(uint64_t a1)
{
  return CodingKey.debugDescription.getter(a1, (uint64_t)&protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
}

uint64_t CollectionDifference.Change<A>.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, _UNKNOWN **);
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  char v30;
  unint64_t *TupleTypeMetadata3;
  uint64_t *v32;
  char *v33;
  char *v34;
  size_t v35;
  uint64_t v36;
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  char v46;

  v42 = a4;
  v38 = a5;
  v39 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](a1);
  v9 = (char *)&v36 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = type metadata accessor for CollectionDifference.Change(0, v10, v11, v12);
  v14 = *(_QWORD *)(v13 - 8);
  MEMORY[0x1E0C80A78](v13);
  v16 = (uint64_t *)((char *)&v36 - v15);
  v17 = a1[3];
  v18 = a1[4];
  v41 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v17);
  v40 = a3;
  v19 = type metadata accessor for CollectionDifference.Change<A>._CodingKeys(0, a2, a3, (uint64_t)v42);
  v20 = v43;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v18 + 24))(&v44, v19, v19, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, v17, v18);
  if (!v20)
  {
    v21 = v40;
    v42 = v16;
    v43 = v14;
    v37 = v13;
    v22 = v44;
    LOBYTE(v44) = 0;
    v23 = v19;
    v24 = (*(uint64_t (**)(uint64_t *, uint64_t, _UNKNOWN **))(*(_QWORD *)v22 + 152))(&v44, v19, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    LOBYTE(v44) = 1;
    v25 = *(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(_QWORD *)v22 + 248);
    v26 = a2;
    v25(a2, &v44, a2, v23, v21, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    v46 = 2;
    v27 = lazy protocol witness table accessor for type Int? and conformance <A> A?();
    ((void (*)(uint64_t *__return_ptr, void *, char *, void *, uint64_t, unint64_t, _UNKNOWN **))v25)(&v44, &unk_1E0EACF60, &v46, &unk_1E0EACF60, v23, v27, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    v28 = v44;
    LOBYTE(v25) = v45;
    LOBYTE(v44) = 3;
    v30 = (*(uint64_t (**)(uint64_t *, uint64_t, _UNKNOWN **))(*(_QWORD *)v22 + 120))(&v44, v23, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    swift_release(v22);
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v26, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v32 = v42;
    v33 = (char *)v42 + *((int *)TupleTypeMetadata3 + 12);
    v34 = (char *)v42 + *((int *)TupleTypeMetadata3 + 16);
    *v42 = v24;
    (*(void (**)(char *, char *, uint64_t))(v39 + 32))(v33, v9, v26);
    *(_QWORD *)v34 = v28;
    v34[8] = (char)v25;
    v35 = v37;
    swift_storeEnumTagMultiPayload(v32, v37, v30 & 1);
    (*(void (**)(uint64_t, uint64_t *, size_t))(v43 + 32))(v38, v32, v35);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v41);
}

uint64_t CollectionDifference.Change<A>.encode(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(unsigned __int8 *, uint64_t, uint64_t);
  uint64_t v26;
  int EnumCaseMultiPayload;
  unsigned __int8 *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t *, uint64_t, _UNKNOWN **);
  uint64_t v31;
  uint64_t v32;
  uint64_t *v34;
  void (*v35)(unsigned __int8 *, uint64_t);
  uint64_t v36;
  unint64_t *TupleTypeMetadata3;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  unint64_t *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  void (*v49)(uint64_t *, char *, void *, uint64_t, unint64_t, _UNKNOWN **);
  unint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  char v61;
  uint64_t v62;

  v56 = a3;
  v7 = *(_QWORD *)(a2 + 16);
  v58 = *(_QWORD *)(v7 - 8);
  v8 = MEMORY[0x1E0C80A78](a1);
  v54 = (char *)&v51 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = *(_QWORD *)(v10 - 8);
  v12 = MEMORY[0x1E0C80A78](v8);
  v52 = (char *)&v51 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v12);
  v53 = (char *)&v51 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v55 = (char *)&v51 - v17;
  v18 = (_QWORD *)MEMORY[0x1E0C80A78](v16);
  v20 = (unsigned __int8 *)&v51 - v19;
  v22 = v18[3];
  v21 = v18[4];
  __swift_project_boxed_opaque_existential_0Tm(v18, v22);
  v23 = v56;
  v56 = a4;
  v24 = type metadata accessor for CollectionDifference.Change<A>._CodingKeys(0, v7, v23, a4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v21 + 24))(&v62, v24, v24, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys, v22, v21);
  v25 = *(void (**)(unsigned __int8 *, uint64_t, uint64_t))(v11 + 16);
  v26 = v4;
  v25(v20, v4, a2);
  EnumCaseMultiPayload = swift_getEnumCaseMultiPayload(v20, a2);
  v28 = &v20[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12)];
  LOBYTE(v59) = 3;
  if (EnumCaseMultiPayload == 1)
  {
    v29 = v62;
    v30 = *(void (**)(uint64_t, uint64_t *, uint64_t, _UNKNOWN **))(*(_QWORD *)v62 + 104);
    v31 = 1;
  }
  else
  {
    v29 = v62;
    v30 = *(void (**)(uint64_t, uint64_t *, uint64_t, _UNKNOWN **))(*(_QWORD *)v62 + 104);
    v31 = 0;
  }
  v32 = v57;
  v30(v31, &v59, v24, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
  if (v32)
  {
    swift_release(v29);
    return (*(uint64_t (**)(unsigned __int8 *, uint64_t))(v58 + 8))(v28, v7);
  }
  else
  {
    v34 = (uint64_t *)v55;
    v35 = *(void (**)(unsigned __int8 *, uint64_t))(v58 + 8);
    v35(v28, v7);
    v25((unsigned __int8 *)v34, v26, a2);
    v36 = *v34;
    TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v35((unsigned __int8 *)v34 + *((int *)TupleTypeMetadata3 + 12), v7);
    LOBYTE(v59) = 0;
    v38 = v62;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, _UNKNOWN **))(*(_QWORD *)v62 + 136))(v36, &v59, v24, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    v39 = v53;
    v25((unsigned __int8 *)v53, v26, a2);
    v40 = &v39[*((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12)];
    v41 = v54;
    (*(void (**)(char *, char *, uint64_t))(v58 + 32))(v54, v40, v7);
    LOBYTE(v59) = 1;
    (*(void (**)(char *, uint64_t *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(_QWORD *)v38 + 232))(v41, &v59, v7, v24, v56, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    v35((unsigned __int8 *)v41, v7);
    v42 = v52;
    v25((unsigned __int8 *)v52, v26, a2);
    v43 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v7, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v44 = &v42[*((int *)v43 + 12)];
    v45 = &v42[*((int *)v43 + 16)];
    v46 = *(_QWORD *)v45;
    v47 = v45[8];
    v35((unsigned __int8 *)v44, v7);
    v61 = 2;
    v59 = v46;
    v60 = v47;
    v48 = v62;
    v49 = *(void (**)(uint64_t *, char *, void *, uint64_t, unint64_t, _UNKNOWN **))(*(_QWORD *)v62 + 232);
    v50 = lazy protocol witness table accessor for type Int? and conformance <A> A?();
    v49(&v59, &v61, &unk_1E0EACF60, v24, v50, &protocol witness table for CollectionDifference<A>.Change<A>._CodingKeys);
    return swift_release(v48);
  }
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CollectionDifference.Change<A>.encode(to:)(a1, a2, *(_QWORD *)(a3 - 8), *(_QWORD *)(a3 - 16));
}

uint64_t protocol witness for Decodable.init(from:) in conformance <A> CollectionDifference<A>.Change@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return CollectionDifference.Change<A>.init(from:)(a1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a3 - 8), *(uint64_t **)(a3 - 16), a4);
}

void CollectionDifference<A>.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t *v4;
  uint64_t v5;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(unint64_t *, char *, uint64_t, uint64_t, uint64_t, _UNKNOWN **);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  uint64_t WitnessTable;
  _QWORD v35[2];
  char v36;
  unint64_t v37;
  uint64_t v38;

  v9 = *v4;
  v33 = v4[1];
  v11 = a1[3];
  v10 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v11);
  v12 = *(_QWORD *)(a2 + 16);
  v15 = type metadata accessor for CollectionDifference.CodingKeys(0, v12, v13, v14);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v10 + 24))(&v38, v15, v15, &protocol witness table for CollectionDifference<A>.CodingKeys, v11, v10);
  v37 = v9;
  v36 = 0;
  v16 = v38;
  v17 = v12;
  v18 = *(void (**)(unint64_t *, char *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(_QWORD *)v38
                                                                                                  + 232);
  v21 = type metadata accessor for CollectionDifference.Change(255, v17, v19, v20);
  v24 = type metadata accessor for Array(0, v21, v22, v23);
  v35[0] = a3;
  v35[1] = a4;
  swift_bridgeObjectRetain(v9, v25, v26, v27);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <A> CollectionDifference<A>.Change, v21, v35);
  v28 = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v24, &WitnessTable);
  v18(&v37, &v36, v24, v15, v28, &protocol witness table for CollectionDifference<A>.CodingKeys);
  if (v5)
  {
    swift_release(v16);
    v29 = v9;
  }
  else
  {
    swift_bridgeObjectRelease(v9);
    v37 = v33;
    v36 = 1;
    swift_bridgeObjectRetain(v33, v30, v31, v32);
    v18(&v37, &v36, v24, v15, v28, &protocol witness table for CollectionDifference<A>.CodingKeys);
    swift_release(v16);
    v29 = v33;
  }
  swift_bridgeObjectRelease(v29);
}

void CollectionDifference<A>.init(from:)(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(unint64_t *__return_ptr, uint64_t, char *, uint64_t, uint64_t, uint64_t, _UNKNOWN **);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t *v32;
  uint64_t WitnessTable;
  _QWORD v35[2];
  char v36;
  unint64_t v37;

  v11 = a1[3];
  v10 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v11);
  v14 = type metadata accessor for CollectionDifference.CodingKeys(0, a2, v12, v13);
  (*(void (**)(unint64_t *__return_ptr, uint64_t, uint64_t, _UNKNOWN **, uint64_t, uint64_t))(v10 + 24))(&v37, v14, v14, &protocol witness table for CollectionDifference<A>.CodingKeys, v11, v10);
  if (v5)
  {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  else
  {
    v32 = a5;
    v17 = v37;
    v36 = 0;
    v18 = type metadata accessor for CollectionDifference.Change(255, a2, v15, v16);
    v21 = type metadata accessor for Array(0, v18, v19, v20);
    v22 = *(void (**)(unint64_t *__return_ptr, uint64_t, char *, uint64_t, uint64_t, uint64_t, _UNKNOWN **))(*(_QWORD *)v17 + 248);
    v35[0] = a3;
    v35[1] = a4;
    WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <A> CollectionDifference<A>.Change, v18, v35);
    v23 = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], v21, &WitnessTable);
    v22(&v37, v21, &v36, v21, v14, v23, &protocol witness table for CollectionDifference<A>.CodingKeys);
    v24 = v37;
    v36 = 1;
    swift_bridgeObjectRetain(v37, v25, v26, v27);
    v22(&v37, v21, &v36, v21, v14, v23, &protocol witness table for CollectionDifference<A>.CodingKeys);
    swift_release(v17);
    v28 = v37;
    *v32 = v24;
    v32[1] = v28;
    swift_bridgeObjectRetain(v28, v29, v30, v31);
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
    swift_bridgeObjectRelease(v28);
    swift_bridgeObjectRelease(v24);
  }
}

void protocol witness for Encodable.encode(to:) in conformance <A> CollectionDifference<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  CollectionDifference<A>.encode(to:)(a1, a2, *(_QWORD *)(a3 - 8), *(_QWORD *)(a3 - 16));
}

void protocol witness for Decodable.init(from:) in conformance <A> CollectionDifference<A>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  CollectionDifference<A>.init(from:)(a1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a3 - 8), *(_QWORD *)(a3 - 16), a4);
}

uint64_t (*CollectionOfOne._element.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.Iterator._elements.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v6;

  v6 = type metadata accessor for Optional(0, *(_QWORD *)(a1 + 16), a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(a4, v4, v6);
}

uint64_t CollectionOfOne.Iterator._elements.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;

  v6 = type metadata accessor for Optional(0, *(_QWORD *)(a2 + 16), a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 40))(v4, a1, v6);
}

uint64_t (*CollectionOfOne.Iterator._elements.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.Iterator.init(_elements:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 56))(a3, 1, 1, a2);
  v8 = type metadata accessor for Optional(0, a2, v6, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 40))(a3, a1, v8);
}

uint64_t CollectionOfOne.Iterator.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  v6 = *(_QWORD *)(a1 + 16);
  v7 = type metadata accessor for Optional(0, v6, a2, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 32))(a4, v4, v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 56))(v4, 1, 1, v6);
}

uint64_t CollectionOfOne.startIndex.getter()
{
  return 0;
}

uint64_t CollectionOfOne.endIndex.getter()
{
  return 1;
}

Swift::Int __swiftcall CollectionOfOne.index(after:)(Swift::Int after)
{
  if (after)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x66uLL, 0);
  return 1;
}

Swift::Int __swiftcall CollectionOfOne.index(before:)(Swift::Int before)
{
  if (before != 1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x70uLL, 0);
  return 0;
}

uint64_t CollectionOfOne.makeIterator()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  void (*v12)(char *, uint64_t, uint64_t, uint64_t);
  uint64_t v14;

  v6 = *(_QWORD *)(a1 + 16);
  v7 = type metadata accessor for Optional(0, v6, a2, a3);
  v8 = *(_QWORD *)(v7 - 8);
  MEMORY[0x1E0C80A78](v7);
  v10 = (char *)&v14 - v9;
  v11 = *(_QWORD *)(v6 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 32))((char *)&v14 - v9, v4, v6);
  v12 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v11 + 56);
  v12(v10, 0, 1, v6);
  v12(a4, 1, 1, v6);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v8 + 40))(a4, v10, v7);
}

uint64_t CollectionOfOne.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;

  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x83uLL, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8) + 16))(a3, v3);
}

uint64_t key path getter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t (*v5)();
  _BYTE v7[32];

  v4 = *(uint64_t *)((char *)a1 + a2 - 8);
  v5 = CollectionOfOne.subscript.read((uint64_t)v7, *a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(v4 - 8) + 16))(a3);
  return ((uint64_t (*)(_BYTE *, _QWORD))v5)(v7, 0);
}

uint64_t (*CollectionOfOne.subscript.read(uint64_t a1, uint64_t a2))()
{
  if (a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x83uLL, 0);
  return EnumeratedSequence._base.modify;
}

uint64_t key path setter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t (*v6)();
  uint64_t v7;
  _BYTE v9[32];

  v5 = *(uint64_t *)((char *)a3 + a4 - 8);
  v6 = CollectionOfOne.subscript.modify((uint64_t)v9, *a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 24))(v7, a1, v5);
  return ((uint64_t (*)(_BYTE *, _QWORD))v6)(v9, 0);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t WitnessTable;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  v6 = type metadata accessor for CollectionOfOne((const char *)0xFF, *(uint64_t *)((char *)a3 + a4 - 8), (uint64_t)a3, a4);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, v6, v7);
  v10 = type metadata accessor for Slice(0, v6, WitnessTable, v9);
  MEMORY[0x1E0C80A78](v10);
  v12 = (uint64_t *)((char *)&v17 - v11);
  v14 = *a3;
  v13 = a3[1];
  (*(void (**)(char *, uint64_t))(v15 + 16))((char *)&v17 - v11, a1);
  return CollectionOfOne.subscript.setter(v12, v14, v13, v6);
}

uint64_t (*CollectionOfOne.subscript.modify(uint64_t a1, uint64_t a2))()
{
  if (a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x87uLL, 0);
  return EnumeratedSequence._base.modify;
}

uint64_t CollectionOfOne.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x87uLL, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 40))(v3, a1);
}

uint64_t CollectionOfOne.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X8>)
{
  uint64_t v4;
  const char *WitnessTable;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  __int128 v13;
  _QWORD v14[2];

  v14[0] = a1;
  v14[1] = a2;
  v13 = xmmword_1816ABBD0;
  WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v14, (char *)&v13, a3, WitnessTable);
  v11 = type metadata accessor for Slice(0, a3, (uint64_t)WitnessTable, v10);
  result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 16))(&a4[*(int *)(v11 + 40)], v4, a3);
  *(_QWORD *)a4 = a1;
  *((_QWORD *)a4 + 1) = a2;
  return result;
}

uint64_t key path getter for CollectionOfOne.subscript(_:) : <A>CollectionOfOne<A>A@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = *a1;
  v6 = a1[1];
  v7 = type metadata accessor for CollectionOfOne(0, *(uint64_t *)((char *)a1 + a2 - 8), a2, a3);
  return CollectionOfOne.subscript.getter(v5, v6, v7, a4);
}

uint64_t CollectionOfOne.subscript.setter(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  const char *WitnessTable;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v20;
  _QWORD v21[2];

  v5 = v4;
  v21[0] = a2;
  v21[1] = a3;
  v20 = xmmword_1816ABBD0;
  WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, a3);
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v21, (char *)&v20, a4, WitnessTable);
  v11 = a1[1];
  v21[0] = *a1;
  *(_QWORD *)&v20 = v11;
  v13 = type metadata accessor for Slice(0, a4, (uint64_t)WitnessTable, v12);
  v14 = (char *)a1 + *(int *)(v13 + 40);
  v16 = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, v15);
  v17 = RandomAccessCollection<>.distance(from:to:)((uint64_t)v21, (uint64_t)&v20, a4, v16, (uint64_t)&protocol witness table for Int);
  if (__OFSUB__(a3, a2))
  {
    __break(1u);
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "CollectionOfOne can't be resized", 32, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x95uLL, 0);
  }
  if (a3 - a2 != v17)
    goto LABEL_8;
  if (v17 != 1)
    return (*(uint64_t (**)(_QWORD *, uint64_t))(*(_QWORD *)(v13 - 8) + 8))(a1, v13);
  v18 = *(_QWORD *)(a4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v18 + 8))(v5, a4);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v18 + 32))(v5, v14, a4);
}

void (*CollectionOfOne.subscript.modify(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t **a1, char a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v10;
  uint64_t v11;
  const char *WitnessTable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  char *v17;

  v5 = v4;
  v10 = malloc(0x60uLL);
  *a1 = v10;
  *((_QWORD *)v10 + 6) = a4;
  *((_QWORD *)v10 + 7) = v5;
  *((_QWORD *)v10 + 4) = a2;
  *((_QWORD *)v10 + 5) = a3;
  WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, v11);
  v14 = type metadata accessor for Slice(0, a4, (uint64_t)WitnessTable, v13);
  *((_QWORD *)v10 + 8) = v14;
  v15 = *(_QWORD *)(v14 - 8);
  *((_QWORD *)v10 + 9) = v15;
  v16 = *(_QWORD *)(v15 + 64);
  *((_QWORD *)v10 + 10) = malloc(v16);
  v17 = (char *)malloc(v16);
  *((_QWORD *)v10 + 11) = v17;
  *(_QWORD *)v10 = a2;
  *((_QWORD *)v10 + 1) = a3;
  *((_OWORD *)v10 + 1) = xmmword_1816ABBD0;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v10, (char *)v10 + 16, a4, WitnessTable);
  (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 16))(&v17[*(int *)(v14 + 40)], v5, a4);
  *(_QWORD *)v17 = a2;
  *((_QWORD *)v17 + 1) = a3;
  return CollectionOfOne.subscript.modify;
}

void CollectionOfOne.subscript.modify(uint64_t **a1, char a2)
{
  uint64_t *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *a1;
  v3 = (_QWORD *)(*a1)[10];
  v4 = (void *)(*a1)[11];
  if ((a2 & 1) != 0)
  {
    v5 = v2[8];
    v6 = v2[9];
    v7 = v2[6];
    v9 = v2[4];
    v8 = v2[5];
    (*(void (**)(uint64_t, void *, uint64_t))(v6 + 16))((*a1)[10], v4, v5);
    CollectionOfOne.subscript.setter(v3, v9, v8, v7);
    (*(void (**)(void *, uint64_t))(v6 + 8))(v4, v5);
  }
  else
  {
    CollectionOfOne.subscript.setter((_QWORD *)(*a1)[11], v2[4], v2[5], v2[6]);
  }
  free(v4);
  free(v3);
  free(v2);
}

uint64_t CollectionOfOne.count.getter()
{
  return 1;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance CollectionOfOne<A>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;

  if (*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x87uLL, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 40))(v3, a1);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>(_QWORD *a1, uint64_t *a2))()
{
  _QWORD *v4;

  v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = CollectionOfOne.subscript.modify((uint64_t)v4, *a2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance CollectionOfOne<A>(_QWORD *a1, uint64_t *a2, uint64_t a3)
{
  return CollectionOfOne.subscript.setter(a1, *a2, a2[1], a3);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>(_QWORD *a1, uint64_t *a2, uint64_t a3))(uint64_t **a1, char a2)
{
  uint64_t v3;
  void *v7;
  uint64_t v8;
  const char *WitnessTable;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;

  v7 = malloc(0x60uLL);
  *a1 = v7;
  *((_QWORD *)v7 + 4) = v3;
  *((_QWORD *)v7 + 5) = a3;
  WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, v8);
  v11 = type metadata accessor for Slice(0, a3, (uint64_t)WitnessTable, v10);
  *((_QWORD *)v7 + 6) = v11;
  v12 = *(_QWORD *)(v11 - 8);
  *((_QWORD *)v7 + 7) = v12;
  v13 = *(_QWORD *)(v12 + 64);
  *((_QWORD *)v7 + 8) = malloc(v13);
  v14 = (char *)malloc(v13);
  v16 = *a2;
  v15 = a2[1];
  *((_QWORD *)v7 + 9) = v14;
  *((_QWORD *)v7 + 10) = v16;
  *((_QWORD *)v7 + 11) = v15;
  *(_QWORD *)v7 = v16;
  *((_QWORD *)v7 + 1) = v15;
  *((_OWORD *)v7 + 1) = xmmword_1816ABBD0;
  specialized Collection._failEarlyRangeCheck(_:bounds:)((char *)v7, (char *)v7 + 16, a3, WitnessTable);
  (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 16))(&v14[*(int *)(v11 + 40)], v3, a3);
  *(_QWORD *)v14 = v16;
  *((_QWORD *)v14 + 1) = v15;
  return protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance CollectionOfOne<A>(uint64_t **a1, char a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *a1;
  v3 = (*a1)[10];
  v4 = (*a1)[11];
  v5 = (_QWORD *)(*a1)[8];
  v6 = (void *)(*a1)[9];
  if ((a2 & 1) != 0)
  {
    v7 = v2[6];
    v8 = v2[7];
    v9 = v2[5];
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[8], v6, v7);
    CollectionOfOne.subscript.setter(v5, v3, v4, v9);
    (*(void (**)(void *, uint64_t))(v8 + 8))(v6, v7);
  }
  else
  {
    CollectionOfOne.subscript.setter((_QWORD *)(*a1)[9], v3, v4, v2[5]);
  }
  free(v6);
  free(v5);
  free(v2);
}

_QWORD *protocol witness for MutableCollection.partition(by:) in conformance CollectionOfOne<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

_QWORD *protocol witness for BidirectionalCollection.index(before:) in conformance CollectionOfOne<A>@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  if (*result != 1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x70uLL, 0);
  *a2 = 0;
  return result;
}

_QWORD *protocol witness for BidirectionalCollection.formIndex(before:) in conformance CollectionOfOne<A>(_QWORD *result)
{
  if (*result != 1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x70uLL, 0);
  *result = 0;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance CollectionOfOne<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance CollectionOfOne<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

void protocol witness for Collection.endIndex.getter in conformance CollectionOfOne<A>(_QWORD *a1@<X8>)
{
  *a1 = 1;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance CollectionOfOne<A>(_QWORD *a1, uint64_t *a2))()
{
  _QWORD *v4;

  v4 = malloc(0x28uLL);
  *a1 = v4;
  v4[4] = CollectionOfOne.subscript.read((uint64_t)v4, *a2);
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t protocol witness for Collection.subscript.getter in conformance CollectionOfOne<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  return CollectionOfOne.subscript.getter(*a1, a1[1], a2, a3);
}

uint64_t protocol witness for Collection.indices.getter in conformance CollectionOfOne<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

_QWORD *protocol witness for Collection.index(after:) in conformance CollectionOfOne<A>@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  if (*result)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x66uLL, 0);
  *a2 = 1;
  return result;
}

_QWORD *protocol witness for Collection.formIndex(after:) in conformance CollectionOfOne<A>(_QWORD *result)
{
  if (*result)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/CollectionOfOne.swift", 27, 2, 0x66uLL, 0);
  *result = 1;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t CollectionOfOne.debugDescription.getter(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  char *v19;
  Swift::Int v20;
  BOOL v21;
  Swift::Int v22;
  uint64_t v23;
  int64_t v24;
  char v25;
  int64_t v26;
  char v27;
  BOOL v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  size_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  unsigned __int8 *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  Swift::String::Index v44;
  Swift::String::Index v45;
  Swift::String::Index v46;
  Swift::String::Index v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  char v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  char v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  char *v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  char *v83;
  Swift::Int v84;
  uint64_t v85;
  uint64_t v86;
  int64_t v87;
  char v88;
  int64_t v89;
  char v90;
  BOOL v91;
  BOOL v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  Swift::String::Index v96;
  Swift::String::Index v97;
  unint64_t v98;
  Swift::String::Index v99;
  Swift::String::Index v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  char v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  char v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  char *v117;
  unint64_t v118;
  unint64_t v119;
  uint64_t v120;
  char v121;
  uint64_t v122;
  uint64_t v123;
  char *v124;
  size_t v125;
  char v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  char v133;
  uint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  char *v138;
  size_t v139;
  id v140;
  uint64_t v141;
  uint64_t v142;
  char *v143;
  size_t v144;
  unint64_t v145;
  unint64_t v146;
  int64_t v147;
  char v148;
  BOOL v150;
  uint64_t v151;
  uint64_t v152;
  char *v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  Swift::String::Index v157;
  Swift::String::Index v158;
  Swift::String::Index v159;
  Swift::String::Index v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  char v168;
  char *v169;
  size_t v170;
  Swift::String::Index v172;
  Swift::String::Index v173;
  Swift::String::Index v174;
  Swift::String::Index v175;
  Swift::Int v176;
  Swift::String::Index v177;
  Swift::String::Index v178;
  Swift::String::Index v179;
  Swift::String::Index v180;
  Swift::Int v181;
  Swift::Int v182;
  unsigned __int8 *v183;
  uint64_t v184;
  unsigned __int8 *v185;
  uint64_t v186;
  unsigned __int8 *v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t v193;
  unint64_t v194;
  unint64_t v195;
  uint64_t v196;
  unint64_t v197;
  __int128 v198;
  unint64_t v199;
  unint64_t v200;

  v3 = v1;
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(v4 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (uint64_t)&v196 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = specialized static String._createEmpty(withInitialCapacity:)(19);
  v12 = v8;
  v13 = v9;
  v199 = v8;
  v200 = v9;
  v14 = HIBYTE(v9) & 0xF;
  v15 = v8 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0x2000000000000000) != 0)
    v16 = HIBYTE(v9) & 0xF;
  else
    v16 = v8 & 0xFFFFFFFFFFFFLL;
  if (!v16 && (v8 & ~v9 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v9);
    v65 = 0x8000000181763B70 | 0x8000000000000000;
    v199 = 0xD000000000000010;
LABEL_85:
    v200 = v65;
    goto LABEL_86;
  }
  if ((v9 & 0x2000000000000000) != 0 && (0x8000000181763B70 & 0x2000000000000000) != 0)
  {
    v2 = v14 + ((0x8000000181763B70 >> 56) & 0xF);
    if (v2 <= 0xF)
    {
      v42 = (0x8000000181763B70 >> 56) & 0xF;
      if (v42)
      {
        v66 = 0;
        v67 = 0;
        v43 = v9;
        do
        {
          v68 = v14 + v67;
          v69 = v67 + 1;
          v70 = 0x8000000181763B70 | 0x8000000000000000;
          if (v67 < 8)
            v70 = 0xD000000000000010;
          v71 = v70 >> (v66 & 0x38);
          v72 = (8 * v14 + v66) & 0x38;
          v73 = (-255 << v72) - 1;
          v74 = (unint64_t)v71 << v72;
          v75 = v74 | v73 & v43;
          v76 = v74 | v73 & v12;
          if (v68 < 8)
            v12 = v76;
          else
            v43 = v75;
          v66 += 8;
          v67 = v69;
        }
        while (v42 != v69);
      }
      else
      {
        v43 = v9;
      }
      swift_bridgeObjectRelease(v9);
      swift_bridgeObjectRelease(0x8000000181763B70 | 0x8000000000000000);
      v77 = 0xA000000000000000;
      if (!(v12 & 0x8080808080808080 | v43 & 0x80808080808080))
        v77 = 0xE000000000000000;
      v65 = v77 & 0xFF00000000000000 | (v2 << 56) | v43 & 0xFFFFFFFFFFFFFFLL;
      v199 = v12;
      goto LABEL_85;
    }
  }
  v197 = v3;
  v17 = (const char *)(0x8000000181763B70 | 0x8000000000000000);
  if ((0x8000000181763B70 & 0x2000000000000000) != 0)
    v2 = (0x8000000181763B70 >> 56) & 0xF;
  else
    v2 = 16;
  swift_bridgeObjectRetain_n(0x8000000181763B70 | 0x8000000000000000, 2, v10, v11);
  if ((0x8000000181763B70 & 0x1000000000000000) != 0)
    goto LABEL_208;
  swift_bridgeObjectRetain_n(0x8000000181763B70 | 0x8000000000000000, 4, v18, v19);
  v20 = v2;
  if ((v13 & 0x1000000000000000) != 0)
    goto LABEL_211;
LABEL_14:
  v21 = __OFADD__(v16, v20);
  v22 = v16 + v20;
  if (v21)
  {
LABEL_213:
    __break(1u);
    goto LABEL_214;
  }
LABEL_15:
  v23 = v12 & ~v13;
  if ((v23 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
  {
    v24 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
    if ((v25 & 1) != 0)
      goto LABEL_236;
    if (v22 <= 15)
    {
      if ((v13 & 0x2000000000000000) != 0)
        goto LABEL_56;
      if (v24 < v20)
        goto LABEL_48;
    }
  }
  else if (v22 <= 15)
  {
    if ((v13 & 0x2000000000000000) != 0)
    {
LABEL_56:
      v17 = "CollectionOfOne(";
      swift_bridgeObjectRelease_n(0x8000000181763B70 | 0x8000000000000000, 5);
      v41 = v13;
      goto LABEL_57;
    }
LABEL_48:
    v17 = "CollectionOfOne(";
    swift_bridgeObjectRelease_n(0x8000000181763B70 | 0x8000000000000000, 5);
    if ((v13 & 0x1000000000000000) == 0)
    {
      if ((v12 & 0x1000000000000000) != 0)
      {
        v40 = (unsigned __int8 *)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        v40 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v12, v13);
        v15 = v37;
      }
      swift_bridgeObjectRetain(v13, v37, v38, v39);
      closure #1 in _StringGuts._convertedToSmall()(v40, v15, &v198);
      swift_bridgeObjectRelease(v13);
      v41 = *((_QWORD *)&v198 + 1);
      v12 = v198;
      goto LABEL_57;
    }
    goto LABEL_231;
  }
  v26 = _StringGuts.nativeUnusedCapacity.getter(v12, v13);
  v29 = (v27 & 1) == 0 && v26 >= v20;
  if ((v23 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
  {
    v3 = v197;
    v17 = "CollectionOfOne(";
    if (v29)
      goto LABEL_41;
  }
  else
  {
    v3 = v197;
    v17 = "CollectionOfOne(";
    if (v29)
      goto LABEL_40;
  }
  v30 = _StringGuts.nativeCapacity.getter(v12, v13);
  if ((v31 & 1) != 0)
    v32 = 0;
  else
    v32 = v30;
  if (v32 + 0x4000000000000000 >= 0)
  {
    v33 = 2 * v32;
    if (v33 > v22)
      v22 = v33;
LABEL_40:
    _StringGuts.grow(_:)(v22);
LABEL_41:
    v34 = 0x8000000181763B70 | 0x8000000000000000;
    swift_bridgeObjectRelease_n(0x8000000181763B70 | 0x8000000000000000, 4);
    if ((0x8000000181763B70 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(0x8000000181763B70 | 0x8000000000000000);
      _StringGuts._foreignAppendInPlace(_:)(0xD000000000000010, 0x8000000181763B70 | 0x8000000000000000, 0, v2);
    }
    else
    {
      if ((0x8000000181763B70 & 0x2000000000000000) != 0)
        v12 = (v34 >> 62) & 1;
      else
        v12 = 1;
      swift_bridgeObjectRelease(0x8000000181763B70 | 0x8000000000000000);
      if ((0x8000000181763B70 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(0x8000000181763B70 | 0x8000000000000000);
        *(_QWORD *)&v198 = 0xD000000000000010;
        *((_QWORD *)&v198 + 1) = 0x8000000181763B70 & 0xFFFFFFFFFFFFFFLL;
        v138 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v2, (uint64_t)&v198, (0x8000000181763B70 >> 56) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v138, v139, v12);
        swift_bridgeObjectRelease(0x8000000181763B70 | 0x8000000000000000);
        goto LABEL_86;
      }
      v34 = 0x8000000181763B70 | 0x8000000000000000;
      v35 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v2, (0x8000000181763B70 & 0xFFFFFFFFFFFFFFFLL) + 32, 16);
      _StringGuts.appendInPlace(_:isASCII:)(v35, v36, v12);
    }
    swift_bridgeObjectRelease_n(v34, 2);
    goto LABEL_86;
  }
  while (1)
  {
    __break(1u);
LABEL_231:
    v12 = _StringGuts._foreignConvertedToSmall()(v12, v13);
    v41 = v188;
LABEL_57:
    v44._rawBits = (v2 << 16) | 1;
    v45._rawBits = 1;
    v46._rawBits = _StringGuts.validateScalarRange(_:)(v45, v44, 0xD000000000000010, (unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    if (v46._rawBits < 0x10000)
      v46._rawBits |= 3;
    v48 = specialized String.init(_:)(v46, v47, 0xD000000000000010, (unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    v2 = v49;
    swift_bridgeObjectRelease((unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    if ((v2 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v2);
    }
    else if ((v2 & 0x1000000000000000) != 0)
    {
      v48 = _StringGuts._foreignConvertedToSmall()(v48, v2);
      v194 = v193;
      swift_bridgeObjectRelease(v2);
      v2 = v194;
    }
    else
    {
      if ((v48 & 0x1000000000000000) != 0)
      {
        v185 = (unsigned __int8 *)((v2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v186 = v48 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v185 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v48, v2);
      }
      closure #1 in _StringGuts._convertedToSmall()(v185, v186, &v198);
      swift_bridgeObjectRelease(v2);
      v2 = *((_QWORD *)&v198 + 1);
      v48 = v198;
    }
    v50 = HIBYTE(v41) & 0xF;
    v51 = HIBYTE(v2) & 0xF;
    v52 = v51 + v50;
    if ((unint64_t)(v51 + v50) > 0xF)
      goto LABEL_235;
    if (v51)
    {
      v53 = 0;
      v54 = 0;
      do
      {
        v55 = v50 + v54;
        v56 = v54 + 1;
        if (v54 >= 8)
          v57 = v2;
        else
          v57 = v48;
        v58 = v57 >> (v53 & 0x38);
        v59 = (8 * v50 + v53) & 0x38;
        v60 = (-255 << v59) - 1;
        v61 = (unint64_t)v58 << v59;
        v62 = v61 | v60 & v41;
        v63 = v61 | v60 & v12;
        if (v55 < 8)
          v12 = v63;
        else
          v41 = v62;
        v53 += 8;
        v54 = v56;
      }
      while (v51 != v56);
    }
    swift_bridgeObjectRelease(v13);
    swift_bridgeObjectRelease((unint64_t)(v17 + 0x7FFFFFFFFFFFFFE0) | 0x8000000000000000);
    v64 = 0xA000000000000000;
    if (!(v12 & 0x8080808080808080 | v41 & 0x80808080808080))
      v64 = 0xE000000000000000;
    v199 = v12;
    v200 = v64 & 0xFF00000000000000 | (v52 << 56) | v41 & 0xFFFFFFFFFFFFFFLL;
    v3 = v197;
LABEL_86:
    (*(void (**)(uint64_t, unint64_t, unint64_t))(v5 + 16))(v7, v3, v4);
    *(_QWORD *)&v198 = 0;
    *((_QWORD *)&v198 + 1) = 0xE000000000000000;
    _debugPrint_unlocked<A, B>(_:_:)(v7, (uint64_t)&v198, (Class *)v4, (uint64_t)&type metadata for String, (uint64_t)&protocol witness table for String);
    (*(void (**)(uint64_t, unint64_t))(v5 + 8))(v7, v4);
    v4 = *((_QWORD *)&v198 + 1);
    v5 = v198;
    v7 = v199;
    v13 = v200;
    v80 = HIBYTE(v200) & 0xF;
    v16 = v199 & 0xFFFFFFFFFFFFLL;
    if ((v200 & 0x2000000000000000) != 0)
      v81 = HIBYTE(v200) & 0xF;
    else
      v81 = v199 & 0xFFFFFFFFFFFFLL;
    if (!v81 && (v199 & ~v200 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v200);
      v199 = v5;
      v200 = v4;
      goto LABEL_171;
    }
    v15 = *((_QWORD *)&v198 + 1) & 0x2000000000000000;
    v2 = HIBYTE(*((_QWORD *)&v198 + 1)) & 0xFLL;
    if ((v200 & 0x2000000000000000) != 0 && v15)
    {
      v12 = v80 + v2;
      if (v80 + v2 <= 0xF)
      {
        if (v2)
        {
          v126 = 0;
          v127 = 0;
          v128 = v200;
          do
          {
            v129 = v80 + v127;
            v130 = v127 + 1;
            if (v127 >= 8)
              v131 = *((_QWORD *)&v198 + 1);
            else
              v131 = v198;
            v132 = v131 >> (v126 & 0x38);
            v133 = (8 * v80 + v126) & 0x38;
            v134 = (-255 << v133) - 1;
            v135 = (unint64_t)v132 << v133;
            v136 = v135 | v134 & v128;
            v137 = v135 | v134 & v7;
            if (v129 < 8)
              v7 = v137;
            else
              v128 = v136;
            v126 += 8;
            v127 = v130;
          }
          while (v2 != v130);
        }
        else
        {
          v128 = v200;
        }
        swift_bridgeObjectRelease(v200);
        swift_bridgeObjectRelease(v4);
        v145 = 0xA000000000000000;
        if (!(v7 & 0x8080808080808080 | v128 & 0x80808080808080))
          v145 = 0xE000000000000000;
        v119 = v145 & 0xFF00000000000000 | (v12 << 56) | v128 & 0xFFFFFFFFFFFFFFLL;
        goto LABEL_170;
      }
      v15 = 1;
    }
    v196 = v198 & 0xFFFFFFFFFFFFLL;
    v12 = v15 ? HIBYTE(*((_QWORD *)&v198 + 1)) & 0xFLL : v198 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(*((uint64_t *)&v198 + 1), 2, v78, v79);
    if ((v4 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain_n(v4, 5, v82, v83);
      v172._rawBits = 1;
      v173._rawBits = (v12 << 16) | 1;
      v174._rawBits = _StringGuts.validateScalarRange(_:)(v172, v173, v5, v4);
      if (v174._rawBits < 0x10000)
        v174._rawBits |= 3;
      v17 = (const char *)specialized Collection.count.getter(v174, v175, v5, v4);
      swift_bridgeObjectRelease(v4);
      if ((v13 & 0x1000000000000000) == 0)
      {
LABEL_100:
        v21 = __OFADD__(v81, v17);
        v84 = (Swift::Int)&v17[v81];
        if (v21)
          goto LABEL_207;
        goto LABEL_101;
      }
    }
    else
    {
      swift_bridgeObjectRetain_n(v4, 4, v82, v83);
      v17 = (const char *)v12;
      if ((v13 & 0x1000000000000000) == 0)
        goto LABEL_100;
    }
    v176 = String.UTF8View._foreignCount()();
    v84 = (Swift::Int)&v17[v176];
    if (__OFADD__(v176, v17))
    {
LABEL_207:
      __break(1u);
LABEL_208:
      swift_bridgeObjectRetain_n((uint64_t)v17, 5, v18, v19);
      v177._rawBits = 1;
      v178._rawBits = (v2 << 16) | 1;
      v179._rawBits = _StringGuts.validateScalarRange(_:)(v177, v178, 0xD000000000000010, (unint64_t)v17);
      if (v179._rawBits < 0x10000)
        v179._rawBits |= 3;
      v20 = specialized Collection.count.getter(v179, v180, 0xD000000000000010, (unint64_t)v17);
      swift_bridgeObjectRelease((uint64_t)v17);
      if ((v13 & 0x1000000000000000) == 0)
        goto LABEL_14;
LABEL_211:
      v181 = String.UTF8View._foreignCount()();
      v22 = v181 + v20;
      if (__OFADD__(v181, v20))
        goto LABEL_213;
      goto LABEL_15;
    }
LABEL_101:
    v197 = v5;
    v85 = v12;
    v86 = v7 & ~v13;
    if ((v86 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v84 > 15)
        goto LABEL_107;
LABEL_118:
      swift_bridgeObjectRelease_n(v4, 5);
      if ((v13 & 0x2000000000000000) != 0)
      {
LABEL_119:
        v2 = v13;
      }
      else if ((v13 & 0x1000000000000000) != 0)
      {
        v7 = _StringGuts._foreignConvertedToSmall()(v7, v13);
        v2 = v195;
      }
      else
      {
        if ((v7 & 0x1000000000000000) != 0)
        {
          v187 = (unsigned __int8 *)((v13 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          v187 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, v13);
          v16 = v93;
        }
        swift_bridgeObjectRetain(v13, v93, v94, v95);
        closure #1 in _StringGuts._convertedToSmall()(v187, v16, &v198);
        swift_bridgeObjectRelease(v13);
        v2 = *((_QWORD *)&v198 + 1);
        v7 = v198;
      }
      v96._rawBits = (v85 << 16) | 1;
      v97._rawBits = 1;
      v98 = v197;
      v99._rawBits = _StringGuts.validateScalarRange(_:)(v97, v96, v197, v4);
      if (v99._rawBits < 0x10000)
        v99._rawBits |= 3;
      v12 = specialized String.init(_:)(v99, v100, v98, v4);
      v5 = v101;
      swift_bridgeObjectRelease(v4);
      if ((v5 & 0x2000000000000000) == 0)
        goto LABEL_217;
      swift_bridgeObjectRelease(v5);
      goto LABEL_124;
    }
    v87 = _StringGuts.nativeUnusedCapacity.getter(v7, v13);
    if ((v88 & 1) != 0)
      goto LABEL_236;
    if (v84 > 15)
      goto LABEL_107;
    if ((v13 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease_n(v4, 5);
      goto LABEL_119;
    }
    if (v87 < (uint64_t)v17)
      goto LABEL_118;
LABEL_107:
    v89 = _StringGuts.nativeUnusedCapacity.getter(v7, v13);
    v91 = (v90 & 1) != 0 || v89 < (uint64_t)v17;
    v92 = !v91;
    if ((v86 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v13 & 0xFFFFFFFFFFFFFFFLL))
    {
      v12 = v85;
      v5 = v197;
      if (v92)
        goto LABEL_145;
    }
    else
    {
      v12 = v85;
      v5 = v197;
      if (v92)
        goto LABEL_144;
    }
    v120 = _StringGuts.nativeCapacity.getter(v7, v13);
    v122 = (v121 & 1) != 0 ? 0 : v120;
    if (v122 + 0x4000000000000000 >= 0)
      break;
    __break(1u);
  }
  v123 = 2 * v122;
  if (v123 > v84)
    v84 = v123;
LABEL_144:
  _StringGuts.grow(_:)(v84);
LABEL_145:
  swift_bridgeObjectRelease_n(v4, 4);
  if ((v4 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v4);
    _StringGuts._foreignAppendInPlace(_:)(v5, v4, 0, v12);
  }
  else
  {
    if (v15)
    {
      swift_bridgeObjectRelease_n(v4, 2);
      *(_QWORD *)&v198 = v5;
      *((_QWORD *)&v198 + 1) = v4 & 0xFFFFFFFFFFFFFFLL;
      v124 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v4) & 0xF, (uint64_t)&v198, HIBYTE(v4) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v124, v125, (v4 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(v4);
      goto LABEL_171;
    }
    if ((v5 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v4);
      v140 = (id)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v141 = v196;
      v142 = v196;
    }
    else
    {
      v140 = _StringObject.sharedUTF8.getter(v5, v4);
      v142 = v189;
      swift_bridgeObjectRelease(v4);
      if (v142 < v196)
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
      v141 = v196;
      v5 = v197;
    }
    v143 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v141, (uint64_t)v140, v142);
    _StringGuts.appendInPlace(_:isASCII:)(v143, v144, v5 < 0);
  }
  swift_bridgeObjectRelease_n(v4, 2);
  while (1)
  {
LABEL_171:
    v13 = v199;
    v4 = v200;
    v5 = HIBYTE(v200) & 0xF;
    if ((v200 & 0x2000000000000000) != 0)
      v146 = HIBYTE(v200) & 0xF;
    else
      v146 = v199 & 0xFFFFFFFFFFFFLL;
    if (!v146 && (v199 & ~v200 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v200);
      return 41;
    }
    if ((v200 & 0x2000000000000000) != 0 && v5 != 15)
      break;
    swift_bridgeObjectRetain_n(0xE100000000000000, 6, v116, v117);
    if ((v4 & 0x1000000000000000) != 0)
    {
LABEL_214:
      v182 = String.UTF8View._foreignCount()();
      v7 = v182 + 1;
      if (!__OFADD__(v182, 1))
      {
LABEL_183:
        if ((v13 & ~v4 & 0x2000000000000000) == 0
          || !swift_isUniquelyReferenced_nonNull_native(v4 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v7 <= 15)
            goto LABEL_194;
          goto LABEL_199;
        }
        v147 = _StringGuts.nativeUnusedCapacity.getter(v13, v4);
        if ((v148 & 1) == 0)
        {
          v150 = (v4 & 0x2000000000000000) == 0 && v147 > 0;
          if (v7 <= 15 && !v150)
          {
LABEL_194:
            swift_bridgeObjectRelease_n(0xE100000000000000, 5);
            swift_bridgeObjectRetain(v4, v151, v152, v153);
            v154 = _StringGuts._convertedToSmall()(v13, v4);
            v156 = v155;
            swift_bridgeObjectRelease(v4);
            v157._rawBits = 1;
            v158._rawBits = 65537;
            v159._rawBits = _StringGuts.validateScalarRange(_:)(v157, v158, 0x29uLL, 0xE100000000000000);
            if (v159._rawBits < 0x10000)
              v159._rawBits |= 3;
            v161 = specialized String.init(_:)(v159, v160, 0x29uLL, 0xE100000000000000);
            v163 = v162;
            swift_bridgeObjectRelease(0xE100000000000000);
            v164 = _StringGuts._convertedToSmall()(v161, v163);
            v166 = v165;
            swift_bridgeObjectRelease(v163);
            v167 = specialized _SmallString.init(_:appending:)(v154, v156, v164, v166);
            if ((v168 & 1) == 0)
            {
              v13 = v167;
              swift_bridgeObjectRelease(v4);
              swift_bridgeObjectRelease(0xE100000000000000);
              return v13;
            }
LABEL_235:
            v190 = 266;
LABEL_237:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v190, 0);
          }
LABEL_199:
          _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v7, 1);
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          v198 = xmmword_1816ABCE0;
          v169 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v198, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v169, v170, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v199;
        }
LABEL_236:
        v190 = 258;
        goto LABEL_237;
      }
    }
    else
    {
      v21 = __OFADD__(v146, 1);
      v7 = v146 + 1;
      if (!v21)
        goto LABEL_183;
    }
    __break(1u);
LABEL_217:
    if ((v5 & 0x1000000000000000) != 0)
    {
      v12 = _StringGuts._foreignConvertedToSmall()(v12, v5);
      v192 = v191;
      swift_bridgeObjectRelease(v5);
      v5 = v192;
    }
    else
    {
      if ((v12 & 0x1000000000000000) != 0)
      {
        v183 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v184 = v12 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v183 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v12, v5);
      }
      closure #1 in _StringGuts._convertedToSmall()(v183, v184, &v198);
      swift_bridgeObjectRelease(v5);
      v5 = *((_QWORD *)&v198 + 1);
      v12 = v198;
    }
LABEL_124:
    v102 = HIBYTE(v2) & 0xF;
    v103 = HIBYTE(v5) & 0xF;
    v104 = v103 + v102;
    if ((unint64_t)(v103 + v102) > 0xF)
      goto LABEL_235;
    if (v103)
    {
      v105 = 0;
      v106 = 0;
      do
      {
        v107 = v102 + v106;
        v108 = v106 + 1;
        if (v106 >= 8)
          v109 = v5;
        else
          v109 = v12;
        v110 = v109 >> (v105 & 0x38);
        v111 = (8 * v102 + v105) & 0x38;
        v112 = (-255 << v111) - 1;
        v113 = (unint64_t)v110 << v111;
        v114 = v113 | v112 & v2;
        v115 = v113 | v112 & v7;
        if (v107 < 8)
          v7 = v115;
        else
          v2 = v114;
        v105 += 8;
        v106 = v108;
      }
      while (v103 != v108);
    }
    swift_bridgeObjectRelease(v13);
    swift_bridgeObjectRelease(v4);
    v118 = 0xA000000000000000;
    if (!(v7 & 0x8080808080808080 | v2 & 0x80808080808080))
      v118 = 0xE000000000000000;
    v119 = v118 & 0xFF00000000000000 | (v104 << 56) | v2 & 0xFFFFFFFFFFFFFFLL;
LABEL_170:
    v199 = v7;
    v200 = v119;
  }
  if ((unint64_t)v5 < 8)
    v13 = (41 << (8 * (HIBYTE(v200) & 7u))) | ((-255 << (8 * (HIBYTE(v200) & 7u))) - 1) & v199;
  swift_bridgeObjectRelease(v200);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v13;
}

uint64_t CollectionOfOne.customMirror.getter@<X0>(swift *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *boxed_opaque_existential_0Tm;
  double (*v15)@<D0>(uint64_t@<X8>);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  void (*v24)(uint64_t *, char *, swift *);
  uint64_t *v25;
  Class *v26;
  uint64_t result;
  char v28;
  uint64_t *v29;
  uint64_t v30[5];

  v3 = v2;
  v6 = *((_QWORD *)a1 - 1);
  v7 = MEMORY[0x1E0C80A78](a1);
  v29 = (uint64_t *)((char *)&v30[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v7);
  v10 = (char *)&v30[-1] - v9;
  (*(void (**)(char *, uint64_t, swift *))(v6 + 16))((char *)&v30[-1] - v9, v3, a1);
  v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<(String, Any)>);
  v12 = swift_allocObject(v11, 0x50uLL, 7uLL);
  *((_OWORD *)v12 + 1) = xmmword_1816ABBA0;
  v12[4] = 0x746E656D656C65;
  v12[5] = 0xE700000000000000;
  v13 = *((_QWORD *)a1 + 2);
  v12[9] = v13;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v12 + 6);
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 16))(boxed_opaque_existential_0Tm, v3, v13);
  v30[0] = 0;
  v30[1] = 0;
  v15 = static Mirror._superclassIterator<A>(_:_:)((uint64_t)v10, (uint64_t)v30, a1);
  v17 = v16;
  v18 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _RandomAccessCollectionBox<LazyMapSequence<KeyValuePairs<String, Any>, (label: String?, value: Any)>>);
  v19 = swift_allocObject(v18, 0x48uLL, 7uLL);
  v19[6] = v12;
  v19[7] = closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:);
  v19[8] = 0;
  v20 = canonical specialized generic type metadata accessor for _IndexBox<Int>();
  v21 = swift_allocObject(v20, 0x18uLL, 7uLL);
  v21[2] = 0;
  v22 = v12[2];
  v23 = swift_allocObject(v20, 0x18uLL, 7uLL);
  v23[2] = v22;
  v19[2] = v21;
  v19[3] = &protocol witness table for _IndexBox<A>;
  v19[4] = v23;
  v19[5] = &protocol witness table for _IndexBox<A>;
  v24 = *(void (**)(uint64_t *, char *, swift *))(v6 + 32);
  v25 = v29;
  v24(v29, v10, a1);
  v26 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomLeafReflectable);
  result = swift_dynamicCast((char *)v30, v25, (Class *)a1, v26, 6uLL);
  v28 = result;
  if ((_DWORD)result)
    result = __swift_destroy_boxed_opaque_existential_1Tm(v30);
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = v19;
  *(_BYTE *)(a2 + 16) = 8;
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)(a2 + 32) = v17;
  *(_BYTE *)(a2 + 40) = v28;
  return result;
}

Swift::Int CollectionDifference._fastEnumeratedApply(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  Swift::Int result;
  int64_t v26;
  int64_t v27;
  uint64_t v28;
  BOOL v29;
  unint64_t *v30;
  BOOL v31;
  BOOL v32;
  unint64_t v33;
  char *v34;
  BOOL v35;
  uint64_t *v36;
  char *v37;
  void (*v38)(char *, char *, uint64_t *);
  uint64_t v39;
  char *v40;
  char v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  void (*v46)(char *, char *, uint64_t *);
  uint64_t *v47;
  uint64_t v48;
  unint64_t *TupleTypeMetadata3;
  uint64_t v50;
  _BOOL4 v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  BOOL v55;
  char v56;
  uint64_t v57;
  void (*v58)(char *, unint64_t, uint64_t *);
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  id v62;
  id v63;
  void *v64;
  char *v65;
  char *v66;
  char *v67;
  id v68;
  char *v69;
  _QWORD v70[2];
  char *v71;
  char *v72;
  char *v73;
  char *v74;
  char *v75;
  void (*v76)(char *, uint64_t);
  uint64_t v77;
  unint64_t v78;
  void (*v79)(char *, unint64_t, uint64_t *);
  unint64_t v80;
  uint64_t v81;
  char *v82;
  Swift::Int v83;
  Swift::Int v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;

  v5 = v4;
  v7 = *(_QWORD *)(a2 + 16);
  v8 = (uint64_t *)type metadata accessor for CollectionDifference.Change(0, v7, a3, a4);
  v9 = *(v8 - 1);
  v10 = MEMORY[0x1E0C80A78](v8);
  v12 = (char *)v70 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v72 = (char *)v70 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v71 = (char *)v70 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v73 = (char *)v70 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v74 = (char *)v70 - v20;
  v70[0] = v21;
  MEMORY[0x1E0C80A78](v19);
  v82 = (char *)v70 - v22;
  v23 = *v5;
  v24 = v5[1];
  v84 = Array._getCount()();
  result = Array._getCount()();
  v83 = result;
  v26 = 0;
  v27 = 0;
  v80 = v23 & 0xC000000000000001;
  v81 = v23;
  v28 = v7;
  v77 = v7;
  v78 = v24 & 0xC000000000000001;
  v85 = v24;
  v70[1] = a1;
  v75 = v12;
  while (1)
  {
    if (v27 >= v84)
    {
      if (v26 >= v83)
        return result;
      v55 = v80 == 0;
      v56 = v55 | ~_swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
      v57 = v81;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v56 & 1);
      if ((v56 & 1) == 0)
      {
        v62 = _ArrayBuffer._getElementSlowPath(_:)(v26, v57, v8);
        v63 = v62;
        if (v70[0] != 8)
          goto LABEL_49;
        v45 = v12;
        v87 = (char *)v62;
        v54 = (uint64_t)v82;
        (*(void (**)(char *, char **, uint64_t *))(v9 + 16))(v82, &v87, v8);
        v64 = v63;
        goto LABEL_39;
      }
      v54 = (uint64_t)v82;
      (*(void (**)(char *, unint64_t, uint64_t *))(v9 + 16))(v82, v57+ ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))+ *(_QWORD *)(v9 + 72) * v26, v8);
      v28 = v77;
      v45 = v12;
    }
    else
    {
      v31 = v78 == 0;
      v32 = !_swift_isClassOrObjCExistentialType((uint64_t)v8, v8) || v31;
      Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v32);
      if (v26 >= v83)
      {
        if (v32)
        {
          v54 = (uint64_t)v82;
          (*(void (**)(char *, unint64_t, uint64_t *))(v9 + 16))(v82, v85+ ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))+ *(_QWORD *)(v9 + 72) * v27, v8);
          v45 = v12;
        }
        else
        {
          v67 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v85, v8);
          v45 = v67;
          if (v70[0] != 8)
            goto LABEL_48;
          v87 = v67;
          v54 = (uint64_t)v82;
          (*(void (**)(char *, char **, uint64_t *))(v9 + 16))(v82, &v87, v8);
          swift_unknownObjectRelease(v45);
          v45 = v12;
        }
      }
      else
      {
        if (v32)
        {
          v33 = v85
              + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
              + *(_QWORD *)(v9 + 72) * v27;
          v34 = v74;
          v79 = *(void (**)(char *, unint64_t, uint64_t *))(v9 + 16);
          v79(v74, v33, v8);
        }
        else
        {
          v65 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v85, v8);
          v45 = v65;
          if (v70[0] != 8)
            goto LABEL_48;
          v87 = v65;
          v34 = v74;
          v79 = *(void (**)(char *, unint64_t, uint64_t *))(v9 + 16);
          v79(v74, (unint64_t)&v87, v8);
          swift_unknownObjectRelease(v45);
        }
        v35 = v80 == 0;
        v36 = (uint64_t *)v73;
        v37 = v34;
        v38 = *(void (**)(char *, char *, uint64_t *))(v9 + 32);
        v38(v73, v37, v8);
        v39 = *v36;
        v40 = (char *)v36
            + *((int *)swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v28, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0)+ 12);
        v76 = *(void (**)(char *, uint64_t))(*(_QWORD *)(v28 - 8) + 8);
        v76(v40, v28);
        v41 = v35 | ~_swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
        v42 = v81;
        Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v41 & 1);
        if ((v41 & 1) != 0)
        {
          v43 = v42
              + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
              + *(_QWORD *)(v9 + 72) * v26;
          v44 = v71;
          v79(v71, v43, v8);
        }
        else
        {
          v66 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v26, v42, v8);
          v45 = v66;
          if (v70[0] != 8)
            goto LABEL_48;
          v87 = v66;
          v44 = v71;
          v79(v71, (unint64_t)&v87, v8);
          swift_unknownObjectRelease(v45);
        }
        v45 = v75;
        v46 = v38;
        v47 = (uint64_t *)v72;
        v46(v72, v44, v8);
        v48 = *v47;
        TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v28, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
        v76((char *)v47 + *((int *)TupleTypeMetadata3 + 12), v28);
        if (__OFSUB__(v39, v27))
          goto LABEL_46;
        v29 = __OFSUB__(v48, v26);
        v50 = v48 - v26;
        if (v29)
          goto LABEL_47;
        v51 = !_swift_isClassOrObjCExistentialType((uint64_t)v8, v8);
        if (v50 < v39 - v27)
        {
          v52 = v81;
          v53 = v51 || v80 == 0;
          Array._checkSubscript(_:wasNativeTypeChecked:)(v26, v51 || v80 == 0);
          if (v53)
          {
            v54 = (uint64_t)v82;
            v79(v82, v52+ ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))+ *(_QWORD *)(v9 + 72) * v26, v8);
LABEL_15:
            v28 = v77;
            goto LABEL_24;
          }
          v62 = _ArrayBuffer._getElementSlowPath(_:)(v26, v52, v8);
          v68 = v62;
          if (v70[0] != 8)
            goto LABEL_49;
          v87 = (char *)v62;
          v54 = (uint64_t)v82;
          v79(v82, (unint64_t)&v87, v8);
          v64 = v68;
LABEL_39:
          swift_unknownObjectRelease(v64);
          goto LABEL_15;
        }
        v58 = v79;
        v59 = v51 || v78 == 0;
        v60 = v85;
        Array._checkSubscript(_:wasNativeTypeChecked:)(v27, v51 || v78 == 0);
        if (v59)
        {
          v54 = (uint64_t)v82;
          v58(v82, v60+ ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))+ *(_QWORD *)(v9 + 72) * v27, v8);
        }
        else
        {
          v69 = (char *)_ArrayBuffer._getElementSlowPath(_:)(v27, v60, v8);
          v45 = v69;
          if (v70[0] != 8)
            goto LABEL_48;
          v87 = v69;
          v54 = (uint64_t)v82;
          v58(v82, (unint64_t)&v87, v8);
          swift_unknownObjectRelease(v45);
        }
        v45 = v75;
      }
    }
LABEL_24:
    v61 = v86;
    partial apply for closure #1 in RangeReplaceableCollection.applying(_:)(v54);
    v86 = v61;
    if (v61)
      return (*(uint64_t (**)(uint64_t, uint64_t *))(v9 + 8))(v54, v8);
    (*(void (**)(char *, uint64_t, uint64_t *))(v9 + 32))(v45, v54, v8);
    if (swift_getEnumCaseMultiPayload((unsigned __int8 *)v45, (uint64_t)v8) == 1)
    {
      v29 = __OFADD__(v27++, 1);
      if (v29)
        goto LABEL_45;
    }
    else
    {
      v29 = __OFADD__(v26++, 1);
      if (v29)
      {
        __break(1u);
LABEL_45:
        __break(1u);
LABEL_46:
        __break(1u);
LABEL_47:
        __break(1u);
LABEL_48:
        v62 = v45;
LABEL_49:
        swift_unknownObjectRelease(v62);
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
      }
    }
    v30 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, v28, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
    v12 = v45;
    result = (*(uint64_t (**)(char *, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(&v45[*((int *)v30 + 12)], v28);
  }
}

uint64_t protocol witness for Error._domain.getter in conformance _ApplicationError(uint64_t a1, uint64_t a2)
{
  return protocol witness for Error._domain.getter in conformance _MergeError(a1, a2, &demangling cache variable for type metadata for _ApplicationError.Type);
}

uint64_t RangeReplaceableCollection.applying(_:)@<X0>(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t AssociatedConformanceWitness;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void (*v49)(uint64_t, uint64_t);
  unint64_t v50;
  uint64_t v51;
  void (*v52)(char *, unint64_t);
  void (*v53)(char *, char *, unint64_t);
  char *v54;
  char *v55;
  char *v56;
  void (*v57)(char *, char *, unint64_t);
  char *v58;
  char *v59;
  void (*v60)(char *, unint64_t);
  char *v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t *v65;
  char *v66;
  char *v67;
  void (*v68)(char *, char *, unint64_t);
  char *v69;
  char *v70;
  void (*v71)(char *, char *, unint64_t);
  char *v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  void (*v80)(char *, unint64_t, _QWORD, uint64_t, uint64_t);
  unint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _OWORD *v85;
  char *v87;
  void (*v88)(uint64_t, uint64_t);
  void (*v89)(char *, char *, unint64_t);
  char *v90;
  uint64_t v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  unint64_t v96;
  unint64_t *TupleTypeMetadata2;
  uint64_t v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  char *v102;
  char *v103;
  char *v104;
  char *v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  _OWORD *v113;
  uint64_t v114;
  char v115[16];
  uint64_t v116;
  uint64_t v117;
  uint64_t *v118;
  char *v119;
  uint64_t v120;
  char *v121;
  uint64_t *v122;
  uint64_t *v123;
  __int128 v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;

  v113 = a1;
  v111 = a4;
  v6 = *(_QWORD *)(a3 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, AssociatedTypeWitness, AssociatedTypeWitness, "lower upper ", 0);
  v8 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v100 = (char *)&v87 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v8);
  v93 = (char *)&v87 - v10;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v99 = type metadata accessor for Range(0, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  v98 = *(_QWORD *)(v99 - 8);
  v13 = MEMORY[0x1E0C80A78](v99);
  v92 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v13);
  v95 = (char *)&v87 - v15;
  v96 = swift_getAssociatedTypeWitness(0, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1E0C80A78](v96);
  v94 = (char *)&v87 - v16;
  v109 = AssociatedConformanceWitness;
  v107 = type metadata accessor for PartialRangeFrom(0, AssociatedTypeWitness, AssociatedConformanceWitness, v17);
  v106 = *(_QWORD *)(v107 - 8);
  v18 = MEMORY[0x1E0C80A78](v107);
  v102 = (char *)&v87 - v19;
  v112 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v20 = MEMORY[0x1E0C80A78](v18);
  v104 = (char *)&v87 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v20);
  v103 = (char *)&v87 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v105 = (char *)&v87 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v108 = (char *)&v87 - v27;
  v28 = MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v87 - v29;
  v31 = MEMORY[0x1E0C80A78](v28);
  v33 = (char *)&v87 - v32;
  v34 = MEMORY[0x1E0C80A78](v31);
  v36 = (char *)&v87 - v35;
  v37 = MEMORY[0x1E0C80A78](v34);
  v39 = (char *)&v87 - v38;
  v110 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](v37);
  v41 = (char *)&v87 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
  v126 = 0;
  v127 = 0;
  v125 = 0;
  v42 = v114;
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(a2, v6);
  v124 = *v113;
  v116 = a2;
  v117 = a3;
  v101 = a3;
  v118 = &v125;
  v119 = v41;
  v113 = v41;
  v120 = v42;
  v121 = v39;
  v122 = &v127;
  v123 = &v126;
  v43 = swift_getAssociatedTypeWitness(255, *(const char **)(v6 + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v46 = type metadata accessor for CollectionDifference(0, v43, v44, v45);
  CollectionDifference._fastEnumeratedApply(_:)((uint64_t)v115, v46, v47, v48);
  v90 = v33;
  v49 = *(void (**)(uint64_t, uint64_t))(v6 + 72);
  v91 = v6;
  v49(a2, v6);
  v50 = v109;
  LOBYTE(v42) = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v109 + 16))(v39, v36, AssociatedTypeWitness, v109);
  v51 = v112;
  v52 = *(void (**)(char *, unint64_t))(v112 + 8);
  v52(v36, AssociatedTypeWitness);
  if ((v42 & 1) != 0)
  {
    v88 = v49;
    v53 = *(void (**)(char *, char *, unint64_t))(v51 + 16);
    v54 = v90;
    v87 = v39;
    v53(v90, v39, AssociatedTypeWitness);
    v89 = v53;
    v53(v30, v54, AssociatedTypeWitness);
    if (((*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(v50 + 8) + 8))(v30, v30, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range cannot have an unordered lower bound.", 43, 2, "Swift/Range.swift", 17, 2, 0x34FuLL, 0);
    v52(v30, AssociatedTypeWitness);
    v55 = v102;
    v112 = *(_QWORD *)(v51 + 32);
    ((void (*)(char *, char *, unint64_t))v112)(v102, v54, AssociatedTypeWitness);
    v56 = v108;
    v57 = v89;
    v89(v108, v55, AssociatedTypeWitness);
    v58 = v105;
    v88(a2, v91);
    v59 = v103;
    v57(v103, v56, AssociatedTypeWitness);
    v60 = v52;
    v61 = v104;
    v57(v104, v58, AssociatedTypeWitness);
    v62 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(v50 + 24))(v59, v61, AssociatedTypeWitness, v50);
    v63 = v107;
    v64 = v106;
    if ((v62 & 1) == 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    v60(v61, AssociatedTypeWitness);
    v60(v59, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t))(v64 + 8))(v55, v63);
    v65 = TupleTypeMetadata2;
    v66 = v93;
    v67 = &v93[*((int *)TupleTypeMetadata2 + 12)];
    v68 = (void (*)(char *, char *, unint64_t))v112;
    ((void (*)(char *, char *, unint64_t))v112)(v93, v108, AssociatedTypeWitness);
    v68(v67, v58, AssociatedTypeWitness);
    v69 = v100;
    v70 = &v100[*((int *)v65 + 12)];
    v71 = v89;
    v89(v100, v66, AssociatedTypeWitness);
    v71(v70, v67, AssociatedTypeWitness);
    v72 = v92;
    v68(v92, v69, AssociatedTypeWitness);
    v60(v70, AssociatedTypeWitness);
    v73 = &v69[*((int *)v65 + 12)];
    v68(v69, v66, AssociatedTypeWitness);
    v68(v73, v67, AssociatedTypeWitness);
    v74 = v99;
    v68(&v72[*(int *)(v99 + 36)], v73, AssociatedTypeWitness);
    v60(v69, AssociatedTypeWitness);
    v75 = v98;
    v76 = v95;
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v95, v72, v74);
    v77 = v91;
    v78 = v94;
    (*(void (**)(char *, uint64_t, uint64_t))(v91 + 88))(v76, a2, v91);
    (*(void (**)(char *, uint64_t))(v75 + 8))(v76, v74);
    v79 = v101;
    v80 = *(void (**)(char *, unint64_t, _QWORD, uint64_t, uint64_t))(v101 + 72);
    v81 = v96;
    v82 = swift_getAssociatedConformanceWitness(v77, a2, v96, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    v80(v78, v81, *(_QWORD *)(v82 + 8), a2, v79);
    v52 = v60;
    v39 = v87;
  }
  v52(v39, AssociatedTypeWitness);
  v83 = v110;
  v84 = v111;
  v85 = v113;
  (*(void (**)(uint64_t, _OWORD *, uint64_t))(v110 + 16))(v111, v113, a2);
  (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v83 + 56))(v84, 0, 1, a2);
  return (*(uint64_t (**)(_OWORD *, uint64_t))(v83 + 8))(v85, a2);
}

uint64_t append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  char *v37;
  void (*v38)(uint64_t, uint64_t, char *, uint64_t, uint64_t);
  uint64_t v39;
  void (*v40)(uint64_t, unint64_t);
  void (*v42)(uint64_t, char *, unint64_t);
  char *v43;
  uint64_t v44;
  void (*v45)(char *, char *, unint64_t);
  char *v46;
  char *v47;
  unint64_t *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  void (*v54)(char *, unint64_t);
  char *v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t (*v63)(char *, unint64_t, _QWORD, uint64_t, uint64_t);
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  char *v69;
  unint64_t *TupleTypeMetadata2;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;
  unint64_t AssociatedTypeWitness;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  void (*v82)(char *, uint64_t, unint64_t);
  char *v83;
  unint64_t AssociatedConformanceWitness;
  char *v85;
  uint64_t v86;

  v78 = a6;
  v86 = a4;
  v77 = a1;
  v9 = *(_QWORD *)(a6 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v75 = (char *)&v66 - v10;
  v11 = swift_getAssociatedTypeWitness(255, (const char *)v9, a5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v11, v11, "lower upper ", 0);
  v12 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v73 = (char *)&v66 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v68 = (char *)&v66 - v14;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a5, v11, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v16 = type metadata accessor for Range(0, v11, AssociatedConformanceWitness, v15);
  v71 = *(_QWORD *)(v16 - 8);
  v72 = v16;
  v17 = MEMORY[0x1E0C80A78](v16);
  v67 = (char *)&v66 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v69 = (char *)&v66 - v19;
  v22 = type metadata accessor for Optional(0, v11, v20, v21);
  v79 = *(_QWORD *)(v22 - 8);
  v80 = v22;
  v23 = MEMORY[0x1E0C80A78](v22);
  v25 = (char *)&v66 - v24;
  v26 = *(_QWORD *)(v11 - 8);
  v27 = MEMORY[0x1E0C80A78](v23);
  v81 = (char *)&v66 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  v29 = MEMORY[0x1E0C80A78](v27);
  v85 = (char *)&v66 - v30;
  v31 = MEMORY[0x1E0C80A78](v29);
  v83 = (char *)&v66 - v32;
  v33 = MEMORY[0x1E0C80A78](v31);
  v35 = (char *)&v66 - v34;
  MEMORY[0x1E0C80A78](v33);
  v37 = (char *)&v66 - v36;
  v82 = *(void (**)(char *, uint64_t, unint64_t))(v26 + 16);
  v82((char *)&v66 - v36, a3, v11);
  (*(void (**)(uint64_t, uint64_t))(v9 + 72))(a5, v9);
  v38 = *(void (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(v9 + 144);
  v39 = v86;
  v74 = a2;
  v86 = a5;
  v38(a3, v39, v35, a5, v9);
  v40 = *(void (**)(uint64_t, unint64_t))(v26 + 8);
  v40(a3, v11);
  if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v26 + 48))(v25, 1, v11) == 1)
  {
    (*(void (**)(char *, uint64_t))(v79 + 8))(v25, v80);
    (*(void (**)(uint64_t, char *, unint64_t))(v26 + 32))(a3, v35, v11);
    v40((uint64_t)v37, v11);
    swift_allocError((uint64_t)&unk_1E0EAD8C8, (uint64_t)&protocol witness table for _ApplicationError, 0, 0);
    return swift_willThrow();
  }
  else
  {
    v40((uint64_t)v35, v11);
    v42 = *(void (**)(uint64_t, char *, unint64_t))(v26 + 32);
    v42(a3, v25, v11);
    v43 = v83;
    v44 = a3;
    v45 = (void (*)(char *, char *, unint64_t))v82;
    v82(v83, v44, v11);
    v46 = v85;
    v45(v85, v37, v11);
    v47 = v81;
    v45(v81, v43, v11);
    if (((*(uint64_t (**)(char *, char *, unint64_t))(AssociatedConformanceWitness + 24))(v46, v47, v11) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    v40((uint64_t)v47, v11);
    v40((uint64_t)v85, v11);
    AssociatedConformanceWitness = (unint64_t)v40;
    v85 = (char *)v9;
    v48 = TupleTypeMetadata2;
    v49 = v68;
    v50 = &v68[*((int *)TupleTypeMetadata2 + 12)];
    v42((uint64_t)v68, v37, v11);
    v42((uint64_t)v50, v43, v11);
    v51 = v73;
    v52 = &v73[*((int *)v48 + 12)];
    v45(v73, v49, v11);
    v45(v52, v50, v11);
    v53 = v67;
    v42((uint64_t)v67, v51, v11);
    v54 = (void (*)(char *, unint64_t))AssociatedConformanceWitness;
    ((void (*)(char *, unint64_t))AssociatedConformanceWitness)(v52, v11);
    v55 = &v51[*((int *)v48 + 12)];
    v42((uint64_t)v51, v49, v11);
    v42((uint64_t)v55, v50, v11);
    v56 = v72;
    v42((uint64_t)&v53[*(int *)(v72 + 36)], v55, v11);
    v54(v51, v11);
    v57 = v71;
    v58 = v69;
    (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v69, v53, v56);
    v59 = (uint64_t)v85;
    v60 = v75;
    v61 = v86;
    (*((void (**)(char *, uint64_t, char *))v85 + 11))(v58, v86, v85);
    (*(void (**)(char *, uint64_t))(v57 + 8))(v58, v56);
    v62 = v78;
    v63 = *(uint64_t (**)(char *, unint64_t, _QWORD, uint64_t, uint64_t))(v78 + 72);
    v64 = AssociatedTypeWitness;
    v65 = swift_getAssociatedConformanceWitness(v59, v61, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection);
    return v63(v60, v64, *(_QWORD *)(v65 + 8), v61, v62);
  }
}

unint64_t *closure #1 in RangeReplaceableCollection.applying(_:)(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *result;
  unsigned __int8 *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  unint64_t AssociatedConformanceWitness;
  char v40;
  void (*v41)(char *, unint64_t);
  char *v42;
  unint64_t v43;
  uint64_t (*v44)(char *, unsigned __int8 *);
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  char *v58;
  void (*v59)(char *, uint64_t, unint64_t);
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  unint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;

  v66 = a7;
  v65 = a6;
  v69 = a4;
  v70 = a5;
  v68 = a3;
  v12 = *(_QWORD *)(a9 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(v12 + 8), a8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v14 = *(_QWORD **)(AssociatedTypeWitness - 8);
  v15 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v60 = (char *)&v59 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v15);
  v18 = (char *)&v59 - v17;
  v63 = v12;
  v71 = a8;
  v19 = swift_getAssociatedTypeWitness(0, (const char *)v12, a8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v64 = *(_QWORD *)(v19 - 8);
  v20 = MEMORY[0x1E0C80A78](v19);
  v62 = (char *)&v59 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v20);
  v61 = (char *)&v59 - v22;
  v25 = type metadata accessor for CollectionDifference.Change(0, AssociatedTypeWitness, v23, v24);
  MEMORY[0x1E0C80A78](v25);
  v27 = (unsigned __int8 *)&v59 - v26;
  (*(void (**)(char *, uint64_t, uint64_t))(v28 + 16))((char *)&v59 - v26, a1, v25);
  LODWORD(v25) = swift_getEnumCaseMultiPayload(v27, v25);
  v29 = *(_QWORD *)v27;
  result = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, AssociatedTypeWitness, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
  v31 = &v27[*((int *)result + 12)];
  if ((_DWORD)v25 != 1)
  {
    v43 = AssociatedTypeWitness;
    v44 = (uint64_t (*)(char *, unsigned __int8 *))v14[4];
    v64 = v43;
    result = (unint64_t *)v44(v18, v31);
    v45 = v29 + *v65;
    if (!__OFADD__(v29, *v65))
    {
      v46 = __OFSUB__(v45, *v66);
      v47 = v45 - *v66;
      if (!v46)
      {
        v48 = v47 - *a2;
        if (!__OFSUB__(v47, *a2))
        {
          v49 = a2;
          v50 = v47 - *a2;
          v51 = v71;
          v52 = v67;
          append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)(v68, v69, v70, v50, v71, a9);
          if (v52)
          {
            v42 = v18;
            AssociatedTypeWitness = v64;
            return (unint64_t *)((uint64_t (*)(char *, unint64_t))v14[1])(v42, AssociatedTypeWitness);
          }
          v53 = v60;
          ((void (*)(char *, char *, unint64_t))v44)(v60, v18, v64);
          result = (unint64_t *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(a9 + 64))(v53, v51, a9);
          if (!__OFADD__(*v49, v48))
          {
            *v49 += v48;
            if (!__OFADD__(*v66, 1))
            {
              ++*v66;
              return result;
            }
            goto LABEL_26;
          }
LABEL_25:
          __break(1u);
LABEL_26:
          __break(1u);
          goto LABEL_27;
        }
LABEL_24:
        __break(1u);
        goto LABEL_25;
      }
LABEL_23:
      __break(1u);
      goto LABEL_24;
    }
LABEL_22:
    __break(1u);
    goto LABEL_23;
  }
  v66 = v14;
  v32 = v29 - *a2;
  if (__OFSUB__(v29, *a2))
  {
    __break(1u);
    goto LABEL_22;
  }
  v60 = (char *)v31;
  v33 = v70;
  v34 = v71;
  v35 = v67;
  append #1 <A>(into:contentsOf:from:count:) in RangeReplaceableCollection.applying(_:)(v68, v69, v70, v32, v71, a9);
  if (!v35)
  {
    v67 = a2;
    v68 = 0;
    v36 = v61;
    v59 = *(void (**)(char *, uint64_t, unint64_t))(v64 + 16);
    v59(v61, v33, v19);
    v38 = v62;
    v37 = v63;
    (*(void (**)(uint64_t, uint64_t))(v63 + 72))(v34, v63);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v37, v34, v19, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
    v40 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                      + 8))(v36, v38, v19);
    v41 = *(void (**)(char *, unint64_t))(v64 + 8);
    v41(v38, v19);
    result = (unint64_t *)((uint64_t (*)(char *, unint64_t))v41)(v36, v19);
    if ((v40 & 1) != 0)
    {
      swift_allocError((uint64_t)&unk_1E0EAD8C8, (uint64_t)&protocol witness table for _ApplicationError, 0, 0);
      swift_willThrow();
      goto LABEL_6;
    }
    v54 = v32 + 1;
    if (!__OFADD__(v32, 1))
    {
      v46 = __OFADD__(*v67, v54);
      v55 = *v67 + v54;
      if (!v46)
      {
        *v67 = v55;
        v56 = v62;
        v57 = v70;
        v59(v62, v70, v19);
        v58 = v61;
        (*(void (**)(char *, uint64_t))(v63 + 184))(v56, v71);
        v41(v56, v19);
        result = (unint64_t *)(*(uint64_t (**)(uint64_t, char *, unint64_t))(v64 + 40))(v57, v58, v19);
        if (!__OFADD__(*v65, 1))
        {
          ++*v65;
          return (unint64_t *)((uint64_t (*)(char *, unint64_t))v66[1])(v60, AssociatedTypeWitness);
        }
        goto LABEL_29;
      }
LABEL_28:
      __break(1u);
LABEL_29:
      __break(1u);
      return result;
    }
LABEL_27:
    __break(1u);
    goto LABEL_28;
  }
LABEL_6:
  v14 = v66;
  v42 = v60;
  return (unint64_t *)((uint64_t (*)(char *, unint64_t))v14[1])(v42, AssociatedTypeWitness);
}

uint64_t BidirectionalCollection.difference<A>(from:by:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[10];

  v17[2] = a5;
  v17[3] = a4;
  v17[4] = a7;
  v17[5] = a6;
  v17[7] = a2;
  v17[8] = a3;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(const char **)(*(_QWORD *)(a6 + 8) + 8), a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v15 = type metadata accessor for CollectionDifference(0, AssociatedTypeWitness, v13, v14);
  return _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)(a1, (void (*)(uint64_t, _QWORD))partial apply for closure #1 in _myers<A, B>(from:to:using:), (uint64_t)v17, a5, v15, *(_QWORD *)(a7 + 8), a8);
}

uint64_t BidirectionalCollection<>.difference<A>(from:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v20[6];
  uint64_t v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  char *v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(*(_QWORD *)(a4 + 8) + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v25 = a2;
  v26 = a3;
  v27 = a4;
  v28 = a5;
  v29 = a6;
  v30 = AssociatedTypeWitness;
  v20[2] = a3;
  v20[3] = a2;
  v20[4] = a5;
  v20[5] = a4;
  v21 = v7;
  v22 = partial apply for implicit closure #1 in BidirectionalCollection<>.difference<A>(from:);
  v23 = &v24;
  v18 = type metadata accessor for CollectionDifference(0, AssociatedTypeWitness, v16, v17);
  return _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)(a1, (void (*)(uint64_t, _QWORD))partial apply for closure #1 in _myers<A, B>(from:to:using:), (uint64_t)v20, a3, v18, *(_QWORD *)(a5 + 8), a7);
}

__objc2_class **_descent #1 <A, B>(from:to:) in _myers<A, B>(from:to:using:)(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(char *, char *), uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  __objc2_class **v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int64_t v21;
  uint64_t v22;
  __objc2_class **v23;
  __objc2_class **v24;
  unint64_t v25;
  unint64_t v26;
  __objc2_class **v27;
  __objc2_class **result;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  BOOL v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  int64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(char *, uint64_t, unint64_t);
  uint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  char v49;
  void (*v50)(char *, unint64_t);
  char *v51;
  char v52;
  BOOL v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  __objc2_class **v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  int64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int64_t v71;
  int64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t (*v75)(char *, char *);
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int64_t v80;

  v74 = a3;
  v75 = a5;
  v77 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(*(_QWORD *)(a8 + 8) + 8), a7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v12 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v73 = (char *)&v56 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v15 = (char *)&v56 - v14;
  v67 = a2;
  v59 = a2 + a4;
  if (__OFADD__(a2, a4))
    goto LABEL_93;
  v16 = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(2);
  v16[2] = (__objc2_class *)2;
  a2 = (unint64_t)v16;
  v16[4] = 0;
  v16[5] = 0;
  if (!swift_isUniquelyReferenced_nonNull_native((uint64_t)v16))
    goto LABEL_94;
  if (!*(_QWORD *)(a2 + 16))
    goto LABEL_95;
  while (1)
  {
    *(_QWORD *)(a2 + 32) = 0;
    if ((v59 & 0x8000000000000000) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
    v76 = v11;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v72 = v67 - 1;
    v61 = -a4;
    v23 = &_swiftEmptyArrayStorage;
    v60 = a4;
LABEL_6:
    v66 = a2;
    swift_bridgeObjectRetain(a2, v17, v18, v19);
    if (swift_isUniquelyReferenced_nonNull_native((uint64_t)v23))
      v24 = v23;
    else
      v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)(0, (int64_t)&v23[2]->isa + 1, 1, (uint64_t)v23);
    v26 = (unint64_t)v24[2];
    v25 = (unint64_t)v24[3];
    v11 = v26 + 1;
    if (v26 >= v25 >> 1)
      v24 = specialized _ArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)((__objc2_class **)(v25 > 1), v26 + 1, 1, (uint64_t)v24);
    v24[2] = (__objc2_class *)v11;
    v27 = &v24[v26];
    a2 = v66;
    v27[4] = (__objc2_class *)v66;
    if (!__OFADD__(v22, 1))
      break;
LABEL_92:
    __break(1u);
LABEL_93:
    __break(1u);
LABEL_94:
    a2 = (unint64_t)specialized _ArrayBuffer._consumeAndCreateNew()(a2);
    if (!*(_QWORD *)(a2 + 16))
      goto LABEL_95;
  }
  v58 = v24;
  v57 = v22 + 1;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)(v22 + 1));
  v29 = (uint64_t)result;
  v64 = 0;
  v65 = 0;
  v30 = -v22;
  v68 = a2 + 32;
  v62 = v22 - 1;
  v63 = -v22;
  v31 = -v22;
  while (v31 < v22)
  {
    if (__OFADD__(v31, 2))
    {
      HIDWORD(v64) = 0;
      v65 = 0x8000000000000000;
      v69 = 0x7FFFFFFFFFFFFFFFLL;
      if (v31 != v30)
      {
        v33 = 0x7FFFFFFFFFFFFFFDLL;
LABEL_33:
        v34 = v33 - 1;
        goto LABEL_35;
      }
      v32 = 0x7FFFFFFFFFFFFFFELL;
      goto LABEL_28;
    }
    v69 = v31 + 2;
    if (v31 == v30)
    {
      v65 = 0;
      if (v30 >= 0x7FFFFFFFFFFFFFFFLL)
        v32 = ~v31;
      else
        v32 = v30;
      HIDWORD(v64) = 1;
      goto LABEL_28;
    }
    v65 = 0;
    v33 = v31 - 1;
    HIDWORD(v64) = 1;
    if (v31 - 1 >= 1)
      goto LABEL_33;
LABEL_34:
    v35 = __OFSUB__(0, v33);
    v34 = -v33;
    if (v35)
    {
LABEL_91:
      __break(1u);
      goto LABEL_92;
    }
LABEL_35:
    if ((v34 & 0x8000000000000000) != 0 || (v36 = *(_QWORD *)(a2 + 16), v34 >= v36))
    {
LABEL_85:
      v55 = 675;
      goto LABEL_86;
    }
    v37 = *(_QWORD *)(v68 + 8 * v34);
    if (v31 == v22)
    {
      v21 = v37 + 1;
    }
    else
    {
      if ((unint64_t)v31 > 0x7FFFFFFFFFFFFFFELL)
      {
        v38 = -(v31 + 1);
        if (__OFSUB__(0, v31 + 1))
        {
          __break(1u);
          return result;
        }
      }
      else
      {
        v38 = v31;
      }
      if ((v38 & 0x8000000000000000) != 0 || v38 >= v36)
        goto LABEL_85;
      if (v37 >= *(_QWORD *)(v68 + 8 * v38))
        v21 = v37 + 1;
      else
        v21 = *(_QWORD *)(v68 + 8 * v38);
    }
LABEL_47:
    v39 = v21 - v31;
    if (v21 >= v67)
    {
      v11 = 0;
      if (v31 <= 0)
        goto LABEL_60;
      goto LABEL_58;
    }
    if (v39 >= a4)
    {
      v11 = 1;
      if (v31 <= 0)
        goto LABEL_60;
      goto LABEL_58;
    }
    v79 = v29;
    v80 = v21 - v31;
    v78 = -v31;
    v70 = v61 - v31;
    v71 = v21;
    v40 = v21;
    do
    {
      if (v21 < 0
        || (v41 = v31,
            v42 = v76,
            v43 = *(_QWORD *)(v76 + 72),
            v44 = *(void (**)(char *, uint64_t, unint64_t))(v76 + 16),
            v44(v15, v77 + v43 * v40, AssociatedTypeWitness),
            v80 < 0))
      {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
      }
      v45 = v22;
      v46 = v15;
      v47 = AssociatedTypeWitness;
      v48 = v73;
      v44(v73, v74 + v43 * (v78 + v40), v47);
      v49 = v75(v46, v48);
      v50 = *(void (**)(char *, unint64_t))(v42 + 8);
      v51 = v48;
      AssociatedTypeWitness = v47;
      v15 = v46;
      v50(v51, AssociatedTypeWitness);
      v50(v46, AssociatedTypeWitness);
      if ((v49 & 1) == 0)
      {
        v31 = v41;
        v39 = v40 - v41;
        v11 = 1;
        v21 = v40;
        a4 = v60;
        v22 = v45;
        v29 = v79;
        if (v41 >= 1)
          goto LABEL_58;
LABEL_60:
        a2 = -v31;
        if (!__OFSUB__(0, v31))
        {
          v20 = v39;
          goto LABEL_62;
        }
        __break(1u);
        goto LABEL_91;
      }
      v22 = v45;
      v31 = v41;
      if (v72 == v40)
      {
        v11 = 0;
        v39 = v40 - v41 + 1;
        v21 = v67;
        a4 = v60;
        v29 = v79;
        if (v41 > 0)
          goto LABEL_58;
        goto LABEL_60;
      }
      ++v40;
      v21 = v71;
      v29 = v79;
    }
    while (v70 + v40);
    v11 = 1;
    a4 = v60;
    v39 = v60;
    v21 = v40;
    if (v41 <= 0)
      goto LABEL_60;
LABEL_58:
    v20 = v39;
    a2 = v31 - 1;
LABEL_62:
    result = (__objc2_class **)swift_isUniquelyReferenced_nonNull_native(v29);
    if ((result & 1) != 0)
    {
      v30 = v63;
      if ((a2 & 0x8000000000000000) == 0)
        goto LABEL_64;
LABEL_95:
      v55 = 688;
LABEL_86:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, v55, 0);
    }
    result = specialized _ArrayBuffer._consumeAndCreateNew()(v29);
    v29 = (uint64_t)result;
    v30 = v63;
    if ((a2 & 0x8000000000000000) != 0)
      goto LABEL_95;
LABEL_64:
    if (a2 >= *(_QWORD *)(v29 + 16))
      goto LABEL_95;
    *(_QWORD *)(v29 + 8 * a2 + 32) = v21;
    if (v20 < a4)
      v52 = 1;
    else
      v52 = v11;
    v31 = v69;
    a2 = v66;
    if ((v52 & 1) == 0)
    {
      swift_bridgeObjectRelease(v29);
      v29 = a2;
      goto LABEL_87;
    }
  }
  if (!((v31 != v22) | v64 & 1) && BYTE4(v64) & 1 | (v65 != 0x8000000000000000))
  {
    if (v22)
    {
      LODWORD(v64) = 1;
      v69 = v22;
      v33 = v62;
      if (v22 > 1)
        goto LABEL_33;
      goto LABEL_34;
    }
    v32 = 0;
    v69 = 0;
    LODWORD(v64) = 1;
LABEL_28:
    if ((v32 & 0x8000000000000000) != 0 || v32 >= *(_QWORD *)(a2 + 16))
      goto LABEL_85;
    v21 = *(_QWORD *)(v68 + 8 * v32);
    goto LABEL_47;
  }
  swift_bridgeObjectRelease(a2);
  if (v20 < a4 || v21 < v67)
  {
    a2 = v29;
    v54 = v22 == v59;
    v22 = v57;
    v23 = v58;
    if (!v54)
      goto LABEL_6;
  }
  else
  {
LABEL_87:
    v23 = v58;
  }
  swift_bridgeObjectRelease(v29);
  return v23;
}

void _formChanges #1 <A, B>(from:to:using:) in _myers<A, B>(from:to:using:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v36;
  unint64_t *TupleTypeMetadata3;
  char *v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __objc2_class **v50;

  v46 = a2;
  v47 = a4;
  v44 = a1;
  v45 = a3;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(const char **)(*(_QWORD *)(a7 + 8) + 8), a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = type metadata accessor for CollectionDifference.Change(0, AssociatedTypeWitness, v9, v10);
  v12 = MEMORY[0x1E0C80A78](v11);
  v14 = (char *)&v43 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v43 - v15;
  v50 = &_swiftEmptyArrayStorage;
  v17 = *(_QWORD *)(a5 + 16);
  v49 = type metadata accessor for Array(0, v11, v18, v19);
  Array._reserveCapacityImpl(minimumCapacity:growForAppend:)(v17, 0);
  if (v17 >= 2)
  {
    v48 = a5 + 24;
    v20 = 1 - v17;
    v21 = v46;
    v22 = v47;
    while (1)
    {
      v26 = v17 - 1;
      v27 = *(_QWORD *)(v48 + 8 * v17);
      v28 = v21 - v22;
      if (v20 == v21 - v22)
        goto LABEL_6;
      v29 = v28 - 1;
      if (v26 != v28)
      {
        if (v29 < 1)
        {
          v39 = 1 - v28;
          if (__OFSUB__(0, v29))
            goto LABEL_45;
        }
        else
        {
          v39 = v28 - 2;
        }
        if ((v39 & 0x8000000000000000) != 0)
          goto LABEL_40;
        v40 = *(_QWORD *)(v27 + 16);
        if (v39 >= v40)
          goto LABEL_40;
        v41 = *(_QWORD *)(v27 + 32 + 8 * v39);
        if (v28 > 0x7FFFFFFFFFFFFFFELL)
        {
          v42 = -(uint64_t)(v28 + 1);
          if (__OFSUB__(0, v28 + 1))
            goto LABEL_44;
        }
        else
        {
          v42 = v21 - v22;
        }
        if ((v42 & 0x8000000000000000) != 0 || v42 >= v40)
LABEL_40:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
        if (v41 < *(_QWORD *)(v27 + 32 + 8 * v42))
LABEL_6:
          v29 = v28 + 1;
      }
      v30 = v29 - 1;
      if (v29 < 1)
      {
        v30 = -v29;
        if (__OFSUB__(0, v29))
          break;
      }
      if ((v30 & 0x8000000000000000) != 0 || v30 >= *(_QWORD *)(v27 + 16))
        goto LABEL_40;
      v31 = *(_QWORD *)(v27 + 8 * v30 + 32);
      v32 = v31 - v29;
      v33 = ~v31 + v29 + v22;
      if (v33 >= v21 + ~v31)
        v33 = v21 + ~v31;
      v34 = v22 + ~v33;
      if (v31 < v21 && v32 < v22)
        v36 = v34;
      else
        v36 = v22;
      if (v36 == v32)
      {
        *(_QWORD *)v14 = v31;
        if (v31 < 0)
          goto LABEL_41;
        if (v31 >= v46)
          goto LABEL_42;
        TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, AssociatedTypeWitness, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
        v38 = &v14[*((int *)TupleTypeMetadata3 + 16)];
        (*(void (**)(char *, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 16))(&v14[*((int *)TupleTypeMetadata3 + 12)], v44 + *(_QWORD *)(*(_QWORD *)(AssociatedTypeWitness - 8) + 72) * v31, AssociatedTypeWitness);
        *(_QWORD *)v38 = 0;
        v38[8] = 1;
        swift_storeEnumTagMultiPayload(v14, v11, 1u);
        v25 = (uint64_t)v14;
      }
      else
      {
        *(_QWORD *)v16 = v32;
        if (v32 < 0)
LABEL_41:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
        if (v32 >= v47)
LABEL_42:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
        v23 = swift_getTupleTypeMetadata3(0, (uint64_t)&type metadata for Int, AssociatedTypeWitness, (uint64_t)&unk_1E0EACF60, "offset element associatedWith ", 0);
        v24 = &v16[*((int *)v23 + 16)];
        (*(void (**)(char *, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 16))(&v16[*((int *)v23 + 12)], v45 + *(_QWORD *)(*(_QWORD *)(AssociatedTypeWitness - 8) + 72) * v32, AssociatedTypeWitness);
        *(_QWORD *)v24 = 0;
        v24[8] = 1;
        swift_storeEnumTagMultiPayload(v16, v11, 0);
        v25 = (uint64_t)v16;
      }
      Array.append(_:)(v25, v49);
      ++v20;
      --v17;
      v21 = v31;
      v22 = v32;
      if (v26 + 1 <= 2)
        return;
    }
    __break(1u);
LABEL_44:
    __break(1u);
LABEL_45:
    __break(1u);
  }
}

uint64_t _withContiguousStorage #1 <A, B><A1, B1>(for:_:) in _myers<A, B>(from:to:using:)@<X0>(uint64_t a1@<X0>, void (*a2)(uint64_t, _QWORD)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t (*v24)(void (*)(uint64_t, _QWORD), uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  uint64_t result;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(char *, char *, uint64_t);
  uint64_t v32;
  uint64_t v33;
  void (*v34)(uint64_t, _QWORD);
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v38 = a7;
  v40 = a1;
  v33 = *(_QWORD *)(a4 - 8);
  MEMORY[0x1E0C80A78](a1);
  v37 = (char *)&v32 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = type metadata accessor for Optional(0, v15, v13, v14);
  v17 = *(_QWORD *)(v16 - 8);
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v32 - v19;
  v36 = *(_QWORD *)(a5 - 8);
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v32 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = *(_QWORD *)(a6 + 8);
  v24 = *(uint64_t (**)(void (*)(uint64_t, _QWORD), uint64_t, uint64_t, uint64_t, uint64_t))(v23 + 72);
  v34 = a2;
  v35 = a3;
  v25 = v39;
  result = v24(a2, a3, a5, a4, v23);
  if (!v25)
  {
    v28 = v36;
    v27 = v37;
    v39 = 0;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v36 + 48))(v20, 1, a5) == 1)
    {
      (*(void (**)(char *, uint64_t))(v17 + 8))(v20, v16);
      (*(void (**)(char *, uint64_t, uint64_t))(v33 + 16))(v27, v40, a4);
      v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v23 + 56))(a4, v23);
      v30 = *(unsigned __int8 *)(*(_QWORD *)(swift_getAssociatedTypeWitness(0, (const char *)v23, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element)- 8)+ 80);
      v34(v29 + ((v30 + 32) & ~v30), *(_QWORD *)(v29 + 16));
      return swift_release(v29);
    }
    else
    {
      v31 = *(void (**)(char *, char *, uint64_t))(v28 + 32);
      v31(v22, v20, a5);
      return ((uint64_t (*)(uint64_t, char *, uint64_t))v31)(v38, v22, a5);
    }
  }
  return result;
}

void closure #1 in _myers<A, B>(from:to:using:)(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X6>, uint64_t a5@<X7>, _OWORD *a6@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t (*v19)(char *, char *);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(_QWORD *__return_ptr, double (*)@<D0>(uint64_t@<X0>, uint64_t@<X1>, _OWORD *@<X8>), _BYTE *, uint64_t, uint64_t, uint64_t);
  unint64_t AssociatedTypeWitness;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _OWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t (*v35)(char *, char *);
  uint64_t v36;
  void *v37;
  _BYTE v38[16];
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t (*v45)(char *, char *);
  uint64_t v46;
  _QWORD v47[2];
  _OWORD *v48;

  v48 = a6;
  v10 = *(_QWORD *)(a4 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (char *)&v32 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v39 = v14;
  v40 = v15;
  v41 = v16;
  v42 = v17;
  v33 = v11;
  v34 = v18;
  v43 = v11;
  v44 = v18;
  v35 = v19;
  v36 = v20;
  v45 = v19;
  v46 = v20;
  v21 = *(_QWORD *)(*(_QWORD *)(v17 + 8) + 8);
  v22 = *(void (**)(_QWORD *__return_ptr, double (*)@<D0>(uint64_t@<X0>, uint64_t@<X1>, _OWORD *@<X8>), _BYTE *, uint64_t, uint64_t, uint64_t))(v21 + 72);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(const char **)(*(_QWORD *)(v16 + 8) + 8), v14, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v26 = type metadata accessor for CollectionDifference(0, AssociatedTypeWitness, v24, v25);
  v27 = v37;
  v22(v47, partial apply for closure #1 in closure #1 in _myers<A, B>(from:to:using:), v38, v26, a4, v21);
  if (v27)
  {
    swift_errorRelease(v27);
    __break(1u);
  }
  else if (v47[0])
  {
    v28 = v47[1];
    v29 = v48;
    *(_QWORD *)v48 = v47[0];
    *((_QWORD *)v29 + 1) = v28;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v13, a2, a4);
    v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v21 + 56))(a4, v21);
    v31 = *(unsigned __int8 *)(*(_QWORD *)(AssociatedTypeWitness - 8) + 80);
    closure #1 in closure #1 in _myers<A, B>(from:to:using:)(v30 + ((v31 + 32) & ~v31), *(_QWORD *)(v30 + 16), v33, v34, v35, v36, a3, a5, v48);
    swift_release(v30);
  }
}

double closure #1 in closure #1 in _myers<A, B>(from:to:using:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t (*a5)(char *, char *)@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _OWORD *a9@<X8>)
{
  __objc2_class **v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t AssociatedTypeWitness;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t WitnessTable;
  double result;
  __int128 v29;
  uint64_t v30;

  v16 = _descent #1 <A, B>(from:to:) in _myers<A, B>(from:to:using:)(a3, a4, a1, a2, a5, a6, a7, a8);
  _formChanges #1 <A, B>(from:to:using:) in _myers<A, B>(from:to:using:)(a3, a4, a1, a2, (uint64_t)v16, a7, a8);
  v18 = v17;
  swift_bridgeObjectRelease((uint64_t)v16);
  v30 = v18;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(*(_QWORD *)(a8 + 8) + 8), a7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v22 = type metadata accessor for CollectionDifference.Change(255, AssociatedTypeWitness, v20, v21);
  v25 = type metadata accessor for Array(0, v22, v23, v24);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v25, v26);
  if ((static CollectionDifference._validateChanges<A>(_:)((uint64_t)&v30, AssociatedTypeWitness, v25, WitnessTable) & 1) == 0)
  {
    swift_bridgeObjectRelease(v18);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/Diffing.swift", 19, 2, 0x16BuLL, 0);
  }
  CollectionDifference.init<A>(_validatedChanges:)((uint64_t)&v30, AssociatedTypeWitness, v25, WitnessTable, (__objc2_class ***)&v29);
  result = *(double *)&v29;
  *a9 = v29;
  return result;
}

uint64_t Duration._low.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Duration._low.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Duration._high.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t (*Duration._high.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Duration __swiftcall Duration.init(secondsComponent:attosecondsComponent:)(Swift::Int64 secondsComponent, Swift::Int64 attosecondsComponent)
{
  Swift::UInt64 v2;
  Swift::Int64 v3;
  Swift::Duration result;

  v2 = specialized static Duration.+ infix(_:_:)(1000000000000000000 * secondsComponent, ((secondsComponent >> 63) & 0xF21F494C589C0000)+ (((unint64_t)secondsComponent * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64), attosecondsComponent, attosecondsComponent >> 63);
  result._high = v3;
  result._low = v2;
  return result;
}

uint64_t static Duration.seconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  void (*v30)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  void (*v34)(char *, char *, uint64_t);
  _BOOL4 v35;
  void (*v36)(char *, uint64_t);
  uint64_t (*v37)(uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, char *, uint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t (*v47)(uint64_t, uint64_t);
  char *v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v54;
  char v55;
  char *v56;
  uint64_t v57;
  char v58;
  char *v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v65;
  char v66;
  uint64_t v67;
  void (*v68)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  void (*v77)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v78;
  char v79;
  uint64_t v80;
  unint64_t v81;
  void (**v82)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v84;
  int64_t v85;
  uint64_t v86;
  BOOL v87;
  uint64_t v88;
  uint64_t (*v89)(uint64_t, uint64_t);
  char *v90;
  unint64_t AssociatedTypeWitness;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  uint64_t v98;
  void (*v99)(char *, char *, uint64_t);
  uint64_t v100;
  int64_t v101;

  v92 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v92, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v6 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v90 = (char *)&v88 - v7;
  v8 = *(_QWORD *)(a2 - 8);
  v9 = MEMORY[0x1E0C80A78](v6);
  v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = MEMORY[0x1E0C80A78](v9);
  v94 = (char *)&v88 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v96 = (char *)&v88 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v88 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v88 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v88 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v88 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v29 = (char *)&v88 - v28;
  v101 = 64;
  v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  v98 = v8;
  v99 = v34;
  v34(v26, v29, a2);
  v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v43 = v99;
    goto LABEL_10;
  }
  v101 = 0x8000000000000000;
  if ((v97(a2, a3) & 1) != 0)
  {
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v39 = v38(a2, a3);
    if (v39 < 64)
    {
      v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      v43 = v99;
      if (v42 < v101)
        goto LABEL_46;
      goto LABEL_10;
    }
    v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    v37 = v97;
    v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0x71uLL, 0);
    }
    goto LABEL_10;
  }
  v60 = v37(a2, a3);
  v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      v81 = AssociatedTypeWitness;
      v82 = (void (**)(char *, uint64_t, const char *))v92;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v92, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v81, AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
      v36(v20, a2);
      v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }
      v85 = v101;
      v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      v87 = v86 < v85;
      v43 = v99;
      v37 = v97;
      if (!v87)
        goto LABEL_10;
      goto LABEL_46;
    }
    v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    v37 = v97;
    v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if ((v66 & 1) != 0)
      goto LABEL_46;
LABEL_10:
    v44 = v38(a2, a3);
    goto LABEL_11;
  }
  if (v61 < 64)
  {
    v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if (v80 < v101)
      goto LABEL_46;
    goto LABEL_10;
  }
  v36(v23, a2);
  v43 = v99;
  v38 = v89;
  v44 = v89(a2, a3);
LABEL_11:
  v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    v46 = v17;
    v47 = v38;
    v36(v46, a2);
    v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }
  v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    v59 = v48;
    goto LABEL_27;
  }
  v47 = v38;
  v58 = v37(a2, a3);
  v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0)
    goto LABEL_26;
LABEL_13:
  v101 = 0x7FFFFFFFFFFFFFFFLL;
  v49 = v37(a2, a3);
  v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v20, v48, a2);
      v36(v20, a2);
      v56 = v48;
      goto LABEL_29;
    }
    goto LABEL_20;
  }
  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }
  v100 = 0x7FFFFFFFFFFFFFFFLL;
  v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v72, v20, a2);
  v36(v72, a2);
  v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0)
    goto LABEL_46;
LABEL_30:
  v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000000000000) >> 64 != (1000000000000000000 * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }
  if (__OFADD__(1000000000000000000 * v74, ((unint64_t)v75 * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  return 1000000000000000000 * v75;
}

uint64_t Duration.components.getter(unint64_t a1, unint64_t a2)
{
  Swift::_Int128 v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  Swift::Int64 v9;
  Swift::_Int128 v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  _BOOL4 v16;
  uint64_t v17;
  _BOOL4 v18;
  BOOL v19;
  _BOOL4 v20;

  v4.low = 0x73AFF322E62439FDLL;
  v4.high = 0x9392EE8E921D5D0;
  *(_OWORD *)(&v5 - 1) = (unsigned __int128)_Int128.multipliedFullWidth(by:)(v4);
  v7 = (__int128)__PAIR128__(v5, v6) >> 55;
  v8 = v7 + (a2 >> 63);
  if (__CFADD__(v7, a2 >> 63))
    v9 = (v5 >> 55) + 1;
  else
    v9 = v5 >> 55;
  v10.low = v7 + (a2 >> 63);
  v10.high = v9;
  *(_OWORD *)&v11 = (unsigned __int128)_Int128.multipliedReportingOverflow(by:)(v10);
  v13 = v12;
  v14 = a1 - v11;
  v15 = v8 >= 0;
  if (v9 != -1)
    v15 = v9 < -1;
  if (v15)
    goto LABEL_17;
  v16 = v8 < 0;
  if (v9)
    v16 = v9 > 0;
  if (v16)
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  v17 = (__PAIR128__(a2, a1) - __PAIR128__(v13, v11)) >> 64;
  v18 = v14 >= 0;
  if (v17 != -1)
    v18 = v17 < -1;
  if (v18)
LABEL_17:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  v19 = v17 == 0;
  v20 = v17 > 0;
  if (v19)
    v20 = v14 < 0;
  if (v20)
    goto LABEL_18;
  return v8;
}

double static Double.- infix(_:_:)(double a1, double a2)
{
  return a1 - a2;
}

double Double.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t (**a3)(_QWORD, _QWORD))
{
  char v7;
  uint64_t v8;
  double v9;

  if (a3[16](a2, a3) <= 64)
  {
    v7 = a3[8](a2, a3);
    v8 = a3[15](a2, a3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    if ((v7 & 1) != 0)
      return (double)v8;
    else
      return (double)(unint64_t)v8;
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v9, a1, a2, (uint64_t)a3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    return v9;
  }
}

uint64_t static Duration.seconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0xDE0B6B3A7640000uLL, a1);
}

uint64_t static Duration.milliseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  void (*v30)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  void (*v34)(char *, char *, uint64_t);
  _BOOL4 v35;
  void (*v36)(char *, uint64_t);
  uint64_t (*v37)(uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, char *, uint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t (*v47)(uint64_t, uint64_t);
  char *v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v54;
  char v55;
  char *v56;
  uint64_t v57;
  char v58;
  char *v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v65;
  char v66;
  uint64_t v67;
  void (*v68)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  void (*v77)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v78;
  char v79;
  uint64_t v80;
  unint64_t v81;
  void (**v82)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v84;
  int64_t v85;
  uint64_t v86;
  BOOL v87;
  uint64_t v88;
  uint64_t (*v89)(uint64_t, uint64_t);
  char *v90;
  unint64_t AssociatedTypeWitness;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  uint64_t v98;
  void (*v99)(char *, char *, uint64_t);
  uint64_t v100;
  int64_t v101;

  v92 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v92, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v6 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v90 = (char *)&v88 - v7;
  v8 = *(_QWORD *)(a2 - 8);
  v9 = MEMORY[0x1E0C80A78](v6);
  v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = MEMORY[0x1E0C80A78](v9);
  v94 = (char *)&v88 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v96 = (char *)&v88 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v88 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v88 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v88 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v88 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v29 = (char *)&v88 - v28;
  v101 = 64;
  v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  v98 = v8;
  v99 = v34;
  v34(v26, v29, a2);
  v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v43 = v99;
    goto LABEL_10;
  }
  v101 = 0x8000000000000000;
  if ((v97(a2, a3) & 1) != 0)
  {
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v39 = v38(a2, a3);
    if (v39 < 64)
    {
      v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      v43 = v99;
      if (v42 < v101)
        goto LABEL_46;
      goto LABEL_10;
    }
    v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    v37 = v97;
    v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0x9FuLL, 0);
    }
    goto LABEL_10;
  }
  v60 = v37(a2, a3);
  v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      v81 = AssociatedTypeWitness;
      v82 = (void (**)(char *, uint64_t, const char *))v92;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v92, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v81, AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
      v36(v20, a2);
      v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }
      v85 = v101;
      v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      v87 = v86 < v85;
      v43 = v99;
      v37 = v97;
      if (!v87)
        goto LABEL_10;
      goto LABEL_46;
    }
    v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    v37 = v97;
    v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if ((v66 & 1) != 0)
      goto LABEL_46;
LABEL_10:
    v44 = v38(a2, a3);
    goto LABEL_11;
  }
  if (v61 < 64)
  {
    v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if (v80 < v101)
      goto LABEL_46;
    goto LABEL_10;
  }
  v36(v23, a2);
  v43 = v99;
  v38 = v89;
  v44 = v89(a2, a3);
LABEL_11:
  v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    v46 = v17;
    v47 = v38;
    v36(v46, a2);
    v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }
  v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    v59 = v48;
    goto LABEL_27;
  }
  v47 = v38;
  v58 = v37(a2, a3);
  v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0)
    goto LABEL_26;
LABEL_13:
  v101 = 0x7FFFFFFFFFFFFFFFLL;
  v49 = v37(a2, a3);
  v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v20, v48, a2);
      v36(v20, a2);
      v56 = v48;
      goto LABEL_29;
    }
    goto LABEL_20;
  }
  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }
  v100 = 0x7FFFFFFFFFFFFFFFLL;
  v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v72, v20, a2);
  v36(v72, a2);
  v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0)
    goto LABEL_46;
LABEL_30:
  v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000000000) >> 64 != (1000000000000000 * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }
  if (__OFADD__(1000000000000000 * v74, ((unint64_t)v75 * (unsigned __int128)0x38D7EA4C68000uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  return 1000000000000000 * v75;
}

uint64_t static Duration.milliseconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0x38D7EA4C68000uLL, a1);
}

uint64_t static Duration.microseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  void (*v30)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  void (*v34)(char *, char *, uint64_t);
  _BOOL4 v35;
  void (*v36)(char *, uint64_t);
  uint64_t (*v37)(uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, char *, uint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t (*v47)(uint64_t, uint64_t);
  char *v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v54;
  char v55;
  char *v56;
  uint64_t v57;
  char v58;
  char *v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v65;
  char v66;
  uint64_t v67;
  void (*v68)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  void (*v77)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v78;
  char v79;
  uint64_t v80;
  unint64_t v81;
  void (**v82)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v84;
  int64_t v85;
  uint64_t v86;
  BOOL v87;
  uint64_t v88;
  uint64_t (*v89)(uint64_t, uint64_t);
  char *v90;
  unint64_t AssociatedTypeWitness;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  uint64_t v98;
  void (*v99)(char *, char *, uint64_t);
  uint64_t v100;
  int64_t v101;

  v92 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v92, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v6 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v90 = (char *)&v88 - v7;
  v8 = *(_QWORD *)(a2 - 8);
  v9 = MEMORY[0x1E0C80A78](v6);
  v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = MEMORY[0x1E0C80A78](v9);
  v94 = (char *)&v88 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v96 = (char *)&v88 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v88 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v88 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v88 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v88 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v29 = (char *)&v88 - v28;
  v101 = 64;
  v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  v98 = v8;
  v99 = v34;
  v34(v26, v29, a2);
  v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v43 = v99;
    goto LABEL_10;
  }
  v101 = 0x8000000000000000;
  if ((v97(a2, a3) & 1) != 0)
  {
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v39 = v38(a2, a3);
    if (v39 < 64)
    {
      v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      v43 = v99;
      if (v42 < v101)
        goto LABEL_46;
      goto LABEL_10;
    }
    v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    v37 = v97;
    v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0xBCuLL, 0);
    }
    goto LABEL_10;
  }
  v60 = v37(a2, a3);
  v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      v81 = AssociatedTypeWitness;
      v82 = (void (**)(char *, uint64_t, const char *))v92;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v92, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v81, AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
      v36(v20, a2);
      v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }
      v85 = v101;
      v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      v87 = v86 < v85;
      v43 = v99;
      v37 = v97;
      if (!v87)
        goto LABEL_10;
      goto LABEL_46;
    }
    v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    v37 = v97;
    v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if ((v66 & 1) != 0)
      goto LABEL_46;
LABEL_10:
    v44 = v38(a2, a3);
    goto LABEL_11;
  }
  if (v61 < 64)
  {
    v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if (v80 < v101)
      goto LABEL_46;
    goto LABEL_10;
  }
  v36(v23, a2);
  v43 = v99;
  v38 = v89;
  v44 = v89(a2, a3);
LABEL_11:
  v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    v46 = v17;
    v47 = v38;
    v36(v46, a2);
    v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }
  v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    v59 = v48;
    goto LABEL_27;
  }
  v47 = v38;
  v58 = v37(a2, a3);
  v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0)
    goto LABEL_26;
LABEL_13:
  v101 = 0x7FFFFFFFFFFFFFFFLL;
  v49 = v37(a2, a3);
  v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v20, v48, a2);
      v36(v20, a2);
      v56 = v48;
      goto LABEL_29;
    }
    goto LABEL_20;
  }
  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }
  v100 = 0x7FFFFFFFFFFFFFFFLL;
  v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v72, v20, a2);
  v36(v72, a2);
  v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0)
    goto LABEL_46;
LABEL_30:
  v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000000) >> 64 != (1000000000000 * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }
  if (__OFADD__(1000000000000 * v74, ((unint64_t)v75 * (unsigned __int128)0xE8D4A51000uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  return 1000000000000 * v75;
}

uint64_t static Duration.microseconds(_:)(double a1)
{
  return specialized Duration.init(_:scale:)(0xE8D4A51000uLL, a1);
}

uint64_t static Duration.nanoseconds<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  void (*v30)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  void (*v34)(char *, char *, uint64_t);
  _BOOL4 v35;
  void (*v36)(char *, uint64_t);
  uint64_t (*v37)(uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, char *, uint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t (*v47)(uint64_t, uint64_t);
  char *v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v54;
  char v55;
  char *v56;
  uint64_t v57;
  char v58;
  char *v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v65;
  char v66;
  uint64_t v67;
  void (*v68)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  void (*v77)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v78;
  char v79;
  uint64_t v80;
  unint64_t v81;
  void (**v82)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v84;
  int64_t v85;
  uint64_t v86;
  BOOL v87;
  uint64_t v88;
  uint64_t (*v89)(uint64_t, uint64_t);
  char *v90;
  unint64_t AssociatedTypeWitness;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  uint64_t v98;
  void (*v99)(char *, char *, uint64_t);
  uint64_t v100;
  int64_t v101;

  v92 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v92, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v6 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v90 = (char *)&v88 - v7;
  v8 = *(_QWORD *)(a2 - 8);
  v9 = MEMORY[0x1E0C80A78](v6);
  v93 = (char *)&v88 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = MEMORY[0x1E0C80A78](v9);
  v94 = (char *)&v88 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v96 = (char *)&v88 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v88 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v88 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v88 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v88 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v29 = (char *)&v88 - v28;
  v101 = 64;
  v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  v95 = (char *)a1;
  v30(a1, &v101, &type metadata for Int, v33, a2, a3);
  v97 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v97(a2, a3);
  v34 = *(void (**)(char *, char *, uint64_t))(v8 + 16);
  v98 = v8;
  v99 = v34;
  v34(v26, v29, a2);
  v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  v36 = *(void (**)(char *, uint64_t))(v98 + 8);
  v36(v26, a2);
  v99(v23, v29, a2);
  v37 = v97;
  if (!v35)
  {
    v36(v23, a2);
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v43 = v99;
    goto LABEL_10;
  }
  v101 = 0x8000000000000000;
  if ((v97(a2, a3) & 1) != 0)
  {
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v39 = v38(a2, a3);
    if (v39 < 64)
    {
      v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      v43 = v99;
      if (v42 < v101)
        goto LABEL_46;
      goto LABEL_10;
    }
    v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v78 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
    v77(&v101, &type metadata for Int64, v78, a2, a3);
    v37 = v97;
    v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    if ((v79 & 1) != 0)
    {
LABEL_46:
      v36(v29, a2);
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/Duration.swift", 20, 2, 0xD9uLL, 0);
    }
    goto LABEL_10;
  }
  v60 = v37(a2, a3);
  v89 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v61 = v89(a2, a3);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      v81 = AssociatedTypeWitness;
      v82 = (void (**)(char *, uint64_t, const char *))v92;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v92, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v84 = v90;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v81, AssociatedConformanceWitness);
      v82[3](v84, a2, (const char *)v82);
      LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
      v36(v20, a2);
      v75 = (uint64_t)v93;
      (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v93, v23, a2);
      v38 = v89;
      if ((v82 & 1) != 0)
      {
LABEL_45:
        v36((char *)v75, a2);
        goto LABEL_46;
      }
      v85 = v101;
      v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36((char *)v75, a2);
      v87 = v86 < v85;
      v43 = v99;
      v37 = v97;
      if (!v87)
        goto LABEL_10;
      goto LABEL_46;
    }
    v64 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v65 = lazy protocol witness table accessor for type Int64 and conformance Int64(v61, v62, v63);
    v64(&v101, &type metadata for Int64, v65, a2, a3);
    v37 = v97;
    v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v20, a2);
    v36(v20, a2);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if ((v66 & 1) != 0)
      goto LABEL_46;
LABEL_10:
    v44 = v38(a2, a3);
    goto LABEL_11;
  }
  if (v61 < 64)
  {
    v80 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    v43 = v99;
    v38 = v89;
    if (v80 < v101)
      goto LABEL_46;
    goto LABEL_10;
  }
  v36(v23, a2);
  v43 = v99;
  v38 = v89;
  v44 = v89(a2, a3);
LABEL_11:
  v45 = v44;
  v43(v17, v29, a2);
  if (v45 >= 65)
  {
    v46 = v17;
    v47 = v38;
    v36(v46, a2);
    v48 = v96;
    v43(v96, v29, a2);
    goto LABEL_13;
  }
  v57 = v38(a2, a3);
  v36(v17, a2);
  if (v57 != 64)
  {
    v48 = v96;
    v43(v96, v29, a2);
LABEL_26:
    v59 = v48;
    goto LABEL_27;
  }
  v47 = v38;
  v58 = v37(a2, a3);
  v48 = v96;
  v43(v96, v29, a2);
  if ((v58 & 1) != 0)
    goto LABEL_26;
LABEL_13:
  v101 = 0x7FFFFFFFFFFFFFFFLL;
  v49 = v37(a2, a3);
  v50 = v47(a2, a3);
  if ((v49 & 1) != 0)
  {
    if (v50 > 64)
    {
      v53 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v54 = lazy protocol witness table accessor for type Int64 and conformance Int64(v50, v51, v52);
      v53(&v101, &type metadata for Int64, v54, a2, a3);
      v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v20, v48, a2);
      v36(v20, a2);
      v56 = v48;
      goto LABEL_29;
    }
    goto LABEL_20;
  }
  if (v50 <= 63)
  {
LABEL_20:
    (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v59 = v20;
LABEL_27:
    v36(v59, a2);
    goto LABEL_30;
  }
  v100 = 0x7FFFFFFFFFFFFFFFLL;
  v67 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v20, v48, a2);
  v68 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v71 = lazy protocol witness table accessor for type Int64 and conformance Int64(v67, v69, v70);
  v72 = v94;
  v68(&v100, &type metadata for Int64, v71, a2, a3);
  v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v72, v20, a2);
  v36(v72, a2);
  v56 = v20;
LABEL_29:
  v36(v56, a2);
  if ((v55 & 1) != 0)
    goto LABEL_46;
LABEL_30:
  v73 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 120);
  v74 = v73(a2, a3);
  v36(v29, a2);
  v43(v20, v95, a2);
  v75 = v73(a2, a3);
  v36(v20, a2);
  if ((unsigned __int128)(v74 * (__int128)1000000000) >> 64 != (1000000000 * v74) >> 63)
  {
    __break(1u);
    goto LABEL_44;
  }
  if (__OFADD__(1000000000 * v74, ((unint64_t)v75 * (unsigned __int128)0x3B9ACA00uLL) >> 64))
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  return 1000000000 * v75;
}

uint64_t Duration.init(from:)(uint64_t *a1)
{
  return specialized Duration.init(from:)(a1);
}

uint64_t Duration.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13[3];
  uint64_t v14;
  uint64_t v15;

  v6 = a1[3];
  v7 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v6);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v7 + 32))(v13, v6, v7);
  v8 = v14;
  v9 = v15;
  __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 96))(a3, v8, v9);
  if (!v3)
  {
    v10 = v14;
    v11 = v15;
    __swift_mutable_project_boxed_opaque_existential_1(v13, v14);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 144))(a2, v10, v11);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v13);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance Duration(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[3];
  uint64_t v13;
  uint64_t v14;

  v3 = *v1;
  v4 = v1[1];
  v5 = a1[3];
  v6 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v5);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v6 + 32))(v12, v5, v6);
  v7 = v13;
  v8 = v14;
  __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 96))(v4, v7, v8);
  if (!v2)
  {
    v9 = v13;
    v10 = v14;
    __swift_mutable_project_boxed_opaque_existential_1(v12, v13);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 144))(v3, v9, v10);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

uint64_t protocol witness for Decodable.init(from:) in conformance Duration@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;

  result = specialized Duration.init(from:)(a1);
  if (!v2)
  {
    *a2 = result;
    a2[1] = v5;
  }
  return result;
}

void Duration.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(a3);
}

Swift::Int Duration.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Duration()
{
  Swift::UInt64 *v0;
  Swift::UInt64 v1;

  v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance Duration()
{
  Swift::UInt64 *v0;
  Swift::UInt64 v1;

  v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance Duration()
{
  Swift::UInt64 *v0;
  Swift::UInt64 v1;

  v1 = v0[1];
  Hasher._combine(_:)(*v0);
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL static Duration.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4 && a1 == a3;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Duration(_QWORD *a1, _QWORD *a2)
{
  return a1[1] == a2[1] && *a1 == *a2;
}

BOOL static Duration.< infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2 == a4)
    return a1 < a3;
  else
    return a2 < a4;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Duration(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v2 == v3;
  v5 = v2 < v3;
  if (v4)
    return *a1 < *a2;
  else
    return v5;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Duration(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v3 == v2;
  v5 = v3 >= v2;
  if (v4)
    return *a2 >= *a1;
  else
    return v5;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Duration(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v2 == v3;
  v5 = v2 >= v3;
  if (v4)
    return *a1 >= *a2;
  else
    return v5;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Duration(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v3 == v2;
  v5 = v3 < v2;
  if (v4)
    return *a2 < *a1;
  else
    return v5;
}

uint64_t static Duration.zero.getter()
{
  return 0;
}

uint64_t protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, specialized static Duration.+ infix(_:_:), a3);
}

_QWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Duration(_QWORD *a1, uint64_t *a2)
{
  return specialized static Duration.+= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Duration@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))specialized static Duration.- infix(_:_:), a3);
}

uint64_t protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t (*a3)(_QWORD, _QWORD, _QWORD, _QWORD)@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result;
  uint64_t v6;

  result = a3(*a1, a1[1], *a2, a2[1]);
  *a4 = result;
  a4[1] = v6;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Duration(unint64_t *a1, uint64_t a2)
{
  return specialized static Duration.-= infix(_:_:)(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8));
}

uint64_t static Duration./= infix(_:_:)(uint64_t a1, double a2)
{
  uint64_t result;
  uint64_t v4;

  result = specialized static Duration./ infix(_:_:)(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), a2);
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = v4;
  return result;
}

unint64_t specialized static Duration./ infix<A>(_:_:)(uint64_t a1, uint64_t a2, Swift::_Int128 dividingBy)
{
  Swift::_Int128 v3;

  if ((dividingBy.low & 0x8000000000000000) != 0)
  {
    if (dividingBy.low == -1 && a2 == 0x8000000000000000 && !a1)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  else if (!dividingBy.low)
  {
    goto LABEL_8;
  }
  v3.high = (uint64_t)dividingBy.low >> 63;
  v3.low = dividingBy.low;
  return (unint64_t)_Int128.quotientAndRemainder(dividingBy:)(v3);
}

unint64_t static Duration./ infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(char *, char *, uint64_t);
  uint64_t v13;
  char *v14;
  void (*v15)(char *, uint64_t, uint64_t);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  Swift::Int64 v19;
  char v20;
  Swift::UInt64 v21;
  Swift::Int64 v22;
  BOOL v23;
  Swift::_Int128 v24;
  uint64_t v28;

  v9 = *(_QWORD *)(a4 - 8);
  v10 = MEMORY[0x1E0C80A78](a1);
  v12 = (void (*)(char *, char *, uint64_t))((char *)&v28 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v28 - v13;
  v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15((char *)&v28 - v13, v16, v17);
  v15((char *)v12, (uint64_t)v14, a4);
  v18 = _Int128.init<A>(exactly:)(v12, a4, a5);
  if ((v20 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000028, 0x8000000181763C20, "Swift/LegacyInt128.swift", 24, 2, 0x27CuLL, 0);
  v21 = v18;
  v22 = v19;
  (*(void (**)(char *, uint64_t))(v9 + 8))(v14, a4);
  if (v22 != -1)
  {
    if (v22)
      v23 = 0;
    else
      v23 = v21 == 0;
    if (!v23)
      goto LABEL_7;
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  if (v21 == -1 && a2 == 0x8000000000000000 && a1 == 0)
    goto LABEL_16;
LABEL_7:
  v24.low = v21;
  v24.high = v22;
  return (unint64_t)_Int128.quotientAndRemainder(dividingBy:)(v24);
}

unint64_t static Duration./= infix<A>(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t result;
  uint64_t v6;

  result = static Duration./ infix<A>(_:_:)(*a1, a1[1], a2, a3, a4);
  *a1 = result;
  a1[1] = v6;
  return result;
}

double static Duration./ infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  double v6;
  double v8;

  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v8, a1, a2);
  v6 = v8;
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v8, a3, a4);
  return v6 / v8;
}

uint64_t static Duration.* infix(_:_:)(unint64_t a1, uint64_t a2, double a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t *TypeName;
  uint64_t v9;
  uint8x16_t *v10;
  int64_t v11;
  int64_t v12;
  int64_t v13;
  char v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  double v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char v29;
  double v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint8x16_t *v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  char v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  char v49;
  double v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  unint64_t v55;
  unint64_t v56;
  char v57;
  unint64_t v58;
  double v59;
  unint64_t v60;
  char v61;

  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v59, a1, a2);
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v59, v59 * a3);
  if ((v61 & 1) != 0)
  {
    *(double *)&v5 = COERCE_DOUBLE(specialized static String._createEmpty(withInitialCapacity:)(80));
    v7 = v6;
    v59 = *(double *)&v5;
    v60 = v6;
    TypeName = (uint64_t *)swift_getTypeName((Class *)&type metadata for Double, 0);
    if (v9 < 0)
      goto LABEL_66;
    v10 = (uint8x16_t *)TypeName;
    v11 = v9;
    v12 = validateUTF8(_:)(TypeName, v9);
    if ((v14 & 1) != 0)
      v15 = repairUTF8(_:firstKnownBrokenRange:)(v10->i8, v11, v12, v13);
    else
      v15 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v10, v11, v12 & 1);
    v17 = v15;
    v18 = v16;
    v19 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000) == 0)
      v19 = v5 & 0xFFFFFFFFFFFFLL;
    if (!v19 && (v5 & ~v7 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v7);
      v59 = *(double *)&v17;
      v60 = v18;
      goto LABEL_21;
    }
    if ((v7 & 0x2000000000000000) != 0)
    {
      if ((v16 & 0x2000000000000000) != 0)
      {
        v21 = specialized _SmallString.init(_:appending:)(v5, v7, v15, v16);
        if ((v23 & 1) == 0)
        {
          v24 = *(double *)&v21;
          v25 = v22;
          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v18);
          v59 = v24;
          v60 = v25;
          v18 = v25;
          *(double *)&v17 = v24;
          goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    else if ((v16 & 0x2000000000000000) != 0)
    {
LABEL_19:
      v20 = HIBYTE(v18) & 0xF;
      goto LABEL_20;
    }
    v20 = v15 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v17, v18, 0, v20);
    swift_bridgeObjectRelease(v18);
    *(double *)&v17 = v59;
    v18 = v60;
LABEL_21:
    v26 = HIBYTE(v18) & 0xF;
    if ((v18 & 0x2000000000000000) == 0)
      v26 = v17 & 0xFFFFFFFFFFFFLL;
    if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
    {
      if ((v18 & 0x2000000000000000) != 0
        && (0x8000000181762940 & 0x2000000000000000) != 0
        && (v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0xD00000000000001ELL, 0x8000000181762940 | 0x8000000000000000), (v29 & 1) == 0))
      {
        v30 = *(double *)&v27;
        v31 = v28;
        swift_bridgeObjectRelease(v18);
        swift_bridgeObjectRelease(0x8000000181762940 | 0x8000000000000000);
        v59 = v30;
        v60 = v31;
      }
      else
      {
        if ((0x8000000181762940 & 0x2000000000000000) != 0)
          v32 = (0x8000000181762940 >> 56) & 0xF;
        else
          v32 = 30;
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x8000000181762940 | 0x8000000000000000, 0, v32);
        swift_bridgeObjectRelease(0x8000000181762940 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v18);
      v59 = -2.31584178e77;
      v60 = 0x8000000181762940 | 0x8000000000000000;
    }
    v33 = (uint64_t *)swift_getTypeName((Class *)&type metadata for _Int128, 0);
    if ((v34 & 0x8000000000000000) == 0)
    {
      v35 = (uint8x16_t *)v33;
      v36 = v34;
      v37 = validateUTF8(_:)(v33, v34);
      if ((v39 & 1) != 0)
        v40 = repairUTF8(_:firstKnownBrokenRange:)(v35->i8, v36, v37, v38);
      else
        v40 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v35, v36, v37 & 1);
      v42 = v40;
      v43 = v41;
      v44 = v60;
      v45 = HIBYTE(v60) & 0xF;
      if ((v60 & 0x2000000000000000) == 0)
        v45 = *(_QWORD *)&v59 & 0xFFFFFFFFFFFFLL;
      if (!v45 && (*(_QWORD *)&v59 & ~v60 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v60);
        v59 = *(double *)&v42;
        v60 = v43;
        goto LABEL_52;
      }
      if ((v60 & 0x2000000000000000) != 0)
      {
        if ((v41 & 0x2000000000000000) != 0)
        {
          v47 = specialized _SmallString.init(_:appending:)(*(unint64_t *)&v59, v60, v40, v41);
          if ((v49 & 1) == 0)
          {
            v50 = *(double *)&v47;
            v51 = v48;
            swift_bridgeObjectRelease(v44);
            swift_bridgeObjectRelease(v43);
            v59 = v50;
            v60 = v51;
            v43 = v51;
            *(double *)&v42 = v50;
            goto LABEL_52;
          }
          goto LABEL_50;
        }
      }
      else if ((v41 & 0x2000000000000000) != 0)
      {
LABEL_50:
        v46 = HIBYTE(v43) & 0xF;
        goto LABEL_51;
      }
      v46 = v40 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v42, v43, 0, v46);
      swift_bridgeObjectRelease(v43);
      *(double *)&v42 = v59;
      v43 = v60;
LABEL_52:
      v52 = HIBYTE(v43) & 0xF;
      if ((v43 & 0x2000000000000000) == 0)
        v52 = v42 & 0xFFFFFFFFFFFFLL;
      if (v52 || (v42 & ~v43 & 0x2000000000000000) != 0)
      {
        if ((v43 & 0x2000000000000000) != 0
          && (0x8000000181762960 & 0x2000000000000000) != 0
          && (v55 = specialized _SmallString.init(_:appending:)(v42, v43, 0xD00000000000002ELL, 0x8000000181762960 | 0x8000000000000000), (v57 & 1) == 0))
        {
          v54 = (char *)v55;
          v53 = v56;
          swift_bridgeObjectRelease(v43);
          swift_bridgeObjectRelease(0x8000000181762960 | 0x8000000000000000);
        }
        else
        {
          if ((0x8000000181762960 & 0x2000000000000000) != 0)
            v58 = (0x8000000181762960 >> 56) & 0xF;
          else
            v58 = 46;
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x8000000181762960 | 0x8000000000000000, 0, v58);
          swift_bridgeObjectRelease(0x8000000181762960 | 0x8000000000000000);
          v54 = *(char **)&v59;
          v53 = v60;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v43);
        v53 = 0x8000000181762960 | 0x8000000000000000;
        v54 = (char *)0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v54, v53, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_66:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return *(_QWORD *)&v59;
}

unint64_t static Duration.* infix<A>(_:_:)(unint64_t a1, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(char *, char *, uint64_t);
  uint64_t v13;
  char *v14;
  void (*v15)(char *, uint64_t, uint64_t);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v24;

  v9 = *(_QWORD *)(a4 - 8);
  v10 = MEMORY[0x1E0C80A78](a1);
  v12 = (void (*)(char *, char *, uint64_t))((char *)&v24 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v24 - v13;
  v15 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v15((char *)&v24 - v13, v16, v17);
  v15((char *)v12, (uint64_t)v14, a4);
  v18 = _Int128.init<A>(exactly:)(v12, a4, a5);
  if ((v20 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000028, 0x8000000181763C20, "Swift/LegacyInt128.swift", 24, 2, 0x27CuLL, 0);
  v21 = v18;
  v22 = v19;
  (*(void (**)(char *, uint64_t))(v9 + 8))(v14, a4);
  return specialized static _Int128.* infix(_:_:)(a1, a2, v21, v22);
}

unint64_t static Duration.*= infix<A>(_:_:)(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(char *, char *, uint64_t);
  unint64_t *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  int64_t v15;
  void (*v16)(char *);
  uint64_t v17;
  unint64_t v18;
  char v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t result;
  unint64_t v23;
  uint64_t v24;

  v7 = *(_QWORD *)(a3 - 8);
  v8 = MEMORY[0x1E0C80A78](a1);
  v10 = (void (*)(char *, char *, uint64_t))((char *)&v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0));
  v11 = (unint64_t *)MEMORY[0x1E0C80A78](v8);
  v13 = (char *)&v24 - v12;
  v14 = *v11;
  v15 = v11[1];
  v16 = *(void (**)(char *))(v7 + 16);
  v16((char *)&v24 - v12);
  ((void (*)(_QWORD, char *, uint64_t))v16)(v10, v13, a3);
  v17 = _Int128.init<A>(exactly:)(v10, a3, a4);
  if ((v19 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000028, 0x8000000181763C20, "Swift/LegacyInt128.swift", 24, 2, 0x27CuLL, 0);
  v20 = v17;
  v21 = v18;
  (*(void (**)(char *, uint64_t))(v7 + 8))(v13, a3);
  result = specialized static _Int128.* infix(_:_:)(v14, v15, v20, v21);
  *a1 = result;
  a1[1] = v23;
  return result;
}

unint64_t Duration.description.getter(unint64_t a1, uint64_t a2)
{
  int64_t v3;
  size_t v4;
  unint64_t v5;
  uint64_t v6;
  int64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  __int128 v19;
  __int128 v20;
  _OWORD __src[2];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)__src, a1, a2);
  if ((~COERCE__INT64(*(double *)__src / 1.0e18) & 0x7FF0000000000000) != 0
    || (COERCE_UNSIGNED_INT64(*(double *)__src / 1.0e18) & 0xFFFFFFFFFFFFFLL) == 0)
  {
    v19 = 0u;
    v20 = 0u;
    v3 = swift_float64ToString(&v19, 32, 0);
    __src[0] = v19;
    __src[1] = v20;
    if (v3 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    v4 = v3;
    if (v3)
    {
      if ((unint64_t)v3 <= 0xF)
      {
        v9 = v3 - 8;
        v10 = 8;
        if (v3 < 8)
          v10 = v3;
        v8 = LOBYTE(__src[0]);
        if (v10 != 1)
        {
          v8 = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
          if (v10 != 2)
          {
            v8 |= (unint64_t)BYTE2(__src[0]) << 16;
            if (v10 != 3)
            {
              v8 |= (unint64_t)BYTE3(__src[0]) << 24;
              if (v10 != 4)
              {
                v8 |= (unint64_t)BYTE4(__src[0]) << 32;
                if (v10 != 5)
                {
                  v8 |= (unint64_t)BYTE5(__src[0]) << 40;
                  if (v10 != 6)
                  {
                    v8 |= (unint64_t)BYTE6(__src[0]) << 48;
                    if (v10 != 7)
                      v8 |= (unint64_t)BYTE7(__src[0]) << 56;
                  }
                }
              }
            }
          }
        }
        v11 = 0;
        if (v4 >= 9)
        {
          v12 = 0;
          v13 = (unsigned __int8 *)__src + 8;
          v14 = v9 & ~(v9 >> 63);
          do
          {
            if (v14 <= v4 - 9)
              _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
            v15 = *v13++;
            v11 |= (unint64_t)v15 << v12;
            v12 += 8;
            --v9;
          }
          while (v9);
        }
        v16 = 0xA000000000000000;
        if (((v11 | v8) & 0x8080808080808080) == 0)
          v16 = 0xE000000000000000;
        v7 = v16 | (v4 << 56) | v11;
      }
      else
      {
        v5 = v3 | 0xF000000000000000;
        v7 = _allocateStringStorage(codeUnitCapacity:)(v3);
        *(_QWORD *)(v7 + 16) = v6;
        *(_QWORD *)(v7 + 24) = v5;
        if (v6 < 0)
        {
          *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
          v5 = *(_QWORD *)(v7 + 24);
        }
        *(_BYTE *)(v7 + 32 + (v5 & 0xFFFFFFFFFFFFLL)) = 0;
        specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v4, (char *)(v7 + 32));
        v8 = *(_QWORD *)(v7 + 24);
      }
    }
    else
    {
      v8 = 0;
      v7 = 0xE000000000000000;
    }
  }
  else
  {
    v7 = 0xE300000000000000;
    v8 = 7233902;
  }
  v17 = specialized static String.+ infix(_:_:)(v8, v7, 0x73646E6F63657320, 0xE800000000000000);
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000);
  return v17;
}

unint64_t Double.description.getter(double a1)
{
  unint64_t result;
  int64_t v2;
  size_t v3;
  unint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned int v13;
  __int128 v14;
  __int128 v15;
  _OWORD __src[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0 && (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL) != 0)
    return 7233902;
  v14 = 0u;
  v15 = 0u;
  v2 = swift_float64ToString(&v14, 32, 0);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v3 = v2;
  if (!v2)
    return 0;
  if ((unint64_t)v2 <= 0xF)
  {
    v7 = v2 - 8;
    v8 = 8;
    if (v2 < 8)
      v8 = v2;
    result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7)
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
              }
            }
          }
        }
      }
    }
    v9 = 0;
    if (v3 >= 9)
    {
      v10 = 0;
      v11 = (unsigned __int8 *)__src + 8;
      v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v4 = v2 | 0xF000000000000000;
    v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(_QWORD *)(v5 + 16) = v6;
    *(_QWORD *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
      v4 = *(_QWORD *)(v5 + 24);
    }
    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(_QWORD *)(v5 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Duration()
{
  uint64_t v0;

  return Duration.description.getter(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
}

unint64_t protocol witness for static DurationProtocol./ infix(_:_:) in conformance Duration@<X0>(Swift::_Int128 dividingBy@<0:X1, 8:X2>, uint64_t *a2@<X0>, uint64_t a3@<X3>, unint64_t *a4@<X8>)
{
  Swift::UInt64 low;
  unint64_t result;
  unint64_t v7;

  low = dividingBy.low;
  result = specialized static Duration./ infix<A>(_:_:)(*a2, a2[1], *(Swift::_Int128 *)(&a3 - 1));
  *a4 = result;
  a4[1] = v7;
  return result;
}

uint64_t specialized static DurationProtocol./= infix(_:_:)(_QWORD *a1, Swift::_Int128 dividingBy)
{
  Swift::_Int128 v4;
  uint64_t result;
  uint64_t v6;

  if ((dividingBy.low & 0x8000000000000000) != 0)
  {
    if (dividingBy.low == -1 && a1[1] == 0x8000000000000000 && *a1 == 0)
LABEL_10:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  else if (!dividingBy.low)
  {
    goto LABEL_10;
  }
  v4.low = dividingBy.low;
  v4.high = (uint64_t)dividingBy.low >> 63;
  *(_OWORD *)&result = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(v4);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t static DurationProtocol./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v11;

  v5 = *(_QWORD *)(a3 - 8);
  v6 = MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(v9 + 24))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

{
  return static DurationProtocol./= infix(_:_:)(a1, a2, a3);
}

unint64_t protocol witness for static DurationProtocol.* infix(_:_:) in conformance Duration@<X0>(uint64_t a1@<X0>, int64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result;
  unint64_t v5;

  result = specialized static _Int128.* infix(_:_:)(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), a2, a2 >> 63);
  *a3 = result;
  a3[1] = v5;
  return result;
}

unint64_t protocol witness for static DurationProtocol.*= infix(_:_:) in conformance Duration(uint64_t a1, int64_t a2)
{
  unint64_t result;
  uint64_t v4;

  result = specialized static _Int128.* infix(_:_:)(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), a2, a2 >> 63);
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = v4;
  return result;
}

uint64_t static DurationProtocol.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v11;

  v5 = *(_QWORD *)(a3 - 8);
  v6 = MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t))(v9 + 40))(v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, a3);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v5 + 32))(a1, v8, a3);
}

{
  return static DurationProtocol.*= infix(_:_:)(a1, a2, a3);
}

double protocol witness for static DurationProtocol./ infix(_:_:) in conformance Duration(uint64_t a1, unint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  double v4;
  double v6;

  v2 = *a2;
  v3 = a2[1];
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v6, *(_QWORD *)a1, *(_QWORD *)(a1 + 8));
  v4 = v6;
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v6, v2, v3);
  return v4 / v6;
}

uint64_t specialized static BinaryFloatingPoint<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void (*v55)(char *, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t (*v58)(uint64_t);
  uint64_t result;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t AssociatedConformanceWitness;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  void (*v71)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void (*v75)(uint64_t, uint64_t);
  char *v76;
  char *v77;
  char *v78;
  _QWORD *v79;
  char *v80;
  char *v81;
  const char *v82;
  unint64_t v83;
  unint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  uint64_t v88;
  void (*v89)(char *, char *, uint64_t, uint64_t);
  char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t (*v95)(char *, uint64_t, uint64_t);
  unint64_t v96;
  void (*v97)(uint64_t *, uint64_t, unint64_t, unint64_t);
  char *v98;
  char *v99;
  unint64_t v100;
  char *v101;
  char *v102;
  const char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  uint64_t (*v113)(char *, char *, uint64_t);
  uint64_t v114;
  char *v115;
  char *v116;
  char *v117;
  char *v118;
  char *v119;
  char *v120;
  unint64_t AssociatedTypeWitness;
  char *v122;
  const char *v123;
  unint64_t *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;

  v126 = a2;
  v110 = a6;
  v10 = *(_QWORD **)(a4 + 16);
  v11 = *(_QWORD *)(v10[2] + 8);
  v123 = *(const char **)(v11 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v123, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v120 = (char *)&v94 - v12;
  v131 = a5;
  v128 = *(_QWORD *)(a5 + 8);
  v104 = *(_QWORD *)(v128 + 24);
  v13 = *(const char **)(v104 + 16);
  v129 = a4;
  v14 = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v103 = v13;
  v100 = swift_getAssociatedTypeWitness(0, v13, v14, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v100);
  v98 = (char *)&v94 - v15;
  v16 = swift_checkMetadataState(0, v14);
  v17 = *(v16 - 1);
  v124 = v16;
  v125 = v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v99 = (char *)&v94 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  v20 = MEMORY[0x1E0C80A78](v18);
  v102 = (char *)&v94 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v101 = (char *)&v94 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v112 = (char *)&v94 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v111 = (uint64_t)&v94 - v27;
  v127 = *(_QWORD *)(a3 - 8);
  v28 = MEMORY[0x1E0C80A78](v26);
  v122 = (char *)&v94 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v116 = (char *)&v94 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v115 = (char *)&v94 - v33;
  v34 = MEMORY[0x1E0C80A78](v32);
  v117 = (char *)&v94 - v35;
  v36 = MEMORY[0x1E0C80A78](v34);
  v119 = (char *)&v94 - v37;
  v38 = MEMORY[0x1E0C80A78](v36);
  v118 = (char *)&v94 - v39;
  v40 = MEMORY[0x1E0C80A78](v38);
  v42 = (char *)&v94 - v41;
  MEMORY[0x1E0C80A78](v40);
  v44 = (char *)&v94 - v43;
  v46 = type metadata accessor for Range(0, a3, *(_QWORD *)(v10[3] + 8), v45);
  v47 = *(_QWORD *)(v46 - 8);
  MEMORY[0x1E0C80A78](v46);
  v49 = (char *)&v94 - v48;
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))((char *)&v94 - v48, a1, v46);
  v50 = &v49[*(int *)(v46 + 36)];
  v130 = v10;
  v51 = *(_QWORD *)(v10[1] + 8);
  v113 = *(uint64_t (**)(char *, char *, uint64_t))(v51 + 8);
  v114 = v51;
  if ((v113(v49, v50, a3) & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't get random value with an empty range", 42, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x34uLL, 0);
  (*(void (**)(char *, uint64_t))(v47 + 8))(v49, v46);
  v52 = a1 + *(int *)(v46 + 36);
  v53 = *(_QWORD *)(v11 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v53 + 40))(v52, a1, a3, v53);
  v54 = v127;
  (*(void (**)(char *, char *, uint64_t))(v127 + 16))(v42, v44, a3);
  if ((((uint64_t (*)(uint64_t))v130[47])(a3) & 1) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x3EuLL, 0);
  v105 = v53;
  v106 = v52;
  v107 = v44;
  v108 = v11;
  v109 = a1;
  v55 = *(void (**)(char *, uint64_t))(v54 + 8);
  v55(v42, a3);
  v56 = (uint64_t)v124;
  v57 = (*(uint64_t (**)(unint64_t *))(v131 + 56))(v124);
  v58 = *(uint64_t (**)(uint64_t))(v129 + 104);
  result = v58(a3);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_15;
  }
  if (v57 == result + 1)
  {
    v60 = v111;
    specialized static FixedWidthInteger._random<A>(using:)(v56, v131, v111);
    v61 = v128;
    v62 = v125;
    v63 = v112;
    goto LABEL_8;
  }
  result = ((uint64_t (*)(uint64_t, uint64_t))v58)(a3, v129);
  v64 = result + 1;
  if (__OFADD__(result, 1))
  {
LABEL_15:
    __break(1u);
    return result;
  }
  v65 = (uint64_t)v103;
  v66 = v100;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v103, v56, v100, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v97 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  v96 = AssociatedConformanceWitness;
  v68 = v98;
  v97(&qword_1816B7DB0, 512, v66, AssociatedConformanceWitness);
  v95 = *(uint64_t (**)(char *, uint64_t, uint64_t))(v65 + 24);
  v69 = (uint64_t)v101;
  v70 = v95(v68, v56, v65);
  v132 = v64;
  v71 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v128 + 256);
  v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v72, v73);
  v63 = v112;
  v71(v69, &v132, &type metadata for Int, v74, v56, v128);
  v75 = *(void (**)(uint64_t, uint64_t))(v125 + 8);
  v75(v69, v56);
  specialized static FixedWidthInteger._random<A>(using:)(v56, v131, v69);
  v97(&qword_1816B7DB0, 512, v66, v96);
  v76 = v99;
  v95(v68, v56, v65);
  v77 = v102;
  (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v104 + 8) + 40))(v63, v76, v56);
  v78 = v76;
  v61 = v128;
  v75((uint64_t)v78, v56);
  v75((uint64_t)v63, v56);
  v60 = v111;
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t))(v61 + 192))(v69, v77, v56, v61);
  v75((uint64_t)v77, v56);
  v75(v69, v56);
  v62 = v125;
LABEL_8:
  (*(void (**)(char *, uint64_t, uint64_t))(v62 + 32))(v63, v60, v56);
  v79 = v130;
  v80 = v119;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, _QWORD *))v130[9])(v63, v56, v61, a3, v130);
  v81 = v115;
  ((void (*)(uint64_t, _QWORD *))v79[18])(a3, v79);
  v82 = v123;
  v83 = AssociatedTypeWitness;
  v84 = swift_getAssociatedConformanceWitness((uint64_t)v123, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v85 = v120;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v84 + 8))(&unk_1816B7DC0, 768, v83, v84);
  v86 = v116;
  (*((void (**)(char *, uint64_t, const char *))v82 + 3))(v85, a3, v82);
  v87 = v117;
  ((void (*)(char *, char *, uint64_t, _QWORD *))v79[24])(v81, v86, a3, v79);
  v55(v86, a3);
  v55(v81, a3);
  v88 = v108;
  v89 = *(void (**)(char *, char *, uint64_t, uint64_t))(v108 + 64);
  v90 = v118;
  v89(v80, v87, a3, v108);
  v55(v87, a3);
  v55(v80, a3);
  v91 = v107;
  v89(v107, v90, a3, v88);
  v55(v90, a3);
  v55(v91, a3);
  v92 = v122;
  v93 = v109;
  (*(void (**)(char *, uint64_t, uint64_t))(v105 + 24))(v80, v109, a3);
  v55(v80, a3);
  if ((((uint64_t (*)(char *, uint64_t, uint64_t, uint64_t))v113)(v92, v106, a3, v114) & 1) == 0)
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v127 + 32))(v110, v92, a3);
  v55(v92, a3);
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(v93, v126, a3, v129, v131);
}

{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(void);
  uint64_t (*v46)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v47)(uint64_t, _QWORD *);
  void (*v48)(char *, uint64_t);
  uint64_t v49;
  uint64_t v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t result;
  char *v53;
  char v54;
  char *v55;
  _QWORD *v56;
  char v57;
  void (*v58)(char *, unint64_t *);
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t AssociatedConformanceWitness;
  unint64_t v63;
  char *v64;
  uint64_t v65;
  void (*v66)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, _QWORD *);
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  char v72;
  _QWORD *v73;
  char *v74;
  char *v75;
  unint64_t v76;
  const char *v77;
  unint64_t v78;
  char *v79;
  void (*v80)(char *, uint64_t);
  char *v81;
  char *v82;
  uint64_t v83;
  void (*v84)(char *, char *, uint64_t, uint64_t);
  char *v85;
  char *v86;
  uint64_t (*v87)(char *, unint64_t *, uint64_t);
  void (*v88)(uint64_t *, uint64_t, unint64_t, unint64_t);
  uint64_t v89;
  uint64_t v90;
  char *v91;
  char *v92;
  unint64_t v93;
  const char *v94;
  uint64_t v95;
  uint64_t (*v96)(uint64_t, uint64_t, uint64_t);
  uint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  char *v101;
  _QWORD *v102;
  char *v103;
  char *v104;
  unint64_t AssociatedTypeWitness;
  const char *v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  void (*v110)(char *, uint64_t);
  char *v111;
  char *v112;
  uint64_t v113;
  char *v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t __buf;

  v113 = a2;
  v116 = a6;
  v10 = *(_QWORD **)(a4 + 16);
  v11 = *(_QWORD *)(v10[2] + 8);
  v106 = *(const char **)(v11 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v106, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v104 = (char *)&v87 - v12;
  v118 = a5;
  v115 = *(_QWORD **)(a5 + 8);
  v95 = v115[3];
  v13 = *(const char **)(v95 + 16);
  v14 = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v94 = v13;
  v93 = swift_getAssociatedTypeWitness(0, v13, v14, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v93);
  v91 = (char *)&v87 - v15;
  v16 = swift_checkMetadataState(0, v14);
  v117 = *(v16 - 1);
  v17 = MEMORY[0x1E0C80A78](v16);
  v92 = (char *)&v87 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v111 = (char *)&v87 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v87 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v112 = (char *)&v87 - v25;
  v26 = *(_QWORD *)(a3 - 8);
  v27 = MEMORY[0x1E0C80A78](v24);
  v99 = (char *)&v87 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  v29 = MEMORY[0x1E0C80A78](v27);
  v98 = (char *)&v87 - v30;
  v31 = MEMORY[0x1E0C80A78](v29);
  v100 = (char *)&v87 - v32;
  v33 = MEMORY[0x1E0C80A78](v31);
  v103 = (char *)&v87 - v34;
  v35 = MEMORY[0x1E0C80A78](v33);
  v101 = (char *)&v87 - v36;
  v37 = MEMORY[0x1E0C80A78](v35);
  v39 = (char *)&v87 - v38;
  MEMORY[0x1E0C80A78](v37);
  v41 = (char *)&v87 - v40;
  v43 = a1 + *(int *)(type metadata accessor for ClosedRange(0, a3, *(_QWORD *)(v10[3] + 8), v42) + 36);
  v107 = v11;
  v44 = *(_QWORD *)(v11 + 8);
  v45 = *(void (**)(void))(v44 + 40);
  v97 = v43;
  v108 = a1;
  v45();
  v46 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v26 + 16);
  v114 = v41;
  v96 = v46;
  v46((uint64_t)v39, (uint64_t)v41, a3);
  v47 = (uint64_t (*)(uint64_t, _QWORD *))v10[47];
  v102 = v10;
  if ((v47(a3, v10) & 1) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0xA2uLL, 0);
  v48 = *(void (**)(char *, uint64_t))(v26 + 8);
  v109 = v23;
  v110 = v48;
  v48(v39, a3);
  v49 = v118;
  v50 = (*(uint64_t (**)(unint64_t *, uint64_t))(v118 + 56))(v16, v118);
  v51 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 104);
  result = v51(a3, a4);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_14;
  }
  v90 = v44;
  if (v50 == result + 1)
  {
    v53 = v112;
    specialized static FixedWidthInteger._random<A>(using:)((uint64_t)v16, v49, (uint64_t)v112);
    __buf = 0;
    swift_stdlib_random(&__buf, 8uLL);
    v54 = __buf;
    v55 = v109;
    (*(void (**)(unint64_t *, uint64_t))(v49 + 64))(v16, v49);
    v56 = v115;
    v57 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(v115[2] + 8) + 8))(v53, v55, v16);
    v58 = *(void (**)(char *, unint64_t *))(v117 + 8);
    v58(v55, v16);
    if ((v57 & 1) == 0 || (v54 & 1) == 0)
      goto LABEL_10;
LABEL_7:
    v58(v53, v16);
    v110(v114, a3);
    return v96(v116, v97, a3);
  }
  result = v51(a3, a4);
  v59 = result + 1;
  if (__OFADD__(result, 1))
  {
LABEL_14:
    __break(1u);
    return result;
  }
  v60 = (uint64_t)v94;
  v61 = v93;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v94, (uint64_t)v16, v93, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v89 = a4;
  v63 = AssociatedConformanceWitness;
  v88 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  v64 = v91;
  v88(&qword_1816B7DB0, 512, v61, AssociatedConformanceWitness);
  v87 = *(uint64_t (**)(char *, unint64_t *, uint64_t))(v60 + 24);
  v55 = v109;
  v65 = v87(v64, v16, v60);
  __buf = v59;
  v56 = v115;
  v66 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, _QWORD *))v115[32];
  v69 = lazy protocol witness table accessor for type Int and conformance Int(v65, v67, v68);
  v66(v55, &__buf, &type metadata for Int, v69, v16, v56);
  v58 = *(void (**)(char *, unint64_t *))(v117 + 8);
  v58(v55, v16);
  v88(&qword_1816B7DB0, 512, v61, v63);
  v70 = v92;
  v87(v64, v16, v60);
  v71 = v111;
  (*(void (**)(char *, char *, unint64_t *))(*(_QWORD *)(v95 + 8) + 24))(v111, v70, v16);
  v58(v70, v16);
  swift_getAssociatedConformanceWitness(v89, a3, (uint64_t)v16, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, (uint64_t)&associated conformance descriptor for BinaryFloatingPoint.BinaryFloatingPoint.RawSignificand: UnsignedInteger);
  v53 = v112;
  specialized RandomNumberGenerator.next<A>(upperBound:)(v55, (uint64_t)v16, v118, v112);
  v58(v55, v16);
  v72 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(v56[2] + 8) + 8))(v53, v71, v16);
  v58(v71, v16);
  if ((v72 & 1) != 0)
    goto LABEL_7;
LABEL_10:
  (*(void (**)(char *, char *, unint64_t *))(v117 + 32))(v55, v53, v16);
  v73 = v102;
  v74 = v103;
  ((void (*)(char *, unint64_t *, _QWORD *, uint64_t, _QWORD *))v102[9])(v55, v16, v56, a3, v102);
  v75 = v98;
  ((void (*)(uint64_t, _QWORD *))v73[18])(a3, v73);
  v76 = AssociatedTypeWitness;
  v77 = v106;
  v78 = swift_getAssociatedConformanceWitness((uint64_t)v106, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v79 = v104;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v78 + 8))(&unk_1816B7DC0, 768, v76, v78);
  v80 = v110;
  v81 = v99;
  (*((void (**)(char *, uint64_t, const char *))v77 + 3))(v79, a3, v77);
  v82 = v100;
  ((void (*)(char *, char *, uint64_t, _QWORD *))v73[24])(v75, v81, a3, v73);
  v80(v81, a3);
  v80(v75, a3);
  v83 = v107;
  v84 = *(void (**)(char *, char *, uint64_t, uint64_t))(v107 + 64);
  v85 = v101;
  v84(v74, v82, a3, v107);
  v80(v82, a3);
  v80(v74, a3);
  v86 = v114;
  v84(v114, v85, a3, v83);
  v80(v85, a3);
  v80(v86, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v90 + 24))(v74, v108, a3);
  return ((uint64_t (*)(char *, uint64_t))v80)(v74, a3);
}

uint64_t static BinaryFloatingPoint<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  _QWORD *v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  uint64_t (*v51)(char *, uint64_t, uint64_t, uint64_t);
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void (*v55)(char *, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t (*v58)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t AssociatedConformanceWitness;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  void (*v71)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  void (*v75)(uint64_t, unint64_t *);
  char *v76;
  char *v77;
  uint64_t v78;
  char *v79;
  _QWORD *v80;
  char *v81;
  char *v82;
  const char *v83;
  unint64_t v84;
  unint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  _QWORD *v89;
  void (*v90)(char *, char *, uint64_t, _QWORD *);
  char *v91;
  void (*v92)(char *, uint64_t);
  char *v93;
  char *v94;
  uint64_t v95;
  uint64_t (*v96)(char *, unint64_t *, uint64_t);
  void (*v97)(uint64_t *, uint64_t, unint64_t, unint64_t);
  void (*v98)(char *, uint64_t);
  char *v99;
  char *v100;
  unint64_t v101;
  char *v102;
  char *v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  uint64_t (*v113)(char *, uint64_t, uint64_t, uint64_t);
  uint64_t v114;
  char *v115;
  char *v116;
  char *v117;
  char *v118;
  char *v119;
  char *v120;
  unint64_t AssociatedTypeWitness;
  char *v122;
  const char *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  _QWORD *v131;
  _QWORD *v132;
  uint64_t v133;
  uint64_t v134;

  v126 = a4;
  v127 = a6;
  v125 = a2;
  v110 = a8;
  v12 = *(_QWORD **)(a5 + 16);
  v132 = *(_QWORD **)(v12[2] + 8);
  v123 = (const char *)v132[2];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v123, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v120 = (char *)&v96 - v13;
  v133 = a7;
  v130 = *(_QWORD *)(a7 + 8);
  v105 = *(_QWORD *)(v130 + 24);
  v14 = *(const char **)(v105 + 16);
  v128 = a5;
  v15 = swift_getAssociatedTypeWitness(255, (const char *)a5, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v104 = v14;
  v101 = swift_getAssociatedTypeWitness(0, v14, v15, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v101);
  v99 = (char *)&v96 - v16;
  v17 = swift_checkMetadataState(0, v15);
  v124 = *(v17 - 1);
  v18 = MEMORY[0x1E0C80A78](v17);
  v100 = (char *)&v96 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  v20 = MEMORY[0x1E0C80A78](v18);
  v103 = (char *)&v96 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v102 = (char *)&v96 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v112 = (char *)&v96 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v111 = (uint64_t)&v96 - v27;
  v129 = *(_QWORD *)(a3 - 8);
  v28 = MEMORY[0x1E0C80A78](v26);
  v122 = (char *)&v96 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v116 = (char *)&v96 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v115 = (char *)&v96 - v33;
  v34 = MEMORY[0x1E0C80A78](v32);
  v117 = (char *)&v96 - v35;
  v36 = MEMORY[0x1E0C80A78](v34);
  v119 = (char *)&v96 - v37;
  v38 = MEMORY[0x1E0C80A78](v36);
  v118 = (char *)&v96 - v39;
  v40 = MEMORY[0x1E0C80A78](v38);
  v42 = (char *)&v96 - v41;
  MEMORY[0x1E0C80A78](v40);
  v44 = (char *)&v96 - v43;
  v46 = type metadata accessor for Range(0, a3, *(_QWORD *)(v12[3] + 8), v45);
  v47 = *(_QWORD *)(v46 - 8);
  MEMORY[0x1E0C80A78](v46);
  v49 = (char *)&v96 - v48;
  (*(void (**)(char *, uint64_t, uint64_t))(v47 + 16))((char *)&v96 - v48, a1, v46);
  v50 = &v49[*(int *)(v46 + 36)];
  v131 = v12;
  v51 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v12[1] + 8) + 8);
  v114 = *(_QWORD *)(v12[1] + 8);
  v113 = v51;
  if ((((uint64_t (*)(char *, char *, uint64_t))v51)(v49, v50, a3) & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't get random value with an empty range", 42, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x34uLL, 0);
  (*(void (**)(char *, uint64_t))(v47 + 8))(v49, v46);
  v52 = a1 + *(int *)(v46 + 36);
  v53 = v132[1];
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v53 + 40))(v52, a1, a3, v53);
  v54 = v129;
  (*(void (**)(char *, char *, uint64_t))(v129 + 16))(v42, v44, a3);
  if ((((uint64_t (*)(uint64_t))v131[47])(a3) & 1) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0x3EuLL, 0);
  v107 = v53;
  v108 = v44;
  v109 = a1;
  v55 = *(void (**)(char *, uint64_t))(v54 + 8);
  v55(v42, a3);
  v56 = (*(uint64_t (**)(unint64_t *))(v133 + 56))(v17);
  v57 = v128;
  v58 = *(uint64_t (**)(uint64_t, uint64_t))(v128 + 104);
  result = v58(a3, v128);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_16;
  }
  v106 = v52;
  if (v56 == result + 1)
  {
    v60 = v111;
    static FixedWidthInteger._random<A>(using:)(v125, (uint64_t)v17, v126, v133, v127, v111);
    v61 = v130;
    v62 = v124;
    v63 = v112;
    goto LABEL_9;
  }
  result = v58(a3, v57);
  v64 = result + 1;
  if (__OFADD__(result, 1))
  {
LABEL_16:
    __break(1u);
    return result;
  }
  v98 = v55;
  v65 = (uint64_t)v104;
  v66 = v101;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v104, (uint64_t)v17, v101, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v97 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
  v68 = v99;
  v97(&qword_1816B7DB0, 512, v66, AssociatedConformanceWitness);
  v96 = *(uint64_t (**)(char *, unint64_t *, uint64_t))(v65 + 24);
  v69 = (uint64_t)v102;
  v70 = v96(v68, v17, v65);
  v134 = v64;
  v71 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v130 + 256);
  v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v72, v73);
  v63 = v112;
  v71(v69, &v134, &type metadata for Int, v74, v17, v130);
  v75 = *(void (**)(uint64_t, unint64_t *))(v124 + 8);
  v75(v69, v17);
  static FixedWidthInteger._random<A>(using:)(v125, (uint64_t)v17, v126, v133, v127, v69);
  v97(&qword_1816B7DB0, 512, v66, AssociatedConformanceWitness);
  v76 = v100;
  v77 = v68;
  v61 = v130;
  v78 = v65;
  v55 = v98;
  v96(v77, v17, v78);
  v79 = v103;
  (*(void (**)(char *, char *, unint64_t *))(*(_QWORD *)(v105 + 8) + 40))(v63, v76, v17);
  v75((uint64_t)v76, v17);
  v75((uint64_t)v63, v17);
  v60 = v111;
  (*(void (**)(uint64_t, char *, unint64_t *, uint64_t))(v61 + 192))(v69, v79, v17, v61);
  v75((uint64_t)v79, v17);
  v75(v69, v17);
  v62 = v124;
LABEL_9:
  (*(void (**)(char *, uint64_t, unint64_t *))(v62 + 32))(v63, v60, v17);
  v80 = v131;
  v81 = v119;
  ((void (*)(char *, unint64_t *, uint64_t, uint64_t, _QWORD *))v131[9])(v63, v17, v61, a3, v131);
  v82 = v115;
  ((void (*)(uint64_t, _QWORD *))v80[18])(a3, v80);
  v83 = v123;
  v84 = AssociatedTypeWitness;
  v85 = swift_getAssociatedConformanceWitness((uint64_t)v123, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v86 = v120;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v85 + 8))(&unk_1816B7DC0, 768, v84, v85);
  v87 = v116;
  (*((void (**)(char *, uint64_t, const char *))v83 + 3))(v86, a3, v83);
  v88 = v117;
  ((void (*)(char *, char *, uint64_t, _QWORD *))v80[24])(v82, v87, a3, v80);
  v55(v87, a3);
  v55(v82, a3);
  v89 = v132;
  v90 = (void (*)(char *, char *, uint64_t, _QWORD *))v132[8];
  v91 = v118;
  v90(v81, v88, a3, v132);
  v55(v88, a3);
  v55(v81, a3);
  v92 = v55;
  v93 = v108;
  v90(v108, v91, a3, v89);
  v92(v91, a3);
  v92(v93, a3);
  v94 = v122;
  v95 = v109;
  (*(void (**)(char *, uint64_t, uint64_t))(v107 + 24))(v81, v109, a3);
  v92(v81, a3);
  if ((v113(v94, v106, a3, v114) & 1) == 0)
    return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v129 + 32))(v110, v94, a3);
  v92(v94, a3);
  return static BinaryFloatingPoint<>.random<A>(in:using:)(v95, v125, a3, v126, v128, v127, v133);
}

{
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(void);
  void (*v47)(char *, char *, uint64_t);
  uint64_t (*v48)(uint64_t, _QWORD *);
  void (*v49)(char *, uint64_t);
  uint64_t (*v50)(unint64_t *, uint64_t);
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  char *v59;
  _QWORD *v60;
  char v61;
  uint64_t v62;
  void (*v63)(char *, unint64_t *);
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t AssociatedConformanceWitness;
  char *v68;
  char *v69;
  uint64_t v70;
  void (*v71)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, _QWORD *);
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  void (*v76)(char *, unint64_t *);
  char *v77;
  char *v78;
  uint64_t (*v79)(uint64_t, uint64_t, uint64_t);
  char *v80;
  char *v81;
  char v82;
  char *v83;
  char *v84;
  _QWORD *v85;
  char *v86;
  char *v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  void (*v95)(char *, uint64_t);
  uint64_t v96;
  void (*v97)(char *, char *, uint64_t, uint64_t);
  char *v98;
  char *v99;
  uint64_t v100;
  uint64_t (*v101)(char *, unint64_t *, uint64_t);
  void (*v102)(uint64_t *, uint64_t, unint64_t, unint64_t);
  void (*v103)(char *, char *, uint64_t);
  char *v104;
  char *v105;
  unint64_t v106;
  char *v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  _QWORD *v111;
  char *v112;
  uint64_t v113;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  const char *v120;
  uint64_t v121;
  uint64_t v122;
  void (*v123)(char *, uint64_t);
  uint64_t v124;
  char *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  char *v129;
  uint64_t v130;
  uint64_t v131;
  char *v132;
  _QWORD *v133;
  uint64_t v134;

  v127 = a2;
  v128 = a6;
  v126 = a4;
  v130 = a8;
  v12 = *(_QWORD **)(a5 + 16);
  v13 = *(_QWORD *)(v12[2] + 8);
  v120 = *(const char **)(v13 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v100 - v14;
  v133 = *(_QWORD **)(a7 + 8);
  v109 = v133[3];
  v15 = *(const char **)(v109 + 16);
  v16 = swift_getAssociatedTypeWitness(255, (const char *)a5, a3, (uint64_t)&protocol requirements base descriptor for BinaryFloatingPoint, associated type descriptor for BinaryFloatingPoint.RawSignificand);
  v108 = v15;
  v106 = swift_getAssociatedTypeWitness(0, v15, v16, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v106);
  v104 = (char *)&v100 - v17;
  v18 = swift_checkMetadataState(0, v16);
  v131 = *(v18 - 1);
  v19 = MEMORY[0x1E0C80A78](v18);
  v105 = (char *)&v100 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = MEMORY[0x1E0C80A78](v19);
  v107 = (char *)&v100 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v132 = (char *)&v100 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v125 = (char *)&v100 - v26;
  v27 = *(_QWORD *)(a3 - 8);
  v28 = MEMORY[0x1E0C80A78](v25);
  v114 = (char *)&v100 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v112 = (char *)&v100 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v115 = (char *)&v100 - v33;
  v34 = MEMORY[0x1E0C80A78](v32);
  v117 = (char *)&v100 - v35;
  v36 = MEMORY[0x1E0C80A78](v34);
  v116 = (char *)&v100 - v37;
  v38 = MEMORY[0x1E0C80A78](v36);
  v40 = (char *)&v100 - v39;
  MEMORY[0x1E0C80A78](v38);
  v42 = (char *)&v100 - v41;
  v44 = a1 + *(int *)(type metadata accessor for ClosedRange(0, a3, *(_QWORD *)(v12[3] + 8), v43) + 36);
  v121 = v13;
  v45 = *(_QWORD *)(v13 + 8);
  v46 = *(void (**)(void))(v45 + 40);
  v110 = v44;
  v122 = a1;
  v113 = v45;
  v46();
  v47 = *(void (**)(char *, char *, uint64_t))(v27 + 16);
  v129 = v42;
  v47(v40, v42, a3);
  v48 = (uint64_t (*)(uint64_t, _QWORD *))v12[47];
  v111 = v12;
  if ((v48(a3, v12) & 1) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "There is no uniform distribution on an infinite range", 53, 2, "Swift/FloatingPointRandom.swift", 31, 2, 0xA2uLL, 0);
  v49 = *(void (**)(char *, uint64_t))(v27 + 8);
  v49(v40, a3);
  v50 = *(uint64_t (**)(unint64_t *, uint64_t))(a7 + 56);
  v124 = a7;
  v51 = v50(v18, a7);
  v52 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 104);
  result = v52(a3, a5);
  if (__OFADD__(result, 1))
  {
    __break(1u);
    goto LABEL_14;
  }
  v123 = v49;
  if (v51 != result + 1)
  {
    result = v52(a3, a5);
    v64 = result + 1;
    if (!__OFADD__(result, 1))
    {
      v103 = v47;
      v65 = (uint64_t)v108;
      v66 = v106;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v108, (uint64_t)v18, v106, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v102 = *(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8);
      v68 = v104;
      v102(&qword_1816B7DB0, 512, v66, AssociatedConformanceWitness);
      v101 = *(uint64_t (**)(char *, unint64_t *, uint64_t))(v65 + 24);
      v69 = v132;
      v70 = v101(v68, v18, v65);
      v134 = v64;
      v71 = (void (*)(char *, uint64_t *, ValueMetadata *, unint64_t, unint64_t *, _QWORD *))v133[32];
      v74 = lazy protocol witness table accessor for type Int and conformance Int(v70, v72, v73);
      v75 = v107;
      v71(v69, &v134, &type metadata for Int, v74, v18, v133);
      v76 = *(void (**)(char *, unint64_t *))(v131 + 8);
      v76(v69, v18);
      v102(&qword_1816B7DB0, 512, v66, AssociatedConformanceWitness);
      v77 = v105;
      v78 = v68;
      v60 = v133;
      v79 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v103;
      v101(v78, v18, v65);
      (*(void (**)(char *, char *, unint64_t *))(*(_QWORD *)(v109 + 8) + 24))(v75, v77, v18);
      v76(v77, v18);
      v80 = v125;
      RandomNumberGenerator.next<A>(upperBound:)(v69, v126, (uint64_t)v18, v128, v124, v125);
      v81 = v69;
      v55 = v80;
      v76(v81, v18);
      v82 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(v60[2] + 8) + 8))(v80, v75, v18);
      v83 = v75;
      v62 = v131;
      v76(v83, v18);
      if ((v82 & 1) != 0)
      {
        v76(v80, v18);
        v123(v129, a3);
        return v79(v130, v110, a3);
      }
      goto LABEL_10;
    }
LABEL_14:
    __break(1u);
    return result;
  }
  v55 = v125;
  v54 = v126;
  v56 = v128;
  v57 = v124;
  static FixedWidthInteger._random<A>(using:)(v127, (uint64_t)v18, v126, v124, v128, (uint64_t)v125);
  v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v56 + 8))(v54, v56);
  v59 = v132;
  (*(void (**)(unint64_t *, uint64_t))(v57 + 64))(v18, v57);
  v60 = v133;
  v61 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(v133[2] + 8) + 8))(v55, v59, v18);
  v62 = v131;
  v63 = *(void (**)(char *, unint64_t *))(v131 + 8);
  v63(v59, v18);
  if ((v61 & 1) != 0 && (v58 & 1) != 0)
  {
    v63(v55, v18);
    v123(v129, a3);
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v47)(v130, v110, a3);
  }
LABEL_10:
  v84 = v132;
  (*(void (**)(char *, char *, unint64_t *))(v62 + 32))(v132, v55, v18);
  v85 = v111;
  v86 = v117;
  ((void (*)(char *, unint64_t *, _QWORD *, uint64_t, _QWORD *))v111[9])(v84, v18, v60, a3, v111);
  v87 = v112;
  ((void (*)(uint64_t, _QWORD *))v85[18])(a3, v85);
  v88 = AssociatedTypeWitness;
  v89 = v120;
  v90 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v91 = v118;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v90 + 8))(&unk_1816B7DC0, 768, v88, v90);
  v92 = v114;
  (*((void (**)(char *, uint64_t, const char *))v89 + 3))(v91, a3, v89);
  v93 = v115;
  ((void (*)(char *, char *, uint64_t, _QWORD *))v85[24])(v87, v92, a3, v85);
  v94 = v92;
  v95 = v123;
  v123(v94, a3);
  v95(v87, a3);
  v96 = v121;
  v97 = *(void (**)(char *, char *, uint64_t, uint64_t))(v121 + 64);
  v98 = v116;
  v97(v86, v93, a3, v121);
  v95(v93, a3);
  v95(v86, a3);
  v99 = v129;
  v97(v129, v98, a3, v96);
  v95(v98, a3);
  v95(v99, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v113 + 24))(v86, v122, a3);
  return ((uint64_t (*)(char *, uint64_t))v95)(v86, a3);
}

uint64_t static BinaryFloatingPoint<>.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5);
}

{
  return specialized static BinaryFloatingPoint<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5);
}

uint64_t Int128._value.setter(uint64_t result, uint64_t a2)
{
  _QWORD *v2;

  *v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t (*Int128._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int128._high.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t static Int128.zero.getter()
{
  return 0;
}

uint64_t static Int128.min.getter()
{
  return 0;
}

uint64_t static Int128.max.getter()
{
  return -1;
}

uint64_t Int128.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 8 <= 0x80)
    return *(_QWORD *)a1;
  else
    return 0;
}

uint64_t Int128.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  void (*v30)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  void (*v34)(char *, char *, uint64_t);
  _BOOL4 v35;
  void (*v36)(char *, uint64_t);
  uint64_t (*v37)(uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t (*v44)(uint64_t, uint64_t);
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  uint64_t (*v49)(uint64_t, uint64_t);
  uint64_t v50;
  char v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v57;
  char *v58;
  char v59;
  char *v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void (*v65)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v66;
  char *v67;
  char v68;
  char *v69;
  char *v70;
  void (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  void (*v73)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v74;
  char *v75;
  char v76;
  uint64_t v77;
  BOOL v78;
  char *v79;
  uint64_t v80;
  void (*v81)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  char *v85;
  const char *v86;
  unint64_t AssociatedConformanceWitness;
  char *v88;
  char *v89;
  char v90;
  char *v91;
  int64_t v92;
  uint64_t v93;
  uint64_t v95;
  uint64_t (*v96)(uint64_t, uint64_t);
  char *v97;
  const char *v98;
  char *v99;
  char *v100;
  char *v101;
  char *v102;
  char *v103;
  char *v104;
  uint64_t (*v105)(uint64_t, uint64_t);
  uint64_t v106;
  uint64_t v107;
  int64_t v108;

  v98 = *(const char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v98, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v97 = (char *)&v95 - v8;
  v9 = *(_QWORD *)(a2 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v99 = (char *)&v95 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v95 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v102 = (char *)&v95 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v103 = (char *)&v95 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v101 = (char *)&v95 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v95 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v95 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v29 = (char *)&v95 - v28;
  v108 = 64;
  v30 = *(void (**)(uint64_t, int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  v33 = lazy protocol witness table accessor for type Int and conformance Int(v27, v31, v32);
  v104 = (char *)a1;
  v30(a1, &v108, &type metadata for Int, v33, a2, a3);
  v105 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v105(a2, a3);
  v106 = v9;
  v34 = *(void (**)(char *, char *, uint64_t))(v9 + 16);
  v34(v26, v29, a2);
  v100 = v14;
  v35 = (a1 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  v36 = *(void (**)(char *, uint64_t))(v106 + 8);
  v36(v26, a2);
  v34(v23, v29, a2);
  if (!v35)
  {
    v36(v23, a2);
    v44 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v43 = v104;
    goto LABEL_10;
  }
  v108 = 0x8000000000000000;
  v37 = v105;
  if ((v105(a2, a3) & 1) != 0)
  {
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v39 = v38(a2, a3);
    if (v39 >= 64)
    {
      v73 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v74 = lazy protocol witness table accessor for type Int64 and conformance Int64(v39, v40, v41);
      v75 = v101;
      v73(&v108, &type metadata for Int64, v74, a2, a3);
      v76 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v75, a2);
      v36(v75, a2);
      v36(v23, a2);
      v43 = v104;
      v44 = v38;
      if ((v76 & 1) != 0)
        goto LABEL_41;
    }
    else
    {
      v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36(v23, a2);
      v43 = v104;
      v44 = v38;
      if (v42 < v108)
        goto LABEL_41;
    }
    goto LABEL_10;
  }
  v61 = v37(a2, a3);
  v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v62 = v96(a2, a3);
  if ((v61 & 1) != 0)
  {
    if (v62 > 64)
    {
      v65 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v66 = lazy protocol witness table accessor for type Int64 and conformance Int64(v62, v63, v64);
      v67 = v101;
      v65(&v108, &type metadata for Int64, v66, a2, a3);
      v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v67, a2);
      v36(v67, a2);
      v36(v23, a2);
      v43 = v104;
      v44 = v96;
      if ((v68 & 1) != 0)
        goto LABEL_41;
      goto LABEL_10;
    }
    v86 = v98;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v98, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v88 = v97;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v89 = v101;
    (*((void (**)(char *, uint64_t, const char *))v86 + 3))(v88, a2, v86);
    v90 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v23, v89, a2);
    v36(v89, a2);
    v91 = v99;
    (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v99, v23, a2);
    v43 = v104;
    if ((v90 & 1) != 0)
    {
      v36(v91, a2);
LABEL_41:
      v36(v29, a2);
      v72 = 0;
      goto LABEL_42;
    }
    v92 = v108;
    v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v91, a2);
    v78 = v93 < v92;
    goto LABEL_39;
  }
  if (v62 < 64)
  {
    v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v36(v23, a2);
    v78 = v77 < v108;
    v43 = v104;
LABEL_39:
    v44 = v96;
    if (v78)
      goto LABEL_41;
LABEL_10:
    v45 = v44(a2, a3);
    goto LABEL_11;
  }
  v36(v23, a2);
  v43 = v104;
  v44 = v96;
  v45 = v96(a2, a3);
LABEL_11:
  v46 = v45;
  v47 = v103;
  v34(v103, v29, a2);
  if (v46 >= 65)
  {
    v36(v47, a2);
    v48 = v102;
    v34(v102, v29, a2);
    v49 = v105;
    goto LABEL_15;
  }
  v50 = v44(a2, a3);
  v36(v47, a2);
  if (v50 != 64)
  {
    v48 = v102;
    v34(v102, v29, a2);
    goto LABEL_25;
  }
  v49 = v105;
  v51 = v105(a2, a3);
  v48 = v102;
  v34(v102, v29, a2);
  if ((v51 & 1) != 0)
  {
LABEL_25:
    v70 = v48;
    goto LABEL_26;
  }
LABEL_15:
  v108 = 0x7FFFFFFFFFFFFFFFLL;
  v52 = v49(a2, a3);
  v53 = v44(a2, a3);
  if ((v52 & 1) != 0)
  {
    if (v53 > 64)
    {
      v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v57 = lazy protocol witness table accessor for type Int64 and conformance Int64(v53, v54, v55);
      v58 = v101;
      v56(&v108, &type metadata for Int64, v57, a2, a3);
      v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v58, v48, a2);
      v36(v58, a2);
      v60 = v48;
      goto LABEL_34;
    }
    goto LABEL_23;
  }
  if (v53 <= 63)
  {
LABEL_23:
    v69 = v101;
    (*(void (**)(char *, char *, uint64_t))(v106 + 32))(v101, v48, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v70 = v69;
LABEL_26:
    v36(v70, a2);
    goto LABEL_27;
  }
  v107 = 0x7FFFFFFFFFFFFFFFLL;
  v79 = v101;
  v80 = (*(uint64_t (**)(char *, char *, uint64_t))(v106 + 32))(v101, v48, a2);
  v81 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v84 = lazy protocol witness table accessor for type Int64 and conformance Int64(v80, v82, v83);
  v85 = v100;
  v81(&v107, &type metadata for Int64, v84, a2, a3);
  v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v85, v79, a2);
  v36(v85, a2);
  v60 = v79;
LABEL_34:
  v36(v60, a2);
  if ((v59 & 1) != 0)
    goto LABEL_41;
LABEL_27:
  v71 = *(void (**)(uint64_t, uint64_t))(a3 + 120);
  v71(a2, a3);
  v36(v29, a2);
  v72 = ((uint64_t (*)(uint64_t, uint64_t))v71)(a2, a3);
LABEL_42:
  v36(v43, a2);
  return v72;
}

uint64_t Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized Int128.init<A>(_:));
}

{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized Int128.init<A>(_:));
}

uint64_t Int128.init<A>(clamping:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  char v12;
  void (*v13)(uint64_t, uint64_t);
  uint64_t v15;

  v6 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  v9 = Int128.init<A>(exactly:)((uint64_t)v8, a2, a3);
  if ((v10 & 1) != 0)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 24) + 8) + 16))(a2);
    v12 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(a1, v8, a2);
    v13 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
    v13(a1, a2);
    v13((uint64_t)v8, a2);
    if ((v12 & 1) != 0)
      return 0;
    else
      return -1;
  }
  else
  {
    v11 = v9;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }
  return v11;
}

uint64_t UInt128.init<A>(truncatingIfNeeded:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = specialized UInt128.init<A>(truncatingIfNeeded:)(a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  return v5;
}

uint64_t *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int128@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  if (a2 >> 8 <= 0x80)
  {
    v3 = *result;
    if (a2 >> 8 > 0x40)
    {
      v4 = result[1];
      *a3 = v3;
      a3[1] = v4;
    }
    else
    {
      *(_OWORD *)a3 = v3;
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

uint64_t Int128.init<A>(exactly:)(char *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  void (*v24)(char *, char *, uint64_t);
  unint64_t AssociatedConformanceWitness;
  void (*v26)(char *, uint64_t, uint64_t);
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t (*v30)(char *, char *, uint64_t, uint64_t);
  void (*v31)(char *, uint64_t);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  const char *v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  char *v52;
  void (*v53)(char *, char *, uint64_t);
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v60;
  char *v61;
  unint64_t AssociatedTypeWitness;
  char *v63;
  const char *v64;
  void (*v65)(char *, char *, uint64_t);
  char *v66;
  uint64_t v67;
  uint64_t v68;
  void (*v69)(char *, uint64_t, uint64_t);
  void (*v70)(unint64_t, double);
  unint64_t v71;
  char *v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  char v77;

  v6 = *(_QWORD *)(a3 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 + 16) + 8);
  v64 = *(const char **)(v7 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v64, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v61 = (char *)&v60 - v8;
  v74 = a3;
  v9 = *(_QWORD *)(a3 + 8);
  v10 = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  v11 = MEMORY[0x1E0C80A78](v10);
  v13 = (char *)&v60 - v12;
  v14 = *(_QWORD *)(a2 - 8);
  v15 = MEMORY[0x1E0C80A78](v11);
  v63 = (char *)&v60 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v15);
  v72 = (char *)&v60 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v60 - v20;
  MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v60 - v22;
  v24 = *(void (**)(char *, char *, uint64_t))(v7 + 56);
  v75 = a1;
  v73 = v7;
  v65 = v24;
  ((void (*)(uint64_t, uint64_t))v24)(a2, v7);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
  v70 = *(void (**)(unint64_t, double))(AssociatedConformanceWitness + 8);
  v71 = AssociatedConformanceWitness;
  v70(v10, 1.84467441e19);
  v26 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 24);
  v66 = v13;
  v67 = v9;
  v27 = v13;
  v28 = v14;
  v69 = v26;
  v26(v27, a2, v9);
  v68 = v6;
  v29 = *(_QWORD *)(*(_QWORD *)(v6 + 24) + 8);
  v30 = *(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v29 + 16);
  LOBYTE(a1) = v30(v23, v21, a2, v29);
  v31 = *(void (**)(char *, uint64_t))(v28 + 8);
  v31(v21, a2);
  v31(v23, a2);
  if ((a1 & 1) == 0)
  {
    v37 = v66;
    ((void (*)(unint64_t, unint64_t, double))v70)(v10, v71, 5.42101086e-20);
    v38 = v67;
    v69(v37, a2, v67);
    v65 = *(void (**)(char *, char *, uint64_t))(v73 + 64);
    v65(v75, v21, a2);
    v31(v21, a2);
    LOBYTE(v76) = 3;
    v39 = v72;
    (*(void (**)(uint64_t *, uint64_t))(v68 + 304))(&v76, a2);
    v31(v23, a2);
    v40 = (*(uint64_t (**)(char *, char *, uint64_t))(v28 + 16))(v23, v39, a2);
    v43 = lazy protocol witness table accessor for type Int64 and conformance Int64(v40, v41, v42);
    FixedWidthInteger.init<A>(exactly:)((uint64_t)v23, (uint64_t)&type metadata for Int64, a2, v43, v74, (uint64_t)&v76);
    if (v77 != 1)
    {
      ((void (*)(unint64_t, unint64_t, double))v70)(v10, v71, 1.84467441e19);
      v50 = v63;
      v69(v37, a2, v38);
      v52 = v72;
      v51 = v73;
      ((void (*)(char *, char *, uint64_t, uint64_t))v65)(v50, v72, a2, v73);
      v31(v50, a2);
      v31(v52, a2);
      v53 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(v51 + 8) + 40);
      v54 = v75;
      v53(v75, v21, a2);
      v31(v54, a2);
      v55 = ((uint64_t (*)(char *, uint64_t))v31)(v21, a2);
      v58 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v55, v56, v57);
      FixedWidthInteger.init<A>(exactly:)((uint64_t)v23, (uint64_t)&type metadata for UInt64, a2, v58, v74, (uint64_t)&v76);
      if (v77 != 1)
        return v76;
      return 0;
    }
    v31(v75, a2);
    v36 = v72;
LABEL_6:
    v31(v36, a2);
    return 0;
  }
  v32 = ((uint64_t (*)(uint64_t, uint64_t))v65)(a2, v73);
  v35 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v32, v33, v34);
  FixedWidthInteger.init<A>(exactly:)((uint64_t)v23, (uint64_t)&type metadata for UInt64, a2, v35, v74, (uint64_t)&v76);
  if (v77 == 1)
  {
    v36 = v75;
    goto LABEL_6;
  }
  v44 = v76;
  v45 = v64;
  v46 = AssociatedTypeWitness;
  v47 = swift_getAssociatedConformanceWitness((uint64_t)v64, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v48 = v61;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8))(&unk_1816B7DA8, 256, v46, v47);
  (*((void (**)(char *, uint64_t, const char *))v45 + 3))(v48, a2, v45);
  v49 = v75;
  LOBYTE(v46) = v30(v75, v23, a2, v29);
  v31(v49, a2);
  v31(v23, a2);
  if ((v46 & 1) != 0)
    return -v44;
  return v44;
}

uint64_t Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  uint64_t v6;

  v6 = a4();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  return v6;
}

BOOL static Int128.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Int128(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL static Int128.< infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return (__int128)__PAIR128__(a2, a1) < (__int128)__PAIR128__(a4, a3);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  return *a2 < *a1;
}

void Int128.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(a3);
}

Swift::Int Int128.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance Int128()
{
  Swift::UInt64 *v0;

  return Int128.hashValue.getter(*v0, v0[1]);
}

uint64_t Int128.addingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t Int128.subtractingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 - a1;
}

uint64_t Int128.multipliedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = (a1 ^ (a2 >> 63)) - (a2 >> 63);
  if ((a4 ^ a2) >= 0)
    return ((a3 ^ (a4 >> 63)) - (a4 >> 63)) * v4;
  else
    return -(((a3 ^ (a4 >> 63)) - (a4 >> 63)) * v4);
}

uint64_t Int128.magnitude.getter(uint64_t a1, uint64_t a2)
{
  return (a1 ^ (a2 >> 63)) - (a2 >> 63);
}

uint64_t UInt128.multipliedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 * a1;
}

uint64_t UInt128.init(_builtinIntegerLiteral:)(uint64_t a1, unint64_t a2)
{
  if (a2 >> 9 <= 0x40 && (a2 & 1) == 0)
    return *(_QWORD *)a1;
  else
    return 0;
}

uint64_t Int128.dividedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a1 | a2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL && (a3 | a4 ^ 0x8000000000000000) == 0)
    return 0;
  else
    return __divti3();
}

uint64_t Int128.remainderReportingOverflow(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a1 | a2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  if ((a1 & a2) == 0xFFFFFFFFFFFFFFFFLL && (a3 | a4 ^ 0x8000000000000000) == 0)
    return 0;
  else
    return __modti3();
}

unint64_t static Int128.+ infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4;
  unint64_t result;
  unsigned __int128 v6;
  char v7;

  v4 = __OFADD__(__CFADD__(a1, a3), a2);
  v6 = __PAIR128__(a2, a1) + a3;
  result = a1 + a3;
  if (v4 | __OFADD__(a4, *((_QWORD *)&v6 + 1)))
    v7 = 1;
  else
    v7 = 0;
  if ((v7 & 1) != 0)
    __break(1u);
  return result;
}

unint64_t static Int128.- infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _BOOL1 v4;
  unint64_t result;

  v4 = a1 >= a3;
  result = a1 - a3;
  if (__OFSUB__(a2, a4, v4))
    __break(1u);
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  __int128 v3;
  char v4;

  v3 = *(_OWORD *)result + *(_OWORD *)a2;
  if (__OFADD__(__CFADD__(*result, *a2), result[1]) | __OFADD__(a2[1], *((_QWORD *)&v3 + 1)))
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int128(_QWORD *result, unint64_t *a2)
{
  unint64_t v2;
  __int128 v3;
  char v4;
  unint64_t v5;
  char v6;

  v2 = a2[1];
  v3 = *(_OWORD *)result + *a2;
  v4 = __OFADD__(__CFADD__(*result, *a2), result[1]) | __OFADD__(v2, *((_QWORD *)&v3 + 1));
  v5 = v2 + *((_QWORD *)&v3 + 1);
  if (v4)
    v6 = 1;
  else
    v6 = 0;
  if ((v6 & 1) != 0)
  {
    __break(1u);
  }
  else
  {
    *result = v3;
    result[1] = v5;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2))
    __break(1u);
  else
    *a3 = *result - *a2;
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int128(_OWORD *result, _OWORD *a2)
{
  if (__OFSUB__(*result, *a2))
    __break(1u);
  else
    *result -= *a2;
  return result;
}

uint64_t static Int128.* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int128 v4;
  unsigned __int128 v5;
  BOOL v6;
  char v9;
  char v10;
  uint64_t result;
  char v12;
  char v13;

  v4 = __PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
     - __PAIR128__(a2 >> 63, a2 >> 63);
  v5 = __PAIR128__(a4 ^ (unint64_t)(a4 >> 63), a3 ^ (unint64_t)(a4 >> 63))
     - __PAIR128__(a4 >> 63, a4 >> 63);
  if ((__PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
      - __PAIR128__(a2 >> 63, a2 >> 63)) >> 64)
    v6 = *((_QWORD *)&v5 + 1) == 0;
  else
    v6 = 1;
  v9 = !v6
    || (((__PAIR128__(a2 ^ (unint64_t)(a2 >> 63), a1 ^ (unint64_t)(a2 >> 63))
        - __PAIR128__(a2 >> 63, a2 >> 63)) >> 64)
      * ((a3 ^ (unint64_t)(a4 >> 63)) - (a4 >> 63))) >> 64 != 0
    || (((__PAIR128__(a4 ^ (unint64_t)(a4 >> 63), a3 ^ (unint64_t)(a4 >> 63))
        - __PAIR128__(a4 >> 63, a4 >> 63)) >> 64)
      * ((a1 ^ (unint64_t)(a2 >> 63)) - (a2 >> 63))) >> 64 != 0;
  if (__CFADD__(((unint64_t)v4 * (unsigned __int128)(unint64_t)v5) >> 64, *((_QWORD *)&v5 + 1) * v4 + *((_QWORD *)&v4 + 1) * v5))
  {
    v10 = 1;
  }
  else
  {
    v10 = v9;
  }
  result = v4 * v5;
  if (((a4 ^ a2) & 0x8000000000000000) == 0)
  {
    if ((((v5 * v4) >> 64) & 0x8000000000000000) != 0)
      v12 = 1;
    else
      v12 = v10;
    if ((v12 & 1) == 0)
      return result;
LABEL_26:
    __break(1u);
    return result;
  }
  result = -result;
  if (result)
    v13 = 1;
  else
    v13 = v10;
  if ((v13 & 1) != 0)
    goto LABEL_26;
  return result;
}

uint64_t static Int128.*= infix(_:_:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned __int128 v3;
  unsigned __int128 v4;
  BOOL v5;
  char v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;

  v3 = abs128(*(_OWORD *)result);
  v4 = __PAIR128__(a3 ^ (unint64_t)(a3 >> 63), a2 ^ (unint64_t)(a3 >> 63))
     - __PAIR128__(a3 >> 63, a3 >> 63);
  if (*((_QWORD *)&v3 + 1))
    v5 = *((_QWORD *)&v4 + 1) == 0;
  else
    v5 = 1;
  v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)((a2 ^ (unint64_t)(a3 >> 63)) - (a3 >> 63))) >> 64 != 0
    || (((__PAIR128__(a3 ^ (unint64_t)(a3 >> 63), a2 ^ (unint64_t)(a3 >> 63))
        - __PAIR128__(a3 >> 63, a3 >> 63)) >> 64)
      * (unint64_t)v3) >> 64 != 0;
  v9 = (v4 * v3) >> 64;
  if (__CFADD__(((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64, *((_QWORD *)&v4 + 1) * v3 + *((_QWORD *)&v3 + 1) * v4))
  {
    v8 = 1;
  }
  v10 = v3 * v4;
  if (((*(_QWORD *)(result + 8) ^ a3) & 0x8000000000000000) == 0)
  {
    if ((v8 & 1) != 0)
    {
      __break(1u);
      goto LABEL_24;
    }
    if ((v9 & 0x8000000000000000) == 0)
    {
LABEL_22:
      *(_QWORD *)result = v10;
      *(_QWORD *)(result + 8) = v9;
      return result;
    }
    __break(1u);
  }
  if ((v8 & 1) != 0)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  v11 = v10 == 0;
  v10 = -v10;
  v9 = -(v9 + !v11);
  if (!v10)
    goto LABEL_22;
LABEL_25:
  __break(1u);
  return result;
}

uint64_t static Int128./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  if (a1 | a2 ^ 0x8000000000000000 || (a3 & a4) != 0xFFFFFFFFFFFFFFFFLL)
    return __divti3();
  else
    return 0;
}

uint64_t static Int128./= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  unint64_t v10;

  if (!(a2 | a3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  v6 = *a1;
  v7 = a1[1];
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || v6 | v7 ^ 0x8000000000000000)
  {
    result = __divti3();
  }
  else
  {
    result = 0;
    v10 = 0x8000000000000000;
  }
  *a1 = result;
  a1[1] = v10;
  return result;
}

uint64_t static Int128.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  if (a1 | a2 ^ 0x8000000000000000 || (a3 & a4) != 0xFFFFFFFFFFFFFFFFLL)
    return __modti3();
  else
    return 0;
}

uint64_t static Int128.%= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v10;

  if (!(a2 | a3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  v6 = *a1;
  v7 = a1[1];
  if ((a2 & a3) != 0xFFFFFFFFFFFFFFFFLL || v6 | v7 ^ 0x8000000000000000)
  {
    result = __modti3();
  }
  else
  {
    result = 0;
    v10 = 0;
  }
  *a1 = result;
  a1[1] = v10;
  return result;
}

uint64_t protocol witness for static SignedNumeric.- prefix(_:) in conformance Int128@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  v2 = -*(_OWORD *)result >> 64;
  if (__OFSUB__(0, *(_QWORD *)(result + 8), *(_QWORD *)result == 0))
  {
    __break(1u);
  }
  else
  {
    *a2 = -*(_QWORD *)result;
    a2[1] = v2;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int128()
{
  uint64_t v0;
  uint64_t v1;

  v1 = -*(_OWORD *)v0 >> 64;
  if (__OFSUB__(0, *(_QWORD *)(v0 + 8), *(_QWORD *)v0 == 0))
  {
    __break(1u);
  }
  else
  {
    *(_QWORD *)v0 = -*(_QWORD *)v0;
    *(_QWORD *)(v0 + 8) = v1;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))Int128.init<A>(exactly:), a1);
}

void protocol witness for Numeric.magnitude.getter in conformance Int128(_OWORD *a1@<X8>)
{
  __int128 *v1;

  *a1 = abs128(*v1);
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance Int128@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unsigned __int128 v3;
  unsigned __int128 v4;
  BOOL v5;
  char v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  BOOL v12;

  v3 = abs128(*(_OWORD *)result);
  v4 = abs128(*(_OWORD *)a2);
  if (*((_QWORD *)&v3 + 1))
    v5 = *((_QWORD *)&v4 + 1) == 0;
  else
    v5 = 1;
  v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v4) >> 64 != 0
    || (*((unint64_t *)&v4 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0;
  v9 = (v4 * v3) >> 64;
  if (__CFADD__(((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64, *((_QWORD *)&v4 + 1) * v3 + *((_QWORD *)&v3 + 1) * v4))
  {
    v10 = 1;
  }
  else
  {
    v10 = v8;
  }
  v11 = v3 * v4;
  if (((*(_QWORD *)(a2 + 8) ^ *(_QWORD *)(result + 8)) & 0x8000000000000000) != 0)
  {
    v12 = v11 == 0;
    v11 = -v11;
    v9 = -(v9 + !v12);
    if (v11)
      v10 = 1;
    if ((v10 & 1) == 0)
      goto LABEL_20;
  }
  else
  {
    if (v9 < 0)
      v10 = 1;
    if ((v10 & 1) == 0)
    {
LABEL_20:
      *a3 = v11;
      a3[1] = v9;
      return result;
    }
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance Int128(uint64_t result, uint64_t a2)
{
  unsigned __int128 v2;
  unsigned __int128 v3;
  BOOL v4;
  char v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  BOOL v11;

  v2 = abs128(*(_OWORD *)result);
  v3 = abs128(*(_OWORD *)a2);
  if (*((_QWORD *)&v2 + 1))
    v4 = *((_QWORD *)&v3 + 1) == 0;
  else
    v4 = 1;
  v7 = !v4
    || (*((unint64_t *)&v2 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v2) >> 64 != 0;
  v8 = (v3 * v2) >> 64;
  if (__CFADD__(((unint64_t)v2 * (unsigned __int128)(unint64_t)v3) >> 64, *((_QWORD *)&v3 + 1) * v2 + *((_QWORD *)&v2 + 1) * v3))
  {
    v9 = 1;
  }
  else
  {
    v9 = v7;
  }
  v10 = v2 * v3;
  if (((*(_QWORD *)(result + 8) ^ *(_QWORD *)(a2 + 8)) & 0x8000000000000000) == 0)
  {
    if ((v9 & 1) != 0)
    {
      __break(1u);
      goto LABEL_24;
    }
    if ((v8 & 0x8000000000000000) == 0)
    {
LABEL_22:
      *(_QWORD *)result = v10;
      *(_QWORD *)(result + 8) = v8;
      return result;
    }
    __break(1u);
  }
  if ((v9 & 1) != 0)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }
  v11 = v10 == 0;
  v10 = -v10;
  v8 = -(v8 + !v11);
  if (!v10)
    goto LABEL_22;
LABEL_25:
  __break(1u);
  return result;
}

_QWORD *static Int128.&= infix(_:_:)(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = result[1] & a3;
  *result &= a2;
  result[1] = v3;
  return result;
}

_QWORD *static Int128.|= infix(_:_:)(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = result[1] | a3;
  *result |= a2;
  result[1] = v3;
  return result;
}

_QWORD *static Int128.^= infix(_:_:)(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = result[1] ^ a3;
  *result ^= a2;
  result[1] = v3;
  return result;
}

uint64_t *static Int128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[1];
  v3 = ((2 * v2) << ~a2) | ((unint64_t)*result >> a2);
  v4 = v2 >> a2;
  if ((a2 & 0x40) != 0)
    v3 = v2 >> a2;
  v5 = v2 >> 63;
  if ((a2 & 0x40) == 0)
    v5 = v4;
  *result = v3;
  result[1] = v5;
  return result;
}

_QWORD *static Int128.&<<= infix(_:_:)(_QWORD *result, char a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = (result[1] << a2) | (*result >> 1 >> ~a2);
  v3 = *result << a2;
  if ((a2 & 0x40) != 0)
  {
    v2 = *result << a2;
    v3 = 0;
  }
  *result = v3;
  result[1] = v2;
  return result;
}

unint64_t Int128.trailingZeroBitCount.getter(unint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = __clz(__rbit64(a1));
  v3 = __clz(__rbit64(a2)) + 64;
  if (a1)
    return v2;
  else
    return v3;
}

unint64_t Int64.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

unint64_t UInt64.trailingZeroBitCount.getter(unint64_t a1)
{
  return __clz(__rbit64(a1));
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))Int128.init<A>(exactly:), a1);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized Int128.init<A>(_:), a3);
}

{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized Int128.init<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(void)@<X5>, uint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v7 = a3();
  v9 = v8;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v7 = specialized UInt128.init<A>(truncatingIfNeeded:)(a1, a2, a3);
  v9 = v8;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result;
  uint64_t v6;

  result = Int128.init<A>(clamping:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  return result;
}

void protocol witness for BinaryInteger.words.getter in conformance Int128(_QWORD *a1@<X8>)
{
  _QWORD *v1;
  uint64_t v2;

  v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
}

uint64_t protocol witness for BinaryInteger.bitWidth.getter in conformance Int128()
{
  return 128;
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int128()
{
  unint64_t *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int128()
{
  unint64_t *v0;
  unint64_t v1;
  unint64_t v2;

  v1 = __clz(__rbit64(*v0));
  v2 = __clz(__rbit64(v0[1])) + 64;
  if (*v0)
    return v1;
  else
    return v2;
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int128@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL v4;
  uint64_t result;
  unint64_t v6;

  if (*(_OWORD *)a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  if (*a1 | a1[1] ^ 0x8000000000000000)
    v4 = 0;
  else
    v4 = (*(_QWORD *)a2 & *(_QWORD *)(a2 + 8)) == -1;
  if (v4)
  {
    result = 0;
    v6 = 0x8000000000000000;
  }
  else
  {
    result = __divti3();
  }
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;

  if (*(_OWORD *)a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  if ((*(_QWORD *)a2 & *(_QWORD *)(a2 + 8)) == -1 && (*a1 | a1[1] ^ 0x8000000000000000) == 0)
  {
    result = 0;
    v5 = 0x8000000000000000;
  }
  else
  {
    result = __divti3();
  }
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int128@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL v4;
  uint64_t result;
  uint64_t v6;

  if (*(_OWORD *)a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  if (*a1 | a1[1] ^ 0x8000000000000000)
    v4 = 0;
  else
    v4 = (*(_QWORD *)a2 & *(_QWORD *)(a2 + 8)) == -1;
  if (v4)
  {
    result = 0;
    v6 = 0;
  }
  else
  {
    result = __modti3();
  }
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  if (*(_OWORD *)a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  if ((*(_QWORD *)a2 & *(_QWORD *)(a2 + 8)) == -1 && (*a1 | a1[1] ^ 0x8000000000000000) == 0)
  {
    result = 0;
    v5 = 0;
  }
  else
  {
    result = __modti3();
  }
  *a1 = result;
  a1[1] = v5;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  v2 = ~result[1];
  *a2 = ~*result;
  a2[1] = v2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  v3 = a2[1] & result[1];
  *a3 = *a2 & *result;
  a3[1] = v3;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int128(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;

  v2 = result[1] & a2[1];
  *result &= *a2;
  result[1] = v2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  v3 = a2[1] | result[1];
  *a3 = *a2 | *result;
  a3[1] = v3;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int128(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;

  v2 = result[1] | a2[1];
  *result |= *a2;
  result[1] = v2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  v3 = a2[1] ^ result[1];
  *a3 = *a2 ^ *result;
  a3[1] = v3;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int128(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;

  v2 = result[1] ^ a2[1];
  *result ^= *a2;
  result[1] = v2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int128@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t result;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v42;
  char v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  char v46;
  uint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  char v61;
  uint64_t (*v62)(char *, uint64_t);
  uint64_t v63;
  void (*v64)(char *, uint64_t, uint64_t);
  char *v65;
  char v66;
  uint64_t v67;
  char *v68;
  uint64_t (*v69)(uint64_t, uint64_t);
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void (*v79)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v80;
  char v81;
  void (*v82)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v83;
  char v84;
  uint64_t v85;
  void (**v86)(char *, uint64_t, const char *);
  unint64_t v87;
  unint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  int64_t v92;
  uint64_t v93;
  char *v94;
  uint64_t (*v95)(uint64_t, uint64_t);
  uint64_t v96;
  char *v97;
  unint64_t v98;
  char v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  void (*v103)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v104;
  int64_t *v105;
  uint64_t v106;
  char *v107;
  char v108;
  char *v109;
  unint64_t v110;
  BOOL v111;
  uint64_t v112;
  uint64_t *v113;
  uint64_t v114;
  uint64_t v115;
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  char *v122;
  unint64_t v123;
  uint64_t *v124;
  char *v125;
  uint64_t (*v126)(uint64_t, uint64_t);
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v124 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v122 = (char *)&v114 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v121 = (char *)&v114 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v117 = (char *)&v114 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v114 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v125 = (char *)&v114 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v114 - v28;
  v30 = *a1;
  v31 = a1[1];
  v127 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v127(a3, a4) & 1) == 0)
  {
    v123 = v30;
    v115 = v31;
    v37 = v127(a3, a4);
    v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v38 = v126(a3, a4);
    if ((v37 & 1) != 0)
    {
      if (v38 > 64)
      {
        v129 = -128;
        v41 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v42 = lazy protocol witness table accessor for type Int and conformance Int(v38, v39, v40);
        v41(&v129, &type metadata for Int, v42, a3, a4);
        v43 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v31 = v115;
        v30 = v123;
        if ((v43 & 1) != 0)
          goto LABEL_18;
        goto LABEL_19;
      }
      v48 = AssociatedTypeWitness;
      v49 = v120;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v118;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_18;
      }
      v47 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
    }
    else
    {
      if (v38 >= 64)
      {
        v31 = v115;
        v30 = v123;
        goto LABEL_19;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v47 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    }
    v31 = v115;
    v30 = v123;
    if (v47 < -128)
      goto LABEL_18;
    goto LABEL_19;
  }
  v126 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v32 = v126(a3, a4);
  if (v32 >= 64)
  {
    v129 = -128;
    v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v45 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
    v44(&v129, &type metadata for Int, v45, a3, a4);
    v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if ((v46 & 1) != 0)
      goto LABEL_18;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v35 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v35 < -128)
      goto LABEL_18;
  }
LABEL_19:
  v55 = v127(a3, a4);
  v56 = v126(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64)
      goto LABEL_21;
LABEL_24:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v62(v29, a3);
    if (v63 > 128)
      goto LABEL_25;
    goto LABEL_26;
  }
  if (v56 <= 63)
    goto LABEL_24;
LABEL_21:
  v129 = 128;
  v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v129, &type metadata for Int, v60, a3, a4);
  v61 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
  v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v62(v29, a3);
  if ((v61 & 1) != 0)
    goto LABEL_25;
LABEL_26:
  v123 = v30;
  v64 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v65 = v125;
  v64(v125, a2, a3);
  v66 = v127(a3, a4);
  v64(v25, (uint64_t)v65, a3);
  if ((v66 & 1) != 0)
  {
    v67 = v126(a3, a4);
    v62(v25, a3);
    if (v67 <= 64)
      goto LABEL_47;
    v68 = v117;
    v64(v117, (uint64_t)v125, a3);
    v129 = 0x8000000000000000;
    v69 = v127;
    if ((v127(a3, a4) & 1) != 0)
    {
      v70 = v126(a3, a4);
      if (v70 < 64)
      {
        v73 = v29;
        goto LABEL_41;
      }
      v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v83 = lazy protocol witness table accessor for type Int and conformance Int(v70, v71, v72);
      v82(&v129, &type metadata for Int, v83, a3, a4);
      v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, v29, a3);
      goto LABEL_36;
    }
    v75 = v69(a3, a4);
    v76 = v126(a3, a4);
    if ((v75 & 1) != 0)
    {
      if (v76 <= 64)
      {
        v87 = AssociatedTypeWitness;
        v86 = (void (**)(char *, uint64_t, const char *))v120;
        v88 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v89 = v118;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v88 + 8))(&unk_1816B7DA8, 256, v87, v88);
        v86[3](v89, a3, (const char *)v86);
        v90 = v117;
        LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v29, a3);
        v62(v29, a3);
        v91 = v116;
        v64(v116, (uint64_t)v90, a3);
        if ((v86 & 1) != 0)
        {
          v62(v91, a3);
          goto LABEL_70;
        }
        v92 = v129;
        v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v62(v91, a3);
        v68 = v117;
        if (v93 < v92)
          goto LABEL_70;
LABEL_45:
        v74 = v68;
        goto LABEL_46;
      }
      v79 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v80 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
      v79(&v129, &type metadata for Int, v80, a3, a4);
      v68 = v117;
      v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v29, a3);
LABEL_36:
      v84 = v81;
      v62(v29, a3);
      if ((v84 & 1) != 0)
        goto LABEL_70;
      goto LABEL_45;
    }
    if (v76 < 64)
    {
      v73 = v29;
      v68 = v117;
LABEL_41:
      v64(v73, (uint64_t)v68, a3);
      v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      if (v85 < v129)
LABEL_70:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_45;
    }
    v74 = v117;
  }
  else
  {
    v74 = v25;
  }
LABEL_46:
  v62(v74, a3);
LABEL_47:
  v94 = v125;
  v95 = v126;
  v96 = v126(a3, a4);
  v97 = v121;
  v64(v121, (uint64_t)v94, a3);
  if (v96 >= 65)
  {
    v62(v97, a3);
    v98 = v123;
    goto LABEL_49;
  }
  v106 = v95(a3, a4);
  v62(v97, a3);
  v98 = v123;
  if (v106 == 64 && (v127(a3, a4) & 1) == 0)
  {
LABEL_49:
    v64(v122, (uint64_t)v125, a3);
    v129 = 0x7FFFFFFFFFFFFFFFLL;
    v99 = v127(a3, a4);
    v100 = v126(a3, a4);
    if ((v99 & 1) != 0)
    {
      if (v100 > 64)
      {
        v103 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v104 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
        v105 = &v129;
        goto LABEL_58;
      }
    }
    else if (v100 > 63)
    {
      v128 = 0x7FFFFFFFFFFFFFFFLL;
      v103 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v104 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
      v105 = &v128;
LABEL_58:
      v103(v105, &type metadata for Int, v104, a3, a4);
      v107 = v122;
      v108 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v122, a3);
      v62(v29, a3);
      if ((v108 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_59;
    }
    v107 = v122;
    v64(v29, (uint64_t)v122, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
LABEL_59:
    v62(v107, a3);
  }
  v109 = v125;
  v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v62(v109, a3);
  if ((v110 & 0x8000000000000000) == 0)
  {
    if (v110 < 0x80)
    {
      v53 = ((2 * v31) << ~(_BYTE)v110) | (v98 >> v110);
      v54 = v31 >> v110;
      v111 = (v110 & 0x40) == 0;
      if ((v110 & 0x40) != 0)
        v53 = v31 >> v110;
      v112 = v31 >> 63;
      goto LABEL_65;
    }
LABEL_25:
    v53 = v31 >> 63;
    v54 = v31 >> 63;
    goto LABEL_67;
  }
  if (v110 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_18:
    v53 = 0;
    v54 = 0;
    goto LABEL_67;
  }
  v112 = v98 << -(char)v110;
  v111 = (-(uint64_t)v110 & 0x40) == 0;
  if ((-(uint64_t)v110 & 0x40) != 0)
    v53 = 0;
  else
    v53 = v98 << -(char)v110;
  v54 = (v31 << -(char)v110) | (v98 >> 1 >> (v110 - 1));
LABEL_65:
  if (!v111)
    v54 = v112;
LABEL_67:
  v113 = v124;
  *v124 = v53;
  v113[1] = v54;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t result;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v40;
  char v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  char v44;
  uint64_t v45;
  unint64_t v46;
  const char *v47;
  unint64_t AssociatedConformanceWitness;
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void (*v57)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v58;
  char v59;
  uint64_t (*v60)(char *, uint64_t);
  void (*v61)(char *, uint64_t, uint64_t);
  char v62;
  uint64_t v63;
  uint64_t (*v64)(uint64_t, uint64_t);
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void (*v75)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v76;
  char v77;
  void (*v78)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v79;
  char v80;
  uint64_t v81;
  void (**v82)(char *, uint64_t, const char *);
  unint64_t v83;
  unint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  int64_t v88;
  uint64_t v89;
  BOOL v90;
  uint64_t (*v91)(uint64_t, uint64_t);
  uint64_t v92;
  char *v93;
  char v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  void (*v98)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v99;
  int64_t *v100;
  uint64_t v101;
  char v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t *v106;
  char *v107;
  uint64_t v108;
  char *v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  unint64_t AssociatedTypeWitness;
  char *v115;
  char *v116;
  uint64_t (*v117)(uint64_t, uint64_t);
  uint64_t *v118;
  uint64_t (*v119)(uint64_t, uint64_t);
  uint64_t v120;
  int64_t v121;

  v118 = a1;
  v115 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v115, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v113 = (char *)&v108 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v108 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v111 = (char *)&v108 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v108 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v108 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v112 = (char *)&v108 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v24 = (char *)&v108 - v23;
  v25 = MEMORY[0x1E0C80A78](v22);
  v27 = (char *)&v108 - v26;
  MEMORY[0x1E0C80A78](v25);
  v29 = (char *)&v108 - v28;
  v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v119(a3, a4) & 1) == 0)
  {
    v109 = v17;
    v110 = v27;
    v35 = v119(a3, a4);
    v117 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v36 = v117(a3, a4);
    if ((v35 & 1) != 0)
    {
      if (v36 > 64)
      {
        v121 = -128;
        v39 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
        v39(&v121, &type metadata for Int, v40, a3, a4);
        v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
        v17 = v109;
        v27 = v110;
        if ((v41 & 1) != 0)
          goto LABEL_18;
        goto LABEL_19;
      }
      v46 = AssociatedTypeWitness;
      v47 = v115;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v49 = v113;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v46, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_18;
      }
      v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
    }
    else
    {
      if (v36 >= 64)
      {
        v17 = v109;
        v27 = v110;
        goto LABEL_19;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
      v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    }
    v17 = v109;
    v27 = v110;
    if (v45 < -128)
      goto LABEL_18;
    goto LABEL_19;
  }
  v117 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v30 = v117(a3, a4);
  if (v30 >= 64)
  {
    v121 = -128;
    v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v43 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v42(&v121, &type metadata for Int, v43, a3, a4);
    v44 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    if ((v44 & 1) != 0)
      goto LABEL_18;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
    v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    if (v33 < -128)
      goto LABEL_18;
  }
LABEL_19:
  v53 = v119(a3, a4);
  v54 = v117(a3, a4);
  if ((v53 & 1) != 0)
  {
    if (v54 > 64)
      goto LABEL_21;
  }
  else if (v54 >= 64)
  {
LABEL_21:
    v121 = 128;
    v57 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v58 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v57(&v121, &type metadata for Int, v58, a3, a4);
    v59 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v60 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    result = v60(v29, a3);
    if ((v59 & 1) == 0)
      goto LABEL_22;
LABEL_29:
    v70 = v118[1];
    goto LABEL_30;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
  v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v60 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  result = v60(v29, a3);
  if (v69 > 128)
    goto LABEL_29;
LABEL_22:
  v61 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v61(v27, a2, a3);
  v62 = v119(a3, a4);
  v61(v24, (uint64_t)v27, a3);
  if ((v62 & 1) == 0)
    goto LABEL_44;
  v63 = v117(a3, a4);
  v60(v24, a3);
  if (v63 <= 64)
    goto LABEL_46;
  v24 = v112;
  v61(v112, (uint64_t)v27, a3);
  v121 = 0x8000000000000000;
  v64 = v119;
  if ((v119(a3, a4) & 1) != 0)
  {
    v65 = v117(a3, a4);
    if (v65 < 64)
    {
      v68 = v29;
      goto LABEL_40;
    }
    v78 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v79 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
    v78(&v121, &type metadata for Int, v79, a3, a4);
    v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v24, v29, a3);
    goto LABEL_35;
  }
  v71 = v64(a3, a4);
  v72 = v117(a3, a4);
  if ((v71 & 1) != 0)
  {
    if (v72 > 64)
    {
      v75 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v76 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
      v75(&v121, &type metadata for Int, v76, a3, a4);
      v24 = v112;
      v77 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
LABEL_35:
      v80 = v77;
      v60(v29, a3);
      if ((v80 & 1) != 0)
        goto LABEL_68;
      goto LABEL_44;
    }
    v83 = AssociatedTypeWitness;
    v82 = (void (**)(char *, uint64_t, const char *))v115;
    v84 = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v85 = v113;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v84 + 8))(&unk_1816B7DA8, 256, v83, v84);
    v82[3](v85, a3, (const char *)v82);
    v86 = v112;
    LOBYTE(v82) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
    v60(v29, a3);
    v87 = v111;
    v61(v111, (uint64_t)v86, a3);
    if ((v82 & 1) != 0)
    {
      v60(v87, a3);
      goto LABEL_68;
    }
    v88 = v121;
    v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v60(v87, a3);
    v90 = v89 < v88;
    v24 = v112;
    if (v90)
      goto LABEL_68;
LABEL_44:
    v107 = v24;
    goto LABEL_45;
  }
  if (v72 < 64)
  {
    v68 = v29;
    v24 = v112;
LABEL_40:
    v61(v68, (uint64_t)v24, a3);
    v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v60(v29, a3);
    if (v81 < v121)
LABEL_68:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_44;
  }
  v107 = v112;
LABEL_45:
  v60(v107, a3);
LABEL_46:
  v91 = v117;
  v92 = v117(a3, a4);
  v93 = v116;
  v61(v116, (uint64_t)v27, a3);
  if (v92 >= 65)
  {
    v60(v93, a3);
    goto LABEL_48;
  }
  v101 = v91(a3, a4);
  v60(v93, a3);
  if (v101 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_48:
    v61(v17, (uint64_t)v27, a3);
    v121 = 0x7FFFFFFFFFFFFFFFLL;
    v94 = v119(a3, a4);
    v95 = v117(a3, a4);
    if ((v94 & 1) != 0)
    {
      if (v95 > 64)
      {
        v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v99 = lazy protocol witness table accessor for type Int and conformance Int(v95, v96, v97);
        v100 = &v121;
        goto LABEL_57;
      }
    }
    else if (v95 >= 64)
    {
      v120 = 0x7FFFFFFFFFFFFFFFLL;
      v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v99 = lazy protocol witness table accessor for type Int and conformance Int(v95, v96, v97);
      v100 = &v120;
LABEL_57:
      v98(v100, &type metadata for Int, v99, a3, a4);
      v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v17, a3);
      v60(v29, a3);
      if ((v102 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_58;
    }
    v61(v29, (uint64_t)v17, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v60(v29, a3);
LABEL_58:
    v60(v17, a3);
  }
  v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v60(v27, a3);
  v104 = *v118;
  v70 = v118[1];
  if ((v103 & 0x8000000000000000) == 0)
  {
    if (v103 < 0x80)
    {
      v51 = ((2 * v70) << ~(_BYTE)v103) | (v104 >> v103);
      v105 = v70 >> v103;
      if ((v103 & 0x40) != 0)
        v51 = v70 >> v103;
      v52 = v70 >> 63;
      if ((v103 & 0x40) == 0)
        v52 = v105;
      goto LABEL_65;
    }
LABEL_30:
    v51 = v70 >> 63;
    v52 = v70 >> 63;
    goto LABEL_65;
  }
  if (v103 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_18:
    v51 = 0;
    v52 = 0;
    goto LABEL_65;
  }
  if ((-(uint64_t)v103 & 0x40) != 0)
    v51 = 0;
  else
    v51 = v104 << -(char)v103;
  v52 = (v70 << -(char)v103) | (v104 >> 1 >> (v103 - 1));
  if ((-(uint64_t)v103 & 0x40) != 0)
    v52 = v104 << -(char)v103;
LABEL_65:
  v106 = v118;
  *v118 = v51;
  v106[1] = v52;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v62;
  uint64_t (*v63)(char *, uint64_t);
  void (*v64)(char *, uint64_t, uint64_t);
  char *v65;
  char v66;
  void (*v67)(char *, char *, uint64_t);
  uint64_t v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t (*v72)(uint64_t, uint64_t);
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t (*v79)(uint64_t, uint64_t);
  uint64_t v80;
  char *v81;
  char v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  int64_t *v88;
  uint64_t v89;
  char v90;
  unint64_t v91;
  char v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void (*v96)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v97;
  char v98;
  void (*v99)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v100;
  char v101;
  char *v102;
  uint64_t v103;
  void (**v104)(char *, uint64_t, const char *);
  unint64_t v105;
  unint64_t v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  char *v114;
  char *v115;
  unint64_t AssociatedTypeWitness;
  char *v117;
  char *v118;
  unint64_t v119;
  char *v120;
  char *v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t (*v124)(uint64_t, uint64_t);
  uint64_t (*v125)(uint64_t, uint64_t);
  uint64_t v126;
  int64_t v127;

  v123 = a5;
  v117 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v117, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v115 = (char *)&v112 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v112 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v113 = (char *)&v112 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v118 = (char *)&v112 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v120 = (char *)&v112 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v114 = (char *)&v112 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v112 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v121 = (char *)&v112 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v112 - v28;
  v122 = a1[1];
  v119 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v124 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v125(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v127 = -128;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v127, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v124;
        v32 = v125;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v117;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v117, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v115;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -128;
    }
    else
    {
      if (v39 >= 64)
      {
        v30 = v124;
        v32 = v125;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -128;
    }
    v30 = v124;
    v32 = v125;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    v127 = -128;
    v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v44(&v127, &type metadata for Int, v45, a3, a4);
    LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if ((v44 & 1) != 0)
      goto LABEL_19;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 < -128)
      goto LABEL_19;
  }
LABEL_20:
  v125 = v32;
  v57 = v30(a3, a4);
  v58 = v32(a3, a4);
  if ((v57 & 1) != 0)
  {
    if (v58 > 64)
      goto LABEL_22;
  }
  else if (v58 > 63)
  {
LABEL_22:
    v127 = 128;
    v61 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v62 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
    v61(&v127, &type metadata for Int, v62, a3, a4);
    LOBYTE(v61) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v63(v29, a3);
    if ((v61 & 1) == 0)
      goto LABEL_23;
LABEL_31:
    v55 = 0;
    v56 = 0;
    v54 = v123;
    goto LABEL_51;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v63(v29, a3);
  if (v78 > 128)
    goto LABEL_31;
LABEL_23:
  v64 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v65 = v121;
  v64(v121, a2, a3);
  v66 = v124(a3, a4);
  v67 = (void (*)(char *, char *, uint64_t))v64;
  v64(v25, (uint64_t)v65, a3);
  if ((v66 & 1) == 0)
  {
    v77 = v25;
    v69 = v120;
    v70 = v121;
    goto LABEL_33;
  }
  v68 = v125(a3, a4);
  v63(v25, a3);
  v69 = v120;
  v70 = v121;
  if (v68 < 65)
    goto LABEL_34;
  v71 = v114;
  v67(v114, v121, a3);
  v127 = 0x8000000000000000;
  v72 = v124;
  if ((v124(a3, a4) & 1) == 0)
  {
    v92 = v72(a3, a4);
    v93 = v125(a3, a4);
    if ((v92 & 1) != 0)
    {
      if (v93 > 64)
      {
        v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
        v96(&v127, &type metadata for Int, v97, a3, a4);
        v71 = v114;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v114, v29, a3);
        goto LABEL_56;
      }
      v105 = AssociatedTypeWitness;
      v104 = (void (**)(char *, uint64_t, const char *))v117;
      v106 = swift_getAssociatedConformanceWitness((uint64_t)v117, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v107 = v115;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v106 + 8))(&unk_1816B7DA8, 256, v105, v106);
      v104[3](v107, a3, (const char *)v104);
      v108 = v114;
      LOBYTE(v104) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v114, v29, a3);
      v63(v29, a3);
      v109 = v113;
      v67(v113, v108, a3);
      if ((v104 & 1) != 0)
      {
        v63(v109, a3);
        goto LABEL_68;
      }
      v110 = v127;
      v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v63(v109, a3);
      v47 = v111 < v110;
      v70 = v121;
      v77 = v114;
      if (!v47)
        goto LABEL_33;
    }
    else
    {
      if (v93 >= 64)
      {
        v77 = v114;
        goto LABEL_33;
      }
      v102 = v114;
      v67(v29, v114, a3);
      v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v63(v29, a3);
      v77 = v102;
      if (v103 >= v127)
        goto LABEL_33;
    }
LABEL_68:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v73 = v125(a3, a4);
  if (v73 < 64)
  {
    v67(v29, v71, a3);
    v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63(v29, a3);
    v77 = v71;
    if (v76 < v127)
      goto LABEL_68;
    goto LABEL_33;
  }
  v99 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v100 = lazy protocol witness table accessor for type Int and conformance Int(v73, v74, v75);
  v99(&v127, &type metadata for Int, v100, a3, a4);
  v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v71, v29, a3);
LABEL_56:
  v101 = v98;
  v63(v29, a3);
  v77 = v71;
  if ((v101 & 1) != 0)
    goto LABEL_68;
LABEL_33:
  v63(v77, a3);
LABEL_34:
  v79 = v125;
  v80 = v125(a3, a4);
  v67(v69, v70, a3);
  if (v80 >= 65)
  {
    v63(v69, a3);
    goto LABEL_36;
  }
  v89 = v79(a3, a4);
  v63(v69, a3);
  if (v89 == 64 && (v124(a3, a4) & 1) == 0)
  {
LABEL_36:
    v81 = v118;
    v67(v118, v70, a3);
    v127 = 0x7FFFFFFFFFFFFFFFLL;
    v82 = v124(a3, a4);
    v83 = v125(a3, a4);
    if ((v82 & 1) != 0)
    {
      if (v83 > 64)
      {
        v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
        v88 = &v127;
        goto LABEL_45;
      }
    }
    else if (v83 > 63)
    {
      v126 = 0x7FFFFFFFFFFFFFFFLL;
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      v88 = &v126;
LABEL_45:
      v86(v88, &type metadata for Int, v87, a3, a4);
      v90 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v81, a3);
      v63(v29, a3);
      if ((v90 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_46;
    }
    v67(v29, v81, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63(v29, a3);
LABEL_46:
    v63(v81, a3);
  }
  v91 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v63(v70, a3);
  if ((v91 & 0x8000000000000000) == 0)
  {
    v54 = v123;
    if (v91 >= 0x80)
    {
      v55 = 0;
      v56 = 0;
    }
    else
    {
      v56 = (v122 << v91) | (v119 >> 1 >> ~(_BYTE)v91);
      v55 = v119 << v91;
      if ((v91 & 0x40) != 0)
      {
        v56 = v119 << v91;
        v55 = 0;
      }
    }
    goto LABEL_51;
  }
  if (v91 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_19:
    v54 = v123;
    v55 = v122 >> 63;
    v56 = v122 >> 63;
    goto LABEL_51;
  }
  v56 = v122 >> 63;
  if ((-(uint64_t)v91 & 0x40) == 0)
    v56 = v122 >> -(char)v91;
  v55 = ((2 * v122) << (v91 - 1)) | (v119 >> -(char)v91);
  if ((-(uint64_t)v91 & 0x40) != 0)
    v55 = v122 >> -(char)v91;
  v54 = v123;
LABEL_51:
  *v54 = v55;
  v54[1] = v56;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t result;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v40;
  char v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  char v44;
  uint64_t v45;
  unint64_t v46;
  const char *v47;
  unint64_t AssociatedConformanceWitness;
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v59;
  char v60;
  uint64_t (*v61)(char *, uint64_t);
  uint64_t v62;
  void (*v63)(char *, uint64_t, uint64_t);
  char v64;
  uint64_t v65;
  char *v66;
  uint64_t (*v67)(uint64_t, uint64_t);
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  char *v72;
  char v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void (*v77)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v78;
  char v79;
  void (*v80)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v81;
  char v82;
  uint64_t v83;
  void (**v84)(char *, uint64_t, const char *);
  unint64_t v85;
  unint64_t v86;
  char *v87;
  char *v88;
  char *v89;
  int64_t v90;
  uint64_t v91;
  BOOL v92;
  uint64_t (*v93)(uint64_t, uint64_t);
  uint64_t v94;
  char *v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  void (*v100)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v101;
  int64_t *v102;
  uint64_t v103;
  char v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t *v107;
  uint64_t v108;
  uint64_t v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  char *v114;
  unint64_t AssociatedTypeWitness;
  char *v116;
  char *v117;
  uint64_t (*v118)(uint64_t, uint64_t);
  uint64_t (*v119)(uint64_t, uint64_t);
  uint64_t *v120;
  uint64_t v121;
  int64_t v122;

  v120 = a1;
  v116 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v116, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v114 = (char *)&v109 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v109 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v112 = (char *)&v109 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v109 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v117 = (char *)&v109 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v113 = (char *)&v109 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v24 = (char *)&v109 - v23;
  v25 = MEMORY[0x1E0C80A78](v22);
  v27 = (char *)&v109 - v26;
  MEMORY[0x1E0C80A78](v25);
  v29 = (char *)&v109 - v28;
  v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v119(a3, a4) & 1) == 0)
  {
    v110 = v17;
    v111 = v27;
    v35 = v119(a3, a4);
    v118 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v36 = v118(a3, a4);
    if ((v35 & 1) != 0)
    {
      if (v36 > 64)
      {
        v122 = -128;
        v39 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
        v39(&v122, &type metadata for Int, v40, a3, a4);
        v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
        v17 = v110;
        v27 = v111;
        if ((v41 & 1) != 0)
          goto LABEL_18;
        goto LABEL_20;
      }
      v46 = AssociatedTypeWitness;
      v47 = v116;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v116, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v49 = v114;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v46, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_18;
      }
      v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
    }
    else
    {
      if (v36 >= 64)
      {
        v17 = v110;
        v27 = v111;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
      v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    }
    v17 = v110;
    v27 = v111;
    if (v45 >= -128)
      goto LABEL_20;
    goto LABEL_18;
  }
  v118 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v30 = v118(a3, a4);
  if (v30 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
    v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
    if (v33 >= -128)
      goto LABEL_20;
LABEL_18:
    v51 = v120[1];
    goto LABEL_19;
  }
  v122 = -128;
  v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v43 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
  v42(&v122, &type metadata for Int, v43, a3, a4);
  v44 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v29, a3);
  if ((v44 & 1) != 0)
    goto LABEL_18;
LABEL_20:
  v54 = v119(a3, a4);
  v55 = v118(a3, a4);
  if ((v54 & 1) != 0)
  {
    if (v55 > 64)
      goto LABEL_22;
LABEL_25:
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v29, a2, a3);
    v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    result = v61(v29, a3);
    if (v62 > 128)
      goto LABEL_26;
    goto LABEL_27;
  }
  if (v55 < 64)
    goto LABEL_25;
LABEL_22:
  v122 = 128;
  v58 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v59 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
  v58(&v122, &type metadata for Int, v59, a3, a4);
  v60 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
  v61 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  result = v61(v29, a3);
  if ((v60 & 1) != 0)
    goto LABEL_26;
LABEL_27:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v63(v27, a2, a3);
  v64 = v119(a3, a4);
  v63(v24, (uint64_t)v27, a3);
  if ((v64 & 1) != 0)
  {
    v65 = v118(a3, a4);
    v61(v24, a3);
    if (v65 <= 64)
      goto LABEL_48;
    v66 = v113;
    v63(v113, (uint64_t)v27, a3);
    v122 = 0x8000000000000000;
    v67 = v119;
    if ((v119(a3, a4) & 1) != 0)
    {
      v68 = v118(a3, a4);
      if (v68 < 64)
      {
        v71 = v29;
        goto LABEL_42;
      }
      v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v81 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
      v80(&v122, &type metadata for Int, v81, a3, a4);
      v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v66, v29, a3);
      goto LABEL_37;
    }
    v73 = v67(a3, a4);
    v74 = v118(a3, a4);
    if ((v73 & 1) != 0)
    {
      if (v74 <= 64)
      {
        v85 = AssociatedTypeWitness;
        v84 = (void (**)(char *, uint64_t, const char *))v116;
        v86 = swift_getAssociatedConformanceWitness((uint64_t)v116, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v87 = v114;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v86 + 8))(&unk_1816B7DA8, 256, v85, v86);
        v84[3](v87, a3, (const char *)v84);
        v88 = v113;
        LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v113, v29, a3);
        v61(v29, a3);
        v89 = v112;
        v63(v112, (uint64_t)v88, a3);
        if ((v84 & 1) != 0)
        {
          v61(v89, a3);
          goto LABEL_68;
        }
        v90 = v122;
        v91 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v61(v89, a3);
        v92 = v91 < v90;
        v66 = v113;
        if (v92)
          goto LABEL_68;
LABEL_46:
        v72 = v66;
        goto LABEL_47;
      }
      v77 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v78 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      v77(&v122, &type metadata for Int, v78, a3, a4);
      v66 = v113;
      v79 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v113, v29, a3);
LABEL_37:
      v82 = v79;
      v61(v29, a3);
      if ((v82 & 1) != 0)
        goto LABEL_68;
      goto LABEL_46;
    }
    if (v74 < 64)
    {
      v71 = v29;
      v66 = v113;
LABEL_42:
      v63(v71, (uint64_t)v66, a3);
      v83 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      if (v83 < v122)
LABEL_68:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_46;
    }
    v72 = v113;
  }
  else
  {
    v72 = v24;
  }
LABEL_47:
  v61(v72, a3);
LABEL_48:
  v93 = v118;
  v94 = v118(a3, a4);
  v95 = v117;
  v63(v117, (uint64_t)v27, a3);
  if (v94 >= 65)
  {
    v61(v95, a3);
    goto LABEL_50;
  }
  v103 = v93(a3, a4);
  v61(v95, a3);
  if (v103 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_50:
    v63(v17, (uint64_t)v27, a3);
    v122 = 0x7FFFFFFFFFFFFFFFLL;
    v96 = v119(a3, a4);
    v97 = v118(a3, a4);
    if ((v96 & 1) != 0)
    {
      if (v97 > 64)
      {
        v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
        v102 = &v122;
        goto LABEL_59;
      }
    }
    else if (v97 >= 64)
    {
      v121 = 0x7FFFFFFFFFFFFFFFLL;
      v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
      v102 = &v121;
LABEL_59:
      v100(v102, &type metadata for Int, v101, a3, a4);
      v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v17, a3);
      v61(v29, a3);
      if ((v104 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_60;
    }
    v63(v29, (uint64_t)v17, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
LABEL_60:
    v61(v17, a3);
  }
  v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v61(v27, a3);
  v106 = *v120;
  v51 = v120[1];
  if ((v105 & 0x8000000000000000) == 0)
  {
    if (v105 < 0x80)
    {
      v53 = (v51 << v105) | (v106 >> 1 >> ~(_BYTE)v105);
      v52 = v106 << v105;
      if ((v105 & 0x40) != 0)
      {
        v53 = v106 << v105;
        v52 = 0;
      }
      goto LABEL_65;
    }
LABEL_26:
    v52 = 0;
    v53 = 0;
    goto LABEL_65;
  }
  if (v105 <= 0xFFFFFFFFFFFFFF80)
  {
LABEL_19:
    v52 = v51 >> 63;
    v53 = v52;
    goto LABEL_65;
  }
  v108 = v51 >> -(char)v105;
  v53 = v51 >> 63;
  if ((-(uint64_t)v105 & 0x40) == 0)
    v53 = v51 >> -(char)v105;
  v52 = ((2 * v51) << (v105 - 1)) | (v106 >> -(char)v105);
  if ((-(uint64_t)v105 & 0x40) != 0)
    v52 = v108;
LABEL_65:
  v107 = v120;
  *v120 = v52;
  v107[1] = v53;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int128(uint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t *v3;
  uint64_t result;
  uint64_t v6;

  result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for BinaryInteger.isMultiple(of:) in conformance Int128(uint64_t *a1)
{
  uint64_t *v1;

  return specialized SignedInteger<>.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

void protocol witness for BinaryInteger.signum() in conformance Int128(uint64_t *a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;

  v2 = *(uint64_t *)(v1 + 8) >> 63;
  *a1 = v2 | (*(_OWORD *)v1 != 0);
  a1[1] = v2;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int128()
{
  uint64_t *v0;

  return specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, *v0, v0[1]);
}

unint64_t *protocol witness for Strideable.distance(to:) in conformance Int128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  char v11;
  unsigned __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;

  v3 = *result;
  v4 = result[1];
  v6 = *v2;
  v5 = v2[1];
  if ((v5 ^ v4) < 0)
  {
    v12 = __PAIR128__(v5 ^ (unint64_t)(v5 >> 63), v6 ^ (v5 >> 63)) - __PAIR128__(v5 >> 63, v5 >> 63);
    v14 = (v3 ^ (v4 >> 63)) - (v4 >> 63);
    v13 = (__PAIR128__(v4 ^ (unint64_t)(v4 >> 63), v3 ^ (v4 >> 63)) - __PAIR128__(v4 >> 63, v4 >> 63)) >> 64;
    v15 = (__PAIR128__(v5 ^ (unint64_t)(v5 >> 63), v6 ^ (v5 >> 63))
         - __PAIR128__(v5 >> 63, v5 >> 63)
         + (unint64_t)v14) >> 64;
    v8 = (v6 ^ (v5 >> 63)) - (v5 >> 63) + v14;
    v16 = __CFADD__(__CFADD__((_QWORD)v12, v14), *((_QWORD *)&v12 + 1)) | __CFADD__(v13, v15);
    v17 = v13 + v15;
    if (v16)
      v18 = 1;
    else
      v18 = 0;
    if ((v18 & 1) == 0)
    {
      if (v17 | (v8 >> 63))
        goto LABEL_18;
      if (v5 >= 0)
        v8 = -(uint64_t)v8;
      goto LABEL_15;
    }
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  v10 = __OFSUB__(__PAIR128__(v4, v3), __PAIR128__(v5, v6));
  v9 = v3 - v6;
  v7 = (__PAIR128__(v4, v3) - __PAIR128__(v5, v6)) >> 64;
  v8 = v3 - v6;
  v11 = v10;
  if ((v11 & 1) != 0)
  {
    __break(1u);
    goto LABEL_17;
  }
  if (__CFADD__(v9, 0x8000000000000000) + v7)
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
LABEL_15:
  *a2 = v8;
  return result;
}

uint64_t *protocol witness for Strideable.advanced(by:) in conformance Int128@<X0>(uint64_t *result@<X0>, _OWORD *a2@<X8>)
{
  _QWORD *v2;
  __int128 v3;
  char v4;

  v3 = *(_OWORD *)v2 + *result;
  if (__OFADD__(__CFADD__(*v2, *result), v2[1]) | __OFADD__(*result >> 63, *((_QWORD *)&v3 + 1)))
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
    __break(1u);
  else
    *a2 = v3;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int128(uint64_t a1, uint64_t a2, char a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance Int128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

uint64_t static Int128.bitWidth.getter()
{
  return 128;
}

uint64_t Int128.nonzeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  uint8x8_t v2;
  uint64_t v3;
  uint8x8_t v4;

  v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  v3 = v2.u32[0];
  v4 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v4.i16[0] = vaddlv_u8(v4);
  return v3 + v4.u32[0];
}

uint64_t Int64.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t UInt64.nonzeroBitCount.getter(uint64_t a1)
{
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t Int128.leadingZeroBitCount.getter(unint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = __clz(a2);
  v3 = __clz(a1) + 64;
  if (a2)
    return v2;
  else
    return v3;
}

BOOL static Int64.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

unint64_t UInt64.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

unint64_t Int64.leadingZeroBitCount.getter(unint64_t a1)
{
  return __clz(a1);
}

unint64_t Int128.byteSwapped.getter(uint64_t a1, unint64_t a2)
{
  return bswap64(a2);
}

unint64_t Int64.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

unint64_t UInt64.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

uint64_t static Int128.&* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 * a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int128(_QWORD *a1@<X8>)
{
  *a1 = -1;
  a1[1] = 0x7FFFFFFFFFFFFFFFLL;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int128(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0x8000000000000000;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int128(_OWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  __int128 v3;
  uint64_t v4;

  v3 = *(_OWORD *)v2 + *(_OWORD *)a2;
  if (__OFADD__(__CFADD__(*v2, *a2), v2[1]) | __OFADD__(a2[1], *((_QWORD *)&v3 + 1)))
    v4 = 1;
  else
    v4 = 0;
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int128(_OWORD *a1, _OWORD *a2)
{
  _OWORD *v2;
  _BOOL8 v3;

  v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int128(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int128 v3;
  unsigned __int128 v4;
  BOOL v5;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  _BOOL4 v15;

  v3 = abs128(*(_OWORD *)v2);
  v4 = abs128(*(_OWORD *)a2);
  if (*((_QWORD *)&v3 + 1))
    v5 = *((_QWORD *)&v4 + 1) == 0;
  else
    v5 = 1;
  v8 = !v5
    || (*((unint64_t *)&v3 + 1) * (unsigned __int128)(unint64_t)v4) >> 64 != 0
    || (*((unint64_t *)&v4 + 1) * (unsigned __int128)(unint64_t)v3) >> 64 != 0;
  if (__CFADD__(((unint64_t)v3 * (unsigned __int128)(unint64_t)v4) >> 64, *((_QWORD *)&v4 + 1) * v3 + *((_QWORD *)&v3 + 1) * v4))
  {
    v9 = 1;
  }
  else
  {
    v9 = v8;
  }
  v10 = *(_QWORD *)(v2 + 8) ^ *(_QWORD *)(a2 + 8);
  v11 = -(v3 * v4);
  v12 = (unsigned __int128)-(__int128)__PAIR128__(v8, (_QWORD)v3 * (_QWORD)v4) >> 64;
  v13 = v10 < 0;
  if (v10 >= 0)
    v14 = (v4 * v3) >> 64;
  else
    v14 = v12;
  if (v13)
  {
    v15 = (_QWORD)v3 * (_QWORD)v4 != 0;
  }
  else
  {
    v11 = v3 * v4;
    v15 = (((v4 * v3) >> 64) & 0x8000000000000000) != 0;
  }
  *a1 = v11;
  a1[1] = v14;
  return v9 | v15;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  _QWORD *v2;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  if (*(_OWORD *)a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/Int128.swift", 18, 2, 0x126uLL, 0);
  v4 = (*(_QWORD *)a2 & *(_QWORD *)(a2 + 8)) == -1 && (*v2 | v2[1] ^ 0x8000000000000000) == 0;
  v5 = v4;
  if (v4)
  {
    v6 = 0;
    v7 = 0x8000000000000000;
  }
  else
  {
    v6 = __divti3();
  }
  *a1 = v6;
  a1[1] = v7;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int128(uint64_t *a1, uint64_t a2)
{
  _QWORD *v2;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_OWORD *)a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/Int128.swift", 18, 2, 0x130uLL, 0);
  v4 = (*(_QWORD *)a2 & *(_QWORD *)(a2 + 8)) == -1 && (*v2 | v2[1] ^ 0x8000000000000000) == 0;
  v5 = v4;
  if (v4)
  {
    v6 = 0;
    v7 = 0;
  }
  else
  {
    v6 = __modti3();
  }
  *a1 = v6;
  a1[1] = v7;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int128(uint64_t *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v6;

  result = specialized FixedWidthInteger.multipliedFullWidth(by:)(a2, *(_QWORD *)a3, *(_QWORD *)(a3 + 8), *(_QWORD *)v3, *(_QWORD *)(v3 + 8));
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int128(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t *v4;
  uint64_t result;
  uint64_t v7;

  result = specialized SignedInteger<>.dividingFullWidth(_:)(a2, *(_QWORD *)a3, *(_QWORD *)(a3 + 8), *a4, a4[1], *v4, v4[1]);
  *a1 = result;
  a1[1] = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.init(_truncatingBits:) in conformance Int128@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = result;
  a2[1] = 0;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int128()
{
  int8x8_t *v0;
  uint8x8_t v1;
  uint64_t v2;
  uint8x8_t v3;

  v1 = (uint8x8_t)vcnt_s8(v0[1]);
  v1.i16[0] = vaddlv_u8(v1);
  v2 = v1.u32[0];
  v3 = (uint8x8_t)vcnt_s8(*v0);
  v3.i16[0] = vaddlv_u8(v3);
  return v2 + v3.u32[0];
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int128()
{
  unint64_t *v0;
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;

  v1 = v0[1];
  v2 = __clz(v1);
  v3 = __clz(*v0) + 64;
  if (v1)
    return v2;
  else
    return v3;
}

unint64_t *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int128@<X0>(unint64_t *result@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v2;

  v2 = bswap64(*result);
  *a2 = bswap64(result[1]);
  a2[1] = v2;
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int128(_QWORD *a1@<X8>)
{
  unint64_t *v1;
  unint64_t v2;

  v2 = bswap64(*v1);
  *a1 = bswap64(v1[1]);
  a1[1] = v2;
}

_QWORD *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = result[1];
  v4 = ((2 * v3) << ~*a2) | (*result >> *a2);
  v5 = v3 >> *a2;
  if ((*a2 & 0x40) != 0)
    v4 = v3 >> *a2;
  v6 = v3 >> 63;
  if ((*a2 & 0x40) == 0)
    v6 = v5;
  *a3 = v4;
  a3[1] = v6;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int128(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[1];
  v3 = v2 >> *a2;
  if ((*a2 & 0x40) != 0)
    v4 = v2 >> *a2;
  else
    v4 = ((2 * v2) << ~*a2) | ((unint64_t)*result >> *a2);
  v5 = v2 >> 63;
  if ((*a2 & 0x40) == 0)
    v5 = v3;
  *result = v4;
  result[1] = v5;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  v3 = (result[1] << *a2) | (*result >> 1 >> ~*a2);
  v4 = *result << *a2;
  if ((*a2 & 0x40) != 0)
  {
    v3 = *result << *a2;
    v4 = 0;
  }
  *a3 = v4;
  a3[1] = v3;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int128(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *result << *a2;
  if ((*a2 & 0x40) != 0)
    v3 = *result << *a2;
  else
    v3 = (result[1] << *a2) | (*result >> 1 >> ~*a2);
  if ((*a2 & 0x40) != 0)
    v2 = 0;
  *result = v2;
  result[1] = v3;
  return result;
}

_OWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  v3 = (*a2 * *result) >> 64;
  *a3 = *(_QWORD *)a2 * *(_QWORD *)result;
  a3[1] = v3;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

uint64_t Mirror.subjectType.getter()
{
  uint64_t v0;

  return *(_QWORD *)v0;
}

unint64_t *Mirror.children.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;

  return swift_retain(*(unint64_t **)(v4 + 8), a2, a3, a4);
}

void Mirror.displayStyle.getter(_BYTE *a1@<X8>)
{
  uint64_t v1;

  *a1 = *(_BYTE *)(v1 + 16);
}

double (*static Mirror._superclassIterator<A>(_:_:)(uint64_t a1, uint64_t a2, swift *a3))@<D0>(uint64_t a1@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  swift *v12;
  unint64_t Superclass;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;

  v5 = *((_QWORD *)a3 - 1);
  v6 = *(_QWORD *)(v5 + 64);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = *v8;
  v9 = (unint64_t *)v8[1];
  if (swift_isClassType(v11))
    v12 = a3;
  else
    v12 = 0;
  if (!v12)
    return (double (*)@<D0>(uint64_t@<X8>))implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
  Superclass = _swift_class_getSuperclass(v12);
  if (!Superclass)
    return (double (*)@<D0>(uint64_t@<X8>))implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
  v14 = Superclass;
  if (v10)
  {
    if (v10 == 1)
      return (double (*)@<D0>(uint64_t@<X8>))implicit closure #1 in static Mirror._superclassIterator<A>(_:_:);
    (*(void (**)(char *, uint64_t, swift *))(v5 + 16))((char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a3);
    v20 = *(unsigned __int8 *)(v5 + 80);
    v21 = (v20 + 48) & ~v20;
    v22 = (char *)swift_allocObject((uint64_t)&unk_1E0EAD788, v21 + v6, v20 | 7);
    *((_QWORD *)v22 + 2) = a3;
    *((_QWORD *)v22 + 3) = v10;
    *((_QWORD *)v22 + 4) = v9;
    *((_QWORD *)v22 + 5) = v14;
    (*(void (**)(char *, char *, swift *))(v5 + 32))(&v22[v21], v7, a3);
    swift_retain(v9, v23, v24, v25);
    return (double (*)@<D0>(uint64_t@<X8>))partial apply for closure #2 in static Mirror._superclassIterator<A>(_:_:);
  }
  else
  {
    (*(void (**)(char *, uint64_t, swift *))(v5 + 16))((char *)&v26 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a3);
    v16 = *(unsigned __int8 *)(v5 + 80);
    v17 = (v16 + 24) & ~v16;
    v18 = (v6 + v17 + 7) & 0xFFFFFFFFFFFFFFF8;
    v19 = (char *)swift_allocObject((uint64_t)&unk_1E0EAD7B0, v18 + 8, v16 | 7);
    *((_QWORD *)v19 + 2) = a3;
    (*(void (**)(char *, char *, swift *))(v5 + 32))(&v19[v17], v7, a3);
    *(_QWORD *)&v19[v18] = v14;
    return partial apply for closure #1 in static Mirror._superclassIterator<A>(_:_:);
  }
}

uint64_t closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _QWORD *v6;
  unint64_t AssociatedTypeWitness;
  _QWORD *boxed_opaque_existential_0Tm;

  v6 = a4 + 2;
  *a4 = 0;
  a4[1] = 0;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  a4[5] = AssociatedTypeWitness;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v6);
  return (*(uint64_t (**)(_QWORD *, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 16))(boxed_opaque_existential_0Tm, a1, AssociatedTypeWitness);
}

uint64_t closure #1 in Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  _OWORD *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _OWORD v11[2];
  uint64_t v12[4];

  v3 = a2 + 2;
  v4 = (uint64_t)(a1 + 2);
  v6 = *a1;
  v5 = a1[1];
  outlined init with copy of Any((uint64_t)(a1 + 2), (uint64_t)v12);
  *a2 = v6;
  a2[1] = v5;
  outlined init with copy of Any(v4, (uint64_t)v11);
  outlined init with take of Any(v11, v3);
  swift_bridgeObjectRetain(v5, v7, v8, v9);
  return __swift_destroy_boxed_opaque_existential_1Tm(v12);
}

double implicit closure #1 in static Mirror._superclassIterator<A>(_:_:)@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *(_OWORD *)((char *)a1 + 25) = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

unint64_t *protocol witness for CustomReflectable.customMirror.getter in conformance Mirror._Dummy@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4;
  unint64_t *v5;
  char v6;
  uint64_t v7;
  unint64_t *v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;

  v5 = *(unint64_t **)(v4 + 8);
  v6 = *(_BYTE *)(v4 + 16);
  v7 = *(_QWORD *)(v4 + 24);
  v8 = *(unint64_t **)(v4 + 32);
  v9 = *(_BYTE *)(v4 + 40);
  *(_QWORD *)a4 = *(_QWORD *)v4;
  *(_QWORD *)(a4 + 8) = v5;
  *(_BYTE *)(a4 + 16) = v6;
  *(_QWORD *)(a4 + 24) = v7;
  *(_QWORD *)(a4 + 32) = v8;
  *(_BYTE *)(a4 + 40) = v9;
  swift_retain(v5, a1, a2, a3);
  return swift_retain(v8, v10, v11, v12);
}

uint64_t Mirror.descendant(_:_:)@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t *v3;
  unint64_t *v6;
  uint64_t v7;
  char v8;
  unint64_t *v9;
  uint64_t v10;
  char v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *inited;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  Class *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  uint64_t v30;
  Class *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  __int128 v35;
  void *v36;
  unint64_t v37;
  uint64_t (*v38)(unint64_t, unint64_t);
  unint64_t v39;
  unint64_t v40;
  unint64_t ObjectType;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char v45;
  int isUniquelyReferenced_nonNull;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  unint64_t v50;
  void (*v51)(id, unint64_t);
  id v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  void *v57;
  void *v58;
  unint64_t v59;
  uint64_t (*v60)(void *, unint64_t, uint64_t, void *, unint64_t);
  uint64_t v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  void *v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t (*v80)(unint64_t, unint64_t);
  uint64_t v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t (*v87)(void *, unint64_t, unint64_t, unint64_t);
  uint64_t v88;
  uint64_t v89;
  char *v90;
  char v91;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  _BYTE v98[48];
  __int128 v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102[4];
  swift::SwiftError *v103[4];
  uint64_t v104[5];
  __int128 v105[2];
  uint64_t v106[9];
  __int128 v107;
  ValueMetadata *v108;

  v7 = *v3;
  v6 = (unint64_t *)v3[1];
  v8 = *((_BYTE *)v3 + 16);
  v10 = v3[3];
  v9 = (unint64_t *)v3[4];
  v11 = *((_BYTE *)v3 + 40);
  v108 = &type metadata for Mirror._Dummy;
  v12 = swift_allocObject((uint64_t)&unk_1E0E9C530, 0x39uLL, 7uLL);
  *(_QWORD *)&v107 = v12;
  v12[2] = v7;
  v12[3] = v6;
  *((_BYTE *)v12 + 32) = v8;
  v12[5] = v10;
  v12[6] = v9;
  *((_BYTE *)v12 + 56) = v11;
  v13 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<MirrorPath>);
  inited = swift_initStackObject(v13, v106);
  *((_OWORD *)inited + 1) = xmmword_1816ABBA0;
  outlined init with copy of MirrorPath(a1, (uint64_t)(inited + 4));
  *(_QWORD *)&v99 = inited;
  swift_retain(v6, v15, v16, v17);
  swift_retain(v9, v18, v19, v20);
  swift_bridgeObjectRetain(a2, v21, v22, v23);
  specialized Array.append<A>(contentsOf:)(a2, &demangling cache variable for type metadata for _ContiguousArrayStorage<MirrorPath>, &demangling cache variable for type metadata for MirrorPath);
  v24 = (uint64_t)inited;
  v96 = inited[2];
  if (!v96)
  {
LABEL_32:
    swift_bridgeObjectRelease(v24);
    outlined init with copy of Any((uint64_t)&v107, (uint64_t)a3);
    return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v107);
  }
  v25 = 0;
  v95 = v99 + 32;
  v94 = v99;
  while (2)
  {
    if (v25 >= *(_QWORD *)(v24 + 16))
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
    outlined init with copy of MirrorPath(v95 + 40 * v25, (uint64_t)v105);
    outlined init with take of MirrorPath(v105, (uint64_t)v104);
    outlined init with copy of Any((uint64_t)&v107, (uint64_t)v103);
    outlined init with copy of Any((uint64_t)v103, (uint64_t)v102);
    v26 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomReflectable);
    if (swift_dynamicCast((char *)&v99, v102, qword_1E0EB1338, v26, 6uLL))
    {
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v103);
      outlined init with take of MirrorPath(&v99, (uint64_t)v98);
      v28 = *(_QWORD *)&v98[32];
      v27 = *(_QWORD *)&v98[24];
      __swift_project_boxed_opaque_existential_0Tm(v98, *(uint64_t *)&v98[24]);
      (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(v28 + 8))(&v99, v27, v28);
      v29 = (unint64_t *)*((_QWORD *)&v99 + 1);
      v30 = v101;
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)v98);
    }
    else
    {
      *(_QWORD *)&v101 = 0;
      v99 = 0u;
      v100 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v99, &demangling cache variable for type metadata for CustomReflectable?);
      memset(v98, 0, 41);
      Mirror.init(internalReflecting:subjectType:customAncestor:)(v103, 0, (uint64_t)v98, (uint64_t)&v99);
      v29 = (unint64_t *)*((_QWORD *)&v99 + 1);
      v30 = v101;
    }
    swift_release(v30);
    outlined init with copy of MirrorPath((uint64_t)v104, (uint64_t)&v99);
    v31 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for MirrorPath);
    v97 = v25;
    if ((swift_dynamicCast(v98, (uint64_t *)&v99, v31, (Class *)&type metadata for String, 6uLL) & 1) == 0)
    {
      outlined init with copy of MirrorPath((uint64_t)v104, (uint64_t)&v99);
      if (!swift_dynamicCast(v98, (uint64_t *)&v99, v31, (Class *)&type metadata for Int, 6uLL))
      {
        swift_release((uint64_t)v29);
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Someone added a conformance to MirrorPath; that privilege is reserved to the standard library",
          93,
          2,
          "Swift/Mirror.swift",
          18,
          2,
          0x1CBuLL,
          0);
      }
      __swift_destroy_boxed_opaque_existential_1Tm(v104);
      v55 = *(_QWORD *)v98;
      v57 = (void *)v29[2];
      v56 = v29[3];
      v58 = (void *)v29[4];
      v59 = v29[5];
      v60 = *(uint64_t (**)(void *, unint64_t, uint64_t, void *, unint64_t))(*v29 + 288);
      swift_retain(v29, v61, v62, v63);
      swift_unknownObjectRetain(v57, v64, v65, v66);
      swift_unknownObjectRetain(v58, v67, v68, v69);
      v36 = (void *)v60(v57, v56, v55, v58, v59);
      v37 = v70;
      swift_unknownObjectRelease(v57);
      swift_unknownObjectRelease(v58);
      swift_release((uint64_t)v29);
      if (!v36)
      {
        v36 = (void *)v29[4];
        v37 = v29[5];
        swift_unknownObjectRetain(v36, v71, v72, v73);
      }
      goto LABEL_29;
    }
    v35 = *(_OWORD *)v98;
    v36 = (void *)v29[2];
    v37 = v29[3];
    swift_unknownObjectRetain(v36, v32, v33, v34);
LABEL_9:
    v38 = *(uint64_t (**)(unint64_t, unint64_t))(v37 + 8);
    while (1)
    {
      v39 = v29[4];
      v40 = v29[5];
      ObjectType = swift_getObjectType((unint64_t)v36);
      v42 = v38(ObjectType, v37);
      v43 = swift_getObjectType(v39);
      if (v42 != (*(uint64_t (**)(unint64_t, unint64_t))(v40 + 8))(v43, v40))
      {
        swift_release((uint64_t)v29);
LABEL_36:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Base index types differ", 23, 2, "Swift/ExistentialCollection.swift", 33, 2, 0x747uLL, 0);
      }
      v44 = swift_getObjectType((unint64_t)v36);
      if (((*(uint64_t (**)(unint64_t, unint64_t, unint64_t, unint64_t))(v37 + 24))(v39, v40, v44, v37) & 1) != 0)
      {
        swift_bridgeObjectRelease(*((uint64_t *)&v35 + 1));
        __swift_destroy_boxed_opaque_existential_1Tm(v104);
        swift_unknownObjectRelease(v36);
        v36 = (void *)v29[4];
        v37 = v29[5];
        swift_unknownObjectRetain(v36, v74, v75, v76);
        goto LABEL_28;
      }
      (*(void (**)(__int128 *__return_ptr, void *, unint64_t))(*v29 + 256))(&v99, v36, v37);
      *(_OWORD *)v98 = v99;
      *(_OWORD *)&v98[16] = v100;
      *(_OWORD *)&v98[32] = v101;
      if (!*((_QWORD *)&v99 + 1))
      {
LABEL_18:
        outlined destroy of _HasContiguousBytes?((uint64_t)v98, &demangling cache variable for type metadata for (label: String?, value: Any));
        goto LABEL_20;
      }
      if (__PAIR128__(*((unint64_t *)&v99 + 1), *(unint64_t *)v98) == v35)
        break;
      if ((~*((_QWORD *)&v99 + 1) & 0x6000000000000000) == 0
        && (*((_QWORD *)&v35 + 1) & 0x2000000000000000) != 0
        && (*((_QWORD *)&v35 + 1) & 0x4000000000000000) != 0)
      {
        goto LABEL_18;
      }
      v45 = _stringCompareInternal(_:_:expecting:)(*(uint64_t *)v98, *((unint64_t *)&v99 + 1), v35, *((unint64_t *)&v35 + 1), 0);
      outlined destroy of _HasContiguousBytes?((uint64_t)v98, &demangling cache variable for type metadata for (label: String?, value: Any));
      if ((v45 & 1) != 0)
        goto LABEL_27;
LABEL_20:
      isUniquelyReferenced_nonNull = swift_isUniquelyReferenced_nonNull((unint64_t)v36);
      v50 = *v29;
      if (!isUniquelyReferenced_nonNull)
      {
        v53 = (*(uint64_t (**)(void *, unint64_t))(v50 + 264))(v36, v37);
        v37 = v54;
        swift_unknownObjectRelease(v36);
        v36 = (void *)v53;
        goto LABEL_9;
      }
      v51 = *(void (**)(id, unint64_t))(v50 + 272);
      v52 = swift_unknownObjectRetain(v36, v47, v48, v49);
      v51(v52, v37);
      swift_unknownObjectRelease(v36);
    }
    outlined destroy of _HasContiguousBytes?((uint64_t)v98, &demangling cache variable for type metadata for (label: String?, value: Any));
LABEL_27:
    swift_bridgeObjectRelease(*((uint64_t *)&v35 + 1));
    __swift_destroy_boxed_opaque_existential_1Tm(v104);
LABEL_28:
    v24 = v94;
LABEL_29:
    v77 = (void *)v29[4];
    v78 = v29[5];
    v79 = swift_getObjectType((unint64_t)v36);
    v80 = *(uint64_t (**)(unint64_t, unint64_t))(v37 + 8);
    swift_unknownObjectRetain(v77, v81, v82, v83);
    v84 = v80(v79, v37);
    v85 = swift_getObjectType((unint64_t)v77);
    if (v84 != (*(uint64_t (**)(unint64_t, unint64_t))(v78 + 8))(v85, v78))
      goto LABEL_36;
    v86 = swift_getObjectType((unint64_t)v36);
    v87 = *(uint64_t (**)(void *, unint64_t, unint64_t, unint64_t))(v37 + 24);
    swift_unknownObjectRetain(v36, v88, v89, v90);
    v91 = v87(v77, v78, v86, v37);
    swift_unknownObjectRelease(v77);
    swift_unknownObjectRelease(v36);
    if ((v91 & 1) == 0)
    {
      v25 = v97 + 1;
      (*(void (**)(__int128 *__return_ptr, void *, unint64_t))(*v29 + 256))(&v99, v36, v37);
      swift_release((uint64_t)v29);
      swift_unknownObjectRelease(v36);
      swift_bridgeObjectRelease(*((uint64_t *)&v99 + 1));
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v107);
      outlined init with take of Any(&v100, &v107);
      if (v97 + 1 == v96)
        goto LABEL_32;
      continue;
    }
    break;
  }
  swift_bridgeObjectRelease(v24);
  swift_release((uint64_t)v29);
  swift_unknownObjectRelease(v36);
  *a3 = 0u;
  a3[1] = 0u;
  return __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v107);
}

uint64_t String.init<A>(describing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  return v5;
}

{
  _QWORD v6[2];

  v6[0] = 0;
  v6[1] = 0xE000000000000000;
  (*(void (**)(_QWORD *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(a3 + 8))(v6, &type metadata for String, &protocol witness table for String, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  return v6[0];
}

{
  uint64_t v5;

  v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  return v5;
}

uint64_t Mirror.description.getter()
{
  unint64_t v0;
  Class **v1;
  Class *v2;
  unint64_t v3;
  void *v4;
  unint64_t v5;
  uint64_t v6;
  char *v7;
  Swift::String v8;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  BOOL v21;
  Swift::Int v22;
  unint64_t v23;
  int64_t v24;
  char v25;
  int64_t v26;
  char v27;
  BOOL v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  size_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unsigned __int8 *v39;
  uint64_t v40;
  unint64_t v41;
  Swift::String::Index v42;
  Swift::String::Index v43;
  Swift::String::Index v44;
  Swift::String::Index v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  char v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  void *v64;
  char v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  char v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  id v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  size_t v81;
  unint64_t v82;
  uint8x16_t *TypeName;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  size_t v87;
  uint64_t *v88;
  uint8x16_t *v89;
  uint64_t v90;
  uint64_t v91;
  char v92;
  uint64_t v93;
  uint8x16_t *v94;
  uint8x16_t *v95;
  uint8x16_t *v96;
  uint64_t v97;
  unsigned __int8 v98;
  int v99;
  unsigned int v100;
  unsigned int v101;
  _QWORD *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  size_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  size_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  int64x2_t v134;
  int8x16_t v135;
  int8x16_t v136;
  int64x2_t v137;
  int64x2_t v138;
  int64x2_t v139;
  int64x2_t v140;
  uint8x8_t *v141;
  int8x16_t v142;
  unint64_t v143;
  int64x2_t v144;
  int8x16_t v145;
  int8x16_t v146;
  uint8x8_t v147;
  uint16x8_t v148;
  uint32x4_t v149;
  uint64x2_t v150;
  uint64x2_t v151;
  uint64x2_t v152;
  uint32x4_t v153;
  uint64x2_t v154;
  int8x16_t v155;
  uint16x8_t v156;
  int8x16_t v157;
  uint16x8_t v158;
  int8x16_t v159;
  int8x16_t v160;
  int8x8_t v161;
  int8x16_t v162;
  int8x8_t v163;
  uint64x2_t v164;
  int8x16_t v165;
  int8x16_t v166;
  int8x16_t v167;
  int8x16_t v168;
  unsigned __int8 *v169;
  unint64_t v170;
  unsigned int v171;
  unint64_t v172;
  int8x8_t v173;
  unint64_t v174;
  unint64_t v175;
  int64x2_t v176;
  int8x16_t v177;
  int8x16_t v178;
  int64x2_t v179;
  int64x2_t v180;
  int64x2_t v181;
  int64x2_t v182;
  uint8x8_t *v183;
  int8x16_t v184;
  unint64_t v185;
  int64x2_t v186;
  int8x16_t v187;
  int8x16_t v188;
  uint8x8_t v189;
  uint16x8_t v190;
  uint32x4_t v191;
  uint64x2_t v192;
  uint64x2_t v193;
  uint64x2_t v194;
  uint32x4_t v195;
  uint64x2_t v196;
  int8x16_t v197;
  uint8x16_t *v198;
  int64x2_t v199;
  int64x2_t v200;
  int64x2_t v201;
  int64x2_t v202;
  int64x2_t v203;
  int64x2_t v204;
  int8x16_t v205;
  int64x2_t v206;
  int64x2_t v207;
  int8x16_t v208;
  int8x16_t v209;
  int64x2_t v210;
  unint64_t v211;
  int8x16_t v212;
  int8x16_t v213;
  int8x16_t v214;
  int8x16_t v215;
  int8x16_t v216;
  int8x16_t v217;
  uint8x16_t v218;
  uint16x8_t v219;
  uint32x4_t v220;
  uint64x2_t v221;
  uint64x2_t v222;
  uint16x8_t v223;
  uint32x4_t v224;
  uint64x2_t v225;
  uint64x2_t v226;
  uint64x2_t v227;
  uint32x4_t v228;
  uint64x2_t v229;
  uint32x4_t v230;
  uint64x2_t v231;
  uint64x2_t v232;
  int8x16_t v233;
  uint64_t v234;
  unsigned __int8 *v235;
  unsigned int v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  Swift::Int v240;
  int64_t v241;
  int64_t v242;
  char v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  char *v247;
  unint64_t v248;
  unint64_t v249;
  unint64_t v250;
  Swift::String::Index v251;
  Swift::String::Index v252;
  Swift::String::Index v253;
  Swift::String::Index v254;
  unint64_t v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  unint64_t v259;
  unint64_t v260;
  unint64_t v261;
  void *v262;
  char v263;
  uint64_t v264;
  void *v265;
  uint64_t v266;
  char *v267;
  int64_t v268;
  char *v269;
  Swift::String *v270;
  size_t v271;
  char v272;
  unint64_t v273;
  unint64_t v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  unint64_t v278;
  char v279;
  uint64_t v280;
  unint64_t v281;
  unint64_t v282;
  unint64_t v283;
  uint64_t v284;
  char *v285;
  size_t v286;
  unint64_t v287;
  unint64_t v288;
  unint64_t v289;
  char v290;
  uint64_t v291;
  uint64_t v292;
  char *v293;
  unint64_t v294;
  unint64_t v295;
  unint64_t v296;
  Swift::String::Index v297;
  Swift::String::Index v298;
  Swift::String::Index v299;
  Swift::String::Index v300;
  unint64_t v301;
  unint64_t v302;
  unint64_t v303;
  unint64_t v304;
  unint64_t v305;
  unint64_t v306;
  unint64_t v307;
  char v308;
  Swift::String::Index v309;
  Swift::String::Index v310;
  Swift::String::Index v311;
  Swift::String::Index v312;
  Swift::Int v313;
  Swift::String::Index v314;
  Swift::String::Index v315;
  Swift::String::Index v316;
  Swift::String::Index v317;
  Swift::Int v318;
  char *v319;
  size_t v320;
  unsigned __int8 *v322;
  uint64_t v323;
  unint64_t v324;
  uint64_t v325;
  int64_t v326;
  unint64_t v327;
  unint64_t v328;
  unint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  unint64_t v333;
  Swift::String v334;
  size_t v335;
  uint64_t v336;

  v2 = *v1;
  v3 = specialized static String._createEmpty(withInitialCapacity:)(13);
  v5 = (unint64_t)v4;
  v334._countAndFlagsBits = v3;
  v334._object = v4;
  v8 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Mirror for ", 0xBuLL, 1);
  countAndFlagsBits = v8._countAndFlagsBits;
  object = v8._object;
  v11 = HIBYTE(v5) & 0xF;
  v12 = v3 & 0xFFFFFFFFFFFFLL;
  if ((v5 & 0x2000000000000000) != 0)
    v13 = HIBYTE(v5) & 0xF;
  else
    v13 = v3 & 0xFFFFFFFFFFFFLL;
  if (!v13 && (v3 & ~v5 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v5);
    v334 = v8;
    goto LABEL_90;
  }
  v331 = (uint64_t)v2;
  v14 = (uint64_t)v8._object & 0x2000000000000000;
  v15 = ((unint64_t)v8._object >> 56) & 0xF;
  if ((v5 & 0x2000000000000000) != 0 && v14)
  {
    v0 = v15 + v11;
    if ((unint64_t)(v15 + v11) <= 0xF)
    {
      if (v15)
      {
        v65 = 0;
        v66 = 0;
        v67 = v5;
        do
        {
          v68 = v11 + v66;
          v69 = v66 + 1;
          if (v66 >= 8)
            v70 = (unint64_t)v8._object;
          else
            v70 = v8._countAndFlagsBits;
          v71 = v70 >> (v65 & 0x38);
          v72 = (8 * v11 + v65) & 0x38;
          v73 = (-255 << v72) - 1;
          v74 = (unint64_t)v71 << v72;
          v75 = v74 | v73 & v67;
          v76 = v74 | v73 & v3;
          if (v68 < 8)
            v3 = v76;
          else
            v67 = v75;
          v65 += 8;
          v66 = v69;
        }
        while (v15 != v69);
      }
      else
      {
        v67 = v5;
      }
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      v82 = 0xA000000000000000;
      if (!(v3 & 0x8080808080808080 | v67 & 0x80808080808080))
        v82 = 0xE000000000000000;
      v64 = (void *)(v82 & 0xFF00000000000000 | (v0 << 56) | v67 & 0xFFFFFFFFFFFFFFLL);
LABEL_88:
      v334._countAndFlagsBits = v3;
      v334._object = v64;
      goto LABEL_89;
    }
    v14 = 1;
  }
  if (v14)
    v16 = ((unint64_t)v8._object >> 56) & 0xF;
  else
    v16 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  swift_bridgeObjectRetain_n((uint64_t)v8._object, 2, v6, v7);
  v330 = v16;
  if (((uint64_t)v8._object & 0x1000000000000000) == 0)
  {
    swift_bridgeObjectRetain_n((uint64_t)v8._object, 4, v17, v18);
    if ((v5 & 0x1000000000000000) == 0)
      goto LABEL_15;
LABEL_274:
    v313 = String.UTF8View._foreignCount()();
    v22 = v313 + v16;
    if (!__OFADD__(v313, v16))
      goto LABEL_16;
LABEL_276:
    __break(1u);
    goto LABEL_277;
  }
  swift_bridgeObjectRetain_n((uint64_t)v8._object, 5, v17, v18);
  v309._rawBits = 1;
  v310._rawBits = (v16 << 16) | 1;
  v311._rawBits = _StringGuts.validateScalarRange(_:)(v309, v310, v8._countAndFlagsBits, (unint64_t)v8._object);
  if (v311._rawBits < 0x10000)
    v311._rawBits |= 3;
  v16 = specialized Collection.count.getter(v311, v312, v8._countAndFlagsBits, (unint64_t)v8._object);
  swift_bridgeObjectRelease((uint64_t)v8._object);
  if ((v5 & 0x1000000000000000) != 0)
    goto LABEL_274;
LABEL_15:
  v21 = __OFADD__(v13, v16);
  v22 = v13 + v16;
  if (v21)
    goto LABEL_276;
LABEL_16:
  v23 = v3 & ~v5;
  if ((v23 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v22 > 15)
      goto LABEL_24;
    if ((v5 & 0x2000000000000000) == 0)
    {
LABEL_46:
      swift_bridgeObjectRelease_n((uint64_t)v8._object, 5);
      if ((v5 & 0x1000000000000000) == 0)
      {
        if ((v3 & 0x1000000000000000) != 0)
        {
          v39 = (unsigned __int8 *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          v39 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v3, v5);
          v12 = v36;
        }
        v40 = v330;
        swift_bridgeObjectRetain(v5, v36, v37, v38);
        closure #1 in _StringGuts._convertedToSmall()(v39, v12, &v332);
        swift_bridgeObjectRelease(v5);
        v3 = v332;
        v41 = v333;
        goto LABEL_53;
      }
      v3 = _StringGuts._foreignConvertedToSmall()(v3, v5);
      v41 = v324;
LABEL_52:
      v40 = v330;
LABEL_53:
      v42._rawBits = (v40 << 16) | 1;
      v43._rawBits = 1;
      v44._rawBits = _StringGuts.validateScalarRange(_:)(v43, v42, v8._countAndFlagsBits, (unint64_t)v8._object);
      if (v44._rawBits < 0x10000)
        v44._rawBits |= 3;
      v46 = specialized String.init(_:)(v44, v45, v8._countAndFlagsBits, (unint64_t)v8._object);
      v48 = v47;
      swift_bridgeObjectRelease((uint64_t)v8._object);
      if ((v48 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v48);
      }
      else if ((v48 & 0x1000000000000000) != 0)
      {
        v46 = _StringGuts._foreignConvertedToSmall()(v46, v48);
        v329 = v328;
        swift_bridgeObjectRelease(v48);
        v48 = v329;
      }
      else
      {
        if ((v46 & 0x1000000000000000) != 0)
        {
          v322 = (unsigned __int8 *)((v48 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v323 = v46 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v322 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v46, v48);
        }
        closure #1 in _StringGuts._convertedToSmall()(v322, v323, &v332);
        swift_bridgeObjectRelease(v48);
        v46 = v332;
        v48 = v333;
      }
      v49 = HIBYTE(v41) & 0xF;
      v50 = HIBYTE(v48) & 0xF;
      v51 = v50 + v49;
      if ((unint64_t)(v50 + v49) > 0xF)
        goto LABEL_301;
      if (v50)
      {
        v52 = 0;
        v53 = 0;
        do
        {
          v54 = v49 + v53;
          v55 = v53 + 1;
          if (v53 >= 8)
            v56 = v48;
          else
            v56 = v46;
          v57 = v56 >> (v52 & 0x38);
          v58 = (8 * v49 + v52) & 0x38;
          v59 = (-255 << v58) - 1;
          v60 = (unint64_t)v57 << v58;
          v61 = v60 | v59 & v41;
          v62 = v60 | v59 & v3;
          if (v54 < 8)
            v3 = v62;
          else
            v41 = v61;
          v52 += 8;
          v53 = v55;
        }
        while (v50 != v55);
      }
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease((uint64_t)v8._object);
      v63 = 0xA000000000000000;
      if (!(v3 & 0x8080808080808080 | v41 & 0x80808080808080))
        v63 = 0xE000000000000000;
      v64 = (void *)(v63 & 0xFF00000000000000 | (v51 << 56) | v41 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_88;
    }
    goto LABEL_51;
  }
  v24 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  if ((v25 & 1) != 0)
    goto LABEL_302;
  if (v22 > 15)
    goto LABEL_24;
  if ((v5 & 0x2000000000000000) != 0)
  {
LABEL_51:
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 5);
    v41 = v5;
    goto LABEL_52;
  }
  if (v24 < v16)
    goto LABEL_46;
LABEL_24:
  v26 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  v29 = (v27 & 1) == 0 && v26 >= v16;
  if ((v23 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v29)
    {
LABEL_41:
      _StringGuts.grow(_:)(v22);
      goto LABEL_42;
    }
LABEL_35:
    v30 = _StringGuts.nativeCapacity.getter(v3, v5);
    if ((v31 & 1) != 0)
      v32 = 0;
    else
      v32 = v30;
    if (v32 + 0x4000000000000000 < 0)
      goto LABEL_293;
    v33 = 2 * v32;
    if (v33 > v22)
      v22 = v33;
    goto LABEL_41;
  }
  if (!v29)
    goto LABEL_35;
LABEL_42:
  swift_bridgeObjectRelease_n((uint64_t)v8._object, 4);
  if (((uint64_t)v8._object & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v8._object);
    _StringGuts._foreignAppendInPlace(_:)(v8._countAndFlagsBits, (unint64_t)v8._object, 0, v330);
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2);
    goto LABEL_89;
  }
  if (v14)
  {
    swift_bridgeObjectRelease_n((uint64_t)v8._object, 2);
    v332 = v8._countAndFlagsBits;
    v333 = (uint64_t)v8._object & 0xFFFFFFFFFFFFFFLL;
    v34 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, ((unint64_t)v8._object >> 56) & 0xF, (uint64_t)&v332, ((unint64_t)v8._object >> 56) & 0xF);
    _StringGuts.appendInPlace(_:isASCII:)(v34, v35, ((uint64_t)v8._object & 0x4000000000000000) != 0);
    swift_bridgeObjectRelease((uint64_t)v8._object);
LABEL_89:
    v2 = (Class *)v331;
    goto LABEL_90;
  }
  if ((v8._countAndFlagsBits & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease((uint64_t)v8._object);
    v77 = (id)(((uint64_t)v8._object & 0xFFFFFFFFFFFFFFFLL) + 32);
    v78 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    v79 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    v2 = (Class *)v331;
  }
  else
  {
    v77 = _StringObject.sharedUTF8.getter(v8._countAndFlagsBits, (uint64_t)v8._object);
    v79 = v325;
    swift_bridgeObjectRelease((uint64_t)v8._object);
    if (v79 < (v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL))
      goto LABEL_300;
    v2 = (Class *)v331;
    v78 = v8._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  v80 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v78, (uint64_t)v77, v79);
  _StringGuts.appendInPlace(_:isASCII:)(v80, v81, v8._countAndFlagsBits < 0);
  swift_bridgeObjectRelease_n((uint64_t)v8._object, 2);
LABEL_90:
  TypeName = (uint8x16_t *)swift_getTypeName(v2, 0);
  if (v84 < 0)
    goto LABEL_270;
  v87 = v84;
  if (!v84)
  {
    countAndFlagsBits = 0;
    v0 = 0xE000000000000000;
LABEL_198:
    object = 0;
    goto LABEL_199;
  }
  v88 = (uint64_t *)TypeName;
  v89 = TypeName;
  if ((v84 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0)
      goto LABEL_112;
    v89 = TypeName + 1;
    while (v89 < (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFF0])
    {
      v90 = v89->i64[0];
      v91 = v89->i64[1];
      ++v89;
      if (((v91 | v90) & 0x8080808080808080) != 0)
        goto LABEL_112;
    }
  }
  if (v89 < (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v89->i64[0] & 0x8080808080808080) != 0)
      goto LABEL_112;
    v89 = (uint8x16_t *)((char *)v89 + 8);
  }
  if (v89 < (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v89->i32[0] & 0x80808080) != 0)
      goto LABEL_112;
    v89 = (uint8x16_t *)((char *)v89 + 4);
  }
  if (v89 >= (uint8x16_t *)&TypeName->i8[v84 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_108:
    if (v89 >= (uint8x16_t *)&TypeName->i8[v84] || (v89->i8[0] & 0x80000000) == 0)
    {
      if (v84 > 15)
      {
        v92 = 1;
LABEL_152:
        v0 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v84, v84, v92 & 1);
        object = 0;
        countAndFlagsBits = *(_QWORD *)(v0 + 24);
        goto LABEL_199;
      }
LABEL_162:
      v129 = v84 - 8;
      v130 = 8;
      if (v84 < 8)
        v130 = v84;
      if ((v130 & 0x8000000000000000) == 0)
      {
        if (v130 >= 8)
        {
          if (v130 >= 0x10)
          {
            v131 = v130 & 0xFFFFFFFFFFFFFFF0;
            v156 = vmovl_high_u8(*TypeName);
            v157 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v156.i8);
            v158 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            v159 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v158.i8);
            v160 = (int8x16_t)vmovl_high_u16(v156);
            v161 = (int8x8_t)vextq_s8(v160, v160, 8uLL).u64[0];
            v162 = (int8x16_t)vmovl_high_u16(v158);
            v163 = (int8x8_t)vextq_s8(v162, v162, 8uLL).u64[0];
            *(int8x8_t *)v162.i8 = vorr_s8(*(int8x8_t *)v162.i8, *(int8x8_t *)v160.i8);
            v164.i64[0] = v162.u32[0];
            v164.i64[1] = v162.u32[1];
            v165 = (int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1816ABC20);
            *(int8x8_t *)v160.i8 = vorr_s8(*(int8x8_t *)v159.i8, *(int8x8_t *)v157.i8);
            v164.i64[0] = v160.u32[0];
            v164.i64[1] = v160.u32[1];
            v166 = vorrq_s8((int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1816ABC10), v165);
            *(int8x8_t *)v160.i8 = vorr_s8(v163, v161);
            v164.i64[0] = v160.u32[0];
            v164.i64[1] = v160.u32[1];
            v167 = (int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1816ABC00);
            *(int8x8_t *)v157.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v159, v159, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v157, v157, 8uLL));
            v164.i64[0] = v157.u32[0];
            v164.i64[1] = v157.u32[1];
            v168 = vorrq_s8(v166, vorrq_s8((int8x16_t)vshlq_u64(v164, (uint64x2_t)xmmword_1816ABBF0), v167));
            countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v168.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v168, v168, 8uLL));
            if (v130 == (v130 & 0xFFFFFFFFFFFFFFF0))
              goto LABEL_179;
            v132 = 8 * v131;
            if ((v130 & 8) == 0)
              goto LABEL_177;
          }
          else
          {
            countAndFlagsBits = 0;
            v132 = 0;
            v131 = 0;
          }
          v133 = v131;
          v134 = vdupq_n_s64(v132);
          v131 = v130 & 0xFFFFFFFFFFFFFFF8;
          v132 = 8 * (v130 & 0xFFFFFFFFFFFFFFF8);
          v135 = 0uLL;
          v136 = (int8x16_t)(unint64_t)countAndFlagsBits;
          v137 = vaddq_s64(v134, (int64x2_t)xmmword_1816ABC00);
          v138 = vaddq_s64(v134, (int64x2_t)xmmword_1816ABC20);
          v139 = vaddq_s64(v134, (int64x2_t)xmmword_1816ABBF0);
          v140 = vaddq_s64(v134, (int64x2_t)xmmword_1816ABC10);
          v141 = (uint8x8_t *)&TypeName->i8[v133];
          v142 = (int8x16_t)vdupq_n_s64(0x38uLL);
          v143 = v133 - (v130 & 0xFFFFFFFFFFFFFFF8);
          v144 = vdupq_n_s64(0x40uLL);
          v145 = 0uLL;
          v146 = 0uLL;
          do
          {
            v147 = *v141++;
            v148 = vmovl_u8(v147);
            v149 = vmovl_high_u16(v148);
            v150.i64[0] = v149.u32[2];
            v150.i64[1] = v149.u32[3];
            v151 = v150;
            v150.i64[0] = v149.u32[0];
            v150.i64[1] = v149.u32[1];
            v152 = v150;
            v153 = vmovl_u16(*(uint16x4_t *)v148.i8);
            v150.i64[0] = v153.u32[2];
            v150.i64[1] = v153.u32[3];
            v154 = v150;
            v150.i64[0] = v153.u32[0];
            v150.i64[1] = v153.u32[1];
            v146 = vorrq_s8((int8x16_t)vshlq_u64(v151, (uint64x2_t)vandq_s8((int8x16_t)v137, v142)), v146);
            v145 = vorrq_s8((int8x16_t)vshlq_u64(v152, (uint64x2_t)vandq_s8((int8x16_t)v138, v142)), v145);
            v135 = vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)vandq_s8((int8x16_t)v139, v142)), v135);
            v136 = vorrq_s8((int8x16_t)vshlq_u64(v150, (uint64x2_t)vandq_s8((int8x16_t)v140, v142)), v136);
            v138 = vaddq_s64(v138, v144);
            v139 = vaddq_s64(v139, v144);
            v140 = vaddq_s64(v140, v144);
            v137 = vaddq_s64(v137, v144);
            v143 += 8;
          }
          while (v143);
          v155 = vorrq_s8(vorrq_s8(v136, v145), vorrq_s8(v135, v146));
          countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v155.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v155, v155, 8uLL));
          if (v130 == v131)
          {
LABEL_179:
            if (v84 < 9)
            {
              v173 = 0;
LABEL_195:
              v237 = 0xA000000000000000;
              if (((*(_QWORD *)&v173 | countAndFlagsBits) & 0x8080808080808080) == 0)
                v237 = 0xE000000000000000;
              v0 = v237 | (v84 << 56) | *(_QWORD *)&v173;
              goto LABEL_198;
            }
            if (v129 < 8)
            {
              v172 = 0;
              v173 = 0;
              v174 = 0;
LABEL_193:
              v234 = v84 - v172 - 8;
              v235 = &TypeName->u8[v172 + 8];
              do
              {
                v236 = *v235++;
                *(_QWORD *)&v173 |= (unint64_t)v236 << (v174 & 0x38);
                v174 += 8;
                --v234;
              }
              while (v234);
              goto LABEL_195;
            }
            if (v129 >= 0x10)
            {
              v198 = (uint8x16_t *)&TypeName->u64[1];
              v172 = v129 & 0xFFFFFFFFFFFFFFF0;
              v199 = (int64x2_t)xmmword_1816ABCA0;
              v200 = (int64x2_t)xmmword_1816ABCB0;
              v201 = (int64x2_t)xmmword_1816ABCC0;
              v202 = (int64x2_t)xmmword_1816ABCD0;
              v203 = (int64x2_t)xmmword_1816ABC00;
              v204 = (int64x2_t)xmmword_1816ABC20;
              v205 = (int8x16_t)vdupq_n_s64(0x38uLL);
              v206 = vdupq_n_s64(0x80uLL);
              v207 = (int64x2_t)xmmword_1816ABBF0;
              v174 = 8 * (v129 & 0xFFFFFFFFFFFFFFF0);
              v208 = 0uLL;
              v209 = 0uLL;
              v210 = (int64x2_t)xmmword_1816ABC10;
              v211 = v129 & 0xFFFFFFFFFFFFFFF0;
              v212 = 0uLL;
              v213 = 0uLL;
              v214 = 0uLL;
              v215 = 0uLL;
              v216 = 0uLL;
              v217 = 0uLL;
              do
              {
                v218 = *v198++;
                v219 = vmovl_u8(*(uint8x8_t *)v218.i8);
                v220 = vmovl_high_u16(v219);
                v221.i64[0] = v220.u32[2];
                v221.i64[1] = v220.u32[3];
                v222 = v221;
                v223 = vmovl_high_u8(v218);
                v224 = vmovl_u16(*(uint16x4_t *)v223.i8);
                v221.i64[0] = v224.u32[2];
                v221.i64[1] = v224.u32[3];
                v225 = v221;
                v221.i64[0] = v224.u32[0];
                v221.i64[1] = v224.u32[1];
                v226 = v221;
                v221.i64[0] = v220.u32[0];
                v221.i64[1] = v220.u32[1];
                v227 = v221;
                v228 = vmovl_u16(*(uint16x4_t *)v219.i8);
                v221.i64[0] = v228.u32[2];
                v221.i64[1] = v228.u32[3];
                v229 = v221;
                v230 = vmovl_high_u16(v223);
                v221.i64[0] = v230.u32[0];
                v221.i64[1] = v230.u32[1];
                v231 = v221;
                v221.i64[0] = v228.u32[0];
                v221.i64[1] = v228.u32[1];
                v232 = v221;
                v221.i64[0] = v230.u32[2];
                v221.i64[1] = v230.u32[3];
                v213 = vorrq_s8((int8x16_t)vshlq_u64(v222, (uint64x2_t)vandq_s8((int8x16_t)v203, v205)), v213);
                v215 = vorrq_s8((int8x16_t)vshlq_u64(v225, (uint64x2_t)vandq_s8((int8x16_t)v201, v205)), v215);
                v214 = vorrq_s8((int8x16_t)vshlq_u64(v226, (uint64x2_t)vandq_s8((int8x16_t)v202, v205)), v214);
                v212 = vorrq_s8((int8x16_t)vshlq_u64(v227, (uint64x2_t)vandq_s8((int8x16_t)v204, v205)), v212);
                v209 = vorrq_s8((int8x16_t)vshlq_u64(v229, (uint64x2_t)vandq_s8((int8x16_t)v207, v205)), v209);
                v216 = vorrq_s8((int8x16_t)vshlq_u64(v231, (uint64x2_t)vandq_s8((int8x16_t)v200, v205)), v216);
                v208 = vorrq_s8((int8x16_t)vshlq_u64(v232, (uint64x2_t)vandq_s8((int8x16_t)v210, v205)), v208);
                v217 = vorrq_s8((int8x16_t)vshlq_u64(v221, (uint64x2_t)vandq_s8((int8x16_t)v199, v205)), v217);
                v204 = vaddq_s64(v204, v206);
                v207 = vaddq_s64(v207, v206);
                v210 = vaddq_s64(v210, v206);
                v203 = vaddq_s64(v203, v206);
                v202 = vaddq_s64(v202, v206);
                v201 = vaddq_s64(v201, v206);
                v200 = vaddq_s64(v200, v206);
                v199 = vaddq_s64(v199, v206);
                v211 -= 16;
              }
              while (v211);
              v233 = vorrq_s8(vorrq_s8(vorrq_s8(v208, v214), vorrq_s8(v212, v216)), vorrq_s8(vorrq_s8(v209, v215), vorrq_s8(v213, v217)));
              v173 = vorr_s8(*(int8x8_t *)v233.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v233, v233, 8uLL));
              if (v129 == v172)
                goto LABEL_195;
              if ((v129 & 8) == 0)
                goto LABEL_193;
            }
            else
            {
              v173 = 0;
              v174 = 0;
              v172 = 0;
            }
            v175 = v172;
            v172 = v129 & 0xFFFFFFFFFFFFFFF8;
            v176 = vdupq_n_s64(v174);
            v174 = 8 * (v129 & 0xFFFFFFFFFFFFFFF8);
            v177 = (int8x16_t)(unint64_t)v173;
            v178 = 0uLL;
            v179 = vaddq_s64(v176, (int64x2_t)xmmword_1816ABC00);
            v180 = vaddq_s64(v176, (int64x2_t)xmmword_1816ABC20);
            v181 = vaddq_s64(v176, (int64x2_t)xmmword_1816ABBF0);
            v182 = vaddq_s64(v176, (int64x2_t)xmmword_1816ABC10);
            v183 = (uint8x8_t *)((char *)&TypeName->u64[1] + v175);
            v184 = (int8x16_t)vdupq_n_s64(0x38uLL);
            v185 = v175 - (v129 & 0xFFFFFFFFFFFFFFF8);
            v186 = vdupq_n_s64(0x40uLL);
            v187 = 0uLL;
            v188 = 0uLL;
            do
            {
              v189 = *v183++;
              v190 = vmovl_u8(v189);
              v191 = vmovl_high_u16(v190);
              v192.i64[0] = v191.u32[2];
              v192.i64[1] = v191.u32[3];
              v193 = v192;
              v192.i64[0] = v191.u32[0];
              v192.i64[1] = v191.u32[1];
              v194 = v192;
              v195 = vmovl_u16(*(uint16x4_t *)v190.i8);
              v192.i64[0] = v195.u32[2];
              v192.i64[1] = v195.u32[3];
              v196 = v192;
              v192.i64[0] = v195.u32[0];
              v192.i64[1] = v195.u32[1];
              v188 = vorrq_s8((int8x16_t)vshlq_u64(v193, (uint64x2_t)vandq_s8((int8x16_t)v179, v184)), v188);
              v187 = vorrq_s8((int8x16_t)vshlq_u64(v194, (uint64x2_t)vandq_s8((int8x16_t)v180, v184)), v187);
              v178 = vorrq_s8((int8x16_t)vshlq_u64(v196, (uint64x2_t)vandq_s8((int8x16_t)v181, v184)), v178);
              v177 = vorrq_s8((int8x16_t)vshlq_u64(v192, (uint64x2_t)vandq_s8((int8x16_t)v182, v184)), v177);
              v180 = vaddq_s64(v180, v186);
              v181 = vaddq_s64(v181, v186);
              v182 = vaddq_s64(v182, v186);
              v179 = vaddq_s64(v179, v186);
              v185 += 8;
            }
            while (v185);
            v197 = vorrq_s8(vorrq_s8(v177, v187), vorrq_s8(v178, v188));
            v173 = vorr_s8(*(int8x8_t *)v197.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v197, v197, 8uLL));
            if (v129 == v172)
              goto LABEL_195;
            goto LABEL_193;
          }
        }
        else
        {
          v131 = 0;
          countAndFlagsBits = 0;
          v132 = 0;
        }
LABEL_177:
        v169 = &TypeName->u8[v131];
        v170 = v130 - v131;
        do
        {
          v171 = *v169++;
          countAndFlagsBits |= (unint64_t)v171 << (v132 & 0x38);
          v132 += 8;
          --v170;
        }
        while (v170);
        goto LABEL_179;
      }
LABEL_294:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    goto LABEL_112;
  }
  if ((v89->i16[0] & 0x8080) == 0)
  {
    v89 = (uint8x16_t *)((char *)v89 + 2);
    goto LABEL_108;
  }
LABEL_112:
  v93 = 0;
  v94 = (uint8x16_t *)((char *)TypeName + v84);
  v92 = 1;
  v95 = TypeName;
  v96 = TypeName;
  while (1)
  {
    v99 = v96->i8[0];
    v96 = (uint8x16_t *)((char *)v96 + 1);
    v98 = v99;
    if (v99 < 0)
      break;
    v97 = 1;
LABEL_114:
    v93 += v97;
    v95 = v96;
    if (v96 == v94)
    {
      if (v84 > 15)
        goto LABEL_152;
      goto LABEL_162;
    }
  }
  if ((v98 + 62) > 0x32u)
    goto LABEL_153;
  if (v98 <= 0xDFu)
  {
    if (v96 == v94 || (v96->i8[0] & 0xC0) != 0x80)
      goto LABEL_153;
    v92 = 0;
    v96 = (uint8x16_t *)&v95->i16[1];
    v97 = 2;
    goto LABEL_114;
  }
  if (v98 == 224)
  {
    if (v96 == v94 || (v95->i8[1] & 0xE0) != 0xA0)
      goto LABEL_153;
    goto LABEL_132;
  }
  if (v98 <= 0xECu)
  {
LABEL_126:
    if (v96 == v94)
      goto LABEL_153;
    LOBYTE(v100) = v95->i8[1];
LABEL_131:
    if ((v100 & 0xC0) != 0x80)
      goto LABEL_153;
LABEL_132:
    if (&v95->i16[1] == (__int16 *)v94 || (v95->i8[2] & 0xC0) != 0x80)
      goto LABEL_153;
    v92 = 0;
    v96 = (uint8x16_t *)((char *)v95->i32 + 3);
    v97 = 3;
    goto LABEL_114;
  }
  if (v98 == 237)
  {
    if (v96 == v94)
      goto LABEL_153;
    v100 = v95->u8[1];
    if (v100 > 0x9F)
      goto LABEL_153;
    goto LABEL_131;
  }
  if (v98 <= 0xEFu)
    goto LABEL_126;
  if (v98 == 240)
  {
    if (v96 == v94 || (v95->i8[1] + 64) < 0xD0u)
      goto LABEL_153;
    goto LABEL_146;
  }
  if ((v98 + 15) <= 2u)
  {
    if (v96 == v94)
      goto LABEL_153;
    LOBYTE(v101) = v95->i8[1];
LABEL_145:
    if ((v101 & 0xC0) != 0x80)
      goto LABEL_153;
LABEL_146:
    if (&v95->i16[1] == (__int16 *)v94
      || (v95->i8[2] & 0xC0) != 0x80
      || (uint8x16_t *)((char *)v95->i32 + 3) == v94
      || (v95->i8[3] & 0xC0) != 0x80)
    {
      goto LABEL_153;
    }
    v92 = 0;
    v96 = (uint8x16_t *)((char *)v95->i64 + 4);
    v97 = 4;
    goto LABEL_114;
  }
  if (v96 != v94)
  {
    v101 = v95->u8[1];
    if (v101 <= 0x8F)
      goto LABEL_145;
  }
LABEL_153:
  v102 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v102);
  v103 = specialized Collection.subscript.getter(v93, (uint64_t)v88, v87);
  v108 = findInvalidRange #1 (_:) in validateUTF8(_:)(v103, v104, v105, v106);
  v332 = 0;
  v333 = 0xE000000000000000;
  if (__OFADD__(v87, 15))
  {
    __break(1u);
LABEL_293:
    __break(1u);
    goto LABEL_294;
  }
  v109 = v107;
  _StringGuts.reserveCapacity(_:)(v87 + 15);
  object = 0;
  while (1)
  {
    v110 = specialized Collection.subscript.getter(v108, (uint64_t)v88, v87);
    v114 = v332 & 0xFFFFFFFFFFFFLL;
    if ((v333 & 0x2000000000000000) != 0)
      v114 = HIBYTE(v333) & 0xF;
    v21 = __OFADD__(v114, v87);
    v115 = v114 + v87;
    if (v21)
    {
      __break(1u);
LABEL_269:
      __break(1u);
LABEL_270:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    v116 = v110;
    if (__OFADD__(v115, 3))
      goto LABEL_269;
    v117 = v111;
    v118 = v112;
    v119 = v113;
    _StringGuts.reserveCapacity(_:)(v115 + 3);
    v120 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v116, v117, v118, v119);
    _StringGuts.appendInPlace(_:isASCII:)(v120, v121, 0);
    v335 = 3;
    v336 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v336, &v335, &v332);
    v122 = specialized Collection.subscript.getter(v109, (uint64_t)v88, v87);
    v88 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v122, v123, v124, v125);
    v87 = v126;
    v127 = validateUTF8(_:)(v88, v126);
    if ((v85 & 1) == 0)
      break;
    v108 = v127;
    v109 = v128;
    if (!v87)
      goto LABEL_168;
  }
  _StringGuts.appendInPlace(_:isASCII:)((char *)v88, v87, 0);
LABEL_168:
  countAndFlagsBits = v332;
  v0 = v333;
LABEL_199:
  v3 = v334._countAndFlagsBits;
  v5 = (unint64_t)v334._object;
  v238 = ((unint64_t)v334._object >> 56) & 0xF;
  if (((uint64_t)v334._object & 0x2000000000000000) != 0)
    v12 = ((unint64_t)v334._object >> 56) & 0xF;
  else
    v12 = v334._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (!v12 && (v334._countAndFlagsBits & ~(uint64_t)v334._object & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease((uint64_t)v334._object);
    v334._countAndFlagsBits = countAndFlagsBits;
    v334._object = (void *)v0;
    goto LABEL_250;
  }
  v16 = v0 & 0x2000000000000000;
  v15 = HIBYTE(v0) & 0xF;
  if (((uint64_t)v334._object & 0x2000000000000000) != 0 && v16)
  {
    v239 = v238 + v15;
    if (v238 + v15 <= 0xF)
    {
      if (v15)
      {
        v272 = 0;
        v273 = 0;
        v274 = (unint64_t)v334._object;
        do
        {
          v275 = v238 + v273;
          v276 = v273 + 1;
          if (v273 >= 8)
            v277 = v0;
          else
            v277 = countAndFlagsBits;
          v278 = v277 >> (v272 & 0x38);
          v279 = (8 * v238 + v272) & 0x38;
          v280 = (-255 << v279) - 1;
          v281 = (unint64_t)v278 << v279;
          v282 = v281 | v280 & v274;
          v283 = v281 | v280 & v3;
          if (v275 < 8)
            v3 = v283;
          else
            v274 = v282;
          v272 += 8;
          v273 = v276;
        }
        while (v15 != v276);
      }
      else
      {
        v274 = (unint64_t)v334._object;
      }
      swift_bridgeObjectRelease((uint64_t)v334._object);
      swift_bridgeObjectRelease(v0);
      v287 = 0xA000000000000000;
      if (!(v3 & 0x8080808080808080 | v274 & 0x80808080808080))
        v287 = 0xE000000000000000;
      v334._countAndFlagsBits = v3;
      v334._object = (void *)(v287 & 0xFF00000000000000 | (v239 << 56) | v274 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_250;
    }
    v16 = 1;
  }
  v331 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v16)
    v14 = HIBYTE(v0) & 0xF;
  else
    v14 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  swift_bridgeObjectRetain_n(v0, 2, v85, v86);
  if ((v0 & 0x1000000000000000) == 0)
  {
    swift_bridgeObjectRetain_n(v0, 4, v19, v20);
    v240 = v14;
    if ((v5 & 0x1000000000000000) == 0)
      goto LABEL_213;
LABEL_280:
    v318 = String.UTF8View._foreignCount()();
    v241 = v318 + v240;
    if (!__OFADD__(v318, v240))
      goto LABEL_214;
LABEL_282:
    __break(1u);
    goto LABEL_283;
  }
LABEL_277:
  swift_bridgeObjectRetain_n(v0, 5, v19, v20);
  v314._rawBits = 1;
  v315._rawBits = (v14 << 16) | 1;
  v316._rawBits = _StringGuts.validateScalarRange(_:)(v314, v315, countAndFlagsBits, v0);
  if (v316._rawBits < 0x10000)
    v316._rawBits |= 3;
  v240 = specialized Collection.count.getter(v316, v317, countAndFlagsBits, v0);
  swift_bridgeObjectRelease(v0);
  if ((v5 & 0x1000000000000000) != 0)
    goto LABEL_280;
LABEL_213:
  v21 = __OFADD__(v12, v240);
  v241 = v12 + v240;
  if (v21)
    goto LABEL_282;
LABEL_214:
  if ((v3 & ~v5 & 0x2000000000000000) == 0 || !swift_isUniquelyReferenced_nonNull_native(v5 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v241 > 15)
      goto LABEL_226;
LABEL_221:
    swift_bridgeObjectRelease_n(v0, 5);
    swift_bridgeObjectRetain(v5, v245, v246, v247);
    v248 = _StringGuts._convertedToSmall()(v3, v5);
    v250 = v249;
    swift_bridgeObjectRelease(v5);
    v251._rawBits = (v14 << 16) | 1;
    v252._rawBits = 1;
    v253._rawBits = _StringGuts.validateScalarRange(_:)(v252, v251, countAndFlagsBits, v0);
    if (v253._rawBits < 0x10000)
      v253._rawBits |= 3;
    v255 = specialized String.init(_:)(v253, v254, countAndFlagsBits, v0);
    v257 = v256;
    swift_bridgeObjectRelease(v0);
    v258 = _StringGuts._convertedToSmall()(v255, v257);
    v260 = v259;
    swift_bridgeObjectRelease(v257);
    v261 = specialized _SmallString.init(_:appending:)(v248, v250, v258, v260);
    if ((v263 & 1) == 0)
    {
      v264 = v261;
      v265 = v262;
      swift_bridgeObjectRelease(v5);
      swift_bridgeObjectRelease(v0);
      v334._countAndFlagsBits = v264;
      v334._object = v265;
      goto LABEL_250;
    }
    goto LABEL_301;
  }
  v242 = _StringGuts.nativeUnusedCapacity.getter(v3, v5);
  if ((v243 & 1) != 0)
  {
LABEL_302:
    v327 = 258;
LABEL_303:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v327, 0);
  }
  v244 = (v5 >> 61) & 1;
  if (v242 < v240)
    LODWORD(v244) = 1;
  if (v241 <= 15 && (_DWORD)v244)
    goto LABEL_221;
LABEL_226:
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v241, v240);
  swift_bridgeObjectRelease_n(v0, 4);
  if ((v0 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v0);
    _StringGuts._foreignAppendInPlace(_:)(countAndFlagsBits, v0, 0, v14);
    goto LABEL_245;
  }
  if (!v16)
  {
    if ((countAndFlagsBits & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v0);
      v270 = (Swift::String *)((v0 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v284 = v331;
      v268 = v331;
      goto LABEL_244;
    }
    v270 = (Swift::String *)_StringObject.sharedUTF8.getter(countAndFlagsBits, v0);
    v268 = v326;
    swift_bridgeObjectRelease(v0);
    if (v268 >= v331)
      goto LABEL_308;
LABEL_300:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
  }
  swift_bridgeObjectRelease_n(v0, 2);
  v268 = (v0 >> 62) & 1;
  v332 = countAndFlagsBits;
  v333 = v0 & 0xFFFFFFFFFFFFFFLL;
  v269 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v15, (uint64_t)&v332, v15);
  v270 = &v334;
  _StringGuts.appendInPlace(_:isASCII:)(v269, v271, (v0 & 0x4000000000000000) != 0);
  if (object)
    goto LABEL_306;
  swift_bridgeObjectRelease(v0);
  while (1)
  {
LABEL_250:
    v5 = v334._countAndFlagsBits;
    v0 = (unint64_t)v334._object;
    countAndFlagsBits = ((unint64_t)v334._object >> 56) & 0xF;
    v268 = v334._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v334._object & 0x2000000000000000) != 0)
      v288 = ((unint64_t)v334._object >> 56) & 0xF;
    else
      v288 = v334._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v288 && (v334._countAndFlagsBits & ~(uint64_t)v334._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v334._object);
      return 0;
    }
    if (((uint64_t)v334._object & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease((uint64_t)v334._object);
      swift_bridgeObjectRelease(0xE000000000000000);
      return v5;
    }
    swift_bridgeObjectRetain_n(0xE000000000000000, 6, v266, v267);
    if ((v0 & 0x1000000000000000) == 0)
      break;
LABEL_283:
    v268 = String.UTF8View._foreignCount()();
    if ((v5 & ~v0 & 0x2000000000000000) != 0)
      goto LABEL_258;
LABEL_284:
    if (v268 <= 15)
      goto LABEL_262;
LABEL_285:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v268, 0);
    swift_bridgeObjectRelease_n(0xE000000000000000, 6);
    v332 = 0;
    v333 = 0;
    v319 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v332, 0);
    v270 = &v334;
    _StringGuts.appendInPlace(_:isASCII:)(v319, v320, 1);
    if (!object)
    {
      swift_bridgeObjectRelease(0xE000000000000000);
      return v334._countAndFlagsBits;
    }
LABEL_306:
    swift_errorRelease(object);
    __break(1u);
    do
    {
      swift_errorRelease(object);
      swift_bridgeObjectRelease(v0);
      __break(1u);
LABEL_308:
      v284 = v331;
LABEL_244:
      v285 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v284, (uint64_t)v270, v268);
      v270 = &v334;
      _StringGuts.appendInPlace(_:isASCII:)(v285, v286, countAndFlagsBits < 0);
    }
    while (object);
LABEL_245:
    swift_bridgeObjectRelease_n(v0, 2);
  }
  if ((v5 & ~v0 & 0x2000000000000000) == 0)
    goto LABEL_284;
LABEL_258:
  if (!swift_isUniquelyReferenced_nonNull_native(v0 & 0xFFFFFFFFFFFFFFFLL))
    goto LABEL_284;
  v289 = _StringGuts.nativeUnusedCapacity.getter(v5, v0);
  if ((v290 & 1) != 0)
    goto LABEL_302;
  if (v268 > 15 || (v289 & 0x8000000000000000) == 0)
    goto LABEL_285;
LABEL_262:
  swift_bridgeObjectRelease_n(0xE000000000000000, 5);
  swift_bridgeObjectRetain(v0, v291, v292, v293);
  v294 = _StringGuts._convertedToSmall()(v5, v0);
  v296 = v295;
  swift_bridgeObjectRelease(v0);
  v297._rawBits = 1;
  v298._rawBits = 1;
  v299._rawBits = _StringGuts.validateScalarRange(_:)(v297, v298, 0, 0xE000000000000000);
  if (v299._rawBits < 0x10000)
    v299._rawBits |= 3;
  v301 = specialized String.init(_:)(v299, v300, 0, 0xE000000000000000);
  v303 = v302;
  swift_bridgeObjectRelease(0xE000000000000000);
  v304 = _StringGuts._convertedToSmall()(v301, v303);
  v306 = v305;
  swift_bridgeObjectRelease(v303);
  v307 = specialized _SmallString.init(_:appending:)(v294, v296, v304, v306);
  if ((v308 & 1) != 0)
  {
LABEL_301:
    v327 = 266;
    goto LABEL_303;
  }
  v5 = v307;
  swift_bridgeObjectRelease(v0);
  swift_bridgeObjectRelease(0xE000000000000000);
  return v5;
}

uint64_t Mirror.customMirror.getter@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 *v4;
  __int128 v6;
  __int128 v8;
  _OWORD v9[2];

  v6 = v4[1];
  v8 = *v4;
  v9[0] = v6;
  *(_OWORD *)((char *)v9 + 9) = *(__int128 *)((char *)v4 + 25);
  outlined retain of Mirror((uint64_t)&v8, a1, a2, a3);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)(&v8, (uint64_t)&_swiftEmptyArrayStorage, 8, 0, 0, a4);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance Mirror@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, char *a3@<X3>, uint64_t a4@<X8>)
{
  __int128 *v4;
  __int128 v6;
  __int128 v8;
  _OWORD v9[2];

  v6 = v4[1];
  v8 = *v4;
  v9[0] = v6;
  *(_OWORD *)((char *)v9 + 9) = *(__int128 *)((char *)v4 + 25);
  outlined retain of Mirror((uint64_t)&v8, a1, a2, a3);
  return specialized Mirror.init<A>(_:children:displayStyle:ancestorRepresentation:)(&v8, (uint64_t)&_swiftEmptyArrayStorage, 8, 0, 0, a4);
}

uint64_t static CommandLine._argc.getter()
{
  return static CommandLine._argc;
}

uint64_t static CommandLine._argc.setter(uint64_t result)
{
  static CommandLine._argc = result;
  return result;
}

uint64_t (*static CommandLine._argc.modify())()
{
  return EnumeratedSequence._base.modify;
}

char **one-time initialization function for _unsafeArgv()
{
  char **result;

  result = _swift_stdlib_getUnsafeArgvArgc(&static CommandLine._argc);
  static CommandLine._unsafeArgv = (uint64_t)result;
  return result;
}

void static CommandLine._unsafeArgv.setter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1)
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  static CommandLine._unsafeArgv = a1;
}

uint64_t (*static CommandLine._unsafeArgv.modify(uint64_t a1, uint64_t a2, void *a3))()
{
  if (one-time initialization token for _unsafeArgv != -1)
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  return EnumeratedSequence._base.modify;
}

uint64_t static CommandLine.argc.getter(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result;

  if (one-time initialization token for _unsafeArgv != -1)
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  result = 0;
  while (*(_QWORD *)(static CommandLine._unsafeArgv + 8 * result))
  {
    if (++result == 0x80000000)
    {
      __break(1u);
      return result;
    }
  }
  return result;
}

_DWORD *static Int32.+= infix(_:_:)(_DWORD *result, int a2)
{
  if (__OFADD__(*result, a2))
    __break(1u);
  else
    *result += a2;
  return result;
}

uint64_t static CommandLine._unsafeArgv.getter(uint64_t a1, uint64_t a2, void *a3)
{
  if (one-time initialization token for _unsafeArgv != -1)
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  return static CommandLine._unsafeArgv;
}

__objc2_class **one-time initialization function for _arguments(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3;
  __objc2_class **result;

  if (one-time initialization token for _unsafeArgv != -1)
    swift_once(&one-time initialization token for _unsafeArgv, (dispatch_function_t)one-time initialization function for _unsafeArgv, a3);
  v3 = 0;
  while (*(_QWORD *)(static CommandLine._unsafeArgv + 8 * v3))
  {
    if (++v3 == 0x80000000)
    {
      __break(1u);
      break;
    }
  }
  result = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg549_ss11CommandLineO10_argumentsSaySSGvpZfiSSSiXEfU_Tf1cn_n(0, v3);
  static CommandLine._arguments = (uint64_t)result;
  return result;
}

unint64_t static CommandLine.arguments.getter(uint64_t a1, uint64_t a2, void *a3, char *a4)
{
  if (one-time initialization token for _arguments != -1)
    swift_once(&one-time initialization token for _arguments, (dispatch_function_t)one-time initialization function for _arguments, a3);
  return swift_bridgeObjectRetain(static CommandLine._arguments, a2, (uint64_t)a3, a4);
}

void static CommandLine.arguments.setter(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;

  if (one-time initialization token for _arguments != -1)
    swift_once(&one-time initialization token for _arguments, (dispatch_function_t)one-time initialization function for _arguments, a3);
  v4 = static CommandLine._arguments;
  static CommandLine._arguments = a1;
  swift_bridgeObjectRelease(v4);
}

void (*static CommandLine.arguments.modify(_QWORD *a1, uint64_t a2, void *a3, char *a4))(uint64_t *a1)
{
  unint64_t v5;

  if (one-time initialization token for _arguments != -1)
    swift_once(&one-time initialization token for _arguments, (dispatch_function_t)one-time initialization function for _arguments, a3);
  v5 = static CommandLine._arguments;
  *a1 = static CommandLine._arguments;
  swift_bridgeObjectRetain(v5, a2, (uint64_t)a3, a4);
  return static CommandLine.arguments.modify;
}

void static CommandLine.arguments.modify(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *a1;
  v2 = static CommandLine._arguments;
  static CommandLine._arguments = v1;
  swift_bridgeObjectRelease(v2);
}

void _SliceBuffer.owner.setter(void *a1)
{
  id *v1;

  swift_unknownObjectRelease(*v1);
  *v1 = a1;
}

uint64_t (*_SliceBuffer.owner.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer.subscriptBaseAddress.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t _SliceBuffer.startIndex.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t _SliceBuffer.startIndex.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = result;
  return result;
}

uint64_t (*_SliceBuffer.startIndex.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer.endIndexAndFlags.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4;
}

uint64_t _SliceBuffer.endIndexAndFlags.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = result;
  return result;
}

uint64_t (*_SliceBuffer.endIndexAndFlags.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t _SliceBuffer._hasNativeBuffer.getter(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  return a4 & 1;
}

__objc2_class **_SliceBuffer.nativeBuffer.getter(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  id v6;
  __objc2_class **result;

  v2 = type metadata accessor for __ContiguousArrayStorageBase();
  v6 = swift_unknownObjectRetain(a1, v3, v4, v5);
  result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v6, v2);
  if (!result)
  {
    swift_unknownObjectRelease(a1);
    return &_swiftEmptyArrayStorage;
  }
  return result;
}

Swift::Bool __swiftcall _SliceBuffer.isUniquelyReferenced()()
{
  unint64_t *v0;

  return swift_isUniquelyReferenced_nonNull(*v0);
}

uint64_t _SliceBuffer.endIndex.setter(uint64_t result)
{
  uint64_t v1;

  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  *(_QWORD *)(v1 + 24) = *(_QWORD *)(v1 + 24) & 1 | (2 * result);
  return result;
}

__objc2_class **_SliceBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:)(uint64_t a1, uint64_t a2)
{
  unint64_t *v2;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  id v14;
  __objc2_class **v15;
  uint64_t v16;
  __objc2_class *v17;
  int64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  __objc2_class **result;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  id v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int64_t v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t WitnessTable;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  __objc2_class **v47;

  if (!swift_isUniquelyReferenced_nonNull(*v2))
    return 0;
  v6 = v2[2];
  v5 = v2[3];
  v7 = (v5 >> 1) - v6;
  if (__OFSUB__(v5 >> 1, v6))
  {
    __break(1u);
    goto LABEL_23;
  }
  v8 = v2[1];
  if ((v5 & 1) == 0)
    goto LABEL_8;
  v9 = (void *)*v2;
  v10 = type metadata accessor for __ContiguousArrayStorageBase();
  v14 = swift_unknownObjectRetain(v9, v11, v12, v13);
  v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v14, v10);
  if (!v15)
  {
    swift_unknownObjectRelease(v9);
    v15 = &_swiftEmptyArrayStorage;
  }
  v16 = *(_QWORD *)(*(_QWORD *)(a2 + 16) - 8);
  v17 = v15[2];
  if ((__objc2_class **)(v8 + *(_QWORD *)(v16 + 72) * v6 + *(_QWORD *)(v16 + 72) * v7) != (__objc2_class **)((char *)v15 + ((*(unsigned __int8 *)(v16 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80)) + *(_QWORD *)(v16 + 72) * (_QWORD)v17))
  {
    swift_release((uint64_t)v15);
LABEL_8:
    v18 = v7;
    goto LABEL_10;
  }
  v19 = (unint64_t)v15[3];
  swift_release((uint64_t)v15);
  v20 = (v19 >> 1) - (_QWORD)v17;
  v21 = __OFADD__(v7, v20);
  v18 = v7 + v20;
  if (v21)
  {
    __break(1u);
    goto LABEL_27;
  }
LABEL_10:
  if (v18 < a1)
    return 0;
  v23 = (void *)*v2;
  v24 = type metadata accessor for __ContiguousArrayStorageBase();
  v28 = swift_unknownObjectRetain(v23, v25, v26, v27);
  result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v28, v24);
  if (!result)
  {
    swift_unknownObjectRelease(v23);
    result = &_swiftEmptyArrayStorage;
  }
  v47 = result;
  v31 = *(_QWORD *)(a2 + 16);
  v32 = *(_QWORD *)(v31 - 8);
  v33 = *(_QWORD *)(v32 + 72);
  if (!v33)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  v34 = v8
      + v33 * v6
      - ((_QWORD)result
       + ((*(unsigned __int8 *)(v32 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v32 + 80)));
  if (v33 == -1 && v34 == 0x8000000000000000)
LABEL_27:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  v36 = v34 / v33;
  v37 = v7 + v36;
  if (__OFADD__(v7, v36))
  {
    __break(1u);
    goto LABEL_25;
  }
  v24 = (uint64_t)result[2];
  if (v37 < v24)
  {
LABEL_25:
    v38 = type metadata accessor for _ContiguousArrayBuffer(0, v31, v29, v30);
    v41 = type metadata accessor for EmptyCollection(0, v31, v39, v40);
    WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, v38, v42);
    v45 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, v41, v44);
    _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(v37, v24, 0, v46, v38, v41, WitnessTable, v45);
    return v47;
  }
  return result;
}

char *_SliceBuffer._copyContents(initializing:)@<X0>(char *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X6>, _QWORD *a8@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v20;

  if (a2 < 1)
    goto LABEL_15;
  if (__OFSUB__(a6 >> 1, a5))
  {
    __break(1u);
    goto LABEL_18;
  }
  if ((uint64_t)((a6 >> 1) - a5) >= a2)
    v13 = a2;
  else
    v13 = (a6 >> 1) - a5;
  if (!result)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/SliceBuffer.swift", 23, 2, 0x112uLL, 0);
  if (v13 < 0)
LABEL_18:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  v14 = *(_QWORD *)(*(_QWORD *)(a7 - 8) + 72);
  v15 = (char *)(a4 + v14 * a5);
  v16 = v14 * v13;
  v17 = &result[v16];
  v18 = &v15[v16];
  if (v15 < v17 && v18 > result)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  result = swift_arrayInitWithCopy(result, v15, v13, a7);
  v20 = a5 + v13;
  if (__OFADD__(a5, v13))
  {
    __break(1u);
LABEL_15:
    v13 = 0;
    v20 = a5;
  }
  *a8 = a3;
  a8[1] = a4;
  a8[2] = a5;
  a8[3] = a6;
  a8[4] = v20;
  a8[5] = v13;
  return result;
}

uint64_t key path getter for _SliceBuffer.count : <A>_SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;

  result = _SliceBuffer.count.getter(a1, a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  *a3 = result;
  return result;
}

__objc2_class **key path setter for _SliceBuffer.count : <A>_SliceBuffer<A>(__objc2_class ***a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __objc2_class **v4;

  v4 = *a1;
  type metadata accessor for _SliceBuffer(0, *(_QWORD *)(a4 + a3 - 8), a3, a4);
  return _SliceBuffer.count.setter(v4);
}

__objc2_class **(*_SliceBuffer.count.modify(__objc2_class **(*result)(__objc2_class **result, char a2), uint64_t a2))(__objc2_class **result, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;

  *((_QWORD *)result + 1) = a2;
  *((_QWORD *)result + 2) = v2;
  v3 = *(_QWORD *)(v2 + 16);
  v4 = *(_QWORD *)(v2 + 24) >> 1;
  v5 = __OFSUB__(v4, v3);
  v6 = v4 - v3;
  if (v5)
  {
    __break(1u);
  }
  else
  {
    *(_QWORD *)result = v6;
    return _SliceBuffer.count.modify;
  }
  return result;
}

__objc2_class **_SliceBuffer.count.modify(__objc2_class **result, char a2)
{
  __objc2_class *v2;
  void *cache;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  char *v7;
  __objc2_class *isa;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  id v13;
  __objc2_class *v14;
  __objc2_class *v15;

  v2 = result[2];
  if ((a2 & 1) != 0)
    return _SliceBuffer.count.setter(&(*result)->isa);
  cache = v2->cache;
  v4 = (unint64_t)v2->vtable >> 1;
  v5 = __OFSUB__(v4, cache);
  v6 = v4 - (_QWORD)cache;
  if (v5)
  {
    __break(1u);
    goto LABEL_13;
  }
  v7 = (char *)*result - v6;
  if (__OFSUB__(*result, v6))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if (!v7)
    return result;
  isa = v2->isa;
  v9 = type metadata accessor for __ContiguousArrayStorageBase();
  v13 = swift_unknownObjectRetain(isa, v10, v11, v12);
  result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v13, v9);
  if (!result)
  {
    swift_unknownObjectRelease(isa);
    result = &_swiftEmptyArrayStorage;
  }
  v14 = result[2];
  v5 = __OFADD__(v14, v7);
  v15 = (__objc2_class *)&v7[(_QWORD)v14];
  if (v5)
    goto LABEL_14;
  result[2] = v15;
  swift_release((uint64_t)result);
  result = (__objc2_class **)&v7[v4];
  if (__OFADD__(v4, v7))
  {
LABEL_15:
    __break(1u);
    return result;
  }
  return (__objc2_class **)_SliceBuffer.endIndex.setter((uint64_t)result);
}

uint64_t _SliceBuffer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 16))(a4, a2 + *(_QWORD *)(*(_QWORD *)(a3 - 8) + 72) * a1, a3);
}

uint64_t key path getter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return _SliceBuffer.subscript.getter(*a2, *(_QWORD *)(a1 + 8), *(uint64_t *)((char *)a2 + a3 - 8), a4);
}

uint64_t key path setter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  v5 = *(_QWORD *)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v15 - v6;
  v9 = *v8;
  (*(void (**)(char *))(v10 + 16))((char *)&v15 - v6);
  return _SliceBuffer.subscript.setter((uint64_t)v7, v9, v11, *(_QWORD *)(a2 + 8), v12, v13, v5);
}

uint64_t _SliceBuffer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a7 - 8) + 40))(a4 + *(_QWORD *)(*(_QWORD *)(a7 - 8) + 72) * a2, a1, a7);
}

void (*_SliceBuffer.subscript.modify(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7))(uint64_t a1)
{
  _QWORD *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;

  v11 = malloc(0x30uLL);
  *a1 = v11;
  *v11 = a2;
  v11[1] = a4;
  v12 = *(_QWORD *)(a7 - 8);
  v11[2] = a7;
  v11[3] = v12;
  v13 = malloc(*(_QWORD *)(v12 + 64));
  v14 = *(_QWORD *)(v12 + 72);
  v11[4] = v13;
  v11[5] = v14;
  (*(void (**)(void))(v12 + 16))();
  return _SliceBuffer.subscript.modify;
}

void _SliceBuffer.subscript.modify(uint64_t a1)
{
  void *v1;
  void *v2;

  v1 = *(void **)a1;
  v2 = *(void **)(*(_QWORD *)a1 + 32);
  (*(void (**)(_QWORD, void *, _QWORD))(*(_QWORD *)(*(_QWORD *)a1 + 24) + 40))(*(_QWORD *)(*(_QWORD *)a1 + 8) + **(_QWORD **)a1 * *(_QWORD *)(*(_QWORD *)a1 + 40), v2, *(_QWORD *)(*(_QWORD *)a1 + 16));
  free(v2);
  free(v1);
}

id key path getter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;

  v4 = (void *)specialized _SliceBuffer.subscript.getter(*a2, a2[1], *a1);
  *a3 = v4;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

void key path setter for _SliceBuffer.subscript(_:) : <A>_SliceBuffer<A>A(void **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;

  v4 = *a1;
  type metadata accessor for _SliceBuffer(0, *(_QWORD *)(a4 + a3 - 8), a3, a4);
  swift_unknownObjectRetain(v4, v5, v6, v7);
  specialized _SliceBuffer.subscript.setter();
}

void _SliceBuffer.subscript.setter()
{
  specialized _SliceBuffer.subscript.setter();
}

void (*_SliceBuffer.subscript.modify(_QWORD *a1, uint64_t a2, uint64_t a3, char *a4))(id *a1, char a2)
{
  uint64_t v4;
  uint64_t v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *(_QWORD *)(v4 + 8);
  v9 = swift_unknownObjectRetain(*(id *)v4, a2, a3, a4);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v9, v8, a2, a3);
  *a1 = v10;
  a1[1] = v11;
  a1[2] = v12;
  a1[3] = v13;
  return _SliceBuffer.subscript.modify;
}

void _SliceBuffer.subscript.modify(id *a1, char a2)
{
  _ArrayBuffer.subscript.modify(a1, a2, "Swift/SliceBuffer.swift", 23, 0x198uLL);
}

void _ArrayBuffer.subscript.modify(id *a1, char a2, const char *a3, uint64_t a4, unint64_t a5)
{
  if ((a2 & 1) == 0)
    swift_unknownObjectRelease(*a1);
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0x6C706D6920746F6ELL, 0xEF6465746E656D65, a3, a4, 2, a5, 0);
}

unint64_t key path getter for _SliceBuffer.endIndex : <A>_SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t result;

  result = _SliceBuffer.endIndex.getter(a1, a2, a3, *(_QWORD *)(a1 + 24));
  *a4 = result;
  return result;
}

uint64_t key path setter for _SliceBuffer.endIndex : <A>_SliceBuffer<A>(uint64_t *a1)
{
  return _SliceBuffer.endIndex.setter(*a1);
}

uint64_t (*_SliceBuffer.endIndex.modify(_QWORD *a1, uint64_t a2))(uint64_t *a1, char a2)
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 24) >> 1;
  return _SliceBuffer.endIndex.modify;
}

uint64_t _SliceBuffer.endIndex.modify(uint64_t *a1, char a2)
{
  uint64_t result;

  result = *a1;
  if ((a2 & 1) != 0)
    return _SliceBuffer.endIndex.setter(result);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  *(_QWORD *)(a1[2] + 24) = *(_QWORD *)(a1[2] + 24) & 1 | (2 * result);
  return result;
}

uint64_t _SliceBuffer.withUnsafeMutableBufferPointer<A>(_:)(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v4 = v3[2];
  v5 = v3[3] >> 1;
  if (__OFSUB__(v5, v4))
  {
    __break(1u);
LABEL_5:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  if (v5 - v4 < 0)
    goto LABEL_5;
  return a1(v3[1] + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 72) * v4);
}

double protocol witness for _ArrayBufferProtocol.init() in conformance _SliceBuffer<A>@<D0>(uint64_t a1@<X8>)
{
  uint64_t v2;
  double result;

  _SliceBuffer.init()();
  *(_QWORD *)a1 = &_swiftEmptyArrayStorage;
  *(_QWORD *)(a1 + 8) = v2;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_1816ABBD0;
  return result;
}

uint64_t protocol witness for _ArrayBufferProtocol.init(_buffer:shiftedToStartIndex:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = _SliceBuffer.init(_buffer:shiftedToStartIndex:)(a1, a2);
  *a3 = result;
  a3[1] = v5;
  a3[2] = v6;
  a3[3] = v7;
  return result;
}

char *protocol witness for _ArrayBufferProtocol._copyContents(subRange:initializing:) in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;

  return _SliceBuffer._copyContents(subRange:initializing:)(a1, a2, a3, *(void **)v7, *(_QWORD *)(v7 + 8), a6, a7, *(_QWORD *)(a4 + 16));
}

__objc2_class **protocol witness for _ArrayBufferProtocol.requestNativeBuffer() in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  return _SliceBuffer.requestNativeBuffer()(*(void **)v2, a2, *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24));
}

uint64_t protocol witness for _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:) in conformance _SliceBuffer<A>(uint64_t a1, char *a2, uint64_t a3, _QWORD *a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  return _SliceBuffer.replaceSubrange<A>(_:with:elementsOf:)(a1, a2, a3, a4, a7, a5, a6);
}

id protocol witness for _ArrayBufferProtocol.subscript.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  v3 = (void *)specialized _SliceBuffer.subscript.getter(a1, a2, *v2);
  return swift_unknownObjectRetain(v3, v4, v5, v6);
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:) in conformance _SliceBuffer<A>(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  return _SliceBuffer.withUnsafeBufferPointer<A>(_:)(a1, a2, a3, *(_QWORD *)(v4 + 8), *(_QWORD *)(v4 + 16), *(_QWORD *)(v4 + 24), *(_QWORD *)(a4 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:) in conformance _SliceBuffer<A>(uint64_t (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _SliceBuffer.withUnsafeMutableBufferPointer<A>(_:)(a1, a2, a4);
}

__objc2_class **(*protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>(__objc2_class **(*result)(__objc2_class **result, char a2), uint64_t a2))(__objc2_class **result, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;

  *((_QWORD *)result + 1) = v2;
  *((_QWORD *)result + 2) = a2;
  v3 = *(_QWORD *)(v2 + 16);
  v4 = *(_QWORD *)(v2 + 24) >> 1;
  v5 = __OFSUB__(v4, v3);
  v6 = v4 - v3;
  if (v5)
  {
    __break(1u);
  }
  else
  {
    *(_QWORD *)result = v6;
    return protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>;
  }
  return result;
}

__objc2_class **protocol witness for _ArrayBufferProtocol.count.modify in conformance _SliceBuffer<A>(__objc2_class **result, char a2)
{
  __objc2_class *v2;
  void *cache;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  char *v7;
  __objc2_class *isa;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  id v13;
  __objc2_class *v14;
  __objc2_class *v15;

  if ((a2 & 1) != 0)
    return _SliceBuffer.count.setter(&(*result)->isa);
  v2 = result[1];
  cache = v2->cache;
  v4 = (unint64_t)v2->vtable >> 1;
  v5 = __OFSUB__(v4, cache);
  v6 = v4 - (_QWORD)cache;
  if (v5)
  {
    __break(1u);
    goto LABEL_13;
  }
  v7 = (char *)*result - v6;
  if (__OFSUB__(*result, v6))
  {
LABEL_13:
    __break(1u);
LABEL_14:
    __break(1u);
    goto LABEL_15;
  }
  if (!v7)
    return result;
  isa = v2->isa;
  v9 = type metadata accessor for __ContiguousArrayStorageBase();
  v13 = swift_unknownObjectRetain(isa, v10, v11, v12);
  result = (__objc2_class **)swift_dynamicCastClass((uint64_t)v13, v9);
  if (!result)
  {
    swift_unknownObjectRelease(isa);
    result = &_swiftEmptyArrayStorage;
  }
  v14 = result[2];
  v5 = __OFADD__(v14, v7);
  v15 = (__objc2_class *)&v7[(_QWORD)v14];
  if (v5)
    goto LABEL_14;
  result[2] = v15;
  swift_release((uint64_t)result);
  result = (__objc2_class **)&v7[v4];
  if (__OFADD__(v4, v7))
  {
LABEL_15:
    __break(1u);
    return result;
  }
  return (__objc2_class **)_SliceBuffer.endIndex.setter((uint64_t)result);
}

uint64_t protocol witness for _ArrayBufferProtocol.capacity.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>(a1, a2, _SliceBuffer.capacity.getter);
}

id protocol witness for _ArrayBufferProtocol.owner.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  id *v4;

  return swift_unknownObjectRetain(*v4, a2, a3, a4);
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddress.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  return _SliceBuffer.firstElementAddress.getter(a1, *(_QWORD *)(v4 + 8), *(_QWORD *)(v4 + 16), a4, *(_QWORD *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.firstElementAddressIfContiguous.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  return _SliceBuffer.firstElementAddressIfContiguous.getter(a1, *(_QWORD *)(v4 + 8), *(_QWORD *)(v4 + 16), a4, *(_QWORD *)(a1 + 16));
}

uint64_t protocol witness for _ArrayBufferProtocol.subscriptBaseAddress.getter in conformance _SliceBuffer<A>()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 8);
}

uint64_t protocol witness for _ArrayBufferProtocol.identity.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  return ArraySlice._baseAddress.getter(a1, *(_QWORD *)(v4 + 8), *(_QWORD *)(v4 + 16), a4, *(_QWORD *)(a1 + 16));
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;

  return _SliceBuffer.subscript.setter(a1, *a2, a3, *(_QWORD *)(v6 + 8), a5, a6, *(_QWORD *)(a3 + 16));
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(_QWORD *a1, uint64_t *a2, uint64_t a3))(_QWORD **a1)
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;

  v7 = malloc(0x30uLL);
  *a1 = v7;
  v8 = *(_QWORD *)(a3 + 16);
  *v7 = v8;
  v9 = *(_QWORD *)(v8 - 8);
  v7[1] = v9;
  v10 = malloc(*(_QWORD *)(v9 + 64));
  v11 = *a2;
  v7[2] = v10;
  v7[3] = v11;
  v12 = *(_QWORD *)(v9 + 72);
  v7[4] = *(_QWORD *)(v3 + 8);
  v7[5] = v12;
  (*(void (**)(void))(v9 + 16))();
  return protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(_QWORD **a1)
{
  _QWORD *v1;
  void *v2;

  v1 = *a1;
  v2 = (void *)(*a1)[2];
  (*(void (**)(_QWORD, void *, _QWORD))((*a1)[1] + 40))((*a1)[4] + (*a1)[3] * (*a1)[5], v2, **a1);
  free(v2);
  free(v1);
}

void protocol witness for MutableCollection.subscript.setter in conformance _SliceBuffer<A>()
{
  specialized _SliceBuffer.subscript.setter();
}

void (*protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(_QWORD *a1, uint64_t *a2, uint64_t a3, char *a4))(id *a1, char a2)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v6 = *a2;
  v7 = a2[1];
  v8 = *(_QWORD *)(v4 + 8);
  v9 = swift_unknownObjectRetain(*(id *)v4, (uint64_t)a2, a3, a4);
  _SliceBuffer.init(owner:subscriptBaseAddress:indices:hasNativeBuffer:)((uint64_t)v9, v8, v6, v7);
  *a1 = v10;
  a1[1] = v11;
  a1[2] = v12;
  a1[3] = v13;
  return protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>;
}

void protocol witness for MutableCollection.subscript.modify in conformance _SliceBuffer<A>(id *a1, char a2)
{
  protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>(a1, a2, "Swift/SliceBuffer.swift", 0x198uLL);
}

void protocol witness for MutableCollection.subscript.modify in conformance _ArrayBuffer<A>(id *a1, char a2, const char *a3, unint64_t a4)
{
  if ((a2 & 1) == 0)
    swift_unknownObjectRelease(*a1);
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0x6C706D6920746F6ELL, 0xEF6465746E656D65, a3, 23, 2, a4, 0);
}

_QWORD *protocol witness for MutableCollection.partition(by:) in conformance _SliceBuffer<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a2);
  return RandomAccessCollection<>.index(before:)(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

_QWORD *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(a1, a2, a3, (_QWORD *(*)(uint64_t *__return_ptr, _QWORD *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(before:));
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a3, a3);
  return RandomAccessCollection<>.index(_:offsetBy:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a4, a3);
  return RandomAccessCollection.index(_:offsetBy:limitedBy:)(a1, a2, a3, a4, WitnessTable, a5);
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a3, a3);
  return RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, WitnessTable, (uint64_t)&protocol witness table for Int);
}

unint64_t protocol witness for Collection.endIndex.getter in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v4;
  unint64_t result;

  result = _SliceBuffer.endIndex.getter(a1, a2, a3, *(_QWORD *)(v4 + 24));
  *a4 = result;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _SliceBuffer<A>(_QWORD *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t *v3;
  _QWORD *v7;

  v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = _SliceBuffer.subscript.read(v7, *a2, *v3, v3[1], v3[2], v3[3], *(_QWORD *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*_SliceBuffer.subscript.read(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7))()
{
  uint64_t v7;

  v7 = *(_QWORD *)(a7 - 8);
  *a1 = a7;
  a1[1] = v7;
  a1[2] = malloc(*(_QWORD *)(v7 + 64));
  (*(void (**)(void))(v7 + 16))();
  return _ArrayBuffer.subscript.read;
}

id protocol witness for Collection.subscript.getter in conformance _SliceBuffer<A>@<X0>(uint64_t *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;

  v4 = (void *)specialized _SliceBuffer.subscript.getter(*a1, a1[1], *v2);
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  return swift_unknownObjectRetain(v4, v5, v6, v7);
}

uint64_t protocol witness for Collection.indices.getter in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a2);
  return RandomAccessCollection<>.indices.getter(a1, WitnessTable, (uint64_t)&protocol witness table for Int, a3);
}

uint64_t protocol witness for Collection.count.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  return _SliceBuffer.count.getter(a1, a2, *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24));
}

uint64_t protocol witness for Collection.index(after:) in conformance _SliceBuffer<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  return RandomAccessCollection<>.index(after:)(a1, a2, WitnessTable, (uint64_t)&protocol witness table for Int, a4);
}

_QWORD *protocol witness for Collection.formIndex(after:) in conformance _SliceBuffer<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(a1, a2, a3, (_QWORD *(*)(uint64_t *__return_ptr, _QWORD *, uint64_t, uint64_t, _UNKNOWN **))RandomAccessCollection<>.index(after:));
}

_QWORD *protocol witness for BidirectionalCollection.formIndex(before:) in conformance _SliceBuffer<A>(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *(*a4)(uint64_t *__return_ptr, _QWORD *, uint64_t, uint64_t, _UNKNOWN **))
{
  uint64_t WitnessTable;
  _QWORD *result;
  uint64_t v9;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  result = a4(&v9, a1, a2, WitnessTable, &protocol witness table for Int);
  *a1 = v9;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance ArraySlice<A>(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))_SliceBuffer._copyToContiguousArray());
}

__objc2_class **_SliceBuffer._copyToContiguousArray()(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __objc2_class **v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  uint64_t v22;
  BOOL isClassOrObjCExistentialType;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  id v28;
  BOOL v29;
  uint64_t v30;

  if ((a4 & 1) == 0)
  {
    v10 = (a4 >> 1) - a3;
    if (!__OFSUB__(a4 >> 1, a3))
    {
      if (v10 > 0)
        goto LABEL_4;
      goto LABEL_16;
    }
    __break(1u);
LABEL_20:
    __break(1u);
    goto LABEL_21;
  }
  v24 = type metadata accessor for __ContiguousArrayStorageBase();
  v28 = swift_unknownObjectRetain(a1, v25, v26, v27);
  v15 = (__objc2_class **)swift_dynamicCastClass((uint64_t)v28, v24);
  if (!v15)
  {
    swift_unknownObjectRelease(a1);
    v15 = &_swiftEmptyArrayStorage;
  }
  v29 = __OFSUB__(a4 >> 1, a3);
  v10 = (a4 >> 1) - a3;
  if (v29)
    goto LABEL_20;
  if ((__objc2_class *)v10 != v15[2])
  {
    swift_release((uint64_t)v15);
    if (v10 > 0)
    {
LABEL_4:
      v11 = getContiguousArrayStorageType<A>(for:)((uint64_t)a5, a5);
      v12 = *(a5 - 1);
      v13 = *(_QWORD *)(v12 + 72);
      v14 = *(unsigned __int8 *)(v12 + 80);
      v15 = (__objc2_class **)swift_allocObject(v11, ((v14 + *(unsigned int *)(v11 + 48)) & ~v14) + v13 * v10, v14 | *(unsigned __int16 *)(v11 + 52));
      v16 = _swift_stdlib_malloc_size(v15);
      if (v13)
      {
        v20 = (v14 + 32) & ~v14;
        if (v16 - v20 == 0x8000000000000000 && v13 == -1)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
        v22 = (uint64_t)(v16 - v20) / v13;
        swift_retain((unint64_t *)v15, v17, v18, v19);
        isClassOrObjCExistentialType = _swift_isClassOrObjCExistentialType((uint64_t)a5, a5);
        v15[2] = (__objc2_class *)v10;
        v15[3] = (__objc2_class *)(isClassOrObjCExistentialType | (unint64_t)(2 * v22));
        swift_unknownObjectRelease(a1);
        swift_release((uint64_t)v15);
        goto LABEL_17;
      }
LABEL_21:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    }
LABEL_16:
    swift_unknownObjectRelease(a1);
    v30 = *(a5 - 1);
    v13 = *(_QWORD *)(v30 + 72);
    v20 = (*(unsigned __int8 *)(v30 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v30 + 80);
    v15 = &_swiftEmptyArrayStorage;
LABEL_17:
    UnsafeMutablePointer.initialize(from:count:)((char *)(a2 + v13 * a3), v10, (char *)v15 + v20, (uint64_t)a5);
    return v15;
  }
  swift_unknownObjectRelease(a1);
  return v15;
}

__n128 protocol witness for Sequence._copyContents(initializing:) in conformance _SliceBuffer<A>(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  __n128 result;
  _OWORD v8[2];
  uint64_t v9;

  _SliceBuffer._copyContents(initializing:)(a2, a3, *(_QWORD *)v4, *(_QWORD *)(v4 + 8), *(_QWORD *)(v4 + 16), *(_QWORD *)(v4 + 24), *(_QWORD *)(a4 + 16), v8);
  v6 = v9;
  result = (__n128)v8[1];
  *(_OWORD *)a1 = v8[0];
  *(__n128 *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 32) = v6;
  return result;
}

Swift::Int __swiftcall StaticBigInt.signum()()
{
  uint64_t v0;

  if ((v0 & 1) != 0)
    return -1;
  else
    return (v0 & 0xFFFFFFFFFFFFFF00) != 256;
}

uint64_t StaticBigInt._isNegative.getter(uint64_t a1, char a2)
{
  return a2 & 1;
}

unint64_t StaticBigInt.bitWidth.getter(uint64_t a1, unint64_t a2)
{
  return a2 >> 8;
}

uint64_t StaticBigInt.subscript.getter(unint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((a1 & 0x8000000000000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/StaticBigInt.swift", 24, 2, 0x7BuLL, 0);
  if (a1 >> 57 || (uint64_t)(a1 << 6) >= (uint64_t)(a3 >> 8))
    return -(uint64_t)(a3 & 1);
  else
    return *(_QWORD *)(a2 + 8 * a1);
}

uint64_t StaticBigInt.debugDescription.getter(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  unint64_t v16;
  unint64_t v17;
  Swift::UInt64 v18;
  char v19;
  char v20;
  Swift::String::Index v21;
  Swift::String::Index v22;
  uint64_t v24[3];
  uint8x16_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) != 0)
    v2 = 7876653;
  else
    v2 = 7876651;
  v3 = ((a2 >> 8) + 2) >> 2;
  v4 = v3 + 3;
  v5 = a2 >> 9;
  if (a2 >> 9 >= 0x19)
  {
    v13 = specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(v3 + 3, v3 + 3, a2 & 1, a1, a2);
    v17 = v6;
  }
  else
  {
    v25 = (uint8x16_t)xmmword_1816ABD30;
    closure #1 in StaticBigInt.debugDescription.getter((uint64_t)&v25, v4, v4, a2 & 1, a1, a2);
    v9 = 8;
    if (v4 >= 8)
      v10 = 8;
    else
      v10 = v4;
    if (v4 > 8)
      v9 = v4;
    v11 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v10) & 0x38);
    v12 = 0xFFFFFFFFFFFFFFFFLL >> ((56 * v9) & 0x38);
    if (v5 <= 0xA)
      v12 = 0;
    v13 = v25.i64[0] & v11;
    v14 = v25.i64[1] & v12;
    v15 = ((v14 | v25.i64[0] & v11) & 0x8080808080808080) == 0;
    v16 = 0xA000000000000000;
    if (v15)
      v16 = 0xE000000000000000;
    v17 = v16 | (v4 << 56) | v14;
    if ((v17 & 0x4000000000000000) == 0)
    {
      v25.i64[0] = v13;
      v25.i64[1] = v14 & 0xFFFFFFFFFFFFFFLL;
      closure #2 in String.init(_uninitializedCapacity:initializingUTF8With:)(&v25, HIBYTE(v17) & 0xF, v24);
      v13 = v24[0];
      v17 = v24[1];
    }
  }
  v25.i64[0] = v13;
  v25.i64[1] = v17;
  swift_bridgeObjectRetain(v17, v6, v7, v8);
  v18 = specialized Collection.firstIndex(where:)(v13, v17);
  v20 = v19;
  swift_bridgeObjectRelease(v17);
  if ((v20 & 1) != 0)
  {
    swift_bridgeObjectRelease(0xE300000000000000);
    swift_bridgeObjectRelease(v17);
    return 813183019;
  }
  else
  {
    v21._rawBits = 15;
    v22._rawBits = v18;
    specialized String.replaceSubrange<A>(_:with:)(v21, v22, v2, 0xE300000000000000);
    swift_bridgeObjectRelease(0xE300000000000000);
    return v25.i64[0];
  }
}

uint64_t closure #1 in StaticBigInt.debugDescription.getter(uint64_t a1, uint64_t a2, uint64_t a3, BOOL a4, uint64_t a5, unint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  Swift::String v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  unint64_t v28;

  v8 = specialized Collection.prefix(_:)(a3, a1, a2);
  v10 = v9;
  v12 = v11;
  specialized Slice.initialize<A>(repeating:)((void *)0x30, v8, v9, v11);
  v13 = 0;
  v14 = a6 >> 8;
  v15 = a4;
  while (v13 < v14)
  {
    v17 = -(uint64_t)(a6 & 1);
    if ((v13 & 0x7FFFFFFFFFFFFFC0) < v14)
      v17 = *(_QWORD *)(a5 + ((v13 >> 3) & 0xFFFFFFFFFFFFF8));
    v18 = v17 >> (v13 & 0x20);
    if (v15)
    {
      v19 = !a4;
      a4 = a4 && ~(_DWORD)v18 == -1;
      if (v19)
        LODWORD(v18) = ~(_DWORD)v18;
      else
        LODWORD(v18) = -(int)v18;
    }
    v20 = _uint64ToString(_:radix:uppercase:)(v18, 16, 1);
    if (((uint64_t)v20._object & 0x1000000000000000) != 0)
    {
      v21 = String.UTF8View._foreignCount()();
      if ((v21 & 0x8000000000000000) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't take a suffix of negative length from a collection", 56, 2, "Swift/BidirectionalCollection.swift", 35, 2, 0x19BuLL, 0);
    }
    else if (((uint64_t)v20._object & 0x2000000000000000) != 0)
    {
      v21 = ((unint64_t)v20._object >> 56) & 0xF;
    }
    else
    {
      v21 = v20._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    v22 = v8 - v10;
    if (__OFSUB__(v8, v10))
    {
      v28 = 271;
      goto LABEL_42;
    }
    v23 = -(uint64_t)v21;
    if (v22 > 0 || (v24 = v8, v22 <= v23))
    {
      v24 = v10 - v21;
      if (__OFADD__(v10, v23))
      {
LABEL_39:
        v28 = 279;
        goto LABEL_42;
      }
    }
    if (v10 < v24)
      goto LABEL_36;
    if (v24 < v8)
    {
      v28 = 571;
      goto LABEL_42;
    }
    if (v12)
      v25 = (char *)(v12 + v24);
    else
      v25 = 0;
    if (v10 - v24 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
    if (v10 != v24 && !v25)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer has a nil start and nonzero count", 60, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x49uLL, 0);
    specialized UnsafeMutableBufferPointer.update<A>(fromContentsOf:)(v20._countAndFlagsBits, (unint64_t)v20._object, v25, v10 - v24);
    swift_bridgeObjectRelease((uint64_t)v20._object);
    v26 = v8;
    if ((unint64_t)(v22 + 7) >= 8)
    {
      v26 = v10 - 8;
      if (__OFSUB__(v10, 8))
        goto LABEL_39;
      if (v26 < v8)
LABEL_36:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    v13 += 32;
    v16 = v10 < v26;
    v10 = v26;
    if (v16)
    {
      v28 = 572;
LABEL_42:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v28, 0);
    }
  }
  return a3;
}

void *specialized Slice.initialize<A>(repeating:)(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v5;
  int64_t v6;

  if (a4)
    v5 = (void *)(a4 + a2);
  else
    v5 = 0;
  v6 = a3 - a2;
  if (v6 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  if (v6)
  {
    if (!v5)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer has a nil start and nonzero count", 60, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x49uLL, 0);
    return specialized UnsafeMutablePointer.initialize(repeating:count:)(result, v6, v5);
  }
  if (v5)
    return specialized UnsafeMutablePointer.initialize(repeating:count:)(result, v6, v5);
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.addingReportingOverflow(_:)(Swift::UInt32 a1)
{
  _BOOL4 v1;
  Swift::UInt32 v2;
  Swift::tuple_partialValue_UInt32_overflow_Bool result;

  v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

uint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance StaticBigInt()
{
  uint64_t v0;

  return StaticBigInt.debugDescription.getter(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
}

uint64_t StaticBigInt.customMirror.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, a2, 8, 0, 0, a3);
}

uint64_t protocol witness for CustomReflectable.customMirror.getter in conformance StaticBigInt@<X0>(uint64_t a1@<X8>)
{
  uint64_t *v1;

  return specialized Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(*v1, v1[1], 8, 0, 0, a1);
}

uint64_t UInt128._value.setter(uint64_t result, uint64_t a2)
{
  _QWORD *v2;

  *v2 = result;
  v2[1] = a2;
  return result;
}

uint64_t (*UInt128._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t static UInt128.zero.getter()
{
  return 0;
}

uint64_t static UInt128.min.getter()
{
  return 0;
}

uint64_t static UInt128.max.getter()
{
  return -1;
}

uint64_t UInt128.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  void (*v28)(char *, char *, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char *v30;
  char v31;
  void (*v32)(char *, uint64_t);
  char *v33;
  char *v34;
  char *v35;
  uint64_t (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  char *v38;
  void (*v39)(char *, uint64_t);
  void (*v40)(uint64_t, uint64_t);
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  unint64_t v52;
  char *v53;
  unint64_t v54;
  void (*v55)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  char *v60;
  unint64_t v61;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  char *v69;
  char *v70;
  char *v71;
  char *v72;
  void (*v73)(char *, uint64_t);
  unint64_t v74;

  v6 = *(_QWORD *)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v8 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v69 = (char *)&v63 - v9;
  v10 = *(_QWORD *)(a2 - 8);
  v11 = MEMORY[0x1E0C80A78](v8);
  v66 = (char *)&v63 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v72 = (char *)&v63 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v63 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v63 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v63 - v22;
  v74 = 64;
  v24 = *(void (**)(char *, unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 240);
  v27 = lazy protocol witness table accessor for type Int and conformance Int(v21, v25, v26);
  v71 = a1;
  v24(a1, &v74, &type metadata for Int, v27, a2, a3);
  v68 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  LOBYTE(a1) = v68(a2, a3);
  v28 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
  v70 = v23;
  v28(v20, v23, a2);
  v64 = AssociatedTypeWitness;
  v65 = v6;
  v67 = v10;
  if ((a1 & 1) != 0)
  {
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v30 = v69;
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 24))(v30, a2, v6);
    v31 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v20, v17, a2);
    v32 = *(void (**)(char *, uint64_t))(v10 + 8);
    v32(v17, a2);
    v73 = v32;
    v32(v20, a2);
    v33 = v70;
    v34 = v71;
    if ((v31 & 1) != 0)
      goto LABEL_17;
  }
  else
  {
    v73 = *(void (**)(char *, uint64_t))(v10 + 8);
    v73(v20, a2);
    v33 = v70;
    v34 = v71;
    v30 = v69;
  }
  v71 = v17;
  v35 = v34;
  v36 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v37 = v36(a2, a3);
  v38 = v72;
  v28(v72, v33, a2);
  if (v37 <= 63)
  {
    v39 = v73;
    v73(v38, a2);
    v34 = v35;
    goto LABEL_7;
  }
  v74 = -1;
  v42 = v68(a2, a3);
  v43 = v36(a2, a3);
  v34 = v35;
  if ((v42 & 1) != 0)
  {
    if (v43 < 65)
    {
      v46 = v64;
      v47 = v65;
      v48 = swift_getAssociatedConformanceWitness(v65, a2, v64, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v48 + 8))(&unk_1816B7DA8, 256, v46, v48);
      v49 = v30;
      v50 = v71;
      (*(void (**)(char *, uint64_t, uint64_t))(v47 + 24))(v49, a2, v47);
      v51 = v72;
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 40))(v72, v50, a2);
      v39 = v73;
      v73(v50, a2);
      v52 = v74;
      v53 = v66;
      (*(void (**)(char *, char *, uint64_t))(v67 + 32))(v66, v51, a2);
      if ((v46 & 1) != 0)
      {
        v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v39(v53, a2);
        if (v52 < v54)
          goto LABEL_17;
      }
      else
      {
        v39(v53, a2);
      }
      goto LABEL_7;
    }
LABEL_14:
    v55 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v56 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v43, v44, v45);
    v57 = v71;
    v55(&v74, &type metadata for UInt64, v56, a2, a3);
    v58 = v72;
    v59 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v57, v72, a2);
    v39 = v73;
    v73(v57, a2);
    v39(v58, a2);
    if ((v59 & 1) != 0)
      goto LABEL_17;
    goto LABEL_7;
  }
  if (v43 >= 65)
    goto LABEL_14;
  v60 = v71;
  (*(void (**)(char *, char *, uint64_t))(v67 + 32))(v71, v72, a2);
  v61 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v39 = v73;
  v73(v60, a2);
  if (v74 < v61)
  {
LABEL_17:
    v39 = v73;
    v73(v33, a2);
    v41 = 0;
    goto LABEL_18;
  }
LABEL_7:
  v40 = *(void (**)(uint64_t, uint64_t))(a3 + 120);
  v40(a2, a3);
  v39(v33, a2);
  v41 = ((uint64_t (*)(uint64_t, uint64_t))v40)(a2, a3);
LABEL_18:
  v39(v34, a2);
  return v41;
}

uint64_t UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized UInt128.init<A>(_:));
}

{
  return Int128.init<A>(_:)(a1, a2, a3, (uint64_t (*)(void))specialized UInt128.init<A>(_:));
}

uint64_t UInt128.init<A>(clamping:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  char v12;
  void (*v13)(uint64_t, uint64_t);
  uint64_t v15;

  v6 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  v9 = UInt128.init<A>(exactly:)(v8, a2, a3);
  if ((v10 & 1) != 0)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 24) + 8) + 16))(a2);
    v12 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(a1, v8, a2);
    v13 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
    v13(a1, a2);
    v13((uint64_t)v8, a2);
    return (v12 & 1) - 1;
  }
  else
  {
    v11 = v9;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  }
  return v11;
}

uint64_t *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt128@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;

  if (a2 >> 9 > 0x40 || (a2 & 1) != 0)
  {
    v4 = 0;
LABEL_7:
    *a3 = v4;
    a3[1] = 0;
    return result;
  }
  v4 = *result;
  if (a2 >> 9 <= 0x20)
    goto LABEL_7;
  v5 = result[1];
  *a3 = v4;
  a3[1] = v5;
  return result;
}

uint64_t UInt128.init<A>(exactly:)(char *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  unint64_t AssociatedConformanceWitness;
  void (*v22)(char *, uint64_t, uint64_t);
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(char *, char *, uint64_t, uint64_t);
  void (*v27)(char *, uint64_t);
  void (*v28)(uint64_t *, uint64_t, uint64_t);
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  uint64_t v36;
  void (*v37)(uint64_t, char *, uint64_t);
  uint64_t v38;
  char *v39;
  _QWORD v41[2];
  void (*v42)(char *, char *, uint64_t, uint64_t);
  void (*v43)(char *, uint64_t, uint64_t);
  void (*v44)(unint64_t, double);
  unint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  char *v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  char v53;

  v50 = a3;
  v5 = *(_QWORD *)(a3 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v5, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, associated type descriptor for ExpressibleByFloatLiteral.FloatLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v9 = (char *)v41 - v8;
  v10 = *(_QWORD *)(a2 - 8);
  v11 = MEMORY[0x1E0C80A78](v7);
  v49 = (char *)v41 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v15 = (char *)v41 - v14;
  v16 = MEMORY[0x1E0C80A78](v13);
  v18 = (char *)v41 - v17;
  MEMORY[0x1E0C80A78](v16);
  v20 = (char *)v41 - v19;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByFloatLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByFloatLiteral.ExpressibleByFloatLiteral.FloatLiteralType: _ExpressibleByBuiltinFloatLiteral);
  v44 = *(void (**)(unint64_t, double))(AssociatedConformanceWitness + 8);
  v45 = AssociatedConformanceWitness;
  v44(AssociatedTypeWitness, 5.42101086e-20);
  v22 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 24);
  v47 = v9;
  v48 = v5;
  v43 = v22;
  v22(v9, a2, v5);
  v23 = v50;
  v24 = *(_QWORD *)(v50 + 16);
  v25 = *(_QWORD *)(*(_QWORD *)(v24 + 16) + 8);
  v26 = *(void (**)(char *, char *, uint64_t, uint64_t))(v25 + 64);
  v51 = a1;
  v46 = v25;
  v42 = v26;
  ((void (*)(char *, char *, uint64_t))v26)(a1, v15, a2);
  v27 = *(void (**)(char *, uint64_t))(v10 + 8);
  v27(v15, a2);
  LOBYTE(v52) = 4;
  v28 = *(void (**)(uint64_t *, uint64_t, uint64_t))(v24 + 304);
  v29 = v24;
  v30 = v23;
  v28(&v52, a2, v29);
  v27(v18, a2);
  v31 = (*(uint64_t (**)(char *, char *, uint64_t))(v10 + 16))(v18, v20, a2);
  v34 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v31, v32, v33);
  FixedWidthInteger.init<A>(exactly:)((uint64_t)v18, (uint64_t)&type metadata for UInt64, a2, v34, v23, (uint64_t)&v52);
  if (v53 == 1)
  {
    v27(v51, a2);
    v27(v20, a2);
    return 0;
  }
  v41[1] = v52;
  if (v52)
  {
    v35 = v47;
    v41[0] = v34;
    ((void (*)(unint64_t, unint64_t, double))v44)(AssociatedTypeWitness, v45, 1.84467441e19);
    v43(v35, a2, v48);
    v36 = v46;
    v42(v15, v20, a2, v46);
    v27(v15, a2);
    v27(v20, a2);
    v37 = *(void (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(v36 + 8) + 40);
    v38 = (uint64_t)v49;
    v39 = v51;
    v37((uint64_t)v51, v18, a2);
    v34 = v41[0];
    v27(v39, a2);
    v27(v18, a2);
  }
  else
  {
    v27(v20, a2);
    v38 = (uint64_t)v49;
    (*(void (**)(char *, char *, uint64_t))(v10 + 32))(v49, v51, a2);
  }
  FixedWidthInteger.init<A>(exactly:)(v38, (uint64_t)&type metadata for UInt64, a2, v34, v30, (uint64_t)&v52);
  if (v53 == 1)
    return 0;
  return v52;
}

BOOL static UInt128.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

BOOL static UInt128.< infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return __PAIR128__(a2, a1) < __PAIR128__(a4, a3);
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  return *a2 < *a1;
}

void UInt128.hash(into:)(int a1, Swift::UInt64 a2, Swift::UInt64 a3)
{
  Hasher._combine(_:)(a2);
  Hasher._combine(_:)(a3);
}

Swift::Int UInt128.hashValue.getter(Swift::UInt64 a1, Swift::UInt64 a2)
{
  Hasher._combine(_:)(a1);
  Hasher._combine(_:)(a2);
  return Hasher._finalize()();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance UInt128()
{
  Swift::UInt64 *v0;

  return UInt128.hashValue.getter(*v0, v0[1]);
}

uint64_t UInt128.addingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a1;
}

uint64_t UInt128.subtractingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 - a1;
}

uint64_t UInt128.dividedReportingOverflow(by:)(uint64_t a1, uint64_t a2)
{
  if (!(a1 | a2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  return __udivti3();
}

uint64_t UInt128.remainderReportingOverflow(dividingBy:)(uint64_t a1, uint64_t a2)
{
  if (!(a1 | a2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  return __umodti3();
}

uint64_t static UInt128.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4;
  uint64_t result;
  char v6;

  v4 = __CFADD__(a1, a3);
  result = a1 + a3;
  if (__CFADD__(v4, a2) | __CFADD__(a4, v4 + a2))
    v6 = 1;
  else
    v6 = 0;
  if ((v6 & 1) != 0)
    __break(1u);
  return result;
}

unint64_t static UInt128.- infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _BOOL1 v4;
  unint64_t result;

  v4 = a1 >= a3;
  result = a1 - a3;
  if (!__CFSUB__(a2, a4, v4))
    __break(1u);
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  __int128 v3;
  char v4;

  v3 = *(_OWORD *)result + *(_OWORD *)a2;
  if (__CFADD__(__CFADD__(*result, *a2), result[1]) | __CFADD__(a2[1], *((_QWORD *)&v3 + 1)))
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt128(_QWORD *result, unint64_t *a2)
{
  unint64_t v2;
  __int128 v3;
  char v4;
  unint64_t v5;
  char v6;

  v2 = a2[1];
  v3 = *(_OWORD *)result + *a2;
  v4 = __CFADD__(__CFADD__(*result, *a2), result[1]) | __CFADD__(v2, *((_QWORD *)&v3 + 1));
  v5 = v2 + *((_QWORD *)&v3 + 1);
  if (v4)
    v6 = 1;
  else
    v6 = 0;
  if ((v6 & 1) != 0)
  {
    __break(1u);
  }
  else
  {
    *result = v3;
    result[1] = v5;
  }
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  if (*result < *a2)
    __break(1u);
  else
    *a3 = *result - *a2;
  return result;
}

_OWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt128(_OWORD *result, _OWORD *a2)
{
  if (*result < *a2)
    __break(1u);
  else
    *result -= *a2;
  return result;
}

unint64_t static UInt128.* infix(_:_:)(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  BOOL v4;
  char v7;

  if (a2)
    v4 = a4 == 0;
  else
    v4 = 1;
  v7 = !v4 || (a2 * (unsigned __int128)a3) >> 64 != 0 || (a4 * (unsigned __int128)result) >> 64 != 0;
  if (__CFADD__((result * (unsigned __int128)a3) >> 64, a4 * result + a2 * a3))
    v7 = 1;
  if ((v7 & 1) != 0)
    __break(1u);
  else
    result *= a3;
  return result;
}

unint64_t *static UInt128.*= infix(_:_:)(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  char v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;

  v3 = *result;
  v4 = result[1];
  if (v4)
    v5 = a3 == 0;
  else
    v5 = 1;
  v8 = !v5 || (v4 * (unsigned __int128)a2) >> 64 != 0 || (a3 * (unsigned __int128)*result) >> 64 != 0;
  v9 = a3 * v3 + v4 * a2;
  v10 = (v3 * (unsigned __int128)a2) >> 64;
  v11 = __CFADD__(v10, v9);
  v12 = v10 + v9;
  if (v11)
    v8 = 1;
  if ((v8 & 1) != 0)
  {
    __break(1u);
  }
  else
  {
    *result = v3 * a2;
    result[1] = v12;
  }
  return result;
}

uint64_t static UInt128./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  return __udivti3();
}

uint64_t static UInt128./= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  if (!(a2 | a3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  result = __udivti3();
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t static UInt128.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(a3 | a4))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  return __umodti3();
}

uint64_t static UInt128.%= infix(_:_:)(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  if (!(a2 | a3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  result = __umodti3();
  *a1 = result;
  a1[1] = v5;
  return result;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))UInt128.init<A>(exactly:), a1);
}

unint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  char v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  char v15;

  v3 = *result;
  v4 = result[1];
  v5 = *a2;
  v6 = a2[1];
  if (v4)
    v7 = v6 == 0;
  else
    v7 = 1;
  v10 = !v7 || (v4 * (unsigned __int128)*a2) >> 64 != 0 || (v6 * (unsigned __int128)*result) >> 64 != 0;
  v11 = v6 * v3 + v4 * v5;
  v12 = (v3 * (unsigned __int128)v5) >> 64;
  v13 = __CFADD__(v12, v11);
  v14 = v12 + v11;
  if (v13)
    v15 = 1;
  else
    v15 = v10;
  if ((v15 & 1) != 0)
  {
    __break(1u);
  }
  else
  {
    *a3 = v3 * v5;
    a3[1] = v14;
  }
  return result;
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt128(unint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  char v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  char v14;

  v2 = *a2;
  v3 = a2[1];
  v4 = *result;
  v5 = result[1];
  if (v5)
    v6 = v3 == 0;
  else
    v6 = 1;
  v9 = !v6 || (v5 * (unsigned __int128)*a2) >> 64 != 0 || (v3 * (unsigned __int128)*result) >> 64 != 0;
  v10 = v3 * v4 + v5 * v2;
  v11 = (v4 * (unsigned __int128)v2) >> 64;
  v12 = __CFADD__(v11, v10);
  v13 = v11 + v10;
  if (v12)
    v14 = 1;
  else
    v14 = v9;
  if ((v14 & 1) != 0)
  {
    __break(1u);
  }
  else
  {
    *result = v4 * v2;
    result[1] = v13;
  }
  return result;
}

uint64_t *static UInt128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = result[1];
  v3 = ((2 * v2) << ~a2) | ((unint64_t)*result >> a2);
  v4 = v2 >> a2;
  if ((a2 & 0x40) != 0)
  {
    v3 = v4;
    v4 = 0;
  }
  *result = v3;
  result[1] = v4;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))UInt128.init<A>(exactly:), a1);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int128@<X0>(uint64_t (*a1)(void)@<X5>, uint64_t a2@<X8>)
{
  uint64_t result;
  uint64_t v4;
  char v5;

  result = a1();
  *(_QWORD *)a2 = result;
  *(_QWORD *)(a2 + 8) = v4;
  *(_BYTE *)(a2 + 16) = v5 & 1;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized UInt128.init<A>(_:), a3);
}

{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized UInt128.init<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result;
  uint64_t v6;

  result = UInt128.init<A>(clamping:)(a1, a2, a3);
  *a4 = result;
  a4[1] = v6;
  return result;
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt128()
{
  unint64_t *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt128@<X0>(_OWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t result;
  uint64_t v4;

  if (*a1 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  result = __udivti3();
  *a2 = result;
  a2[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  if (*a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  result = __udivti3();
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt128@<X0>(_OWORD *a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t result;
  uint64_t v4;

  if (*a1 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  result = __umodti3();
  *a2 = result;
  a2[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  if (*a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  result = __umodti3();
  *a1 = result;
  a1[1] = v4;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  uint64_t *v38;
  char v39;
  uint64_t (*v40)(uint64_t, uint64_t);
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  char v46;
  void (*v47)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v48;
  char v49;
  uint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t AssociatedConformanceWitness;
  char *v54;
  void (*v55)(char *, uint64_t);
  uint64_t v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void (*v62)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v63;
  char v64;
  uint64_t (*v65)(char *, uint64_t);
  uint64_t v66;
  void (*v67)(char *, uint64_t, uint64_t);
  char *v68;
  char v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t (*v75)(uint64_t, uint64_t);
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char v79;
  void (*v80)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v81;
  char v82;
  uint64_t *v83;
  uint64_t v84;
  const char *v85;
  unint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  uint64_t v90;
  BOOL v91;
  char *v92;
  uint64_t (*v93)(uint64_t, uint64_t);
  uint64_t v94;
  uint64_t *v95;
  uint64_t (*v96)(uint64_t, uint64_t);
  char v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  void (*v101)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v102;
  int64_t *v103;
  uint64_t v104;
  BOOL v105;
  char v106;
  char *v107;
  unint64_t v108;
  uint64_t *v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t AssociatedTypeWitness;
  const char *v114;
  unint64_t v115;
  char *v116;
  char *v117;
  char *v118;
  unint64_t v119;
  char *v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t (*v122)(uint64_t, uint64_t);
  uint64_t v123;
  int64_t v124;

  v114 = *(const char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v112 = (char *)&v109 - v11;
  v12 = *(_QWORD *)(a3 - 8);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v109 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v110 = (char *)&v109 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v118 = (char *)&v109 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v117 = (char *)&v109 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v111 = (char *)&v109 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v116 = (char *)&v109 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v120 = (char *)&v109 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v109 - v28;
  v30 = a1[1];
  v115 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v122 = v31;
  if ((v32 & 1) != 0)
  {
    v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v121(a3, a4);
    if (v33 >= 64)
    {
      v124 = -128;
      v47 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v48 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v47(&v124, &type metadata for Int, v48, a3, a4);
      v49 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = a5;
      if ((v49 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = a5;
      if (v36 < -128)
        goto LABEL_24;
    }
  }
  else
  {
    v119 = v30;
    v109 = a5;
    v39 = v31(a3, a4);
    v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v41 = v40(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v41 > 64)
      {
        v121 = v40;
        v124 = -128;
        v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        v44(&v124, &type metadata for Int, v45, a3, a4);
        v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
        v38 = v109;
        v30 = v119;
        if ((v46 & 1) != 0)
          goto LABEL_24;
        goto LABEL_18;
      }
      v51 = AssociatedTypeWitness;
      v52 = v114;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v54 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v51, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v52 + 3))(v54, a3, v52);
      LOBYTE(v51) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v55 = *(void (**)(char *, uint64_t))(v12 + 8);
      v55(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
      if ((v51 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
        v56 = 0;
        v57 = 0;
        v38 = v109;
        goto LABEL_60;
      }
      v121 = v40;
      v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
    }
    else
    {
      v121 = v40;
      if (v41 >= 64)
      {
        v38 = v109;
        v30 = v119;
        goto LABEL_18;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    }
    v38 = v109;
    v30 = v119;
    if (v50 < -128)
      goto LABEL_24;
  }
LABEL_18:
  v58 = v122(a3, a4);
  v59 = v121(a3, a4);
  if ((v58 & 1) != 0)
  {
    if (v59 > 64)
      goto LABEL_20;
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    result = v65(v29, a3);
    if (v66 > 128)
      goto LABEL_24;
    goto LABEL_25;
  }
  if (v59 <= 63)
    goto LABEL_23;
LABEL_20:
  v124 = 128;
  v62 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v63 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
  v62(&v124, &type metadata for Int, v63, a3, a4);
  v64 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
  v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  result = v65(v29, a3);
  if ((v64 & 1) != 0)
    goto LABEL_24;
LABEL_25:
  v109 = (uint64_t *)v65;
  v67 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v68 = v120;
  v67(v120, a2, a3);
  v69 = v122(a3, a4);
  v70 = v116;
  v67(v116, (uint64_t)v68, a3);
  v119 = v30;
  if ((v69 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v109)(v70, a3);
    v73 = v117;
    v72 = v118;
    goto LABEL_42;
  }
  v71 = v121(a3, a4);
  ((void (*)(char *, uint64_t))v109)(v70, a3);
  v73 = v117;
  v72 = v118;
  if (v71 <= 64)
    goto LABEL_42;
  v74 = v111;
  v67(v111, (uint64_t)v120, a3);
  v124 = 0x8000000000000000;
  v75 = v122;
  if ((v122(a3, a4) & 1) != 0)
  {
    v76 = v121(a3, a4);
    if (v76 < 64)
    {
LABEL_37:
      v67(v29, (uint64_t)v74, a3);
      v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v83 = v109;
      ((void (*)(char *, uint64_t))v109)(v29, a3);
      if (v84 < v124)
LABEL_70:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_41;
    }
LABEL_33:
    v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v81 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
    v80(&v124, &type metadata for Int, v81, a3, a4);
    v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v74, v29, a3);
    v83 = v109;
    ((void (*)(char *, uint64_t))v109)(v29, a3);
    if ((v82 & 1) != 0)
      goto LABEL_70;
    goto LABEL_41;
  }
  v79 = v75(a3, a4);
  v76 = v121(a3, a4);
  if ((v79 & 1) == 0)
  {
    if (v76 >= 64)
    {
      ((void (*)(char *, uint64_t))v109)(v74, a3);
      goto LABEL_42;
    }
    goto LABEL_37;
  }
  if (v76 > 64)
    goto LABEL_33;
  v86 = AssociatedTypeWitness;
  v85 = v114;
  v87 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v88 = v112;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))(&unk_1816B7DA8, 256, v86, v87);
  (*((void (**)(char *, uint64_t, const char *))v85 + 3))(v88, a3, v85);
  LOBYTE(v88) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v74, v29, a3);
  v83 = v109;
  ((void (*)(char *, uint64_t))v109)(v29, a3);
  v89 = v110;
  v67(v110, (uint64_t)v74, a3);
  if ((v88 & 1) != 0)
  {
    ((void (*)(char *, uint64_t))v83)(v89, a3);
    goto LABEL_70;
  }
  v116 = (char *)v124;
  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v83)(v89, a3);
  v91 = v90 < (uint64_t)v116;
  v72 = v118;
  if (v91)
    goto LABEL_70;
LABEL_41:
  ((void (*)(char *, uint64_t))v83)(v74, a3);
LABEL_42:
  v92 = v120;
  v93 = v121;
  v94 = v121(a3, a4);
  v67(v73, (uint64_t)v92, a3);
  if (v94 >= 65)
  {
    v95 = v109;
    ((void (*)(char *, uint64_t))v109)(v73, a3);
    v96 = v122;
    goto LABEL_44;
  }
  v104 = v93(a3, a4);
  v95 = v109;
  ((void (*)(char *, uint64_t))v109)(v73, a3);
  v105 = v104 == 64;
  v96 = v122;
  if (v105 && (v122(a3, a4) & 1) == 0)
  {
LABEL_44:
    v67(v72, (uint64_t)v120, a3);
    v124 = 0x7FFFFFFFFFFFFFFFLL;
    v97 = v96(a3, a4);
    v98 = v121(a3, a4);
    if ((v97 & 1) != 0)
    {
      if (v98 > 64)
      {
        v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
        v103 = &v124;
        goto LABEL_54;
      }
    }
    else if (v98 > 63)
    {
      v123 = 0x7FFFFFFFFFFFFFFFLL;
      v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
      v103 = &v123;
LABEL_54:
      v101(v103, &type metadata for Int, v102, a3, a4);
      v106 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v72, a3);
      ((void (*)(char *, uint64_t))v95)(v29, a3);
      if ((v106 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v67(v29, (uint64_t)v72, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    ((void (*)(char *, uint64_t))v95)(v29, a3);
LABEL_55:
    ((void (*)(char *, uint64_t))v95)(v72, a3);
  }
  v107 = v120;
  v108 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = ((uint64_t (*)(char *, uint64_t))v95)(v107, a3);
  if ((v108 & 0x8000000000000000) == 0)
  {
    if (v108 < 0x80)
    {
      v56 = ((2 * v119) << ~(_BYTE)v108) | (v115 >> v108);
      v57 = v119 >> v108;
      if ((v108 & 0x40) != 0)
      {
        v56 = v119 >> v108;
        v57 = 0;
      }
      goto LABEL_60;
    }
LABEL_24:
    v56 = 0;
    v57 = 0;
    goto LABEL_60;
  }
  if (v108 <= 0xFFFFFFFFFFFFFF80)
    goto LABEL_24;
  if ((-(uint64_t)v108 & 0x40) != 0)
    v56 = 0;
  else
    v56 = v115 << -(char)v108;
  v57 = (v119 << -(char)v108) | (v115 >> 1 >> (v108 - 1));
  if ((-(uint64_t)v108 & 0x40) != 0)
    v57 = v115 << -(char)v108;
LABEL_60:
  *v38 = v56;
  v38[1] = v57;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t (*v28)(uint64_t, uint64_t);
  char v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t result;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void (*v40)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  uint64_t v44;
  BOOL v45;
  unint64_t v46;
  const char *v47;
  unint64_t AssociatedConformanceWitness;
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v57;
  uint64_t (*v58)(char *, uint64_t);
  void (*v59)(void);
  char *v60;
  char v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t *v73;
  char v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void (*v78)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v79;
  char v80;
  void (*v81)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v82;
  char v83;
  uint64_t v84;
  void (**v85)(char *, uint64_t, const char *);
  unint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  char *v90;
  int64_t v91;
  uint64_t v92;
  uint64_t (*v93)(uint64_t, uint64_t);
  uint64_t v94;
  char *v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  void (*v100)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v101;
  int64_t *v102;
  uint64_t v103;
  char v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  char *v108;
  uint64_t v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t AssociatedTypeWitness;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  uint64_t *v118;
  uint64_t (*v119)(uint64_t, uint64_t);
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t v121;
  int64_t v122;

  v118 = a1;
  v114 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v112 = (char *)&v109 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v109 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v110 = (char *)&v109 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v116 = (char *)&v109 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v115 = (char *)&v109 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v111 = (char *)&v109 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v109 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v117 = (char *)&v109 - v25;
  MEMORY[0x1E0C80A78](v24);
  v27 = (char *)&v109 - v26;
  v28 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v29 = v28(a3, a4);
  v119 = v28;
  if ((v29 & 1) != 0)
  {
    v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v31 = v30(a3, a4);
    if (v31 >= 64)
    {
      v122 = -128;
      v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v43 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v42(&v122, &type metadata for Int, v43, a3, a4);
      LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v27, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      if ((v42 & 1) != 0)
        goto LABEL_28;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      if (v34 < -128)
        goto LABEL_28;
    }
  }
  else
  {
    v36 = v28(a3, a4);
    v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v37 = v120(a3, a4);
    if ((v36 & 1) != 0)
    {
      if (v37 > 64)
      {
        v122 = -128;
        v40 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v41 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
        v40(&v122, &type metadata for Int, v41, a3, a4);
        LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v27, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
        v28 = v119;
        v30 = v120;
        if ((v40 & 1) != 0)
          goto LABEL_28;
        goto LABEL_18;
      }
      v46 = AssociatedTypeWitness;
      v47 = v114;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v49 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v46, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v27, a3);
      v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v27, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_28;
      }
      v51 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
      v45 = v51 < -128;
    }
    else
    {
      if (v37 >= 64)
      {
        v28 = v119;
        v30 = v120;
        goto LABEL_18;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      v45 = v44 < -128;
    }
    v28 = v119;
    v30 = v120;
    if (v45)
      goto LABEL_28;
  }
LABEL_18:
  v120 = v30;
  v52 = v28(a3, a4);
  v53 = v30(a3, a4);
  if ((v52 & 1) != 0)
  {
    if (v53 > 64)
      goto LABEL_20;
  }
  else if (v53 >= 64)
  {
LABEL_20:
    v122 = 128;
    v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v57 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    v56(&v122, &type metadata for Int, v57, a3, a4);
    LOBYTE(v56) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v27, a2, a3);
    v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    result = v58(v27, a3);
    if ((v56 & 1) == 0)
      goto LABEL_21;
LABEL_28:
    v71 = 0;
    v72 = 0;
    v73 = v118;
    goto LABEL_62;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
  v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  result = v58(v27, a3);
  if (v70 > 128)
    goto LABEL_28;
LABEL_21:
  v59 = *(void (**)(void))(v9 + 16);
  v60 = v117;
  v59();
  v61 = v119(a3, a4);
  ((void (*)(char *, char *, uint64_t))v59)(v23, v60, a3);
  if ((v61 & 1) == 0)
  {
    v58(v23, a3);
    v63 = v116;
    goto LABEL_45;
  }
  v62 = v120(a3, a4);
  v58(v23, a3);
  v63 = v116;
  if (v62 <= 64)
    goto LABEL_45;
  v64 = v111;
  ((void (*)(char *, char *, uint64_t))v59)(v111, v60, a3);
  v122 = 0x8000000000000000;
  v65 = v119;
  if ((v119(a3, a4) & 1) != 0)
  {
    v66 = v120(a3, a4);
    if (v66 < 64)
    {
      v69 = v27;
      goto LABEL_39;
    }
    v81 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v82 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v81(&v122, &type metadata for Int, v82, a3, a4);
    v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v64, v27, a3);
    goto LABEL_34;
  }
  v74 = v65(a3, a4);
  v75 = v120(a3, a4);
  if ((v74 & 1) != 0)
  {
    if (v75 <= 64)
    {
      v86 = AssociatedTypeWitness;
      v85 = (void (**)(char *, uint64_t, const char *))v114;
      v87 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v88 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))(&unk_1816B7DA8, 256, v86, v87);
      v85[3](v88, a3, (const char *)v85);
      v89 = v111;
      LOBYTE(v85) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v27, a3);
      v58(v27, a3);
      v90 = v110;
      ((void (*)(char *, char *, uint64_t))v59)(v110, v89, a3);
      if ((v85 & 1) != 0)
      {
        v58(v90, a3);
        goto LABEL_73;
      }
      v91 = v122;
      v92 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v58(v90, a3);
      v45 = v92 < v91;
      v60 = v117;
      v64 = v111;
      if (v45)
        goto LABEL_73;
LABEL_43:
      v108 = v64;
      goto LABEL_44;
    }
    v78 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v79 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
    v78(&v122, &type metadata for Int, v79, a3, a4);
    v64 = v111;
    v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v27, a3);
LABEL_34:
    v83 = v80;
    v58(v27, a3);
    if ((v83 & 1) != 0)
      goto LABEL_73;
    goto LABEL_43;
  }
  if (v75 < 64)
  {
    v69 = v27;
    v64 = v111;
LABEL_39:
    ((void (*)(char *, char *, uint64_t))v59)(v69, v64, a3);
    v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
    if (v84 < v122)
LABEL_73:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_43;
  }
  v108 = v111;
LABEL_44:
  v58(v108, a3);
LABEL_45:
  v93 = v120;
  v94 = v120(a3, a4);
  v95 = v115;
  ((void (*)(char *, char *, uint64_t))v59)(v115, v60, a3);
  if (v94 >= 65)
  {
    v58(v95, a3);
    goto LABEL_47;
  }
  v103 = v93(a3, a4);
  v58(v95, a3);
  if (v103 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_47:
    ((void (*)(char *, char *, uint64_t))v59)(v63, v60, a3);
    v122 = 0x7FFFFFFFFFFFFFFFLL;
    v96 = v119(a3, a4);
    v97 = v120(a3, a4);
    if ((v96 & 1) != 0)
    {
      if (v97 > 64)
      {
        v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
        v102 = &v122;
        goto LABEL_56;
      }
    }
    else if (v97 >= 64)
    {
      v121 = 0x7FFFFFFFFFFFFFFFLL;
      v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
      v102 = &v121;
LABEL_56:
      v100(v102, &type metadata for Int, v101, a3, a4);
      v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v27, v63, a3);
      v58(v27, a3);
      if ((v104 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_57;
    }
    ((void (*)(char *, char *, uint64_t))v59)(v27, v63, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
LABEL_57:
    v58(v63, a3);
  }
  v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v58(v60, a3);
  v73 = v118;
  v107 = *v118;
  v106 = v118[1];
  if ((v105 & 0x8000000000000000) == 0)
  {
    if (v105 < 0x80)
    {
      v71 = ((2 * v106) << ~(_BYTE)v105) | (v107 >> v105);
      v72 = v106 >> v105;
      if ((v105 & 0x40) != 0)
      {
        v71 = v72;
        v72 = 0;
      }
      goto LABEL_62;
    }
LABEL_70:
    v71 = 0;
    v72 = 0;
    goto LABEL_62;
  }
  if (v105 < 0xFFFFFFFFFFFFFF81)
    goto LABEL_70;
  if ((-(uint64_t)v105 & 0x40) != 0)
    v71 = 0;
  else
    v71 = v107 << -(char)v105;
  v72 = (v106 << -(char)v105) | (v107 >> 1 >> (v105 - 1));
  if ((-(uint64_t)v105 & 0x40) != 0)
    v72 = v107 << -(char)v105;
LABEL_62:
  *v73 = v71;
  v73[1] = v72;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  uint64_t *v38;
  char v39;
  uint64_t (*v40)(uint64_t, uint64_t);
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  char v46;
  void (*v47)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v48;
  char v49;
  uint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t AssociatedConformanceWitness;
  char *v54;
  void (*v55)(char *, uint64_t);
  uint64_t v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void (*v62)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v63;
  char v64;
  uint64_t (*v65)(char *, uint64_t);
  uint64_t v66;
  void (*v67)(char *, uint64_t, uint64_t);
  char *v68;
  char v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t (*v75)(uint64_t, uint64_t);
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char v79;
  void (*v80)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v81;
  char v82;
  uint64_t *v83;
  uint64_t v84;
  const char *v85;
  unint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  uint64_t v90;
  BOOL v91;
  char *v92;
  uint64_t (*v93)(uint64_t, uint64_t);
  uint64_t v94;
  uint64_t *v95;
  uint64_t (*v96)(uint64_t, uint64_t);
  char v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  void (*v101)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v102;
  int64_t *v103;
  uint64_t v104;
  BOOL v105;
  char v106;
  char *v107;
  unint64_t v108;
  uint64_t *v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t AssociatedTypeWitness;
  const char *v114;
  unint64_t v115;
  char *v116;
  char *v117;
  char *v118;
  unint64_t v119;
  char *v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t (*v122)(uint64_t, uint64_t);
  uint64_t v123;
  int64_t v124;

  v114 = *(const char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v112 = (char *)&v109 - v11;
  v12 = *(_QWORD *)(a3 - 8);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v109 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v110 = (char *)&v109 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v118 = (char *)&v109 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v117 = (char *)&v109 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v111 = (char *)&v109 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v116 = (char *)&v109 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v120 = (char *)&v109 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v109 - v28;
  v30 = *a1;
  v115 = a1[1];
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v122 = v31;
  if ((v32 & 1) != 0)
  {
    v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v121(a3, a4);
    if (v33 >= 64)
    {
      v124 = -128;
      v47 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v48 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v47(&v124, &type metadata for Int, v48, a3, a4);
      v49 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = a5;
      if ((v49 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = a5;
      if (v36 < -128)
        goto LABEL_24;
    }
  }
  else
  {
    v119 = v30;
    v109 = a5;
    v39 = v31(a3, a4);
    v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v41 = v40(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v41 > 64)
      {
        v121 = v40;
        v124 = -128;
        v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        v44(&v124, &type metadata for Int, v45, a3, a4);
        v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
        v38 = v109;
        v30 = v119;
        if ((v46 & 1) != 0)
          goto LABEL_24;
        goto LABEL_18;
      }
      v51 = AssociatedTypeWitness;
      v52 = v114;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v54 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v51, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v52 + 3))(v54, a3, v52);
      LOBYTE(v51) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v55 = *(void (**)(char *, uint64_t))(v12 + 8);
      v55(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
      if ((v51 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
        v56 = 0;
        v57 = 0;
        v38 = v109;
        goto LABEL_64;
      }
      v121 = v40;
      v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v55)(v15, a3);
    }
    else
    {
      v121 = v40;
      if (v41 >= 64)
      {
        v38 = v109;
        v30 = v119;
        goto LABEL_18;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    }
    v38 = v109;
    v30 = v119;
    if (v50 < -128)
      goto LABEL_24;
  }
LABEL_18:
  v58 = v122(a3, a4);
  v59 = v121(a3, a4);
  if ((v58 & 1) != 0)
  {
    if (v59 > 64)
      goto LABEL_20;
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    result = v65(v29, a3);
    if (v66 > 128)
      goto LABEL_24;
    goto LABEL_25;
  }
  if (v59 <= 63)
    goto LABEL_23;
LABEL_20:
  v124 = 128;
  v62 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v63 = lazy protocol witness table accessor for type Int and conformance Int(v59, v60, v61);
  v62(&v124, &type metadata for Int, v63, a3, a4);
  v64 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
  v65 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  result = v65(v29, a3);
  if ((v64 & 1) != 0)
    goto LABEL_24;
LABEL_25:
  v109 = (uint64_t *)v65;
  v67 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v68 = v120;
  v67(v120, a2, a3);
  v69 = v122(a3, a4);
  v70 = v116;
  v67(v116, (uint64_t)v68, a3);
  v119 = v30;
  if ((v69 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v109)(v70, a3);
    v73 = v117;
    v72 = v118;
    goto LABEL_42;
  }
  v71 = v121(a3, a4);
  ((void (*)(char *, uint64_t))v109)(v70, a3);
  v73 = v117;
  v72 = v118;
  if (v71 <= 64)
    goto LABEL_42;
  v74 = v111;
  v67(v111, (uint64_t)v120, a3);
  v124 = 0x8000000000000000;
  v75 = v122;
  if ((v122(a3, a4) & 1) != 0)
  {
    v76 = v121(a3, a4);
    if (v76 < 64)
    {
LABEL_37:
      v67(v29, (uint64_t)v74, a3);
      v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v83 = v109;
      ((void (*)(char *, uint64_t))v109)(v29, a3);
      if (v84 < v124)
LABEL_74:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_41;
    }
LABEL_33:
    v80 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v81 = lazy protocol witness table accessor for type Int and conformance Int(v76, v77, v78);
    v80(&v124, &type metadata for Int, v81, a3, a4);
    v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v74, v29, a3);
    v83 = v109;
    ((void (*)(char *, uint64_t))v109)(v29, a3);
    if ((v82 & 1) != 0)
      goto LABEL_74;
    goto LABEL_41;
  }
  v79 = v75(a3, a4);
  v76 = v121(a3, a4);
  if ((v79 & 1) == 0)
  {
    if (v76 >= 64)
    {
      ((void (*)(char *, uint64_t))v109)(v74, a3);
      goto LABEL_42;
    }
    goto LABEL_37;
  }
  if (v76 > 64)
    goto LABEL_33;
  v86 = AssociatedTypeWitness;
  v85 = v114;
  v87 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v88 = v112;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))(&unk_1816B7DA8, 256, v86, v87);
  (*((void (**)(char *, uint64_t, const char *))v85 + 3))(v88, a3, v85);
  LOBYTE(v88) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v74, v29, a3);
  v83 = v109;
  ((void (*)(char *, uint64_t))v109)(v29, a3);
  v89 = v110;
  v67(v110, (uint64_t)v74, a3);
  if ((v88 & 1) != 0)
  {
    ((void (*)(char *, uint64_t))v83)(v89, a3);
    goto LABEL_74;
  }
  v116 = (char *)v124;
  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v83)(v89, a3);
  v91 = v90 < (uint64_t)v116;
  v72 = v118;
  if (v91)
    goto LABEL_74;
LABEL_41:
  ((void (*)(char *, uint64_t))v83)(v74, a3);
LABEL_42:
  v92 = v120;
  v93 = v121;
  v94 = v121(a3, a4);
  v67(v73, (uint64_t)v92, a3);
  if (v94 >= 65)
  {
    v95 = v109;
    ((void (*)(char *, uint64_t))v109)(v73, a3);
    v96 = v122;
    goto LABEL_44;
  }
  v104 = v93(a3, a4);
  v95 = v109;
  ((void (*)(char *, uint64_t))v109)(v73, a3);
  v105 = v104 == 64;
  v96 = v122;
  if (v105 && (v122(a3, a4) & 1) == 0)
  {
LABEL_44:
    v67(v72, (uint64_t)v120, a3);
    v124 = 0x7FFFFFFFFFFFFFFFLL;
    v97 = v96(a3, a4);
    v98 = v121(a3, a4);
    if ((v97 & 1) != 0)
    {
      if (v98 > 64)
      {
        v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
        v103 = &v124;
        goto LABEL_54;
      }
    }
    else if (v98 > 63)
    {
      v123 = 0x7FFFFFFFFFFFFFFFLL;
      v101 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v102 = lazy protocol witness table accessor for type Int and conformance Int(v98, v99, v100);
      v103 = &v123;
LABEL_54:
      v101(v103, &type metadata for Int, v102, a3, a4);
      v106 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v72, a3);
      ((void (*)(char *, uint64_t))v95)(v29, a3);
      if ((v106 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v67(v29, (uint64_t)v72, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    ((void (*)(char *, uint64_t))v95)(v29, a3);
LABEL_55:
    ((void (*)(char *, uint64_t))v95)(v72, a3);
  }
  v107 = v120;
  v108 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = ((uint64_t (*)(char *, uint64_t))v95)(v107, a3);
  if ((v108 & 0x8000000000000000) == 0)
  {
    if (v108 <= 0x7F)
    {
      if ((v108 & 0x40) != 0)
        v57 = v119 << v108;
      else
        v57 = (v115 << v108) | (v119 >> 1 >> ~(_BYTE)v108);
      if ((v108 & 0x40) != 0)
        v56 = 0;
      else
        v56 = v119 << v108;
      goto LABEL_64;
    }
LABEL_24:
    v56 = 0;
    v57 = 0;
    goto LABEL_64;
  }
  if (v108 <= 0xFFFFFFFFFFFFFF80)
    goto LABEL_24;
  if ((-(uint64_t)v108 & 0x40) != 0)
    v57 = 0;
  else
    v57 = v115 >> -(char)v108;
  v56 = ((2 * v115) << (v108 - 1)) | (v119 >> -(char)v108);
  if ((-(uint64_t)v108 & 0x40) != 0)
    v56 = v115 >> -(char)v108;
LABEL_64:
  *v38 = v56;
  v38[1] = v57;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt128(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t (*v28)(uint64_t, uint64_t);
  char v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t result;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void (*v40)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  uint64_t v44;
  BOOL v45;
  unint64_t v46;
  const char *v47;
  unint64_t AssociatedConformanceWitness;
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v57;
  uint64_t (*v58)(char *, uint64_t);
  void (*v59)(void);
  char *v60;
  char v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t (*v65)(uint64_t, uint64_t);
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t *v73;
  char v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void (*v78)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v79;
  char v80;
  void (*v81)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v82;
  char v83;
  uint64_t v84;
  void (**v85)(char *, uint64_t, const char *);
  unint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  char *v90;
  int64_t v91;
  uint64_t v92;
  uint64_t (*v93)(uint64_t, uint64_t);
  uint64_t v94;
  char *v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  void (*v100)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v101;
  int64_t *v102;
  uint64_t v103;
  char v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  char *v108;
  uint64_t v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t AssociatedTypeWitness;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  uint64_t *v118;
  uint64_t (*v119)(uint64_t, uint64_t);
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t v121;
  int64_t v122;

  v118 = a1;
  v114 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v112 = (char *)&v109 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v109 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v110 = (char *)&v109 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v116 = (char *)&v109 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v115 = (char *)&v109 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v111 = (char *)&v109 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v109 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v117 = (char *)&v109 - v25;
  MEMORY[0x1E0C80A78](v24);
  v27 = (char *)&v109 - v26;
  v28 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v29 = v28(a3, a4);
  v119 = v28;
  if ((v29 & 1) != 0)
  {
    v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v31 = v30(a3, a4);
    if (v31 >= 64)
    {
      v122 = -128;
      v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v43 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v42(&v122, &type metadata for Int, v43, a3, a4);
      LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v27, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      if ((v42 & 1) != 0)
        goto LABEL_28;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      if (v34 < -128)
        goto LABEL_28;
    }
  }
  else
  {
    v36 = v28(a3, a4);
    v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v37 = v120(a3, a4);
    if ((v36 & 1) != 0)
    {
      if (v37 > 64)
      {
        v122 = -128;
        v40 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v41 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
        v40(&v122, &type metadata for Int, v41, a3, a4);
        LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v27, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
        v28 = v119;
        v30 = v120;
        if ((v40 & 1) != 0)
          goto LABEL_28;
        goto LABEL_18;
      }
      v46 = AssociatedTypeWitness;
      v47 = v114;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v49 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v46, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v47 + 3))(v49, a3, v47);
      LOBYTE(v46) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v27, a3);
      v50 = *(void (**)(char *, uint64_t))(v9 + 8);
      v50(v27, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v46 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
        goto LABEL_28;
      }
      v51 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v50)(v12, a3);
      v45 = v51 < -128;
    }
    else
    {
      if (v37 >= 64)
      {
        v28 = v119;
        v30 = v120;
        goto LABEL_18;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
      v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v9 + 8))(v27, a3);
      v45 = v44 < -128;
    }
    v28 = v119;
    v30 = v120;
    if (v45)
      goto LABEL_28;
  }
LABEL_18:
  v120 = v30;
  v52 = v28(a3, a4);
  v53 = v30(a3, a4);
  if ((v52 & 1) != 0)
  {
    if (v53 > 64)
      goto LABEL_20;
  }
  else if (v53 >= 64)
  {
LABEL_20:
    v122 = 128;
    v56 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v57 = lazy protocol witness table accessor for type Int and conformance Int(v53, v54, v55);
    v56(&v122, &type metadata for Int, v57, a3, a4);
    LOBYTE(v56) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v27, a2, a3);
    v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
    result = v58(v27, a3);
    if ((v56 & 1) == 0)
      goto LABEL_21;
LABEL_28:
    v71 = 0;
    v72 = 0;
    v73 = v118;
    goto LABEL_62;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v27, a2, a3);
  v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v58 = *(uint64_t (**)(char *, uint64_t))(v9 + 8);
  result = v58(v27, a3);
  if (v70 > 128)
    goto LABEL_28;
LABEL_21:
  v59 = *(void (**)(void))(v9 + 16);
  v60 = v117;
  v59();
  v61 = v119(a3, a4);
  ((void (*)(char *, char *, uint64_t))v59)(v23, v60, a3);
  if ((v61 & 1) == 0)
  {
    v58(v23, a3);
    v63 = v116;
    goto LABEL_45;
  }
  v62 = v120(a3, a4);
  v58(v23, a3);
  v63 = v116;
  if (v62 <= 64)
    goto LABEL_45;
  v64 = v111;
  ((void (*)(char *, char *, uint64_t))v59)(v111, v60, a3);
  v122 = 0x8000000000000000;
  v65 = v119;
  if ((v119(a3, a4) & 1) != 0)
  {
    v66 = v120(a3, a4);
    if (v66 < 64)
    {
      v69 = v27;
      goto LABEL_39;
    }
    v81 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v82 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v81(&v122, &type metadata for Int, v82, a3, a4);
    v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v64, v27, a3);
    goto LABEL_34;
  }
  v74 = v65(a3, a4);
  v75 = v120(a3, a4);
  if ((v74 & 1) != 0)
  {
    if (v75 <= 64)
    {
      v86 = AssociatedTypeWitness;
      v85 = (void (**)(char *, uint64_t, const char *))v114;
      v87 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v88 = v112;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v87 + 8))(&unk_1816B7DA8, 256, v86, v87);
      v85[3](v88, a3, (const char *)v85);
      v89 = v111;
      LOBYTE(v85) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v27, a3);
      v58(v27, a3);
      v90 = v110;
      ((void (*)(char *, char *, uint64_t))v59)(v110, v89, a3);
      if ((v85 & 1) != 0)
      {
        v58(v90, a3);
        goto LABEL_73;
      }
      v91 = v122;
      v92 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v58(v90, a3);
      v45 = v92 < v91;
      v60 = v117;
      v64 = v111;
      if (v45)
        goto LABEL_73;
LABEL_43:
      v108 = v64;
      goto LABEL_44;
    }
    v78 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v79 = lazy protocol witness table accessor for type Int and conformance Int(v75, v76, v77);
    v78(&v122, &type metadata for Int, v79, a3, a4);
    v64 = v111;
    v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v27, a3);
LABEL_34:
    v83 = v80;
    v58(v27, a3);
    if ((v83 & 1) != 0)
      goto LABEL_73;
    goto LABEL_43;
  }
  if (v75 < 64)
  {
    v69 = v27;
    v64 = v111;
LABEL_39:
    ((void (*)(char *, char *, uint64_t))v59)(v69, v64, a3);
    v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
    if (v84 < v122)
LABEL_73:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_43;
  }
  v108 = v111;
LABEL_44:
  v58(v108, a3);
LABEL_45:
  v93 = v120;
  v94 = v120(a3, a4);
  v95 = v115;
  ((void (*)(char *, char *, uint64_t))v59)(v115, v60, a3);
  if (v94 >= 65)
  {
    v58(v95, a3);
    goto LABEL_47;
  }
  v103 = v93(a3, a4);
  v58(v95, a3);
  if (v103 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_47:
    ((void (*)(char *, char *, uint64_t))v59)(v63, v60, a3);
    v122 = 0x7FFFFFFFFFFFFFFFLL;
    v96 = v119(a3, a4);
    v97 = v120(a3, a4);
    if ((v96 & 1) != 0)
    {
      if (v97 > 64)
      {
        v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
        v102 = &v122;
        goto LABEL_56;
      }
    }
    else if (v97 >= 64)
    {
      v121 = 0x7FFFFFFFFFFFFFFFLL;
      v100 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v101 = lazy protocol witness table accessor for type Int and conformance Int(v97, v98, v99);
      v102 = &v121;
LABEL_56:
      v100(v102, &type metadata for Int, v101, a3, a4);
      v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v27, v63, a3);
      v58(v27, a3);
      if ((v104 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_57;
    }
    ((void (*)(char *, char *, uint64_t))v59)(v27, v63, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v58(v27, a3);
LABEL_57:
    v58(v63, a3);
  }
  v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v58(v60, a3);
  v73 = v118;
  v106 = *v118;
  v107 = v118[1];
  if ((v105 & 0x8000000000000000) == 0)
  {
    if (v105 < 0x80)
    {
      v72 = (v107 << v105) | (v106 >> 1 >> ~(_BYTE)v105);
      v71 = v106 << v105;
      if ((v105 & 0x40) != 0)
      {
        v72 = v71;
        v71 = 0;
      }
      goto LABEL_62;
    }
LABEL_70:
    v71 = 0;
    v72 = 0;
    goto LABEL_62;
  }
  if (v105 <= 0xFFFFFFFFFFFFFF80)
    goto LABEL_70;
  if ((-(uint64_t)v105 & 0x40) != 0)
    v72 = 0;
  else
    v72 = v107 >> -(char)v105;
  v71 = ((2 * v107) << (v105 - 1)) | (v106 >> -(char)v105);
  if ((-(uint64_t)v105 & 0x40) != 0)
    v71 = v107 >> -(char)v105;
LABEL_62:
  *v73 = v71;
  v73[1] = v72;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt128(uint64_t *a1, _OWORD *a2, unint64_t *a3)
{
  unint64_t *v3;
  uint64_t result;
  uint64_t v6;

  result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt128(uint64_t *a1)
{
  uint64_t *v1;

  return specialized BinaryInteger.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

void protocol witness for BinaryInteger.signum() in conformance UInt128(_QWORD *a1@<X8>)
{
  _OWORD *v1;

  *a1 = *v1 != 0;
  a1[1] = 0;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt128()
{
  unint64_t *v0;

  return specialized BinaryInteger._description(radix:uppercase:)(0xAuLL, 0, *v0, v0[1]);
}

unint64_t *protocol witness for Strideable.distance(to:) in conformance UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;

  v3 = *result;
  v4 = result[1];
  v6 = *v2;
  v5 = v2[1];
  if (*(_OWORD *)result >= *(_OWORD *)v2)
  {
    v7 = v3 >= v6;
    v9 = v3 - v6;
    if (!((v4 - (v5 + !v7)) | (v9 >> 63)))
      goto LABEL_5;
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
  }
  v7 = v6 >= v3;
  v8 = v6 - v3;
  if ((v5 - (v4 + !v7)) | (v8 >> 63))
    goto LABEL_6;
  v9 = -(uint64_t)v8;
LABEL_5:
  *a2 = v9;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  char v10;

  v3 = *result;
  v5 = *v2;
  v4 = v2[1];
  if ((*result & 0x8000000000000000) == 0)
  {
    v6 = __CFADD__(v5, v3);
    v3 += v5;
    v7 = v6;
    v6 = __CFADD__(v6, v4);
    v4 += v7;
    v5 = v6;
    if ((v5 & 1) == 0)
      goto LABEL_11;
    __break(1u);
  }
  v8 = -(uint64_t)v3;
  v6 = v5 >= v8;
  v3 = v5 - v8;
  v9 = v6;
  v6 = v4 >= !v6;
  v4 -= !v9;
  v10 = !v6;
  if ((v10 & 1) == 0)
  {
LABEL_11:
    *a2 = v3;
    a2[1] = v4;
    return result;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt128(uint64_t a1, uint64_t a2, char a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance Int128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int128(uint64_t a1, uint64_t a2, char a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  return a9(a1, a2, a3 & 1, *a4, a4[1], *a5, a5[1], *a6);
}

uint64_t UInt128.Words.count.getter()
{
  return 2;
}

uint64_t UInt128.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt128.Words.endIndex.getter()
{
  return 2;
}

uint64_t UInt128.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall UInt128.Words.index(after:)(Swift::Int after)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFADD__(after, 1);
  result = after + 1;
  if (v1)
    __break(1u);
  return result;
}

Swift::Int __swiftcall UInt128.Words.index(before:)(Swift::Int before)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFSUB__(before, 1);
  result = before - 1;
  if (v1)
    __break(1u);
  return result;
}

uint64_t UInt128.Words.subscript.getter(unint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[2];

  if (a1 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/UInt128.swift", 19, 2, 0x1F9uLL, 0);
  v4[0] = a2;
  v4[1] = a3;
  return v4[a1];
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance UInt128.Words@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result;

  result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2);
  *a3 = result;
  return result;
}

unint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt128.Words@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result;
  char v6;

  result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3);
  *(_QWORD *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance UInt128.Words(unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt128.Words(uint64_t *a1, unint64_t *a2))()
{
  uint64_t *v2;

  *a1 = UInt128.Words.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UInt128.Words@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if ((*result & 0x8000000000000000) != 0 || (v3 = result[1], v3 >= 3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  v4 = *v2;
  v5 = v2[1];
  *a2 = *result;
  a2[1] = v3;
  a2[2] = v4;
  a2[3] = v5;
  return result;
}

double protocol witness for Collection.indices.getter in conformance UInt128.Words@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = xmmword_1816ABF00;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance UInt128.Words(_QWORD *a1@<X8>)
{
  _QWORD *v1;
  uint64_t v2;

  v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
  a1[2] = 0;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance UInt128.Words()
{
  uint64_t *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt128.Words(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

uint64_t static UInt128.bitWidth.getter()
{
  return 128;
}

unint64_t UInt128.byteSwapped.getter(uint64_t a1, unint64_t a2)
{
  return bswap64(a2);
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt128(_QWORD *a1@<X8>)
{
  *a1 = -1;
  a1[1] = -1;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt128(_OWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  __int128 v3;
  uint64_t v4;

  v3 = *(_OWORD *)v2 + *(_OWORD *)a2;
  if (__CFADD__(__CFADD__(*v2, *a2), v2[1]) | __CFADD__(a2[1], *((_QWORD *)&v3 + 1)))
    v4 = 1;
  else
    v4 = 0;
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt128(_OWORD *a1, _OWORD *a2)
{
  _OWORD *v2;
  _BOOL8 v3;

  v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt128(_QWORD *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;

  v4 = *a2;
  v3 = a2[1];
  v6 = *v2;
  v5 = v2[1];
  if (v5)
    v7 = v3 == 0;
  else
    v7 = 1;
  v10 = !v7 || (v5 * (unsigned __int128)*a2) >> 64 != 0 || (v3 * (unsigned __int128)*v2) >> 64 != 0;
  v11 = v3 * v6 + v5 * v4;
  v12 = (v6 * (unsigned __int128)v4) >> 64;
  v13 = __CFADD__(v12, v11);
  v14 = v12 + v11;
  if (v13)
    v15 = 1;
  else
    v15 = v10;
  *a1 = v6 * v4;
  a1[1] = v14;
  return v15;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  uint64_t v3;

  if (*a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/UInt128.swift", 19, 2, 0x112uLL, 0);
  *a1 = __udivti3();
  a1[1] = v3;
  return 0;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt128(uint64_t *a1, _OWORD *a2)
{
  uint64_t v3;

  if (*a2 == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/UInt128.swift", 19, 2, 0x11CuLL, 0);
  *a1 = __umodti3();
  a1[1] = v3;
  return 0;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt128(uint64_t *a1, _OWORD *a2, unint64_t *a3)
{
  unint64_t *v3;
  uint64_t result;
  uint64_t v6;

  result = specialized FixedWidthInteger.multipliedFullWidth(by:)(a2, *a3, a3[1], *v3, v3[1]);
  *a1 = result;
  a1[1] = v6;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt128(uint64_t *a1, uint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t *v4;
  uint64_t result;
  uint64_t v7;

  result = specialized UnsignedInteger<>.dividingFullWidth(_:)(a2, *a3, a3[1], *a4, a4[1], *v4, v4[1]);
  *a1 = result;
  a1[1] = v7;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = result[1];
  v4 = ((2 * v3) << ~*a2) | (*result >> *a2);
  v5 = v3 >> *a2;
  if ((*a2 & 0x40) != 0)
  {
    v4 = v5;
    v5 = 0;
  }
  *a3 = v4;
  a3[1] = v5;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt128(uint64_t *result, _QWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[1];
  v3 = (2 * v2) << ~*a2;
  v4 = v2 >> *a2;
  if ((*a2 & 0x40) != 0)
    v5 = v4;
  else
    v5 = v3 | ((unint64_t)*result >> *a2);
  if ((*a2 & 0x40) != 0)
    v4 = 0;
  *result = v5;
  result[1] = v4;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char v17;
  char v18;
  char v19;

  v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  if (!v7)
  {
    swift_bridgeObjectRelease(a2);
    goto LABEL_10;
  }
  v10 = a3();
  if ((v12 & 0x100) != 0)
  {
    v13 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    v14 = v16;
    v18 = v17;
    swift_bridgeObjectRelease(a2);
    if ((v18 & 1) == 0)
      goto LABEL_8;
LABEL_10:
    v13 = 0;
    v14 = 0;
    v19 = 1;
    goto LABEL_11;
  }
  v13 = v10;
  v14 = v11;
  v15 = v12;
  swift_bridgeObjectRelease(a2);
  if ((v15 & 1) != 0)
    goto LABEL_10;
LABEL_8:
  v19 = 0;
LABEL_11:
  *(_QWORD *)a5 = v13;
  *(_QWORD *)(a5 + 8) = v14;
  *(_BYTE *)(a5 + 16) = v19;
}

unint64_t *sequence<A>(first:next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8;
  unint64_t *TupleTypeMetadata2;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)@<X0>(uint64_t@<X0>, uint64_t@<X8>);
  uint64_t v20;
  unint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (**v24)@<X0>(uint64_t@<X0>, uint64_t@<X8>);
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v29;
  unint64_t *v30;

  v29 = a2;
  v30 = (unint64_t *)a3;
  v8 = type metadata accessor for Optional((const char *)0xFF, a4, a3, a4);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v8, (uint64_t)&type metadata for Bool, 0, 0);
  v10 = *(TupleTypeMetadata2 - 1);
  v11 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v13 = (char *)&v29 - v12;
  v14 = *(_QWORD *)(v8 - 8);
  MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  v17 = *(_QWORD *)(a4 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v17 + 16))((char *)&v29 - v15, a1, a4);
  (*(void (**)(char *, _QWORD, uint64_t, uint64_t))(v17 + 56))(v16, 0, 1, a4);
  v18 = *((int *)TupleTypeMetadata2 + 12);
  (*(void (**)(char *, char *, uint64_t))(v14 + 32))(v13, v16, v8);
  v13[v18] = 1;
  v19 = (uint64_t (*)@<X0>(uint64_t@<X0>, uint64_t@<X8>))swift_allocObject((uint64_t)&unk_1E0E9C558, 0x28uLL, 7uLL);
  v20 = v29;
  v21 = v30;
  *((_QWORD *)v19 + 2) = a4;
  *((_QWORD *)v19 + 3) = v20;
  *((_QWORD *)v19 + 4) = v21;
  (*(void (**)(uint64_t, char *, unint64_t *))(v10 + 32))(a5, v13, TupleTypeMetadata2);
  v23 = type metadata accessor for UnfoldSequence(0, a4, (uint64_t)TupleTypeMetadata2, v22);
  *(_BYTE *)(a5 + *(int *)(v23 + 40)) = 0;
  v24 = (uint64_t (**)@<X0>(uint64_t@<X0>, uint64_t@<X8>))(a5 + *(int *)(v23 + 36));
  *v24 = partial apply for closure #1 in sequence<A>(first:next:);
  v24[1] = v19;
  return swift_retain(v21, v25, v26, v27);
}

uint64_t closure #1 in sequence<A>(first:next:)@<X0>(uint64_t a1@<X0>, void (*a2)(char *)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *TupleTypeMetadata2;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  void (*v22)(char *, char *, uint64_t);
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  void (*v30)(char *);
  uint64_t v31;
  uint64_t v32;

  v29 = a3;
  v30 = a2;
  v32 = a5;
  v31 = *(_QWORD *)(a4 - 8);
  MEMORY[0x1E0C80A78](a1);
  v28 = (char *)&v27 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = type metadata accessor for Optional((const char *)0xFF, v9, v8, v9);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, v10, (uint64_t)&type metadata for Bool, 0, 0);
  v12 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v14 = (char *)&v27 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v27 - v16;
  v18 = *(int *)(v15 + 48);
  v19 = *(_QWORD *)(v10 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v19 + 16))((char *)&v27 - v16, a1, v10);
  v20 = *(unsigned __int8 *)(a1 + v18);
  v17[v18] = v20;
  v21 = *((int *)TupleTypeMetadata2 + 12);
  v22 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  v22(v14, v17, v10);
  v14[v21] = v20;
  if (v20 == 1)
  {
    result = ((uint64_t (*)(uint64_t, char *, uint64_t))v22)(v32, v14, v10);
    *(_BYTE *)(a1 + v18) = 0;
  }
  else
  {
    v25 = v31;
    v24 = v32;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v31 + 48))(v14, 1, a4) == 1)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 56))(v24, 1, 1, a4);
    }
    else
    {
      v26 = v28;
      (*(void (**)(char *, char *, uint64_t))(v25 + 32))(v28, v14, a4);
      v30(v26);
      (*(void (**)(char *, uint64_t))(v25 + 8))(v26, a4);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v19 + 24))(a1, v24, v10);
    }
  }
  return result;
}

unint64_t *sequence<A, B>(state:next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;

  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 16))(a6, a1, a5);
  v12 = type metadata accessor for UnfoldSequence(0, a4, a5, v11);
  *(_BYTE *)(a6 + *(int *)(v12 + 40)) = 0;
  v13 = (_QWORD *)(a6 + *(int *)(v12 + 36));
  *v13 = a2;
  v13[1] = a3;
  return swift_retain(a3, v14, v15, v16);
}

uint64_t UnfoldSequence.init(_state:_next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v11;
  uint64_t result;
  _QWORD *v13;

  v11 = type metadata accessor for UnfoldSequence(0, a4, a5, a4);
  *(_BYTE *)(a6 + *(int *)(v11 + 40)) = 0;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 32))(a6, a1, a5);
  v13 = (_QWORD *)(a6 + *(int *)(v11 + 36));
  *v13 = a2;
  v13[1] = a3;
  return result;
}

uint64_t UnfoldSequence._state.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 24) - 8) + 16))(a2, v2);
}

uint64_t UnfoldSequence._state.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 24) - 8) + 40))(v2, a1);
}

uint64_t (*UnfoldSequence._state.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t LazyDropWhileSequence._predicate.getter(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  v5 = (uint64_t *)(v4 + *(int *)(a1 + 36));
  v6 = *v5;
  swift_retain((unint64_t *)v5[1], a2, a3, a4);
  return v6;
}

uint64_t UnfoldSequence._done.getter(uint64_t a1)
{
  uint64_t v1;

  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 40));
}

uint64_t UnfoldSequence._done.setter(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + *(int *)(a2 + 40)) = result;
  return result;
}

uint64_t (*UnfoldSequence._done.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnfoldSequence.next()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v18;
  unint64_t *v19;
  void (*v20)(uint64_t);
  uint64_t v21;
  uint64_t v22;

  v5 = v4;
  v8 = *(_QWORD *)(a1 + 16);
  v9 = type metadata accessor for Optional(0, v8, a2, a3);
  v10 = *(_QWORD *)(v9 - 8);
  MEMORY[0x1E0C80A78](v9);
  v15 = (char *)&v22 - v14;
  v16 = *(int *)(a1 + 40);
  if ((*(_BYTE *)(v5 + v16) & 1) != 0)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 56))(a4, 1, 1, v8);
  v18 = v5 + *(int *)(a1 + 36);
  v20 = *(void (**)(uint64_t))v18;
  v19 = *(unint64_t **)(v18 + 8);
  swift_retain(v19, v11, v12, v13);
  v20(v5);
  swift_release((uint64_t)v19);
  v21 = *(_QWORD *)(v8 - 8);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v21 + 48))(v15, 1, v8) == 1)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v15, v9);
    *(_BYTE *)(v5 + v16) = 1;
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v21 + 56))(a4, 1, 1, v8);
  }
  else
  {
    (*(void (**)(uint64_t, char *, uint64_t))(v21 + 32))(a4, v15, v8);
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v21 + 56))(a4, 0, 1, v8);
  }
}

uint64_t UnsafeMutableRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  if (a3)
    result = a3 + a1;
  else
    result = 0;
  v5 = a2 - a1;
  if (v5 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer with negative count", 49, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x68uLL, 0);
  if (v5)
  {
    if (!result)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer has a nil start and nonzero count", 63, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x69uLL, 0);
  }
  return result;
}

_QWORD *UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *result;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v29)(_QWORD *__return_ptr, unint64_t *, unint64_t);
  unint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _QWORD v44[2];
  uint64_t v45;

  v9 = *(_QWORD *)(a4 - 8);
  MEMORY[0x1E0C80A78](a1);
  v11 = (char *)&v39 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = *(_QWORD *)(v12 + 8);
  v15 = type metadata accessor for EnumeratedSequence(0, v14, v13, v14);
  MEMORY[0x1E0C80A78](v15);
  v17 = (char *)&v39 - v16;
  v19 = type metadata accessor for EnumeratedSequence.Iterator(0, a4, v13, v18);
  result = (_QWORD *)MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v39 - v22;
  if (a2)
  {
    v42 = v21;
    v43 = result;
    MEMORY[0x1E0C80A78](result);
    *(&v39 - 6) = a4;
    *(&v39 - 5) = a5;
    v35 = a1;
    v36 = a2;
    v41 = v24;
    v37 = v24;
    v38 = a2;
    result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(v13 + 72))(&v45, partial apply for closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:));
    if ((v45 & 1) != 0)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v17, a1, a4);
      (*(void (**)(char *, char *, uint64_t))(v9 + 32))(v11, v17, a4);
      (*(void (**)(uint64_t, uint64_t))(v13 + 32))(a4, v13);
      v25 = v43;
      v26 = *((int *)v43 + 9);
      *(_QWORD *)&v23[v26] = 0;
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v13, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, a4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
      v29 = *(void (**)(_QWORD *__return_ptr, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                              + 16);
      v30 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v29(v44, v30, AssociatedConformanceWitness);
      v31 = 0;
      if ((v44[0] & 0x100) == 0)
      {
        v40 = v26;
        v32 = 0;
        v33 = v41 - a2;
        do
        {
          v31 = v32 + 1;
          if (__OFADD__(v32, 1))
          {
            __break(1u);
LABEL_12:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.copyBytes source has too many elements", 68, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x20FuLL, 0);
          }
          if (v32 >= v33)
            goto LABEL_12;
          *(_BYTE *)(a2 + v32) = v44[0];
          v34 = swift_checkMetadataState(0, AssociatedTypeWitness);
          v29(v44, v34, AssociatedConformanceWitness);
          ++v32;
        }
        while (BYTE1(v44[0]) != 1);
        v26 = v40;
      }
      *(_QWORD *)&v23[v26] = v31;
      return (_QWORD *)(*(uint64_t (**)(char *, _QWORD *))(v42 + 8))(v23, v25);
    }
  }
  return result;
}

uint64_t UnsafeMutableRawBufferPointer.initializeMemory<A>(as:repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a3)
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a5 - 8) + 72);
    if (!v6)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    v7 = a4 - a3;
    if (a4 - a3 == 0x8000000000000000 && v6 == -1)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
    v8 = v7 / v6;
    UnsafeMutableRawPointer.initializeMemory<A>(as:repeating:count:)(a1, a2, v7 / v6, a3, a5);
    if (v8 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  return a3;
}

uint64_t UnsafeMutableRawBufferPointer.initializeMemory<A>(as:from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  void (*v29)(char *, uint64_t, uint64_t);
  void (*v30)(uint64_t, uint64_t);
  uint64_t v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unint64_t v40;
  unint64_t AssociatedConformanceWitness;
  char *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(char *, uint64_t);
  uint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  char *v61;
  unint64_t v62;
  char *v63;
  uint64_t v64;

  v56 = a5;
  v64 = a4;
  v54 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a7, a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = type metadata accessor for Optional(0, AssociatedTypeWitness, v11, v12);
  v51 = *(_QWORD *)(v13 - 8);
  v52 = v13;
  v14 = MEMORY[0x1E0C80A78](v13);
  v63 = (char *)&v51 - v15;
  v55 = AssociatedTypeWitness;
  v16 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v17 = MEMORY[0x1E0C80A78](v14);
  v59 = (char *)&v51 - v18;
  v19 = *(_QWORD *)(a6 - 8);
  v20 = MEMORY[0x1E0C80A78](v17);
  v58 = (uint64_t)&v51 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v20);
  v24 = (char *)&v51 - v23;
  MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v51 - v25;
  v62 = swift_getAssociatedTypeWitness(0, (const char *)a7, a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v53 = *(_QWORD *)(v62 - 8);
  MEMORY[0x1E0C80A78](v62);
  v28 = (char *)&v51 - v27;
  v57 = v19;
  v29 = *(void (**)(char *, uint64_t, uint64_t))(v19 + 16);
  v29(v26, a3, a6);
  v30 = *(void (**)(uint64_t, uint64_t))(a7 + 32);
  v61 = v28;
  v30(a6, a7);
  v31 = *(_QWORD *)(v16 + 72);
  v29(v24, a3, a6);
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a7 + 40);
  v60 = a7;
  v33 = v32(a6, a7);
  if (!v64)
  {
    v45 = v58;
    if (!v31)
      goto LABEL_26;
    if (v33 <= 0)
    {
      v46 = *(void (**)(char *, uint64_t))(v57 + 8);
      v46(v24, a6);
      v29((char *)v45, a3, a6);
      if (!v32(a6, v60))
      {
        v46((char *)v45, a6);
        (*(void (**)(uint64_t, char *, unint64_t))(v53 + 32))(v54, v61, v62);
        return v64;
      }
LABEL_30:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "no memory available to initialize from source", 45, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x2A9uLL, 0);
    }
LABEL_27:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "insufficient space to accommodate source.underestimatedCount elements", 69, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x2A5uLL, 0);
  }
  if (!v31)
    goto LABEL_26;
  v34 = v56;
  v58 = v56 - v64;
  if (v56 - v64 == 0x8000000000000000 && v31 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  if (v58 / v31 < v33)
    goto LABEL_27;
  (*(void (**)(char *, uint64_t))(v57 + 8))(v24, a6);
  v35 = v64;
  if ((*(_BYTE *)(v16 + 80) & v64) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "buffer base address must be properly aligned to access S.Element", 64, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x2AEuLL, 0);
  if (__OFSUB__(0, v31))
  {
    __break(1u);
    goto LABEL_30;
  }
  v36 = 0;
  v37 = v34 - v31 + 1;
  v38 = v55;
  while (1)
  {
    v39 = v37 >= v35 + v36;
    if (v31 > 0)
      v39 = v35 + v36 >= v37;
    if (v39)
      goto LABEL_23;
    v40 = v62;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v60, a6, v62, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
    (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16))(v40, AssociatedConformanceWitness);
    v42 = v63;
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t))(v16 + 48))(v63, 1, v38) == 1)
      break;
    v43 = v59;
    (*(void (**)(char *, char *, unint64_t))(v16 + 32))(v59, v42, v38);
    (*(void (**)(uint64_t, char *, unint64_t))(v16 + 16))(v35 + v36, v43, v38);
    (*(void (**)(char *, unint64_t))(v16 + 8))(v43, v38);
    v44 = v36 + v31;
    if (__OFADD__(v36, v31))
    {
      __break(1u);
LABEL_26:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    }
    if ((v44 & 0x8000000000000000) == 0)
    {
      v36 += v31;
      if (v58 >= v44)
        continue;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  (*(void (**)(char *, uint64_t))(v51 + 8))(v42, v52);
LABEL_23:
  v48 = v53;
  v50 = v61;
  v49 = v62;
  (*(void (**)(uint64_t, char *, unint64_t))(v53 + 16))(v54, v61, v62);
  (*(void (**)(char *, unint64_t))(v48 + 8))(v50, v49);
  if (v36 / v31 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  return v35;
}

uint64_t UnsafeMutableRawBufferPointer.bindMemory<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeRawBufferPointer.bindMemory<A>(to:)(a1, a2, a3, a4, "UnsafeMutableBufferPointer with negative count", 46, 0x47uLL);
}

uint64_t UnsafeRawBufferPointer.bindMemory<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, unint64_t a7)
{
  uint64_t v7;

  if (a2)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a4 - 8) + 72);
    if (!v7)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
    if (a3 - a2 == 0x8000000000000000 && v7 == -1)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
    if ((a3 - a2) / v7 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a5, a6, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a7, 0);
  }
  return a2;
}

uint64_t UnsafeMutableRawBufferPointer.load<A>(fromByteOffset:as:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;

  if (a1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.load with negative offset", 55, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x156uLL, 0);
  v5 = *(_QWORD *)(a4 - 8);
  v6 = *(_QWORD *)(v5 + 64);
  v7 = __OFADD__(a1, v6);
  v8 = a1 + v6;
  if (v7)
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x4F9uLL, 0);
  }
  if (!a2)
  {
    if (v8 < 1)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x159uLL, 0);
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.load out of bounds", 48, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x157uLL, 0);
  }
  if (a3 - a2 < v8)
    goto LABEL_12;
  if ((*(_BYTE *)(v5 + 80) & (a2 + a1)) != 0)
    goto LABEL_9;
  return (*(uint64_t (**)(uint64_t))(v5 + 16))(a5);
}

uint64_t UnsafeRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;

  if (a1 < 0)
    goto LABEL_12;
  if (a3)
  {
    if (a4 - a3 >= a2)
      goto LABEL_4;
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid slice", 13, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x5E5uLL, 0);
  }
  if (a2 >= 1)
    goto LABEL_12;
LABEL_4:
  if (a3)
    result = a3 + a1;
  else
    result = 0;
  v6 = a2 - a1;
  if (v6 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  if (v6)
  {
    if (!result)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
  }
  return result;
}

uint64_t UnsafeMutableBufferPointer.initialize(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.initialize(repeating:)(a1, a2, a3, a4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))UnsafeMutablePointer.initialize(repeating:count:));
}

Swift::Int __swiftcall Int.advanced(by:)(Swift::Int by)
{
  uint64_t v1;
  BOOL v2;
  Swift::Int result;

  v2 = __OFADD__(v1, by);
  result = v1 + by;
  if (v2)
    __break(1u);
  return result;
}

uint64_t UnsafeMutableBufferPointer.assign(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.initialize(repeating:)(a1, a2, a3, a4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))UnsafeMutablePointer.assign(repeating:count:));
}

uint64_t UnsafeMutableBufferPointer.initialize(repeating:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (a2)
    return a5(result, a3, a2);
  return result;
}

uint64_t specialized UnsafeMutableBufferPointer.update<A>(fromContentsOf:)(uint64_t a1, unint64_t a2, char *__dst, uint64_t a4)
{
  char *v7;
  int64_t v8;
  Swift::UInt64 v10;
  uint64_t v11;
  Swift::UInt64 rawBits;
  uint64_t v13;
  Swift::UInt8 v14;
  Swift::String::Index v15;
  Swift::String::Index v16;
  unint64_t v17;
  int64_t v18;
  unint64_t v19;
  _QWORD __src[2];

  if ((a2 & 0x1000000000000000) != 0)
  {
    if ((a2 & 0x2000000000000000) != 0)
      v10 = HIBYTE(a2) & 0xF;
    else
      v10 = a1 & 0xFFFFFFFFFFFFLL;
    if (a4)
    {
      v8 = 0;
      if (!v10)
        return v8;
      v11 = 4 << ((a1 & 0x800000000000000) != 0);
      rawBits = 15;
      v13 = a4 & ~(a4 >> 63);
      while (1)
      {
        if ((rawBits & 0xC) == v11)
        {
          v16._rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if (v10 <= v16._rawBits >> 16)
          {
LABEL_33:
            v17 = 228;
LABEL_34:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUTF8View.swift", 26, 2, v17, 0);
          }
          v14 = String.UTF8View._foreignSubscript(position:)(v16);
          rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
          if (rawBits >> 16 >= v10)
          {
            v17 = 144;
            goto LABEL_34;
          }
        }
        else
        {
          if (rawBits >> 16 >= v10)
            goto LABEL_33;
          v14 = String.UTF8View._foreignSubscript(position:)((Swift::String::Index)rawBits);
        }
        v15._rawBits = String.UTF8View._foreignIndex(after:)((Swift::String::Index)rawBits)._rawBits;
        if (v13 == v8)
          break;
        rawBits = v15._rawBits;
        __dst[v8++] = v14;
        if (4 * v10 == v15._rawBits >> 14)
          return v8;
      }
      v19 = 941;
    }
    else
    {
      if (!v10)
        return 0;
      v19 = 930;
    }
LABEL_30:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "buffer cannot contain every element from source.", 48, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v19, 0);
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      v7 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v8 = a1 & 0xFFFFFFFFFFFFLL;
      if ((a1 & 0xFFFFFFFFFFFFLL) <= a4)
        goto LABEL_5;
      goto LABEL_29;
    }
    v7 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
    if (v7)
    {
      v8 = v18;
      if (v18 <= a4)
      {
LABEL_5:
        if (__dst)
          goto LABEL_10;
        return v8;
      }
      goto LABEL_29;
    }
    return 0;
  }
  v8 = HIBYTE(a2) & 0xF;
  __src[0] = a1;
  __src[1] = a2 & 0xFFFFFFFFFFFFFFLL;
  if (v8 > a4)
  {
LABEL_29:
    v19 = 918;
    goto LABEL_30;
  }
  if (__dst)
  {
    v7 = (char *)__src;
LABEL_10:
    specialized UnsafeMutablePointer.moveInitialize(from:count:)(v7, v8, __dst, "UnsafeMutablePointer.update with negative count", 47, 0x3DEuLL);
  }
  return v8;
}

uint64_t _sSrsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_Sryqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSryxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5(uint64_t (*a1)(uint64_t, uint64_t, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v13;

  if (!a3)
    return a1(0, 0, &v13);
  v6 = *(_QWORD *)(a6 - 8);
  if ((*(_BYTE *)(v6 + 80) & a3) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "baseAddress must be a properly aligned pointer for types Element and T", 70, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x4D3uLL, 0);
  v7 = *(_QWORD *)(v6 + 72);
  v8 = *(_QWORD *)(*(_QWORD *)(a5 - 8) + 72);
  if (v7 != v8)
  {
    v9 = a4 * v8;
    if ((unsigned __int128)(a4 * (__int128)v8) >> 64 == (a4 * v8) >> 63)
    {
      if (v7)
      {
        if (v7 == -1 && v9 == 0x8000000000000000)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
        if (v8 >= v7)
        {
          if (v7 != -1 || v8 != 0x8000000000000000)
          {
            v11 = v8 % v7;
            goto LABEL_19;
          }
        }
        else
        {
          if (!v8)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x390EuLL, 0);
          if (v7 != 0x8000000000000000 || v8 != -1)
          {
            v11 = v7 % v8;
LABEL_19:
            if (v11)
              _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Buffer must contain a whole number of Element instances", 55, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x4DDuLL, 0);
            a4 = v9 / v7;
            goto LABEL_21;
          }
        }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3913uLL, 0);
      }
    }
    else
    {
      __break(1u);
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
LABEL_21:
  if (a4 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  return a1(a3, a4, &v13);
}

uint64_t UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a3, a4, a5);
}

{
  uint64_t v5;
  uint64_t result;

  result = a1(a2, a3);
  if (!v5)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 56))(a5, 0, 1, a4);
  return result;
}

void withVaList<A>(_:_:)(uint64_t a1, void (*a2)(void *))
{
  uint64_t v4;
  _QWORD *inited;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13[3];
  uint64_t v14;
  uint64_t v15;
  __int128 v16[2];
  _QWORD v17[6];

  v4 = type metadata accessor for __VaListBuilder();
  inited = swift_initStackObject(v4, v17);
  inited[2] = 8;
  inited[3] = 0;
  inited[4] = 0;
  inited[5] = 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (v6)
  {
    v7 = a1 + 32;
    do
    {
      outlined init with copy of MirrorPath(v7, (uint64_t)v16);
      outlined init with take of MirrorPath(v16, (uint64_t)v13);
      v8 = v14;
      v9 = v15;
      __swift_project_boxed_opaque_existential_0Tm(v13, v14);
      v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 8))(v8, v9);
      __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v10);
      swift_bridgeObjectRelease(v10);
      __swift_destroy_boxed_opaque_existential_1Tm(v13);
      v7 += 40;
      --v6;
    }
    while (v6);
    v11 = (void *)inited[5];
  }
  else
  {
    v11 = 0;
  }
  if (v11)
    v12 = v11;
  else
    v12 = &static __VaListBuilder.alignedStorageForEmptyVaLists;
  a2(v12);
  swift_setDeallocating((uint64_t)inited);
  if (v11)
  {
    if ((unint64_t)(inited[4] - 0x1000000000000000) >> 61 == 7)
      swift_slowDealloc(v11);
    else
      __break(1u);
  }
}

_QWORD *__VaListBuilder.__allocating_init()()
{
  uint64_t v0;
  _QWORD *result;

  result = swift_allocObject(v0, 0x30uLL, 7uLL);
  result[2] = 8;
  result[3] = 0;
  result[4] = 0;
  result[5] = 0;
  return result;
}

void __VaListBuilder.append(_:)(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1[3];
  v2 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v1);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 8))(v1, v2);
  __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v3);
  swift_bridgeObjectRelease(v3);
}

uint64_t _withVaList<A>(_:_:)(uint64_t a1, uint64_t (*a2)(void *))
{
  void *v2;

  if (*(_QWORD *)(a1 + 40))
    v2 = *(void **)(a1 + 40);
  else
    v2 = &static __VaListBuilder.alignedStorageForEmptyVaLists;
  return a2(v2);
}

Swift::CVaListPointer __swiftcall __VaListBuilder.va_list()()
{
  Swift::CVaListPointer *v0;

  if (v0[5]._value._rawValue)
    return (Swift::CVaListPointer)v0[5]._value._rawValue;
  else
    return (Swift::CVaListPointer)&static __VaListBuilder.alignedStorageForEmptyVaLists;
}

Swift::CVaListPointer __swiftcall getVaList(_:)(Swift::OpaquePointer a1)
{
  uint64_t v2;
  Swift::CVaListPointer *v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  Swift::CVaListPointer *v9;
  uint64_t v11[3];
  uint64_t v12;
  uint64_t v13;
  __int128 v14[2];

  v2 = type metadata accessor for __VaListBuilder();
  v3 = (Swift::CVaListPointer *)swift_allocObject(v2, 0x30uLL, 7uLL);
  v3[2]._value._rawValue = (Builtin::RawPointer)8;
  v3[3]._value._rawValue = 0;
  v3[4]._value._rawValue = 0;
  v3[5]._value._rawValue = 0;
  v4 = *((_QWORD *)a1._rawValue + 2);
  if (v4)
  {
    v5 = (char *)a1._rawValue + 32;
    do
    {
      outlined init with copy of MirrorPath((uint64_t)v5, (uint64_t)v14);
      outlined init with take of MirrorPath(v14, (uint64_t)v11);
      v6 = v12;
      v7 = v13;
      __swift_project_boxed_opaque_existential_0Tm(v11, v12);
      v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v6, v7);
      __VaListBuilder.appendWords(_:)((Swift::OpaquePointer)v8);
      swift_bridgeObjectRelease(v8);
      __swift_destroy_boxed_opaque_existential_1Tm(v11);
      v5 += 40;
      --v4;
    }
    while (v4);
  }
  v9 = v3;
  if (v3[5]._value._rawValue)
    return (Swift::CVaListPointer)v3[5]._value._rawValue;
  else
    return (Swift::CVaListPointer)&static __VaListBuilder.alignedStorageForEmptyVaLists;
}

__objc2_class **_encodeBitsAsWords<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  __objc2_class **v7;
  uint64_t v9;

  v4 = *(_QWORD *)(a2 - 8);
  v5 = *(_QWORD *)(v4 + 64);
  MEMORY[0x1E0C80A78](a1);
  if (__OFADD__(v5, 8))
  {
    __break(1u);
    goto LABEL_7;
  }
  v6 = v5 + 14;
  if ((uint64_t)(v5 + 8) >= 1)
    v6 = v5 + 7;
  v7 = specialized Array.init(repeating:count:)(0, (__objc2_class *)(v6 >> 3));
  (*(void (**)(char *, uint64_t, uint64_t))(v4 + 16))((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), a1, a2);
  (*(void (**)(char *, uint64_t))(v4 + 8))((char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), a2);
  if ((v5 & 0x8000000000000000) != 0)
LABEL_7:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  memcpy(v7 + 4, (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  return v7;
}

__objc2_class **Bool._cVarArgEncoding.getter(char a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1 & 1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Bool()
{
  char *v0;

  return Bool._cVarArgEncoding.getter(*v0);
}

uint64_t Int64._cVarArgAlignment.getter()
{
  return 8;
}

uint64_t protocol witness for _CVarArgAligned._cVarArgAlignment.getter in conformance Int64()
{
  return 8;
}

__objc2_class **Int16._cVarArgEncoding.getter(__int16 a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int16()
{
  __int16 *v0;
  int v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **Int8._cVarArgEncoding.getter(char a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int8()
{
  char *v0;
  int v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **Int._cVarArgEncoding.getter(__objc2_class *a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = a1;
  return result;
}

uint64_t UInt64._cVarArgAlignment.getter()
{
  return 8;
}

__objc2_class **Int32._cVarArgEncoding.getter(int a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int32()
{
  int *v0;
  int v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **UInt16._cVarArgEncoding.getter(unsigned __int16 a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance UInt16()
{
  unsigned __int16 *v0;
  int v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **UInt8._cVarArgEncoding.getter(unsigned __int8 a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = 0;
  *((_DWORD *)result + 8) = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance UInt8()
{
  unsigned __int8 *v0;
  int v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((_DWORD *)result + 8) = v1;
  return result;
}

__objc2_class **OpaquePointer._cVarArgEncoding.getter(__objc2_class *a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  result[4] = a1;
  return result;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Int()
{
  __objc2_class **v0;
  __objc2_class *v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  result[4] = v1;
  return result;
}

__objc2_class **UnsafePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter(a1, a2, (uint64_t (*)(_QWORD))type metadata accessor for UnsafePointer);
}

__objc2_class **_sSPyxGs7CVarArgsRi_zrlsABP05_cVarB8EncodingSaySiGvgTW(uint64_t a1)
{
  uint64_t *v1;

  return UnsafePointer._cVarArgEncoding.getter(*v1, *(_QWORD *)(a1 + 16));
}

__objc2_class **UnsafeMutablePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter(a1, a2, (uint64_t (*)(_QWORD))type metadata accessor for UnsafeMutablePointer);
}

__objc2_class **_sSpyxGs7CVarArgsRi_zrlsABP05_cVarB8EncodingSaySiGvgTW(uint64_t a1)
{
  uint64_t *v1;

  return UnsafeMutablePointer._cVarArgEncoding.getter(*v1, *(_QWORD *)(a1 + 16));
}

__objc2_class **AutoreleasingUnsafeMutablePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return UnsafePointer._cVarArgEncoding.getter(a1, a2, (uint64_t (*)(_QWORD))type metadata accessor for AutoreleasingUnsafeMutablePointer);
}

__objc2_class **UnsafePointer._cVarArgEncoding.getter(uint64_t a1, uint64_t a2, uint64_t (*a3)(_QWORD))
{
  uint64_t v3;
  uint64_t v5;

  v5 = a1;
  v3 = a3(0);
  return _encodeBitsAsWords<A>(_:)((uint64_t)&v5, v3);
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance AutoreleasingUnsafeMutablePointer<A>(uint64_t a1)
{
  uint64_t *v1;

  return AutoreleasingUnsafeMutablePointer._cVarArgEncoding.getter(*v1, *(_QWORD *)(a1 + 16));
}

double Float._cVarArgEncoding.getter(float a1)
{
  __objc2_class **v2;
  double result;

  v2 = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  v2[2] = (__objc2_class *)1;
  result = a1;
  *((double *)v2 + 4) = a1;
  return result;
}

Swift::Double __swiftcall Double.init(_:)(Swift::Float a1)
{
  return a1;
}

uint64_t Float._cVarArgAlignment.getter()
{
  return 8;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Float()
{
  float *v0;
  double v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  *((double *)result + 4) = v1;
  return result;
}

__objc2_class **Double._cVarArgEncoding.getter(double a1)
{
  __objc2_class **result;

  result = specialized static Array._allocateBufferUninitialized(minimumCapacity:)(1);
  result[2] = (__objc2_class *)1;
  *((double *)result + 4) = a1;
  return result;
}

uint64_t Double._cVarArgAlignment.getter()
{
  return 8;
}

__objc2_class **protocol witness for CVarArg._cVarArgEncoding.getter in conformance Double()
{
  __objc2_class **v0;
  __objc2_class *v1;
  __objc2_class **result;

  v1 = *v0;
  result = specialized Array.init(repeating:count:)(0, (__objc2_class *)1);
  result[4] = v1;
  return result;
}

_QWORD *__VaListBuilder.init()()
{
  _QWORD *v0;
  _QWORD *result;

  result = v0;
  v0[2] = 8;
  v0[3] = 0;
  v0[4] = 0;
  v0[5] = 0;
  return result;
}

Swift::Void __swiftcall __VaListBuilder.appendWords(_:)(Swift::OpaquePointer a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;

  v2 = v1[3];
  v3 = *((_QWORD *)a1._rawValue + 2);
  v4 = v2 + v3;
  if (__OFADD__(v2, v3))
  {
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  v6 = v1[4];
  if (v6 < v4)
  {
    if (v6 + 0x4000000000000000 < 0)
    {
LABEL_18:
      __break(1u);
LABEL_19:
      __break(1u);
      goto LABEL_20;
    }
    v7 = (char *)v1[5];
    if (2 * v6 > v4)
      v4 = 2 * v6;
    v1[4] = v4;
    if ((unint64_t)(v4 - 0x1000000000000000) >> 61 != 7)
      goto LABEL_19;
    v8 = (char *)swift_slowAlloc(8 * v4, 7uLL);
    v1[5] = v8;
    if (v7)
    {
      specialized UnsafeMutablePointer.moveInitialize(from:count:)(v7, v2, v8);
      if ((unint64_t)(v6 - 0x1000000000000000) >> 61 != 7)
      {
LABEL_20:
        __break(1u);
LABEL_21:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/VarArgs.swift", 19, 2, 0x29EuLL, 0);
      }
      swift_slowDealloc(v7);
    }
  }
  v9 = v1[5];
  if (!v9)
    goto LABEL_21;
  if (v3)
  {
    v10 = (uint64_t *)((char *)a1._rawValue + 32);
    v11 = v1[3];
    while (1)
    {
      v12 = *v10++;
      *(_QWORD *)(v9 + 8 * v11) = v12;
      v13 = v1[3];
      v14 = __OFADD__(v13, 1);
      v11 = v13 + 1;
      if (v14)
        break;
      v1[3] = v11;
      if (!--v3)
        return;
    }
    __break(1u);
    goto LABEL_17;
  }
}

unint64_t __VaListBuilder.allocStorage(wordCount:)(unint64_t result)
{
  if ((result - 0x1000000000000000) >> 61 == 7)
    return (unint64_t)swift_slowAlloc(8 * result, 7uLL);
  __break(1u);
  return result;
}

void __VaListBuilder.deallocStorage(wordCount:storage:)(uint64_t a1, void *a2)
{
  if ((unint64_t)(a1 - 0x1000000000000000) >> 61 == 7)
    swift_slowDealloc(a2);
  else
    __break(1u);
}

Swift::tuple_Builtin_Word_Builtin_Word __swiftcall __VaListBuilder.rawSizeAndAlignment(_:)(Swift::Int a1)
{
  Builtin::Word v1;
  Swift::tuple_Builtin_Word_Builtin_Word result;

  if ((unint64_t)(a1 - 0x1000000000000000) >> 61 == 7)
  {
    a1 *= 8;
    v1 = 8;
  }
  else
  {
    __break(1u);
  }
  result._1 = v1;
  result._0 = a1;
  return result;
}

void *__VaListBuilder.deinit()
{
  uint64_t v0;
  void *result;

  result = *(void **)(v0 + 40);
  if (!result)
    return (void *)v0;
  if ((unint64_t)(*(_QWORD *)(v0 + 32) - 0x1000000000000000) >> 61 == 7)
  {
    swift_slowDealloc(result);
    return (void *)v0;
  }
  __break(1u);
  return result;
}

void __VaListBuilder.__deallocating_deinit()
{
  uint64_t v0;
  void *v1;

  v1 = *(void **)(v0 + 40);
  if (!v1)
    goto LABEL_4;
  if ((unint64_t)(*(_QWORD *)(v0 + 32) - 0x1000000000000000) >> 61 == 7)
  {
    swift_slowDealloc(v1);
LABEL_4:
    swift_deallocClassInstance(v0);
    return;
  }
  __break(1u);
}

uint64_t __VaListBuilder.requiredAlignmentInBytes.getter()
{
  return 8;
}

uint64_t __VaListBuilder.count.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 24);
}

uint64_t __VaListBuilder.count.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 24) = result;
  return result;
}

uint64_t (*__VaListBuilder.count.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __VaListBuilder.allocated.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 32);
}

uint64_t __VaListBuilder.allocated.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 32) = result;
  return result;
}

uint64_t (*__VaListBuilder.allocated.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t __VaListBuilder.storage.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 40);
}

uint64_t __VaListBuilder.storage.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 40) = result;
  return result;
}

uint64_t (*__VaListBuilder.storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.init(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v13;
  _QWORD v15[4];

  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 32))(a7, a1);
  v15[0] = a3;
  v15[1] = a4;
  v15[2] = a5;
  v15[3] = a6;
  v13 = type metadata accessor for Zip2Sequence(0, (uint64_t)v15);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 32))(a7 + *(int *)(v13 + 52), a2, a4);
}

uint64_t Zip2Sequence._sequence2.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 24) - 8) + 16))(a2, v2 + *(int *)(a1 + 52));
}

uint64_t LazyMapSequence.Iterator._base.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  unint64_t AssociatedTypeWitness;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a1 + 32), *(_QWORD *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 16))(a2, v2, AssociatedTypeWitness);
}

uint64_t LazyMapSequence.Iterator._base.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t AssociatedTypeWitness;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a2 + 32), *(_QWORD *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 40))(v2, a1, AssociatedTypeWitness);
}

uint64_t (*Zip2Sequence.Iterator._baseStream1.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator._baseStream2.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;

  v4 = v2 + *(int *)(a1 + 52);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a1 + 40), *(_QWORD *)(a1 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 16))(a2, v4, AssociatedTypeWitness);
}

uint64_t Zip2Sequence.Iterator._baseStream2.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;

  v4 = v2 + *(int *)(a2 + 52);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a2 + 40), *(_QWORD *)(a2 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 40))(v4, a1, AssociatedTypeWitness);
}

uint64_t (*Zip2Sequence.Iterator._baseStream2.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator._reachedEnd.getter(uint64_t a1)
{
  uint64_t v1;

  return *(unsigned __int8 *)(v1 + *(int *)(a1 + 56));
}

uint64_t Zip2Sequence.Iterator._reachedEnd.setter(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + *(int *)(a2 + 56)) = result;
  return result;
}

uint64_t (*Zip2Sequence.Iterator._reachedEnd.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Zip2Sequence.Iterator.init(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, const char *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v14;
  unint64_t AssociatedTypeWitness;
  uint64_t v16;
  unint64_t v17;
  _QWORD v19[4];

  v19[0] = a3;
  v19[1] = a4;
  v19[2] = a5;
  v19[3] = a6;
  v14 = type metadata accessor for Zip2Sequence.Iterator(0, (uint64_t)v19);
  *(_BYTE *)(a7 + *(int *)(v14 + 56)) = 0;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 32))(a7, a1, AssociatedTypeWitness);
  v16 = a7 + *(int *)(v14 + 52);
  v17 = swift_getAssociatedTypeWitness(0, a6, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)(v17 - 8) + 32))(v16, a2, v17);
}

uint64_t Zip2Sequence.underestimatedCount.getter(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = (*(uint64_t (**)(_QWORD))(a1[4] + 40))(a1[2]);
  result = (*(uint64_t (**)(_QWORD))(a1[5] + 40))(a1[3]);
  if (result >= v2)
    return v2;
  return result;
}

uint64_t SIMD.indices.getter(uint64_t a1, uint64_t a2)
{
  if ((*(uint64_t (**)(void))(*(_QWORD *)(a2 + 48) + 40))() < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  return 0;
}

uint64_t SIMD.init(repeating:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(char *, uint64_t, unint64_t);
  uint64_t v14;
  uint64_t v15;

  v5 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v5, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v15 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v8 = (char *)&v14 - v7;
  (*(void (**)(uint64_t, uint64_t))(v5 + 48))(a2, v5);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a2, v5);
  if (v9 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v10 = v9;
  if (v9)
  {
    v11 = 0;
    v12 = *(void (**)(char *, uint64_t, unint64_t))(v15 + 16);
    do
    {
      v12(v8, a1, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v5 + 64))(v8, v11++, a2, v5);
    }
    while (v10 != v11);
  }
  return (*(uint64_t (**)(uint64_t, unint64_t))(v15 + 8))(a1, AssociatedTypeWitness);
}

uint64_t static SIMD.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t, uint64_t);
  char v23;
  void (*v24)(char *, uint64_t);
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t, uint64_t);
  char *v27;
  char *v28;
  void (*v29)(char *, uint64_t);
  void (*v30)(char *, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t AssociatedConformanceWitness;
  void (*v36)(char *, unint64_t);
  char *v37;
  char *v38;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  unint64_t AssociatedTypeWitness;
  char *v47;
  uint64_t v48;
  uint64_t v49;

  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v48 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v8 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v47 = (char *)&v40 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = MEMORY[0x1E0C80A78](v8);
  v45 = (char *)&v40 - v11;
  v12 = *(_QWORD *)(a3 - 8);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v40 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v40 - v16;
  v18 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  v49 = v7;
  v19 = v18(a3, v7);
  if (v19 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v19;
  if (v19)
  {
    v21 = 0;
    v22 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
    v23 = 1;
    v43 = a2;
    v44 = a1;
    v41 = v17;
    v42 = v19;
    v22(v17, a1, a3);
    while (1)
    {
      v22(v15, a2, a3);
      if ((v23 & 1) != 0)
      {
        v25 = v49;
        v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(v49 + 56);
        v27 = v45;
        v26(v21, a3, v49);
        v28 = v15;
        v29 = *(void (**)(char *, uint64_t))(v12 + 8);
        v29(v17, a3);
        v30 = v22;
        v31 = v12;
        v32 = v47;
        v26(v21, a3, v25);
        v29(v28, a3);
        v15 = v28;
        v33 = v25;
        v34 = AssociatedTypeWitness;
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v33, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
        v23 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                          + 8))(v27, v32, v34);
        v36 = *(void (**)(char *, unint64_t))(v48 + 8);
        v37 = v32;
        v12 = v31;
        v22 = v30;
        v17 = v41;
        v36(v37, v34);
        v38 = v27;
        v20 = v42;
        v36(v38, v34);
        a2 = v43;
        a1 = v44;
      }
      else
      {
        v24 = *(void (**)(char *, uint64_t))(v12 + 8);
        v24(v15, a3);
        v24(v17, a3);
        v23 = 0;
      }
      if (v20 == ++v21)
        break;
      v22(v17, a1, a3);
    }
  }
  else
  {
    v23 = 1;
  }
  return v23 & 1;
}

uint64_t SIMD.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t result;
  uint64_t v11;
  void (*v12)(void);
  uint64_t v13;
  unint64_t AssociatedConformanceWitness;
  uint64_t v15;
  uint64_t v16;

  v5 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v5, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v7 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v9 = (char *)&v15 - v8;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a2, v5);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v11 = result;
  v16 = a1;
  if (result)
  {
    result = 0;
    v12 = *(void (**)(void))(v5 + 56);
    do
    {
      v13 = result + 1;
      v12();
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      (*(void (**)(uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))(v16, AssociatedTypeWitness, AssociatedConformanceWitness);
      (*(void (**)(char *, unint64_t))(v7 + 8))(v9, AssociatedTypeWitness);
      result = v13;
    }
    while (v11 != v13);
  }
  return result;
}

uint64_t SIMD.encode(to:)(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t AssociatedConformanceWitness;
  uint64_t v27;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(char *, unint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v36[3];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v5 = v4;
  v6 = v3;
  v9 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v31 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v29 - v11;
  v13 = a1[3];
  v14 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v13);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v36, v13, v14);
  v15 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v32 = a2;
  v33 = v6;
  v34 = v9;
  v16 = v15(a2, v9);
  if (v16 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v17 = v16;
  if (v16)
  {
    v18 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v34 + 56);
    v19 = v32;
    while (1)
    {
      v39 = v5;
      v20 = v12;
      v21 = AssociatedTypeWitness;
      v22 = v34;
      v30(v18, v19, v34);
      v23 = v37;
      v24 = v38;
      __swift_mutable_project_boxed_opaque_existential_1(v36, v37);
      v35 = *(void (**)(char *, unint64_t, unint64_t, uint64_t, uint64_t))(v24 + 160);
      v25 = v22;
      AssociatedTypeWitness = v21;
      v12 = v20;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v25, v19, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Encodable);
      v27 = v39;
      v35(v20, AssociatedTypeWitness, AssociatedConformanceWitness, v23, v24);
      v5 = v27;
      if (v27)
        break;
      ++v18;
      (*(void (**)(char *, unint64_t))(v31 + 8))(v12, AssociatedTypeWitness);
      if (v17 == v18)
        return __swift_destroy_boxed_opaque_existential_1Tm(v36);
    }
    (*(void (**)(char *, unint64_t))(v31 + 8))(v12, AssociatedTypeWitness);
  }
  return __swift_destroy_boxed_opaque_existential_1Tm(v36);
}

uint64_t SIMD.init(from:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t (*v22)(void);
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  char v60;
  unint64_t v61;
  unint64_t v62;
  Swift::String v63;
  uint64_t countAndFlagsBits;
  void *object;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  void *v69;
  char v70;
  unint64_t v71;
  void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  char *v77;
  unint64_t AssociatedTypeWitness;
  char *v79;
  unint64_t v80;
  void *v81;
  uint64_t v82[3];
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;

  v75 = a4;
  v6 = *(char **)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v9 = (char *)&v73 - v8;
  v10 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v73 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*((void (**)(uint64_t, char *))v6 + 6))(a2, v6);
  v13 = a1[3];
  v14 = a1[4];
  v76 = a1;
  __swift_project_boxed_opaque_existential_0Tm(a1, v13);
  v15 = v85;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v14 + 32))(v82, v13, v14);
  if (v15)
  {
    (*(void (**)(char *, uint64_t))(v10 + 8))(v12, a2);
    v16 = v76;
    return __swift_destroy_boxed_opaque_existential_1Tm(v16);
  }
  v17 = v83;
  v18 = v84;
  __swift_project_boxed_opaque_existential_0Tm(v82, v83);
  v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v18 + 16))(v17, v18);
  LOBYTE(v18) = v20;
  v21 = a2;
  v22 = (uint64_t (*)(void))*((_QWORD *)v6 + 5);
  v77 = v12;
  v74 = v21;
  v23 = v22();
  v24 = v6;
  v73 = v10;
  if ((v18 & 1) != 0 || v19 != v23)
  {
    v85 = swift_allocError((uint64_t)&type metadata for DecodingError, (uint64_t)&protocol witness table for DecodingError, 0, 0);
    v35 = v34;
    v36 = v76[3];
    v37 = v76[4];
    __swift_project_boxed_opaque_existential_0Tm(v76, v36);
    v38 = (*(uint64_t (**)(uint64_t, uint64_t))(v37 + 8))(v36, v37);
    v39 = specialized static String._createEmpty(withInitialCapacity:)(41);
    v41 = v40;
    v80 = v39;
    v81 = (void *)v40;
    v42 = HIBYTE(v40) & 0xF;
    if ((v40 & 0x2000000000000000) == 0)
      v42 = v39 & 0xFFFFFFFFFFFFLL;
    if (v42 || (v39 & ~v40 & 0x2000000000000000) != 0)
    {
      if ((v40 & 0x2000000000000000) == 0
        || (0x8000000181763F90 & 0x2000000000000000) == 0
        || (v43 = specialized _SmallString.init(_:appending:)(v39, v40, 0xD00000000000001DLL, 0x8000000181763F90 | 0x8000000000000000), (v45 & 1) != 0))
      {
        if ((0x8000000181763F90 & 0x2000000000000000) != 0)
          v48 = (0x8000000181763F90 >> 56) & 0xF;
        else
          v48 = 29;
        _StringGuts.append(_:)(0xD00000000000001DLL, 0x8000000181763F90 | 0x8000000000000000, 0, v48);
        swift_bridgeObjectRelease(0x8000000181763F90 | 0x8000000000000000);
        v46 = v80;
        v47 = (unint64_t)v81;
LABEL_26:
        v50 = v77;
        v51 = v74;
        v52 = ((uint64_t (*)(uint64_t, char *))v22)(v74, v24);
        (*(void (**)(char *, uint64_t))(v73 + 8))(v50, v51);
        v54 = _int64ToString(_:radix:uppercase:)(v52, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
        v55 = v53;
        v56 = HIBYTE(v47) & 0xF;
        if ((v47 & 0x2000000000000000) == 0)
          v56 = v46 & 0xFFFFFFFFFFFFLL;
        if (!v56 && (v46 & ~v47 & 0x2000000000000000) == 0)
        {
          swift_bridgeObjectRelease(v47);
          v80 = v54;
          v81 = (void *)v55;
LABEL_39:
          v63 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(" elements.", 0xAuLL, 1);
          countAndFlagsBits = v63._countAndFlagsBits;
          object = v63._object;
          v66 = HIBYTE(v55) & 0xF;
          if ((v55 & 0x2000000000000000) == 0)
            v66 = v54 & 0xFFFFFFFFFFFFLL;
          if (!v66 && (v54 & ~v55 & 0x2000000000000000) == 0)
          {
            swift_bridgeObjectRelease(v55);
            goto LABEL_52;
          }
          if ((v55 & 0x2000000000000000) != 0)
          {
            if (((uint64_t)v63._object & 0x2000000000000000) != 0)
            {
              v68 = specialized _SmallString.init(_:appending:)(v54, v55, v63._countAndFlagsBits, (unint64_t)v63._object);
              if ((v70 & 1) == 0)
              {
                v71 = v68;
                v72 = v69;
                swift_bridgeObjectRelease(v55);
                swift_bridgeObjectRelease((uint64_t)v63._object);
                object = v72;
                countAndFlagsBits = v71;
LABEL_52:
                v16 = v76;
                *(_QWORD *)v35 = v38;
                *(_QWORD *)(v35 + 8) = countAndFlagsBits;
                *(_QWORD *)(v35 + 16) = object;
                *(_QWORD *)(v35 + 24) = 0;
                *(_BYTE *)(v35 + 72) = 3;
                swift_willThrow();
                __swift_destroy_boxed_opaque_existential_1Tm(v82);
                return __swift_destroy_boxed_opaque_existential_1Tm(v16);
              }
              goto LABEL_50;
            }
          }
          else if (((uint64_t)v63._object & 0x2000000000000000) != 0)
          {
LABEL_50:
            v67 = ((unint64_t)v63._object >> 56) & 0xF;
            goto LABEL_51;
          }
          v67 = v63._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
LABEL_51:
          _StringGuts.append(_:)(v63._countAndFlagsBits, (unint64_t)v63._object, 0, v67);
          swift_bridgeObjectRelease((uint64_t)v63._object);
          countAndFlagsBits = v80;
          object = v81;
          goto LABEL_52;
        }
        if ((v47 & 0x2000000000000000) != 0)
        {
          if ((v53 & 0x2000000000000000) != 0)
          {
            v58 = specialized _SmallString.init(_:appending:)(v46, v47, v54, v53);
            if ((v60 & 1) == 0)
            {
              v61 = v58;
              v62 = v59;
              swift_bridgeObjectRelease(v47);
              swift_bridgeObjectRelease(v55);
              v80 = v61;
              v81 = (void *)v62;
              v55 = v62;
              v54 = v61;
              goto LABEL_39;
            }
            goto LABEL_37;
          }
        }
        else if ((v53 & 0x2000000000000000) != 0)
        {
LABEL_37:
          v57 = HIBYTE(v55) & 0xF;
          goto LABEL_38;
        }
        v57 = v54 & 0xFFFFFFFFFFFFLL;
LABEL_38:
        _StringGuts.append(_:)(v54, v55, 0, v57);
        swift_bridgeObjectRelease(v55);
        v54 = v80;
        v55 = (unint64_t)v81;
        goto LABEL_39;
      }
      v46 = v43;
      v47 = v44;
      swift_bridgeObjectRelease(v41);
      swift_bridgeObjectRelease(0x8000000181763F90 | 0x8000000000000000);
    }
    else
    {
      v46 = 0xD00000000000001DLL;
      swift_bridgeObjectRelease(v40);
      v47 = 0x8000000181763F90 | 0x8000000000000000;
    }
    v80 = v46;
    v81 = (void *)v47;
    goto LABEL_26;
  }
  v25 = ((uint64_t (*)(uint64_t, char *))v22)(v74, v6);
  if (v25 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (v25)
  {
    v26 = 0;
    v85 = v6;
    v27 = v74;
    v79 = v9;
    v28 = AssociatedTypeWitness;
    do
    {
      v29 = v25;
      v31 = v83;
      v30 = v84;
      __swift_mutable_project_boxed_opaque_existential_1(v82, v83);
      v32 = *(void (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(v30 + 176);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v85, v27, v28, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Decodable);
      v32(v28, v28, AssociatedConformanceWitness, v31, v30);
      ((void (*)(char *, uint64_t, uint64_t))v85[8])(v79, v26++, v27);
      v25 = v29;
    }
    while (v29 != v26);
  }
  else
  {
    v27 = v74;
  }
  __swift_destroy_boxed_opaque_existential_1Tm(v82);
  (*(void (**)(uint64_t, char *, uint64_t))(v73 + 32))(v75, v77, v27);
  return __swift_destroy_boxed_opaque_existential_1Tm(v76);
}

unint64_t SIMD.description.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  Swift::Int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  unsigned __int8 *v23;
  unint64_t v24;
  unint64_t v25;
  Swift::String::Index v26;
  Swift::String::Index v27;
  Swift::String::Index v28;
  Swift::String::Index v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  int64_t v50;
  char v51;
  _BOOL8 v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  size_t v59;
  uint8x16_t *TypeName;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  size_t v64;
  uint64_t *v65;
  uint8x16_t *v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  uint8x16_t *v70;
  uint8x16_t *v71;
  uint8x16_t *v72;
  uint64_t v73;
  unsigned __int8 v74;
  int v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  BOOL v90;
  size_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  size_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  int64x2_t v110;
  int8x16_t v111;
  int8x16_t v112;
  int64x2_t v113;
  int64x2_t v114;
  int64x2_t v115;
  int64x2_t v116;
  uint8x8_t *v117;
  int8x16_t v118;
  unint64_t v119;
  int64x2_t v120;
  int8x16_t v121;
  int8x16_t v122;
  uint8x8_t v123;
  uint16x8_t v124;
  uint32x4_t v125;
  uint64x2_t v126;
  uint64x2_t v127;
  uint64x2_t v128;
  uint32x4_t v129;
  uint64x2_t v130;
  int8x16_t v131;
  uint16x8_t v132;
  int8x16_t v133;
  uint16x8_t v134;
  int8x16_t v135;
  int8x16_t v136;
  int8x8_t v137;
  int8x16_t v138;
  int8x8_t v139;
  uint64x2_t v140;
  int8x16_t v141;
  int8x16_t v142;
  int8x16_t v143;
  int8x16_t v144;
  unsigned __int8 *v145;
  unint64_t v146;
  unsigned int v147;
  unint64_t v148;
  int8x8_t v149;
  unint64_t v150;
  unint64_t v151;
  int64x2_t v152;
  int8x16_t v153;
  int8x16_t v154;
  int64x2_t v155;
  int64x2_t v156;
  int64x2_t v157;
  int64x2_t v158;
  uint8x8_t *v159;
  int8x16_t v160;
  unint64_t v161;
  int64x2_t v162;
  int8x16_t v163;
  int8x16_t v164;
  uint8x8_t v165;
  uint16x8_t v166;
  uint32x4_t v167;
  uint64x2_t v168;
  uint64x2_t v169;
  uint64x2_t v170;
  uint32x4_t v171;
  uint64x2_t v172;
  int8x16_t v173;
  uint8x16_t *v174;
  int64x2_t v175;
  int64x2_t v176;
  int64x2_t v177;
  int64x2_t v178;
  int64x2_t v179;
  int64x2_t v180;
  int8x16_t v181;
  int64x2_t v182;
  int64x2_t v183;
  int8x16_t v184;
  int8x16_t v185;
  int64x2_t v186;
  unint64_t v187;
  int8x16_t v188;
  int8x16_t v189;
  int8x16_t v190;
  int8x16_t v191;
  int8x16_t v192;
  int8x16_t v193;
  uint8x16_t v194;
  uint16x8_t v195;
  uint32x4_t v196;
  uint64x2_t v197;
  uint64x2_t v198;
  uint16x8_t v199;
  uint32x4_t v200;
  uint64x2_t v201;
  uint64x2_t v202;
  uint64x2_t v203;
  uint32x4_t v204;
  uint64x2_t v205;
  uint32x4_t v206;
  uint64x2_t v207;
  uint64x2_t v208;
  int8x16_t v209;
  uint64_t v210;
  unsigned __int8 *v211;
  unsigned int v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  char *v220;
  int64_t v221;
  int64_t v222;
  char v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  char *v227;
  unint64_t v228;
  unint64_t v229;
  unint64_t v230;
  Swift::String::Index v231;
  Swift::String::Index v232;
  Swift::String::Index v233;
  Swift::String::Index v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  char v243;
  unint64_t v244;
  unint64_t v245;
  uint64_t v246;
  char *v247;
  char *v248;
  size_t v249;
  char v250;
  unint64_t v251;
  unint64_t v252;
  unint64_t v253;
  unint64_t v254;
  unint64_t v255;
  unint64_t v256;
  char v257;
  uint64_t v258;
  unint64_t v259;
  unint64_t v260;
  unint64_t v261;
  id v262;
  uint64_t v263;
  uint64_t *v264;
  char *v265;
  size_t v266;
  unint64_t v267;
  unint64_t v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  Swift::Int v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  int64_t v278;
  int64_t v279;
  char v280;
  BOOL v282;
  uint64_t v283;
  uint64_t v284;
  char *v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  Swift::String::Index v289;
  Swift::String::Index v290;
  Swift::String::Index v291;
  Swift::String::Index v292;
  unint64_t v293;
  unint64_t v294;
  unint64_t v295;
  unint64_t v296;
  unint64_t v297;
  unint64_t v298;
  unint64_t v299;
  unint64_t v300;
  char v301;
  char *v302;
  size_t v303;
  uint64_t v304;
  uint64_t v305;
  __objc2_class **v306;
  unint64_t v307;
  unint64_t v308;
  unint64_t v309;
  unint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unint64_t v313;
  const char *v315;
  uint64_t v316;
  Swift::String::Index v317;
  Swift::String::Index v318;
  Swift::String::Index v319;
  Swift::String::Index v320;
  Swift::Int v321;
  Swift::Int v322;
  unint64_t v323;
  unsigned __int8 *v324;
  uint64_t v325;
  uint64_t *v326;
  unint64_t v327;
  unint64_t v328;
  unint64_t v329;
  uint64_t v330;
  uint64_t v331;
  unint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  __int128 v338;
  uint64_t v339;
  unint64_t v340;
  size_t v341;
  uint64_t v342;

  v4 = v2;
  v7 = specialized static String._createEmpty(withInitialCapacity:)(3);
  v11 = v7;
  v12 = v8;
  v339 = v7;
  v340 = v8;
  v13 = HIBYTE(v8) & 0xF;
  v14 = v7 & 0xFFFFFFFFFFFFLL;
  if ((v8 & 0x2000000000000000) != 0)
    v15 = HIBYTE(v8) & 0xF;
  else
    v15 = v7 & 0xFFFFFFFFFFFFLL;
  if (v15 || (v7 & ~v8 & 0x2000000000000000) != 0)
  {
    if ((v8 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v8);
      swift_bridgeObjectRelease(0xE000000000000000);
      v49 = 0xA000000000000000;
      if (!(v12 & 0x80808080808080 | v11 & 0x8080808080808080))
        v49 = 0xE000000000000000;
      v48 = v49 & 0xFF00000000000000 | (v13 << 56) | v12 & 0xFFFFFFFFFFFFFFLL;
      v339 = v11;
      goto LABEL_38;
    }
    swift_bridgeObjectRetain_n(0xE000000000000000, 6, v9, v10);
    v16 = v14;
    if ((v12 & 0x1000000000000000) != 0)
    {
      v16 = String.UTF8View._foreignCount()();
      v17 = v11 & ~v12;
      if ((v17 & 0x2000000000000000) == 0)
        goto LABEL_40;
    }
    else
    {
      v17 = v11 & ~v12;
      if ((v17 & 0x2000000000000000) == 0)
        goto LABEL_40;
    }
    if (swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
    {
      v18 = _StringGuts.nativeUnusedCapacity.getter(v11, v12);
      if ((v19 & 1) != 0)
        goto LABEL_283;
      if (v16 <= 15 && (v18 & 0x8000000000000000) != 0)
      {
LABEL_13:
        swift_bridgeObjectRelease_n(0xE000000000000000, 5);
        if ((v12 & 0x1000000000000000) == 0)
        {
          if ((v11 & 0x1000000000000000) != 0)
          {
            v23 = (unsigned __int8 *)((v12 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            v23 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v12);
            v14 = v20;
          }
          swift_bridgeObjectRetain(v12, v20, v21, v22);
          closure #1 in _StringGuts._convertedToSmall()(v23, v14, &v338);
          swift_bridgeObjectRelease(v12);
          v25 = *((_QWORD *)&v338 + 1);
          v24 = v338;
          goto LABEL_17;
        }
        goto LABEL_273;
      }
LABEL_41:
      v50 = _StringGuts.nativeUnusedCapacity.getter(v11, v12);
      v53 = (v51 & 1) == 0 && v50 >= 0;
      if ((v17 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
      {
        if (v53)
          goto LABEL_59;
      }
      else if (v53)
      {
LABEL_58:
        _StringGuts.grow(_:)(v16);
LABEL_59:
        swift_bridgeObjectRelease_n(0xE000000000000000, 6);
        v338 = 0uLL;
        v58 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 0, (uint64_t)&v338, 0);
        _StringGuts.appendInPlace(_:isASCII:)(v58, v59, 1);
        swift_bridgeObjectRelease(0xE000000000000000);
        goto LABEL_60;
      }
      v54 = _StringGuts.nativeCapacity.getter(v11, v12);
      if ((v55 & 1) != 0)
        v56 = 0;
      else
        v56 = v54;
      if (v56 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_280;
      }
      v57 = 2 * v56;
      if (v57 > v16)
        v16 = v57;
      goto LABEL_58;
    }
LABEL_40:
    if (v16 <= 15)
      goto LABEL_13;
    goto LABEL_41;
  }
  swift_bridgeObjectRelease(v8);
  v48 = 0xE000000000000000;
  v339 = 0;
LABEL_38:
  while (2)
  {
    v340 = v48;
LABEL_60:
    TypeName = (uint8x16_t *)swift_getTypeName((Class *)a1, 0);
    if (v61 < 0)
    {
      LODWORD(v333) = 0;
      v332 = 1343;
      LOBYTE(v331) = 2;
      v315 = "UnsafeBufferPointer with negative count";
      v316 = 39;
      goto LABEL_262;
    }
    v64 = v61;
    v335 = v4;
    v336 = a2;
    v337 = a1;
    if (!v61)
    {
      v4 = 0;
      v3 = 0xE000000000000000;
LABEL_168:
      v53 = 0;
      goto LABEL_169;
    }
    v65 = (uint64_t *)TypeName;
    v66 = TypeName;
    if ((v61 & 0xFFFFFFFFFFFFFFF0) != 0)
    {
      if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0)
        goto LABEL_82;
      v66 = TypeName + 1;
      while (v66 < (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFF0])
      {
        v67 = v66->i64[0];
        v68 = v66->i64[1];
        ++v66;
        if (((v68 | v67) & 0x8080808080808080) != 0)
          goto LABEL_82;
      }
    }
    if (v66 < (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFF8])
    {
      if ((v66->i64[0] & 0x8080808080808080) != 0)
        goto LABEL_82;
      v66 = (uint8x16_t *)((char *)v66 + 8);
    }
    if (v66 < (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFFCLL])
    {
      if ((v66->i32[0] & 0x80808080) != 0)
        goto LABEL_82;
      v66 = (uint8x16_t *)((char *)v66 + 4);
    }
    if (v66 >= (uint8x16_t *)&TypeName->i8[v61 & 0xFFFFFFFFFFFFFFFELL])
    {
LABEL_78:
      if (v66 >= (uint8x16_t *)&TypeName->i8[v61] || (v66->i8[0] & 0x80000000) == 0)
      {
        if (v61 > 15)
        {
          v69 = 1;
LABEL_122:
          v3 = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v61, v61, v69 & 1);
          v53 = 0;
          v4 = *(_QWORD *)(v3 + 24);
          goto LABEL_169;
        }
LABEL_132:
        v105 = v61 - 8;
        v106 = 8;
        if (v61 < 8)
          v106 = v61;
        if ((v106 & 0x8000000000000000) == 0)
        {
          if (v106 >= 8)
          {
            if (v106 >= 0x10)
            {
              v107 = v106 & 0xFFFFFFFFFFFFFFF0;
              v132 = vmovl_high_u8(*TypeName);
              v133 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v132.i8);
              v134 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
              v135 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v134.i8);
              v136 = (int8x16_t)vmovl_high_u16(v132);
              v137 = (int8x8_t)vextq_s8(v136, v136, 8uLL).u64[0];
              v138 = (int8x16_t)vmovl_high_u16(v134);
              v139 = (int8x8_t)vextq_s8(v138, v138, 8uLL).u64[0];
              *(int8x8_t *)v138.i8 = vorr_s8(*(int8x8_t *)v138.i8, *(int8x8_t *)v136.i8);
              v140.i64[0] = v138.u32[0];
              v140.i64[1] = v138.u32[1];
              v141 = (int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1816ABC20);
              *(int8x8_t *)v136.i8 = vorr_s8(*(int8x8_t *)v135.i8, *(int8x8_t *)v133.i8);
              v140.i64[0] = v136.u32[0];
              v140.i64[1] = v136.u32[1];
              v142 = vorrq_s8((int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1816ABC10), v141);
              *(int8x8_t *)v136.i8 = vorr_s8(v139, v137);
              v140.i64[0] = v136.u32[0];
              v140.i64[1] = v136.u32[1];
              v143 = (int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1816ABC00);
              *(int8x8_t *)v133.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v135, v135, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v133, v133, 8uLL));
              v140.i64[0] = v133.u32[0];
              v140.i64[1] = v133.u32[1];
              v144 = vorrq_s8(v142, vorrq_s8((int8x16_t)vshlq_u64(v140, (uint64x2_t)xmmword_1816ABBF0), v143));
              v4 = (uint64_t)vorr_s8(*(int8x8_t *)v144.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v144, v144, 8uLL));
              if (v106 == (v106 & 0xFFFFFFFFFFFFFFF0))
                goto LABEL_149;
              v108 = 8 * v107;
              if ((v106 & 8) == 0)
                goto LABEL_147;
            }
            else
            {
              v4 = 0;
              v108 = 0;
              v107 = 0;
            }
            v109 = v107;
            v110 = vdupq_n_s64(v108);
            v107 = v106 & 0xFFFFFFFFFFFFFFF8;
            v108 = 8 * (v106 & 0xFFFFFFFFFFFFFFF8);
            v111 = 0uLL;
            v112 = (int8x16_t)(unint64_t)v4;
            v113 = vaddq_s64(v110, (int64x2_t)xmmword_1816ABC00);
            v114 = vaddq_s64(v110, (int64x2_t)xmmword_1816ABC20);
            v115 = vaddq_s64(v110, (int64x2_t)xmmword_1816ABBF0);
            v116 = vaddq_s64(v110, (int64x2_t)xmmword_1816ABC10);
            v117 = (uint8x8_t *)&TypeName->i8[v109];
            v118 = (int8x16_t)vdupq_n_s64(0x38uLL);
            v119 = v109 - (v106 & 0xFFFFFFFFFFFFFFF8);
            v120 = vdupq_n_s64(0x40uLL);
            v121 = 0uLL;
            v122 = 0uLL;
            do
            {
              v123 = *v117++;
              v124 = vmovl_u8(v123);
              v125 = vmovl_high_u16(v124);
              v126.i64[0] = v125.u32[2];
              v126.i64[1] = v125.u32[3];
              v127 = v126;
              v126.i64[0] = v125.u32[0];
              v126.i64[1] = v125.u32[1];
              v128 = v126;
              v129 = vmovl_u16(*(uint16x4_t *)v124.i8);
              v126.i64[0] = v129.u32[2];
              v126.i64[1] = v129.u32[3];
              v130 = v126;
              v126.i64[0] = v129.u32[0];
              v126.i64[1] = v129.u32[1];
              v122 = vorrq_s8((int8x16_t)vshlq_u64(v127, (uint64x2_t)vandq_s8((int8x16_t)v113, v118)), v122);
              v121 = vorrq_s8((int8x16_t)vshlq_u64(v128, (uint64x2_t)vandq_s8((int8x16_t)v114, v118)), v121);
              v111 = vorrq_s8((int8x16_t)vshlq_u64(v130, (uint64x2_t)vandq_s8((int8x16_t)v115, v118)), v111);
              v112 = vorrq_s8((int8x16_t)vshlq_u64(v126, (uint64x2_t)vandq_s8((int8x16_t)v116, v118)), v112);
              v114 = vaddq_s64(v114, v120);
              v115 = vaddq_s64(v115, v120);
              v116 = vaddq_s64(v116, v120);
              v113 = vaddq_s64(v113, v120);
              v119 += 8;
            }
            while (v119);
            v131 = vorrq_s8(vorrq_s8(v112, v121), vorrq_s8(v111, v122));
            v4 = (uint64_t)vorr_s8(*(int8x8_t *)v131.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v131, v131, 8uLL));
            if (v106 == v107)
            {
LABEL_149:
              if (v61 < 9)
              {
                v149 = 0;
LABEL_165:
                v213 = 0xA000000000000000;
                if (((*(_QWORD *)&v149 | v4) & 0x8080808080808080) == 0)
                  v213 = 0xE000000000000000;
                v3 = v213 | (v61 << 56) | *(_QWORD *)&v149;
                goto LABEL_168;
              }
              if (v105 < 8)
              {
                v148 = 0;
                v149 = 0;
                v150 = 0;
LABEL_163:
                v210 = v61 - v148 - 8;
                v211 = &TypeName->u8[v148 + 8];
                do
                {
                  v212 = *v211++;
                  *(_QWORD *)&v149 |= (unint64_t)v212 << (v150 & 0x38);
                  v150 += 8;
                  --v210;
                }
                while (v210);
                goto LABEL_165;
              }
              if (v105 >= 0x10)
              {
                v174 = (uint8x16_t *)&TypeName->u64[1];
                v148 = v105 & 0xFFFFFFFFFFFFFFF0;
                v175 = (int64x2_t)xmmword_1816ABCA0;
                v176 = (int64x2_t)xmmword_1816ABCB0;
                v177 = (int64x2_t)xmmword_1816ABCC0;
                v178 = (int64x2_t)xmmword_1816ABCD0;
                v179 = (int64x2_t)xmmword_1816ABC00;
                v180 = (int64x2_t)xmmword_1816ABC20;
                v181 = (int8x16_t)vdupq_n_s64(0x38uLL);
                v182 = vdupq_n_s64(0x80uLL);
                v183 = (int64x2_t)xmmword_1816ABBF0;
                v150 = 8 * (v105 & 0xFFFFFFFFFFFFFFF0);
                v184 = 0uLL;
                v185 = 0uLL;
                v186 = (int64x2_t)xmmword_1816ABC10;
                v187 = v105 & 0xFFFFFFFFFFFFFFF0;
                v188 = 0uLL;
                v189 = 0uLL;
                v190 = 0uLL;
                v191 = 0uLL;
                v192 = 0uLL;
                v193 = 0uLL;
                do
                {
                  v194 = *v174++;
                  v195 = vmovl_u8(*(uint8x8_t *)v194.i8);
                  v196 = vmovl_high_u16(v195);
                  v197.i64[0] = v196.u32[2];
                  v197.i64[1] = v196.u32[3];
                  v198 = v197;
                  v199 = vmovl_high_u8(v194);
                  v200 = vmovl_u16(*(uint16x4_t *)v199.i8);
                  v197.i64[0] = v200.u32[2];
                  v197.i64[1] = v200.u32[3];
                  v201 = v197;
                  v197.i64[0] = v200.u32[0];
                  v197.i64[1] = v200.u32[1];
                  v202 = v197;
                  v197.i64[0] = v196.u32[0];
                  v197.i64[1] = v196.u32[1];
                  v203 = v197;
                  v204 = vmovl_u16(*(uint16x4_t *)v195.i8);
                  v197.i64[0] = v204.u32[2];
                  v197.i64[1] = v204.u32[3];
                  v205 = v197;
                  v206 = vmovl_high_u16(v199);
                  v197.i64[0] = v206.u32[0];
                  v197.i64[1] = v206.u32[1];
                  v207 = v197;
                  v197.i64[0] = v204.u32[0];
                  v197.i64[1] = v204.u32[1];
                  v208 = v197;
                  v197.i64[0] = v206.u32[2];
                  v197.i64[1] = v206.u32[3];
                  v189 = vorrq_s8((int8x16_t)vshlq_u64(v198, (uint64x2_t)vandq_s8((int8x16_t)v179, v181)), v189);
                  v191 = vorrq_s8((int8x16_t)vshlq_u64(v201, (uint64x2_t)vandq_s8((int8x16_t)v177, v181)), v191);
                  v190 = vorrq_s8((int8x16_t)vshlq_u64(v202, (uint64x2_t)vandq_s8((int8x16_t)v178, v181)), v190);
                  v188 = vorrq_s8((int8x16_t)vshlq_u64(v203, (uint64x2_t)vandq_s8((int8x16_t)v180, v181)), v188);
                  v185 = vorrq_s8((int8x16_t)vshlq_u64(v205, (uint64x2_t)vandq_s8((int8x16_t)v183, v181)), v185);
                  v192 = vorrq_s8((int8x16_t)vshlq_u64(v207, (uint64x2_t)vandq_s8((int8x16_t)v176, v181)), v192);
                  v184 = vorrq_s8((int8x16_t)vshlq_u64(v208, (uint64x2_t)vandq_s8((int8x16_t)v186, v181)), v184);
                  v193 = vorrq_s8((int8x16_t)vshlq_u64(v197, (uint64x2_t)vandq_s8((int8x16_t)v175, v181)), v193);
                  v180 = vaddq_s64(v180, v182);
                  v183 = vaddq_s64(v183, v182);
                  v186 = vaddq_s64(v186, v182);
                  v179 = vaddq_s64(v179, v182);
                  v178 = vaddq_s64(v178, v182);
                  v177 = vaddq_s64(v177, v182);
                  v176 = vaddq_s64(v176, v182);
                  v175 = vaddq_s64(v175, v182);
                  v187 -= 16;
                }
                while (v187);
                v209 = vorrq_s8(vorrq_s8(vorrq_s8(v184, v190), vorrq_s8(v188, v192)), vorrq_s8(vorrq_s8(v185, v191), vorrq_s8(v189, v193)));
                v149 = vorr_s8(*(int8x8_t *)v209.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v209, v209, 8uLL));
                if (v105 == v148)
                  goto LABEL_165;
                if ((v105 & 8) == 0)
                  goto LABEL_163;
              }
              else
              {
                v149 = 0;
                v150 = 0;
                v148 = 0;
              }
              v151 = v148;
              v148 = v105 & 0xFFFFFFFFFFFFFFF8;
              v152 = vdupq_n_s64(v150);
              v150 = 8 * (v105 & 0xFFFFFFFFFFFFFFF8);
              v153 = (int8x16_t)(unint64_t)v149;
              v154 = 0uLL;
              v155 = vaddq_s64(v152, (int64x2_t)xmmword_1816ABC00);
              v156 = vaddq_s64(v152, (int64x2_t)xmmword_1816ABC20);
              v157 = vaddq_s64(v152, (int64x2_t)xmmword_1816ABBF0);
              v158 = vaddq_s64(v152, (int64x2_t)xmmword_1816ABC10);
              v159 = (uint8x8_t *)((char *)&TypeName->u64[1] + v151);
              v160 = (int8x16_t)vdupq_n_s64(0x38uLL);
              v161 = v151 - (v105 & 0xFFFFFFFFFFFFFFF8);
              v162 = vdupq_n_s64(0x40uLL);
              v163 = 0uLL;
              v164 = 0uLL;
              do
              {
                v165 = *v159++;
                v166 = vmovl_u8(v165);
                v167 = vmovl_high_u16(v166);
                v168.i64[0] = v167.u32[2];
                v168.i64[1] = v167.u32[3];
                v169 = v168;
                v168.i64[0] = v167.u32[0];
                v168.i64[1] = v167.u32[1];
                v170 = v168;
                v171 = vmovl_u16(*(uint16x4_t *)v166.i8);
                v168.i64[0] = v171.u32[2];
                v168.i64[1] = v171.u32[3];
                v172 = v168;
                v168.i64[0] = v171.u32[0];
                v168.i64[1] = v171.u32[1];
                v164 = vorrq_s8((int8x16_t)vshlq_u64(v169, (uint64x2_t)vandq_s8((int8x16_t)v155, v160)), v164);
                v163 = vorrq_s8((int8x16_t)vshlq_u64(v170, (uint64x2_t)vandq_s8((int8x16_t)v156, v160)), v163);
                v154 = vorrq_s8((int8x16_t)vshlq_u64(v172, (uint64x2_t)vandq_s8((int8x16_t)v157, v160)), v154);
                v153 = vorrq_s8((int8x16_t)vshlq_u64(v168, (uint64x2_t)vandq_s8((int8x16_t)v158, v160)), v153);
                v156 = vaddq_s64(v156, v162);
                v157 = vaddq_s64(v157, v162);
                v158 = vaddq_s64(v158, v162);
                v155 = vaddq_s64(v155, v162);
                v161 += 8;
              }
              while (v161);
              v173 = vorrq_s8(vorrq_s8(v153, v163), vorrq_s8(v154, v164));
              v149 = vorr_s8(*(int8x8_t *)v173.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v173, v173, 8uLL));
              if (v105 == v148)
                goto LABEL_165;
              goto LABEL_163;
            }
          }
          else
          {
            v107 = 0;
            v4 = 0;
            v108 = 0;
          }
LABEL_147:
          v145 = &TypeName->u8[v107];
          v146 = v106 - v107;
          do
          {
            v147 = *v145++;
            v4 |= (unint64_t)v147 << (v108 & 0x38);
            v108 += 8;
            --v146;
          }
          while (v146);
          goto LABEL_149;
        }
LABEL_260:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
      }
      goto LABEL_82;
    }
    if ((v66->i16[0] & 0x8080) == 0)
    {
      v66 = (uint8x16_t *)((char *)v66 + 2);
      goto LABEL_78;
    }
LABEL_82:
    v12 = 0;
    v70 = (uint8x16_t *)((char *)TypeName + v61);
    v69 = 1;
    v71 = TypeName;
    v72 = TypeName;
    while (1)
    {
      v75 = v72->i8[0];
      v72 = (uint8x16_t *)((char *)v72 + 1);
      v74 = v75;
      if (v75 < 0)
        break;
      v73 = 1;
LABEL_84:
      v12 += v73;
      v71 = v72;
      if (v72 == v70)
      {
        if (v61 > 15)
          goto LABEL_122;
        goto LABEL_132;
      }
    }
    if ((v74 + 62) > 0x32u)
      goto LABEL_123;
    if (v74 <= 0xDFu)
    {
      if (v72 == v70 || (v72->i8[0] & 0xC0) != 0x80)
        goto LABEL_123;
      v69 = 0;
      v72 = (uint8x16_t *)&v71->i16[1];
      v73 = 2;
      goto LABEL_84;
    }
    if (v74 == 224)
    {
      if (v72 == v70 || (v71->i8[1] & 0xE0) != 0xA0)
        goto LABEL_123;
      goto LABEL_102;
    }
    if (v74 <= 0xECu)
    {
LABEL_96:
      if (v72 == v70)
        goto LABEL_123;
      LOBYTE(v76) = v71->i8[1];
LABEL_101:
      if ((v76 & 0xC0) != 0x80)
        goto LABEL_123;
LABEL_102:
      if (&v71->i16[1] == (__int16 *)v70 || (v71->i8[2] & 0xC0) != 0x80)
        goto LABEL_123;
      v69 = 0;
      v72 = (uint8x16_t *)((char *)v71->i32 + 3);
      v73 = 3;
      goto LABEL_84;
    }
    if (v74 == 237)
    {
      if (v72 == v70)
        goto LABEL_123;
      v76 = v71->u8[1];
      if (v76 > 0x9F)
        goto LABEL_123;
      goto LABEL_101;
    }
    if (v74 <= 0xEFu)
      goto LABEL_96;
    if (v74 == 240)
    {
      if (v72 == v70 || (v71->i8[1] + 64) < 0xD0u)
        goto LABEL_123;
      goto LABEL_116;
    }
    if ((v74 + 15) <= 2u)
    {
      if (v72 == v70)
        goto LABEL_123;
      LOBYTE(v77) = v71->i8[1];
LABEL_115:
      if ((v77 & 0xC0) != 0x80)
        goto LABEL_123;
LABEL_116:
      if (&v71->i16[1] == (__int16 *)v70
        || (v71->i8[2] & 0xC0) != 0x80
        || (uint8x16_t *)((char *)v71->i32 + 3) == v70
        || (v71->i8[3] & 0xC0) != 0x80)
      {
        goto LABEL_123;
      }
      v69 = 0;
      v72 = (uint8x16_t *)((char *)v71->i64 + 4);
      v73 = 4;
      goto LABEL_84;
    }
    if (v72 != v70)
    {
      v77 = v71->u8[1];
      if (v77 <= 0x8F)
        goto LABEL_115;
    }
LABEL_123:
    v11 = (Swift::Int)swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease((id)v11);
    v78 = specialized Collection.subscript.getter(v12, (uint64_t)v65, v64);
    v83 = findInvalidRange #1 (_:) in validateUTF8(_:)(v78, v79, v80, v81);
    *(_QWORD *)&v338 = 0;
    *((_QWORD *)&v338 + 1) = 0xE000000000000000;
    if (__OFADD__(v64, 15))
      goto LABEL_272;
    v84 = v82;
    _StringGuts.reserveCapacity(_:)(v64 + 15);
    v53 = 0;
    while (2)
    {
      v85 = specialized Collection.subscript.getter(v83, (uint64_t)v65, v64);
      v89 = v338 & 0xFFFFFFFFFFFFLL;
      if ((*((_QWORD *)&v338 + 1) & 0x2000000000000000) != 0)
        v89 = HIBYTE(*((_QWORD *)&v338 + 1)) & 0xFLL;
      v90 = __OFADD__(v89, v64);
      v91 = v89 + v64;
      if (v90)
      {
        __break(1u);
LABEL_259:
        __break(1u);
        goto LABEL_260;
      }
      v92 = v85;
      if (__OFADD__(v91, 3))
        goto LABEL_259;
      v93 = v86;
      v94 = v87;
      v95 = v88;
      _StringGuts.reserveCapacity(_:)(v91 + 3);
      v96 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v92, v93, v94, v95);
      _StringGuts.appendInPlace(_:isASCII:)(v96, v97, 0);
      v341 = 3;
      v342 = 12435439;
      specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v342, &v341, &v338);
      v98 = specialized Collection.subscript.getter(v84, (uint64_t)v65, v64);
      v65 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v98, v99, v100, v101);
      v64 = v102;
      v103 = validateUTF8(_:)(v65, v102);
      if ((v62 & 1) != 0)
      {
        v83 = v103;
        v84 = v104;
        if (!v64)
          goto LABEL_138;
        continue;
      }
      break;
    }
    _StringGuts.appendInPlace(_:isASCII:)((char *)v65, v64, 0);
LABEL_138:
    v3 = *((_QWORD *)&v338 + 1);
    v4 = v338;
    a1 = v337;
LABEL_169:
    v214 = v339;
    v12 = v340;
    v215 = HIBYTE(v340) & 0xF;
    if ((v340 & 0x2000000000000000) != 0)
      v216 = HIBYTE(v340) & 0xF;
    else
      v216 = v339 & 0xFFFFFFFFFFFFLL;
    if (!v216 && (v339 & ~v340 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v340);
      v339 = v4;
      v340 = v3;
      goto LABEL_220;
    }
    a1 = v3 & 0x2000000000000000;
    a2 = HIBYTE(v3) & 0xF;
    if ((v340 & 0x2000000000000000) == 0 || !a1)
      goto LABEL_178;
    v217 = v215 + a2;
    if (v215 + a2 <= 0xF)
    {
      a1 = v337;
      if (a2)
      {
        v250 = 0;
        v251 = 0;
        v252 = v340;
        do
        {
          v253 = v215 + v251;
          v254 = v251 + 1;
          if (v251 >= 8)
            v255 = v3;
          else
            v255 = v4;
          v256 = v255 >> (v250 & 0x38);
          v257 = (8 * v215 + v250) & 0x38;
          v258 = (-255 << v257) - 1;
          v259 = (unint64_t)v256 << v257;
          v260 = v259 | v258 & v252;
          v261 = v259 | v258 & v214;
          if (v253 < 8)
            v214 = v261;
          else
            v252 = v260;
          v250 += 8;
          v251 = v254;
        }
        while (a2 != v254);
      }
      else
      {
        v252 = v340;
      }
      swift_bridgeObjectRelease(v340);
      swift_bridgeObjectRelease(v3);
      v267 = 0xA000000000000000;
      if (!(v214 & 0x8080808080808080 | v252 & 0x80808080808080))
        v267 = 0xE000000000000000;
      v339 = v214;
      v340 = v267 & 0xFF00000000000000 | (v217 << 56) | v252 & 0xFFFFFFFFFFFFFFLL;
      goto LABEL_220;
    }
    a1 = 1;
LABEL_178:
    v334 = v4 & 0xFFFFFFFFFFFFLL;
    if (a1)
      v218 = HIBYTE(v3) & 0xF;
    else
      v218 = v4 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v3, 2, v62, v63);
    if ((v3 & 0x1000000000000000) == 0)
    {
      swift_bridgeObjectRetain_n(v3, 4, v219, v220);
      v11 = v218;
      if ((v12 & 0x1000000000000000) == 0)
        goto LABEL_183;
LABEL_266:
      v321 = String.UTF8View._foreignCount()();
      v221 = v321 + v11;
      if (!__OFADD__(v321, v11))
        goto LABEL_184;
LABEL_268:
      __break(1u);
LABEL_269:
      v322 = String.UTF8View._foreignCount()();
      v278 = v322 + 1;
      if (!__OFADD__(v322, 1))
        goto LABEL_238;
LABEL_271:
      __break(1u);
LABEL_272:
      __break(1u);
LABEL_273:
      v24 = _StringGuts._foreignConvertedToSmall()(v11, v12);
      v25 = v323;
LABEL_17:
      v26._rawBits = 1;
      v27._rawBits = 1;
      v28._rawBits = _StringGuts.validateScalarRange(_:)(v26, v27, 0, 0xE000000000000000);
      if (v28._rawBits < 0x10000)
        v28._rawBits |= 3;
      v30 = specialized String.init(_:)(v28, v29, 0, 0xE000000000000000);
      v32 = v31;
      swift_bridgeObjectRelease(0xE000000000000000);
      if ((v32 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v32);
      }
      else if ((v32 & 0x1000000000000000) != 0)
      {
        v30 = _StringGuts._foreignConvertedToSmall()(v30, v32);
        v329 = v328;
        swift_bridgeObjectRelease(v32);
        v32 = v329;
      }
      else
      {
        if ((v30 & 0x1000000000000000) != 0)
        {
          v324 = (unsigned __int8 *)((v32 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v325 = v30 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v324 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v30, v32);
        }
        closure #1 in _StringGuts._convertedToSmall()(v324, v325, &v338);
        swift_bridgeObjectRelease(v32);
        v32 = *((_QWORD *)&v338 + 1);
        v30 = v338;
      }
      v33 = HIBYTE(v25) & 0xF;
      v34 = HIBYTE(v32) & 0xF;
      v35 = v34 + v33;
      if ((unint64_t)(v34 + v33) <= 0xF)
      {
        if (v34)
        {
          v36 = 0;
          v37 = 0;
          do
          {
            v38 = v33 + v37;
            v39 = v37 + 1;
            if (v37 >= 8)
              v40 = v32;
            else
              v40 = v30;
            v41 = v40 >> (v36 & 0x38);
            v42 = (8 * v33 + v36) & 0x38;
            v43 = (-255 << v42) - 1;
            v44 = (unint64_t)v41 << v42;
            v45 = v44 | v43 & v25;
            v46 = v44 | v43 & v24;
            if (v38 < 8)
              v24 = v46;
            else
              v25 = v45;
            v36 += 8;
            v37 = v39;
          }
          while (v34 != v39);
        }
        swift_bridgeObjectRelease(v12);
        swift_bridgeObjectRelease(0xE000000000000000);
        v47 = 0xA000000000000000;
        if (!(v24 & 0x8080808080808080 | v25 & 0x80808080808080))
          v47 = 0xE000000000000000;
        v48 = v47 & 0xFF00000000000000 | (v35 << 56) | v25 & 0xFFFFFFFFFFFFFFLL;
        v339 = v24;
        continue;
      }
LABEL_282:
      v327 = 266;
LABEL_284:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v327, 0);
    }
    break;
  }
  swift_bridgeObjectRetain_n(v3, 5, v219, v220);
  v317._rawBits = 1;
  v318._rawBits = (v218 << 16) | 1;
  v319._rawBits = _StringGuts.validateScalarRange(_:)(v317, v318, v4, v3);
  if (v319._rawBits < 0x10000)
    v319._rawBits |= 3;
  v11 = specialized Collection.count.getter(v319, v320, v4, v3);
  swift_bridgeObjectRelease(v3);
  if ((v12 & 0x1000000000000000) != 0)
    goto LABEL_266;
LABEL_183:
  v90 = __OFADD__(v216, v11);
  v221 = v216 + v11;
  if (v90)
    goto LABEL_268;
LABEL_184:
  if ((v214 & ~v12 & 0x2000000000000000) == 0
    || !swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
  {
    if (v221 <= 15)
      goto LABEL_191;
LABEL_197:
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v221, v11);
    swift_bridgeObjectRelease_n(v3, 4);
    if ((v3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v3);
      _StringGuts._foreignAppendInPlace(_:)(v4, v3, 0, v218);
      swift_bridgeObjectRelease_n(v3, 2);
      v4 = v335;
      a2 = v336;
      a1 = v337;
      goto LABEL_221;
    }
    if (a1)
    {
      swift_bridgeObjectRelease_n(v3, 2);
      *(_QWORD *)&v338 = v4;
      *((_QWORD *)&v338 + 1) = v3 & 0xFFFFFFFFFFFFFFLL;
      v248 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v3) & 0xF, (uint64_t)&v338, HIBYTE(v3) & 0xF);
      _StringGuts.appendInPlace(_:isASCII:)(v248, v249, (v3 & 0x4000000000000000) != 0);
      a1 = v337;
      swift_bridgeObjectRelease(v3);
LABEL_220:
      v4 = v335;
      a2 = v336;
      goto LABEL_221;
    }
    if ((v4 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v3);
      v262 = (id)((v3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v263 = v334;
      v264 = (uint64_t *)v334;
      a2 = v336;
      a1 = v337;
      goto LABEL_214;
    }
LABEL_280:
    v262 = _StringObject.sharedUTF8.getter(v4, v3);
    v264 = v326;
    swift_bridgeObjectRelease(v3);
    if ((uint64_t)v264 >= v334)
    {
      while (1)
      {
        a2 = v336;
        a1 = v337;
        v263 = v334;
LABEL_214:
        v265 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v263, (uint64_t)v262, (uint64_t)v264);
        v264 = &v339;
        _StringGuts.appendInPlace(_:isASCII:)(v265, v266, v4 < 0);
        if (!v53)
          break;
        swift_errorRelease((id)v53);
        swift_bridgeObjectRelease(v3);
        __break(1u);
      }
      swift_bridgeObjectRelease_n(v3, 2);
      goto LABEL_195;
    }
    LODWORD(v333) = 0;
    v332 = 1861;
    LOBYTE(v331) = 2;
    v315 = "";
    v316 = 0;
LABEL_262:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, v315, v316, 2, "Swift/UnsafeBufferPointer.swift", 31, v331, v332, v333);
  }
  v222 = _StringGuts.nativeUnusedCapacity.getter(v214, v12);
  if ((v223 & 1) != 0)
    goto LABEL_283;
  v224 = (v12 >> 61) & 1;
  if (v222 < v11)
    LODWORD(v224) = 1;
  if (v221 > 15 || !(_DWORD)v224)
    goto LABEL_197;
LABEL_191:
  swift_bridgeObjectRelease_n(v3, 5);
  swift_bridgeObjectRetain(v12, v225, v226, v227);
  v228 = _StringGuts._convertedToSmall()(v214, v12);
  v230 = v229;
  swift_bridgeObjectRelease(v12);
  v231._rawBits = (v218 << 16) | 1;
  v232._rawBits = 1;
  v233._rawBits = _StringGuts.validateScalarRange(_:)(v232, v231, v4, v3);
  if (v233._rawBits < 0x10000)
    v233._rawBits |= 3;
  v235 = specialized String.init(_:)(v233, v234, v4, v3);
  v237 = v236;
  swift_bridgeObjectRelease(v3);
  v238 = _StringGuts._convertedToSmall()(v235, v237);
  v240 = v239;
  swift_bridgeObjectRelease(v237);
  v241 = specialized _SmallString.init(_:appending:)(v228, v230, v238, v240);
  a2 = v336;
  a1 = v337;
  if ((v243 & 1) != 0)
    goto LABEL_282;
  v244 = v241;
  v245 = v242;
  swift_bridgeObjectRelease(v12);
  swift_bridgeObjectRelease(v3);
  v339 = v244;
  v340 = v245;
LABEL_195:
  v4 = v335;
LABEL_221:
  v11 = v339;
  v12 = v340;
  v268 = HIBYTE(v340) & 0xF;
  if ((v340 & 0x2000000000000000) != 0)
    v269 = HIBYTE(v340) & 0xF;
  else
    v269 = v339 & 0xFFFFFFFFFFFFLL;
  if (!v269 && (v339 & ~v340 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v340);
    v11 = 40;
    v339 = 40;
    v277 = 0xE100000000000000;
    goto LABEL_256;
  }
  if ((v340 & 0x2000000000000000) != 0 && v268 != 15)
  {
    v270 = 8 * (HIBYTE(v340) & 7);
    v271 = (-255 << v270) - 1;
    v272 = 40 << v270;
    v273 = v272 | v271 & v340;
    v274 = v272 | v271 & v339;
    if (v268 >= 8)
      v275 = v273;
    else
      v275 = v340;
    if (v268 < 8)
      v11 = v274;
    swift_bridgeObjectRelease(v340);
    swift_bridgeObjectRelease(0xE100000000000000);
    v276 = 0xA000000000000000;
    if (!(v11 & 0x8080808080808080 | v275 & 0x80808080808080))
      v276 = 0xE000000000000000;
    v277 = (v276 & 0xFF00000000000000 | (v268 << 56) | v275 & 0xFFFFFFFFFFFFFFLL) + 0x100000000000000;
    v339 = v11;
    v340 = v277;
    goto LABEL_256;
  }
  swift_bridgeObjectRetain_n(0xE100000000000000, 6, v246, v247);
  if ((v12 & 0x1000000000000000) != 0)
    goto LABEL_269;
  v90 = __OFADD__(v269, 1);
  v278 = v269 + 1;
  if (v90)
    goto LABEL_271;
LABEL_238:
  if ((v11 & ~v12 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v12 & 0xFFFFFFFFFFFFFFFLL))
  {
    v279 = _StringGuts.nativeUnusedCapacity.getter(v11, v12);
    if ((v280 & 1) == 0)
    {
      v282 = (v12 & 0x2000000000000000) == 0 && v279 > 0;
      if (v278 <= 15 && !v282)
        goto LABEL_249;
LABEL_254:
      _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v278, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 6);
      v338 = xmmword_1816ABF10;
      v302 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v338, 1);
      _StringGuts.appendInPlace(_:isASCII:)(v302, v303, 1);
      swift_bridgeObjectRelease(0xE100000000000000);
      v11 = v339;
      v277 = v340;
      goto LABEL_256;
    }
LABEL_283:
    v327 = 258;
    goto LABEL_284;
  }
  if (v278 > 15)
    goto LABEL_254;
LABEL_249:
  swift_bridgeObjectRelease_n(0xE100000000000000, 5);
  swift_bridgeObjectRetain(v12, v283, v284, v285);
  v286 = _StringGuts._convertedToSmall()(v11, v12);
  v288 = v287;
  swift_bridgeObjectRelease(v12);
  v289._rawBits = 1;
  v290._rawBits = 65537;
  v291._rawBits = _StringGuts.validateScalarRange(_:)(v289, v290, 0x28uLL, 0xE100000000000000);
  if (v291._rawBits < 0x10000)
    v291._rawBits |= 3;
  v293 = specialized String.init(_:)(v291, v292, 0x28uLL, 0xE100000000000000);
  v295 = v294;
  swift_bridgeObjectRelease(0xE100000000000000);
  v296 = _StringGuts._convertedToSmall()(v293, v295);
  v298 = v297;
  swift_bridgeObjectRelease(v295);
  v299 = specialized _SmallString.init(_:appending:)(v286, v288, v296, v298);
  if ((v301 & 1) != 0)
    goto LABEL_282;
  v11 = v299;
  v277 = v300;
  swift_bridgeObjectRelease(v12);
  swift_bridgeObjectRelease(0xE100000000000000);
  v339 = v11;
LABEL_256:
  v304 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 48) + 40))(a1);
  if (v304 < 0)
    goto LABEL_260;
  MEMORY[0x1E0C80A78](v304);
  v331 = a1;
  v332 = a2;
  v333 = v4;
  v306 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFSnySiG_SSs5NeverOTg5((void (*)(_QWORD *__return_ptr, uint64_t *))partial apply for closure #1 in SIMD.description.getter, (uint64_t)&v330, 0, v305);
  v307 = specialized BidirectionalCollection<>.joined(separator:)(8236, 0xE200000000000000, v306);
  v309 = v308;
  swift_bridgeObjectRelease((uint64_t)v306);
  swift_bridgeObjectRelease(0xE200000000000000);
  v310 = specialized static String.+ infix(_:_:)(v11, v277, v307, v309);
  v312 = v311;
  swift_bridgeObjectRelease(v277);
  swift_bridgeObjectRelease(v309);
  v313 = specialized static String.+ infix(_:_:)(v310, v312, 41, 0xE100000000000000);
  swift_bridgeObjectRelease(v312);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v313;
}

void closure #1 in SIMD.description.getter(uint64_t *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t *a4@<X8>)
{
  uint64_t v6;
  Class *AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unint64_t v30;

  v28 = a4;
  v6 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = (Class *)swift_getAssociatedTypeWitness(0, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v8 = (uint64_t)*(AssociatedTypeWitness - 1);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v10 = (char *)&v27 - v9;
  v11 = *a1;
  v12 = specialized static String._createEmpty(withInitialCapacity:)(2);
  v14 = v12;
  v15 = v13;
  v29 = v12;
  v30 = v13;
  v16 = HIBYTE(v13) & 0xF;
  v17 = v12 & 0xFFFFFFFFFFFFLL;
  if ((v13 & 0x2000000000000000) != 0)
    v17 = HIBYTE(v13) & 0xF;
  if (v17 || (v12 & ~v13 & 0x2000000000000000) != 0)
  {
    if ((v13 & 0x2000000000000000) == 0)
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      goto LABEL_12;
    }
    swift_bridgeObjectRelease(v13);
    v18 = 0xA000000000000000;
    if (!(v15 & 0x80808080808080 | v14 & 0x8080808080808080))
      v18 = 0xE000000000000000;
    v19 = v18 & 0xFF00000000000000 | (v16 << 56) | v15 & 0xFFFFFFFFFFFFFFLL;
    v29 = v14;
  }
  else
  {
    swift_bridgeObjectRelease(v13);
    v19 = 0xE000000000000000;
    v29 = 0;
  }
  v30 = v19;
LABEL_12:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56))(v11, a2, v6);
  _print_unlocked<A, B>(_:_:)((uint64_t)v10, (uint64_t)&v29, AssociatedTypeWitness, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  (*(void (**)(char *, Class *))(v8 + 8))(v10, AssociatedTypeWitness);
  v21 = v29;
  v20 = v30;
  v22 = HIBYTE(v30) & 0xF;
  v23 = v29 & 0xFFFFFFFFFFFFLL;
  if ((v30 & 0x2000000000000000) != 0)
    v23 = HIBYTE(v30) & 0xF;
  if (v23 || (v29 & ~v30 & 0x2000000000000000) != 0)
  {
    if ((v30 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v30);
      v25 = 0xA000000000000000;
      if (!(v20 & 0x80808080808080 | v21 & 0x8080808080808080))
        v25 = 0xE000000000000000;
      v24 = v25 & 0xFF00000000000000 | (v22 << 56) | v20 & 0xFFFFFFFFFFFFFFLL;
    }
    else
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      v21 = v29;
      v24 = v30;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v30);
    v21 = 0;
    v24 = 0xE000000000000000;
  }
  v26 = v28;
  *v28 = v21;
  v26[1] = v24;
}

uint64_t static SIMD..== infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t result;
  unint64_t v22;
  void (*v23)(_QWORD, _QWORD, _QWORD);
  char *v24;
  char *v25;
  const char *v26;
  unint64_t AssociatedConformanceWitness;
  char v28;
  void (*v29)(char *, unint64_t);
  char *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  void (*v35)(void *, uint64_t, unint64_t, unint64_t);
  char *v36;
  void *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t *v43;
  void (*v44)(_QWORD, _QWORD, _QWORD);
  uint64_t v45;
  char *v46;
  char *v47;
  unint64_t v48;
  uint64_t v49;
  const char *v50;
  char *v51;
  uint64_t (*v52)(unint64_t *, uint64_t);
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;

  v6 = a3;
  v55 = a1;
  v56 = a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v9 = *(_QWORD *)(swift_getAssociatedConformanceWitness(a4, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v10 = swift_getAssociatedTypeWitness(255, (const char *)v9, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v50 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, v6, v10, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v48 = swift_getAssociatedTypeWitness(0, v50, v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v48);
  v12 = (char *)&v41 - v11;
  v13 = swift_checkMetadataState(0, v10);
  MEMORY[0x1E0C80A78](v13);
  v47 = (char *)&v41 - v14;
  v58 = *(const char **)(a4 + 48);
  v15 = swift_getAssociatedTypeWitness(0, v58, v6, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v54 = *(_QWORD *)(v15 - 8);
  v16 = MEMORY[0x1E0C80A78](v15);
  v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v51 = (char *)&v41 - v18;
  v19 = swift_checkMetadataState(0, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v9 + 48))(v19, v9);
  v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v9 + 40);
  v57 = a5;
  v52 = v20;
  result = v20(v19, v9);
  if (result < 0)
    goto LABEL_12;
  v46 = v12;
  if (result)
  {
    v22 = 0;
    v23 = (void (*)(_QWORD, _QWORD, _QWORD))*((_QWORD *)v58 + 7);
    v44 = v23;
    v45 = result;
    v49 = v9;
    v24 = v53;
    while (1)
    {
      v25 = v51;
      v26 = v58;
      v23(v22, v6, v58);
      v23(v22, v6, v26);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v26, v6, v15, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v28 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(v25, v24, v15);
      v29 = *(void (**)(char *, unint64_t))(v54 + 8);
      v29(v24, v15);
      v30 = v25;
      v31 = v49;
      v29(v30, v15);
      v32 = v52(v19, v31);
      if ((v32 & 0x8000000000000000) != 0)
        break;
      if (v22 >= v32)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v43 = v13;
      v33 = v48;
      v34 = swift_getAssociatedConformanceWitness((uint64_t)v50, (uint64_t)v13, v48, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v35 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v34 + 8);
      v42 = v6;
      v36 = v46;
      if ((v28 & 1) != 0)
      {
        v37 = &unk_1816B7DB8;
        v38 = 257;
      }
      else
      {
        v37 = &unk_1816B7DA8;
        v38 = 256;
      }
      v35(v37, v38, v33, v34);
      v39 = v47;
      v40 = v36;
      v13 = v43;
      (*((void (**)(char *, unint64_t *))v50 + 3))(v40, v43);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v31 + 64))(v39, v22++, v19, v31);
      v23 = v44;
      result = v45;
      v6 = v42;
      if (v45 == v22)
        return result;
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;

  v64 = a2;
  v69 = a5;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v68 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v9 = swift_getAssociatedTypeWitness(255, v68, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v61 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v9, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v59 = swift_getAssociatedTypeWitness(0, v61, v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v59);
  v11 = (char *)&v54 - v10;
  v60 = swift_checkMetadataState(0, v9);
  MEMORY[0x1E0C80A78](v60);
  v58 = (char *)&v54 - v12;
  v13 = *(_QWORD *)(a4 + 48);
  v14 = swift_getAssociatedTypeWitness(0, (const char *)v13, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v15 = MEMORY[0x1E0C80A78](v14);
  v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v54 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v54 - v21;
  v65 = *(_QWORD *)(a3 - 8);
  v23 = MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v23);
  v67 = (char *)&v54 - v26;
  v62 = v27;
  v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a1, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0)
    goto LABEL_16;
  v30 = v29;
  v57 = v11;
  if (v29)
  {
    v31 = 0;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }
    while (v30 != v31);
  }
  v62 = *(_QWORD *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  v32 = swift_checkMetadataState(0, v66);
  v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  v34 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v33 + 5);
  v66 = (uint64_t)v32;
  v35 = v33;
  v36 = v34;
  v37 = v34((uint64_t)v32, v35);
  if (v37 < 0)
    goto LABEL_16;
  if (v37)
  {
    v38 = 0;
    v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      v40 = v63;
      v41 = v39;
      v39(v38, a3, v13);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, a3, v14, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(v19, v40, v14);
      v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v38 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v59;
      v47 = swift_getAssociatedConformanceWitness((uint64_t)v61, (uint64_t)v60, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      v55 = v36;
      if ((v43 & 1) != 0)
      {
        v49 = v57;
        v50 = &unk_1816B7DB8;
        v51 = 257;
      }
      else
      {
        v49 = v57;
        v50 = &unk_1816B7DA8;
        v51 = 256;
      }
      v48(v50, v51, v46, v47);
      v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      v36 = v55;
      v39 = v41;
      if (v56 == v38)
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;

  v64 = a1;
  v69 = a5;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v68 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v9 = swift_getAssociatedTypeWitness(255, v68, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v61 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v9, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v59 = swift_getAssociatedTypeWitness(0, v61, v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v59);
  v11 = (char *)&v54 - v10;
  v60 = swift_checkMetadataState(0, v9);
  MEMORY[0x1E0C80A78](v60);
  v58 = (char *)&v54 - v12;
  v13 = *(_QWORD *)(a4 + 48);
  v14 = swift_getAssociatedTypeWitness(0, (const char *)v13, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v15 = MEMORY[0x1E0C80A78](v14);
  v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v54 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v54 - v21;
  v65 = *(_QWORD *)(a3 - 8);
  v23 = MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v23);
  v67 = (char *)&v54 - v26;
  v62 = v27;
  v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a2, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0)
    goto LABEL_16;
  v30 = v29;
  v57 = v11;
  if (v29)
  {
    v31 = 0;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }
    while (v30 != v31);
  }
  v62 = *(_QWORD *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  v32 = swift_checkMetadataState(0, v66);
  v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  v34 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v33 + 5);
  v66 = (uint64_t)v32;
  v35 = v33;
  v36 = v34;
  v37 = v34((uint64_t)v32, v35);
  if (v37 < 0)
    goto LABEL_16;
  if (v37)
  {
    v38 = 0;
    v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      v40 = v63;
      v41 = v39;
      v39(v38, a3, v13);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, a3, v14, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(v19, v40, v14);
      v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v38 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v59;
      v47 = swift_getAssociatedConformanceWitness((uint64_t)v61, (uint64_t)v60, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      v55 = v36;
      if ((v43 & 1) != 0)
      {
        v49 = v57;
        v50 = &unk_1816B7DB8;
        v51 = 257;
      }
      else
      {
        v49 = v57;
        v50 = &unk_1816B7DA8;
        v51 = 256;
      }
      v48(v50, v51, v46, v47);
      v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      v36 = v55;
      v39 = v41;
      if (v56 == v38)
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

uint64_t SIMDMask.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 48) + 48))();
}

uint64_t SIMDMask.subscript.setter(int a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  unint64_t *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  uint64_t v16;
  uint64_t v17;
  unint64_t AssociatedConformanceWitness;
  void *v19;
  uint64_t v20;
  _BYTE v22[12];
  int v23;
  uint64_t v24;
  uint64_t v25;

  v4 = v3;
  v25 = a2;
  v23 = a1;
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3[4] + 8) + 24) + 16);
  v6 = a3[2];
  v7 = *(_QWORD *)(a3[3] + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v7, v6, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = swift_getAssociatedTypeWitness(0, (const char *)v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v9);
  v11 = &v22[-v10];
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  MEMORY[0x1E0C80A78](v12);
  v14 = &v22[-v13];
  v15 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  v24 = v4;
  v16 = v15(v6, v7);
  if (v16 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v17 = v25;
  if (v25 < 0 || v16 <= v25)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, (uint64_t)v12, v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if ((v23 & 1) != 0)
  {
    v19 = &unk_1816B7DB8;
    v20 = 257;
  }
  else
  {
    v19 = &unk_1816B7DA8;
    v20 = 256;
  }
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v19, v20, v9, AssociatedConformanceWitness);
  (*(void (**)(_BYTE *, unint64_t *, uint64_t))(v5 + 24))(v11, v12, v5);
  return (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v14, v17, v6, v7);
}

uint64_t static SIMD..!= infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t result;
  unint64_t v22;
  void (*v23)(_QWORD, _QWORD, _QWORD);
  char *v24;
  char *v25;
  const char *v26;
  unint64_t AssociatedConformanceWitness;
  char v28;
  void (*v29)(char *, unint64_t);
  char *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  void (*v35)(void *, uint64_t, unint64_t, unint64_t);
  char *v36;
  void *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t *v43;
  void (*v44)(_QWORD, _QWORD, _QWORD);
  uint64_t v45;
  char *v46;
  char *v47;
  unint64_t v48;
  uint64_t v49;
  const char *v50;
  char *v51;
  uint64_t (*v52)(unint64_t *, uint64_t);
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;

  v6 = a3;
  v55 = a1;
  v56 = a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v9 = *(_QWORD *)(swift_getAssociatedConformanceWitness(a4, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v10 = swift_getAssociatedTypeWitness(255, (const char *)v9, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v50 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, v6, v10, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v48 = swift_getAssociatedTypeWitness(0, v50, v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v48);
  v12 = (char *)&v41 - v11;
  v13 = swift_checkMetadataState(0, v10);
  MEMORY[0x1E0C80A78](v13);
  v47 = (char *)&v41 - v14;
  v58 = *(const char **)(a4 + 48);
  v15 = swift_getAssociatedTypeWitness(0, v58, v6, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v54 = *(_QWORD *)(v15 - 8);
  v16 = MEMORY[0x1E0C80A78](v15);
  v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v51 = (char *)&v41 - v18;
  v19 = swift_checkMetadataState(0, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v9 + 48))(v19, v9);
  v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v9 + 40);
  v57 = a5;
  v52 = v20;
  result = v20(v19, v9);
  if (result < 0)
    goto LABEL_12;
  v46 = v12;
  if (result)
  {
    v22 = 0;
    v23 = (void (*)(_QWORD, _QWORD, _QWORD))*((_QWORD *)v58 + 7);
    v44 = v23;
    v45 = result;
    v49 = v9;
    v24 = v53;
    while (1)
    {
      v25 = v51;
      v26 = v58;
      v23(v22, v6, v58);
      v23(v22, v6, v26);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v26, v6, v15, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v28 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(v25, v24, v15);
      v29 = *(void (**)(char *, unint64_t))(v54 + 8);
      v29(v24, v15);
      v30 = v25;
      v31 = v49;
      v29(v30, v15);
      v32 = v52(v19, v31);
      if ((v32 & 0x8000000000000000) != 0)
        break;
      if (v22 >= v32)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v43 = v13;
      v33 = v48;
      v34 = swift_getAssociatedConformanceWitness((uint64_t)v50, (uint64_t)v13, v48, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v35 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v34 + 8);
      v42 = v6;
      v36 = v46;
      if ((v28 & 1) != 0)
      {
        v37 = &unk_1816B7DA8;
        v38 = 256;
      }
      else
      {
        v37 = &unk_1816B7DB8;
        v38 = 257;
      }
      v35(v37, v38, v33, v34);
      v39 = v47;
      v40 = v36;
      v13 = v43;
      (*((void (**)(char *, unint64_t *))v50 + 3))(v40, v43);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v31 + 64))(v39, v22++, v19, v31);
      v23 = v44;
      result = v45;
      v6 = v42;
      if (v45 == v22)
        return result;
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;

  v64 = a2;
  v69 = a5;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v68 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v9 = swift_getAssociatedTypeWitness(255, v68, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v61 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v9, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v59 = swift_getAssociatedTypeWitness(0, v61, v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v59);
  v11 = (char *)&v54 - v10;
  v60 = swift_checkMetadataState(0, v9);
  MEMORY[0x1E0C80A78](v60);
  v58 = (char *)&v54 - v12;
  v13 = *(_QWORD *)(a4 + 48);
  v14 = swift_getAssociatedTypeWitness(0, (const char *)v13, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v15 = MEMORY[0x1E0C80A78](v14);
  v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v54 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v54 - v21;
  v65 = *(_QWORD *)(a3 - 8);
  v23 = MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v23);
  v67 = (char *)&v54 - v26;
  v62 = v27;
  v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a1, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0)
    goto LABEL_16;
  v30 = v29;
  v57 = v11;
  if (v29)
  {
    v31 = 0;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }
    while (v30 != v31);
  }
  v62 = *(_QWORD *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  v32 = swift_checkMetadataState(0, v66);
  v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  v34 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v33 + 5);
  v66 = (uint64_t)v32;
  v35 = v33;
  v36 = v34;
  v37 = v34((uint64_t)v32, v35);
  if (v37 < 0)
    goto LABEL_16;
  if (v37)
  {
    v38 = 0;
    v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      v40 = v63;
      v41 = v39;
      v39(v38, a3, v13);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, a3, v14, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(v19, v40, v14);
      v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v38 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v59;
      v47 = swift_getAssociatedConformanceWitness((uint64_t)v61, (uint64_t)v60, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      v55 = v36;
      if ((v43 & 1) != 0)
      {
        v49 = v57;
        v50 = &unk_1816B7DA8;
        v51 = 256;
      }
      else
      {
        v49 = v57;
        v50 = &unk_1816B7DB8;
        v51 = 257;
      }
      v48(v50, v51, v46, v47);
      v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      v36 = v55;
      v39 = v41;
      if (v56 == v38)
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(char *, uint64_t, unint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t *v32;
  const char *v33;
  uint64_t (*v34)(uint64_t, const char *);
  const char *v35;
  uint64_t (*v36)(uint64_t, const char *);
  uint64_t v37;
  unint64_t v38;
  void (*v39)(unint64_t, uint64_t, uint64_t);
  char *v40;
  void (*v41)(unint64_t, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  void (*v48)(void *, uint64_t, unint64_t, unint64_t);
  char *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t (*v55)(uint64_t, const char *);
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;

  v64 = a1;
  v69 = a5;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v68 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v9 = swift_getAssociatedTypeWitness(255, v68, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v61 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v9, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v59 = swift_getAssociatedTypeWitness(0, v61, v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v59);
  v11 = (char *)&v54 - v10;
  v60 = swift_checkMetadataState(0, v9);
  MEMORY[0x1E0C80A78](v60);
  v58 = (char *)&v54 - v12;
  v13 = *(_QWORD *)(a4 + 48);
  v14 = swift_getAssociatedTypeWitness(0, (const char *)v13, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v15 = MEMORY[0x1E0C80A78](v14);
  v63 = (char *)&v54 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v54 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v54 - v21;
  v65 = *(_QWORD *)(a3 - 8);
  v23 = MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v54 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v23);
  v67 = (char *)&v54 - v26;
  v62 = v27;
  v28 = *(void (**)(char *, uint64_t, unint64_t))(v27 + 16);
  v28(v22, a2, v14);
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (v29 < 0)
    goto LABEL_16;
  v30 = v29;
  v57 = v11;
  if (v29)
  {
    v31 = 0;
    do
    {
      v28(v19, (uint64_t)v22, v14);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v13 + 64))(v19, v31++, a3, v13);
    }
    while (v30 != v31);
  }
  v62 = *(_QWORD *)(v62 + 8);
  ((void (*)(char *, unint64_t))v62)(v22, v14);
  (*(void (**)(char *, char *, uint64_t))(v65 + 32))(v67, v25, a3);
  v32 = swift_checkMetadataState(0, v66);
  v33 = v68;
  (*((void (**)(unint64_t *, const char *))v68 + 6))(v32, v68);
  v34 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v33 + 5);
  v66 = (uint64_t)v32;
  v35 = v33;
  v36 = v34;
  v37 = v34((uint64_t)v32, v35);
  if (v37 < 0)
    goto LABEL_16;
  if (v37)
  {
    v38 = 0;
    v39 = *(void (**)(unint64_t, uint64_t, uint64_t))(v13 + 56);
    v56 = v37;
    while (1)
    {
      v39(v38, a3, v13);
      v40 = v63;
      v41 = v39;
      v39(v38, a3, v13);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, a3, v14, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8)
                                                                        + 8))(v19, v40, v14);
      v44 = (void (*)(char *, unint64_t))v62;
      ((void (*)(char *, unint64_t))v62)(v40, v14);
      v44(v19, v14);
      v45 = v36(v66, v68);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v38 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v59;
      v47 = swift_getAssociatedConformanceWitness((uint64_t)v61, (uint64_t)v60, v59, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(v47 + 8);
      v55 = v36;
      if ((v43 & 1) != 0)
      {
        v49 = v57;
        v50 = &unk_1816B7DA8;
        v51 = 256;
      }
      else
      {
        v49 = v57;
        v50 = &unk_1816B7DB8;
        v51 = 257;
      }
      v48(v50, v51, v46, v47);
      v52 = v58;
      (*((void (**)(char *))v61 + 3))(v49);
      (*((void (**)(char *, unint64_t, uint64_t))v68 + 8))(v52, v38++, v66);
      v36 = v55;
      v39 = v41;
      if (v56 == v38)
        return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v65 + 8))(v67, a3);
}

uint64_t SIMD.replace(with:where:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v26;
  unint64_t v27;
  void (*v28)(_QWORD, _QWORD, _QWORD);
  void (*v29)(_QWORD, _QWORD, _QWORD);
  unint64_t v30;
  void (*v31)(char *, uint64_t);
  char *v32;
  uint64_t v33;
  uint64_t (*v34)(unint64_t *, uint64_t);
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v44;
  uint64_t v45;
  char *v46;
  void (*v47)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v48;
  uint64_t v49;
  void (*v50)(char *, unint64_t *);
  char *v51;
  uint64_t v52;
  unint64_t v53;
  const char *v54;
  unint64_t v55;
  char *v56;
  char *v57;
  uint64_t v58;
  void (*v59)(char *, unint64_t *);
  void (*v60)(char *, char *, unint64_t *);
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  char *v65;
  unint64_t v66;
  const char *v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  const char *v80;
  unint64_t v81;
  _QWORD v82[5];

  v78 = a2;
  v72 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  v80 = *(const char **)(AssociatedConformanceWitness + 48);
  v9 = swift_getAssociatedTypeWitness(255, v80, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = swift_getAssociatedConformanceWitness(a4, a3, v9, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  v76 = *(_QWORD *)(v10 + 8);
  v67 = *(const char **)(*(_QWORD *)(v76 + 24) + 16);
  v66 = swift_getAssociatedTypeWitness(0, v67, v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v66);
  v65 = (char *)&v63 - v11;
  v12 = swift_checkMetadataState(0, v9);
  v74 = *(v12 - 1);
  v13 = MEMORY[0x1E0C80A78](v12);
  v64 = (char *)&v63 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v71 = (char *)&v63 - v16;
  MEMORY[0x1E0C80A78](v15);
  v77 = (char *)&v63 - v17;
  v18 = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  v81 = AssociatedTypeWitness;
  v82[0] = AssociatedTypeWitness;
  v82[1] = AssociatedConformanceWitness;
  v82[2] = v10;
  v82[3] = v18;
  v19 = type metadata accessor for SIMDMask(0, (uint64_t)v82);
  v79 = *(_QWORD *)(v19 - 8);
  MEMORY[0x1E0C80A78](v19);
  v21 = (char *)&v63 - v20;
  v22 = *(_QWORD *)(a4 + 48);
  v23 = swift_getAssociatedTypeWitness(0, (const char *)v22, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1E0C80A78](v23);
  v75 = (char *)&v63 - v24;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v22 + 40))(a3, v22);
  if (result < 0)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v26 = result;
  v73 = v4;
  if (result)
  {
    v27 = 0;
    v28 = *(void (**)(_QWORD, _QWORD, _QWORD))(v79 + 16);
    while (1)
    {
      v29 = v28;
      v28(v21, v78, v19);
      v30 = (*((uint64_t (**)(unint64_t))v80 + 5))(v81);
      if ((v30 & 0x8000000000000000) != 0)
        goto LABEL_23;
      if (v27 >= v30)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
      v31 = *(void (**)(char *, uint64_t))(v79 + 8);
      v68 = v21;
      v70 = v19;
      v31(v21, v19);
      v32 = v77;
      (*((void (**)(unint64_t, unint64_t))v80 + 7))(v27, v81);
      v33 = v76;
      v34 = *(uint64_t (**)(unint64_t *, uint64_t))(v76 + 64);
      v35 = v34(v12, v76);
      v69 = v26;
      if ((v35 & 1) == 0)
        break;
      v36 = (*(uint64_t (**)(unint64_t *, uint64_t))(v33 + 128))(v12, v33);
      if (v36 >= 64)
      {
        v82[0] = 0;
        v47 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v33 + 96);
        v48 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
        v49 = v33;
        v46 = v71;
        v47(v82, &type metadata for Int, v48, v12, v49);
        (*(void (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v49 + 32) + 8) + 16))(v32, v46, v12);
LABEL_13:
        v50 = *(void (**)(char *, unint64_t *))(v74 + 8);
        v50(v46, v12);
        v50(v32, v12);
        v21 = v68;
        goto LABEL_20;
      }
      (*(void (**)(unint64_t *, uint64_t))(v33 + 120))(v12, v33);
      (*(void (**)(char *, unint64_t *))(v74 + 8))(v32, v12);
      v21 = v68;
LABEL_20:
      v62 = v75;
      (*(void (**)(unint64_t, uint64_t, uint64_t))(v22 + 56))(v27, a3, v22);
      result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v62, v27++, a3, v22);
      v26 = v69;
      v19 = v70;
      v28 = v29;
      if (v69 == v27)
        return result;
    }
    v39 = v34(v12, v33);
    v40 = (*(uint64_t (**)(unint64_t *, uint64_t))(v33 + 128))(v12, v33);
    if ((v39 & 1) == 0)
    {
      v21 = v68;
      if (v40 < 64)
      {
        v51 = v77;
        (*(void (**)(unint64_t *, uint64_t))(v33 + 120))(v12, v33);
        (*(void (**)(char *, unint64_t *))(v74 + 8))(v51, v12);
      }
      else
      {
        (*(void (**)(char *, unint64_t *))(v74 + 8))(v77, v12);
      }
      goto LABEL_20;
    }
    if (v40 <= 64)
    {
      v52 = v33;
      v53 = v66;
      v54 = v67;
      v55 = swift_getAssociatedConformanceWitness((uint64_t)v67, (uint64_t)v12, v66, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v56 = v65;
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v55 + 8))(&unk_1816B7DA8, 256, v53, v55);
      v57 = v71;
      (*((void (**)(char *, unint64_t *, const char *))v54 + 3))(v56, v12, v54);
      LOBYTE(v53) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v52 + 32)
                                                                                              + 8)
                                                                                  + 16))(v77, v57, v12);
      v58 = v74;
      v59 = *(void (**)(char *, unint64_t *))(v74 + 8);
      v59(v57, v12);
      v60 = *(void (**)(char *, char *, unint64_t *))(v58 + 32);
      v61 = v64;
      v60(v64, v77, v12);
      v21 = v68;
      if ((v53 & 1) == 0)
        (*(void (**)(unint64_t *))(v76 + 120))(v12);
      v59(v61, v12);
      goto LABEL_20;
    }
    v82[0] = 0;
    v43 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v33 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v45 = v33;
    v46 = v71;
    v43(v82, &type metadata for Int, v44, v12, v45);
    v32 = v77;
    (*(void (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v45 + 32) + 8) + 16))(v77, v46, v12);
    goto LABEL_13;
  }
  return result;
}

{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(char *, uint64_t, unint64_t);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  const char *v45;
  unint64_t v46;
  void (**v47)(char *, unint64_t);
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(_QWORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char *v62;
  void (*v63)(char *, char *, uint64_t);
  char *v64;
  void (*v65)(char *, uint64_t);
  char *v66;
  char *v67;
  void (*v68)(_QWORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t v73;
  const char *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  uint64_t v81;
  char *v82;
  void (*v83)(char *, uint64_t);
  void (*v84)(char *, char *, uint64_t);
  char *v85;
  char *v87;
  char *v88;
  unint64_t v89;
  const char *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  void (**v98)(char *, unint64_t);
  uint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  char *v103;
  char *v104;
  uint64_t v105;
  unint64_t v106;
  _QWORD v107[5];

  v102 = a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD);
  v96 = *(const char **)(AssociatedConformanceWitness + 48);
  v9 = swift_getAssociatedTypeWitness(255, v96, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = swift_getAssociatedConformanceWitness(a4, a3, v9, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger);
  v94 = *(_QWORD *)(v10 + 8);
  v90 = *(const char **)(*(_QWORD *)(v94 + 24) + 16);
  v89 = swift_getAssociatedTypeWitness(0, v90, v9, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v89);
  v88 = (char *)&v87 - v11;
  v12 = swift_checkMetadataState(0, v9);
  v93 = *(v12 - 1);
  v13 = MEMORY[0x1E0C80A78](v12);
  v15 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v91 = (char *)&v87 - v17;
  MEMORY[0x1E0C80A78](v16);
  v101 = (char *)&v87 - v18;
  v95 = v19;
  v20 = swift_getAssociatedConformanceWitness(a4, a3, v19, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: SignedInteger);
  v106 = AssociatedTypeWitness;
  v107[0] = AssociatedTypeWitness;
  v107[1] = AssociatedConformanceWitness;
  v107[2] = v10;
  v107[3] = v20;
  v105 = type metadata accessor for SIMDMask(0, (uint64_t)v107);
  v99 = *(_QWORD *)(v105 - 8);
  MEMORY[0x1E0C80A78](v105);
  v104 = (char *)&v87 - v21;
  v22 = *(_QWORD *)(a4 + 48);
  v23 = swift_getAssociatedTypeWitness(0, (const char *)v22, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v24 = MEMORY[0x1E0C80A78](v23);
  v92 = (char *)&v87 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  v26 = MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v87 - v27;
  v29 = MEMORY[0x1E0C80A78](v26);
  v31 = (char *)&v87 - v30;
  v100 = *(_QWORD *)(a3 - 8);
  v32 = MEMORY[0x1E0C80A78](v29);
  v34 = (char *)&v87 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v32);
  v103 = (char *)&v87 - v35;
  v98 = (void (**)(char *, unint64_t))v36;
  v37 = *(void (**)(char *, uint64_t, unint64_t))(v36 + 16);
  v37(v31, a1, v23);
  (*(void (**)(uint64_t, uint64_t))(v22 + 48))(a3, v22);
  v97 = *(uint64_t (**)(uint64_t, uint64_t))(v22 + 40);
  v38 = v97(a3, v22);
  if (v38 < 0)
    goto LABEL_29;
  v39 = v38;
  v87 = v15;
  if (v38)
  {
    v40 = 0;
    do
    {
      v37(v28, (uint64_t)v31, v23);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v22 + 64))(v28, v40++, a3, v22);
    }
    while (v39 != v40);
  }
  v98[1](v31, v23);
  (*(void (**)(char *, char *, uint64_t))(v100 + 32))(v103, v34, a3);
  v41 = v97(a3, v22);
  if (v41 < 0)
LABEL_29:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v42 = v41;
  v44 = v101;
  v43 = v102;
  v45 = v96;
  if (v41)
  {
    v46 = 0;
    v47 = *(void (***)(char *, unint64_t))(v99 + 16);
    while (1)
    {
      ((void (*)(char *, uint64_t, uint64_t))v47)(v104, v43, v105);
      v48 = (*((uint64_t (**)(unint64_t, const char *))v45 + 5))(v106, v45);
      if ((v48 & 0x8000000000000000) != 0)
        goto LABEL_29;
      if (v46 >= v48)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
      v98 = v47;
      (*(void (**)(char *, uint64_t))(v99 + 8))(v104, v105);
      (*((void (**)(unint64_t, unint64_t, const char *))v45 + 7))(v46, v106, v45);
      v49 = v94;
      v50 = v95;
      v51 = *(uint64_t (**)(uint64_t, uint64_t))(v94 + 64);
      if ((v51(v95, v94) & 1) != 0)
        break;
      v55 = v51(v50, v49);
      v56 = (*(uint64_t (**)(uint64_t, uint64_t))(v49 + 128))(v50, v49);
      if ((v55 & 1) != 0)
      {
        if (v56 <= 64)
        {
          v74 = v90;
          v75 = v95;
          v76 = v89;
          v77 = swift_getAssociatedConformanceWitness((uint64_t)v90, v95, v89, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v78 = v88;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v77 + 8))(&unk_1816B7DA8, 256, v76, v77);
          v79 = v91;
          (*((void (**)(char *, uint64_t, const char *))v74 + 3))(v78, v75, v74);
          v80 = v101;
          LOBYTE(v76) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v94 + 32) + 8)
                                                                           + 16))(v101, v79, v75);
          v81 = v93;
          v82 = v79;
          v44 = v80;
          v83 = *(void (**)(char *, uint64_t))(v93 + 8);
          v83(v82, v75);
          v84 = *(void (**)(char *, char *, uint64_t))(v81 + 32);
          v85 = v87;
          v84(v87, v44, v75);
          if ((v76 & 1) != 0)
          {
            v83(v85, v75);
            v72 = v92;
            goto LABEL_24;
          }
          (*(void (**)(uint64_t))(v94 + 120))(v75);
          v83(v85, v75);
          goto LABEL_21;
        }
        v107[0] = 0;
        v59 = v94;
        v60 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v94 + 96);
        v61 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
        v62 = v91;
        v50 = v95;
        v60(v107, &type metadata for Int, v61, v95, v59);
        v63 = *(void (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v59 + 32) + 8) + 16);
        v64 = v101;
        v63(v101, v62, v50);
        v65 = *(void (**)(char *, uint64_t))(v93 + 8);
        v66 = v62;
        v44 = v64;
        v65(v66, v50);
        v67 = v64;
LABEL_17:
        v65(v67, v50);
        v72 = v92;
        goto LABEL_24;
      }
      if (v56 < 64)
      {
        v73 = v95;
        (*(void (**)(uint64_t))(v94 + 120))(v95);
        (*(void (**)(char *, uint64_t))(v93 + 8))(v44, v73);
        goto LABEL_21;
      }
      (*(void (**)(char *, uint64_t))(v93 + 8))(v44, v95);
      v72 = v92;
LABEL_24:
      (*(void (**)(unint64_t, uint64_t, uint64_t))(v22 + 56))(v46, a3, v22);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v22 + 64))(v72, v46++, a3, v22);
      v43 = v102;
      v47 = v98;
      if (v42 == v46)
        return (*(uint64_t (**)(char *, uint64_t))(v100 + 8))(v103, a3);
    }
    v52 = (*(uint64_t (**)(uint64_t, uint64_t))(v49 + 128))(v50, v49);
    if (v52 < 64)
    {
      (*(void (**)(uint64_t, uint64_t))(v49 + 120))(v50, v49);
      (*(void (**)(char *, uint64_t))(v93 + 8))(v44, v50);
LABEL_21:
      v72 = v92;
      goto LABEL_24;
    }
    v107[0] = 0;
    v68 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v49 + 96);
    v69 = lazy protocol witness table accessor for type Int and conformance Int(v52, v53, v54);
    v70 = v91;
    v68(v107, &type metadata for Int, v69, v50, v49);
    (*(void (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v49 + 32) + 8) + 16))(v101, v70, v50);
    v65 = *(void (**)(char *, uint64_t))(v93 + 8);
    v71 = v70;
    v44 = v101;
    v65(v71, v50);
    v67 = v44;
    goto LABEL_17;
  }
  return (*(uint64_t (**)(char *, uint64_t))(v100 + 8))(v103, a3);
}

unint64_t SIMDMask.subscript.getter(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t (*v24)(unint64_t *, uint64_t);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char v30;
  void (*v31)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v32;
  char *v33;
  void (*v34)(char *, unint64_t *);
  uint64_t v35;
  unint64_t v36;
  unint64_t AssociatedConformanceWitness;
  char *v38;
  char *v39;
  uint64_t v40;
  void (*v41)(char *, unint64_t *);
  void (*v42)(char *, char *, unint64_t *);
  char *v43;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  const char *v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;

  v3 = v2;
  v6 = *(_QWORD *)(a2[4] + 8);
  v7 = *(const char **)(*(_QWORD *)(v6 + 24) + 16);
  v8 = a2[2];
  v9 = *(_QWORD *)(a2[3] + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v9, v8, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v49 = v7;
  v47 = swift_getAssociatedTypeWitness(0, v7, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v47);
  v46 = (char *)&v45 - v11;
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v51 = *(v12 - 1);
  v13 = MEMORY[0x1E0C80A78](v12);
  v48 = (char *)&v45 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v50 = (char *)&v45 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v45 - v18;
  v20 = *(a2 - 1);
  MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v45 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, _QWORD *))(v20 + 16))(v22, v3, a2);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v8, v9);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (a1 < 0 || v23 <= a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  (*(void (**)(char *, _QWORD *))(v20 + 8))(v22, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56))(a1, v8, v9);
  v24 = *(uint64_t (**)(unint64_t *, uint64_t))(v6 + 64);
  if ((v24(v12, v6) & 1) != 0)
  {
    v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 128))(v12, v6);
    if (v25 < 64)
    {
LABEL_6:
      v28 = (*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 120))(v12, v6);
      (*(void (**)(char *, unint64_t *))(v51 + 8))(v19, v12);
      v29 = v28 >> 63;
      return v29 & 1;
    }
    goto LABEL_10;
  }
  v30 = v24(v12, v6);
  v25 = (*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 128))(v12, v6);
  if ((v30 & 1) == 0)
  {
    if (v25 >= 64)
    {
      (*(void (**)(char *, unint64_t *))(v51 + 8))(v19, v12);
      LOBYTE(v29) = 0;
      return v29 & 1;
    }
    goto LABEL_6;
  }
  if (v25 > 64)
  {
LABEL_10:
    v52 = 0;
    v31 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v6 + 96);
    v32 = lazy protocol witness table accessor for type Int and conformance Int(v25, v26, v27);
    v33 = v50;
    v31(&v52, &type metadata for Int, v32, v12, v6);
    LOBYTE(v29) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v6 + 32) + 8)
                                                                                + 16))(v19, v33, v12);
    v34 = *(void (**)(char *, unint64_t *))(v51 + 8);
    v34(v33, v12);
    v34(v19, v12);
    return v29 & 1;
  }
  v35 = (uint64_t)v49;
  v36 = v47;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v49, (uint64_t)v12, v47, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v38 = v46;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v36, AssociatedConformanceWitness);
  v39 = v50;
  (*(void (**)(char *, unint64_t *, uint64_t))(v35 + 24))(v38, v12, v35);
  LOBYTE(v36) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v6 + 32) + 8)
                                                                              + 16))(v19, v39, v12);
  v40 = v51;
  v41 = *(void (**)(char *, unint64_t *))(v51 + 8);
  v41(v39, v12);
  v42 = *(void (**)(char *, char *, unint64_t *))(v40 + 32);
  v43 = v48;
  v42(v48, v19, v12);
  if ((v36 & 1) != 0)
    LOBYTE(v29) = 1;
  else
    v29 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v6 + 120))(v12, v6) >> 63;
  v41(v43, v12);
  return v29 & 1;
}

uint64_t SIMD.init(arrayLiteral:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *WitnessTable;
  uint64_t v14;

  v14 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(const char **)(a3 + 48), a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = type metadata accessor for Array(0, AssociatedTypeWitness, v8, v9);
  WitnessTable = (const char *)swift_getWitnessTable(&protocol conformance descriptor for [A], v10, v11);
  return SIMD.init<A>(_:)((uint64_t)&v14, a2, v10, a3, WitnessTable, a4);
}

uint64_t SIMD.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  void (*v27)(uint64_t, uint64_t);
  void (*v28)(uint64_t);
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t AssociatedConformanceWitness;
  uint64_t v33;
  void (*v34)(unint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;

  v47 = a2;
  v42 = (uint64_t)a5;
  v43 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v40 - v12;
  v44 = v14;
  v17 = type metadata accessor for Optional(0, v14, v15, v16);
  v18 = MEMORY[0x1E0C80A78](v17);
  v20 = (char *)&v40 - v19;
  v21 = *(_QWORD *)(a3 - 8);
  MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v40 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v24 = swift_getAssociatedTypeWitness(0, a5, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v41 = *(_QWORD *)(v24 - 8);
  MEMORY[0x1E0C80A78](v24);
  v26 = (char *)&v40 - v25;
  v27 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  v45 = a6;
  v27(v47, v9);
  v40 = v21;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v23, v43, a3);
  v28 = *(void (**)(uint64_t))(v42 + 32);
  v46 = v26;
  v29 = v42;
  v28(a3);
  v42 = a3;
  v30 = a3;
  v31 = v24;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v29, v30, v24, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v33 = 0;
  v34 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  while (1)
  {
    v34(v31, AssociatedConformanceWitness);
    v35 = v44;
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v11 + 48))(v20, 1, v44) == 1)
      break;
    v36 = v11;
    (*(void (**)(char *, char *, uint64_t))(v11 + 32))(v13, v20, v35);
    v37 = v47;
    if (v33 == (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v47, v9))
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Too many elements in sequence.", 30, 2, "Swift/SIMDVector.swift", 22, 2, 0xF9uLL, 0);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v13, v33, v37, v9);
    v38 = __OFADD__(v33++, 1);
    v11 = v36;
    if (v38)
    {
      __break(1u);
      break;
    }
  }
  (*(void (**)(char *, unint64_t))(v41 + 8))(v46, v31);
  if (v33 < (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v47, v9))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough elements in sequence.", 32, 2, "Swift/SIMDVector.swift", 22, 2, 0xFFuLL, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 8))(v43, v42);
}

uint64_t SIMD2.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
}

uint64_t SIMD2.subscript.getter(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD2.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x2CuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD3.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t SIMD3.subscript.getter(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD3.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x58BuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD4.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t SIMD4.subscript.getter(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD4.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC9uLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD8.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD8Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
}

uint64_t SIMD8.subscript.getter(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD8.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1BBuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD16.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD16Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
}

uint64_t SIMD16.subscript.getter(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD16.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x283uLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD32.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD32Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
}

uint64_t SIMD32.subscript.getter(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD32.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x35BuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t SIMD64.init()(uint64_t a1, const char *a2)
{
  return SIMD2.init()(a1, a2, associated type descriptor for SIMDScalar.SIMD64Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
}

uint64_t SIMD2.init()(uint64_t a1, const char *a2, _DWORD *a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a2, a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a2, a1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  return (*(uint64_t (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD64.subscript.getter(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t SIMD64.subscript.setter(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x453uLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t static SIMD<>..<= infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t (*v21)(unint64_t *, uint64_t);
  uint64_t result;
  unint64_t v23;
  void (*v24)(unint64_t, uint64_t, uint64_t);
  char *v25;
  char *v26;
  void (*v27)(unint64_t, uint64_t, uint64_t);
  unint64_t v28;
  char v29;
  void (*v30)(char *, unint64_t);
  char *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t AssociatedConformanceWitness;
  void (*v36)(void *, uint64_t, unint64_t, unint64_t);
  char *v37;
  void *v38;
  uint64_t v39;
  char *v40;
  uint64_t (*v41)(unint64_t *, uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  const char *v50;
  unint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;

  v56 = a2;
  v57 = a5;
  v55 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v10 = *(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v11 = swift_getAssociatedTypeWitness(255, (const char *)v10, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v50 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v11, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v47 = swift_getAssociatedTypeWitness(0, v50, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v47);
  v46 = (char *)&v41 - v12;
  v49 = swift_checkMetadataState(0, v11);
  MEMORY[0x1E0C80A78](v49);
  v45 = (char *)&v41 - v13;
  v14 = *(_QWORD *)(a4 + 48);
  v15 = a3;
  v51 = swift_getAssociatedTypeWitness(0, (const char *)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v54 = *(_QWORD *)(v51 - 8);
  v16 = MEMORY[0x1E0C80A78](v51);
  v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v52 = (char *)&v41 - v18;
  v19 = swift_checkMetadataState(0, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v10 + 48))(v19, v10);
  v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v10 + 40);
  v58 = a6;
  v21 = v20;
  result = v20(v19, v10);
  if (result < 0)
    goto LABEL_12;
  if (result)
  {
    v23 = 0;
    v24 = *(void (**)(unint64_t, uint64_t, uint64_t))(v14 + 56);
    v43 = v15;
    v44 = result;
    v48 = v10;
    v25 = v53;
    while (1)
    {
      v26 = v52;
      v24(v23, v15, v14);
      v27 = v24;
      v24(v23, v15, v14);
      v28 = v51;
      v29 = (*(uint64_t (**)(char *, char *, unint64_t))(v57 + 24))(v26, v25, v51);
      v30 = *(void (**)(char *, unint64_t))(v54 + 8);
      v30(v25, v28);
      v31 = v26;
      v32 = v48;
      v30(v31, v28);
      v33 = v21(v19, v32);
      if ((v33 & 0x8000000000000000) != 0)
        break;
      if (v23 >= v33)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v41 = v21;
      v34 = v47;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v50, (uint64_t)v49, v47, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v36 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      v42 = v14;
      v37 = v46;
      if ((v29 & 1) != 0)
      {
        v38 = &unk_1816B7DB8;
        v39 = 257;
      }
      else
      {
        v38 = &unk_1816B7DA8;
        v39 = 256;
      }
      v36(v38, v39, v34, AssociatedConformanceWitness);
      v24 = v27;
      v40 = v45;
      (*((void (**)(char *))v50 + 3))(v37);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v32 + 64))(v40, v23++, v19, v32);
      result = v44;
      v21 = v41;
      v14 = v42;
      v15 = v43;
      if (v44 == v23)
        return result;
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;

  v62 = a2;
  v63 = a5;
  v68 = a6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v10 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v67 = v10;
  v11 = swift_getAssociatedTypeWitness(255, v10, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v58 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v11, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v56 = swift_getAssociatedTypeWitness(0, v58, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v56);
  v13 = (char *)&v53 - v12;
  v57 = swift_checkMetadataState(0, v11);
  MEMORY[0x1E0C80A78](v57);
  v55 = (char *)&v53 - v14;
  v15 = *(_QWORD *)(a4 + 48);
  v16 = swift_getAssociatedTypeWitness(0, (const char *)v15, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v17 = MEMORY[0x1E0C80A78](v16);
  v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v53 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v53 - v23;
  v64 = *(_QWORD *)(a3 - 8);
  v25 = MEMORY[0x1E0C80A78](v22);
  v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v25);
  v65 = (char *)&v53 - v28;
  v60 = v29;
  v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a1, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0)
    goto LABEL_16;
  v32 = v31;
  v54 = v13;
  if (v31)
  {
    v33 = 0;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }
    while (v32 != v33);
  }
  v60 = *(_QWORD *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  v35 = swift_checkMetadataState(0, v66);
  v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  v37 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v36 + 5);
  v66 = (uint64_t)v35;
  v59 = v37;
  v38 = v37((uint64_t)v35, v36);
  if (v38 < 0)
    goto LABEL_16;
  if (v38)
  {
    v39 = 0;
    v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      v41 = v61;
      v42 = v40;
      v40(v39, a3, v15);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 24))(v21, v41, v16);
      v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v39 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v56;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v58, (uint64_t)v57, v56, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v54;
      if ((v43 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      v34 = v65;
      v40 = v42;
      if (v53 == v39)
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;

  v62 = a1;
  v63 = a5;
  v68 = a6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v10 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v67 = v10;
  v11 = swift_getAssociatedTypeWitness(255, v10, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v58 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v11, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v56 = swift_getAssociatedTypeWitness(0, v58, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v56);
  v13 = (char *)&v53 - v12;
  v57 = swift_checkMetadataState(0, v11);
  MEMORY[0x1E0C80A78](v57);
  v55 = (char *)&v53 - v14;
  v15 = *(_QWORD *)(a4 + 48);
  v16 = swift_getAssociatedTypeWitness(0, (const char *)v15, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v17 = MEMORY[0x1E0C80A78](v16);
  v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v53 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v53 - v23;
  v64 = *(_QWORD *)(a3 - 8);
  v25 = MEMORY[0x1E0C80A78](v22);
  v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v25);
  v65 = (char *)&v53 - v28;
  v60 = v29;
  v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a2, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0)
    goto LABEL_16;
  v32 = v31;
  v54 = v13;
  if (v31)
  {
    v33 = 0;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }
    while (v32 != v33);
  }
  v60 = *(_QWORD *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  v35 = swift_checkMetadataState(0, v66);
  v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  v37 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v36 + 5);
  v66 = (uint64_t)v35;
  v59 = v37;
  v38 = v37((uint64_t)v35, v36);
  if (v38 < 0)
    goto LABEL_16;
  if (v38)
  {
    v39 = 0;
    v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      v41 = v61;
      v42 = v40;
      v40(v39, a3, v15);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 24))(v21, v41, v16);
      v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v39 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v56;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v58, (uint64_t)v57, v56, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v54;
      if ((v43 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      v34 = v65;
      v40 = v42;
      if (v53 == v39)
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

uint64_t static SIMD<>..> infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t (*v21)(unint64_t *, uint64_t);
  uint64_t result;
  unint64_t v23;
  void (*v24)(unint64_t, uint64_t, uint64_t);
  char *v25;
  char *v26;
  void (*v27)(unint64_t, uint64_t, uint64_t);
  unint64_t v28;
  char v29;
  void (*v30)(char *, unint64_t);
  char *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t AssociatedConformanceWitness;
  void (*v36)(void *, uint64_t, unint64_t, unint64_t);
  char *v37;
  void *v38;
  uint64_t v39;
  char *v40;
  uint64_t (*v41)(unint64_t *, uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  const char *v50;
  unint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;

  v56 = a2;
  v57 = a5;
  v55 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v10 = *(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v11 = swift_getAssociatedTypeWitness(255, (const char *)v10, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v50 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v11, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v47 = swift_getAssociatedTypeWitness(0, v50, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v47);
  v46 = (char *)&v41 - v12;
  v49 = swift_checkMetadataState(0, v11);
  MEMORY[0x1E0C80A78](v49);
  v45 = (char *)&v41 - v13;
  v14 = *(_QWORD *)(a4 + 48);
  v15 = a3;
  v51 = swift_getAssociatedTypeWitness(0, (const char *)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v54 = *(_QWORD *)(v51 - 8);
  v16 = MEMORY[0x1E0C80A78](v51);
  v53 = (char *)&v41 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v52 = (char *)&v41 - v18;
  v19 = swift_checkMetadataState(0, AssociatedTypeWitness);
  (*(void (**)(unint64_t *, uint64_t))(v10 + 48))(v19, v10);
  v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v10 + 40);
  v58 = a6;
  v21 = v20;
  result = v20(v19, v10);
  if (result < 0)
    goto LABEL_12;
  if (result)
  {
    v23 = 0;
    v24 = *(void (**)(unint64_t, uint64_t, uint64_t))(v14 + 56);
    v43 = v15;
    v44 = result;
    v48 = v10;
    v25 = v53;
    while (1)
    {
      v26 = v52;
      v24(v23, v15, v14);
      v27 = v24;
      v24(v23, v15, v14);
      v28 = v51;
      v29 = (*(uint64_t (**)(char *, char *, unint64_t))(v57 + 16))(v26, v25, v51);
      v30 = *(void (**)(char *, unint64_t))(v54 + 8);
      v30(v25, v28);
      v31 = v26;
      v32 = v48;
      v30(v31, v28);
      v33 = v21(v19, v32);
      if ((v33 & 0x8000000000000000) != 0)
        break;
      if (v23 >= v33)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v41 = v21;
      v34 = v47;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v50, (uint64_t)v49, v47, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v36 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      v42 = v14;
      v37 = v46;
      if ((v29 & 1) != 0)
      {
        v38 = &unk_1816B7DB8;
        v39 = 257;
      }
      else
      {
        v38 = &unk_1816B7DA8;
        v39 = 256;
      }
      v36(v38, v39, v34, AssociatedConformanceWitness);
      v24 = v27;
      v40 = v45;
      (*((void (**)(char *))v50 + 3))(v37);
      (*(void (**)(char *, unint64_t, unint64_t *, uint64_t))(v32 + 64))(v40, v23++, v19, v32);
      result = v44;
      v21 = v41;
      v14 = v42;
      v15 = v43;
      if (v44 == v23)
        return result;
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;

  v62 = a2;
  v63 = a5;
  v68 = a6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v10 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v67 = v10;
  v11 = swift_getAssociatedTypeWitness(255, v10, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v58 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v11, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v56 = swift_getAssociatedTypeWitness(0, v58, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v56);
  v13 = (char *)&v53 - v12;
  v57 = swift_checkMetadataState(0, v11);
  MEMORY[0x1E0C80A78](v57);
  v55 = (char *)&v53 - v14;
  v15 = *(_QWORD *)(a4 + 48);
  v16 = swift_getAssociatedTypeWitness(0, (const char *)v15, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v17 = MEMORY[0x1E0C80A78](v16);
  v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v53 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v53 - v23;
  v64 = *(_QWORD *)(a3 - 8);
  v25 = MEMORY[0x1E0C80A78](v22);
  v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v25);
  v65 = (char *)&v53 - v28;
  v60 = v29;
  v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a1, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0)
    goto LABEL_16;
  v32 = v31;
  v54 = v13;
  if (v31)
  {
    v33 = 0;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }
    while (v32 != v33);
  }
  v60 = *(_QWORD *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  v35 = swift_checkMetadataState(0, v66);
  v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  v37 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v36 + 5);
  v66 = (uint64_t)v35;
  v59 = v37;
  v38 = v37((uint64_t)v35, v36);
  if (v38 < 0)
    goto LABEL_16;
  if (v38)
  {
    v39 = 0;
    v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      v41 = v61;
      v42 = v40;
      v40(v39, a3, v15);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 16))(v21, v41, v16);
      v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v39 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v56;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v58, (uint64_t)v57, v56, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v54;
      if ((v43 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      v34 = v65;
      v40 = v42;
      if (v53 == v39)
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

{
  unint64_t AssociatedTypeWitness;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(char *, uint64_t, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  unint64_t *v35;
  const char *v36;
  uint64_t (*v37)(uint64_t, const char *);
  uint64_t v38;
  unint64_t v39;
  void (*v40)(unint64_t, uint64_t, uint64_t);
  char *v41;
  void (*v42)(unint64_t, uint64_t, uint64_t);
  char v43;
  void (*v44)(char *, unint64_t);
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  uint64_t v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t *v57;
  const char *v58;
  uint64_t (*v59)(uint64_t, const char *);
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;

  v62 = a1;
  v63 = a5;
  v68 = a6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for SIMD, associated type descriptor for SIMD.MaskStorage);
  v10 = *(const char **)(swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage: SIMD)+ 48);
  v66 = AssociatedTypeWitness;
  v67 = v10;
  v11 = swift_getAssociatedTypeWitness(255, v10, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v58 = *(const char **)(*(_QWORD *)(*(_QWORD *)(swift_getAssociatedConformanceWitness(a4, a3, v11, (uint64_t)&protocol requirements base descriptor for SIMD, (uint64_t)&associated conformance descriptor for SIMD.SIMD.MaskStorage.SIMDStorage.Scalar: FixedWidthInteger)+ 8)+ 24)+ 16);
  v56 = swift_getAssociatedTypeWitness(0, v58, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v56);
  v13 = (char *)&v53 - v12;
  v57 = swift_checkMetadataState(0, v11);
  MEMORY[0x1E0C80A78](v57);
  v55 = (char *)&v53 - v14;
  v15 = *(_QWORD *)(a4 + 48);
  v16 = swift_getAssociatedTypeWitness(0, (const char *)v15, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v17 = MEMORY[0x1E0C80A78](v16);
  v61 = (char *)&v53 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v53 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v53 - v23;
  v64 = *(_QWORD *)(a3 - 8);
  v25 = MEMORY[0x1E0C80A78](v22);
  v27 = (char *)&v53 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v25);
  v65 = (char *)&v53 - v28;
  v60 = v29;
  v30 = *(void (**)(char *, uint64_t, unint64_t))(v29 + 16);
  v30(v24, a2, v16);
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  v31 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (v31 < 0)
    goto LABEL_16;
  v32 = v31;
  v54 = v13;
  if (v31)
  {
    v33 = 0;
    do
    {
      v30(v21, (uint64_t)v24, v16);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v15 + 64))(v21, v33++, a3, v15);
    }
    while (v32 != v33);
  }
  v60 = *(_QWORD *)(v60 + 8);
  ((void (*)(char *, unint64_t))v60)(v24, v16);
  v34 = v65;
  (*(void (**)(char *, char *, uint64_t))(v64 + 32))(v65, v27, a3);
  v35 = swift_checkMetadataState(0, v66);
  v36 = v67;
  (*((void (**)(unint64_t *, const char *))v67 + 6))(v35, v67);
  v37 = (uint64_t (*)(uint64_t, const char *))*((_QWORD *)v36 + 5);
  v66 = (uint64_t)v35;
  v59 = v37;
  v38 = v37((uint64_t)v35, v36);
  if (v38 < 0)
    goto LABEL_16;
  if (v38)
  {
    v39 = 0;
    v40 = *(void (**)(unint64_t, uint64_t, uint64_t))(v15 + 56);
    v53 = v38;
    while (1)
    {
      v40(v39, a3, v15);
      v41 = v61;
      v42 = v40;
      v40(v39, a3, v15);
      v43 = (*(uint64_t (**)(char *, char *, unint64_t))(v63 + 16))(v21, v41, v16);
      v44 = (void (*)(char *, unint64_t))v60;
      ((void (*)(char *, unint64_t))v60)(v41, v16);
      v44(v21, v16);
      v45 = v59(v66, v67);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v39 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v46 = v56;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v58, (uint64_t)v57, v56, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v54;
      if ((v43 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      v51 = v55;
      (*((void (**)(char *))v58 + 3))(v48);
      (*((void (**)(char *, unint64_t, uint64_t))v67 + 8))(v51, v39++, v66);
      v34 = v65;
      v40 = v42;
      if (v53 == v39)
        return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v64 + 8))(v34, a3);
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))static FixedWidthInteger.random<A>(in:using:), a8);
}

{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))static FixedWidthInteger.random<A>(in:using:), a8);
}

uint64_t static SIMD<>.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, (void (*)(uint64_t, uint64_t, unint64_t, uint64_t))specialized static FixedWidthInteger.random<A>(in:using:), a5);
}

{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, (void (*)(uint64_t, uint64_t, unint64_t, uint64_t))specialized static FixedWidthInteger.random<A>(in:using:), a5);
}

uint64_t specialized static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void (*a6)(uint64_t, uint64_t, unint64_t, uint64_t)@<X5>, uint64_t a7@<X8>)
{
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  char *v15;
  uint64_t result;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t, unint64_t, uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t, unint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;

  v25 = a6;
  v12 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v15 = (char *)&v24 - v14;
  (*(void (**)(uint64_t, uint64_t))(v12 + 48))(a3, v12);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 40))(a3, v12);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v17 = result;
  v26 = a7;
  v27 = a3;
  v18 = v25;
  if (result)
  {
    v19 = a2;
    v20 = a1;
    v21 = 0;
    do
    {
      v22 = v20;
      v23 = v19;
      v18(v20, v19, AssociatedTypeWitness, a5);
      result = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v15, v21, v27, v12);
      v20 = v22;
      v19 = v23;
      ++v21;
    }
    while (v17 != v21);
  }
  return result;
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, void (*a8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD)@<X7>, uint64_t a9@<X8>)
{
  uint64_t v14;
  unint64_t AssociatedTypeWitness;
  uint64_t v16;
  char *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v34 = a7;
  v35 = a8;
  v33 = a6;
  v14 = *(_QWORD *)(a5 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v14, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v17 = (char *)&v32 - v16;
  (*(void (**)(uint64_t, uint64_t))(v14 + 48))(a3, v14);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 40))(a3, v14);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v19 = v33;
  v20 = v34;
  v38 = v14;
  v39 = a3;
  v21 = v35;
  v37 = a9;
  if (result)
  {
    v22 = a4;
    v23 = a2;
    v24 = a1;
    v25 = AssociatedTypeWitness;
    v26 = 0;
    v36 = result;
    do
    {
      v27 = v22;
      v28 = v20;
      v29 = v19;
      v30 = v21;
      v31 = v24;
      v21(v24, v23, v25, v22, v20, v19);
      (*(void (**)(char *, uint64_t, uint64_t))(v38 + 64))(v17, v26, v39);
      v24 = v31;
      v21 = v30;
      v20 = v28;
      result = v36;
      v22 = v27;
      v19 = v29;
      ++v26;
    }
    while (v36 != v26);
  }
  return result;
}

uint64_t static SIMD<>.zero.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 48) + 48))();
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, a8, a9, (void (*)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))static BinaryFloatingPoint<>.random<A>(in:using:));
}

{
  return static SIMD<>.random<A>(in:using:)(a1, a2, a3, a4, a5, a6, a7, a8, a9, (void (*)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))static BinaryFloatingPoint<>.random<A>(in:using:));
}

uint64_t static SIMD<>.random(in:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))specialized static BinaryFloatingPoint<>.random<A>(in:using:), a6);
}

{
  return specialized static SIMD<>.random<A>(in:using:)(a1, a2, a2, a3, a4, a5, (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))specialized static BinaryFloatingPoint<>.random<A>(in:using:), a6);
}

uint64_t specialized static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void (*a7)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD)@<X6>, uint64_t a8@<X8>)
{
  uint64_t v13;
  unint64_t AssociatedTypeWitness;
  uint64_t v15;
  char *v16;
  uint64_t result;
  uint64_t v18;
  void (*v19)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v29;
  uint64_t v30;
  void (*v31)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v30 = a6;
  v31 = a7;
  v13 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v13, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v16 = (char *)&v29 - v15;
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a3, v13);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v13 + 40))(a3, v13);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v33 = a8;
  v34 = a3;
  v18 = a1;
  v20 = v30;
  v19 = v31;
  v32 = v13;
  if (result)
  {
    v21 = a5;
    v22 = a2;
    v23 = AssociatedTypeWitness;
    v24 = 0;
    do
    {
      v25 = result;
      v26 = v22;
      v27 = v21;
      v28 = v19;
      v19(v18, v22, v23, v21, v20);
      (*(void (**)(char *, uint64_t, uint64_t))(v32 + 64))(v16, v24, v34);
      v19 = v28;
      result = v25;
      v22 = v26;
      v21 = v27;
      ++v24;
    }
    while (v25 != v24);
  }
  return result;
}

uint64_t static SIMD<>.random<A>(in:using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, void (*a10)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v15;
  unint64_t AssociatedTypeWitness;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v35 = a7;
  v36 = a8;
  v34 = a6;
  v15 = *(_QWORD *)(a5 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v15, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v18 = (char *)&v34 - v17;
  (*(void (**)(uint64_t, uint64_t))(v15 + 48))(a3, v15);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 40))(a3, v15);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = a9;
  v41 = a3;
  v21 = v34;
  v20 = v35;
  v22 = v36;
  v39 = v15;
  if (result)
  {
    v23 = a4;
    v24 = a2;
    v25 = AssociatedTypeWitness;
    v26 = v18;
    v27 = 0;
    v37 = a10;
    v38 = result;
    do
    {
      v28 = a1;
      v29 = v25;
      v30 = v23;
      v31 = v20;
      v32 = a1;
      v33 = v22;
      v37(v28, v24, v25, v23, v20, v21, v22);
      (*(void (**)(char *, uint64_t, uint64_t))(v39 + 64))(v26, v27, v41);
      v25 = v29;
      v20 = v31;
      v22 = v33;
      a1 = v32;
      result = v38;
      v23 = v30;
      ++v27;
    }
    while (v38 != v27);
  }
  return result;
}

uint64_t (*SIMDMask._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMDMask.scalarCount.getter(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t SIMDMask.init(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 32))(a3, a1);
}

uint64_t key path getter for SIMDMask.subscript(_:) : <A>SIMDMask<A>A@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t (*v26)(unint64_t *, uint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t result;
  void (*v32)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  char v33;
  unint64_t v34;
  char *v35;
  void (*v36)(char *, unint64_t *);
  void (**v37)(char *, unint64_t *, const char *);
  unint64_t v38;
  unint64_t AssociatedConformanceWitness;
  char *v40;
  char *v41;
  uint64_t v42;
  void (*v43)(char *, unint64_t *);
  char *v44;
  _BYTE *v45;
  uint64_t v46;
  char *v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  _BYTE *v52;
  uint64_t v53;
  __int128 v54;
  _QWORD v55[2];
  __int128 v56;

  v52 = a4;
  v6 = (char *)a2 + a3;
  v8 = *(uint64_t *)((char *)a2 + a3 - 32);
  v7 = *(uint64_t *)((char *)a2 + a3 - 24);
  v9 = *(_QWORD *)(v7 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v9, v8, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v54 = *((_OWORD *)v6 - 1);
  v11 = *(_QWORD *)(v54 + 8);
  v49 = *(char **)(*(_QWORD *)(v11 + 24) + 16);
  v48 = swift_getAssociatedTypeWitness(0, v49, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v48);
  v47 = (char *)&v46 - v12;
  v13 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v53 = *(v13 - 1);
  v14 = MEMORY[0x1E0C80A78](v13);
  v50 = (char *)&v46 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v51 = (char *)&v46 - v17;
  MEMORY[0x1E0C80A78](v16);
  v19 = (char *)&v46 - v18;
  v55[0] = v8;
  v55[1] = v7;
  v56 = v54;
  v20 = type metadata accessor for SIMDMask(0, (uint64_t)v55);
  v21 = *(_QWORD *)(v20 - 8);
  MEMORY[0x1E0C80A78](v20);
  v23 = (char *)&v46 - v22;
  v24 = *a2;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))((char *)&v46 - v22, a1, v20);
  v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(v8, v9);
  if (v25 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (v24 < 0 || v24 >= v25)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  (*(void (**)(char *, uint64_t))(v21 + 8))(v23, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56))(v24, v8, v9);
  v26 = *(uint64_t (**)(unint64_t *, uint64_t))(v11 + 64);
  if ((v26(v13, v11) & 1) != 0)
  {
    v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 128))(v13, v11);
    if (v27 < 64)
    {
LABEL_6:
      v30 = (*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 120))(v13, v11);
      result = (*(uint64_t (**)(char *, unint64_t *))(v53 + 8))(v19, v13);
      v32 = (void (*)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v30 >> 63);
LABEL_16:
      v45 = v52;
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  v33 = v26(v13, v11);
  v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 128))(v13, v11);
  if ((v33 & 1) == 0)
  {
    if (v27 >= 64)
    {
      result = (*(uint64_t (**)(char *, unint64_t *))(v53 + 8))(v19, v13);
      LOBYTE(v32) = 0;
      goto LABEL_16;
    }
    goto LABEL_6;
  }
  if (v27 > 64)
  {
LABEL_10:
    v55[0] = 0;
    v32 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v11 + 96);
    v34 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    v35 = v51;
    v32(v55, &type metadata for Int, v34, v13, v11);
    LOBYTE(v32) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v11 + 32) + 8)
                                                                                + 16))(v19, v35, v13);
    v36 = *(void (**)(char *, unint64_t *))(v53 + 8);
    v36(v35, v13);
    result = ((uint64_t (*)(char *, unint64_t *))v36)(v19, v13);
    goto LABEL_16;
  }
  v38 = v48;
  v37 = (void (**)(char *, unint64_t *, const char *))v49;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v49, (uint64_t)v13, v48, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v40 = v47;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v38, AssociatedConformanceWitness);
  v41 = v51;
  v37[3](v40, v13, (const char *)v37);
  LOBYTE(v37) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v11 + 32) + 8)
                                                                              + 16))(v19, v41, v13);
  v42 = v53;
  v43 = *(void (**)(char *, unint64_t *))(v53 + 8);
  v43(v41, v13);
  v44 = v50;
  (*(void (**)(char *, char *, unint64_t *))(v42 + 32))(v50, v19, v13);
  if ((v37 & 1) != 0)
    LOBYTE(v32) = 1;
  else
    v32 = (void (*)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))((unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v11 + 120))(v13, v11) >> 63);
  v45 = v52;
  result = ((uint64_t (*)(char *, unint64_t *))v43)(v44, v13);
LABEL_17:
  *v45 = v32 & 1;
  return result;
}

uint64_t key path setter for SIMDMask.subscript(_:) : <A>SIMDMask<A>A(unsigned __int8 *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  unint64_t *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  uint64_t (*v19)(uint64_t, uint64_t);
  uint64_t v20;
  uint64_t v21;
  unint64_t AssociatedConformanceWitness;
  void *v23;
  uint64_t v24;
  uint64_t v26[2];

  v7 = *(uint64_t *)((char *)a3 + a4 - 32);
  v8 = *(const char **)(*(_QWORD *)(*(_QWORD *)(*(uint64_t *)((char *)a3 + a4 - 16) + 8) + 24) + 16);
  v9 = *(_QWORD *)(*(uint64_t *)((char *)a3 + a4 - 24) + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v9, v7, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v26[0] = (uint64_t)v8;
  v11 = swift_getAssociatedTypeWitness(0, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v11);
  v13 = (char *)v26 - v12;
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  MEMORY[0x1E0C80A78](v14);
  v16 = (char *)v26 - v15;
  v17 = *a3;
  v18 = *a1;
  v19 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v26[1] = a2;
  v20 = v19(v7, v9);
  if (v20 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (v17 < 0 || v17 >= v20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
  v21 = v26[0];
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v26[0], (uint64_t)v14, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v18)
  {
    v23 = &unk_1816B7DB8;
    v24 = 257;
  }
  else
  {
    v23 = &unk_1816B7DA8;
    v24 = 256;
  }
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v23, v24, v11, AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t *, uint64_t))(v21 + 24))(v13, v14, v21);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v16, v17, v7, v9);
}

void (*SIMDMask.subscript.modify(_QWORD *a1, uint64_t a2, _QWORD *a3))(uint64_t a1, char a2)
{
  uint64_t v3;
  _QWORD *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t AssociatedTypeWitness;
  unint64_t v12;
  unint64_t *v13;
  size_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v31;
  void (*v32)(void *, unint64_t *);
  void *v33;
  void (*v34)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v35;
  unint64_t AssociatedConformanceWitness;
  char v37;
  void (*v38)(void *, unint64_t *);
  _BYTE *v39;
  void *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;

  v7 = malloc(0x90uLL);
  *a1 = v7;
  v7[2] = a2;
  v7[3] = v3;
  v47 = *(_QWORD *)(a3[4] + 8);
  v8 = *(const char **)(*(_QWORD *)(v47 + 24) + 16);
  v7[4] = v8;
  v9 = a3[2];
  v10 = *(_QWORD *)(a3[3] + 48);
  v7[5] = v10;
  v7[6] = v9;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v10, v9, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = (uint64_t)v8;
  v12 = swift_getAssociatedTypeWitness(0, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7[7] = v12;
  v42 = v12;
  v41 = malloc(*(_QWORD *)(*(_QWORD *)(v12 - 8) + 64));
  v7[8] = v41;
  v13 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[9] = v13;
  v46 = *(v13 - 1);
  v14 = *(_QWORD *)(v46 + 64);
  v7[10] = malloc(v14);
  v7[11] = malloc(v14);
  v43 = malloc(v14);
  v7[12] = v43;
  v45 = malloc(v14);
  v7[13] = v45;
  v15 = malloc(v14);
  v7[14] = v15;
  v16 = *(a3 - 1);
  v17 = malloc(*(_QWORD *)(v16 + 64));
  v7[15] = v17;
  (*(void (**)(void))(v16 + 16))();
  v18 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 40);
  v7[16] = v18;
  v19 = v18(v9, v10);
  if (v19 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (a2 < 0 || v19 <= a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  (*(void (**)(void *, _QWORD *))(v16 + 8))(v17, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(a2, v9, v10);
  v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v47 + 64);
  if ((v20(v13, v47) & 1) != 0)
  {
    v21 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
    if (v21 < 64)
    {
LABEL_6:
      v24 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47);
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      v25 = v24 >> 63;
LABEL_18:
      v39 = v7 + 17;
      goto LABEL_19;
    }
    v7[1] = 0;
    v34 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    v35 = lazy protocol witness table accessor for type Int and conformance Int(v21, v22, v23);
    v34(v7 + 1, &type metadata for Int, v35, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v47 + 32) + 8)
                                                                                + 16))(v15, v45, v13);
    v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    v33 = v15;
LABEL_12:
    v32(v33, v13);
    goto LABEL_18;
  }
  v26 = v20(v13, v47);
  v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
  if ((v26 & 1) == 0)
  {
    if (v27 >= 64)
    {
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      LOBYTE(v25) = 0;
      goto LABEL_18;
    }
    goto LABEL_6;
  }
  if (v27 > 64)
  {
    *v7 = 0;
    v30 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    v31 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    v30(v7, &type metadata for Int, v31, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v47 + 32) + 8)
                                                                                + 16))(v15, v45, v13);
    v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    v33 = v15;
    goto LABEL_12;
  }
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v44, (uint64_t)v13, v42, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v42, AssociatedConformanceWitness);
  (*(void (**)(void *, unint64_t *, uint64_t))(v44 + 24))(v41, v13, v44);
  v37 = (*(uint64_t (**)(void *, void *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v47 + 32) + 8) + 16))(v15, v45, v13);
  v38 = *(void (**)(void *, unint64_t *))(v46 + 8);
  v38(v45, v13);
  (*(void (**)(void *, void *, unint64_t *))(v46 + 32))(v43, v15, v13);
  if ((v37 & 1) != 0)
    LOBYTE(v25) = 1;
  else
    v25 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47) >> 63;
  v39 = v7 + 17;
  v38(v43, v13);
LABEL_19:
  *v39 = v25 & 1;
  return SIMDMask.subscript.modify;
}

void SIMDMask.subscript.modify(uint64_t a1, char a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t AssociatedConformanceWitness;
  uint64_t v15;
  void *v16;
  void (*v17)(void *, unint64_t, uint64_t, uint64_t);
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  v3 = *(_QWORD **)a1;
  v4 = *(unsigned __int8 *)(*(_QWORD *)a1 + 136);
  v5 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)a1 + 128))(*(_QWORD *)(*(_QWORD *)a1 + 48), *(_QWORD *)(*(_QWORD *)a1 + 40));
  if ((a2 & 1) != 0)
  {
    if ((v5 & 0x8000000000000000) == 0)
    {
      v6 = v3[2];
      if (v5 > v6)
      {
        v28 = (void *)v3[14];
        v29 = (void *)v3[15];
        v7 = (void *)v3[11];
        v26 = (void *)v3[12];
        v27 = (void *)v3[13];
        v8 = v3[9];
        v9 = (void *)v3[10];
        v10 = v3[7];
        v11 = (void *)v3[8];
        v12 = v3[5];
        v13 = v3[4];
        v25 = v3[6];
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, v8, v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        if (v4)
          v15 = 257;
        else
          v15 = 256;
        if (v4)
          v16 = &unk_1816B7DB8;
        else
          v16 = &unk_1816B7DA8;
        (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v16, v15, v10, AssociatedConformanceWitness);
        (*(void (**)(void *, uint64_t, uint64_t))(v13 + 24))(v11, v8, v13);
        v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
        v18 = v9;
        goto LABEL_21;
      }
LABEL_13:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
    }
LABEL_22:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((v5 & 0x8000000000000000) != 0)
    goto LABEL_22;
  v6 = v3[2];
  if (v5 <= v6)
    goto LABEL_13;
  v28 = (void *)v3[14];
  v29 = (void *)v3[15];
  v7 = (void *)v3[11];
  v26 = (void *)v3[12];
  v27 = (void *)v3[13];
  v19 = v3[9];
  v9 = (void *)v3[10];
  v20 = v3[7];
  v11 = (void *)v3[8];
  v12 = v3[5];
  v21 = v3[4];
  v25 = v3[6];
  v22 = swift_getAssociatedConformanceWitness(v21, v19, v20, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v4)
    v23 = 257;
  else
    v23 = 256;
  if (v4)
    v24 = &unk_1816B7DB8;
  else
    v24 = &unk_1816B7DA8;
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v22 + 8))(v24, v23, v20, v22);
  (*(void (**)(void *, uint64_t, uint64_t))(v21 + 24))(v11, v19, v21);
  v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
  v18 = v7;
LABEL_21:
  v17(v18, v6, v25, v12);
  free(v29);
  free(v28);
  free(v27);
  free(v26);
  free(v7);
  free(v9);
  free(v11);
  free(v3);
}

Swift::Int SIMDMask.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMDMask<A>, a3);
}

{
  uint64_t WitnessTable;
  _QWORD v6[5];
  __int128 v7;
  __int128 v8;

  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1ECD25520 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1ECD25520 ^ 0x7465646279746573;
  v7 = 0u;
  v8 = 0u;
  WitnessTable = swift_getWitnessTable(a2, a1, a3);
  SIMD.hash(into:)((uint64_t)v6, a1, WitnessTable);
  return Hasher._finalize()();
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMDMask<A>(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMDMask<A>(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 48) + 48))(*(_QWORD *)(a1 + 16));
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMDMask<A>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t AssociatedTypeWitness;
  uint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t (*v25)(unint64_t *, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t result;
  void (*v31)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  char v32;
  unint64_t v33;
  char *v34;
  void (*v35)(char *, unint64_t *);
  uint64_t v36;
  unint64_t v37;
  unint64_t AssociatedConformanceWitness;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, unint64_t *);
  char *v43;
  _BYTE *v44;
  char *v45;
  unint64_t v46;
  char *v47;
  const char *v48;
  char *v49;
  _BYTE *v50;
  uint64_t v51;
  uint64_t v52;

  v5 = v3;
  v50 = a3;
  v7 = *(_QWORD *)(a2[4] + 8);
  v8 = *(const char **)(*(_QWORD *)(v7 + 24) + 16);
  v9 = a2[2];
  v10 = *(_QWORD *)(a2[3] + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v10, v9, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v48 = v8;
  v46 = swift_getAssociatedTypeWitness(0, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v46);
  v45 = (char *)&v45 - v12;
  v13 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v51 = *(v13 - 1);
  v14 = MEMORY[0x1E0C80A78](v13);
  v47 = (char *)&v45 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v49 = (char *)&v45 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v45 - v19;
  v21 = *(a2 - 1);
  MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v45 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, _QWORD *))(v21 + 16))(v23, v5, a2);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 40))(v9, v10);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (a1 < 0 || v24 <= a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  (*(void (**)(char *, _QWORD *))(v21 + 8))(v23, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(a1, v9, v10);
  v25 = *(uint64_t (**)(unint64_t *, uint64_t))(v7 + 64);
  if ((v25(v13, v7) & 1) != 0)
  {
    v26 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v13, v7);
    if (v26 < 64)
    {
LABEL_6:
      v29 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v13, v7);
      result = (*(uint64_t (**)(char *, unint64_t *))(v51 + 8))(v20, v13);
      v31 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v29 >> 63);
LABEL_16:
      v44 = v50;
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  v32 = v25(v13, v7);
  v26 = (*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 128))(v13, v7);
  if ((v32 & 1) == 0)
  {
    if (v26 >= 64)
    {
      result = (*(uint64_t (**)(char *, unint64_t *))(v51 + 8))(v20, v13);
      LOBYTE(v31) = 0;
      goto LABEL_16;
    }
    goto LABEL_6;
  }
  if (v26 > 64)
  {
LABEL_10:
    v52 = 0;
    v31 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v7 + 96);
    v33 = lazy protocol witness table accessor for type Int and conformance Int(v26, v27, v28);
    v34 = v49;
    v31(&v52, &type metadata for Int, v33, v13, v7);
    LOBYTE(v31) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8)
                                                                                + 16))(v20, v34, v13);
    v35 = *(void (**)(char *, unint64_t *))(v51 + 8);
    v35(v34, v13);
    result = ((uint64_t (*)(char *, unint64_t *))v35)(v20, v13);
    goto LABEL_16;
  }
  v36 = (uint64_t)v48;
  v37 = v46;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v48, (uint64_t)v13, v46, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v39 = v45;
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v37, AssociatedConformanceWitness);
  v40 = v49;
  (*(void (**)(char *, unint64_t *, uint64_t))(v36 + 24))(v39, v13, v36);
  LOBYTE(v36) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v7 + 32) + 8)
                                                                              + 16))(v20, v40, v13);
  v41 = v51;
  v42 = *(void (**)(char *, unint64_t *))(v51 + 8);
  v42(v40, v13);
  v43 = v47;
  (*(void (**)(char *, char *, unint64_t *))(v41 + 32))(v47, v20, v13);
  if ((v36 & 1) != 0)
    LOBYTE(v31) = 1;
  else
    v31 = (void (*)(uint64_t *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))((unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v7 + 120))(v13, v7) >> 63);
  v44 = v50;
  result = ((uint64_t (*)(char *, unint64_t *))v42)(v43, v13);
LABEL_17:
  *v44 = v31 & 1;
  return result;
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMDMask<A>(unsigned __int8 *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t *v13;
  uint64_t v14;
  char *v15;
  int v16;
  uint64_t (*v17)(uint64_t, uint64_t);
  uint64_t v18;
  unint64_t AssociatedConformanceWitness;
  void *v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;

  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3[4] + 8) + 24) + 16);
  v7 = a3[2];
  v8 = *(_QWORD *)(a3[3] + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v8, v7, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = swift_getAssociatedTypeWitness(0, (const char *)v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v10);
  v12 = (char *)&v23 - v11;
  v13 = swift_checkMetadataState(0, AssociatedTypeWitness);
  MEMORY[0x1E0C80A78](v13);
  v15 = (char *)&v23 - v14;
  v16 = *a1;
  v17 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v24 = v3;
  v18 = v17(v7, v8);
  if (v18 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (a2 < 0 || v18 <= a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, (uint64_t)v13, v10, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v16)
  {
    v20 = &unk_1816B7DB8;
    v21 = 257;
  }
  else
  {
    v20 = &unk_1816B7DA8;
    v21 = 256;
  }
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v20, v21, v10, AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t *, uint64_t))(v6 + 24))(v12, v13, v6);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v15, a2, v7, v8);
}

void (*protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>(_QWORD *a1, uint64_t a2, _QWORD *a3))(uint64_t a1, char a2)
{
  uint64_t v3;
  _QWORD *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t AssociatedTypeWitness;
  unint64_t v12;
  unint64_t *v13;
  size_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  uint64_t (*v20)(unint64_t *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v31;
  void (*v32)(void *, unint64_t *);
  void *v33;
  void (*v34)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v35;
  unint64_t AssociatedConformanceWitness;
  char v37;
  void (*v38)(void *, unint64_t *);
  _BYTE *v39;
  void *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;

  v7 = malloc(0x90uLL);
  *a1 = v7;
  v7[2] = a2;
  v7[3] = v3;
  v47 = *(_QWORD *)(a3[4] + 8);
  v8 = *(const char **)(*(_QWORD *)(v47 + 24) + 16);
  v7[4] = v8;
  v9 = a3[2];
  v10 = *(_QWORD *)(a3[3] + 48);
  v7[5] = v10;
  v7[6] = v9;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v10, v9, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = (uint64_t)v8;
  v12 = swift_getAssociatedTypeWitness(0, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7[7] = v12;
  v42 = v12;
  v41 = malloc(*(_QWORD *)(*(_QWORD *)(v12 - 8) + 64));
  v7[8] = v41;
  v13 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[9] = v13;
  v46 = *(v13 - 1);
  v14 = *(_QWORD *)(v46 + 64);
  v43 = malloc(v14);
  v7[10] = v43;
  v7[11] = malloc(v14);
  v7[12] = malloc(v14);
  v45 = malloc(v14);
  v7[13] = v45;
  v15 = malloc(v14);
  v7[14] = v15;
  v16 = *(a3 - 1);
  v17 = malloc(*(_QWORD *)(v16 + 64));
  v7[15] = v17;
  (*(void (**)(void))(v16 + 16))();
  v18 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 40);
  v7[16] = v18;
  v19 = v18(v9, v10);
  if (v19 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (a2 < 0 || v19 <= a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
  (*(void (**)(void *, _QWORD *))(v16 + 8))(v17, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 56))(a2, v9, v10);
  v20 = *(uint64_t (**)(unint64_t *, uint64_t))(v47 + 64);
  if ((v20(v13, v47) & 1) != 0)
  {
    v21 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
    if (v21 < 64)
    {
LABEL_6:
      v24 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47);
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      v25 = v24 >> 63;
LABEL_18:
      v39 = v7 + 17;
      goto LABEL_19;
    }
    v7[1] = 0;
    v34 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    v35 = lazy protocol witness table accessor for type Int and conformance Int(v21, v22, v23);
    v34(v7 + 1, &type metadata for Int, v35, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v47 + 32) + 8)
                                                                                + 16))(v15, v45, v13);
    v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    v33 = v15;
LABEL_12:
    v32(v33, v13);
    goto LABEL_18;
  }
  v26 = v20(v13, v47);
  v27 = (*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 128))(v13, v47);
  if ((v26 & 1) == 0)
  {
    if (v27 >= 64)
    {
      (*(void (**)(void *, unint64_t *))(v46 + 8))(v15, v13);
      LOBYTE(v25) = 0;
      goto LABEL_18;
    }
    goto LABEL_6;
  }
  if (v27 > 64)
  {
    *v7 = 0;
    v30 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v47 + 96);
    v31 = lazy protocol witness table accessor for type Int and conformance Int(v27, v28, v29);
    v30(v7, &type metadata for Int, v31, v13, v47);
    LOBYTE(v25) = (*(uint64_t (**)(void *, void *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v47 + 32) + 8)
                                                                                + 16))(v15, v45, v13);
    v32 = *(void (**)(void *, unint64_t *))(v46 + 8);
    v32(v45, v13);
    v33 = v15;
    goto LABEL_12;
  }
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v44, (uint64_t)v13, v42, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v42, AssociatedConformanceWitness);
  (*(void (**)(void *, unint64_t *, uint64_t))(v44 + 24))(v41, v13, v44);
  v37 = (*(uint64_t (**)(void *, void *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v47 + 32) + 8) + 16))(v15, v45, v13);
  v38 = *(void (**)(void *, unint64_t *))(v46 + 8);
  v38(v45, v13);
  (*(void (**)(void *, void *, unint64_t *))(v46 + 32))(v43, v15, v13);
  if ((v37 & 1) != 0)
    LOBYTE(v25) = 1;
  else
    v25 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v47 + 120))(v13, v47) >> 63;
  v39 = v7 + 17;
  v38(v43, v13);
LABEL_19:
  *v39 = v25 & 1;
  return protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>;
}

void protocol witness for SIMDStorage.subscript.modify in conformance SIMDMask<A>(uint64_t a1, char a2)
{
  _QWORD *v3;
  int v4;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t AssociatedConformanceWitness;
  uint64_t v15;
  void *v16;
  void (*v17)(void *, unint64_t, uint64_t, uint64_t);
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  v3 = *(_QWORD **)a1;
  v4 = *(unsigned __int8 *)(*(_QWORD *)a1 + 136);
  v5 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)a1 + 128))(*(_QWORD *)(*(_QWORD *)a1 + 48), *(_QWORD *)(*(_QWORD *)a1 + 40));
  if ((a2 & 1) != 0)
  {
    if ((v5 & 0x8000000000000000) == 0)
    {
      v6 = v3[2];
      if (v5 > v6)
      {
        v28 = (void *)v3[14];
        v29 = (void *)v3[15];
        v7 = (void *)v3[12];
        v8 = (void *)v3[11];
        v26 = (void *)v3[10];
        v27 = (void *)v3[13];
        v10 = (void *)v3[8];
        v9 = v3[9];
        v11 = v3[7];
        v13 = v3[4];
        v12 = v3[5];
        v25 = v3[6];
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v13, v9, v11, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        if (v4)
          v15 = 257;
        else
          v15 = 256;
        if (v4)
          v16 = &unk_1816B7DB8;
        else
          v16 = &unk_1816B7DA8;
        (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v16, v15, v11, AssociatedConformanceWitness);
        (*(void (**)(void *, uint64_t, uint64_t))(v13 + 24))(v10, v9, v13);
        v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
        v18 = v8;
        goto LABEL_21;
      }
LABEL_13:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
    }
LABEL_22:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if ((v5 & 0x8000000000000000) != 0)
    goto LABEL_22;
  v6 = v3[2];
  if (v5 <= v6)
    goto LABEL_13;
  v28 = (void *)v3[14];
  v29 = (void *)v3[15];
  v7 = (void *)v3[12];
  v8 = (void *)v3[11];
  v26 = (void *)v3[10];
  v27 = (void *)v3[13];
  v10 = (void *)v3[8];
  v19 = v3[9];
  v20 = v3[7];
  v21 = v3[4];
  v12 = v3[5];
  v25 = v3[6];
  v22 = swift_getAssociatedConformanceWitness(v21, v19, v20, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  if (v4)
    v23 = 257;
  else
    v23 = 256;
  if (v4)
    v24 = &unk_1816B7DB8;
  else
    v24 = &unk_1816B7DA8;
  (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v22 + 8))(v24, v23, v20, v22);
  (*(void (**)(void *, uint64_t, uint64_t))(v21 + 24))(v10, v19, v21);
  v17 = *(void (**)(void *, unint64_t, uint64_t, uint64_t))(v12 + 64);
  v18 = v7;
LABEL_21:
  v17(v18, v6, v25, v12);
  free(v29);
  free(v28);
  free(v27);
  free(v7);
  free(v8);
  free(v26);
  free(v10);
  free(v3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMDMask<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMDMask<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMDMask<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMDMask<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMDMask<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMDMask<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMDMask<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMDMask<A>(char *a1, char *a2, _QWORD *a3)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  uint64_t v32;
  unint64_t v33;
  char v34;
  void (*v35)(char *, char *, _QWORD *);
  char *v36;
  char *v37;
  unint64_t v38;
  void (*v39)(char *, _QWORD *);
  char *v40;
  uint64_t v41;
  uint64_t (*v42)(unint64_t *, uint64_t);
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(char *, char *, _QWORD *);
  void (*v48)(char *, _QWORD *);
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v54;
  char *v55;
  char *v56;
  void (*v57)(char *, unint64_t *);
  char *v58;
  void (*v59)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t AssociatedConformanceWitness;
  char *v68;
  char *v69;
  char *v70;
  uint64_t v71;
  void (*v72)(char *, char *, unint64_t *);
  char *v73;
  unint64_t v74;
  char *v75;
  unint64_t v76;
  void (*v77)(char *, _QWORD *);
  char *v78;
  uint64_t (*v79)(unint64_t *, uint64_t);
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  char v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void (*v89)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v90;
  char *v91;
  char *v92;
  void (*v93)(char *, unint64_t *);
  char *v94;
  void (*v95)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t);
  unint64_t v96;
  char *v97;
  void (*v98)(char *, unint64_t *);
  char v99;
  char *v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  char *v105;
  uint64_t v106;
  void (*v107)(char *, unint64_t *, uint64_t);
  char *v108;
  char *v109;
  char *v110;
  char *v111;
  char *v112;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(unint64_t *, uint64_t);
  void (*v117)(unint64_t, uint64_t, uint64_t);
  uint64_t (*v118)(unint64_t *, uint64_t);
  void (*v119)(char *, _QWORD *);
  void (*v120)(char *, unint64_t *);
  const char *v121;
  uint64_t v122;
  char *v123;
  void (*v124)(char *, char *, _QWORD *);
  char *v125;
  char *v126;
  unint64_t v127;
  char *v128;
  char *v129;
  uint64_t v130;
  char *v131;
  uint64_t v132;
  char *v133;
  uint64_t (*v134)(uint64_t, uint64_t);
  char *v135;
  char *v136;
  uint64_t v137;
  uint64_t v138;
  char *v139;
  _QWORD v140[2];

  v6 = *(_QWORD *)(a3[4] + 8);
  v7 = *(const char **)(*(_QWORD *)(v6 + 24) + 16);
  v8 = a3[2];
  v9 = *(_QWORD *)(a3[3] + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v9, v8, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v127 = swift_getAssociatedTypeWitness(0, v7, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v127);
  v126 = (char *)&v114 - v11;
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v130 = *(v12 - 1);
  v13 = MEMORY[0x1E0C80A78](v12);
  v123 = (char *)&v114 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v128 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v125 = (char *)&v114 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v129 = (char *)&v114 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v133 = (char *)&v114 - v22;
  v138 = *(a3 - 1);
  v23 = MEMORY[0x1E0C80A78](v21);
  v131 = (char *)&v114 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  v25 = MEMORY[0x1E0C80A78](v23);
  v135 = (char *)&v114 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v139 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v136 = a1;
  v137 = v8;
  v134 = v31;
  v32 = v31(v8, v9);
  if (v32 < 0)
LABEL_48:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (v32)
  {
    v121 = v7;
    v122 = v6;
    v33 = 0;
    v34 = 1;
    v35 = *(void (**)(char *, char *, _QWORD *))(v138 + 16);
    v36 = v133;
    v132 = v32;
    while (1)
    {
      v35(v30, v136, a3);
      v37 = v139;
      v35(v139, a2, a3);
      if ((v34 & 1) != 0)
        break;
      v48 = *(void (**)(char *, _QWORD *))(v138 + 8);
      v48(v37, a3);
      v48(v30, a3);
      v34 = 0;
LABEL_11:
      if (v132 == ++v33)
        return v34 & 1;
    }
    v35(v135, v30, a3);
    v38 = v134(v137, v9);
    if ((v38 & 0x8000000000000000) != 0)
      goto LABEL_48;
    if (v33 >= v38)
      goto LABEL_45;
    v124 = v35;
    v39 = *(void (**)(char *, _QWORD *))(v138 + 8);
    v39(v135, a3);
    v40 = v36;
    v117 = *(void (**)(unint64_t, uint64_t, uint64_t))(v9 + 56);
    v117(v33, v137, v9);
    v119 = v39;
    v39(v30, a3);
    v41 = v122;
    v42 = *(uint64_t (**)(unint64_t *, uint64_t))(v122 + 64);
    v43 = v42(v12, v122);
    v115 = a2;
    v118 = v42;
    if ((v43 & 1) != 0)
    {
      v116 = *(uint64_t (**)(unint64_t *, uint64_t))(v41 + 128);
      v44 = v116(v12, v41);
      v47 = v124;
      if (v44 < 64)
        goto LABEL_20;
      v140[0] = 0;
      v59 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
      v60 = lazy protocol witness table accessor for type Int and conformance Int(v44, v45, v46);
      v61 = v129;
      v59(v140, &type metadata for Int, v60, v12, v41);
      v114 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v41 + 32) + 8)
                                                                           + 16))(v133, v61, v12);
      v57 = *(void (**)(char *, unint64_t *))(v130 + 8);
      v62 = v61;
      v63 = v133;
      v57(v62, v12);
      v58 = v63;
    }
    else
    {
      v49 = v42(v12, v41);
      v116 = *(uint64_t (**)(unint64_t *, uint64_t))(v41 + 128);
      v50 = v116(v12, v41);
      if ((v49 & 1) == 0)
      {
        v47 = v124;
        if (v50 < 64)
        {
LABEL_20:
          v64 = (*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41);
          v120 = *(void (**)(char *, unint64_t *))(v130 + 8);
          v120(v40, v12);
          v114 = v64 >> 63;
          goto LABEL_23;
        }
        v120 = *(void (**)(char *, unint64_t *))(v130 + 8);
        v120(v40, v12);
        v114 = 0;
LABEL_23:
        v75 = v139;
        v47(v131, v139, a3);
        goto LABEL_24;
      }
      v47 = v124;
      if (v50 <= 64)
      {
        v65 = (uint64_t)v121;
        v66 = v127;
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v121, (uint64_t)v12, v127, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v68 = v126;
        (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v66, AssociatedConformanceWitness);
        v69 = v129;
        (*(void (**)(char *, unint64_t *, uint64_t))(v65 + 24))(v68, v12, v65);
        v70 = v133;
        LOBYTE(v66) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v41 + 32)
                                                                                                + 8)
                                                                                    + 16))(v133, v69, v12);
        v71 = v130;
        v120 = *(void (**)(char *, unint64_t *))(v130 + 8);
        v120(v69, v12);
        v72 = *(void (**)(char *, char *, unint64_t *))(v71 + 32);
        v73 = v125;
        v72(v125, v70, v12);
        if ((v66 & 1) != 0)
          v74 = 1;
        else
          v74 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41) >> 63;
        v114 = v74;
        v120(v73, v12);
        v75 = v139;
        v124(v131, v139, a3);
LABEL_24:
        v76 = v134(v137, v9);
        if ((v76 & 0x8000000000000000) != 0)
          goto LABEL_48;
        if (v33 >= v76)
LABEL_45:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2C8uLL, 0);
        v77 = v119;
        v119(v131, a3);
        v78 = v128;
        v117(v33, v137, v9);
        v77(v75, a3);
        v79 = v118;
        if ((v118(v12, v41) & 1) != 0)
        {
          v80 = v116(v12, v41);
          if (v80 >= 64)
          {
            v140[0] = 0;
            v94 = v78;
            v95 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
            v96 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
            v97 = v129;
            v95(v140, &type metadata for Int, v96, v12, v41);
            LOBYTE(v84) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v41 + 32) + 8)
                                                                                        + 16))(v94, v97, v12);
            v36 = v133;
            v98 = v120;
            v120(v97, v12);
            v98(v94, v12);
            a2 = v115;
          }
          else
          {
            v83 = (*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41);
            v120(v78, v12);
            v84 = v83 >> 63;
            a2 = v115;
            v36 = v133;
          }
          v99 = v114;
          v35 = v124;
        }
        else
        {
          v85 = v79(v12, v41);
          v86 = v116(v12, v41);
          if ((v85 & 1) != 0)
          {
            v35 = v124;
            if (v86 <= 64)
            {
              v102 = (uint64_t)v121;
              v103 = v127;
              v104 = swift_getAssociatedConformanceWitness((uint64_t)v121, (uint64_t)v12, v127, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v105 = v126;
              (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v104 + 8))(&unk_1816B7DA8, 256, v103, v104);
              v106 = v102;
              v107 = *(void (**)(char *, unint64_t *, uint64_t))(v102 + 24);
              v108 = v129;
              v109 = v105;
              v110 = v128;
              v107(v109, v12, v106);
              LOBYTE(v103) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v41 + 32) + 8)
                                                                                           + 16))(v110, v108, v12);
              v120(v108, v12);
              v111 = v123;
              (*(void (**)(char *, char *, unint64_t *))(v130 + 32))(v123, v110, v12);
              if ((v103 & 1) != 0)
                LOBYTE(v84) = 1;
              else
                v84 = (unint64_t)(*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41) >> 63;
              v112 = v111;
              a2 = v115;
              v36 = v133;
              v99 = v114;
              v120(v112, v12);
              goto LABEL_44;
            }
            v140[0] = 0;
            v89 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
            v90 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
            v91 = v129;
            v89(v140, &type metadata for Int, v90, v12, v41);
            v92 = v128;
            LOBYTE(v84) = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v41 + 32) + 8)
                                                                                        + 16))(v128, v91, v12);
            v93 = v120;
            v120(v91, v12);
            v93(v92, v12);
          }
          else
          {
            v35 = v124;
            if (v86 < 64)
            {
              v100 = v128;
              v101 = (*(uint64_t (**)(unint64_t *, uint64_t))(v41 + 120))(v12, v41);
              v120(v100, v12);
              v84 = v101 >> 63;
            }
            else
            {
              v120(v128, v12);
              LOBYTE(v84) = 0;
            }
          }
          a2 = v115;
          v36 = v133;
          v99 = v114;
        }
LABEL_44:
        v34 = v99 ^ v84 ^ 1;
        goto LABEL_11;
      }
      v140[0] = 0;
      v53 = *(void (**)(_QWORD *, ValueMetadata *, unint64_t, unint64_t *, uint64_t))(v41 + 96);
      v54 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
      v55 = v129;
      v53(v140, &type metadata for Int, v54, v12, v41);
      v56 = v133;
      v114 = (*(uint64_t (**)(char *, char *, unint64_t *))(*(_QWORD *)(*(_QWORD *)(v41 + 32) + 8)
                                                                           + 16))(v133, v55, v12);
      v57 = *(void (**)(char *, unint64_t *))(v130 + 8);
      v57(v55, v12);
      v58 = v56;
    }
    v120 = v57;
    v57(v58, v12);
    goto LABEL_23;
  }
  v34 = 1;
  return v34 & 1;
}

uint64_t specialized static SIMDMask.random<A>(using:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  void (*v19)(void *, uint64_t);
  char *v20;
  void *v21;
  uint64_t v22;
  char *v23;
  uint64_t (*v24)(uint64_t, uint64_t);
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  uint64_t __buf;

  v5 = *(const char **)(*(_QWORD *)(*(_QWORD *)(a4 + 8) + 24) + 16);
  v6 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v28 = v5;
  v8 = swift_getAssociatedTypeWitness(0, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v8);
  v10 = (char *)&v24 - v9;
  v11 = swift_checkMetadataState(0, AssociatedTypeWitness);
  MEMORY[0x1E0C80A78](v11);
  v27 = (char *)&v24 - v12;
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(a2, v6);
  v13 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 40);
  result = v13(a2, v6);
  if (result < 0)
    goto LABEL_12;
  v15 = result;
  v26 = v10;
  if (result)
  {
    v16 = 0;
    while (1)
    {
      __buf = 0;
      swift_stdlib_random(&__buf, 8uLL);
      v17 = __buf;
      v18 = v13(a2, v6);
      if ((v18 & 0x8000000000000000) != 0)
        break;
      if (v16 >= v18)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v19 = *(void (**)(void *, uint64_t))(swift_getAssociatedConformanceWitness((uint64_t)v28, (uint64_t)v11, v8, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral)+ 8);
      v24 = v13;
      v25 = v8;
      v20 = v26;
      if ((v17 & 0x20000) != 0)
      {
        v21 = &unk_1816B7DA8;
        v22 = 256;
      }
      else
      {
        v21 = &unk_1816B7DB8;
        v22 = 257;
      }
      v19(v21, v22);
      v23 = v27;
      (*((void (**)(char *, unint64_t *))v28 + 3))(v20, v11);
      result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v6 + 64))(v23, v16++, a2, v6);
      v13 = v24;
      v8 = v25;
      if (v15 == v16)
        return result;
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

uint64_t static SIMDMask.random<A>(using:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  const char *v12;
  uint64_t v13;
  unint64_t AssociatedTypeWitness;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v20;
  unint64_t v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t AssociatedConformanceWitness;
  void (*v31)(void *, uint64_t, unint64_t, unint64_t);
  char *v32;
  void *v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t (*v37)(uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, uint64_t);
  char *v39;
  char *v40;
  unint64_t v41;
  unint64_t *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;

  v12 = *(const char **)(*(_QWORD *)(*(_QWORD *)(a6 + 8) + 24) + 16);
  v13 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v13, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v43 = v12;
  v41 = swift_getAssociatedTypeWitness(0, v12, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v41);
  v16 = (char *)&v36 - v15;
  v42 = swift_checkMetadataState(0, AssociatedTypeWitness);
  MEMORY[0x1E0C80A78](v42);
  v40 = (char *)&v36 - v17;
  (*(void (**)(uint64_t, uint64_t))(v13 + 48))(a2, v13);
  v18 = *(uint64_t (**)(uint64_t, uint64_t))(v13 + 40);
  v44 = a2;
  v45 = a7;
  result = v18(a2, v13);
  if (result < 0)
    goto LABEL_12;
  v20 = result;
  v39 = v16;
  if (result)
  {
    v21 = 0;
    v22 = *(uint64_t (**)(uint64_t, uint64_t))(a5 + 8);
    while (1)
    {
      v23 = a1;
      v24 = a3;
      v25 = a3;
      v26 = a5;
      v27 = v22(v25, a5);
      v28 = v18(v44, v13);
      if ((v28 & 0x8000000000000000) != 0)
        break;
      if (v21 >= v28)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v37 = v22;
      v29 = v41;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v43, (uint64_t)v42, v41, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v31 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      v38 = v18;
      v32 = v39;
      if ((v27 & 0x20000) != 0)
      {
        v33 = &unk_1816B7DA8;
        v34 = 256;
      }
      else
      {
        v33 = &unk_1816B7DB8;
        v34 = 257;
      }
      v31(v33, v34, v29, AssociatedConformanceWitness);
      v35 = v40;
      (*((void (**)(char *))v43 + 3))(v32);
      result = (*(uint64_t (**)(char *, unint64_t, uint64_t, uint64_t))(v13 + 64))(v35, v21++, v44, v13);
      a5 = v26;
      a3 = v24;
      a1 = v23;
      v22 = v37;
      v18 = v38;
      if (v20 == v21)
        return result;
    }
LABEL_12:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return result;
}

uint64_t static SIMDMask.random()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return specialized static SIMDMask.random<A>(using:)(a1, a1, a2, a3);
}

uint64_t SIMD<>.leadingZeroBitCount.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  void (*v33)(uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v5 = a1;
  v7 = *(_QWORD *)(a2 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v37 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v32 - v12;
  v14 = a4;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v36 = v13;
  if (result)
  {
    v16 = 0;
    v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v34 = v7;
    v35 = result;
    do
    {
      v38 = v16 + 1;
      v33(v16, v5, v7);
      v17 = (*(uint64_t (**)(unint64_t, uint64_t))(a3 + 152))(AssociatedTypeWitness, a3);
      v18 = (*(uint64_t (**)(char *, unint64_t))(v37 + 8))(v11, AssociatedTypeWitness);
      v39 = v17;
      v19 = AssociatedTypeWitness;
      v20 = v11;
      v21 = v14;
      v22 = v5;
      v23 = *(_QWORD *)(a3 + 8);
      v24 = a3;
      v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v23 + 88);
      v28 = lazy protocol witness table accessor for type Int and conformance Int(v18, v26, v27);
      v29 = v36;
      v30 = v23;
      v5 = v22;
      v11 = v20;
      AssociatedTypeWitness = v19;
      v25(&v39, &type metadata for Int, v28, v19, v30);
      a3 = v24;
      v7 = v34;
      v31 = v29;
      v14 = v21;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v31, v16, v5, v34);
      result = v35;
      v16 = v38;
    }
    while (v35 != v38);
  }
  return result;
}

uint64_t SIMD<>.trailingZeroBitCount.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void (*v25)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  void (*v33)(uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v37 = a3;
  v4 = a1;
  v6 = *(_QWORD *)(a2 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v32 - v12;
  v14 = a4;
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(v4, v6);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 40))(v4, v6);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v36 = v13;
  if (result)
  {
    v16 = 0;
    v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56);
    v34 = result;
    v35 = v6;
    do
    {
      v38 = v16 + 1;
      v33(v16, v4, v6);
      v17 = v14;
      v18 = v4;
      v19 = *(_QWORD *)(v37 + 8);
      v20 = (*(uint64_t (**)(unint64_t, uint64_t))(v19 + 144))(AssociatedTypeWitness, v19);
      v21 = (*(uint64_t (**)(char *, unint64_t))(v8 + 8))(v11, AssociatedTypeWitness);
      v39 = v20;
      v22 = AssociatedTypeWitness;
      v23 = v11;
      v24 = v8;
      v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v19 + 88);
      v28 = lazy protocol witness table accessor for type Int and conformance Int(v21, v26, v27);
      v29 = v36;
      v30 = v19;
      v4 = v18;
      v6 = v35;
      v25(&v39, &type metadata for Int, v28, v22, v30);
      v8 = v24;
      v11 = v23;
      AssociatedTypeWitness = v22;
      v31 = v29;
      v14 = v17;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v6 + 64))(v31, v16, v4, v6);
      result = v34;
      v16 = v38;
    }
    while (v34 != v38);
  }
  return result;
}

uint64_t SIMD<>.nonzeroBitCount.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  void (*v33)(uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v5 = a1;
  v7 = *(_QWORD *)(a2 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v37 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v32 - v12;
  v14 = a4;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(v5, v7);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(v5, v7);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v36 = v13;
  if (result)
  {
    v16 = 0;
    v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v34 = v7;
    v35 = result;
    do
    {
      v38 = v16 + 1;
      v33(v16, v5, v7);
      v17 = (*(uint64_t (**)(unint64_t, uint64_t))(a3 + 144))(AssociatedTypeWitness, a3);
      v18 = (*(uint64_t (**)(char *, unint64_t))(v37 + 8))(v11, AssociatedTypeWitness);
      v39 = v17;
      v19 = AssociatedTypeWitness;
      v20 = v11;
      v21 = v14;
      v22 = v5;
      v23 = *(_QWORD *)(a3 + 8);
      v24 = a3;
      v25 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, unint64_t, uint64_t))(v23 + 88);
      v28 = lazy protocol witness table accessor for type Int and conformance Int(v18, v26, v27);
      v29 = v36;
      v30 = v23;
      v5 = v22;
      v11 = v20;
      AssociatedTypeWitness = v19;
      v25(&v39, &type metadata for Int, v28, v19, v30);
      a3 = v24;
      v7 = v34;
      v31 = v29;
      v14 = v21;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v34 + 64))(v31, v16, v5, v34);
      result = v35;
      v16 = v38;
    }
    while (v35 != v38);
  }
  return result;
}

uint64_t static SIMD<>.~ prefix(_:)@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t, uint64_t);
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = a3;
  v6 = *(_QWORD *)(a2 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v17 - v12;
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(a1, v6);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 40))(a1, v6);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v18 = v8;
  v19 = a4;
  if (result)
  {
    v15 = 0;
    v17 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56);
    do
    {
      v16 = result;
      v17(v15, a1, v6);
      (*(void (**)(char *, unint64_t))(*(_QWORD *)(v20 + 8) + 184))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v18 + 8))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v6 + 64))(v13, v15, a1, v6);
      result = v16;
      ++v15;
    }
    while (v16 != v15);
  }
  return result;
}

uint64_t static SIMD<>.& infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v36 + 8) + 192))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 192))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v57 + 8) + 192))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.^ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v36 + 8) + 224))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 224))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v57 + 8) + 224))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.| infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v36 + 8) + 208))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 208))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v57 + 8) + 208))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.&<< infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  char *v24;
  void (*v25)(char *, unint64_t);
  char *v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = a2;
  v27 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v33 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v27 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v31 = a6;
  v32 = a5;
  v30 = v18;
  if (result)
  {
    v20 = AssociatedTypeWitness;
    v21 = 0;
    v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v29 = result;
    do
    {
      v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      v23 = v9;
      v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 216))(v16, v13, v20);
      v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      v26 = v24;
      v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      result = v29;
      ++v21;
    }
    while (v29 != v21);
  }
  return result;
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, unint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v56 = a5;
  v57 = a2;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v50 = (char *)&v48 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v59 = (char *)&v48 - v17;
  MEMORY[0x1E0C80A78](v16);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v55 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v54 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v54)(a3, v9);
  v27 = v21;
  v28 = a3;
  v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v29 = v53(a3, v9);
  if (v29 < 0)
    goto LABEL_10;
  v30 = v29;
  v49 = v13;
  v58 = a6;
  v31 = AssociatedTypeWitness;
  v32 = v59;
  if (v29)
  {
    v33 = 0;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }
    while (v30 != v33);
  }
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v55 + 1);
  v34(v26, v31);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v28);
  ((void (*)(uint64_t, uint64_t))v54)(v28, v9);
  v36 = v53(v28, v9);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v35;
  v39 = v49;
  v38 = v50;
  v55 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v40, v28, v9);
      v42(v40, v28, v9);
      v43 = v9;
      v44 = v59;
      (*(void (**)(char *, char *, unint64_t))(v56 + 216))(v38, v39, v31);
      v45 = (void (*)(char *, unint64_t))v55;
      v55((uint64_t)v39, v31);
      v45(v38, v31);
      v46 = v44;
      v9 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v28, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v28);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t);
  uint64_t v42;
  char *v43;
  void (*v44)(char *, unint64_t);
  char *v45;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  char *v53;
  void (*v54)(uint64_t, unint64_t);
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;

  v55 = a5;
  v49 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v50 = (char *)&v47 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v57 = (char *)&v47 - v17;
  MEMORY[0x1E0C80A78](v16);
  v51 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v47 - v18);
  v21 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v58 = (char *)&v47 - v23;
  v54 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v53 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v53)(a3, v9);
  v27 = v21;
  v28 = a3;
  v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v29 = v52(a3, v9);
  if (v29 < 0)
    goto LABEL_10;
  v30 = v29;
  v48 = v13;
  v56 = a6;
  v31 = AssociatedTypeWitness;
  v32 = v57;
  if (v29)
  {
    v33 = 0;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }
    while (v30 != v33);
  }
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v54 + 1);
  v34(v26, v31);
  (*(void (**)(char *, char *, uint64_t))(v51 + 32))(v58, v27, v28);
  ((void (*)(uint64_t, uint64_t))v53)(v28, v9);
  v35 = v52(v28, v9);
  if (v35 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v48;
  v36 = v49;
  v54 = v34;
  v38 = v50;
  if (v35)
  {
    v39 = 0;
    v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    v53 = (char *)v35;
    do
    {
      v40 = v36;
      v41 = (void (*)(char *, uint64_t, uint64_t))v52;
      ((void (*)(char *, uint64_t, uint64_t))v52)(v39, v28, v9);
      v41(v39, v28, v9);
      v42 = v9;
      v43 = v57;
      (*(void (**)(char *, char *, unint64_t))(v55 + 216))(v38, v37, v31);
      v44 = (void (*)(char *, unint64_t))v54;
      v54((uint64_t)v37, v31);
      v44(v38, v31);
      v45 = v43;
      v9 = v42;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v42 + 64))(v45, v39, v28, v42);
      v36 = v40;
      ++v39;
    }
    while (v53 != v39);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v51 + 8))(v58, v28);
}

uint64_t static SIMD<>.&>> infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  char *v24;
  void (*v25)(char *, unint64_t);
  char *v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = a2;
  v27 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v33 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v27 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v31 = a6;
  v32 = a5;
  v30 = v18;
  if (result)
  {
    v20 = AssociatedTypeWitness;
    v21 = 0;
    v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v29 = result;
    do
    {
      v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      v23 = v9;
      v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 200))(v16, v13, v20);
      v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      v26 = v24;
      v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      result = v29;
      ++v21;
    }
    while (v29 != v21);
  }
  return result;
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, unint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v56 = a5;
  v57 = a2;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v50 = (char *)&v48 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v59 = (char *)&v48 - v17;
  MEMORY[0x1E0C80A78](v16);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v55 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v54 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v54)(a3, v9);
  v27 = v21;
  v28 = a3;
  v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v29 = v53(a3, v9);
  if (v29 < 0)
    goto LABEL_10;
  v30 = v29;
  v49 = v13;
  v58 = a6;
  v31 = AssociatedTypeWitness;
  v32 = v59;
  if (v29)
  {
    v33 = 0;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }
    while (v30 != v33);
  }
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v55 + 1);
  v34(v26, v31);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v28);
  ((void (*)(uint64_t, uint64_t))v54)(v28, v9);
  v36 = v53(v28, v9);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v35;
  v39 = v49;
  v38 = v50;
  v55 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v40, v28, v9);
      v42(v40, v28, v9);
      v43 = v9;
      v44 = v59;
      (*(void (**)(char *, char *, unint64_t))(v56 + 200))(v38, v39, v31);
      v45 = (void (*)(char *, unint64_t))v55;
      v55((uint64_t)v39, v31);
      v45(v38, v31);
      v46 = v44;
      v9 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v28, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v28);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t);
  uint64_t v42;
  char *v43;
  void (*v44)(char *, unint64_t);
  char *v45;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  char *v53;
  void (*v54)(uint64_t, unint64_t);
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;

  v55 = a5;
  v49 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v50 = (char *)&v47 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v57 = (char *)&v47 - v17;
  MEMORY[0x1E0C80A78](v16);
  v51 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v47 - v18);
  v21 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v58 = (char *)&v47 - v23;
  v54 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v53 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v53)(a3, v9);
  v27 = v21;
  v28 = a3;
  v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v29 = v52(a3, v9);
  if (v29 < 0)
    goto LABEL_10;
  v30 = v29;
  v48 = v13;
  v56 = a6;
  v31 = AssociatedTypeWitness;
  v32 = v57;
  if (v29)
  {
    v33 = 0;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }
    while (v30 != v33);
  }
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v54 + 1);
  v34(v26, v31);
  (*(void (**)(char *, char *, uint64_t))(v51 + 32))(v58, v27, v28);
  ((void (*)(uint64_t, uint64_t))v53)(v28, v9);
  v35 = v52(v28, v9);
  if (v35 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v48;
  v36 = v49;
  v54 = v34;
  v38 = v50;
  if (v35)
  {
    v39 = 0;
    v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    v53 = (char *)v35;
    do
    {
      v40 = v36;
      v41 = (void (*)(char *, uint64_t, uint64_t))v52;
      ((void (*)(char *, uint64_t, uint64_t))v52)(v39, v28, v9);
      v41(v39, v28, v9);
      v42 = v9;
      v43 = v57;
      (*(void (**)(char *, char *, unint64_t))(v55 + 200))(v38, v37, v31);
      v44 = (void (*)(char *, unint64_t))v54;
      v54((uint64_t)v37, v31);
      v44(v38, v31);
      v45 = v43;
      v9 = v42;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v42 + 64))(v45, v39, v28, v42);
      v36 = v40;
      ++v39;
    }
    while (v53 != v39);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v51 + 8))(v58, v28);
}

uint64_t static SIMD<>.&+ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  char *v24;
  void (*v25)(char *, unint64_t);
  char *v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = a2;
  v27 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v33 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v27 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v31 = a6;
  v32 = a5;
  v30 = v18;
  if (result)
  {
    v20 = AssociatedTypeWitness;
    v21 = 0;
    v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v29 = result;
    do
    {
      v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      v23 = v9;
      v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 80))(v30, v13, v20);
      v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      v26 = v24;
      v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      result = v29;
      ++v21;
    }
    while (v29 != v21);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, uint64_t);
  char *v46;
  char *v48;
  char *v49;
  char *v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v56 = a2;
  v57 = a5;
  v58 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v50 = (char *)&v48 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v59 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v18 = MEMORY[0x1E0C80A78]((char *)&v48 - v17);
  v20 = (char *)&v48 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v48 - v22;
  v55 = v24;
  v25 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v24 + 2);
  v26 = v21;
  v28 = v27;
  v25(v21, a1);
  v53 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v53(a3, v8);
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v54 = v20;
  v30 = a3;
  v51 = v29;
  v31 = v29(a3, v8);
  if (v31 < 0)
    goto LABEL_10;
  v32 = v31;
  v48 = v12;
  v49 = v23;
  v33 = v59;
  v34 = v54;
  if (v31)
  {
    v35 = 0;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }
    while (v32 != v35);
  }
  v36 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v55 + 1);
  v36(v26, v28);
  v37 = v49;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v49, v34, v30);
  v53(v30, v8);
  v38 = v51(v30, v8);
  if (v38 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v55 = v36;
  v39 = v48;
  v40 = v50;
  if (v38)
  {
    v41 = 0;
    v53 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v38;
    do
    {
      v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v41, v30, v8);
      v42(v41, v30, v8);
      v43 = v8;
      v44 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 80))(v59, v39, v28);
      v45 = (void (*)(char *, uint64_t))v55;
      v55((uint64_t)v39, v28);
      v45(v40, v28);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v30, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v30);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  void (*v43)(char *, uint64_t, uint64_t);
  uint64_t v44;
  char *v45;
  void (*v46)(char *, uint64_t);
  char *v47;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  uint64_t v53;
  void (*v54)(uint64_t, uint64_t);
  char *v55;
  void (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v49 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v51 = (char *)&v49 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v59 = (char *)&v49 - v16;
  MEMORY[0x1E0C80A78](v15);
  v53 = *(_QWORD *)(a3 - 8);
  v18 = MEMORY[0x1E0C80A78]((char *)&v49 - v17);
  v20 = (char *)&v49 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v49 - v22;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v24 + 2);
  v26 = v21;
  v28 = v27;
  v25(v21, a2);
  v54 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v54(a3, v8);
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v55 = v20;
  v30 = a3;
  v52 = v29;
  v31 = v29(a3, v8);
  if (v31 < 0)
    goto LABEL_10;
  v32 = v31;
  v60 = v23;
  v49 = v12;
  v33 = v59;
  v34 = v55;
  if (v31)
  {
    v35 = 0;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }
    while (v32 != v35);
  }
  v36 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v56 + 1);
  v36(v26, v28);
  (*(void (**)(char *, char *, uint64_t))(v53 + 32))(v60, v34, v30);
  v54(v30, v8);
  v37 = v52(v30, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v56 = v36;
  v39 = v49;
  v38 = v50;
  v40 = v51;
  if (v37)
  {
    v41 = 0;
    v54 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    v55 = (char *)v37;
    do
    {
      v42 = v38;
      v43 = (void (*)(char *, uint64_t, uint64_t))v54;
      ((void (*)(char *, uint64_t, uint64_t))v54)(v41, v30, v8);
      v43(v41, v30, v8);
      v44 = v8;
      v45 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 80))(v59, v39, v28);
      v46 = (void (*)(char *, uint64_t))v56;
      v56((uint64_t)v39, v28);
      v46(v40, v28);
      v47 = v45;
      v8 = v44;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v44 + 64))(v47, v41, v30, v44);
      v38 = v42;
      ++v41;
    }
    while (v55 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v60, v30);
}

uint64_t static SIMD<>.&* infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  char *v24;
  void (*v25)(char *, unint64_t);
  char *v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = a2;
  v27 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v33 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v27 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v31 = a6;
  v32 = a5;
  v30 = v18;
  if (result)
  {
    v20 = AssociatedTypeWitness;
    v21 = 0;
    v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v29 = result;
    do
    {
      v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      v23 = v9;
      v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 96))(v30, v16, v20);
      v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      v26 = v24;
      v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      result = v29;
      ++v21;
    }
    while (v29 != v21);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, uint64_t);
  char *v46;
  char *v48;
  char *v49;
  char *v50;
  uint64_t (*v51)(uint64_t, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v56 = a2;
  v57 = a5;
  v58 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v50 = (char *)&v48 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v59 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v18 = MEMORY[0x1E0C80A78]((char *)&v48 - v17);
  v20 = (char *)&v48 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v48 - v22;
  v55 = v24;
  v25 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v24 + 2);
  v26 = v21;
  v28 = v27;
  v25(v21, a1);
  v53 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v53(a3, v8);
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v54 = v20;
  v30 = a3;
  v51 = v29;
  v31 = v29(a3, v8);
  if (v31 < 0)
    goto LABEL_10;
  v32 = v31;
  v48 = v12;
  v49 = v23;
  v33 = v59;
  v34 = v54;
  if (v31)
  {
    v35 = 0;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }
    while (v32 != v35);
  }
  v36 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v55 + 1);
  v36(v26, v28);
  v37 = v49;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v49, v34, v30);
  v53(v30, v8);
  v38 = v51(v30, v8);
  if (v38 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v55 = v36;
  v39 = v48;
  v40 = v50;
  if (v38)
  {
    v41 = 0;
    v53 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v38;
    do
    {
      v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v41, v30, v8);
      v42(v41, v30, v8);
      v43 = v8;
      v44 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 96))(v59, v40, v28);
      v45 = (void (*)(char *, uint64_t))v55;
      v55((uint64_t)v39, v28);
      v45(v40, v28);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v30, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v30);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  uint64_t v42;
  void (*v43)(char *, uint64_t, uint64_t);
  uint64_t v44;
  char *v45;
  void (*v46)(char *, uint64_t);
  char *v47;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  uint64_t v53;
  void (*v54)(uint64_t, uint64_t);
  char *v55;
  void (*v56)(uint64_t, uint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v49 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v51 = (char *)&v49 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v59 = (char *)&v49 - v16;
  MEMORY[0x1E0C80A78](v15);
  v53 = *(_QWORD *)(a3 - 8);
  v18 = MEMORY[0x1E0C80A78]((char *)&v49 - v17);
  v20 = (char *)&v49 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = MEMORY[0x1E0C80A78](v18);
  v23 = (char *)&v49 - v22;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v24 + 2);
  v26 = v21;
  v28 = v27;
  v25(v21, a2);
  v54 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v54(a3, v8);
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v55 = v20;
  v30 = a3;
  v52 = v29;
  v31 = v29(a3, v8);
  if (v31 < 0)
    goto LABEL_10;
  v32 = v31;
  v60 = v23;
  v49 = v12;
  v33 = v59;
  v34 = v55;
  if (v31)
  {
    v35 = 0;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v25)(v33, v26, v28);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v35++, v30, v8);
    }
    while (v32 != v35);
  }
  v36 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v56 + 1);
  v36(v26, v28);
  (*(void (**)(char *, char *, uint64_t))(v53 + 32))(v60, v34, v30);
  v54(v30, v8);
  v37 = v52(v30, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v56 = v36;
  v39 = v49;
  v38 = v50;
  v40 = v51;
  if (v37)
  {
    v41 = 0;
    v54 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    v55 = (char *)v37;
    do
    {
      v42 = v38;
      v43 = (void (*)(char *, uint64_t, uint64_t))v54;
      ((void (*)(char *, uint64_t, uint64_t))v54)(v41, v30, v8);
      v43(v41, v30, v8);
      v44 = v8;
      v45 = v59;
      (*(void (**)(char *, char *, uint64_t))(v57 + 96))(v59, v40, v28);
      v46 = (void (*)(char *, uint64_t))v56;
      v56((uint64_t)v39, v28);
      v46(v40, v28);
      v47 = v45;
      v8 = v44;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v44 + 64))(v47, v41, v30, v44);
      v38 = v42;
      ++v41;
    }
    while (v55 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v53 + 8))(v60, v30);
}

uint64_t static SIMD<>./ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v36 + 8) + 152))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t, uint64_t);
  uint64_t v23;
  char *v24;
  void (*v25)(char *, unint64_t);
  char *v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = a2;
  v27 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v33 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v27 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v27 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v27 - v17;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v31 = a6;
  v32 = a5;
  v30 = v18;
  if (result)
  {
    v20 = AssociatedTypeWitness;
    v21 = 0;
    v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v29 = result;
    do
    {
      v22 = v28;
      v28(v21, a3, v9);
      v22(v21, a3, v9);
      v23 = v9;
      v24 = v30;
      (*(void (**)(char *, char *, unint64_t))(v32 + 192))(v16, v13, v20);
      v25 = *(void (**)(char *, unint64_t))(v33 + 8);
      v25(v13, v20);
      v25(v16, v20);
      v26 = v24;
      v9 = v23;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 64))(v26, v21, a3, v23);
      result = v29;
      ++v21;
    }
    while (v29 != v21);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 152))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v57 + 8) + 152))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  char *v54;
  void (*v55)(uint64_t, unint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v56 = a5;
  v57 = a2;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v50 = (char *)&v48 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v59 = (char *)&v48 - v17;
  MEMORY[0x1E0C80A78](v16);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v55 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v54 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v54)(a3, v9);
  v27 = v21;
  v28 = a3;
  v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v29 = v53(a3, v9);
  if (v29 < 0)
    goto LABEL_10;
  v30 = v29;
  v49 = v13;
  v58 = a6;
  v31 = AssociatedTypeWitness;
  v32 = v59;
  if (v29)
  {
    v33 = 0;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }
    while (v30 != v33);
  }
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v55 + 1);
  v34(v26, v31);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v28);
  ((void (*)(uint64_t, uint64_t))v54)(v28, v9);
  v36 = v53(v28, v9);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v35;
  v39 = v49;
  v38 = v50;
  v55 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = (void (*)(char *, uint64_t, uint64_t))v53;
      ((void (*)(char *, uint64_t, uint64_t))v53)(v40, v28, v9);
      v42(v40, v28, v9);
      v43 = v9;
      v44 = v59;
      (*(void (**)(char *, char *, unint64_t))(v56 + 192))(v38, v39, v31);
      v45 = (void (*)(char *, unint64_t))v55;
      v55((uint64_t)v39, v31);
      v45(v38, v31);
      v46 = v44;
      v9 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v28, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v37, v28);
}

{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t);
  uint64_t v42;
  char *v43;
  void (*v44)(char *, unint64_t);
  char *v45;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t (*v52)(uint64_t, uint64_t);
  char *v53;
  void (*v54)(uint64_t, unint64_t);
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;

  v55 = a5;
  v49 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v50 = (char *)&v47 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v57 = (char *)&v47 - v17;
  MEMORY[0x1E0C80A78](v16);
  v51 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v47 - v18);
  v21 = (char *)&v47 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v58 = (char *)&v47 - v23;
  v54 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v53 = *(char **)(v9 + 48);
  ((void (*)(uint64_t, uint64_t))v53)(a3, v9);
  v27 = v21;
  v28 = a3;
  v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v29 = v52(a3, v9);
  if (v29 < 0)
    goto LABEL_10;
  v30 = v29;
  v48 = v13;
  v56 = a6;
  v31 = AssociatedTypeWitness;
  v32 = v57;
  if (v29)
  {
    v33 = 0;
    do
    {
      v25((uint64_t)v32, v26, v31);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v32, v33++, v28, v9);
    }
    while (v30 != v33);
  }
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v54 + 1);
  v34(v26, v31);
  (*(void (**)(char *, char *, uint64_t))(v51 + 32))(v58, v27, v28);
  ((void (*)(uint64_t, uint64_t))v53)(v28, v9);
  v35 = v52(v28, v9);
  if (v35 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v48;
  v36 = v49;
  v54 = v34;
  v38 = v50;
  if (v35)
  {
    v39 = 0;
    v52 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 56);
    v53 = (char *)v35;
    do
    {
      v40 = v36;
      v41 = (void (*)(char *, uint64_t, uint64_t))v52;
      ((void (*)(char *, uint64_t, uint64_t))v52)(v39, v28, v9);
      v41(v39, v28, v9);
      v42 = v9;
      v43 = v57;
      (*(void (**)(char *, char *, unint64_t))(v55 + 192))(v38, v37, v31);
      v44 = (void (*)(char *, unint64_t))v54;
      v54((uint64_t)v37, v31);
      v44(v38, v31);
      v45 = v43;
      v9 = v42;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v42 + 64))(v45, v39, v28, v42);
      v36 = v40;
      ++v39;
    }
    while (v53 != v39);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v51 + 8))(v58, v28);
}

uint64_t static SIMD<>.% infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v36 + 8) + 168))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 168))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v57 + 8) + 168))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.+ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36 + 16) + 8)
                                                                           + 8)
                                                               + 24))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v58 + 16) + 8)
                                                                           + 8)
                                                               + 24))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v57 + 16) + 8)
                                                                           + 8)
                                                               + 24))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.- infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v36 + 16) + 8)
                                                                           + 8)
                                                               + 40))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v58 + 16) + 8)
                                                                           + 8)
                                                               + 40))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v57 + 16) + 8)
                                                                           + 8)
                                                               + 40))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t static SIMD<>.* infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  char *v26;
  void (*v27)(char *, unint64_t);
  char *v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v35 = a2;
  v36 = a5;
  v29 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v29 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v29 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v20 = v29;
  v33 = v10;
  v34 = a6;
  v32 = v18;
  if (result)
  {
    v21 = a3;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v23 = v20;
      v24 = v30;
      v30(v22, v21, v8);
      v24(v22, v21, v8);
      v25 = v8;
      v26 = v32;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v36 + 16) + 8) + 64))(v16, v13, AssociatedTypeWitness);
      v27 = *(void (**)(char *, unint64_t))(v33 + 8);
      v27(v13, AssociatedTypeWitness);
      v27(v16, AssociatedTypeWitness);
      v28 = v26;
      v8 = v25;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v28, v22, v21, v25);
      v20 = v23;
      result = v31;
      ++v22;
    }
    while (v31 != v22);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  char *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v57 = a2;
  v58 = a5;
  v59 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v50 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v51 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a1, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  v35 = v51;
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v51, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v36 = v33;
  v37 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v37 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v35;
  v39 = v49;
  v40 = v50;
  v55 = v32;
  v56 = v34;
  if (v37)
  {
    v41 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v37;
    do
    {
      v42 = v53;
      v53(v41, v36, v8);
      v42(v41, v36, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v58 + 16) + 8) + 64))(v39, v40, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v40, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v41++, v36, v43);
    }
    while (v54 != v41);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v38, v36);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, unint64_t);
  void (*v25)(uint64_t, uint64_t, unint64_t);
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  void (*v34)(uint64_t, unint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  void (*v42)(char *, uint64_t, uint64_t);
  uint64_t v43;
  char *v44;
  void (*v45)(char *, unint64_t);
  char *v46;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void (*v53)(char *, uint64_t, uint64_t);
  char *v54;
  char *v55;
  void (*v56)(uint64_t, unint64_t);
  uint64_t v57;
  uint64_t v58;
  char *v59;

  v57 = a5;
  v58 = a6;
  v50 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v51 = (char *)&v48 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  MEMORY[0x1E0C80A78](v15);
  v52 = *(_QWORD *)(a3 - 8);
  v19 = MEMORY[0x1E0C80A78]((char *)&v48 - v18);
  v21 = (char *)&v48 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v22 = MEMORY[0x1E0C80A78](v19);
  v59 = (char *)&v48 - v23;
  v56 = v24;
  v25 = (void (*)(uint64_t, uint64_t, unint64_t))*((_QWORD *)v24 + 2);
  v26 = v22;
  v25(v22, a2, AssociatedTypeWitness);
  v55 = *(char **)(v8 + 48);
  ((void (*)(uint64_t, uint64_t))v55)(a3, v8);
  v27 = v21;
  v54 = *(char **)(v8 + 40);
  v28 = ((uint64_t (*)(uint64_t, uint64_t))v54)(a3, v8);
  if (v28 < 0)
    goto LABEL_10;
  v29 = v28;
  v49 = v14;
  if (v28)
  {
    v30 = 0;
    do
    {
      v25((uint64_t)v17, v26, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v30++, a3, v8);
    }
    while (v29 != v30);
  }
  v31 = v26;
  v32 = v17;
  v33 = a3;
  v34 = (void (*)(uint64_t, unint64_t))*((_QWORD *)v56 + 1);
  v34(v31, AssociatedTypeWitness);
  (*(void (**)(char *, char *, uint64_t))(v52 + 32))(v59, v27, v33);
  ((void (*)(uint64_t, uint64_t))v55)(v33, v8);
  v35 = v33;
  v36 = ((uint64_t (*)(uint64_t, uint64_t))v54)(v33, v8);
  if (v36 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v37 = v50;
  v38 = v51;
  v39 = v49;
  v55 = v32;
  v56 = v34;
  if (v36)
  {
    v40 = 0;
    v53 = *(void (**)(char *, uint64_t, uint64_t))(v8 + 56);
    v54 = (char *)v36;
    do
    {
      v41 = v37;
      v42 = v53;
      v53(v40, v35, v8);
      v42(v40, v35, v8);
      v43 = v8;
      v44 = v55;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v57 + 16) + 8) + 64))(v39, v38, AssociatedTypeWitness);
      v45 = (void (*)(char *, unint64_t))v56;
      v56((uint64_t)v38, AssociatedTypeWitness);
      v45(v39, AssociatedTypeWitness);
      v46 = v44;
      v8 = v43;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v43 + 64))(v46, v40, v35, v43);
      v37 = v41;
      ++v40;
    }
    while (v54 != v40);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v52 + 8))(v59, v35);
}

uint64_t SIMD<>.addingProduct(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t result;
  char *v21;
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t, uint64_t);
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  void (*v28)(char *, unint64_t);
  char *v29;
  void (*v30)(uint64_t, uint64_t, uint64_t);
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v34 = a2;
  v35 = a5;
  v38 = a1;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v37 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v30 - v14;
  v16 = MEMORY[0x1E0C80A78](v13);
  v18 = (char *)&v30 - v17;
  MEMORY[0x1E0C80A78](v16);
  v36 = (char *)&v30 - v19;
  (*(void (**)(uint64_t, uint64_t))(v8 + 48))(a3, v8);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 40))(a3, v8);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v32 = v12;
  v33 = a6;
  if (result)
  {
    v21 = v15;
    v22 = 0;
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 56);
    v31 = result;
    do
    {
      v39 = v22 + 1;
      v23 = v30;
      v30(v22, a3, v8);
      v23(v22, a3, v8);
      v24 = v8;
      v25 = v21;
      v26 = v32;
      v23(v22, a3, v24);
      v27 = v36;
      (*(void (**)(char *, char *, unint64_t))(v35 + 256))(v25, v26, AssociatedTypeWitness);
      v28 = *(void (**)(char *, unint64_t))(v37 + 8);
      v29 = v26;
      v21 = v25;
      v8 = v24;
      v28(v29, AssociatedTypeWitness);
      v28(v21, AssociatedTypeWitness);
      v28(v18, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v27, v22, a3, v24);
      result = v31;
      v22 = v39;
    }
    while (v31 != v39);
  }
  return result;
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(uint64_t, uint64_t, uint64_t);
  uint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  void (*v51)(uint64_t, uint64_t);
  _QWORD v53[2];
  char *v54;
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(uint64_t, uint64_t);
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;

  v59 = a5;
  v60 = a2;
  v63 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v61 = (char *)v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)v53 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v54 = (char *)v53 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v62 = (char *)v53 - v18;
  MEMORY[0x1E0C80A78](v17);
  v55 = *(_QWORD *)(a3 - 8);
  v20 = MEMORY[0x1E0C80A78]((char *)v53 - v19);
  v22 = (char *)v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  v64 = (char *)v53 - v24;
  v65 = v25;
  v26 = *(void (**)(uint64_t, uint64_t))(v25 + 16);
  v27 = v23;
  v29 = v28;
  v26(v23, a1);
  v58 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v58(a3, v8);
  v30 = a3;
  v57 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v31 = v57(a3, v8);
  if (v31 < 0)
    goto LABEL_10;
  v32 = v31;
  v53[0] = v14;
  v33 = v62;
  if (v31)
  {
    v34 = 0;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v26)(v33, v27, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v34++, v30, v8);
    }
    while (v32 != v34);
  }
  v35 = v8;
  v36 = *(void (**)(uint64_t, uint64_t))(v65 + 8);
  v36(v27, v29);
  (*(void (**)(char *, char *, uint64_t))(v55 + 32))(v64, v22, v30);
  v58(v30, v35);
  v37 = v35;
  v38 = v57(v30, v35);
  if (v38 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v39 = v29;
  v41 = v53[0];
  v40 = v53[1];
  v58 = v36;
  v42 = v30;
  v43 = v54;
  if (v38)
  {
    v44 = 0;
    v56 = *(void (**)(uint64_t, uint64_t, uint64_t))(v37 + 56);
    v57 = (uint64_t (*)(uint64_t, uint64_t))v38;
    do
    {
      v65 = v44 + 1;
      v45 = v40;
      v46 = v56;
      v56(v44, v42, v37);
      v46(v44, v42, v37);
      v47 = v41;
      v48 = v61;
      v46(v44, v42, v37);
      v49 = v62;
      (*(void (**)(uint64_t, char *, uint64_t))(v59 + 256))(v47, v48, v39);
      v50 = v48;
      v41 = v47;
      v51 = v58;
      v58((uint64_t)v50, v39);
      v51(v47, v39);
      v51((uint64_t)v43, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v37 + 64))(v49, v44, v42, v37);
      v40 = v45;
      v44 = v65;
    }
    while (v57 != (uint64_t (*)(uint64_t, uint64_t))v65);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v55 + 8))(v64, v42);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(uint64_t, uint64_t, uint64_t);
  uint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  void (*v51)(uint64_t, uint64_t);
  _QWORD v53[2];
  char *v54;
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(uint64_t, uint64_t);
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;

  v59 = a5;
  v60 = a1;
  v63 = a6;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v61 = (char *)v53 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)v53 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v54 = (char *)v53 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v62 = (char *)v53 - v18;
  MEMORY[0x1E0C80A78](v17);
  v55 = *(_QWORD *)(a3 - 8);
  v20 = MEMORY[0x1E0C80A78]((char *)v53 - v19);
  v22 = (char *)v53 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  v64 = (char *)v53 - v24;
  v65 = v25;
  v26 = *(void (**)(uint64_t, uint64_t))(v25 + 16);
  v27 = v23;
  v29 = v28;
  v26(v23, a2);
  v58 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v58(a3, v8);
  v30 = a3;
  v57 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v31 = v57(a3, v8);
  if (v31 < 0)
    goto LABEL_10;
  v32 = v31;
  v53[0] = v14;
  v33 = v62;
  if (v31)
  {
    v34 = 0;
    do
    {
      ((void (*)(char *, uint64_t, uint64_t))v26)(v33, v27, v29);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v33, v34++, v30, v8);
    }
    while (v32 != v34);
  }
  v35 = v8;
  v36 = *(void (**)(uint64_t, uint64_t))(v65 + 8);
  v36(v27, v29);
  (*(void (**)(char *, char *, uint64_t))(v55 + 32))(v64, v22, v30);
  v58(v30, v35);
  v37 = v35;
  v38 = v57(v30, v35);
  if (v38 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v39 = v29;
  v41 = v53[0];
  v40 = v53[1];
  v58 = v36;
  v42 = v30;
  v43 = v54;
  if (v38)
  {
    v44 = 0;
    v56 = *(void (**)(uint64_t, uint64_t, uint64_t))(v37 + 56);
    v57 = (uint64_t (*)(uint64_t, uint64_t))v38;
    do
    {
      v65 = v44 + 1;
      v45 = v40;
      v46 = v56;
      v56(v44, v42, v37);
      v46(v44, v42, v37);
      v47 = v41;
      v48 = v61;
      v46(v44, v42, v37);
      v49 = v62;
      (*(void (**)(uint64_t, char *, uint64_t))(v59 + 256))(v47, v48, v39);
      v50 = v48;
      v41 = v47;
      v51 = v58;
      v58((uint64_t)v50, v39);
      v51(v47, v39);
      v51((uint64_t)v43, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v37 + 64))(v49, v44, v42, v37);
      v40 = v45;
      v44 = v65;
    }
    while (v57 != (uint64_t (*)(uint64_t, uint64_t))v65);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v55 + 8))(v64, v42);
}

uint64_t SIMD<>.squareRoot()@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  uint64_t result;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t, uint64_t);
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v7 = *(_QWORD *)(a2 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v22 - v13;
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a1, v7);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a1, v7);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v24 = a3;
  v25 = AssociatedTypeWitness;
  v26 = v9;
  v27 = a4;
  if (result)
  {
    v16 = a1;
    v17 = v14;
    v18 = 0;
    v23 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v19 = v25;
    do
    {
      v20 = result;
      v21 = v16;
      v23(v18, v16, v7);
      (*(void (**)(unint64_t))(v24 + 240))(v19);
      (*(void (**)(char *, unint64_t))(v26 + 8))(v12, v19);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v18, v21, v7);
      v16 = v21;
      result = v20;
      ++v18;
    }
    while (v20 != v18);
  }
  return result;
}

uint64_t SIMD<>.rounded(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t result;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, uint64_t, uint64_t);
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v9 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v12 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v14 = (char *)&v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v24 - v15;
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a2, v9);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a2, v9);
  if (result < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v26 = a4;
  v27 = AssociatedTypeWitness;
  v29 = a5;
  v30 = a1;
  v28 = v11;
  if (result)
  {
    v18 = a2;
    v19 = v16;
    v20 = 0;
    v25 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v21 = v27;
    do
    {
      v22 = result;
      v23 = v18;
      v25(v20, v18, v9);
      (*(void (**)(uint64_t, unint64_t))(v26 + 304))(v30, v21);
      (*(void (**)(char *, unint64_t))(v28 + 8))(v14, v21);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v19, v20, v23, v9);
      v18 = v23;
      result = v22;
      ++v20;
    }
    while (v22 != v20);
  }
  return result;
}

uint64_t static SIMDMask..! prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(char *, char *, uint64_t);
  char *v30;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t, uint64_t);
  uint64_t v37;
  uint64_t v38;
  char *v39;

  v38 = a4;
  v35 = a5;
  v7 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v37 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v32 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v32 - v13;
  v15 = *(_QWORD *)(a2 - 8);
  v16 = MEMORY[0x1E0C80A78](v12);
  v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v20 = MEMORY[0x1E0C80A78]((char *)&v32 - v19);
  v34 = (char *)&v32 - v21;
  v22 = v20;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v15 + 16))(v20, a1, a2);
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a2, v7);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a2, v7);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v33 = v15;
  v39 = v18;
  v24 = v22;
  v25 = a2;
  if (v23)
  {
    v26 = 0;
    v36 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    do
    {
      v27 = v23;
      v36(v26, a2, v7);
      (*(void (**)(char *, unint64_t))(*(_QWORD *)(v38 + 8) + 184))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, unint64_t))(v37 + 8))(v11, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v14, v26, a2, v7);
      v23 = v27;
      ++v26;
    }
    while (v27 != v26);
  }
  v28 = v33;
  (*(void (**)(uint64_t, uint64_t))(v33 + 8))(v24, v25);
  v29 = *(void (**)(char *, char *, uint64_t))(v28 + 32);
  v30 = v34;
  v29(v34, v39, v25);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v29)(v35, v30, v25);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t, uint64_t);
  char *v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  void (*v40)(uint64_t, uint64_t);
  void (*v41)(char *, char *, uint64_t);
  char *v42;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;

  v50 = a5;
  v46 = a6;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v49 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v44 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v44 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v44 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  MEMORY[0x1E0C80A78](v23);
  v25 = MEMORY[0x1E0C80A78]((char *)&v44 - v24);
  v44 = (char *)&v44 - v26;
  v45 = v27;
  v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v27 + 16);
  v53 = v25;
  v29 = a1;
  v31 = v30;
  v28(v25, v29, a3);
  v28(v31, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v32 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v51 = v31;
  v52 = v22;
  v48 = v19;
  v33 = a3;
  if (v32)
  {
    v34 = 0;
    v47 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    do
    {
      v35 = v32;
      v36 = v47;
      v47(v34, v33, v9);
      v36(v34, v33, v9);
      v37 = v48;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v50 + 8) + 192))(v16, v13, AssociatedTypeWitness);
      v38 = *(void (**)(char *, unint64_t))(v49 + 8);
      v38(v13, AssociatedTypeWitness);
      v38(v16, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v37, v34, v33, v9);
      v32 = v35;
      ++v34;
    }
    while (v35 != v34);
  }
  v39 = v45;
  v40 = *(void (**)(uint64_t, uint64_t))(v45 + 8);
  v40(v51, v33);
  v40(v53, v33);
  v41 = *(void (**)(char *, char *, uint64_t))(v39 + 32);
  v42 = v44;
  v41(v44, v52, v33);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v41)(v46, v42, v33);
}

uint64_t static SIMDMask..^ infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t, uint64_t);
  char *v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  void (*v40)(uint64_t, uint64_t);
  void (*v41)(char *, char *, uint64_t);
  char *v42;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;

  v50 = a5;
  v46 = a6;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v49 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v44 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v44 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v44 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  MEMORY[0x1E0C80A78](v23);
  v25 = MEMORY[0x1E0C80A78]((char *)&v44 - v24);
  v44 = (char *)&v44 - v26;
  v45 = v27;
  v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v27 + 16);
  v53 = v25;
  v29 = a1;
  v31 = v30;
  v28(v25, v29, a3);
  v28(v31, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v32 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v51 = v31;
  v52 = v22;
  v48 = v19;
  v33 = a3;
  if (v32)
  {
    v34 = 0;
    v47 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    do
    {
      v35 = v32;
      v36 = v47;
      v47(v34, v33, v9);
      v36(v34, v33, v9);
      v37 = v48;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v50 + 8) + 224))(v16, v13, AssociatedTypeWitness);
      v38 = *(void (**)(char *, unint64_t))(v49 + 8);
      v38(v13, AssociatedTypeWitness);
      v38(v16, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v37, v34, v33, v9);
      v32 = v35;
      ++v34;
    }
    while (v35 != v34);
  }
  v39 = v45;
  v40 = *(void (**)(uint64_t, uint64_t))(v45 + 8);
  v40(v51, v33);
  v40(v53, v33);
  v41 = *(void (**)(char *, char *, uint64_t))(v39 + 32);
  v42 = v44;
  v41(v44, v52, v33);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v41)(v46, v42, v33);
}

uint64_t static SIMDMask..| infix(_:_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t, uint64_t);
  char *v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  void (*v40)(uint64_t, uint64_t);
  void (*v41)(char *, char *, uint64_t);
  char *v42;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;

  v50 = a5;
  v46 = a6;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v49 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v44 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v44 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v44 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  MEMORY[0x1E0C80A78](v23);
  v25 = MEMORY[0x1E0C80A78]((char *)&v44 - v24);
  v44 = (char *)&v44 - v26;
  v45 = v27;
  v28 = *(void (**)(uint64_t, uint64_t, uint64_t))(v27 + 16);
  v53 = v25;
  v29 = a1;
  v31 = v30;
  v28(v25, v29, a3);
  v28(v31, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v32 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v51 = v31;
  v52 = v22;
  v48 = v19;
  v33 = a3;
  if (v32)
  {
    v34 = 0;
    v47 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    do
    {
      v35 = v32;
      v36 = v47;
      v47(v34, v33, v9);
      v36(v34, v33, v9);
      v37 = v48;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v50 + 8) + 208))(v16, v13, AssociatedTypeWitness);
      v38 = *(void (**)(char *, unint64_t))(v49 + 8);
      v38(v13, AssociatedTypeWitness);
      v38(v16, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v37, v34, v33, v9);
      v32 = v35;
      ++v34;
    }
    while (v35 != v34);
  }
  v39 = v45;
  v40 = *(void (**)(uint64_t, uint64_t))(v45 + 8);
  v40(v51, v33);
  v40(v53, v33);
  v41 = *(void (**)(char *, char *, uint64_t))(v39 + 32);
  v42 = v44;
  v41(v44, v52, v33);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v41)(v46, v42, v33);
}

uint64_t static SIMD<>.&= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v43 + 8) + 192))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v62 + 8) + 192))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.^= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v43 + 8) + 224))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v62 + 8) + 224))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.|= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v43 + 8) + 208))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v62 + 8) + 208))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.&<<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  char *v35;
  void (*v36)(void);
  char *v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v43 = a2;
  v44 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v35 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v37 = (char *)&v34 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v34 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v38 = v20;
  v22 = (char *)&v34 - v21;
  v36 = *(void (**)(void))(v20 + 32);
  v36();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v34 = a1;
  v41 = v16;
  v42 = v9;
  v24 = v35;
  v25 = v37;
  v45 = v19;
  if (v23)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v23;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(v44 + 216))(v25, v24, v26);
      v31 = *(void (**)(char *, unint64_t))(v42 + 8);
      v31(v24, v26);
      v31(v25, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v45, a3);
}

uint64_t static SIMD<>.&>>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  char *v35;
  void (*v36)(void);
  char *v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v43 = a2;
  v44 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v35 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v37 = (char *)&v34 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v34 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v38 = v20;
  v22 = (char *)&v34 - v21;
  v36 = *(void (**)(void))(v20 + 32);
  v36();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v34 = a1;
  v41 = v16;
  v42 = v9;
  v24 = v35;
  v25 = v37;
  v45 = v19;
  if (v23)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v23;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(v44 + 200))(v25, v24, v26);
      v31 = *(void (**)(char *, unint64_t))(v42 + 8);
      v31(v24, v26);
      v31(v25, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v45, a3);
}

uint64_t static SIMD<>.&+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t, uint64_t);
  uint64_t v28;
  char *v29;
  void (*v30)(char *, unint64_t);
  char *v31;
  uint64_t v33;
  unint64_t AssociatedTypeWitness;
  void (*v35)(void);
  char *v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t, uint64_t);
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v33 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v36 = (char *)&v33 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v33 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v37 = v20;
  v22 = (char *)&v33 - v21;
  v35 = *(void (**)(void))(v20 + 32);
  v35();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v33 = a1;
  v40 = v16;
  v41 = v8;
  v24 = AssociatedTypeWitness;
  v25 = v36;
  v44 = v19;
  if (v23)
  {
    v26 = 0;
    v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v39 = v23;
    do
    {
      v27 = v38;
      v38(v26, a3, v7);
      v27(v26, a3, v7);
      v28 = v7;
      v29 = v40;
      (*(void (**)(char *, char *, unint64_t))(v43 + 80))(v40, v11, v24);
      v30 = *(void (**)(char *, unint64_t))(v41 + 8);
      v30(v11, v24);
      v30(v25, v24);
      v31 = v29;
      v7 = v28;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 64))(v31, v26++, a3, v28);
    }
    while (v39 != v26);
  }
  (*(void (**)(char *, uint64_t))(v37 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v35)(v33, v44, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  unint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  void (*v39)(_QWORD, _QWORD, _QWORD);
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t, uint64_t);
  void (*v58)(void);
  void (*v59)(_QWORD, _QWORD, _QWORD);
  void (*v60)(char *, unint64_t);
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;

  v61 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v53 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v54 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v63 = (char *)&v52 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v52 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v65 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v52 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v62 = (char *)&v52 - v30;
  v55 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v19;
  v33 = AssociatedTypeWitness;
  v31(v19, a2, AssociatedTypeWitness);
  v57 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v57(a3, v8);
  v34 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v59 = (void (*)(_QWORD, _QWORD, _QWORD))v25;
  v35 = a3;
  v56 = v34;
  v36 = v34(a3, v8);
  if (v36 < 0)
    goto LABEL_10;
  v37 = v36;
  v64 = v22;
  v38 = v63;
  v39 = v59;
  if (v36)
  {
    v40 = 0;
    do
    {
      v31(v38, (uint64_t)v32, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v38, v40++, v35, v8);
    }
    while (v37 != v40);
  }
  v41 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v41(v32, v33);
  ((void (*)(char *, _QWORD, uint64_t))v58)(v65, v39, v35);
  v57(v35, v8);
  v42 = v56(v35, v8);
  if (v42 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v43 = v42;
  v45 = v53;
  v44 = v54;
  v60 = v41;
  if (v42)
  {
    v46 = 0;
    v59 = *(void (**)(_QWORD, _QWORD, _QWORD))(v8 + 56);
    do
    {
      v47 = v59;
      v59(v46, v35, v8);
      v47(v46, v35, v8);
      v48 = v63;
      (*(void (**)(char *, char *, unint64_t))(v61 + 80))(v63, v45, v33);
      v49 = v60;
      v60(v45, v33);
      v49(v44, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v48, v46++, v35, v8);
    }
    while (v43 != v46);
  }
  v50 = *(void (**)(char *, uint64_t))(v52 + 8);
  v50(v65, v35);
  v50(v62, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v55, v64, v35);
}

uint64_t static SIMD<>.&-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t, uint64_t);
  uint64_t v28;
  char *v29;
  void (*v30)(char *, unint64_t);
  char *v31;
  uint64_t v33;
  unint64_t AssociatedTypeWitness;
  void (*v35)(void);
  char *v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t, uint64_t);
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v33 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v36 = (char *)&v33 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v33 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v37 = v20;
  v22 = (char *)&v33 - v21;
  v35 = *(void (**)(void))(v20 + 32);
  v35();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v33 = a1;
  v40 = v16;
  v41 = v8;
  v24 = AssociatedTypeWitness;
  v25 = v36;
  v44 = v19;
  if (v23)
  {
    v26 = 0;
    v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v39 = v23;
    do
    {
      v27 = v38;
      v38(v26, a3, v7);
      v27(v26, a3, v7);
      v28 = v7;
      v29 = v40;
      (*(void (**)(char *, char *, unint64_t))(v43 + 88))(v40, v11, v24);
      v30 = *(void (**)(char *, unint64_t))(v41 + 8);
      v30(v11, v24);
      v30(v25, v24);
      v31 = v29;
      v7 = v28;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 64))(v31, v26++, a3, v28);
    }
    while (v39 != v26);
  }
  (*(void (**)(char *, uint64_t))(v37 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v35)(v33, v44, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  unint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  void (*v39)(_QWORD, _QWORD, _QWORD);
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t, uint64_t);
  void (*v58)(void);
  void (*v59)(_QWORD, _QWORD, _QWORD);
  void (*v60)(char *, unint64_t);
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;

  v61 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v53 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v54 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v63 = (char *)&v52 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v52 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v65 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v52 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v62 = (char *)&v52 - v30;
  v55 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v19;
  v33 = AssociatedTypeWitness;
  v31(v19, a2, AssociatedTypeWitness);
  v57 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v57(a3, v8);
  v34 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v59 = (void (*)(_QWORD, _QWORD, _QWORD))v25;
  v35 = a3;
  v56 = v34;
  v36 = v34(a3, v8);
  if (v36 < 0)
    goto LABEL_10;
  v37 = v36;
  v64 = v22;
  v38 = v63;
  v39 = v59;
  if (v36)
  {
    v40 = 0;
    do
    {
      v31(v38, (uint64_t)v32, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v38, v40++, v35, v8);
    }
    while (v37 != v40);
  }
  v41 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v41(v32, v33);
  ((void (*)(char *, _QWORD, uint64_t))v58)(v65, v39, v35);
  v57(v35, v8);
  v42 = v56(v35, v8);
  if (v42 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v43 = v42;
  v45 = v53;
  v44 = v54;
  v60 = v41;
  if (v42)
  {
    v46 = 0;
    v59 = *(void (**)(_QWORD, _QWORD, _QWORD))(v8 + 56);
    do
    {
      v47 = v59;
      v59(v46, v35, v8);
      v47(v46, v35, v8);
      v48 = v63;
      (*(void (**)(char *, char *, unint64_t))(v61 + 88))(v63, v45, v33);
      v49 = v60;
      v60(v45, v33);
      v49(v44, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v48, v46++, v35, v8);
    }
    while (v43 != v46);
  }
  v50 = *(void (**)(char *, uint64_t))(v52 + 8);
  v50(v65, v35);
  v50(v62, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v55, v64, v35);
}

uint64_t static SIMD<>.&*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t, uint64_t);
  uint64_t v28;
  char *v29;
  void (*v30)(char *, unint64_t);
  char *v31;
  uint64_t v33;
  unint64_t AssociatedTypeWitness;
  void (*v35)(void);
  char *v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t, uint64_t);
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v33 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v36 = (char *)&v33 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v33 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v33 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v37 = v20;
  v22 = (char *)&v33 - v21;
  v35 = *(void (**)(void))(v20 + 32);
  v35();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v33 = a1;
  v40 = v16;
  v41 = v8;
  v24 = AssociatedTypeWitness;
  v25 = v36;
  v44 = v19;
  if (v23)
  {
    v26 = 0;
    v38 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v39 = v23;
    do
    {
      v27 = v38;
      v38(v26, a3, v7);
      v27(v26, a3, v7);
      v28 = v7;
      v29 = v40;
      (*(void (**)(char *, char *, unint64_t))(v43 + 96))(v40, v25, v24);
      v30 = *(void (**)(char *, unint64_t))(v41 + 8);
      v30(v11, v24);
      v30(v25, v24);
      v31 = v29;
      v7 = v28;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 64))(v31, v26++, a3, v28);
    }
    while (v39 != v26);
  }
  (*(void (**)(char *, uint64_t))(v37 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v35)(v33, v44, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  unint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  void (*v39)(_QWORD, _QWORD, _QWORD);
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  void (*v57)(uint64_t, uint64_t);
  void (*v58)(void);
  void (*v59)(_QWORD, _QWORD, _QWORD);
  void (*v60)(char *, unint64_t);
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;

  v61 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v53 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v54 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v63 = (char *)&v52 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v52 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v22 = (char *)&v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v20);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v65 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v52 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v62 = (char *)&v52 - v30;
  v55 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v19;
  v33 = AssociatedTypeWitness;
  v31(v19, a2, AssociatedTypeWitness);
  v57 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v57(a3, v8);
  v34 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v59 = (void (*)(_QWORD, _QWORD, _QWORD))v25;
  v35 = a3;
  v56 = v34;
  v36 = v34(a3, v8);
  if (v36 < 0)
    goto LABEL_10;
  v37 = v36;
  v64 = v22;
  v38 = v63;
  v39 = v59;
  if (v36)
  {
    v40 = 0;
    do
    {
      v31(v38, (uint64_t)v32, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v38, v40++, v35, v8);
    }
    while (v37 != v40);
  }
  v41 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v41(v32, v33);
  ((void (*)(char *, _QWORD, uint64_t))v58)(v65, v39, v35);
  v57(v35, v8);
  v42 = v56(v35, v8);
  if (v42 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v43 = v42;
  v45 = v53;
  v44 = v54;
  v60 = v41;
  if (v42)
  {
    v46 = 0;
    v59 = *(void (**)(_QWORD, _QWORD, _QWORD))(v8 + 56);
    do
    {
      v47 = v59;
      v59(v46, v35, v8);
      v47(v46, v35, v8);
      v48 = v63;
      (*(void (**)(char *, char *, unint64_t))(v61 + 96))(v63, v44, v33);
      v49 = v60;
      v60(v45, v33);
      v49(v44, v33);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v48, v46++, v35, v8);
    }
    while (v43 != v46);
  }
  v50 = *(void (**)(char *, uint64_t))(v52 + 8);
  v50(v65, v35);
  v50(v62, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v55, v64, v35);
}

uint64_t static SIMD<>./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v43 + 8) + 152))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v62 + 8) + 152))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  char *v35;
  void (*v36)(void);
  char *v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v43 = a2;
  v44 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v35 = (char *)&v34 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v37 = (char *)&v34 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v34 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v34 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v38 = v20;
  v22 = (char *)&v34 - v21;
  v36 = *(void (**)(void))(v20 + 32);
  v36();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v23 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v34 = a1;
  v41 = v16;
  v42 = v9;
  v24 = v35;
  v25 = v37;
  v45 = v19;
  if (v23)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v23;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(v44 + 192))(v25, v24, v26);
      v31 = *(void (**)(char *, unint64_t))(v42 + 8);
      v31(v24, v26);
      v31(v25, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v22, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v36)(v34, v45, a3);
}

uint64_t static SIMD<>.%= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v43 + 8) + 168))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v62 + 8) + 168))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.&<<= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  void (*v9)(char *, unint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, char *, unint64_t);
  char *v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(void);
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(char *, unint64_t);
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;

  v59 = a2;
  v60 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v53 = (char *)&v52 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v52 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v63 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v62 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v54 = v28;
  v55 = a1;
  v29 = *(void (**)(void))(v28 + 32);
  v61 = (char *)&v52 - v30;
  v56 = v29;
  v29();
  v58 = v9;
  v31 = (void (*)(char *, char *, unint64_t))*((_QWORD *)v9 + 2);
  v32 = v20;
  v33 = v20;
  v34 = AssociatedTypeWitness;
  v31(v33, v59, AssociatedTypeWitness);
  v59 = *(char **)(v7 + 48);
  ((void (*)(uint64_t, uint64_t))v59)(a3, v7);
  v35 = a3;
  v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  v36 = v57(a3, v7);
  if (v36 < 0)
    goto LABEL_10;
  v37 = v36;
  v52 = v14;
  v38 = v25;
  v39 = AssociatedTypeWitness;
  if (v36)
  {
    v40 = 0;
    do
    {
      v31(v17, v32, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v40++, v35, v7);
    }
    while (v37 != v40);
  }
  v41 = (void (*)(char *, unint64_t))*((_QWORD *)v58 + 1);
  v41(v32, v39);
  ((void (*)(char *, char *, uint64_t))v56)(v62, v38, v35);
  ((void (*)(uint64_t, uint64_t))v59)(v35, v7);
  v42 = v57(v35, v7);
  if (v42 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v44 = v52;
  v43 = v53;
  v58 = v41;
  v59 = v17;
  if (v42)
  {
    v45 = 0;
    v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 56);
    do
    {
      v46 = v42;
      v47 = (void (*)(uint64_t, uint64_t, uint64_t))v57;
      ((void (*)(uint64_t, uint64_t, uint64_t))v57)(v45, v35, v7);
      v47(v45, v35, v7);
      v48 = v59;
      (*(void (**)(char *, char *, unint64_t))(v60 + 216))(v44, v43, v39);
      v49 = v58;
      v58(v43, v39);
      v49(v44, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v48, v45, v35, v7);
      v42 = v46;
      ++v45;
    }
    while (v46 != v45);
  }
  v50 = *(void (**)(char *, uint64_t))(v54 + 8);
  v50(v62, v35);
  v50(v61, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v56)(v55, v63, v35);
}

uint64_t static SIMD<>.&>>= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  void (*v9)(char *, unint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, char *, unint64_t);
  char *v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(void);
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(char *, unint64_t);
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;

  v59 = a2;
  v60 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v53 = (char *)&v52 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v52 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v63 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v62 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v54 = v28;
  v55 = a1;
  v29 = *(void (**)(void))(v28 + 32);
  v61 = (char *)&v52 - v30;
  v56 = v29;
  v29();
  v58 = v9;
  v31 = (void (*)(char *, char *, unint64_t))*((_QWORD *)v9 + 2);
  v32 = v20;
  v33 = v20;
  v34 = AssociatedTypeWitness;
  v31(v33, v59, AssociatedTypeWitness);
  v59 = *(char **)(v7 + 48);
  ((void (*)(uint64_t, uint64_t))v59)(a3, v7);
  v35 = a3;
  v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  v36 = v57(a3, v7);
  if (v36 < 0)
    goto LABEL_10;
  v37 = v36;
  v52 = v14;
  v38 = v25;
  v39 = AssociatedTypeWitness;
  if (v36)
  {
    v40 = 0;
    do
    {
      v31(v17, v32, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v40++, v35, v7);
    }
    while (v37 != v40);
  }
  v41 = (void (*)(char *, unint64_t))*((_QWORD *)v58 + 1);
  v41(v32, v39);
  ((void (*)(char *, char *, uint64_t))v56)(v62, v38, v35);
  ((void (*)(uint64_t, uint64_t))v59)(v35, v7);
  v42 = v57(v35, v7);
  if (v42 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v44 = v52;
  v43 = v53;
  v58 = v41;
  v59 = v17;
  if (v42)
  {
    v45 = 0;
    v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 56);
    do
    {
      v46 = v42;
      v47 = (void (*)(uint64_t, uint64_t, uint64_t))v57;
      ((void (*)(uint64_t, uint64_t, uint64_t))v57)(v45, v35, v7);
      v47(v45, v35, v7);
      v48 = v59;
      (*(void (**)(char *, char *, unint64_t))(v60 + 200))(v44, v43, v39);
      v49 = v58;
      v58(v43, v39);
      v49(v44, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v48, v45, v35, v7);
      v42 = v46;
      ++v45;
    }
    while (v46 != v45);
  }
  v50 = *(void (**)(char *, uint64_t))(v54 + 8);
  v50(v62, v35);
  v50(v61, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v56)(v55, v63, v35);
}

void static SIMD<>.+ infix(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4BCuLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4CBuLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4DAuLL, 0);
}

void static SIMD<>.- infix(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4C1uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4D0uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4DFuLL, 0);
}

void static SIMD<>.* infix(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4C6uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4D5uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4E4uLL, 0);
}

void static SIMD<>.+= infix(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4E9uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4F8uLL, 0);
}

void static SIMD<>.-= infix(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4EEuLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4FDuLL, 0);
}

void static SIMD<>.*= infix(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x4F3uLL, 0);
}

{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/SIMDVector.swift", 22, 2, 0x502uLL, 0);
}

uint64_t static SIMD<>.- prefix(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t AssociatedTypeWitness;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t AssociatedConformanceWitness;
  void (*v29)(char *, char *, unint64_t);
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  void (*v36)(char *, unint64_t);
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  void (*v48)(char *, char *, unint64_t);
  uint64_t v49;
  char *v50;
  void (*v51)(char *, unint64_t);
  char *v52;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t (*v59)(uint64_t, uint64_t);
  uint64_t v60;
  void (*v61)(uint64_t, uint64_t);
  uint64_t v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  char *v67;

  v64 = a1;
  v65 = a4;
  v60 = *(_QWORD *)(a2 - 8);
  v6 = MEMORY[0x1E0C80A78](a1);
  v63 = (char *)&v54 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v6);
  v67 = (char *)&v54 - v8;
  v10 = *(_QWORD *)(v9 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v10, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v12 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v13 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v58 = (char *)&v54 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v57 = (char *)&v54 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v66 = (char *)&v54 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v54 - v20;
  MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v54 - v22;
  v56 = *(_QWORD *)(*(_QWORD *)(a3 + 16) + 8);
  v24 = *(_QWORD *)(v56 + 16);
  v25 = swift_getAssociatedTypeWitness(0, (const char *)v24, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v25);
  v27 = (char *)&v54 - v26;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v24, AssociatedTypeWitness, v25, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&unk_1816B7DA8, 256, v25, AssociatedConformanceWitness);
  (*(void (**)(char *, unint64_t, uint64_t))(v24 + 24))(v27, AssociatedTypeWitness, v24);
  v62 = v12;
  v29 = *(void (**)(char *, char *, unint64_t))(v12 + 16);
  v55 = v23;
  v29(v21, v23, AssociatedTypeWitness);
  v30 = v63;
  v61 = *(void (**)(uint64_t, uint64_t))(v10 + 48);
  v61(a2, v10);
  v31 = v30;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v10 + 40);
  v32 = v59(a2, v10);
  if (v32 < 0)
    goto LABEL_10;
  v33 = v32;
  v34 = v66;
  if (v32)
  {
    v35 = 0;
    do
    {
      v29(v34, v21, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v10 + 64))(v34, v35++, a2, v10);
    }
    while (v33 != v35);
  }
  v36 = *(void (**)(char *, unint64_t))(v62 + 8);
  v36(v21, AssociatedTypeWitness);
  v37 = v67;
  (*(void (**)(char *, char *, uint64_t))(v60 + 32))(v67, v31, a2);
  v61(a2, v10);
  v38 = v10;
  v39 = v59(a2, v10);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v39;
  v41 = a2;
  v36(v55, AssociatedTypeWitness);
  v42 = v37;
  v43 = v57;
  v44 = v58;
  v63 = (char *)v36;
  v45 = v56;
  if (v40)
  {
    v46 = 0;
    v61 = *(void (**)(uint64_t, uint64_t))(v38 + 56);
    v62 = v40;
    do
    {
      v47 = (void (*)(uint64_t, uint64_t, uint64_t))v61;
      ((void (*)(uint64_t, uint64_t, uint64_t))v61)(v46, v41, v38);
      v47(v46, v41, v38);
      v48 = *(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v45 + 8) + 40);
      v49 = v45;
      v50 = v66;
      v48(v43, v44, AssociatedTypeWitness);
      v51 = (void (*)(char *, unint64_t))v63;
      ((void (*)(char *, unint64_t))v63)(v44, AssociatedTypeWitness);
      v51(v43, AssociatedTypeWitness);
      v52 = v50;
      v45 = v49;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v38 + 64))(v52, v46, v41, v38);
      v42 = v67;
      ++v46;
    }
    while (v62 != v46);
  }
  return (*(uint64_t (**)(char *, uint64_t))(v60 + 8))(v42, v41);
}

uint64_t static SIMD<>.+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 16) + 8)
                                                                           + 8)
                                                               + 24))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v62 + 16) + 8)
                                                                           + 8)
                                                               + 24))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 16) + 8)
                                                                           + 8)
                                                               + 40))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v62 + 16) + 8)
                                                                           + 8)
                                                               + 40))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  void (*v22)(void);
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  void (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  char *v30;
  void (*v31)(char *, unint64_t);
  char *v32;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  void (*v37)(void);
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t, uint64_t);
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;

  v42 = a2;
  v43 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v44 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v34 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v34 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v34 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v34 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = *(void (**)(void))(v21 + 32);
  v36 = (char *)&v34 - v23;
  v37 = v22;
  v38 = v21;
  v22();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v24 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v35 = a1;
  v45 = v20;
  v25 = v36;
  v41 = v17;
  if (v24)
  {
    v26 = AssociatedTypeWitness;
    v27 = 0;
    v39 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 56);
    v40 = v24;
    do
    {
      v28 = v39;
      v39(v27, a3, v7);
      v28(v27, a3, v7);
      v29 = v7;
      v30 = v41;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v43 + 16) + 8) + 64))(v14, v11, v26);
      v31 = *(void (**)(char *, unint64_t))(v44 + 8);
      v31(v11, v26);
      v31(v14, v26);
      v32 = v30;
      v7 = v29;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v29 + 64))(v32, v27++, a3, v29);
    }
    while (v40 != v27);
  }
  (*(void (**)(char *, uint64_t))(v38 + 8))(v25, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v37)(v35, v45, a3);
}

{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  void (*v10)(char *, unint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, uint64_t, unint64_t);
  char *v32;
  void (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(char *, unint64_t);
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t, uint64_t, uint64_t);
  uint64_t v46;
  char *v47;
  void (*v48)(char *, unint64_t);
  char *v49;
  void (*v50)(char *, uint64_t);
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  void (*v58)(void);
  uint64_t (*v59)(uint64_t, uint64_t);
  void (*v60)(char *, unint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;

  v62 = a5;
  v8 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v10 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v54 = (char *)&v52 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v11);
  v56 = (char *)&v52 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v65 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v64 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v55 = v28;
  v29 = *(void (**)(void))(v28 + 32);
  v63 = (char *)&v52 - v30;
  v57 = a1;
  v58 = v29;
  v29();
  v60 = v10;
  v31 = (void (*)(char *, uint64_t, unint64_t))*((_QWORD *)v10 + 2);
  v32 = v20;
  v31(v20, a2, AssociatedTypeWitness);
  v33 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
  v33(a3, v8);
  v34 = a3;
  v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 40);
  v35 = v59(a3, v8);
  if (v35 < 0)
    goto LABEL_10;
  v36 = v35;
  v53 = v33;
  if (v35)
  {
    v37 = 0;
    do
    {
      v31(v17, (uint64_t)v32, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v8 + 64))(v17, v37++, v34, v8);
    }
    while (v36 != v37);
  }
  v61 = v17;
  v38 = (void (*)(char *, unint64_t))*((_QWORD *)v60 + 1);
  v38(v32, AssociatedTypeWitness);
  ((void (*)(char *, char *, uint64_t))v58)(v64, v25, v34);
  v53(v34, v8);
  v39 = v59(v34, v8);
  if (v39 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v40 = v34;
  v41 = v54;
  v60 = v38;
  v42 = v56;
  if (v39)
  {
    v43 = 0;
    v59 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 56);
    do
    {
      v44 = v39;
      v45 = (void (*)(uint64_t, uint64_t, uint64_t))v59;
      ((void (*)(uint64_t, uint64_t, uint64_t))v59)(v43, v40, v8);
      v45(v43, v40, v8);
      v46 = v8;
      v47 = v61;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(*(_QWORD *)(v62 + 16) + 8) + 64))(v42, v41, AssociatedTypeWitness);
      v48 = v60;
      v60(v41, AssociatedTypeWitness);
      v48(v42, AssociatedTypeWitness);
      v49 = v47;
      v8 = v46;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v46 + 64))(v49, v43, v40, v46);
      v39 = v44;
      ++v43;
    }
    while (v44 != v43);
  }
  v50 = *(void (**)(char *, uint64_t))(v55 + 8);
  v50(v64, v40);
  v50(v63, v40);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v58)(v57, v65, v40);
}

uint64_t static SIMD<>./= infix(_:_:)(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  void (*v9)(char *, unint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(void);
  uint64_t v30;
  void (*v31)(char *, char *, unint64_t);
  char *v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  void (*v41)(char *, unint64_t);
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  void (*v47)(uint64_t, uint64_t, uint64_t);
  char *v48;
  void (*v49)(char *, unint64_t);
  void (*v50)(char *, uint64_t);
  char *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(void);
  uint64_t (*v57)(uint64_t, uint64_t);
  void (*v58)(char *, unint64_t);
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;

  v59 = a2;
  v60 = a5;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v9 = *(void (**)(char *, unint64_t))(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v53 = (char *)&v52 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v52 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v52 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v52 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v63 = (char *)&v52 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v52 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v62 = (char *)&v52 - v27;
  MEMORY[0x1E0C80A78](v26);
  v54 = v28;
  v55 = a1;
  v29 = *(void (**)(void))(v28 + 32);
  v61 = (char *)&v52 - v30;
  v56 = v29;
  v29();
  v58 = v9;
  v31 = (void (*)(char *, char *, unint64_t))*((_QWORD *)v9 + 2);
  v32 = v20;
  v33 = v20;
  v34 = AssociatedTypeWitness;
  v31(v33, v59, AssociatedTypeWitness);
  v59 = *(char **)(v7 + 48);
  ((void (*)(uint64_t, uint64_t))v59)(a3, v7);
  v35 = a3;
  v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
  v36 = v57(a3, v7);
  if (v36 < 0)
    goto LABEL_10;
  v37 = v36;
  v52 = v14;
  v38 = v25;
  v39 = AssociatedTypeWitness;
  if (v36)
  {
    v40 = 0;
    do
    {
      v31(v17, v32, v34);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v17, v40++, v35, v7);
    }
    while (v37 != v40);
  }
  v41 = (void (*)(char *, unint64_t))*((_QWORD *)v58 + 1);
  v41(v32, v39);
  ((void (*)(char *, char *, uint64_t))v56)(v62, v38, v35);
  ((void (*)(uint64_t, uint64_t))v59)(v35, v7);
  v42 = v57(v35, v7);
  if (v42 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v44 = v52;
  v43 = v53;
  v58 = v41;
  v59 = v17;
  if (v42)
  {
    v45 = 0;
    v57 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 56);
    do
    {
      v46 = v42;
      v47 = (void (*)(uint64_t, uint64_t, uint64_t))v57;
      ((void (*)(uint64_t, uint64_t, uint64_t))v57)(v45, v35, v7);
      v47(v45, v35, v7);
      v48 = v59;
      (*(void (**)(char *, char *, unint64_t))(v60 + 192))(v44, v43, v39);
      v49 = v58;
      v58(v43, v39);
      v49(v44, v39);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v7 + 64))(v48, v45, v35, v7);
      v42 = v46;
      ++v45;
    }
    while (v46 != v45);
  }
  v50 = *(void (**)(char *, uint64_t))(v54 + 8);
  v50(v62, v35);
  v50(v61, v35);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v56)(v55, v63, v35);
}

uint64_t SIMD<>.addProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  void (*v29)(uint64_t, uint64_t, uint64_t);
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  void (*v34)(char *, unint64_t);
  char *v35;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(void);
  uint64_t v40;
  void (*v41)(uint64_t, uint64_t, uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;

  v44 = a2;
  v45 = a5;
  v43 = a1;
  v7 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v7, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v48 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v47 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v37 - v12;
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v37 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v46 = (char *)&v37 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v37 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v37 - v23;
  v39 = *(void (**)(void))(v22 + 32);
  v40 = v22;
  v39();
  (*(void (**)(uint64_t, uint64_t))(v7 + 48))(a3, v7);
  v25 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 40))(a3, v7);
  if (v25 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38 = v5;
  v49 = v21;
  v26 = v7;
  v27 = v24;
  if (v25)
  {
    v28 = 0;
    v41 = *(void (**)(uint64_t, uint64_t, uint64_t))(v26 + 56);
    v42 = v25;
    do
    {
      v50 = v28 + 1;
      v29 = v41;
      v41(v28, a3, v26);
      v29(v28, a3, v26);
      v30 = v16;
      v31 = v13;
      v32 = v47;
      v29(v28, a3, v26);
      v33 = v46;
      (*(void (**)(char *, char *, unint64_t))(v45 + 256))(v31, v32, AssociatedTypeWitness);
      v34 = *(void (**)(char *, unint64_t))(v48 + 8);
      v35 = v32;
      v13 = v31;
      v16 = v30;
      v34(v35, AssociatedTypeWitness);
      v34(v13, AssociatedTypeWitness);
      v34(v30, AssociatedTypeWitness);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v26 + 64))(v33, v28, a3, v26);
      v28 = v50;
    }
    while (v42 != v50);
  }
  (*(void (**)(char *, uint64_t))(v40 + 8))(v27, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v39)(v38, v49, a3);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(void);
  uint64_t v33;
  void (*v34)(char *, uint64_t, unint64_t);
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, unint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  void (*v53)(uint64_t, uint64_t, uint64_t);
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  void (*v58)(char *, unint64_t);
  void (*v59)(char *, uint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  void (*v65)(void);
  char *v66;
  void (*v67)(char *, unint64_t);
  uint64_t (*v68)(uint64_t, uint64_t);
  void (*v69)(uint64_t, uint64_t);
  uint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  char *v76;

  v6 = v5;
  v70 = a5;
  v71 = a2;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v12 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v72 = (char *)&v61 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v61 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v63 = (char *)&v61 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v66 = (char *)&v61 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v61 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v74 = (char *)&v61 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  v26 = MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v61 - v27;
  v29 = MEMORY[0x1E0C80A78](v26);
  v73 = (char *)&v61 - v30;
  MEMORY[0x1E0C80A78](v29);
  v62 = v31;
  v32 = *(void (**)(void))(v31 + 32);
  v76 = (char *)&v61 - v33;
  v64 = v6;
  v65 = v32;
  v32();
  v75 = v11;
  v34 = *(void (**)(char *, uint64_t, unint64_t))(v11 + 16);
  v35 = AssociatedTypeWitness;
  v34(v23, a1, AssociatedTypeWitness);
  v69 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  v69(a3, v9);
  v36 = a3;
  v68 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v37 = v68(a3, v9);
  if (v37 < 0)
    goto LABEL_10;
  v38 = v37;
  v61 = v16;
  v39 = v66;
  v40 = v28;
  if (v37)
  {
    v41 = 0;
    do
    {
      v34(v39, (uint64_t)v23, v35);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v39, v41++, v36, v9);
    }
    while (v38 != v41);
  }
  v42 = v9;
  v43 = *(void (**)(char *, unint64_t))(v75 + 8);
  v43(v23, v35);
  ((void (*)(char *, char *, uint64_t))v65)(v73, v40, v36);
  v69(v36, v42);
  v44 = v42;
  v45 = v68(v36, v42);
  if (v45 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v46 = v61;
  v47 = v35;
  v48 = v63;
  v49 = v66;
  v50 = v76;
  if (v45)
  {
    v51 = 0;
    v68 = *(uint64_t (**)(uint64_t, uint64_t))(v44 + 56);
    v69 = (void (*)(uint64_t, uint64_t))v45;
    v67 = v43;
    do
    {
      v75 = v51 + 1;
      v52 = v47;
      v53 = (void (*)(uint64_t, uint64_t, uint64_t))v68;
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v51, v36, v44);
      v53(v51, v36, v44);
      v54 = v49;
      v55 = v46;
      v56 = v72;
      v53(v51, v36, v44);
      v47 = v52;
      (*(void (**)(char *, char *, unint64_t))(v70 + 256))(v55, v56, v52);
      v57 = v56;
      v46 = v55;
      v49 = v54;
      v58 = v67;
      v67(v57, v47);
      v58(v46, v47);
      v58(v48, v47);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 64))(v54, v51, v36, v44);
      v50 = v76;
      v51 = v75;
    }
    while (v69 != (void (*)(uint64_t, uint64_t))v75);
  }
  v59 = *(void (**)(char *, uint64_t))(v62 + 8);
  v59(v73, v36);
  v59(v50, v36);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v65)(v64, v74, v36);
}

{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(void);
  uint64_t v33;
  void (*v34)(char *, uint64_t, unint64_t);
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(char *, unint64_t);
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  void (*v53)(uint64_t, uint64_t, uint64_t);
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  void (*v58)(char *, unint64_t);
  void (*v59)(char *, uint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  void (*v65)(void);
  char *v66;
  void (*v67)(char *, unint64_t);
  uint64_t (*v68)(uint64_t, uint64_t);
  void (*v69)(uint64_t, uint64_t);
  uint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  char *v76;

  v6 = v5;
  v70 = a5;
  v71 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v11 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v12 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v72 = (char *)&v61 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v61 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v63 = (char *)&v61 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v66 = (char *)&v61 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v61 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v74 = (char *)&v61 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  v26 = MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v61 - v27;
  v29 = MEMORY[0x1E0C80A78](v26);
  v73 = (char *)&v61 - v30;
  MEMORY[0x1E0C80A78](v29);
  v62 = v31;
  v32 = *(void (**)(void))(v31 + 32);
  v76 = (char *)&v61 - v33;
  v64 = v6;
  v65 = v32;
  v32();
  v75 = v11;
  v34 = *(void (**)(char *, uint64_t, unint64_t))(v11 + 16);
  v35 = AssociatedTypeWitness;
  v34(v23, a2, AssociatedTypeWitness);
  v69 = *(void (**)(uint64_t, uint64_t))(v9 + 48);
  v69(a3, v9);
  v36 = a3;
  v68 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 40);
  v37 = v68(a3, v9);
  if (v37 < 0)
    goto LABEL_10;
  v38 = v37;
  v61 = v16;
  v39 = v66;
  v40 = v28;
  if (v37)
  {
    v41 = 0;
    do
    {
      v34(v39, (uint64_t)v23, v35);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v39, v41++, v36, v9);
    }
    while (v38 != v41);
  }
  v42 = v9;
  v43 = *(void (**)(char *, unint64_t))(v75 + 8);
  v43(v23, v35);
  ((void (*)(char *, char *, uint64_t))v65)(v73, v40, v36);
  v69(v36, v42);
  v44 = v42;
  v45 = v68(v36, v42);
  if (v45 < 0)
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v46 = v61;
  v47 = v35;
  v48 = v63;
  v49 = v66;
  v50 = v76;
  if (v45)
  {
    v51 = 0;
    v68 = *(uint64_t (**)(uint64_t, uint64_t))(v44 + 56);
    v69 = (void (*)(uint64_t, uint64_t))v45;
    v67 = v43;
    do
    {
      v75 = v51 + 1;
      v52 = v47;
      v53 = (void (*)(uint64_t, uint64_t, uint64_t))v68;
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v51, v36, v44);
      v53(v51, v36, v44);
      v54 = v49;
      v55 = v46;
      v56 = v72;
      v53(v51, v36, v44);
      v47 = v52;
      (*(void (**)(char *, char *, unint64_t))(v70 + 256))(v55, v56, v52);
      v57 = v56;
      v46 = v55;
      v49 = v54;
      v58 = v67;
      v67(v57, v47);
      v58(v46, v47);
      v58(v48, v47);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v44 + 64))(v54, v51, v36, v44);
      v50 = v76;
      v51 = v75;
    }
    while (v69 != (void (*)(uint64_t, uint64_t))v75);
  }
  v59 = *(void (**)(char *, uint64_t))(v62 + 8);
  v59(v73, v36);
  v59(v50, v36);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v65)(v64, v74, v36);
}

uint64_t SIMD<>.formSquareRoot()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  void (*v17)(void);
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  void (*v32)(void);
  void (*v33)(uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  char *v36;

  v35 = a3;
  v5 = *(_QWORD *)(a2 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v5, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v34 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v9 = (char *)&v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v29 - v11;
  v13 = *(_QWORD *)(a1 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v17 = *(void (**)(void))(v13 + 32);
  v31 = (char *)&v29 - v18;
  v32 = v17;
  v17();
  (*(void (**)(uint64_t, uint64_t))(v5 + 48))(a1, v5);
  v19 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 40))(a1, v5);
  if (v19 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v29 = v13;
  v30 = v3;
  v36 = v16;
  v20 = v31;
  v21 = a1;
  if (v19)
  {
    v22 = AssociatedTypeWitness;
    v23 = v9;
    v24 = v5;
    v25 = 0;
    v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 56);
    do
    {
      v26 = v19;
      v27 = v20;
      v33(v25, v21, v24);
      (*(void (**)(unint64_t))(v35 + 240))(v22);
      (*(void (**)(char *, unint64_t))(v34 + 8))(v23, v22);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v12, v25, v21, v24);
      v20 = v27;
      v19 = v26;
      ++v25;
    }
    while (v26 != v25);
  }
  (*(void (**)(char *, uint64_t))(v29 + 8))(v20, v21);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v32)(v30, v36, v21);
}

uint64_t SIMD<>.round(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v30;
  void (*v31)(void);
  uint64_t v32;
  void (*v33)(uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;

  v35 = a1;
  v36 = a4;
  v6 = *(_QWORD *)(a3 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v34 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v8 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v10 = (char *)&v30 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = MEMORY[0x1E0C80A78](v8);
  v13 = (char *)&v30 - v12;
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v19 = (char *)&v30 - v18;
  v31 = *(void (**)(void))(v17 + 32);
  v32 = v17;
  v31();
  (*(void (**)(uint64_t, uint64_t))(v6 + 48))(a2, v6);
  v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 40))(a2, v6);
  if (v20 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v30 = v4;
  v37 = v16;
  v21 = v19;
  v22 = a2;
  if (v20)
  {
    v23 = AssociatedTypeWitness;
    v24 = v10;
    v25 = v6;
    v26 = 0;
    v33 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 56);
    do
    {
      v27 = v20;
      v28 = v21;
      v33(v26, v22, v25);
      (*(void (**)(uint64_t, unint64_t))(v36 + 304))(v35, v23);
      (*(void (**)(char *, unint64_t))(v34 + 8))(v24, v23);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v25 + 64))(v13, v26, v22, v25);
      v21 = v28;
      v20 = v27;
      ++v26;
    }
    while (v27 != v26);
  }
  (*(void (**)(char *, uint64_t))(v32 + 8))(v21, v22);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v31)(v30, v37, v22);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t AssociatedTypeWitness;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, char *, uint64_t);
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  char *v64;
  void (*v65)(char *, unint64_t *);
  uint64_t v66;
  void (*v67)(char *, uint64_t);
  void (*v68)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t);
  char *v69;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t *v86;
  const char *v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char *v93;
  _QWORD v94[5];

  v80 = a2;
  v84 = a1;
  v76 = a7;
  v85 = *(_QWORD *)(a3 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v71 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v93 = (char *)&v71 - v18;
  MEMORY[0x1E0C80A78](v17);
  v20 = (char *)&v71 - v19;
  v91 = *(_QWORD *)(v21 + 8);
  v22 = *(const char **)(*(_QWORD *)(v91 + 24) + 16);
  v24 = *(_QWORD *)(v23 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v24, v25, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v87 = v22;
  v83 = swift_getAssociatedTypeWitness(0, v22, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v83);
  v82 = (char *)&v71 - v27;
  v86 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v90 = *(v86 - 1);
  v28 = MEMORY[0x1E0C80A78](v86);
  v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v74 = (char *)&v71 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v89 = (char *)&v71 - v33;
  MEMORY[0x1E0C80A78](v32);
  v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  v79 = type metadata accessor for SIMDMask(0, (uint64_t)v94);
  v35 = *(_QWORD *)(v79 - 8);
  v36 = MEMORY[0x1E0C80A78](v79);
  v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v36);
  v78 = (char *)&v71 - v39;
  v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  v40 = a3;
  v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  v41 = v88(a3, v24);
  if (v41 < 0)
    goto LABEL_16;
  v42 = v41;
  v92 = v16;
  v73 = v20;
  if (v41)
  {
    v43 = 0;
    v44 = v81;
    while (1)
    {
      v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v43 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v72 = v35;
      v46 = v83;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, (uint64_t)v86, v83, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v82;
      if ((v84 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      v35 = v72;
      if (v42 == v43)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v51 = v78;
  v52 = v38;
  v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  v54 = *(void (**)(char *, char *, uint64_t))(v85 + 16);
  v54(v93, v51, v40);
  v54(v92, v80, v40);
  v77(v40, v24);
  v55 = v88(v40, v24);
  if (v55 < 0)
    goto LABEL_16;
  v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  v88 = v13;
  v57 = v40;
  v58 = v75;
  v59 = v74;
  v60 = v86;
  if (v56)
  {
    v61 = 0;
    v87 = *(const char **)(v24 + 56);
    do
    {
      v62 = v56;
      v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 192))(v59, v58, v60);
      v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      v56 = v62;
      ++v61;
    }
    while (v62 != v61);
  }
  v66 = v85;
  v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

uint64_t static SIMDMask..^ infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t AssociatedTypeWitness;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, char *, uint64_t);
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  char *v64;
  void (*v65)(char *, unint64_t *);
  uint64_t v66;
  void (*v67)(char *, uint64_t);
  void (*v68)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t);
  char *v69;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t *v86;
  const char *v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char *v93;
  _QWORD v94[5];

  v80 = a2;
  v84 = a1;
  v76 = a7;
  v85 = *(_QWORD *)(a3 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v71 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v93 = (char *)&v71 - v18;
  MEMORY[0x1E0C80A78](v17);
  v20 = (char *)&v71 - v19;
  v91 = *(_QWORD *)(v21 + 8);
  v22 = *(const char **)(*(_QWORD *)(v91 + 24) + 16);
  v24 = *(_QWORD *)(v23 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v24, v25, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v87 = v22;
  v83 = swift_getAssociatedTypeWitness(0, v22, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v83);
  v82 = (char *)&v71 - v27;
  v86 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v90 = *(v86 - 1);
  v28 = MEMORY[0x1E0C80A78](v86);
  v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v74 = (char *)&v71 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v89 = (char *)&v71 - v33;
  MEMORY[0x1E0C80A78](v32);
  v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  v79 = type metadata accessor for SIMDMask(0, (uint64_t)v94);
  v35 = *(_QWORD *)(v79 - 8);
  v36 = MEMORY[0x1E0C80A78](v79);
  v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v36);
  v78 = (char *)&v71 - v39;
  v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  v40 = a3;
  v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  v41 = v88(a3, v24);
  if (v41 < 0)
    goto LABEL_16;
  v42 = v41;
  v92 = v16;
  v73 = v20;
  if (v41)
  {
    v43 = 0;
    v44 = v81;
    while (1)
    {
      v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v43 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v72 = v35;
      v46 = v83;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, (uint64_t)v86, v83, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v82;
      if ((v84 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      v35 = v72;
      if (v42 == v43)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v51 = v78;
  v52 = v38;
  v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  v54 = *(void (**)(char *, char *, uint64_t))(v85 + 16);
  v54(v93, v51, v40);
  v54(v92, v80, v40);
  v77(v40, v24);
  v55 = v88(v40, v24);
  if (v55 < 0)
    goto LABEL_16;
  v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  v88 = v13;
  v57 = v40;
  v58 = v75;
  v59 = v74;
  v60 = v86;
  if (v56)
  {
    v61 = 0;
    v87 = *(const char **)(v24 + 56);
    do
    {
      v62 = v56;
      v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 224))(v59, v58, v60);
      v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      v56 = v62;
      ++v61;
    }
    while (v62 != v61);
  }
  v66 = v85;
  v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

uint64_t static SIMDMask..| infix(_:_:)@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t AssociatedTypeWitness;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, char *, uint64_t);
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  char *v64;
  void (*v65)(char *, unint64_t *);
  uint64_t v66;
  void (*v67)(char *, uint64_t);
  void (*v68)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t);
  char *v69;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t *v86;
  const char *v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char *v93;
  _QWORD v94[5];

  v80 = a2;
  v84 = a1;
  v76 = a7;
  v85 = *(_QWORD *)(a3 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v71 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v93 = (char *)&v71 - v18;
  MEMORY[0x1E0C80A78](v17);
  v20 = (char *)&v71 - v19;
  v91 = *(_QWORD *)(v21 + 8);
  v22 = *(const char **)(*(_QWORD *)(v91 + 24) + 16);
  v24 = *(_QWORD *)(v23 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v24, v25, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v87 = v22;
  v83 = swift_getAssociatedTypeWitness(0, v22, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v83);
  v82 = (char *)&v71 - v27;
  v86 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v90 = *(v86 - 1);
  v28 = MEMORY[0x1E0C80A78](v86);
  v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v74 = (char *)&v71 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v89 = (char *)&v71 - v33;
  MEMORY[0x1E0C80A78](v32);
  v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  v79 = type metadata accessor for SIMDMask(0, (uint64_t)v94);
  v35 = *(_QWORD *)(v79 - 8);
  v36 = MEMORY[0x1E0C80A78](v79);
  v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v36);
  v78 = (char *)&v71 - v39;
  v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  v40 = a3;
  v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  v41 = v88(a3, v24);
  if (v41 < 0)
    goto LABEL_16;
  v42 = v41;
  v92 = v16;
  v73 = v20;
  if (v41)
  {
    v43 = 0;
    v44 = v81;
    while (1)
    {
      v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v43 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v72 = v35;
      v46 = v83;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, (uint64_t)v86, v83, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v82;
      if ((v84 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      v35 = v72;
      if (v42 == v43)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v51 = v78;
  v52 = v38;
  v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  v54 = *(void (**)(char *, char *, uint64_t))(v85 + 16);
  v54(v93, v51, v40);
  v54(v92, v80, v40);
  v77(v40, v24);
  v55 = v88(v40, v24);
  if (v55 < 0)
    goto LABEL_16;
  v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  v88 = v13;
  v57 = v40;
  v58 = v75;
  v59 = v74;
  v60 = v86;
  if (v56)
  {
    v61 = 0;
    v87 = *(const char **)(v24 + 56);
    do
    {
      v62 = v56;
      v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 208))(v59, v58, v60);
      v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      v56 = v62;
      ++v61;
    }
    while (v62 != v61);
  }
  v66 = v85;
  v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

uint64_t static SIMDMask..& infix(_:_:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t AssociatedTypeWitness;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, uint64_t, uint64_t);
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  char *v64;
  void (*v65)(char *, unint64_t *);
  uint64_t v66;
  void (*v67)(char *, uint64_t);
  void (*v68)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t);
  char *v69;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  char *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t *v86;
  const char *v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char *v93;
  _QWORD v94[5];

  v84 = a2;
  v80 = a1;
  v76 = a7;
  v85 = *(_QWORD *)(a3 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v71 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v93 = (char *)&v71 - v18;
  MEMORY[0x1E0C80A78](v17);
  v20 = (char *)&v71 - v19;
  v91 = *(_QWORD *)(v21 + 8);
  v22 = *(const char **)(*(_QWORD *)(v91 + 24) + 16);
  v24 = *(_QWORD *)(v23 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v24, v25, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v87 = v22;
  v83 = swift_getAssociatedTypeWitness(0, v22, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v83);
  v82 = (char *)&v71 - v27;
  v86 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v90 = *(v86 - 1);
  v28 = MEMORY[0x1E0C80A78](v86);
  v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v74 = (char *)&v71 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v89 = (char *)&v71 - v33;
  MEMORY[0x1E0C80A78](v32);
  v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  v79 = type metadata accessor for SIMDMask(0, (uint64_t)v94);
  v35 = *(_QWORD *)(v79 - 8);
  v36 = MEMORY[0x1E0C80A78](v79);
  v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v36);
  v78 = (char *)&v71 - v39;
  v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  v40 = a3;
  v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  v41 = v88(a3, v24);
  if (v41 < 0)
    goto LABEL_16;
  v42 = v41;
  v92 = v16;
  v73 = v20;
  if (v41)
  {
    v43 = 0;
    v44 = v81;
    while (1)
    {
      v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v43 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v72 = v35;
      v46 = v83;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, (uint64_t)v86, v83, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v82;
      if ((v84 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      v35 = v72;
      if (v42 == v43)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v51 = v78;
  v52 = v38;
  v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  v54 = *(void (**)(char *, uint64_t, uint64_t))(v85 + 16);
  v54(v93, v80, v40);
  v54(v92, (uint64_t)v51, v40);
  v77(v40, v24);
  v55 = v88(v40, v24);
  if (v55 < 0)
    goto LABEL_16;
  v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  v88 = v13;
  v57 = v40;
  v58 = v75;
  v59 = v74;
  v60 = v86;
  if (v56)
  {
    v61 = 0;
    v87 = *(const char **)(v24 + 56);
    do
    {
      v62 = v56;
      v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 192))(v59, v58, v60);
      v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      v56 = v62;
      ++v61;
    }
    while (v62 != v61);
  }
  v66 = v85;
  v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

uint64_t static SIMDMask..^ infix(_:_:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t AssociatedTypeWitness;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, uint64_t, uint64_t);
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  char *v64;
  void (*v65)(char *, unint64_t *);
  uint64_t v66;
  void (*v67)(char *, uint64_t);
  void (*v68)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t);
  char *v69;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  char *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t *v86;
  const char *v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char *v93;
  _QWORD v94[5];

  v84 = a2;
  v80 = a1;
  v76 = a7;
  v85 = *(_QWORD *)(a3 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v71 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v93 = (char *)&v71 - v18;
  MEMORY[0x1E0C80A78](v17);
  v20 = (char *)&v71 - v19;
  v91 = *(_QWORD *)(v21 + 8);
  v22 = *(const char **)(*(_QWORD *)(v91 + 24) + 16);
  v24 = *(_QWORD *)(v23 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v24, v25, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v87 = v22;
  v83 = swift_getAssociatedTypeWitness(0, v22, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v83);
  v82 = (char *)&v71 - v27;
  v86 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v90 = *(v86 - 1);
  v28 = MEMORY[0x1E0C80A78](v86);
  v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v74 = (char *)&v71 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v89 = (char *)&v71 - v33;
  MEMORY[0x1E0C80A78](v32);
  v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  v79 = type metadata accessor for SIMDMask(0, (uint64_t)v94);
  v35 = *(_QWORD *)(v79 - 8);
  v36 = MEMORY[0x1E0C80A78](v79);
  v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v36);
  v78 = (char *)&v71 - v39;
  v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  v40 = a3;
  v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  v41 = v88(a3, v24);
  if (v41 < 0)
    goto LABEL_16;
  v42 = v41;
  v92 = v16;
  v73 = v20;
  if (v41)
  {
    v43 = 0;
    v44 = v81;
    while (1)
    {
      v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v43 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v72 = v35;
      v46 = v83;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, (uint64_t)v86, v83, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v82;
      if ((v84 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      v35 = v72;
      if (v42 == v43)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v51 = v78;
  v52 = v38;
  v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  v54 = *(void (**)(char *, uint64_t, uint64_t))(v85 + 16);
  v54(v93, v80, v40);
  v54(v92, (uint64_t)v51, v40);
  v77(v40, v24);
  v55 = v88(v40, v24);
  if (v55 < 0)
    goto LABEL_16;
  v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  v88 = v13;
  v57 = v40;
  v58 = v75;
  v59 = v74;
  v60 = v86;
  if (v56)
  {
    v61 = 0;
    v87 = *(const char **)(v24 + 56);
    do
    {
      v62 = v56;
      v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 224))(v59, v58, v60);
      v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      v56 = v62;
      ++v61;
    }
    while (v62 != v61);
  }
  v66 = v85;
  v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

uint64_t static SIMDMask..| infix(_:_:)@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t AssociatedTypeWitness;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t AssociatedConformanceWitness;
  char *v48;
  void *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  void (*v54)(char *, uint64_t, uint64_t);
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  unint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  char *v64;
  void (*v65)(char *, unint64_t *);
  uint64_t v66;
  void (*v67)(char *, uint64_t);
  void (*v68)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t);
  char *v69;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  char *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t *v86;
  const char *v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  char *v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char *v93;
  _QWORD v94[5];

  v84 = a2;
  v80 = a1;
  v76 = a7;
  v85 = *(_QWORD *)(a3 - 8);
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (uint64_t (*)(uint64_t, uint64_t))((char *)&v71 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v71 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v93 = (char *)&v71 - v18;
  MEMORY[0x1E0C80A78](v17);
  v20 = (char *)&v71 - v19;
  v91 = *(_QWORD *)(v21 + 8);
  v22 = *(const char **)(*(_QWORD *)(v91 + 24) + 16);
  v24 = *(_QWORD *)(v23 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v24, v25, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v87 = v22;
  v83 = swift_getAssociatedTypeWitness(0, v22, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v83);
  v82 = (char *)&v71 - v27;
  v86 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v90 = *(v86 - 1);
  v28 = MEMORY[0x1E0C80A78](v86);
  v75 = (char *)&v71 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
  v30 = MEMORY[0x1E0C80A78](v28);
  v74 = (char *)&v71 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v89 = (char *)&v71 - v33;
  MEMORY[0x1E0C80A78](v32);
  v81 = (char *)&v71 - v34;
  v94[0] = a3;
  v94[1] = a4;
  v94[2] = a5;
  v94[3] = a6;
  v79 = type metadata accessor for SIMDMask(0, (uint64_t)v94);
  v35 = *(_QWORD *)(v79 - 8);
  v36 = MEMORY[0x1E0C80A78](v79);
  v38 = (char *)&v71 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v36);
  v78 = (char *)&v71 - v39;
  v77 = *(void (**)(uint64_t, uint64_t))(v24 + 48);
  v77(a3, v24);
  v40 = a3;
  v88 = *(uint64_t (**)(uint64_t, uint64_t))(v24 + 40);
  v41 = v88(a3, v24);
  if (v41 < 0)
    goto LABEL_16;
  v42 = v41;
  v92 = v16;
  v73 = v20;
  if (v41)
  {
    v43 = 0;
    v44 = v81;
    while (1)
    {
      v45 = v88(v40, v24);
      if ((v45 & 0x8000000000000000) != 0)
        break;
      if (v43 >= v45)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v72 = v35;
      v46 = v83;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, (uint64_t)v86, v83, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v48 = v82;
      if ((v84 & 1) != 0)
      {
        v49 = &unk_1816B7DB8;
        v50 = 257;
      }
      else
      {
        v49 = &unk_1816B7DA8;
        v50 = 256;
      }
      (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(v49, v50, v46, AssociatedConformanceWitness);
      (*((void (**)(char *))v87 + 3))(v48);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v24 + 64))(v44, v43++, v40, v24);
      v35 = v72;
      if (v42 == v43)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v51 = v78;
  v52 = v38;
  v53 = v79;
  (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v78, v52, v79);
  v54 = *(void (**)(char *, uint64_t, uint64_t))(v85 + 16);
  v54(v93, v80, v40);
  v54(v92, (uint64_t)v51, v40);
  v77(v40, v24);
  v55 = v88(v40, v24);
  if (v55 < 0)
    goto LABEL_16;
  v56 = v55;
  (*(void (**)(char *, uint64_t))(v35 + 8))(v51, v53);
  v88 = v13;
  v57 = v40;
  v58 = v75;
  v59 = v74;
  v60 = v86;
  if (v56)
  {
    v61 = 0;
    v87 = *(const char **)(v24 + 56);
    do
    {
      v62 = v56;
      v63 = v87;
      ((void (*)(uint64_t, uint64_t, uint64_t))v87)(v61, v57, v24);
      ((void (*)(uint64_t, uint64_t, uint64_t))v63)(v61, v57, v24);
      v64 = v89;
      (*(void (**)(char *, char *, unint64_t *))(v91 + 208))(v59, v58, v60);
      v65 = *(void (**)(char *, unint64_t *))(v90 + 8);
      v65(v58, v60);
      v65(v59, v60);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v24 + 64))(v64, v61, v57, v24);
      v56 = v62;
      ++v61;
    }
    while (v62 != v61);
  }
  v66 = v85;
  v67 = *(void (**)(char *, uint64_t))(v85 + 8);
  v67(v92, v57);
  v67(v93, v57);
  v68 = *(void (**)(char *, uint64_t (*)(uint64_t, uint64_t), uint64_t))(v66 + 32);
  v69 = v73;
  v68(v73, v88, v57);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v68)(v76, v69, v57);
}

uint64_t static SIMDMask..&= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(char *, char *, uint64_t);
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t, uint64_t);
  uint64_t v38;
  char *v39;
  void (*v40)(char *, unint64_t);
  char *v41;
  void (*v42)(char *, uint64_t);
  char *v43;
  void (*v44)(char *, char *, uint64_t);
  char *v45;
  void (*v47)(char *, char *, uint64_t);
  char *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  char *v54;
  void (*v55)(uint64_t, uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  _QWORD v62[5];

  v60 = a6;
  v61 = a2;
  v54 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v57 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v47 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v59 = (char *)&v47 - v18;
  v19 = *(_QWORD *)(a3 - 8);
  v20 = MEMORY[0x1E0C80A78](v17);
  v21 = MEMORY[0x1E0C80A78](v20);
  v23 = (char *)&v47 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v47 - v25;
  MEMORY[0x1E0C80A78](v24);
  v52 = (char *)&v47 - v27;
  v62[0] = a3;
  v62[1] = a4;
  v58 = a5;
  v62[2] = a5;
  v62[3] = v60;
  v29 = v28;
  v30 = type metadata accessor for SIMDMask(0, (uint64_t)v62);
  v49 = *(_QWORD *)(v30 - 8);
  v50 = v30;
  MEMORY[0x1E0C80A78](v30);
  v48 = (char *)&v47 - v31;
  v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  v51 = v26;
  v47 = v32;
  v32(v26, v54, a3);
  v53 = v19;
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v61, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v33 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v60 = v23;
  v61 = v29;
  v34 = v51;
  v35 = a3;
  if (v33)
  {
    v36 = 0;
    v55 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v56 = v33;
    do
    {
      v37 = v55;
      v55(v36, v35, v9);
      v37(v36, v35, v9);
      v38 = v35;
      v39 = v59;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 192))(v16, v13, AssociatedTypeWitness);
      v40 = *(void (**)(char *, unint64_t))(v57 + 8);
      v40(v13, AssociatedTypeWitness);
      v40(v16, AssociatedTypeWitness);
      v41 = v39;
      v35 = v38;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v41, v36++, v38, v9);
    }
    while (v56 != v36);
  }
  v42 = *(void (**)(char *, uint64_t))(v53 + 8);
  v42(v60, v35);
  v42(v34, v35);
  v43 = v52;
  v44 = v47;
  v47(v52, v61, v35);
  v45 = v48;
  v44(v48, v43, v35);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v49 + 32))(v54, v45, v50);
}

uint64_t static SIMDMask..^= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(char *, char *, uint64_t);
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t, uint64_t);
  uint64_t v38;
  char *v39;
  void (*v40)(char *, unint64_t);
  char *v41;
  void (*v42)(char *, uint64_t);
  char *v43;
  void (*v44)(char *, char *, uint64_t);
  char *v45;
  void (*v47)(char *, char *, uint64_t);
  char *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  char *v54;
  void (*v55)(uint64_t, uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  _QWORD v62[5];

  v60 = a6;
  v61 = a2;
  v54 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v57 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v47 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v59 = (char *)&v47 - v18;
  v19 = *(_QWORD *)(a3 - 8);
  v20 = MEMORY[0x1E0C80A78](v17);
  v21 = MEMORY[0x1E0C80A78](v20);
  v23 = (char *)&v47 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v47 - v25;
  MEMORY[0x1E0C80A78](v24);
  v52 = (char *)&v47 - v27;
  v62[0] = a3;
  v62[1] = a4;
  v58 = a5;
  v62[2] = a5;
  v62[3] = v60;
  v29 = v28;
  v30 = type metadata accessor for SIMDMask(0, (uint64_t)v62);
  v49 = *(_QWORD *)(v30 - 8);
  v50 = v30;
  MEMORY[0x1E0C80A78](v30);
  v48 = (char *)&v47 - v31;
  v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  v51 = v26;
  v47 = v32;
  v32(v26, v54, a3);
  v53 = v19;
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v61, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v33 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v60 = v23;
  v61 = v29;
  v34 = v51;
  v35 = a3;
  if (v33)
  {
    v36 = 0;
    v55 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v56 = v33;
    do
    {
      v37 = v55;
      v55(v36, v35, v9);
      v37(v36, v35, v9);
      v38 = v35;
      v39 = v59;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 224))(v16, v13, AssociatedTypeWitness);
      v40 = *(void (**)(char *, unint64_t))(v57 + 8);
      v40(v13, AssociatedTypeWitness);
      v40(v16, AssociatedTypeWitness);
      v41 = v39;
      v35 = v38;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v41, v36++, v38, v9);
    }
    while (v56 != v36);
  }
  v42 = *(void (**)(char *, uint64_t))(v53 + 8);
  v42(v60, v35);
  v42(v34, v35);
  v43 = v52;
  v44 = v47;
  v47(v52, v61, v35);
  v45 = v48;
  v44(v48, v43, v35);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v49 + 32))(v54, v45, v50);
}

uint64_t static SIMDMask..|= infix(_:_:)(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(char *, char *, uint64_t);
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t, uint64_t);
  uint64_t v38;
  char *v39;
  void (*v40)(char *, unint64_t);
  char *v41;
  void (*v42)(char *, uint64_t);
  char *v43;
  void (*v44)(char *, char *, uint64_t);
  char *v45;
  void (*v47)(char *, char *, uint64_t);
  char *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  char *v54;
  void (*v55)(uint64_t, uint64_t, uint64_t);
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  _QWORD v62[5];

  v60 = a6;
  v61 = a2;
  v54 = a1;
  v9 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v57 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v47 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  v14 = MEMORY[0x1E0C80A78](v11);
  v16 = (char *)&v47 - v15;
  v17 = MEMORY[0x1E0C80A78](v14);
  v59 = (char *)&v47 - v18;
  v19 = *(_QWORD *)(a3 - 8);
  v20 = MEMORY[0x1E0C80A78](v17);
  v21 = MEMORY[0x1E0C80A78](v20);
  v23 = (char *)&v47 - v22;
  v24 = MEMORY[0x1E0C80A78](v21);
  v26 = (char *)&v47 - v25;
  MEMORY[0x1E0C80A78](v24);
  v52 = (char *)&v47 - v27;
  v62[0] = a3;
  v62[1] = a4;
  v58 = a5;
  v62[2] = a5;
  v62[3] = v60;
  v29 = v28;
  v30 = type metadata accessor for SIMDMask(0, (uint64_t)v62);
  v49 = *(_QWORD *)(v30 - 8);
  v50 = v30;
  MEMORY[0x1E0C80A78](v30);
  v48 = (char *)&v47 - v31;
  v32 = *(void (**)(char *, char *, uint64_t))(v19 + 32);
  v51 = v26;
  v47 = v32;
  v32(v26, v54, a3);
  v53 = v19;
  (*(void (**)(char *, char *, uint64_t))(v19 + 16))(v23, v61, a3);
  (*(void (**)(uint64_t, uint64_t))(v9 + 48))(a3, v9);
  v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 40))(a3, v9);
  if (v33 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v60 = v23;
  v61 = v29;
  v34 = v51;
  v35 = a3;
  if (v33)
  {
    v36 = 0;
    v55 = *(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 56);
    v56 = v33;
    do
    {
      v37 = v55;
      v55(v36, v35, v9);
      v37(v36, v35, v9);
      v38 = v35;
      v39 = v59;
      (*(void (**)(char *, char *, unint64_t))(*(_QWORD *)(v58 + 8) + 208))(v16, v13, AssociatedTypeWitness);
      v40 = *(void (**)(char *, unint64_t))(v57 + 8);
      v40(v13, AssociatedTypeWitness);
      v40(v16, AssociatedTypeWitness);
      v41 = v39;
      v35 = v38;
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v9 + 64))(v41, v36++, v38, v9);
    }
    while (v56 != v36);
  }
  v42 = *(void (**)(char *, uint64_t))(v53 + 8);
  v42(v60, v35);
  v42(v34, v35);
  v43 = v52;
  v44 = v47;
  v47(v52, v61, v35);
  v45 = v48;
  v44(v48, v43, v35);
  return (*(uint64_t (**)(char *, char *, uint64_t))(v49 + 32))(v54, v45, v50);
}

uint64_t static SIMDMask..&= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(void);
  uint64_t v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t, uint64_t);
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t AssociatedConformanceWitness;
  void (*v53)(void *, uint64_t, unint64_t, unint64_t);
  char *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  void (*v59)(char *, char *, uint64_t);
  char *v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(char *, uint64_t);
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  const char *v68;
  char *v69;
  void (*v70)(char *, uint64_t);
  uint64_t v71;
  void (*v72)(char *, uint64_t);
  void (*v73)(char *, char *, uint64_t);
  char *v74;
  uint64_t v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  void (*v83)(void);
  void (*v84)(uint64_t, uint64_t);
  char *v85;
  char *v86;
  uint64_t v87;
  char *v88;
  char *v89;
  unint64_t v90;
  int v91;
  uint64_t v92;
  unint64_t *v93;
  const char *v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  char *v98;
  char *v99;
  char *v100;
  _QWORD v101[5];

  v97 = a6;
  v91 = a2;
  v10 = *(_QWORD *)(a5 + 8);
  v11 = *(const char **)(*(_QWORD *)(v10 + 24) + 16);
  v12 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v94 = v11;
  v90 = swift_getAssociatedTypeWitness(0, v11, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v90);
  v89 = (char *)&v76 - v14;
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v16 = *(v15 - 1);
  v17 = MEMORY[0x1E0C80A78](v15);
  v80 = (char *)&v76 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v76 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v76 - v23;
  v25 = MEMORY[0x1E0C80A78](v22);
  v88 = (char *)&v76 - v26;
  v92 = *(_QWORD *)(a3 - 8);
  v27 = MEMORY[0x1E0C80A78](v25);
  v100 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  v29 = MEMORY[0x1E0C80A78](v27);
  v99 = (char *)&v76 - v30;
  v31 = MEMORY[0x1E0C80A78](v29);
  v98 = (char *)&v76 - v32;
  MEMORY[0x1E0C80A78](v31);
  v81 = (char *)&v76 - v33;
  v101[0] = a3;
  v101[1] = a4;
  v101[2] = a5;
  v101[3] = v97;
  v34 = type metadata accessor for SIMDMask(0, (uint64_t)v101);
  v35 = MEMORY[0x1E0C80A78](v34);
  v37 = (char *)&v76 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  v38 = MEMORY[0x1E0C80A78](v35);
  v86 = (char *)&v76 - v39;
  MEMORY[0x1E0C80A78](v38);
  v79 = v40;
  v41 = *(void (**)(void))(v40 + 32);
  v85 = (char *)&v76 - v42;
  v82 = a1;
  v87 = v43;
  v83 = v41;
  v41();
  v84 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v84(a3, v12);
  v44 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  v45 = v44(a3, v12);
  if (v45 < 0)
    goto LABEL_16;
  v93 = v15;
  v97 = v24;
  v78 = v21;
  v95 = v10;
  v96 = v16;
  v46 = (uint64_t)v94;
  if (v45)
  {
    v47 = 0;
    v48 = v88;
    while (1)
    {
      v49 = v45;
      v50 = v44(a3, v12);
      if ((v50 & 0x8000000000000000) != 0)
        break;
      if (v47 >= v50)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v51 = v90;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, (uint64_t)v93, v90, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v53 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      v77 = v44;
      v54 = v89;
      if ((v91 & 1) != 0)
      {
        v55 = &unk_1816B7DB8;
        v56 = 257;
      }
      else
      {
        v55 = &unk_1816B7DA8;
        v56 = 256;
      }
      v53(v55, v56, v51, AssociatedConformanceWitness);
      (*(void (**)(char *))(v46 + 24))(v54);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v48, v47++, a3, v12);
      v45 = v49;
      v44 = v77;
      if (v49 == v47)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v58 = v86;
  v57 = v87;
  ((void (*)(char *, char *, uint64_t))v83)(v86, v37, v87);
  v59 = *(void (**)(char *, char *, uint64_t))(v92 + 16);
  v60 = v85;
  v59(v98, v85, a3);
  v59(v99, v58, a3);
  v84(a3, v12);
  v61 = v44(a3, v12);
  if (v61 < 0)
    goto LABEL_16;
  v62 = v61;
  v63 = *(void (**)(char *, uint64_t))(v79 + 8);
  v63(v58, v57);
  v63(v60, v57);
  v64 = v80;
  v65 = v78;
  v66 = (uint64_t)v93;
  if (v62)
  {
    v67 = 0;
    v94 = *(const char **)(v12 + 56);
    do
    {
      v68 = v94;
      ((void (*)(uint64_t, uint64_t, uint64_t))v94)(v67, a3, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v67, a3, v12);
      v69 = v97;
      (*(void (**)(char *, char *, uint64_t))(v95 + 192))(v65, v64, v66);
      v70 = *(void (**)(char *, uint64_t))(v96 + 8);
      v70(v64, v66);
      v70(v65, v66);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v69, v67++, a3, v12);
    }
    while (v62 != v67);
  }
  v71 = v92;
  v72 = *(void (**)(char *, uint64_t))(v92 + 8);
  v72(v99, a3);
  v72(v98, a3);
  v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  v74 = v81;
  v73(v81, v100, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, a3);
}

uint64_t static SIMDMask..^= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(void);
  uint64_t v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t, uint64_t);
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t AssociatedConformanceWitness;
  void (*v53)(void *, uint64_t, unint64_t, unint64_t);
  char *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  void (*v59)(char *, char *, uint64_t);
  char *v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(char *, uint64_t);
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  const char *v68;
  char *v69;
  void (*v70)(char *, uint64_t);
  uint64_t v71;
  void (*v72)(char *, uint64_t);
  void (*v73)(char *, char *, uint64_t);
  char *v74;
  uint64_t v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  void (*v83)(void);
  void (*v84)(uint64_t, uint64_t);
  char *v85;
  char *v86;
  uint64_t v87;
  char *v88;
  char *v89;
  unint64_t v90;
  int v91;
  uint64_t v92;
  unint64_t *v93;
  const char *v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  char *v98;
  char *v99;
  char *v100;
  _QWORD v101[5];

  v97 = a6;
  v91 = a2;
  v10 = *(_QWORD *)(a5 + 8);
  v11 = *(const char **)(*(_QWORD *)(v10 + 24) + 16);
  v12 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v94 = v11;
  v90 = swift_getAssociatedTypeWitness(0, v11, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v90);
  v89 = (char *)&v76 - v14;
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v16 = *(v15 - 1);
  v17 = MEMORY[0x1E0C80A78](v15);
  v80 = (char *)&v76 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v76 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v76 - v23;
  v25 = MEMORY[0x1E0C80A78](v22);
  v88 = (char *)&v76 - v26;
  v92 = *(_QWORD *)(a3 - 8);
  v27 = MEMORY[0x1E0C80A78](v25);
  v100 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  v29 = MEMORY[0x1E0C80A78](v27);
  v99 = (char *)&v76 - v30;
  v31 = MEMORY[0x1E0C80A78](v29);
  v98 = (char *)&v76 - v32;
  MEMORY[0x1E0C80A78](v31);
  v81 = (char *)&v76 - v33;
  v101[0] = a3;
  v101[1] = a4;
  v101[2] = a5;
  v101[3] = v97;
  v34 = type metadata accessor for SIMDMask(0, (uint64_t)v101);
  v35 = MEMORY[0x1E0C80A78](v34);
  v37 = (char *)&v76 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  v38 = MEMORY[0x1E0C80A78](v35);
  v86 = (char *)&v76 - v39;
  MEMORY[0x1E0C80A78](v38);
  v79 = v40;
  v41 = *(void (**)(void))(v40 + 32);
  v85 = (char *)&v76 - v42;
  v82 = a1;
  v87 = v43;
  v83 = v41;
  v41();
  v84 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v84(a3, v12);
  v44 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  v45 = v44(a3, v12);
  if (v45 < 0)
    goto LABEL_16;
  v93 = v15;
  v97 = v24;
  v78 = v21;
  v95 = v10;
  v96 = v16;
  v46 = (uint64_t)v94;
  if (v45)
  {
    v47 = 0;
    v48 = v88;
    while (1)
    {
      v49 = v45;
      v50 = v44(a3, v12);
      if ((v50 & 0x8000000000000000) != 0)
        break;
      if (v47 >= v50)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v51 = v90;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, (uint64_t)v93, v90, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v53 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      v77 = v44;
      v54 = v89;
      if ((v91 & 1) != 0)
      {
        v55 = &unk_1816B7DB8;
        v56 = 257;
      }
      else
      {
        v55 = &unk_1816B7DA8;
        v56 = 256;
      }
      v53(v55, v56, v51, AssociatedConformanceWitness);
      (*(void (**)(char *))(v46 + 24))(v54);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v48, v47++, a3, v12);
      v45 = v49;
      v44 = v77;
      if (v49 == v47)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v58 = v86;
  v57 = v87;
  ((void (*)(char *, char *, uint64_t))v83)(v86, v37, v87);
  v59 = *(void (**)(char *, char *, uint64_t))(v92 + 16);
  v60 = v85;
  v59(v98, v85, a3);
  v59(v99, v58, a3);
  v84(a3, v12);
  v61 = v44(a3, v12);
  if (v61 < 0)
    goto LABEL_16;
  v62 = v61;
  v63 = *(void (**)(char *, uint64_t))(v79 + 8);
  v63(v58, v57);
  v63(v60, v57);
  v64 = v80;
  v65 = v78;
  v66 = (uint64_t)v93;
  if (v62)
  {
    v67 = 0;
    v94 = *(const char **)(v12 + 56);
    do
    {
      v68 = v94;
      ((void (*)(uint64_t, uint64_t, uint64_t))v94)(v67, a3, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v67, a3, v12);
      v69 = v97;
      (*(void (**)(char *, char *, uint64_t))(v95 + 224))(v65, v64, v66);
      v70 = *(void (**)(char *, uint64_t))(v96 + 8);
      v70(v64, v66);
      v70(v65, v66);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v69, v67++, a3, v12);
    }
    while (v62 != v67);
  }
  v71 = v92;
  v72 = *(void (**)(char *, uint64_t))(v92 + 8);
  v72(v99, a3);
  v72(v98, a3);
  v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  v74 = v81;
  v73(v81, v100, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, a3);
}

uint64_t static SIMDMask..|= infix(_:_:)(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  unint64_t AssociatedTypeWitness;
  uint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(void);
  uint64_t v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t, uint64_t);
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t AssociatedConformanceWitness;
  void (*v53)(void *, uint64_t, unint64_t, unint64_t);
  char *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  void (*v59)(char *, char *, uint64_t);
  char *v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(char *, uint64_t);
  char *v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  const char *v68;
  char *v69;
  void (*v70)(char *, uint64_t);
  uint64_t v71;
  void (*v72)(char *, uint64_t);
  void (*v73)(char *, char *, uint64_t);
  char *v74;
  uint64_t v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  char *v78;
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  void (*v83)(void);
  void (*v84)(uint64_t, uint64_t);
  char *v85;
  char *v86;
  uint64_t v87;
  char *v88;
  char *v89;
  unint64_t v90;
  int v91;
  uint64_t v92;
  unint64_t *v93;
  const char *v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  char *v98;
  char *v99;
  char *v100;
  _QWORD v101[5];

  v97 = a6;
  v91 = a2;
  v10 = *(_QWORD *)(a5 + 8);
  v11 = *(const char **)(*(_QWORD *)(v10 + 24) + 16);
  v12 = *(_QWORD *)(a4 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v12, a3, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated type descriptor for SIMDStorage.Scalar);
  v94 = v11;
  v90 = swift_getAssociatedTypeWitness(0, v11, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v90);
  v89 = (char *)&v76 - v14;
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v16 = *(v15 - 1);
  v17 = MEMORY[0x1E0C80A78](v15);
  v80 = (char *)&v76 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v76 - v20;
  v22 = MEMORY[0x1E0C80A78](v19);
  v24 = (char *)&v76 - v23;
  v25 = MEMORY[0x1E0C80A78](v22);
  v88 = (char *)&v76 - v26;
  v92 = *(_QWORD *)(a3 - 8);
  v27 = MEMORY[0x1E0C80A78](v25);
  v100 = (char *)&v76 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
  v29 = MEMORY[0x1E0C80A78](v27);
  v99 = (char *)&v76 - v30;
  v31 = MEMORY[0x1E0C80A78](v29);
  v98 = (char *)&v76 - v32;
  MEMORY[0x1E0C80A78](v31);
  v81 = (char *)&v76 - v33;
  v101[0] = a3;
  v101[1] = a4;
  v101[2] = a5;
  v101[3] = v97;
  v34 = type metadata accessor for SIMDMask(0, (uint64_t)v101);
  v35 = MEMORY[0x1E0C80A78](v34);
  v37 = (char *)&v76 - ((v36 + 15) & 0xFFFFFFFFFFFFFFF0);
  v38 = MEMORY[0x1E0C80A78](v35);
  v86 = (char *)&v76 - v39;
  MEMORY[0x1E0C80A78](v38);
  v79 = v40;
  v41 = *(void (**)(void))(v40 + 32);
  v85 = (char *)&v76 - v42;
  v82 = a1;
  v87 = v43;
  v83 = v41;
  v41();
  v84 = *(void (**)(uint64_t, uint64_t))(v12 + 48);
  v84(a3, v12);
  v44 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 40);
  v45 = v44(a3, v12);
  if (v45 < 0)
    goto LABEL_16;
  v93 = v15;
  v97 = v24;
  v78 = v21;
  v95 = v10;
  v96 = v16;
  v46 = (uint64_t)v94;
  if (v45)
  {
    v47 = 0;
    v48 = v88;
    while (1)
    {
      v49 = v45;
      v50 = v44(a3, v12);
      if ((v50 & 0x8000000000000000) != 0)
        break;
      if (v47 >= v50)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVector.swift", 22, 2, 0x2CDuLL, 0);
      v51 = v90;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v46, (uint64_t)v93, v90, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v53 = *(void (**)(void *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8);
      v77 = v44;
      v54 = v89;
      if ((v91 & 1) != 0)
      {
        v55 = &unk_1816B7DB8;
        v56 = 257;
      }
      else
      {
        v55 = &unk_1816B7DA8;
        v56 = 256;
      }
      v53(v55, v56, v51, AssociatedConformanceWitness);
      (*(void (**)(char *))(v46 + 24))(v54);
      (*(void (**)(char *, unint64_t, uint64_t, uint64_t))(v12 + 64))(v48, v47++, a3, v12);
      v45 = v49;
      v44 = v77;
      if (v49 == v47)
        goto LABEL_10;
    }
LABEL_16:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
LABEL_10:
  v58 = v86;
  v57 = v87;
  ((void (*)(char *, char *, uint64_t))v83)(v86, v37, v87);
  v59 = *(void (**)(char *, char *, uint64_t))(v92 + 16);
  v60 = v85;
  v59(v98, v85, a3);
  v59(v99, v58, a3);
  v84(a3, v12);
  v61 = v44(a3, v12);
  if (v61 < 0)
    goto LABEL_16;
  v62 = v61;
  v63 = *(void (**)(char *, uint64_t))(v79 + 8);
  v63(v58, v57);
  v63(v60, v57);
  v64 = v80;
  v65 = v78;
  v66 = (uint64_t)v93;
  if (v62)
  {
    v67 = 0;
    v94 = *(const char **)(v12 + 56);
    do
    {
      v68 = v94;
      ((void (*)(uint64_t, uint64_t, uint64_t))v94)(v67, a3, v12);
      ((void (*)(uint64_t, uint64_t, uint64_t))v68)(v67, a3, v12);
      v69 = v97;
      (*(void (**)(char *, char *, uint64_t))(v95 + 208))(v65, v64, v66);
      v70 = *(void (**)(char *, uint64_t))(v96 + 8);
      v70(v64, v66);
      v70(v65, v66);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 64))(v69, v67++, a3, v12);
    }
    while (v62 != v67);
  }
  v71 = v92;
  v72 = *(void (**)(char *, uint64_t))(v92 + 8);
  v72(v99, a3);
  v72(v98, a3);
  v73 = *(void (**)(char *, char *, uint64_t))(v71 + 32);
  v74 = v81;
  v73(v81, v100, a3);
  return ((uint64_t (*)(uint64_t, char *, uint64_t))v73)(v82, v74, a3);
}

void *ObjectIdentifier._lldb_summary.unsafeMutableAddressor()
{
  return &static ObjectIdentifier._lldb_summary;
}

_QWORD *_stdlib_AtomicInt.__allocating_init(_:)(uint64_t a1)
{
  uint64_t v1;
  _QWORD *result;

  result = swift_allocObject(v1, 0x18uLL, 7uLL);
  result[2] = a1;
  return result;
}

uint64_t _stdlib_AtomicInt.init(_:)(uint64_t a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 16) = a1;
  return v1;
}

Swift::Void __swiftcall _stdlib_AtomicInt.store(_:)(Swift::Int a1)
{
  uint64_t v1;

  atomic_store(a1, (unint64_t *)(v1 + 16));
}

unint64_t *_swift_stdlib_atomicStoreInt(object:desired:)(unint64_t *result, unint64_t a2)
{
  atomic_store(a2, result);
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.load()()
{
  uint64_t v0;

  return atomic_load((unint64_t *)(v0 + 16));
}

unint64_t _swift_stdlib_atomicLoadInt(object:)(unint64_t *a1)
{
  return atomic_load(a1);
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndAdd(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  Swift::Int v3;

  v2 = (unint64_t *)(v1 + 16);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 + a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchAddInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result + a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.addAndFetch(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v3;
  BOOL v4;
  Swift::Int result;

  v2 = (unint64_t *)(v1 + 16);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 + a1, v2));
  v4 = __OFADD__(v3, a1);
  result = v3 + a1;
  if (v4)
    __break(1u);
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndAnd(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  Swift::Int v3;

  v2 = (unint64_t *)(v1 + 16);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 & a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchAndInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result & a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.andAndFetch(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v3;
  Swift::Int v4;

  v2 = (unint64_t *)(v1 + 16);
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 & a1;
  }
  while (__stlxr(v4, v2));
  return v4;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndOr(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  Swift::Int v3;

  v2 = (unint64_t *)(v1 + 16);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 | a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchOrInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result | a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.orAndFetch(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v3;
  Swift::Int v4;

  v2 = (unint64_t *)(v1 + 16);
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 | a1;
  }
  while (__stlxr(v4, v2));
  return v4;
}

uint64_t static Int.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

Swift::Int __swiftcall _stdlib_AtomicInt.fetchAndXor(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  Swift::Int v3;

  v2 = (unint64_t *)(v1 + 16);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 ^ a1, v2));
  return v3;
}

unint64_t _swift_stdlib_atomicFetchXorInt(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result ^ a2, a1));
  return result;
}

Swift::Int __swiftcall _stdlib_AtomicInt.xorAndFetch(_:)(Swift::Int a1)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t v3;
  Swift::Int v4;

  v2 = (unint64_t *)(v1 + 16);
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 ^ a1;
  }
  while (__stlxr(v4, v2));
  return v4;
}

uint64_t static Int.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

Swift::Bool __swiftcall _stdlib_AtomicInt.compareExchange(expected:desired:)(Swift::Int *expected, Swift::Int desired)
{
  uint64_t v2;
  Swift::Int v3;
  unint64_t *v4;
  Swift::Int v5;
  Swift::Bool v6;

  v3 = *expected;
  v4 = (unint64_t *)(v2 + 16);
  while (1)
  {
    v5 = __ldaxr(v4);
    if (v5 != v3)
      break;
    if (!__stlxr(desired, v4))
    {
      v6 = 1;
      goto LABEL_6;
    }
  }
  v6 = 0;
  __clrex();
LABEL_6:
  *expected = v5;
  return v6;
}

uint64_t _swift_stdlib_atomicCompareExchangeStrongInt(object:expected:desired:)(unint64_t *a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t result;

  v3 = *a2;
  while (1)
  {
    v4 = __ldaxr(a1);
    if (v4 != v3)
      break;
    if (!__stlxr(a3, a1))
    {
      result = 1;
      *a2 = v4;
      return result;
    }
  }
  result = 0;
  __clrex();
  *a2 = v4;
  return result;
}

uint64_t _stdlib_AtomicInt.deinit()
{
  uint64_t v0;

  return v0;
}

unint64_t _swift_stdlib_atomicFetchAddInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result + a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchAddInt32(object:operand:)(unsigned int *a1, int a2)
{
  uint64_t v2;

  do
    v2 = __ldaxr(a1);
  while (__stlxr(v2 + a2, a1));
  return v2;
}

unint64_t _swift_stdlib_atomicFetchAndInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result & a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchAndInt32(object:operand:)(unsigned int *a1, int a2)
{
  uint64_t v2;

  do
    v2 = __ldaxr(a1);
  while (__stlxr(v2 & a2, a1));
  return v2;
}

unint64_t _swift_stdlib_atomicFetchOrInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result | a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchOrInt32(object:operand:)(unsigned int *a1, int a2)
{
  uint64_t v2;

  do
    v2 = __ldaxr(a1);
  while (__stlxr(v2 | a2, a1));
  return v2;
}

unint64_t _swift_stdlib_atomicFetchXorInt64(object:operand:)(unint64_t *a1, uint64_t a2)
{
  unint64_t result;

  do
    result = __ldaxr(a1);
  while (__stlxr(result ^ a2, a1));
  return result;
}

uint64_t _swift_stdlib_atomicFetchXorInt32(object:operand:)(unsigned int *a1, int a2)
{
  uint64_t v2;

  do
    v2 = __ldaxr(a1);
  while (__stlxr(v2 ^ a2, a1));
  return v2;
}

Swift::Bool __swiftcall _isspace_clocale(_:)(Swift::UInt16 a1)
{
  _QWORD v2[5];
  Swift::UInt16 v3;

  v3 = a1;
  v2[2] = &v3;
  return specialized Sequence.contains(where:)((uint64_t (*)(_QWORD *))partial apply for specialized closure #1 in Sequence<>.contains(_:), (uint64_t)v2, 0x200D0C0B0A09, 0xE600000000000000) & 1;
}

uint64_t Float16.init<A>(_:)(uint64_t *a1, ValueMetadata *x1_0, uint64_t a3)
{
  Swift::String::Index v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char v10;
  int v11;
  unsigned __int16 v13;
  Swift::String::Index v14;

  v3._rawBits = Substring.init<A>(_:)(a1, x1_0, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 8) + 8) + 8));
  v5 = v4;
  v13 = 0;
  v7 = specialized String.init(_:)(v3, v14, v6, v4);
  v9 = v8;
  swift_bridgeObjectRelease(v5);
  v10 = specialized String.withCString<A>(_:)(v7, v9, (uint64_t)&v13, (char *)_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v9);
  if ((v10 & 1) != 0)
    v11 = v13;
  else
    v11 = 0;
  return v11 & 0xFFFEFFFF | (((v10 & 1) == 0) << 16);
}

uint64_t Float16.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  int v9;
  unsigned __int16 v11;

  v11 = 0;
  v5 = specialized String.init(_:)(a1, a2, a3, a4);
  v7 = v6;
  swift_bridgeObjectRelease(a4);
  v8 = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v11, (char *)_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v7);
  if ((v8 & 1) != 0)
    v9 = v11;
  else
    v9 = 0;
  return v9 & 0xFFFEFFFF | (((v8 & 1) == 0) << 16);
}

__int16 Float16.init(_builtinFloatLiteral:)@<H0>(double _D0@<D0>)
{
  __int16 result;

  __asm { FCVT            H0, D0 }
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Float16(uint64_t a1@<X8>)
{
  Swift::String::Index v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  __int16 v10;
  __int16 v11;
  Swift::String::Index v12;

  v2._rawBits = specialized Substring.init<A>(_:)();
  v4 = v3;
  v11 = 0;
  v6 = specialized String.init(_:)(v2, v12, v5, v3);
  v8 = v7;
  swift_bridgeObjectRelease(v4);
  v9 = specialized String.withCString<A>(_:)(v6, v8, (uint64_t)&v11, (char *)_swift_stdlib_strtof16_clocale);
  swift_bridgeObjectRelease(v8);
  v10 = v11;
  if ((v9 & 1) == 0)
    v10 = 0;
  *(_WORD *)a1 = v10;
  *(_BYTE *)(a1 + 2) = (v9 & 1) == 0;
}

unint64_t specialized Float.init<A>(_:)(unint64_t a1, unint64_t a2)
{
  _BYTE *v3;
  char v4;
  char *v5;
  uint64_t v6;
  uint64_t v8;
  char __s[8];
  uint64_t v10;
  unsigned int v11;

  v11 = 0;
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    v4 = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)&v11, (char *)_swift_stdlib_strtof_clocale);
  }
  else if ((a2 & 0x2000000000000000) != 0)
  {
    *(_QWORD *)__s = a1;
    v10 = a2 & 0xFFFFFFFFFFFFFFLL;
    v4 = (a1 > 0x20u || ((0x100003E01uLL >> a1) & 1) == 0)
      && (v5 = _swift_stdlib_strtof_clocale(__s, (float *)&v11)) != 0
      && *v5 == 0;
  }
  else
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      v3 = (_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v3 = _StringObject.sharedUTF8.getter(a1, a2);
      if (v8 < 0)
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    closure #1 in closure #1 in Double.init<A>(_:)partial apply(v3, (uint64_t (*)(void))_swift_stdlib_strtof_clocale, (BOOL *)__s);
    v4 = __s[0];
  }
  swift_bridgeObjectRelease(a2);
  v6 = v11;
  __s[0] = (v4 & 1) == 0;
  if ((v4 & 1) == 0)
    v6 = 0;
  return v6 | ((unint64_t)((v4 & 1) == 0) << 32);
}

unint64_t Float.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  _QWORD v8[5];
  uint64_t v9;

  *(_DWORD *)((char *)&v9 + 1) = 0;
  v8[2] = (char *)&v9 + 1;
  (*(void (**)(uint64_t *__return_ptr, _BYTE *(*)@<X0>(_BYTE *@<X0>, BOOL *@<X8>), _QWORD *, ValueMetadata *, uint64_t, uint64_t))(a3 + 200))(&v9, partial apply for closure #1 in closure #1 in Float.init<A>(_:), v8, &type metadata for Bool, a2, a3);
  v5 = v9;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  v6 = *(unsigned int *)((char *)&v9 + 1);
  BYTE1(v9) = v5 ^ 1;
  if (!v5)
    v6 = 0;
  return v6 | ((unint64_t)(v5 ^ 1u) << 32);
}

float Float.init(_builtinFloatLiteral:)(double a1)
{
  return a1;
}

unint64_t Float.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t v9;
  unsigned int v11;

  v11 = 0;
  v5 = specialized String.init(_:)(a1, a2, a3, a4);
  v7 = v6;
  swift_bridgeObjectRelease(a4);
  v8 = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v11, (char *)_swift_stdlib_strtof_clocale);
  swift_bridgeObjectRelease(v7);
  v9 = v11;
  if ((v8 & 1) == 0)
    v9 = 0;
  return v9 | ((unint64_t)((v8 & 1) == 0) << 32);
}

unint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance Float@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t result;

  result = specialized Float.init<A>(_:)(a1, a2);
  *(_DWORD *)a3 = result;
  *(_BYTE *)(a3 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t specialized Double.init<A>(_:)(unint64_t a1, unint64_t a2)
{
  _BYTE *v3;
  char v4;
  char *v5;
  uint64_t v7;
  char __s[8];
  uint64_t v9;
  uint64_t v10;

  v10 = 0;
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
  {
    v4 = specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)&v10, (char *)_swift_stdlib_strtod_clocale);
  }
  else if ((a2 & 0x2000000000000000) != 0)
  {
    *(_QWORD *)__s = a1;
    v9 = a2 & 0xFFFFFFFFFFFFFFLL;
    v4 = (a1 > 0x20u || ((0x100003E01uLL >> a1) & 1) == 0)
      && (v5 = _swift_stdlib_strtod_clocale(__s, (double *)&v10)) != 0
      && *v5 == 0;
  }
  else
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      v3 = (_BYTE *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v3 = _StringObject.sharedUTF8.getter(a1, a2);
      if (v7 < 0)
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    closure #1 in closure #1 in Double.init<A>(_:)partial apply(v3, (uint64_t (*)(void))_swift_stdlib_strtod_clocale, (BOOL *)__s);
    v4 = __s[0];
  }
  swift_bridgeObjectRelease(a2);
  if ((v4 & 1) != 0)
    return v10;
  else
    return 0;
}

uint64_t Double.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  _QWORD v7[4];
  unsigned __int8 v8;
  uint64_t v9;

  v9 = 0;
  v7[2] = &v9;
  (*(void (**)(unsigned __int8 *__return_ptr, _BYTE *(*)@<X0>(_BYTE *@<X0>, BOOL *@<X8>), _QWORD *, ValueMetadata *, uint64_t, uint64_t))(a3 + 200))(&v8, partial apply for closure #1 in closure #1 in Double.init<A>(_:), v7, &type metadata for Bool, a2, a3);
  v5 = v8;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  if (v5)
    return v9;
  else
    return 0;
}

uint64_t Double.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v9;

  v4 = a4;
  v9 = 0;
  v5 = specialized String.init(_:)(a1, a2, a3, a4);
  v7 = v6;
  swift_bridgeObjectRelease(v4);
  LOBYTE(v4) = specialized String.withCString<A>(_:)(v5, v7, (uint64_t)&v9, (char *)_swift_stdlib_strtod_clocale);
  swift_bridgeObjectRelease(v7);
  if ((v4 & 1) != 0)
    return v9;
  else
    return 0;
}

uint64_t protocol witness for LosslessStringConvertible.init(_:) in conformance Double@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  char v5;

  result = specialized Double.init<A>(_:)(a1, a2);
  *(_QWORD *)a3 = result;
  *(_BYTE *)(a3 + 8) = v5 & 1;
  return result;
}

void Float16._value.setter(__n128 a1)
{
  _WORD *v1;

  *v1 = a1.n128_u16[0];
}

uint64_t (*Float16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

float Float16.init()()
{
  return 0.0;
}

unint64_t Float16.description.getter(__n128 a1)
{
  unint64_t result;
  int64_t v2;
  size_t v3;
  unint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned int v13;
  __int128 v14;
  __int128 v15;
  _OWORD __src[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((~a1.n128_u32[0] & 0x7C00) == 0 && (a1.n128_u16[0] & 0x3FF) != 0)
    return 7233902;
  v14 = 0u;
  v15 = 0u;
  v2 = swift_float16ToString(&v14, 0x20uLL, a1);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v3 = v2;
  if (!v2)
    return 0;
  if ((unint64_t)v2 <= 0xF)
  {
    v7 = v2 - 8;
    v8 = 8;
    if (v2 < 8)
      v8 = v2;
    result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7)
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
              }
            }
          }
        }
      }
    }
    v9 = 0;
    if (v3 >= 9)
    {
      v10 = 0;
      v11 = (unsigned __int8 *)__src + 8;
      v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v4 = v2 | 0xF000000000000000;
    v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(_QWORD *)(v5 + 16) = v6;
    *(_QWORD *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
      v4 = *(_QWORD *)(v5 + 24);
    }
    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(_QWORD *)(v5 + 24);
  }
  return result;
}

BOOL Float16.isNaN.getter(float a1)
{
  return (LOWORD(a1) & 0x3FF) != 0 && (~LODWORD(a1) & 0x7C00) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Float16(__n128 a1)
{
  unsigned __int16 *v1;

  a1.n128_u16[0] = *v1;
  return Float16.description.getter(a1);
}

unint64_t Float16.debugDescription.getter(__n128 a1)
{
  int64_t v1;
  size_t v2;
  unint64_t v3;
  int64_t v4;
  uint64_t v5;
  unint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned int v13;
  __int128 v14;
  __int128 v15;
  _OWORD __src[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v14 = 0u;
  v15 = 0u;
  v1 = swift_float16ToString(&v14, 0x20uLL, a1);
  __src[0] = v14;
  __src[1] = v15;
  if (v1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v2 = v1;
  if (!v1)
    return 0;
  if ((unint64_t)v1 <= 0xF)
  {
    v7 = v1 - 8;
    v8 = 8;
    if (v1 < 8)
      v8 = v1;
    result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7)
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
              }
            }
          }
        }
      }
    }
    v9 = 0;
    if (v2 >= 9)
    {
      v10 = 0;
      v11 = (unsigned __int8 *)__src + 8;
      v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v2 - 9)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v3 = v1 | 0xF000000000000000;
    v4 = _allocateStringStorage(codeUnitCapacity:)(v1);
    *(_QWORD *)(v4 + 16) = v5;
    *(_QWORD *)(v4 + 24) = v3;
    if (v5 < 0)
    {
      *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
      v3 = *(_QWORD *)(v4 + 24);
    }
    *(_BYTE *)(v4 + 32 + (v3 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v2, (char *)(v4 + 32));
    return *(_QWORD *)(v4 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Float16(__n128 a1)
{
  unsigned __int16 *v1;

  a1.n128_u16[0] = *v1;
  return Float16.debugDescription.getter(a1);
}

uint64_t Float16.write<A>(to:)(__n128 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _OWORD v8[2];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  memset(v8, 0, sizeof(v8));
  v6 = swift_float16ToString(v8, 0x20uLL, a1);
  if (v6 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a4 + 32))(v8, v6, a3, a4);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Float16(uint64_t a1, uint64_t a2, uint64_t a3, __n128 a4)
{
  unsigned __int16 *v4;

  a4.n128_u16[0] = *v4;
  return Float16.write<A>(to:)(a4, a1, a2, a3);
}

uint64_t static Float16.exponentBitCount.getter()
{
  return 5;
}

uint64_t static Float16.significandBitCount.getter()
{
  return 10;
}

uint64_t static Float16._infinityExponent.getter()
{
  return 31;
}

uint64_t static Float16._exponentBias.getter()
{
  return 15;
}

uint64_t static Float16._significandMask.getter()
{
  return 1023;
}

uint64_t static UInt16.- infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result;

  result = a1 - a2;
  if ((result & 0xFFFF0000) != 0)
    __break(1u);
  return result;
}

uint64_t static Float16._quietNaNMask.getter()
{
  return 512;
}

float Float16.init(bitPattern:)(int a1)
{
  return *(float *)&a1;
}

uint64_t Float16.sign.getter(float a1)
{
  return (LODWORD(a1) >> 15) & 1;
}

uint64_t Float16.exponentBitPattern.getter(float a1)
{
  return (LODWORD(a1) >> 10) & 0x1F;
}

uint64_t Float16.significandBitPattern.getter(__n128 a1)
{
  return a1.n128_u16[0] & 0x3FF;
}

uint64_t static UInt16.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

uint64_t Float16.isCanonical.getter()
{
  return 1;
}

__int16 static Float16.leastNonzeroMagnitude.getter@<H0>()
{
  return 1;
}

__int16 static Float16.leastNormalMagnitude.getter@<H0>()
{
  return 1024;
}

__int16 static Float16.infinity.getter@<H0>()
{
  return 31744;
}

__int16 static Float16.nan.getter@<H0>()
{
  return 32256;
}

float Float16.init(nan:signaling:)(int a1, char a2)
{
  float result;

  if ((unsigned __int16)a1 >= 0x100u)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "NaN payload is not encodable.", 29, 2, "Swift/FloatingPointTypes.swift", 30, 2, 0x198uLL, 0);
  LODWORD(result) = (0x200u >> (a2 & 1)) | a1 | 0x7C00;
  return result;
}

__int16 static Float16.signalingNaN.getter@<H0>()
{
  return 32000;
}

__int16 static Float16.greatestFiniteMagnitude.getter@<H0>()
{
  return 31743;
}

__int16 static Float16.pi.getter@<H0>()
{
  return 16968;
}

__int16 Float16.ulp.getter@<H0>(float a1@<S0>)
{
  int v1;
  __int16 result;

  v1 = (LODWORD(a1) >> 10) & 0x1F;
  if (!v1)
    return 1;
  if (v1 == 31)
    return 32256;
  _H0 = LOWORD(a1) & 0x7C00;
  __asm { FCVT            S0, H0 }
  _S0 = _S0 * 0.00097656;
  __asm { FCVT            H0, S0 }
  return result;
}

BOOL Float16.isFinite.getter(float a1)
{
  return (~LODWORD(a1) & 0x7C00) != 0;
}

BOOL Float16.isNormal.getter(float a1)
{
  return ((LODWORD(a1) >> 10) & 0x1F) != 0x1F && ((LODWORD(a1) >> 10) & 0x1F) != 0;
}

__int16 static Float16.* infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __int16 result;

  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 static Float16.ulpOfOne.getter@<H0>()
{
  return 5120;
}

uint64_t Float16.exponent.getter(float a1)
{
  uint64_t v1;
  unsigned int v3;

  v1 = (LODWORD(a1) >> 10) & 0x1F;
  if ((_DWORD)v1 == 31)
    return 0x7FFFFFFFFFFFFFFFLL;
  v3 = LOWORD(a1) & 0x3FF;
  if (!(v1 | v3))
    return 0x8000000000000000;
  if ((_DWORD)v1)
    return v1 - 15;
  if ((LOWORD(a1) & 0x3FF) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  return v1 - (unsigned __int16)(__clz(v3) - 16) - 9;
}

BOOL Float16.isZero.getter(__n128 a1)
{
  return (a1.n128_u16[0] & 0x7FFF) == 0;
}

float Float16.significand.getter(float result)
{
  int v1;
  unsigned int v2;

  v1 = (LODWORD(result) >> 10) & 0x1F;
  v2 = LOWORD(result) & 0x3FF;
  if ((LOWORD(result) & 0x3FF) == 0 || v1 != 31)
  {
    if (v1)
    {
      if (v1 != 31)
      {
        LODWORD(result) = v2 | 0x3C00;
        return result;
      }
    }
    else if ((LOWORD(result) & 0x3FF) != 0)
    {
      LODWORD(result) = (LODWORD(result) << ((__clz(v2) - 5) & 0xF)) & 0x3FF | 0x3C00;
      return result;
    }
    LODWORD(result) = v1 << 10;
  }
  return result;
}

BOOL Float16.isSubnormal.getter(__n128 a1)
{
  return (a1.n128_u16[0] & 0x3FF) != 0 && (a1.n128_u16[0] & 0x7C00) == 0;
}

double Float16.init(sign:exponent:significand:)(char a1, uint64_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = specialized Float16.init(sign:exponent:significand:)(a1 & 1, a2, a3);
  return result;
}

__int16 static Float16.- prefix(_:)@<H0>(__n128 _Q0@<Q0>)
{
  __int16 result;

  __asm { FCVT            S0, H0 }
  _S0 = -_S0;
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 static Float16.*= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  __int16 result;

  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

float Float16.nextUp.getter(__n128 _Q0)
{
  float result;

  __asm { FCVT            S0, H0 }
  result = _S0 + 0.0;
  __asm
  {
    FCVT            H0, S0
    FCVT            S1, H0
  }
  if (_S1 < INFINITY)
    LODWORD(result) += (SLOWORD(result) >> 15) | 1;
  return result;
}

__int16 Float16.init(_builtinIntegerLiteral:)@<H0>(uint64_t *a1@<X0>, unint64_t a2@<X1>)
{
  __int16 result;

  _S0 = swift_intToFloat32(a1, a2);
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 static Float16.+ infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __int16 result;

  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }
  return result;
}

uint64_t static Int16.&>> infix(_:_:)(__int16 a1, char a2)
{
  return (a1 >> (a2 & 0xF));
}

uint64_t static Int16.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

unsigned __int16 Float16.init(signOf:magnitudeOf:)@<H0>(int8x16_t _Q0@<Q0>, int8x16_t _Q1@<Q1>)
{
  int8x16_t v6;

  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  _Q0.i32[0] = vbslq_s8(v6, _Q1, _Q0).u32[0];
  __asm { FCVT            H0, S0 }
  return _Q0.i16[0];
}

Swift::Void __swiftcall Float16.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  __int16 *v1;

  switch(*(_BYTE *)a1)
  {
    case 0:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = roundf(_S0);
      goto LABEL_12;
    case 1:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = rintf(_S0);
      goto LABEL_12;
    case 2:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = ceilf(_S0);
      goto LABEL_12;
    case 3:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      goto LABEL_11;
    case 4:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = truncf(_S0);
      goto LABEL_12;
    case 5:
      _H0 = *v1;
      if (*v1 < 0)
      {
        __asm { FCVT            S0, H0 }
LABEL_11:
        _S0 = floorf(_S0);
      }
      else
      {
        __asm { FCVT            S0, H0 }
        _S0 = ceilf(_S0);
      }
LABEL_12:
      __asm { FCVT            H0, S0 }
      *v1 = _H0;
      return;
    default:
      Float16._roundSlowPath(_:)(a1);
      return;
  }
}

Swift::Void __swiftcall Float16._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  __int16 *v1;
  char v20;

  v20 = *(_BYTE *)a1;
  switch(v20)
  {
    case 0:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = roundf(_S0);
      goto LABEL_12;
    case 1:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = rintf(_S0);
      goto LABEL_12;
    case 2:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = ceilf(_S0);
      goto LABEL_12;
    case 3:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      goto LABEL_11;
    case 4:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = truncf(_S0);
      goto LABEL_12;
    case 5:
      _H0 = *v1;
      if (*v1 < 0)
      {
        __asm { FCVT            S0, H0 }
LABEL_11:
        _S0 = floorf(_S0);
      }
      else
      {
        __asm { FCVT            S0, H0 }
        _S0 = ceilf(_S0);
      }
LABEL_12:
      __asm { FCVT            H0, S0 }
      *v1 = _H0;
      return;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v20);
      return;
  }
}

Swift::Void __swiftcall Float16.negate()()
{
  __int16 *v0;

  _H0 = *v0;
  __asm { FCVT            S0, H0 }
  _S0 = -_S0;
  __asm { FCVT            H0, S0 }
  *v0 = LOWORD(_S0);
}

__int16 static Float16.+= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  __int16 result;

  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 + _S0;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 static Float16.-= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  __int16 result;

  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 - _S0;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 static Float16./= infix(_:_:)@<H0>(__int16 *a1@<X0>, __n128 _Q0@<Q0>)
{
  __int16 result;

  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 / _S0;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 Float16.formRemainder(dividingBy:)@<H0>(__n128 _Q0@<Q0>)
{
  __int16 *v1;
  __int16 result;

  _H1 = *v1;
  __asm
  {
    FCVT            S2, H1
    FCVT            S1, H0; float
  }
  _S0 = remainderf(_S2, _S1);
  __asm { FCVT            H0, S0 }
  *v1 = result;
  return result;
}

__int16 Float16.formTruncatingRemainder(dividingBy:)@<H0>(__n128 _Q0@<Q0>)
{
  __int16 *v1;
  __int16 result;

  _H2 = *v1;
  __asm
  {
    FCVT            S1, H0; float
    FCVT            S0, H2; float
  }
  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *v1 = result;
  return result;
}

Swift::Void __swiftcall Float16.formSquareRoot()()
{
  __int16 *v0;

  _H0 = *v0;
  __asm { FCVT            S0, H0 }
  _S0 = sqrtf(_S0);
  __asm { FCVT            H0, S0 }
  *v0 = LOWORD(_S0);
}

__int16 Float16.addProduct(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __int16 *v2;
  __int16 result;

  _H2 = *v2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
    FCVT            S2, H2
  }
  _S0 = _S2 + (float)(_S0 * _S1);
  __asm { FCVT            H0, S0 }
  *v2 = result;
  return result;
}

BOOL Float16.isEqual(to:)(__n128 _Q0, __n128 _Q1)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 == _S0;
}

BOOL Float16.isLess(than:)(__n128 _Q0, __n128 _Q1)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 < _S0;
}

BOOL Float16.isLessThanOrEqualTo(_:)(__n128 _Q0, __n128 _Q1)
{
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 <= _S0;
}

BOOL Float16.isSignalingNaN.getter(float a1)
{
  return (~LODWORD(a1) & 0x7C00) == 0 && (LOWORD(a1) & 0x3FF) != 0 && (LOWORD(a1) & 0x200) == 0;
}

__int16 Float16.binade.getter@<H0>(float _S0@<S0>)
{
  int v1;
  __int16 result;

  v1 = (LODWORD(_S0) >> 10) & 0x1F;
  if (v1 == 31)
    return 32256;
  if ((LOWORD(_S0) & 0x3FF) == 0 || v1)
    return LOWORD(_S0) & 0xFC00;
  __asm { FCVT            S0, H0 }
  _S0 = _S0 * 1024.0;
  __asm { FCVT            H0, S0 }
  LOWORD(_S0) &= 0xFC00u;
  __asm { FCVT            S0, H0 }
  _S0 = _S0 * 0.00097656;
  __asm { FCVT            H0, S0 }
  return result;
}

uint64_t Float16.significandWidth.getter(float a1)
{
  unsigned int v1;
  int v2;
  uint64_t result;
  uint64_t v4;

  v1 = __clz(__rbit32(LOWORD(a1) & 0x3FF | 0x10000));
  v2 = (LODWORD(a1) >> 10) & 0x1F;
  if (v2 && v2 != 31)
  {
    if ((LOWORD(a1) & 0x3FF) != 0)
      return 10 - v1;
    else
      return 0;
  }
  else
  {
    result = -1;
    if ((LOWORD(a1) & 0x3FF) != 0)
    {
      v4 = 16 - (unsigned __int16)(__clz(LOWORD(a1) & 0x3FF) + v1 - 15);
      if (!v2)
        return v4;
    }
  }
  return result;
}

uint64_t static UInt16.bitWidth.getter()
{
  return 16;
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Float16(char a1@<W0>, _QWORD *a2@<X1>, __int16 *a3@<X2>, _WORD *a4@<X8>)
{
  float v5;

  v5 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
  *a4 = LOWORD(v5);
}

__int16 protocol witness for BinaryFloatingPoint.init(_:) in conformance Float16@<H0>(_WORD *a1@<X8>, float _S0@<S0>)
{
  __int16 result;

  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 protocol witness for BinaryFloatingPoint.init(_:) in conformance Float16@<H0>(_WORD *a1@<X8>, double _D0@<D0>)
{
  __int16 result;

  __asm { FCVT            H0, D0 }
  *a1 = result;
  return result;
}

__int16 Float16.init(_:)@<H0>(double _D0@<D0>)
{
  __int16 result;

  __asm { FCVT            H0, D0 }
  return result;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Float16(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, _WORD *a4@<X8>)
{
  float v5;

  v5 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
  *a4 = LOWORD(v5);
}

uint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Float16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;

  result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(_WORD *)a4 = result;
  *(_BYTE *)(a4 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.exponentBitCount.getter in conformance Float16()
{
  return 5;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Float16()
{
  return 10;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Float16(unint64_t *a1@<X8>)
{
  unsigned __int16 *v1;

  *a1 = ((unint64_t)*v1 >> 10) & 0x1F;
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Float16(_WORD *a1@<X8>)
{
  _WORD *v1;

  *a1 = *v1 & 0x3FF;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Float16(__int16 *a1@<X8>, float a2@<S0>)
{
  _WORD *v2;

  LOWORD(a2) = *v2;
  *a1 = Float16.binade.getter(a2);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Float16(float a1)
{
  _WORD *v1;

  LOWORD(a1) = *v1;
  return Float16.significandWidth.getter(a1);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Float16(char a1@<W0>, uint64_t *a2@<X1>, _WORD *a3@<X2>, __int16 *a4@<X8>, float a5@<S0>)
{
  LOWORD(a5) = *a3;
  *a4 = specialized Float16.init(sign:exponent:significand:)(a1 & 1, *a2, a5);
}

unsigned __int16 protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Float16@<H0>(unsigned __int16 *a1@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>, int8x16_t _Q0@<Q0>, int8x16_t _Q1@<Q1>)
{
  int8x16_t v9;

  _Q0.i16[0] = *a1;
  _Q1.i16[0] = *a2;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  v9.i64[0] = 0x8000000080000000;
  v9.i64[1] = 0x8000000080000000;
  _Q0.i32[0] = vbslq_s8(v9, _Q1, _Q0).u32[0];
  __asm { FCVT            H0, S0 }
  *a3 = _Q0.i16[0];
  return _Q0.i16[0];
}

__int16 protocol witness for FloatingPoint.init(_:) in conformance Float16@<H0>(uint64_t a1@<X0>, _WORD *a2@<X8>)
{
  __int16 result;

  _S0 = (float)a1;
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

__int16 Float16.init(_:)@<H0>(uint64_t a1@<X0>)
{
  __int16 result;

  _S0 = (float)a1;
  __asm { FCVT            H0, S0 }
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Float16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(_QWORD, _QWORD)@<X2>, __int16 *a4@<X8>)
{
  uint64_t result;
  char v10;
  uint64_t v11;
  __int16 v17;

  if (a3[16](a2, a3) < 65)
  {
    v10 = a3[8](a2, a3);
    v11 = a3[15](a2, a3);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    if ((v10 & 1) != 0)
      _S0 = (float)v11;
    else
      _S0 = (float)(unint64_t)v11;
    __asm { FCVT            H0, S0 }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v17, a1, a2, (uint64_t)a3);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    _H0 = v17;
  }
  *a4 = _H0;
  return result;
}

__int16 Float16.init<A>(_:)@<H0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(_QWORD, _QWORD)@<X2>)
{
  __int16 result;
  char v7;
  uint64_t v8;
  __int16 v14;

  if (a3[16](a2, a3) <= 64)
  {
    v7 = a3[8](a2, a3);
    v8 = a3[15](a2, a3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    if ((v7 & 1) != 0)
      _S0 = (float)v8;
    else
      _S0 = (float)(unint64_t)v8;
    __asm { FCVT            H0, S0 }
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v14, a1, a2, (uint64_t)a3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    return v14;
  }
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Float16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result;

  result = Float16.init<A>(exactly:)(a1, a2, a3);
  *(_WORD *)a4 = result;
  *(_BYTE *)(a4 + 2) = BYTE2(result) & 1;
  return result;
}

uint64_t Float16.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  int v12;
  char v13;
  uint64_t v14;
  void (*v15)(char *, uint64_t);
  int v21;
  uint64_t v22;
  int v26;
  uint64_t v28;
  __int16 v29;

  v6 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v28 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) <= 64)
  {
    v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
    v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v15 = *(void (**)(char *, uint64_t))(v6 + 8);
    v15(v8, a2);
    v15((char *)a1, a2);
    if ((v13 & 1) != 0)
    {
      _S0 = (float)v14;
      __asm
      {
        FCVT            H0, S0
        FCVT            S1, H0
      }
      LOWORD(v12) = LOWORD(_S0);
      v21 = ~LODWORD(_S0) & 0x7C00;
      v22 = (uint64_t)_S1;
    }
    else
    {
      _S0 = (float)(unint64_t)v14;
      __asm
      {
        FCVT            H0, S0
        FCVT            S1, H0
      }
      LOWORD(v12) = LOWORD(_S0);
      v21 = ~LODWORD(_S0) & 0x7C00;
      v22 = (unint64_t)_S1;
    }
    if (v21)
      _ZF = v14 == v22;
    else
      _ZF = 0;
    if (_ZF)
      goto LABEL_12;
  }
  else
  {
    v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v29, a1, a2, a3);
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
    if ((v11 & 1) != 0)
    {
      LOWORD(v12) = v29;
LABEL_12:
      v26 = 0;
      v12 = (unsigned __int16)v12;
      return v12 | (v26 << 16);
    }
  }
  v12 = 0;
  v26 = 1;
  return v12 | (v26 << 16);
}

void protocol witness for static FloatingPoint.nan.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2;

  v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 512);
  *a1 = LOWORD(v2);
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2;

  v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 256);
  *a1 = LOWORD(v2);
}

__int16 protocol witness for static FloatingPoint.infinity.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result;

  result = 31744;
  *a1 = 31744;
  return result;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Float16(_WORD *a1@<X8>)
{
  float v2;

  v2 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 30, 1023);
  *a1 = LOWORD(v2);
}

__int16 protocol witness for static FloatingPoint.pi.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result;

  result = 16968;
  *a1 = 16968;
  return result;
}

void protocol witness for FloatingPoint.ulp.getter in conformance Float16(_WORD *a1@<X8>)
{
  unsigned __int16 *v1;
  unsigned int v3;
  int v4;

  v3 = *v1;
  v4 = (v3 >> 10) & 0x1F;
  if (v4)
  {
    if (v4 == 31)
    {
      _S0 = specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(0, 31, 512);
    }
    else
    {
      _H0 = v3 & 0x7C00;
      __asm { FCVT            S0, H0 }
      _S0 = _S0 * 0.00097656;
      __asm { FCVT            H0, S0 }
    }
  }
  else
  {
    LOWORD(_S0) = 1;
  }
  *a1 = LOWORD(_S0);
}

__int16 protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result;

  result = 5120;
  *a1 = 5120;
  return result;
}

__int16 protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result;

  result = 1024;
  *a1 = 1024;
  return result;
}

__int16 protocol witness for static FloatingPoint.leastNonzeroMagnitude.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 result;

  result = 1;
  *a1 = 1;
  return result;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Float16(float a1)
{
  _WORD *v1;

  LOWORD(a1) = *v1;
  return Float16.sign.getter(a1);
}

uint64_t protocol witness for FloatingPoint.exponent.getter in conformance Float16@<X0>(uint64_t *a1@<X8>, float a2@<S0>)
{
  _WORD *v2;
  uint64_t result;

  LOWORD(a2) = *v2;
  result = Float16.exponent.getter(a2);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Float16(_WORD *a1@<X8>, float a2@<S0>)
{
  _WORD *v2;
  float v4;

  LOWORD(a2) = *v2;
  v4 = Float16.significand.getter(a2);
  *a1 = LOWORD(v4);
}

__int16 protocol witness for static FloatingPoint./ infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 / _S1;
  __asm { FCVT            H0, S0 }
  *a3 = result;
  return result;
}

__int16 static Float16./ infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __int16 result;

  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 / _S1;
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 protocol witness for static FloatingPoint./= infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>)
{
  __int16 result;

  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 / _S0;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>, _WORD *a2@<X8>)
{
  __int16 *v2;
  __int16 result;

  _H1 = *a1;
  _H0 = *v2;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = _stdlib_remainderf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>)
{
  __int16 *v1;
  __int16 result;

  _H1 = *a1;
  _H0 = *v1;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = _stdlib_remainderf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *v1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>, _WORD *a2@<X8>)
{
  __int16 *v2;
  __int16 result;

  _H1 = *a1;
  _H0 = *v2;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Float16@<H0>(__int16 *a1@<X0>)
{
  __int16 *v1;
  __int16 result;

  _H1 = *a1;
  _H0 = *v1;
  __asm
  {
    FCVT            S0, H0; float
    FCVT            S1, H1; float
  }
  _S0 = fmodf(_S0, _S1);
  __asm { FCVT            H0, S0 }
  *v1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.squareRoot() in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 *v1;
  __int16 result;

  _H0 = *v1;
  __asm { FCVT            S0, H0 }
  _S0 = _stdlib_squareRootf(_S0);
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.formSquareRoot() in conformance Float16@<H0>()
{
  __int16 *v0;
  __int16 result;

  _H0 = *v0;
  __asm { FCVT            S0, H0 }
  _S0 = _stdlib_squareRootf(_S0);
  __asm { FCVT            H0, S0 }
  *v0 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 *v3;
  __int16 result;

  _H0 = *a1;
  _H1 = *a2;
  _H2 = *v3;
  __asm
  {
    FCVT            S2, H2
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S2 + (float)(_S0 * _S1);
  __asm { FCVT            H0, S0 }
  *a3 = result;
  return result;
}

__int16 protocol witness for FloatingPoint.addProduct(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>)
{
  __int16 *v2;
  __int16 result;

  _H0 = *a1;
  _H1 = *a2;
  _H2 = *v2;
  __asm
  {
    FCVT            S2, H2
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S2 + (float)(_S0 * _S1);
  __asm { FCVT            H0, S0 }
  *v2 = result;
  return result;
}

_WORD *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Float16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S0) = *result;
  LOWORD(_S1) = *a2;
  __asm
  {
    FCVT            S2, H1
    FCVT            S3, H0
  }
  if (_S3 <= _S2)
    goto LABEL_7;
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }
  if ((LOWORD(_S1) & 0x3FF) == 0)
    _S0 = _S1;
  *a3 = LOWORD(_S0);
  return result;
}

_WORD *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Float16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S0) = *result;
  LOWORD(_S1) = *a2;
  __asm
  {
    FCVT            S2, H0
    FCVT            S3, H1
  }
  if (_S3 < _S2)
    goto LABEL_7;
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }
  if ((LOWORD(_S1) & 0x3FF) == 0)
    _S0 = _S1;
  *a3 = LOWORD(_S0);
  return result;
}

_WORD *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Float16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S0) = *result;
  LOWORD(_S1) = *a2;
  __asm { FCVT            S2, H0 }
  _S2 = fabsf(_S2);
  __asm
  {
    FCVT            H2, S2
    FCVT            S3, H1
  }
  _S3 = fabsf(_S3);
  __asm
  {
    FCVT            H3, S3
    FCVT            S3, H3
    FCVT            S2, H2
  }
  if (_S2 <= _S3)
    goto LABEL_7;
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }
  if ((LOWORD(_S1) & 0x3FF) == 0)
    _S0 = _S1;
  *a3 = LOWORD(_S0);
  return result;
}

_WORD *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Float16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>, float _S1@<S1>)
{
  LOWORD(_S0) = *result;
  LOWORD(_S1) = *a2;
  __asm { FCVT            S2, H0 }
  _S2 = fabsf(_S2);
  __asm
  {
    FCVT            H2, S2
    FCVT            S3, H1
  }
  _S3 = fabsf(_S3);
  __asm
  {
    FCVT            H3, S3
    FCVT            S2, H2
    FCVT            S3, H3
  }
  if (_S3 < _S2)
    goto LABEL_7;
  if ((~LODWORD(_S1) & 0x7C00) != 0)
  {
    LOWORD(_S0) = *a2;
LABEL_7:
    *a3 = LOWORD(_S0);
    return result;
  }
  if ((LOWORD(_S1) & 0x3FF) == 0)
    _S0 = _S1;
  *a3 = LOWORD(_S0);
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Float16(_BYTE *a1@<X0>, _WORD *a2@<X8>)
{
  _WORD *v2;
  __int16 v16;

  LOWORD(_S8) = *v2;
  v16 = *v2;
  switch(*a1)
  {
    case 0:
      __asm { FCVT            S0, H8; jumptable 000000018152C150 case 0 }
      _S0 = roundf(_S0);
      goto LABEL_9;
    case 1:
      __asm { FCVT            S0, H8; jumptable 000000018152C150 case 1 }
      _S0 = rintf(_S0);
      goto LABEL_9;
    case 2:
      goto LABEL_8;
    case 3:
      goto LABEL_7;
    case 4:
      __asm { FCVT            S0, H8; jumptable 000000018152C150 case 4 }
      _S0 = truncf(_S0);
      goto LABEL_9;
    case 5:
      if (Float16.sign.getter(_S8))
      {
LABEL_7:
        __asm { FCVT            S0, H8; jumptable 000000018152C150 case 3 }
        _S0 = floorf(_S0);
      }
      else
      {
LABEL_8:
        __asm { FCVT            S0, H8; jumptable 000000018152C150 case 2 }
        _S0 = ceilf(_S0);
      }
LABEL_9:
      __asm { FCVT            H0, S0 }
      break;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      _H0 = v16;
      break;
  }
  *a2 = _H0;
}

__int16 protocol witness for FloatingPoint.round(_:) in conformance Float16@<H0>(_BYTE *a1@<X0>)
{
  __int16 *v1;
  __int16 result;
  char v18;

  switch(*a1)
  {
    case 0:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = roundf(_S0);
      goto LABEL_11;
    case 1:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = rintf(_S0);
      goto LABEL_11;
    case 2:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      goto LABEL_10;
    case 3:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      goto LABEL_9;
    case 4:
      _H0 = *v1;
      __asm { FCVT            S0, H0 }
      _S0 = truncf(_S0);
      goto LABEL_11;
    case 5:
      LOWORD(_S8) = *v1;
      v18 = Float16.sign.getter(_S8);
      __asm { FCVT            S0, H8 }
      if (v18)
LABEL_9:
        _S0 = floorf(_S0);
      else
LABEL_10:
        _S0 = ceilf(_S0);
LABEL_11:
      __asm { FCVT            H0, S0 }
      *v1 = result;
      break;
    default:
      Float16._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }
  return result;
}

void protocol witness for FloatingPoint.nextUp.getter in conformance Float16(_WORD *a1@<X8>)
{
  __int16 *v1;

  _H0 = *v1;
  __asm { FCVT            S0, H0 }
  _S0 = _S0 + 0.0;
  __asm
  {
    FCVT            H0, S0
    FCVT            S1, H0
  }
  if (_S1 < INFINITY)
    LODWORD(_S0) += (SLOWORD(_S0) >> 15) | 1;
  *a1 = LOWORD(_S0);
}

__int16 protocol witness for FloatingPoint.nextDown.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 *v1;
  __int16 result;

  _H0 = *v1;
  __asm { FCVT            S0, H0 }
  _S0 = 0.0 - _S0;
  __asm
  {
    FCVT            H0, S0
    FCVT            S1, H0
  }
  if (_S1 < INFINITY)
    _H0 += (_H0 >> 15) | 1;
  __asm { FCVT            S0, H0 }
  _S0 = -_S0;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Float16(__int16 *a1)
{
  __int16 *v1;

  _H0 = *a1;
  _H1 = *v1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 == _S0;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Float16(__int16 *a1)
{
  __int16 *v1;

  _H0 = *a1;
  _H1 = *v1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 < _S0;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Float16(__int16 *a1)
{
  __int16 *v1;

  _H0 = *a1;
  _H1 = *v1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 <= _S0;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Float16(unsigned __int16 *a1, __n128 a2, __n128 a3)
{
  unsigned __int16 *v3;

  a2.n128_u16[0] = *a1;
  a3.n128_u16[0] = *v3;
  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(a2, a3);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Float16()
{
  unsigned __int16 *v0;
  int v1;

  v1 = (*v0 >> 10) & 0x1F;
  return v1 != 31 && v1 != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Float16()
{
  unsigned __int16 *v0;

  return (~*v0 & 0x7C00) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Float16()
{
  _WORD *v0;

  return (*v0 & 0x7FFF) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Float16()
{
  _WORD *v0;

  return (*v0 & 0x3FF) != 0 && (*v0 & 0x7C00) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Float16()
{
  _WORD *v0;

  return (*v0 & 0x7FFF) == 31744;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Float16()
{
  unsigned __int16 *v0;
  int v1;

  v1 = *v0;
  return (v1 & 0x3FF) != 0 && (~v1 & 0x7C00) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Float16()
{
  unsigned __int16 *v0;
  int v1;
  int v2;
  int v3;
  _BOOL4 v4;
  BOOL v5;

  v1 = *v0;
  v2 = ~v1 & 0x7C00;
  v3 = v1 & 0x3FF;
  v4 = (v1 & 0x200) == 0;
  if (v2)
    v5 = 1;
  else
    v5 = v3 == 0;
  return !v5 && v4;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Float16(float a1)
{
  _WORD *v1;

  LOWORD(a1) = *v1;
  return specialized FloatingPoint.floatingPointClass.getter(a1);
}

__int16 protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X8>)
{
  __int16 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

__int16 protocol witness for static SignedNumeric.- prefix(_:) in conformance Float16@<H0>(__int16 *a1@<X0>, _WORD *a2@<X8>)
{
  __int16 result;

  _H0 = *a1;
  __asm { FCVT            S0, H0 }
  _S0 = -_S0;
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

__int16 protocol witness for SignedNumeric.negate() in conformance Float16@<H0>()
{
  __int16 *v0;
  __int16 result;

  _H0 = *v0;
  __asm { FCVT            S0, H0 }
  _S0 = -_S0;
  __asm { FCVT            H0, S0 }
  *v0 = result;
  return result;
}

__int16 protocol witness for Numeric.magnitude.getter in conformance Float16@<H0>(_WORD *a1@<X8>)
{
  __int16 *v1;
  __int16 result;

  _H0 = *v1;
  __asm { FCVT            S0, H0 }
  _S0 = fabsf(_S0);
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 Float16.magnitude.getter@<H0>(__n128 _Q0@<Q0>)
{
  __int16 result;

  __asm { FCVT            S0, H0 }
  _S0 = fabsf(_S0);
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 protocol witness for static Numeric.* infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }
  *a3 = result;
  return result;
}

__int16 protocol witness for static Numeric.*= infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>)
{
  __int16 result;

  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.zero.getter in conformance Float16@<S0>(_WORD *a1@<X8>)
{
  float result;

  result = 0.0;
  *a1 = 0;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }
  *a3 = result;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>)
{
  __int16 result;

  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }
  *a3 = result;
  return result;
}

__int16 static Float16.- infix(_:_:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __int16 result;

  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Float16@<H0>(__int16 *a1@<X0>, __int16 *a2@<X1>)
{
  __int16 result;

  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 - _S0;
  __asm { FCVT            H0, S0 }
  *a1 = result;
  return result;
}

__int16 Float16.init(integerLiteral:)@<H0>(uint64_t a1@<X0>)
{
  __int16 result;

  _S0 = (float)a1;
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Float16@<H0>(uint64_t *a1@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  _S0 = swift_intToFloat32(a1, a2);
  __asm { FCVT            H0, S0 }
  *a3 = result;
  return result;
}

__int16 protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Float16@<H0>(uint64_t *a1@<X0>, _WORD *a2@<X8>)
{
  __int16 result;

  _S0 = (float)*a1;
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

void Float16.hash(into:)(__n128 a1)
{
  Swift::UInt16 v1;

  if ((a1.n128_u16[0] & 0x7FFF) != 0)
    v1 = a1.n128_u16[0];
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Float16._rawHashValue(seed:)(Swift::Int seed)
{
  unsigned __int16 v1;
  unsigned __int16 v2;

  v2 = v1;
  if ((v1 & 0x7FFF) == 0)
    v2 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v2, 2);
}

uint64_t Float16.hashValue.getter(__n128 a1)
{
  unsigned __int16 v1;

  v1 = a1.n128_u16[0];
  if ((a1.n128_u16[0] & 0x7FFF) == 0)
    v1 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 2);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Float16()
{
  _WORD *v0;
  uint64_t v1;

  if ((*v0 & 0x7FFF) != 0)
    v1 = (unsigned __int16)*v0;
  else
    v1 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 2);
}

void protocol witness for Hashable.hash(into:) in conformance Float16()
{
  Swift::UInt16 *v0;
  Swift::UInt16 v1;

  if ((*v0 & 0x7FFF) != 0)
    v1 = *v0;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Float16(uint64_t a1)
{
  _WORD *v1;
  uint64_t v2;

  if ((*v1 & 0x7FFF) != 0)
    v2 = (unsigned __int16)*v1;
  else
    v2 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(a1, v2, 2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a2;
  _H1 = *a1;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 == _S0;
}

uint64_t Int.init(_:)(float a1)
{
  return Int.init(_:)("Float16 value cannot be converted to Int because it is either infinite or NaN", 77, 0x36A2uLL, a1);
}

unint64_t UInt.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3093uLL, 0);
  __asm { FCVT            S0, H0 }
  if (_S0 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt because the result would be less than UInt.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3096uLL, 0);
  return (unint64_t)_S0;
}

uint64_t Float16.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S1, H0 }
  return _Q0.n128_u16[0];
}

uint64_t Float16.init(exactly:)(float _S0)
{
  int v7;

  __asm
  {
    FCVT            H1, S0
    FCVT            S2, H1
  }
  v7 = _H1;
  if (_S2 != _S0)
    v7 = 0;
  return v7 | ((_S2 != _S0) << 16);
}

uint64_t Float16.init(exactly:)(double _D0)
{
  int v7;

  __asm
  {
    FCVT            H1, D0
    FCVT            D2, H1
  }
  v7 = _H1;
  if (_D2 != _D0)
    v7 = 0;
  return v7 | ((_D2 != _D0) << 16);
}

double Double.init(_:)(__n128 _Q0)
{
  double result;

  __asm { FCVT            D0, H0 }
  return result;
}

__int16 Float16.distance(to:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __int16 result;

  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 Float16.advanced(by:)@<H0>(__n128 _Q0@<Q0>, __n128 _Q1@<Q1>)
{
  __int16 result;

  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }
  return result;
}

__int16 protocol witness for Strideable.distance(to:) in conformance Float16@<H0>(__int16 *a1@<X0>, _WORD *a2@<X8>)
{
  __int16 *v2;
  __int16 result;

  _H0 = *a1;
  _H1 = *v2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 - _S1;
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

__int16 protocol witness for Strideable.advanced(by:) in conformance Float16@<H0>(__int16 *a1@<X0>, _WORD *a2@<X8>)
{
  __int16 *v2;
  __int16 result;

  _H0 = *a1;
  _H1 = *v2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  _S0 = _S0 + _S1;
  __asm { FCVT            H0, S0 }
  *a2 = result;
  return result;
}

_WORD *protocol witness for static Strideable._step(after:from:by:) in conformance Float16(_WORD *result, uint64_t a2, char a3, __int16 *a4, __int16 *a5, __int16 *a6)
{
  _H0 = *a6;
  if ((a3 & 1) != 0)
  {
    _H1 = *a4;
    __asm
    {
      FCVT            S0, H0
      FCVT            S1, H1
    }
    _S0 = _S0 + _S1;
    goto LABEL_5;
  }
  if (!__OFADD__(a2++, 1))
  {
    _H1 = *a5;
    _S2 = (float)a2;
    __asm
    {
      FCVT            H2, S2
      FCVT            S1, H1
      FCVT            S0, H0
      FCVT            S2, H2
    }
    _S0 = _S1 + (float)(_S2 * _S0);
LABEL_5:
    __asm { FCVT            H0, S0 }
    *result = _H0;
    return (_WORD *)a2;
  }
  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  return _S0 < _S1;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  return _S0 <= _S1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 <= _S0;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Float16(__int16 *a1, __int16 *a2)
{
  _H0 = *a1;
  _H1 = *a2;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  return _S1 < _S0;
}

void Float._value.setter(float a1)
{
  float *v1;

  *v1 = a1;
}

uint64_t (*Float._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Float __swiftcall Float.init()()
{
  return 0.0;
}

unint64_t Float.description.getter(float a1)
{
  unint64_t result;
  int64_t v2;
  size_t v3;
  unint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned int v13;
  __int128 v14;
  __int128 v15;
  _OWORD __src[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((~LODWORD(a1) & 0x7F800000) == 0 && (LODWORD(a1) & 0x7FFFFF) != 0)
    return 7233902;
  v14 = 0u;
  v15 = 0u;
  v2 = swift_float32ToString(&v14, 32, 0);
  __src[0] = v14;
  __src[1] = v15;
  if (v2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v3 = v2;
  if (!v2)
    return 0;
  if ((unint64_t)v2 <= 0xF)
  {
    v7 = v2 - 8;
    v8 = 8;
    if (v2 < 8)
      v8 = v2;
    result = LOBYTE(__src[0]);
    if (v8 != 1)
    {
      result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v8 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v8 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v8 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v8 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v8 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v8 != 7)
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
              }
            }
          }
        }
      }
    }
    v9 = 0;
    if (v3 >= 9)
    {
      v10 = 0;
      v11 = (unsigned __int8 *)__src + 8;
      v12 = v7 & ~(v7 >> 63);
      do
      {
        if (v12 <= v3 - 9)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v13 = *v11++;
        v9 |= (unint64_t)v13 << v10;
        v10 += 8;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v4 = v2 | 0xF000000000000000;
    v5 = _allocateStringStorage(codeUnitCapacity:)(v2);
    *(_QWORD *)(v5 + 16) = v6;
    *(_QWORD *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
      v4 = *(_QWORD *)(v5 + 24);
    }
    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v3, (char *)(v5 + 32));
    return *(_QWORD *)(v5 + 24);
  }
  return result;
}

BOOL Float.isNaN.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFF) != 0 && (~LODWORD(a1) & 0x7F800000) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Float()
{
  float *v0;

  return Float.description.getter(*v0);
}

unint64_t Float.debugDescription.getter()
{
  int64_t v0;
  size_t v1;
  unint64_t v2;
  int64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unsigned int v12;
  __int128 v13;
  __int128 v14;
  _OWORD __src[2];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = 0u;
  v14 = 0u;
  v0 = swift_float32ToString(&v13, 32, 1);
  __src[0] = v13;
  __src[1] = v14;
  if (v0 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v1 = v0;
  if (!v0)
    return 0;
  if ((unint64_t)v0 <= 0xF)
  {
    v6 = v0 - 8;
    v7 = 8;
    if (v0 < 8)
      v7 = v0;
    result = LOBYTE(__src[0]);
    if (v7 != 1)
    {
      result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v7 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v7 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v7 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v7 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v7 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v7 != 7)
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
              }
            }
          }
        }
      }
    }
    v8 = 0;
    if (v1 >= 9)
    {
      v9 = 0;
      v10 = (unsigned __int8 *)__src + 8;
      v11 = v6 & ~(v6 >> 63);
      do
      {
        if (v11 <= v1 - 9)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v12 = *v10++;
        v8 |= (unint64_t)v12 << v9;
        v9 += 8;
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    v2 = v0 | 0xF000000000000000;
    v3 = _allocateStringStorage(codeUnitCapacity:)(v0);
    *(_QWORD *)(v3 + 16) = v4;
    *(_QWORD *)(v3 + 24) = v2;
    if (v4 < 0)
    {
      *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
      v2 = *(_QWORD *)(v3 + 24);
    }
    *(_BYTE *)(v3 + 32 + (v2 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v1, (char *)(v3 + 32));
    return *(_QWORD *)(v3 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Float()
{
  return Float.debugDescription.getter();
}

void specialized Float.write<A>(to:)()
{
  uint64_t v0;
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  memset(v1, 0, sizeof(v1));
  v0 = swift_float32ToString(v1, 32, 1);
  if (v0 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  _StringGuts.append(_:)(v0 | 0xD000000000000000, (unint64_t)&v1[0x7FFFFFFFFFFFFFELL] | 0x8000000000000000);
}

uint64_t Float.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _OWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v5 = swift_float32ToString(v7, 32, 1);
  if (v5 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a3 + 32))(v7, v5, a2, a3);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Float(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Float.write<A>(to:)(a1, a2, a3);
}

uint64_t static Float.exponentBitCount.getter()
{
  return 8;
}

uint64_t static Float.significandBitCount.getter()
{
  return 23;
}

uint64_t static Float._infinityExponent.getter()
{
  return 255;
}

uint64_t static Float._exponentBias.getter()
{
  return 127;
}

uint64_t static Float._significandMask.getter()
{
  return 0x7FFFFFLL;
}

uint64_t static Float._quietNaNMask.getter()
{
  return 0x400000;
}

Swift::Float __swiftcall Float.init(bitPattern:)(Swift::UInt32 bitPattern)
{
  return *(float *)&bitPattern;
}

uint64_t Float.sign.getter(float a1)
{
  return LODWORD(a1) >> 31;
}

uint64_t Float.exponentBitPattern.getter(float a1)
{
  return (LODWORD(a1) >> 23);
}

uint64_t Float.significandBitPattern.getter(float a1)
{
  return LODWORD(a1) & 0x7FFFFF;
}

uint64_t Float.isCanonical.getter()
{
  return 1;
}

float static Float.leastNonzeroMagnitude.getter()
{
  float result;

  LODWORD(result) = 1;
  return result;
}

float static Float.leastNormalMagnitude.getter()
{
  return 1.1755e-38;
}

float static Float.infinity.getter()
{
  return INFINITY;
}

float static Float.nan.getter()
{
  return NAN;
}

float static Float.signalingNaN.getter()
{
  return NAN;
}

Swift::Float __swiftcall Float.init(nan:signaling:)(Swift::UInt32 nan, Swift::Bool signaling)
{
  Swift::Float result;

  if (nan >= 0x200000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "NaN payload is not encodable.", 29, 2, "Swift/FloatingPointTypes.swift", 30, 2, 0x61AuLL, 0);
  LODWORD(result) = (0x400000u >> signaling) | nan | 0x7F800000;
  return result;
}

float static Float.greatestFiniteMagnitude.getter()
{
  return 3.4028e38;
}

float static Float.pi.getter()
{
  return 3.1416;
}

float Float.ulp.getter(float a1)
{
  int v2;
  float result;

  v2 = (LODWORD(a1) >> 23);
  if ((LODWORD(a1) >> 23))
  {
    result = NAN;
    if (v2 != 255)
      return COERCE_FLOAT(LODWORD(a1) & 0x7F800000) * 0.00000011921;
  }
  else
  {
    LODWORD(result) = 1;
  }
  return result;
}

BOOL Float.isNormal.getter(float a1)
{
  return (LODWORD(a1) >> 23) != 255 && (LODWORD(a1) >> 23) != 0;
}

double static Float.ulpOfOne.getter()
{
  return 3.18618444e-58;
}

uint64_t Float.exponent.getter(float a1)
{
  uint64_t v1;
  unsigned int v3;

  v1 = (LODWORD(a1) >> 23);
  if ((_DWORD)v1 == 255)
    return 0x7FFFFFFFFFFFFFFFLL;
  v3 = LODWORD(a1) & 0x7FFFFF;
  if (!(v1 | LODWORD(a1) & 0x7FFFFF))
    return 0x8000000000000000;
  if ((LODWORD(a1) >> 23))
    return v1 - 127;
  if (!v3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  return v1 - __clz(v3) - 118;
}

BOOL Float.isZero.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 0;
}

float Float.significand.getter(float result)
{
  int v1;
  unsigned int v2;

  v1 = (LODWORD(result) >> 23);
  v2 = LODWORD(result) & 0x7FFFFF;
  if ((LODWORD(result) & 0x7FFFFF) == 0 || v1 != 255)
  {
    if ((LODWORD(result) >> 23))
    {
      if (v1 != 255)
      {
        LODWORD(result) = v2 | 0x3F800000;
        return result;
      }
    }
    else if (v2)
    {
      LODWORD(result) = (LODWORD(result) << (__clz(v2) + 24)) & 0x7FFFFF | 0x3F800000;
      return result;
    }
    LODWORD(result) = v1 << 23;
  }
  return result;
}

BOOL Float.isSubnormal.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFF) != 0 && (LODWORD(a1) & 0x7F800000) == 0;
}

Swift::Float __swiftcall Float.init(sign:exponent:significand:)(Swift::FloatingPointSign sign, Swift::Int exponent, Swift::Float significand)
{
  return specialized Float.init(sign:exponent:significand:)(sign & 1, exponent, significand);
}

float static Float.- prefix(_:)(float a1)
{
  return -a1;
}

float static Float.*= infix(_:_:)(float *a1, float a2)
{
  float result;

  result = *a1 * a2;
  *a1 = result;
  return result;
}

float Float.nextUp.getter(float a1)
{
  float result;

  result = a1 + 0.0;
  if (result < INFINITY)
    LODWORD(result) += (SLODWORD(result) >> 31) | 1;
  return result;
}

float static Float.+ infix(_:_:)(float a1, float a2)
{
  return a1 + a2;
}

uint64_t static Int32.&>> infix(_:_:)(int a1, char a2)
{
  return (a1 >> a2);
}

uint64_t static Int32.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

Swift::Float __swiftcall Float.init(signOf:magnitudeOf:)(Swift::Float signOf, Swift::Float magnitudeOf)
{
  int8x16_t v2;
  Swift::Float result;

  v2.i64[0] = 0x8000000080000000;
  v2.i64[1] = 0x8000000080000000;
  LODWORD(result) = vbslq_s8(v2, *(int8x16_t *)&magnitudeOf, *(int8x16_t *)&signOf).u32[0];
  return result;
}

Swift::Void __swiftcall Float.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  float *v1;
  float v2;

  switch(*(_BYTE *)a1)
  {
    case 0:
      *v1 = roundf(*v1);
      return;
    case 1:
      *v1 = rintf(*v1);
      return;
    case 2:
      v2 = *v1;
      goto LABEL_9;
    case 3:
      v2 = *v1;
      goto LABEL_10;
    case 4:
      *v1 = truncf(*v1);
      return;
    case 5:
      v2 = *v1;
      if ((*(_DWORD *)v1 & 0x80000000) != 0)
LABEL_10:
        *v1 = floorf(v2);
      else
LABEL_9:
        *v1 = ceilf(v2);
      break;
    default:
      Float._roundSlowPath(_:)(a1);
      break;
  }
}

Swift::Void __swiftcall Float._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  float *v1;
  float v2;
  float v3;
  char v4;

  v4 = *(_BYTE *)a1;
  switch(v4)
  {
    case 0:
      v2 = roundf(*v1);
      goto LABEL_11;
    case 1:
      v2 = rintf(*v1);
      goto LABEL_11;
    case 2:
      v3 = *v1;
      goto LABEL_9;
    case 3:
      v3 = *v1;
      goto LABEL_10;
    case 4:
      v2 = truncf(*v1);
      goto LABEL_11;
    case 5:
      v3 = *v1;
      if ((*(_DWORD *)v1 & 0x80000000) != 0)
LABEL_10:
        v2 = floorf(v3);
      else
LABEL_9:
        v2 = ceilf(v3);
LABEL_11:
      *v1 = v2;
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v4);
      break;
  }
}

Swift::Void __swiftcall Float.negate()()
{
  float *v0;

  *v0 = -*v0;
}

float static Float.+= infix(_:_:)(float *a1, float a2)
{
  float result;

  result = *a1 + a2;
  *a1 = result;
  return result;
}

float static Float.-= infix(_:_:)(float *a1, float a2)
{
  float result;

  result = *a1 - a2;
  *a1 = result;
  return result;
}

float static Float./= infix(_:_:)(float *a1, float a2)
{
  float result;

  result = *a1 / a2;
  *a1 = result;
  return result;
}

Swift::Void __swiftcall Float.formRemainder(dividingBy:)(Swift::Float dividingBy)
{
  float *v1;

  *v1 = remainderf(*v1, dividingBy);
}

Swift::Void __swiftcall Float.formTruncatingRemainder(dividingBy:)(Swift::Float dividingBy)
{
  float *v1;

  *v1 = fmodf(*v1, dividingBy);
}

Swift::Void __swiftcall Float.formSquareRoot()()
{
  float *v0;

  *v0 = sqrtf(*v0);
}

Swift::Void __swiftcall Float.addProduct(_:_:)(Swift::Float a1, Swift::Float a2)
{
  float *v2;

  *v2 = *v2 + (float)(a1 * a2);
}

Swift::Bool __swiftcall Float.isEqual(to:)(Swift::Float to)
{
  float v1;

  return v1 == to;
}

Swift::Bool __swiftcall Float.isLess(than:)(Swift::Float than)
{
  float v1;

  return v1 < than;
}

Swift::Bool __swiftcall Float.isLessThanOrEqualTo(_:)(Swift::Float a1)
{
  float v1;

  return v1 <= a1;
}

BOOL Float.isInfinite.getter(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 2139095040;
}

BOOL Float.isSignalingNaN.getter(float a1)
{
  return (~LODWORD(a1) & 0x7F800000) == 0 && (LODWORD(a1) & 0x7FFFFF) != 0 && (LODWORD(a1) & 0x400000) == 0;
}

float Float.binade.getter(float a1)
{
  float result;

  if ((LODWORD(a1) >> 23) == 255)
    return NAN;
  if ((LODWORD(a1) & 0x7FFFFF) != 0 && !(LODWORD(a1) >> 23))
    return COERCE_FLOAT(COERCE_UNSIGNED_INT(a1 * 8388600.0) & 0xFF800000) * 0.00000011921;
  LODWORD(result) = LODWORD(a1) & 0xFF800000;
  return result;
}

uint64_t Float.significandWidth.getter(float a1)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v1 = LODWORD(a1) & 0x7FFFFF;
  v2 = __clz(__rbit32(LODWORD(a1) & 0x7FFFFF));
  if ((LODWORD(a1) >> 23) && (LODWORD(a1) >> 23) != 255)
  {
    v5 = 23 - v2;
    if (v1)
      return v5;
    else
      return 0;
  }
  else
  {
    result = -1;
    if ((LODWORD(a1) & 0x7F800000) == 0)
    {
      v4 = 32 - (__clz(v1) + v2 + 1);
      if (v1)
        return v4;
    }
  }
  return result;
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Float(char a1@<W0>, _QWORD *a2@<X1>, int *a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
}

void protocol witness for BinaryFloatingPoint.init(_:) in conformance Float(float *a1@<X8>, float a2@<S0>)
{
  *a1 = a2;
}

float protocol witness for BinaryFloatingPoint.init(_:) in conformance Float@<S0>(float *a1@<X8>, double a2@<D0>)
{
  float result;

  result = a2;
  *a1 = result;
  return result;
}

Swift::Float __swiftcall Float.init(_:)(Swift::Double a1)
{
  return a1;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Float(const char *a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
}

unint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Float@<X0>(const char *a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result;

  result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(_DWORD *)a4 = result;
  *(_BYTE *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Float()
{
  return 23;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Float(_QWORD *a1@<X8>)
{
  unsigned int *v1;

  *a1 = ((unint64_t)*v1 >> 23);
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Float(int *a1@<X8>)
{
  _DWORD *v1;

  *a1 = *v1 & 0x7FFFFF;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Float(float *a1@<X8>)
{
  float *v1;

  *a1 = Float.binade.getter(*v1);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Float()
{
  float *v0;

  return Float.significandWidth.getter(*v0);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Float(char a1@<W0>, uint64_t *a2@<X1>, float *a3@<X2>, float *a4@<X8>)
{
  *a4 = specialized Float.init(sign:exponent:significand:)(a1 & 1, *a2, *a3);
}

double protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Float@<D0>(unsigned __int32 *a1@<X0>, unsigned __int32 *a2@<X1>, _DWORD *a3@<X8>, int8x16_t a4@<Q0>, int8x16_t a5@<Q1>)
{
  int8x16_t v5;

  a4.i32[0] = *a1;
  a5.i32[0] = *a2;
  v5.i64[0] = 0x8000000080000000;
  v5.i64[1] = 0x8000000080000000;
  a4.i64[0] = vbslq_s8(v5, a5, a4).u64[0];
  *a3 = a4.i32[0];
  return *(double *)a4.i64;
}

float protocol witness for FloatingPoint.init(_:) in conformance Float@<S0>(uint64_t a1@<X0>, float *a2@<X8>)
{
  float result;

  result = (float)a1;
  *a2 = (float)a1;
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Float@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(_QWORD, _QWORD)@<X2>, float *a4@<X8>)
{
  uint64_t result;
  float v9;
  char v10;
  uint64_t v11;
  float v12;

  if (a3[16](a2, a3) < 65)
  {
    v10 = a3[8](a2, a3);
    v11 = a3[15](a2, a3);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    if ((v10 & 1) != 0)
      v9 = (float)v11;
    else
      v9 = (float)(unint64_t)v11;
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v12, a1, a2, (uint64_t)a3);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    v9 = v12;
  }
  *a4 = v9;
  return result;
}

float Float.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t (**a3)(_QWORD, _QWORD))
{
  char v7;
  uint64_t v8;
  float v9;

  if (a3[16](a2, a3) <= 64)
  {
    v7 = a3[8](a2, a3);
    v8 = a3[15](a2, a3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    if ((v7 & 1) != 0)
      return (float)v8;
    else
      return (float)(unint64_t)v8;
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v9, a1, a2, (uint64_t)a3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    return v9;
  }
}

unint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Float@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result;

  result = Float.init<A>(exactly:)(a1, a2, a3);
  *(_DWORD *)a4 = result;
  *(_BYTE *)(a4 + 4) = BYTE4(result) & 1;
  return result;
}

unint64_t Float.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  float v12;
  char v13;
  uint64_t v14;
  void (*v15)(char *, uint64_t);
  float v16;
  float v17;
  unsigned __int8 v18;
  uint64_t v19;
  uint64_t v21;
  float v22;
  unsigned __int8 v23;

  v6 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) <= 64)
  {
    v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
    v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v15 = *(void (**)(char *, uint64_t))(v6 + 8);
    v15(v8, a2);
    if ((v13 & 1) != 0)
    {
      v16 = (float)v14;
      if ((float)v14 < 9.2234e18)
      {
        v12 = (float)v14;
        if ((~LODWORD(v16) & 0x7F800000) == 0)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int because it is either infinite or NaN", 75, 2, "Swift/IntegerTypes.swift", 24, 2, 0x36EDuLL, 0);
        if (v16 <= -9.2234e18)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int because the result would be less than Int.min", 84, 2, "Swift/IntegerTypes.swift", 24, 2, 0x36F0uLL, 0);
        v15((char *)a1, a2);
        if (v14 == (uint64_t)v16)
          goto LABEL_13;
LABEL_15:
        v19 = 0;
        v18 = 1;
        goto LABEL_16;
      }
    }
    else
    {
      v17 = (float)(unint64_t)v14;
      if ((float)(unint64_t)v14 < 1.8447e19)
      {
        v12 = (float)(unint64_t)v14;
        if ((~LODWORD(v17) & 0x7F800000) == 0)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E1uLL, 0);
        v15((char *)a1, a2);
        if (v14 == (unint64_t)v17)
          goto LABEL_13;
        goto LABEL_15;
      }
    }
    v15((char *)a1, a2);
    goto LABEL_15;
  }
  v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)(&v22, a1, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
  if ((v11 & 1) == 0)
    goto LABEL_15;
  v12 = v22;
LABEL_13:
  v18 = 0;
  v19 = LODWORD(v12);
LABEL_16:
  v23 = v18;
  return v19 | ((unint64_t)v18 << 32);
}

void protocol witness for static FloatingPoint.nan.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2143289344;
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Float(float *a1@<X8>)
{
  *a1 = specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(0, 0xFFu, 0x200000);
}

void protocol witness for static FloatingPoint.infinity.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2139095040;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 2139095039;
}

void protocol witness for static FloatingPoint.pi.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 1078530010;
}

float protocol witness for FloatingPoint.ulp.getter in conformance Float@<S0>(float *a1@<X8>)
{
  _DWORD *v1;
  float result;
  float v3;

  if ((*v1 >> 23))
  {
    if ((*v1 >> 23) != 255)
    {
      result = COERCE_FLOAT(*v1 & 0x7F800000) * 0.00000011921;
      *a1 = result;
      return result;
    }
    v3 = NAN;
  }
  else
  {
    LODWORD(v3) = 1;
  }
  result = v3;
  *a1 = v3;
  return result;
}

void protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 872415232;
}

void protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 0x800000;
}

void protocol witness for static FloatingPoint.leastNonzeroMagnitude.getter in conformance Float(_DWORD *a1@<X8>)
{
  *a1 = 1;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Float()
{
  float *v0;

  return Float.sign.getter(*v0);
}

uint64_t protocol witness for FloatingPoint.exponent.getter in conformance Float@<X0>(uint64_t *a1@<X8>)
{
  float *v1;
  uint64_t result;

  result = Float.exponent.getter(*v1);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Float(float *a1@<X8>)
{
  float *v1;

  *a1 = Float.significand.getter(*v1);
}

float protocol witness for static FloatingPoint./ infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *a1 / *a2;
  *a3 = result;
  return result;
}

float static Float./ infix(_:_:)(float a1, float a2)
{
  return a1 / a2;
}

float protocol witness for static FloatingPoint./= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result;

  result = *a1 / *a2;
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Float(float *a1@<X0>, float *a2@<X8>)
{
  float *v2;

  *a2 = _stdlib_remainderf(*v2, *a1);
}

void protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Float(float *a1)
{
  float *v1;

  *v1 = _stdlib_remainderf(*v1, *a1);
}

void protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Float(float *a1@<X0>, float *a2@<X8>)
{
  float *v2;

  *a2 = fmodf(*v2, *a1);
}

void protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Float(float *a1)
{
  float *v1;

  *v1 = fmodf(*v1, *a1);
}

void protocol witness for FloatingPoint.squareRoot() in conformance Float(float *a1@<X8>)
{
  float *v1;

  *a1 = _stdlib_squareRootf(*v1);
}

void protocol witness for FloatingPoint.formSquareRoot() in conformance Float()
{
  float *v0;

  *v0 = _stdlib_squareRootf(*v0);
}

float protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float *v3;
  float result;

  result = *v3 + (float)(*a1 * *a2);
  *a3 = result;
  return result;
}

float protocol witness for FloatingPoint.addProduct(_:_:) in conformance Float(float *a1, float *a2)
{
  float *v2;
  float result;

  result = *v2 + (float)(*a1 * *a2);
  *v2 = result;
  return result;
}

float *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3;

  v3 = *result;
  if (*result > *a2)
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0)
      v3 = *a2;
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3;

  v3 = *result;
  if (*a2 >= *result)
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0)
      v3 = *a2;
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3;

  v3 = *result;
  if (fabsf(*result) > fabsf(*a2))
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0)
      v3 = *a2;
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

float *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Float@<X0>(float *result@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3;

  v3 = *result;
  if (fabsf(*a2) >= fabsf(*result))
  {
    if ((*(_DWORD *)a2 & 0x7FFFFF) == 0)
      v3 = *a2;
    if ((~*(_DWORD *)a2 & 0x7F800000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Float(_BYTE *a1@<X0>, float *a2@<X8>)
{
  float *v2;
  float v4;
  float v5;
  char v6;
  float v7;
  float v8;

  v4 = *v2;
  v8 = *v2;
  switch(*a1)
  {
    case 0:
      v5 = roundf(v4);
      break;
    case 1:
      v5 = rintf(v4);
      break;
    case 2:
      v5 = ceilf(v4);
      break;
    case 3:
      v5 = floorf(v4);
      break;
    case 4:
      v5 = truncf(v4);
      break;
    case 5:
      v6 = Float.sign.getter(v4);
      v5 = ceilf(v4);
      v7 = floorf(v4);
      if (v6)
        v5 = v7;
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      v5 = v8;
      break;
  }
  *a2 = v5;
}

void protocol witness for FloatingPoint.round(_:) in conformance Float(_BYTE *a1)
{
  float *v1;
  float v2;
  float v3;

  switch(*a1)
  {
    case 0:
      v2 = roundf(*v1);
      goto LABEL_11;
    case 1:
      v2 = rintf(*v1);
      goto LABEL_11;
    case 2:
      v2 = ceilf(*v1);
      goto LABEL_11;
    case 3:
      v2 = floorf(*v1);
      goto LABEL_11;
    case 4:
      v2 = truncf(*v1);
      goto LABEL_11;
    case 5:
      v3 = *v1;
      if (Float.sign.getter(*v1))
        v2 = floorf(v3);
      else
        v2 = ceilf(v3);
LABEL_11:
      *v1 = v2;
      break;
    default:
      Float._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }
}

void protocol witness for FloatingPoint.nextUp.getter in conformance Float(float *a1@<X8>)
{
  float *v1;
  float v2;

  v2 = *v1 + 0.0;
  if (v2 < INFINITY)
    LODWORD(v2) += (SLODWORD(v2) >> 31) | 1;
  *a1 = v2;
}

float protocol witness for FloatingPoint.nextDown.getter in conformance Float@<S0>(float *a1@<X8>)
{
  float *v1;
  float v2;
  float result;

  v2 = 0.0 - *v1;
  if (v2 < INFINITY)
    LODWORD(v2) += (SLODWORD(v2) >> 31) | 1;
  result = -v2;
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Float(float *a1)
{
  float *v1;

  return *v1 == *a1;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Float(float *a1)
{
  float *v1;

  return *v1 < *a1;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Float(float *a1)
{
  float *v1;

  return *v1 <= *a1;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Float(float *a1)
{
  float *v1;

  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(*a1, *v1);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Float()
{
  _DWORD *v0;

  return (*v0 >> 23) != 255 && (*v0 >> 23) != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Float()
{
  _DWORD *v0;

  return (~*v0 & 0x7F800000) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Float()
{
  _DWORD *v0;

  return (*v0 & 0x7FFFFFFF) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Float()
{
  _DWORD *v0;

  return (*v0 & 0x7FFFFF) != 0 && (*v0 & 0x7F800000) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Float()
{
  _DWORD *v0;

  return (*v0 & 0x7FFFFFFF) == 2139095040;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Float()
{
  _DWORD *v0;

  return (*v0 & 0x7FFFFF) != 0 && (~*v0 & 0x7F800000) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Float()
{
  _DWORD *v0;

  return (~*v0 & 0x7F800000) == 0 && (*v0 & 0x7FFFFF) != 0 && (*v0 & 0x400000) == 0;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Float()
{
  float *v0;

  return specialized FloatingPoint.floatingPointClass.getter(*v0);
}

float protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Float@<S0>(float *a1@<X0>, _DWORD *a2@<X8>)
{
  float result;

  result = *a1;
  *a2 = *(_DWORD *)a1;
  return result;
}

float protocol witness for static SignedNumeric.- prefix(_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float result;

  result = -*a1;
  *a2 = result;
  return result;
}

float protocol witness for SignedNumeric.negate() in conformance Float()
{
  float *v0;
  float result;

  result = -*v0;
  *v0 = result;
  return result;
}

float protocol witness for Numeric.magnitude.getter in conformance Float@<S0>(float *a1@<X8>)
{
  float *v1;
  float result;

  result = fabsf(*v1);
  *a1 = result;
  return result;
}

float Float.magnitude.getter(float a1)
{
  return fabsf(a1);
}

float protocol witness for static Numeric.* infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *a1 * *a2;
  *a3 = result;
  return result;
}

float protocol witness for static Numeric.*= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result;

  result = *a2 * *a1;
  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *a1 + *a2;
  *a3 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result;

  result = *a2 + *a1;
  *a1 = result;
  return result;
}

float protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *a1 - *a2;
  *a3 = result;
  return result;
}

float static Float.- infix(_:_:)(float a1, float a2)
{
  return a1 - a2;
}

float protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  float result;

  result = *a1 - *a2;
  *a1 = result;
  return result;
}

Swift::Float __swiftcall Float.init(integerLiteral:)(Swift::Int64 integerLiteral)
{
  return (float)integerLiteral;
}

void protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Float(uint64_t *a1@<X0>, unint64_t a2@<X1>, float *a3@<X8>)
{
  *a3 = swift_intToFloat32(a1, a2);
}

float protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Float@<S0>(uint64_t *a1@<X0>, float *a2@<X8>)
{
  float result;

  result = (float)*a1;
  *a2 = result;
  return result;
}

void Float.hash(into:)(float a1)
{
  Swift::UInt32 v1;

  if ((LODWORD(a1) & 0x7FFFFFFF) != 0)
    v1 = LODWORD(a1);
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Float._rawHashValue(seed:)(Swift::Int seed)
{
  unsigned int v1;
  uint64_t v2;

  if ((v1 & 0x7FFFFFFF) != 0)
    v2 = v1;
  else
    v2 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v2, 4);
}

uint64_t Float.hashValue.getter(float a1)
{
  uint64_t v1;

  if ((LODWORD(a1) & 0x7FFFFFFF) != 0)
    v1 = LODWORD(a1);
  else
    v1 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 4);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Float()
{
  _DWORD *v0;
  uint64_t v1;

  if ((*v0 & 0x7FFFFFFF) != 0)
    v1 = *v0;
  else
    v1 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(0, v1, 4);
}

void protocol witness for Hashable.hash(into:) in conformance Float()
{
  Swift::UInt32 *v0;
  Swift::UInt32 v1;

  if ((*v0 & 0x7FFFFFFF) != 0)
    v1 = *v0;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Float(uint64_t a1)
{
  _DWORD *v1;
  uint64_t v2;

  if ((*v1 & 0x7FFFFFFF) != 0)
    v2 = *v1;
  else
    v2 = 0;
  return specialized static Hasher._hash(seed:bytes:count:)(a1, v2, 4);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 == *a2;
}

void Float._toCustomAnyHashable()(uint64_t a1@<X8>, float a2@<S0>)
{
  *(_QWORD *)(a1 + 24) = &type metadata for _FloatAnyHashableBox;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _FloatAnyHashableBox;
  *(float *)a1 = a2;
}

float protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Float@<S0>(uint64_t a1@<X8>)
{
  float *v1;
  float result;

  result = *v1;
  *(_QWORD *)(a1 + 24) = &type metadata for _FloatAnyHashableBox;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _FloatAnyHashableBox;
  *(float *)a1 = result;
  return result;
}

Swift::UInt __swiftcall UInt.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E1uLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because the result would be less than UInt.min", 86, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E4uLL, 0);
  if (a1 >= 1.8447e19)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt because the result would be greater than UInt.max", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x30E7uLL, 0);
  return (unint64_t)a1;
}

uint64_t Float.init(exactly:)(__n128 _Q0)
{
  __asm { FCVT            S0, H0 }
  return _S0;
}

Swift::Float __swiftcall Float.distance(to:)(Swift::Float to)
{
  float v1;

  return to - v1;
}

Swift::Float __swiftcall Float.advanced(by:)(Swift::Float by)
{
  float v1;

  return by + v1;
}

float protocol witness for Strideable.distance(to:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float *v2;
  float result;

  result = *a1 - *v2;
  *a2 = result;
  return result;
}

float protocol witness for Strideable.advanced(by:) in conformance Float@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float *v2;
  float result;

  result = *a1 + *v2;
  *a2 = result;
  return result;
}

float *protocol witness for static Strideable._step(after:from:by:) in conformance Float(float *result, uint64_t a2, char a3, float *a4, float *a5, float *a6)
{
  float v6;
  float v8;

  v6 = *a6;
  if ((a3 & 1) != 0)
  {
    v8 = v6 + *a4;
    goto LABEL_5;
  }
  if (!__OFADD__(a2++, 1))
  {
    v8 = *a5 + (float)((float)a2 * v6);
LABEL_5:
    *result = v8;
    return (float *)a2;
  }
  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a1 <= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a2 <= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Float(float *a1, float *a2)
{
  return *a2 < *a1;
}

void _FloatAnyHashableBox._canonicalBox.getter(uint64_t a1@<X8>, float a2@<S0>)
{
  float v3;
  uint64_t v6;
  uint64_t *v7;

  v3 = truncf(a2);
  if (a2 >= 0.0)
  {
    if (a2 <= -1.0 || a2 >= 1.8447e19 || v3 != a2)
      goto LABEL_18;
    v6 = (unint64_t)a2;
    v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
  }
  else
  {
    if (a2 <= -9.2234e18 || a2 >= 9.2234e18 || v3 != a2)
    {
LABEL_18:
      *(_QWORD *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
      *(_QWORD *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
      *(double *)a1 = a2;
      return;
    }
    v6 = (uint64_t)a2;
    v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  }
  *(_QWORD *)(a1 + 24) = __swift_instantiateConcreteTypeFromMangledName(v7);
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_QWORD *)a1 = v6;
}

Swift::Double_optional __swiftcall Double.init(exactly:)(Swift::Float exactly)
{
  double v1;
  Swift::Double_optional result;

  v1 = exactly;
  result.is_nil = LOBYTE(v1);
  *(Swift::Float *)&result.value = exactly;
  return result;
}

uint64_t _FloatAnyHashableBox._unbox<A>()@<X0>(Class *a1@<X0>, char *a2@<X8>, float a3@<S0>)
{
  int v5;
  uint64_t v7;

  *(float *)&v7 = a3;
  v5 = swift_dynamicCast(a2, &v7, (Class *)&type metadata for Float, a1, 6uLL);
  return (*((uint64_t (**)(char *, _QWORD, uint64_t, Class *))*(a1 - 1) + 7))(a2, v5 ^ 1u, 1, a1);
}

uint64_t _FloatAnyHashableBox._downCastConditional<A>(into:)(char *a1, Class *a2, uint64_t a3, uint64_t a4, float a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  void (*v17)(char *, uint64_t, uint64_t, Class *);
  void (*v18)(char *, char *, Class *);
  _BYTE v20[12];
  uint64_t v21;

  v8 = type metadata accessor for Optional(0, (uint64_t)a2, a3, a4);
  v9 = *(_QWORD *)(v8 - 8);
  v10 = MEMORY[0x1E0C80A78](v8);
  v12 = &v20[-v11];
  v13 = (uint64_t)*(a2 - 1);
  MEMORY[0x1E0C80A78](v10);
  v15 = &v20[-((v14 + 15) & 0xFFFFFFFFFFFFFFF0)];
  *(float *)&v21 = a5;
  v16 = swift_dynamicCast(v12, &v21, (Class *)&type metadata for Float, a2, 6uLL);
  v17 = *(void (**)(char *, uint64_t, uint64_t, Class *))(v13 + 56);
  if ((_DWORD)v16)
  {
    v17(v12, 0, 1, a2);
    v18 = *(void (**)(char *, char *, Class *))(v13 + 32);
    v18(v15, v12, a2);
    v18(a1, v15, a2);
  }
  else
  {
    v17(v12, 1, 1, a2);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  }
  return v16;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _FloatAnyHashableBox(uint64_t a1@<X8>)
{
  float *v1;

  _FloatAnyHashableBox._canonicalBox.getter(a1, *v1);
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _FloatAnyHashableBox(uint64_t a1, Class *a2)
{
  float *v2;
  float v4;
  Class *v5;
  float v7;
  uint64_t v8[5];

  v4 = *v2;
  outlined init with copy of MirrorPath(a1, (uint64_t)v8);
  v5 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  if (swift_dynamicCast((char *)&v7, v8, v5, a2, 6uLL))
    return v4 == v7;
  else
    return 2;
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _FloatAnyHashableBox()
{
  Swift::UInt32 *v0;
  Swift::UInt32 v1;

  if ((*v0 & 0x7FFFFFFF) != 0)
    v1 = *v0;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _FloatAnyHashableBox()
{
  Swift::UInt32 *v0;
  Swift::UInt32 v1;

  if ((*v0 & 0x7FFFFFFF) != 0)
    v1 = *v0;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

float protocol witness for _AnyHashableBox._base.getter in conformance _FloatAnyHashableBox@<S0>(uint64_t a1@<X8>)
{
  float *v1;
  float result;

  result = *v1;
  *(_QWORD *)(a1 + 24) = &type metadata for Float;
  *(float *)a1 = result;
  return result;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _FloatAnyHashableBox@<X0>(Class *a1@<X0>, char *a2@<X8>)
{
  float *v2;

  return _FloatAnyHashableBox._unbox<A>()(a1, a2, *v2);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _FloatAnyHashableBox(char *a1, Class *a2, uint64_t a3, uint64_t a4)
{
  float *v4;

  return _FloatAnyHashableBox._downCastConditional<A>(into:)(a1, a2, a3, a4, *v4);
}

void Double._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*Double._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::Double __swiftcall Double.init()()
{
  return 0.0;
}

BOOL Double.isNaN.getter(double a1)
{
  return (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && (~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Double()
{
  double *v0;

  return Double.description.getter(*v0);
}

unint64_t Double.debugDescription.getter()
{
  int64_t v0;
  size_t v1;
  unint64_t v2;
  int64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unsigned int v12;
  __int128 v13;
  __int128 v14;
  _OWORD __src[2];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = 0u;
  v14 = 0u;
  v0 = swift_float64ToString(&v13, 32, 1);
  __src[0] = v13;
  __src[1] = v14;
  if (v0 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v1 = v0;
  if (!v0)
    return 0;
  if ((unint64_t)v0 <= 0xF)
  {
    v6 = v0 - 8;
    v7 = 8;
    if (v0 < 8)
      v7 = v0;
    result = LOBYTE(__src[0]);
    if (v7 != 1)
    {
      result = LOBYTE(__src[0]) | ((unint64_t)BYTE1(__src[0]) << 8);
      if (v7 != 2)
      {
        result |= (unint64_t)BYTE2(__src[0]) << 16;
        if (v7 != 3)
        {
          result |= (unint64_t)BYTE3(__src[0]) << 24;
          if (v7 != 4)
          {
            result |= (unint64_t)BYTE4(__src[0]) << 32;
            if (v7 != 5)
            {
              result |= (unint64_t)BYTE5(__src[0]) << 40;
              if (v7 != 6)
              {
                result |= (unint64_t)BYTE6(__src[0]) << 48;
                if (v7 != 7)
                  result |= (unint64_t)BYTE7(__src[0]) << 56;
              }
            }
          }
        }
      }
    }
    v8 = 0;
    if (v1 >= 9)
    {
      v9 = 0;
      v10 = (unsigned __int8 *)__src + 8;
      v11 = v6 & ~(v6 >> 63);
      do
      {
        if (v11 <= v1 - 9)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v12 = *v10++;
        v8 |= (unint64_t)v12 << v9;
        v9 += 8;
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    v2 = v0 | 0xF000000000000000;
    v3 = _allocateStringStorage(codeUnitCapacity:)(v0);
    *(_QWORD *)(v3 + 16) = v4;
    *(_QWORD *)(v3 + 24) = v2;
    if (v4 < 0)
    {
      *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
      v2 = *(_QWORD *)(v3 + 24);
    }
    *(_BYTE *)(v3 + 32 + (v2 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)((char *)__src, v1, (char *)(v3 + 32));
    return *(_QWORD *)(v3 + 24);
  }
  return result;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance Double()
{
  return Double.debugDescription.getter();
}

void specialized Double.write<A>(to:)()
{
  uint64_t v0;
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  memset(v1, 0, sizeof(v1));
  v0 = swift_float64ToString(v1, 32, 1);
  if (v0 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  _StringGuts.append(_:)(v0 | 0xD000000000000000, (unint64_t)&v1[0x7FFFFFFFFFFFFFELL] | 0x8000000000000000);
}

uint64_t Double.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _OWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v5 = swift_float64ToString(v7, 32, 1);
  if (v5 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  return (*(uint64_t (**)(_OWORD *, uint64_t, uint64_t, uint64_t))(a3 + 32))(v7, v5, a2, a3);
}

uint64_t protocol witness for TextOutputStreamable.write<A>(to:) in conformance Double(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Double.write<A>(to:)(a1, a2, a3);
}

uint64_t static Double.exponentBitCount.getter()
{
  return 11;
}

uint64_t static Double.significandBitCount.getter()
{
  return 52;
}

uint64_t static Double._infinityExponent.getter()
{
  return 2047;
}

uint64_t static Double._exponentBias.getter()
{
  return 1023;
}

uint64_t static Double._significandMask.getter()
{
  return 0xFFFFFFFFFFFFFLL;
}

uint64_t static Double._quietNaNMask.getter()
{
  return 0x8000000000000;
}

Swift::Double __swiftcall Double.init(bitPattern:)(Swift::UInt64 bitPattern)
{
  return *(double *)&bitPattern;
}

uint64_t Double.sign.getter(double a1)
{
  return *(_QWORD *)&a1 >> 63;
}

uint64_t Double.exponentBitPattern.getter(double a1)
{
  return (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
}

uint64_t Double.significandBitPattern.getter(double a1)
{
  return *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL;
}

uint64_t Double.isCanonical.getter()
{
  return 1;
}

double static Double.leastNonzeroMagnitude.getter()
{
  double result;

  *(_QWORD *)&result = 1;
  return result;
}

double static Double.leastNormalMagnitude.getter()
{
  return 2.22507386e-308;
}

double static Double.infinity.getter()
{
  return INFINITY;
}

double static Double.nan.getter()
{
  return NAN;
}

double static Double.signalingNaN.getter()
{
  return NAN;
}

Swift::Double __swiftcall Double.init(nan:signaling:)(Swift::UInt64 nan, Swift::Bool signaling)
{
  Swift::Double result;

  if (nan >> 50)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "NaN payload is not encodable.", 29, 2, "Swift/FloatingPointTypes.swift", 30, 2, 0xAC2uLL, 0);
  *(_QWORD *)&result = (0x8000000000000uLL >> signaling) | nan | 0x7FF0000000000000;
  return result;
}

double static Double.greatestFiniteMagnitude.getter()
{
  return 1.79769313e308;
}

double static Double.pi.getter()
{
  return 3.14159265;
}

double Double.ulp.getter(double a1)
{
  uint64_t v2;
  double result;

  v2 = (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
  if (v2)
  {
    result = NAN;
    if (v2 != 2047)
      return COERCE_DOUBLE(*(_QWORD *)&a1 & 0x7FF0000000000000) * 2.22044605e-16;
  }
  else
  {
    *(_QWORD *)&result = 1;
  }
  return result;
}

BOOL Double.isFinite.getter(double a1)
{
  return (~*(_QWORD *)&a1 & 0x7FF0000000000000) != 0;
}

BOOL Double.isNormal.getter(double a1)
{
  return ((*(_QWORD *)&a1 >> 52) & 0x7FFLL) != 0x7FF && ((*(_QWORD *)&a1 >> 52) & 0x7FFLL) != 0;
}

double static Double.ulpOfOne.getter()
{
  return 2.22044605e-16;
}

unint64_t Double.exponent.getter(double a1)
{
  uint64_t v1;
  unint64_t v3;

  v1 = (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047)
    return 0x7FFFFFFFFFFFFFFFLL;
  v3 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL;
  if (!(v1 | *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL))
    return 0x8000000000000000;
  if (v1)
    return v1 - 1023;
  if (!v3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  return -1011 - __clz(v3);
}

BOOL Double.isZero.getter(double a1)
{
  return (*(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0;
}

double Double.significand.getter(double result)
{
  uint64_t v1;
  unint64_t v2;

  v1 = (*(_QWORD *)&result >> 52) & 0x7FFLL;
  v2 = *(_QWORD *)&result & 0xFFFFFFFFFFFFFLL;
  if ((*(_QWORD *)&result & 0xFFFFFFFFFFFFFLL) == 0 || v1 != 2047)
  {
    if (v1)
    {
      if (v1 != 2047)
      {
        *(_QWORD *)&result = v2 | 0x3FF0000000000000;
        return result;
      }
    }
    else if (v2)
    {
      *(_QWORD *)&result = (*(_QWORD *)&result << (__clz(v2) + 53)) & 0xFFFFFFFFFFFFFLL | 0x3FF0000000000000;
      return result;
    }
    *(_QWORD *)&result = v1 << 52;
  }
  return result;
}

BOOL Double.isSubnormal.getter(double a1)
{
  return (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && (*(_QWORD *)&a1 & 0x7FF0000000000000) == 0;
}

Swift::Double __swiftcall Double.init(sign:exponent:significand:)(Swift::FloatingPointSign sign, Swift::Int exponent, Swift::Double significand)
{
  return specialized Double.init(sign:exponent:significand:)(sign & 1, exponent, significand);
}

double static Double.- prefix(_:)(double a1)
{
  return -a1;
}

double static Double.*= infix(_:_:)(double *a1, double a2)
{
  double result;

  result = *a1 * a2;
  *a1 = result;
  return result;
}

double Double.nextUp.getter(double a1)
{
  double result;

  result = a1 + 0.0;
  if (result < INFINITY)
    *(_QWORD *)&result += (*(uint64_t *)&result >> 63) | 1;
  return result;
}

double static Double.+ infix(_:_:)(double a1, double a2)
{
  return a1 + a2;
}

uint64_t static Int64.| infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 | a1;
}

Swift::Double __swiftcall Double.init(signOf:magnitudeOf:)(Swift::Double signOf, Swift::Double magnitudeOf)
{
  float64x2_t v2;
  Swift::Double result;

  v2.f64[0] = NAN;
  v2.f64[1] = NAN;
  *(_QWORD *)&result = vbslq_s8((int8x16_t)vnegq_f64(v2), *(int8x16_t *)&magnitudeOf, *(int8x16_t *)&signOf).u64[0];
  return result;
}

Swift::Void __swiftcall Double.round(_:)(Swift::FloatingPointRoundingRule a1)
{
  double *v1;
  double v2;

  switch(*(_BYTE *)a1)
  {
    case 0:
      *v1 = round(*v1);
      return;
    case 1:
      *v1 = rint(*v1);
      return;
    case 2:
      v2 = *v1;
      goto LABEL_9;
    case 3:
      v2 = *v1;
      goto LABEL_10;
    case 4:
      *v1 = trunc(*v1);
      return;
    case 5:
      v2 = *v1;
      if ((*(_QWORD *)v1 & 0x8000000000000000) != 0)
LABEL_10:
        *v1 = floor(v2);
      else
LABEL_9:
        *v1 = ceil(v2);
      break;
    default:
      Double._roundSlowPath(_:)(a1);
      break;
  }
}

Swift::Void __swiftcall Double._roundSlowPath(_:)(Swift::FloatingPointRoundingRule a1)
{
  double *v1;
  double v2;
  double v3;
  char v4;

  v4 = *(_BYTE *)a1;
  switch(v4)
  {
    case 0:
      v2 = round(*v1);
      goto LABEL_11;
    case 1:
      v2 = rint(*v1);
      goto LABEL_11;
    case 2:
      v3 = *v1;
      goto LABEL_9;
    case 3:
      v3 = *v1;
      goto LABEL_10;
    case 4:
      v2 = trunc(*v1);
      goto LABEL_11;
    case 5:
      v3 = *v1;
      if ((*(_QWORD *)v1 & 0x8000000000000000) != 0)
LABEL_10:
        v2 = floor(v3);
      else
LABEL_9:
        v2 = ceil(v3);
LABEL_11:
      *v1 = v2;
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)&v4);
      break;
  }
}

Swift::Void __swiftcall Double.negate()()
{
  double *v0;

  *v0 = -*v0;
}

double static Double.+= infix(_:_:)(double *a1, double a2)
{
  double result;

  result = *a1 + a2;
  *a1 = result;
  return result;
}

double static Double.-= infix(_:_:)(double *a1, double a2)
{
  double result;

  result = *a1 - a2;
  *a1 = result;
  return result;
}

double static Double./= infix(_:_:)(double *a1, double a2)
{
  double result;

  result = *a1 / a2;
  *a1 = result;
  return result;
}

Swift::Void __swiftcall Double.formRemainder(dividingBy:)(Swift::Double dividingBy)
{
  long double *v1;

  *v1 = remainder(*v1, dividingBy);
}

Swift::Void __swiftcall Double.formTruncatingRemainder(dividingBy:)(Swift::Double dividingBy)
{
  long double *v1;

  *v1 = fmod(*v1, dividingBy);
}

Swift::Void __swiftcall Double.formSquareRoot()()
{
  double *v0;

  *v0 = sqrt(*v0);
}

Swift::Void __swiftcall Double.addProduct(_:_:)(Swift::Double a1, Swift::Double a2)
{
  double *v2;

  *v2 = *v2 + a1 * a2;
}

Swift::Bool __swiftcall Double.isEqual(to:)(Swift::Double to)
{
  double v1;

  return v1 == to;
}

Swift::Bool __swiftcall Double.isLess(than:)(Swift::Double than)
{
  double v1;

  return v1 < than;
}

Swift::Bool __swiftcall Double.isLessThanOrEqualTo(_:)(Swift::Double a1)
{
  double v1;

  return v1 <= a1;
}

BOOL Double.isInfinite.getter(double a1)
{
  return (*(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FF0000000000000;
}

BOOL Double.isSignalingNaN.getter(double a1)
{
  return (~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0
      && (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL) != 0
      && (*(_QWORD *)&a1 & 0x8000000000000) == 0;
}

double Double.binade.getter(double a1)
{
  uint64_t v1;
  double result;

  v1 = (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
  if (v1 == 2047)
    return NAN;
  if ((*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL) != 0 && !v1)
    return COERCE_DOUBLE(COERCE_UNSIGNED_INT64(a1 * 4.50359963e15) & 0xFFF0000000000000) * 2.22044605e-16;
  *(_QWORD *)&result = *(_QWORD *)&a1 & 0xFFF0000000000000;
  return result;
}

uint64_t Double.significandWidth.getter(double a1)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v6;

  v1 = *(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL;
  v2 = __clz(__rbit64(*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFLL));
  v3 = (*(_QWORD *)&a1 >> 52) & 0x7FFLL;
  if (v3 && v3 != 2047)
  {
    v6 = 52 - v2;
    if (v1)
      return v6;
    else
      return 0;
  }
  else
  {
    v4 = 63 - (__clz(v1) + v2);
    if (v3)
      v4 = -1;
    if (v1)
      return v4;
    else
      return -1;
  }
}

void protocol witness for BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:) in conformance Double(char a1@<W0>, _QWORD *a2@<X1>, uint64_t *a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized Double.init(sign:exponentBitPattern:significandBitPattern:)(a1 & 1, *a2, *a3);
}

double protocol witness for BinaryFloatingPoint.init(_:) in conformance Double@<D0>(double *a1@<X8>, float a2@<S0>)
{
  double result;

  result = a2;
  *a1 = result;
  return result;
}

void protocol witness for BinaryFloatingPoint.init(_:) in conformance Double(double *a1@<X8>, double a2@<D0>)
{
  *a1 = a2;
}

void protocol witness for BinaryFloatingPoint.init<A>(_:) in conformance Double(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized BinaryFloatingPoint.init<A>(_:)(a1, a2, a3);
}

unint64_t protocol witness for BinaryFloatingPoint.init<A>(exactly:) in conformance Double@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result;
  char v6;

  result = specialized BinaryFloatingPoint.init<A>(exactly:)(a1, a2, a3);
  *(_QWORD *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

uint64_t protocol witness for static BinaryFloatingPoint.exponentBitCount.getter in conformance Double()
{
  return 11;
}

uint64_t protocol witness for static BinaryFloatingPoint.significandBitCount.getter in conformance Double()
{
  return 52;
}

void protocol witness for BinaryFloatingPoint.exponentBitPattern.getter in conformance Double(uint64_t *a1@<X8>)
{
  _QWORD *v1;

  *a1 = (*v1 >> 52) & 0x7FFLL;
}

void protocol witness for BinaryFloatingPoint.significandBitPattern.getter in conformance Double(uint64_t *a1@<X8>)
{
  _QWORD *v1;

  *a1 = *v1 & 0xFFFFFFFFFFFFFLL;
}

void protocol witness for BinaryFloatingPoint.binade.getter in conformance Double(double *a1@<X8>)
{
  double *v1;

  *a1 = Double.binade.getter(*v1);
}

uint64_t protocol witness for BinaryFloatingPoint.significandWidth.getter in conformance Double()
{
  double *v0;

  return Double.significandWidth.getter(*v0);
}

void protocol witness for FloatingPoint.init(sign:exponent:significand:) in conformance Double(char a1@<W0>, uint64_t *a2@<X1>, double *a3@<X2>, double *a4@<X8>)
{
  *a4 = specialized Double.init(sign:exponent:significand:)(a1 & 1, *a2, *a3);
}

double protocol witness for FloatingPoint.init(signOf:magnitudeOf:) in conformance Double@<D0>(unint64_t *a1@<X0>, unint64_t *a2@<X1>, _QWORD *a3@<X8>, int8x16_t a4@<Q0>, int8x16_t a5@<Q1>)
{
  float64x2_t v5;

  a4.i64[0] = *a1;
  a5.i64[0] = *a2;
  v5.f64[0] = NAN;
  v5.f64[1] = NAN;
  a4.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v5), a5, a4).u64[0];
  *a3 = a4.i64[0];
  return *(double *)a4.i64;
}

double protocol witness for FloatingPoint.init(_:) in conformance Double@<D0>(uint64_t a1@<X0>, double *a2@<X8>)
{
  double result;

  result = (double)a1;
  *a2 = (double)a1;
  return result;
}

uint64_t protocol witness for FloatingPoint.init<A>(_:) in conformance Double@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (**a3)(_QWORD, _QWORD)@<X2>, double *a4@<X8>)
{
  uint64_t result;
  double v9;
  char v10;
  uint64_t v11;
  double v12;

  if (a3[16](a2, a3) < 65)
  {
    v10 = a3[8](a2, a3);
    v11 = a3[15](a2, a3);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    if ((v10 & 1) != 0)
      v9 = (double)v11;
    else
      v9 = (double)(unint64_t)v11;
  }
  else
  {
    specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v12, a1, a2, (uint64_t)a3);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
    v9 = v12;
  }
  *a4 = v9;
  return result;
}

unint64_t protocol witness for FloatingPoint.init<A>(exactly:) in conformance Double@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result;
  char v6;

  result = Double.init<A>(exactly:)(a1, a2, a3);
  *(_QWORD *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

unint64_t Double.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  double v12;
  char v13;
  uint64_t v14;
  void (*v15)(char *, uint64_t);
  double v16;
  double v17;
  uint64_t v19;
  double v20;

  v6 = *(_QWORD *)(a2 - 8);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(uint64_t (**)(uint64_t, uint64_t))(v9 + 128))(v10, v9) > 64)
  {
    v11 = specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v20, a1, a2, a3);
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, a2);
    if ((v11 & 1) != 0)
    {
      v12 = v20;
      return *(_QWORD *)&v12;
    }
LABEL_15:
    v12 = 0.0;
    return *(_QWORD *)&v12;
  }
  v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 64))(a2, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, a2);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v15 = *(void (**)(char *, uint64_t))(v6 + 8);
  v15(v8, a2);
  if ((v13 & 1) == 0)
  {
    v17 = (double)(unint64_t)v14;
    if ((double)(unint64_t)v14 < 1.84467441e19)
    {
      v12 = (double)(unint64_t)v14;
      if ((~*(_QWORD *)&v17 & 0x7FF0000000000000) == 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3129uLL, 0);
      v15((char *)a1, a2);
      if (v14 != (unint64_t)v17)
        goto LABEL_15;
      return *(_QWORD *)&v12;
    }
LABEL_14:
    v15((char *)a1, a2);
    goto LABEL_15;
  }
  v16 = (double)v14;
  if ((double)v14 >= 9.22337204e18)
    goto LABEL_14;
  v12 = (double)v14;
  if ((~*(_QWORD *)&v16 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v16 <= -9.22337204e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  v15((char *)a1, a2);
  if (v14 != (uint64_t)v16)
    goto LABEL_15;
  return *(_QWORD *)&v12;
}

void protocol witness for static FloatingPoint.nan.getter in conformance Double(_QWORD *a1@<X8>)
{
  *a1 = 0x7FF8000000000000;
}

void protocol witness for static FloatingPoint.signalingNaN.getter in conformance Double(_QWORD *a1@<X8>)
{
  *a1 = 0x7FF4000000000000;
}

void protocol witness for static FloatingPoint.infinity.getter in conformance Double(_QWORD *a1@<X8>)
{
  *a1 = 0x7FF0000000000000;
}

void protocol witness for static FloatingPoint.greatestFiniteMagnitude.getter in conformance Double(_QWORD *a1@<X8>)
{
  *a1 = 0x7FEFFFFFFFFFFFFFLL;
}

void protocol witness for static FloatingPoint.pi.getter in conformance Double(_QWORD *a1@<X8>)
{
  *a1 = 0x400921FB54442D18;
}

double protocol witness for FloatingPoint.ulp.getter in conformance Double@<D0>(double *a1@<X8>)
{
  _QWORD *v1;
  uint64_t v2;
  double result;
  double v4;

  v2 = (*v1 >> 52) & 0x7FFLL;
  if (v2)
  {
    if (v2 != 2047)
    {
      result = COERCE_DOUBLE(*v1 & 0x7FF0000000000000) * 2.22044605e-16;
      *a1 = result;
      return result;
    }
    v4 = NAN;
  }
  else
  {
    *(_QWORD *)&v4 = 1;
  }
  result = v4;
  *a1 = v4;
  return result;
}

void protocol witness for static FloatingPoint.ulpOfOne.getter in conformance Double(_QWORD *a1@<X8>)
{
  *a1 = 0x3CB0000000000000;
}

void protocol witness for static FloatingPoint.leastNormalMagnitude.getter in conformance Double(_QWORD *a1@<X8>)
{
  *a1 = 0x10000000000000;
}

uint64_t protocol witness for FloatingPoint.sign.getter in conformance Double()
{
  double *v0;

  return Double.sign.getter(*v0);
}

unint64_t protocol witness for FloatingPoint.exponent.getter in conformance Double@<X0>(unint64_t *a1@<X8>)
{
  double *v1;
  unint64_t result;

  result = Double.exponent.getter(*v1);
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.significand.getter in conformance Double(double *a1@<X8>)
{
  double *v1;

  *a1 = Double.significand.getter(*v1);
}

double protocol witness for static FloatingPoint./ infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *a1 / *a2;
  *a3 = result;
  return result;
}

double protocol witness for static FloatingPoint./= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result;

  result = *a1 / *a2;
  *a1 = result;
  return result;
}

void protocol witness for FloatingPoint.remainder(dividingBy:) in conformance Double(long double *a1@<X0>, long double *a2@<X8>)
{
  long double *v2;

  *a2 = _stdlib_remainder(*v2, *a1);
}

void protocol witness for FloatingPoint.formRemainder(dividingBy:) in conformance Double(long double *a1)
{
  long double *v1;

  *v1 = _stdlib_remainder(*v1, *a1);
}

void protocol witness for FloatingPoint.truncatingRemainder(dividingBy:) in conformance Double(long double *a1@<X0>, long double *a2@<X8>)
{
  long double *v2;

  *a2 = fmod(*v2, *a1);
}

void protocol witness for FloatingPoint.formTruncatingRemainder(dividingBy:) in conformance Double(long double *a1)
{
  long double *v1;

  *v1 = fmod(*v1, *a1);
}

void protocol witness for FloatingPoint.squareRoot() in conformance Double(double *a1@<X8>)
{
  double *v1;

  *a1 = _stdlib_squareRoot(*v1);
}

void protocol witness for FloatingPoint.formSquareRoot() in conformance Double()
{
  double *v0;

  *v0 = _stdlib_squareRoot(*v0);
}

double protocol witness for FloatingPoint.addingProduct(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double *v3;
  double result;

  result = *v3 + *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for FloatingPoint.addProduct(_:_:) in conformance Double(double *a1, double *a2)
{
  double *v2;
  double result;

  result = *v2 + *a1 * *a2;
  *v2 = result;
  return result;
}

double *protocol witness for static FloatingPoint.minimum(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3;
  double v4;

  v3 = *result;
  v4 = *a2;
  if (*result > *a2)
  {
    if ((*(_QWORD *)&v4 & 0xFFFFFFFFFFFFFLL) == 0)
      v3 = *a2;
    if ((~*(_QWORD *)&v4 & 0x7FF0000000000000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximum(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3;
  double v4;

  v3 = *result;
  v4 = *a2;
  if (*a2 >= *result)
  {
    if ((*(_QWORD *)&v4 & 0xFFFFFFFFFFFFFLL) == 0)
      v3 = *a2;
    if ((~*(_QWORD *)&v4 & 0x7FF0000000000000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.minimumMagnitude(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3;
  double v4;

  v3 = *result;
  v4 = *a2;
  if (fabs(*result) > fabs(*a2))
  {
    if ((*(_QWORD *)&v4 & 0xFFFFFFFFFFFFFLL) == 0)
      v3 = *a2;
    if ((~*(_QWORD *)&v4 & 0x7FF0000000000000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

double *protocol witness for static FloatingPoint.maximumMagnitude(_:_:) in conformance Double@<X0>(double *result@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3;
  double v4;

  v3 = *result;
  v4 = *a2;
  if (fabs(*a2) >= fabs(*result))
  {
    if ((*(_QWORD *)&v4 & 0xFFFFFFFFFFFFFLL) == 0)
      v3 = *a2;
    if ((~*(_QWORD *)&v4 & 0x7FF0000000000000) != 0)
      v3 = *a2;
  }
  *a3 = v3;
  return result;
}

void protocol witness for FloatingPoint.rounded(_:) in conformance Double(_BYTE *a1@<X0>, double *a2@<X8>)
{
  double *v2;
  double v4;
  double v5;
  char v6;
  double v7;
  double v8;

  v4 = *v2;
  v8 = *v2;
  switch(*a1)
  {
    case 0:
      v5 = round(v4);
      break;
    case 1:
      v5 = rint(v4);
      break;
    case 2:
      v5 = ceil(v4);
      break;
    case 3:
      v5 = floor(v4);
      break;
    case 4:
      v5 = trunc(v4);
      break;
    case 5:
      v6 = Double.sign.getter(v4);
      v5 = ceil(v4);
      v7 = floor(v4);
      if (v6)
        v5 = v7;
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      v5 = v8;
      break;
  }
  *a2 = v5;
}

void protocol witness for FloatingPoint.round(_:) in conformance Double(_BYTE *a1)
{
  double *v1;
  double v2;
  double v3;

  switch(*a1)
  {
    case 0:
      v2 = round(*v1);
      goto LABEL_11;
    case 1:
      v2 = rint(*v1);
      goto LABEL_11;
    case 2:
      v2 = ceil(*v1);
      goto LABEL_11;
    case 3:
      v2 = floor(*v1);
      goto LABEL_11;
    case 4:
      v2 = trunc(*v1);
      goto LABEL_11;
    case 5:
      v3 = *v1;
      if (Double.sign.getter(*v1))
        v2 = floor(v3);
      else
        v2 = ceil(v3);
LABEL_11:
      *v1 = v2;
      break;
    default:
      Double._roundSlowPath(_:)((Swift::FloatingPointRoundingRule)a1);
      break;
  }
}

void protocol witness for FloatingPoint.nextUp.getter in conformance Double(double *a1@<X8>)
{
  double *v1;
  double v2;

  v2 = *v1 + 0.0;
  if (v2 < INFINITY)
    *(_QWORD *)&v2 += (*(uint64_t *)&v2 >> 63) | 1;
  *a1 = v2;
}

double protocol witness for FloatingPoint.nextDown.getter in conformance Double@<D0>(double *a1@<X8>)
{
  double *v1;
  double v2;
  double result;

  v2 = 0.0 - *v1;
  if (v2 < INFINITY)
    *(_QWORD *)&v2 += (*(uint64_t *)&v2 >> 63) | 1;
  result = -v2;
  *a1 = result;
  return result;
}

BOOL protocol witness for FloatingPoint.isEqual(to:) in conformance Double(double *a1)
{
  double *v1;

  return *v1 == *a1;
}

BOOL protocol witness for FloatingPoint.isLess(than:) in conformance Double(double *a1)
{
  double *v1;

  return *v1 < *a1;
}

BOOL protocol witness for FloatingPoint.isLessThanOrEqualTo(_:) in conformance Double(double *a1)
{
  double *v1;

  return *v1 <= *a1;
}

uint64_t protocol witness for FloatingPoint.isTotallyOrdered(belowOrEqualTo:) in conformance Double(double *a1)
{
  double *v1;

  return specialized BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:)(*a1, *v1);
}

BOOL protocol witness for FloatingPoint.isNormal.getter in conformance Double()
{
  _QWORD *v0;

  return ((*v0 >> 52) & 0x7FFLL) != 0x7FF && ((*v0 >> 52) & 0x7FFLL) != 0;
}

BOOL protocol witness for FloatingPoint.isFinite.getter in conformance Double()
{
  _QWORD *v0;

  return (~*v0 & 0x7FF0000000000000) != 0;
}

BOOL protocol witness for FloatingPoint.isZero.getter in conformance Double()
{
  _QWORD *v0;

  return (*v0 & 0x7FFFFFFFFFFFFFFFLL) == 0;
}

BOOL protocol witness for FloatingPoint.isSubnormal.getter in conformance Double()
{
  _QWORD *v0;

  return (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (*v0 & 0x7FF0000000000000) == 0;
}

BOOL protocol witness for FloatingPoint.isInfinite.getter in conformance Double()
{
  _QWORD *v0;

  return (*v0 & 0x7FFFFFFFFFFFFFFFLL) == 0x7FF0000000000000;
}

BOOL protocol witness for FloatingPoint.isNaN.getter in conformance Double()
{
  _QWORD *v0;

  return (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (~*v0 & 0x7FF0000000000000) == 0;
}

BOOL protocol witness for FloatingPoint.isSignalingNaN.getter in conformance Double()
{
  _QWORD *v0;

  return (~*v0 & 0x7FF0000000000000) == 0 && (*v0 & 0xFFFFFFFFFFFFFLL) != 0 && (*v0 & 0x8000000000000) == 0;
}

uint64_t protocol witness for FloatingPoint.floatingPointClass.getter in conformance Double()
{
  double *v0;

  return specialized FloatingPoint.floatingPointClass.getter(*v0);
}

double protocol witness for ExpressibleByFloatLiteral.init(floatLiteral:) in conformance Double@<D0>(double *a1@<X0>, _QWORD *a2@<X8>)
{
  double result;

  result = *a1;
  *a2 = *(_QWORD *)a1;
  return result;
}

double protocol witness for static SignedNumeric.- prefix(_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double result;

  result = -*a1;
  *a2 = result;
  return result;
}

double protocol witness for SignedNumeric.negate() in conformance Double()
{
  double *v0;
  double result;

  result = -*v0;
  *v0 = result;
  return result;
}

double protocol witness for Numeric.magnitude.getter in conformance Double@<D0>(double *a1@<X8>)
{
  double *v1;
  double result;

  result = fabs(*v1);
  *a1 = result;
  return result;
}

double Double.magnitude.getter(double a1)
{
  return fabs(a1);
}

double protocol witness for static Numeric.* infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *a1 * *a2;
  *a3 = result;
  return result;
}

double protocol witness for static Numeric.*= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result;

  result = *a2 * *a1;
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *a1 + *a2;
  *a3 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result;

  result = *a2 + *a1;
  *a1 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *a1 - *a2;
  *a3 = result;
  return result;
}

double protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  double result;

  result = *a1 - *a2;
  *a1 = result;
  return result;
}

Swift::Double __swiftcall Double.init(integerLiteral:)(Swift::Int64 integerLiteral)
{
  return (double)integerLiteral;
}

void protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Double(uint64_t *a1@<X0>, unint64_t a2@<X1>, double *a3@<X8>)
{
  *a3 = swift_intToFloat64(a1, a2);
}

double protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance Double@<D0>(uint64_t *a1@<X0>, double *a2@<X8>)
{
  double result;

  result = (double)*a1;
  *a2 = result;
  return result;
}

void Double.hash(into:)(double a1)
{
  Swift::UInt64 v1;

  if ((*(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v1 = *(_QWORD *)&a1;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
}

Swift::Int __swiftcall Double._rawHashValue(seed:)(Swift::Int seed)
{
  uint64_t v1;
  uint64_t v2;

  if ((v1 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v2 = v1;
  else
    v2 = 0;
  return specialized static Hasher._hash(seed:_:)(seed, v2);
}

uint64_t Double.hashValue.getter(double a1)
{
  uint64_t v1;

  if ((*(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v1 = *(_QWORD *)&a1;
  else
    v1 = 0;
  return specialized static Hasher._hash(seed:_:)(0, v1);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance Double()
{
  uint64_t *v0;
  uint64_t v1;

  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v1 = *v0;
  else
    v1 = 0;
  return specialized static Hasher._hash(seed:_:)(0, v1);
}

void protocol witness for Hashable.hash(into:) in conformance Double()
{
  Swift::UInt64 *v0;
  Swift::UInt64 v1;

  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v1 = *v0;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Double(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;

  if ((*v1 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v2 = *v1;
  else
    v2 = 0;
  return specialized static Hasher._hash(seed:_:)(a1, v2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 == *a2;
}

void Double._toCustomAnyHashable()(uint64_t a1@<X8>, double a2@<D0>)
{
  *(_QWORD *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
  *(double *)a1 = a2;
}

double protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Double@<D0>(uint64_t a1@<X8>)
{
  double *v1;
  double result;

  result = *v1;
  *(_QWORD *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
  *(double *)a1 = result;
  return result;
}

Swift::UInt __swiftcall UInt.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3129uLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because the result would be less than UInt.min", 87, 2, "Swift/IntegerTypes.swift", 24, 2, 0x312CuLL, 0);
  if (a1 >= 1.84467441e19)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt because the result would be greater than UInt.max", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x312FuLL, 0);
  return (unint64_t)a1;
}

uint64_t Double.init(exactly:)(__n128 _Q0)
{
  __asm
  {
    FCVT            D1, H0
    FCVT            S0, H0
  }
  return _D1;
}

Swift::Double_optional __swiftcall Double.init(exactly:)(Swift::Double exactly)
{
  char v1;
  Swift::Double_optional result;

  v1 = LOBYTE(exactly);
  result.value = exactly;
  result.is_nil = v1;
  return result;
}

Swift::Double __swiftcall Double.distance(to:)(Swift::Double to)
{
  double v1;

  return to - v1;
}

Swift::Double __swiftcall Double.advanced(by:)(Swift::Double by)
{
  double v1;

  return by + v1;
}

double protocol witness for Strideable.distance(to:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double *v2;
  double result;

  result = *a1 - *v2;
  *a2 = result;
  return result;
}

double protocol witness for Strideable.advanced(by:) in conformance Double@<D0>(double *a1@<X0>, double *a2@<X8>)
{
  double *v2;
  double result;

  result = *a1 + *v2;
  *a2 = result;
  return result;
}

double *protocol witness for static Strideable._step(after:from:by:) in conformance Double(double *result, uint64_t a2, char a3, double *a4, double *a5, double *a6)
{
  double v6;
  double v8;

  v6 = *a6;
  if ((a3 & 1) != 0)
  {
    v8 = v6 + *a4;
    goto LABEL_5;
  }
  if (!__OFADD__(a2++, 1))
  {
    v8 = *a5 + (double)a2 * v6;
LABEL_5:
    *result = v8;
    return (double *)a2;
  }
  __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a1 <= *a2;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a2 <= *a1;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Double(double *a1, double *a2)
{
  return *a2 < *a1;
}

void _DoubleAnyHashableBox._canonicalBox.getter(uint64_t a1@<X8>, double a2@<D0>)
{
  double v3;
  uint64_t v6;
  uint64_t *v7;

  v3 = trunc(a2);
  if (a2 >= 0.0)
  {
    if (a2 <= -1.0 || a2 >= 1.84467441e19 || v3 != a2)
      goto LABEL_18;
    v6 = (unint64_t)a2;
    v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
  }
  else
  {
    if (a2 <= -9.22337204e18 || a2 >= 9.22337204e18 || v3 != a2)
    {
LABEL_18:
      *(_QWORD *)(a1 + 24) = &type metadata for _DoubleAnyHashableBox;
      *(_QWORD *)(a1 + 32) = &protocol witness table for _DoubleAnyHashableBox;
      *(double *)a1 = a2;
      return;
    }
    v6 = (uint64_t)a2;
    v7 = (uint64_t *)&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  }
  *(_QWORD *)(a1 + 24) = __swift_instantiateConcreteTypeFromMangledName(v7);
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_QWORD *)a1 = v6;
}

uint64_t _DoubleAnyHashableBox._unbox<A>()@<X0>(Class *a1@<X0>, char *a2@<X8>, double a3@<D0>)
{
  int v5;
  double v7;

  v7 = a3;
  v5 = swift_dynamicCast(a2, (uint64_t *)&v7, (Class *)&type metadata for Double, a1, 6uLL);
  return (*((uint64_t (**)(char *, _QWORD, uint64_t, Class *))*(a1 - 1) + 7))(a2, v5 ^ 1u, 1, a1);
}

uint64_t _DoubleAnyHashableBox._downCastConditional<A>(into:)(char *a1, Class *a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  void (*v17)(char *, uint64_t, uint64_t, Class *);
  void (*v18)(char *, char *, Class *);
  uint64_t v20;
  double v21;

  v8 = type metadata accessor for Optional(0, (uint64_t)a2, a3, a4);
  v9 = *(_QWORD *)(v8 - 8);
  v10 = MEMORY[0x1E0C80A78](v8);
  v12 = (char *)&v20 - v11;
  v13 = (uint64_t)*(a2 - 1);
  MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v20 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = a5;
  v16 = swift_dynamicCast(v12, (uint64_t *)&v21, (Class *)&type metadata for Double, a2, 6uLL);
  v17 = *(void (**)(char *, uint64_t, uint64_t, Class *))(v13 + 56);
  if ((_DWORD)v16)
  {
    v17(v12, 0, 1, a2);
    v18 = *(void (**)(char *, char *, Class *))(v13 + 32);
    v18(v15, v12, a2);
    v18(a1, v15, a2);
  }
  else
  {
    v17(v12, 1, 1, a2);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v12, v8);
  }
  return v16;
}

void protocol witness for _AnyHashableBox._canonicalBox.getter in conformance _DoubleAnyHashableBox(uint64_t a1@<X8>)
{
  double *v1;

  _DoubleAnyHashableBox._canonicalBox.getter(a1, *v1);
}

uint64_t protocol witness for _AnyHashableBox._isEqual(to:) in conformance _DoubleAnyHashableBox(uint64_t a1, Class *a2)
{
  double *v2;
  double v4;
  Class *v5;
  double v7;
  uint64_t v8[5];

  v4 = *v2;
  outlined init with copy of MirrorPath(a1, (uint64_t)v8);
  v5 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  if (swift_dynamicCast((char *)&v7, v8, v5, a2, 6uLL))
    return v4 == v7;
  else
    return 2;
}

Swift::Int protocol witness for _AnyHashableBox._hashValue.getter in conformance _DoubleAnyHashableBox()
{
  Swift::UInt64 *v0;
  Swift::UInt64 v1;

  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v1 = *v0;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

Swift::Int protocol witness for _AnyHashableBox._rawHashValue(_seed:) in conformance _DoubleAnyHashableBox()
{
  Swift::UInt64 *v0;
  Swift::UInt64 v1;

  if ((*v0 & 0x7FFFFFFFFFFFFFFFLL) != 0)
    v1 = *v0;
  else
    v1 = 0;
  Hasher._combine(_:)(v1);
  return Hasher.finalize()();
}

double protocol witness for _AnyHashableBox._base.getter in conformance _DoubleAnyHashableBox@<D0>(uint64_t a1@<X8>)
{
  double *v1;
  double result;

  result = *v1;
  *(_QWORD *)(a1 + 24) = &type metadata for Double;
  *(double *)a1 = result;
  return result;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _DoubleAnyHashableBox@<X0>(Class *a1@<X0>, char *a2@<X8>)
{
  double *v2;

  return _DoubleAnyHashableBox._unbox<A>()(a1, a2, *v2);
}

uint64_t protocol witness for _AnyHashableBox._downCastConditional<A>(into:) in conformance _DoubleAnyHashableBox(char *a1, Class *a2, uint64_t a3, uint64_t a4)
{
  double *v4;

  return _DoubleAnyHashableBox._downCastConditional<A>(into:)(a1, a2, a3, a4, *v4);
}

void __swiftcall Float80.init()()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000018, 0x8000000181764390, "Swift/FloatingPointTypes.swift", 30, 2, 0x12E6uLL, 0);
}

void % infix<A>(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000013, 0x80000001817643B0, "Swift/FloatingPointTypes.swift", 30, 2, 0x12F3uLL, 0);
}

void %= infix<A>(_:_:)()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000014, 0x80000001817643D0, "Swift/FloatingPointTypes.swift", 30, 2, 0x12FAuLL, 0);
}

uint64_t UInt8._value.setter(uint64_t result)
{
  _BYTE *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt8._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt8 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x58uLL, 0);
  __asm { FCVT            S0, H0 }
  if (_S0 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt8 because the result would be less than UInt8.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x5BuLL, 0);
  if (_S0 >= 256.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt8 because the result would be greater than UInt8.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x5EuLL, 0);
  return (int)_S0;
}

uint64_t UInt8.init(exactly:)(__n128 _Q0)
{
  BOOL v6;
  int v9;
  char v10;
  int v11;

  __asm { FCVT            S0, H0 }
  v6 = _S0 > -1.0;
  if (_S0 >= 256.0)
    v6 = 0;
  _S1 = truncf(_S0);
  __asm
  {
    FCVT            H1, S1
    FCVT            S1, H1
  }
  v9 = v6 && _S1 == _S0;
  _ZF = v9 == 0;
  v10 = ~(_BYTE)v9;
  if (_ZF)
    v11 = 0;
  else
    v11 = (int)_S0;
  return v11 & 0xFFFFFEFF | ((v10 & 1) << 8);
}

Swift::UInt8 __swiftcall UInt8.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt8 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA4uLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt8 because the result would be less than UInt8.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA7uLL, 0);
  if (a1 >= 256.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt8 because the result would be greater than UInt8.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0xAAuLL, 0);
  return (int)a1;
}

Swift::UInt8_optional __swiftcall UInt8.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  int v5;

  v1 = exactly > -1.0;
  if (exactly >= 256.0)
    v1 = 0;
  v3 = v1 & (truncf(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    LOWORD(v5) = 0;
  else
    v5 = (int)exactly;
  return (Swift::UInt8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

Swift::UInt8 __swiftcall UInt8.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt8 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0xECuLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt8 because the result would be less than UInt8.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEFuLL, 0);
  if (a1 >= 256.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt8 because the result would be greater than UInt8.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0xF2uLL, 0);
  return (int)a1;
}

Swift::UInt8_optional __swiftcall UInt8.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  int v5;

  v1 = exactly > -1.0;
  if (exactly >= 256.0)
    v1 = 0;
  v3 = v1 & (trunc(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    LOWORD(v5) = 0;
  else
    v5 = (int)exactly;
  return (Swift::UInt8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

_BYTE *static UInt8.+= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  unsigned int v2;

  v2 = *result + a2;
  if (((v2 >> 8) & 1) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

_BYTE *static UInt8.-= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  int v2;

  v2 = *result - a2;
  if ((v2 & 0xFFFFFF00) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

_BYTE *static UInt8.*= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  if (((*result * (unsigned __int16)a2) & 0xFF00) != 0)
    __break(1u);
  else
    *result *= a2;
  return result;
}

_BYTE *static UInt8./= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.addingReportingOverflow(_:)(Swift::UInt8 a1)
{
  Swift::Bool v1;
  Swift::UInt8 v2;
  Swift::tuple_partialValue_UInt8_overflow_Bool result;

  v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.subtractingReportingOverflow(_:)(Swift::UInt8 a1)
{
  Swift::Bool v1;
  Swift::UInt8 v2;
  Swift::tuple_partialValue_UInt8_overflow_Bool result;

  v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.multipliedReportingOverflow(by:)(Swift::UInt8 by)
{
  Swift::Bool v1;
  Swift::UInt8 v2;
  Swift::tuple_partialValue_UInt8_overflow_Bool result;

  v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.dividedReportingOverflow(by:)(Swift::UInt8 by)
{
  unsigned __int8 v1;
  Swift::UInt8 v2;
  Swift::tuple_partialValue_UInt8_overflow_Bool result;

  if (by)
    v1 /= by;
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt8_overflow_Bool __swiftcall UInt8.remainderReportingOverflow(dividingBy:)(Swift::UInt8 dividingBy)
{
  unsigned __int8 v1;
  Swift::UInt8 v2;
  Swift::tuple_partialValue_UInt8_overflow_Bool result;

  if (dividingBy)
    v1 %= dividingBy;
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

_BYTE *static UInt8.%= infix(_:_:)(_BYTE *result, unsigned __int8 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  *result %= a2;
  return result;
}

_BYTE *static UInt8.&>>= infix(_:_:)(_BYTE *result, char a2)
{
  *result = *result >> (a2 & 7);
  return result;
}

uint64_t UInt8._lowWord.getter(uint64_t result)
{
  return result;
}

uint64_t UInt8.Words._value.setter(uint64_t result)
{
  _BYTE *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt8.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.Words.count.getter()
{
  return 1;
}

uint64_t UInt8.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt8.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt8.Words.indices.getter()
{
  return 0;
}

uint64_t UInt8.Words.subscript.getter(uint64_t a1, unsigned __int8 a2)
{
  if (a1 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3B1uLL, 0);
  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3B2uLL, 0);
  return a2;
}

unint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt8.Words@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t result;
  char v6;

  result = specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(*a1, a2, *a3);
  *(_QWORD *)a4 = result;
  *(_BYTE *)(a4 + 8) = v6 & 1;
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt8.Words(uint64_t *a1, uint64_t *a2))()
{
  unsigned __int8 *v2;

  *a1 = UInt8.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

double protocol witness for Collection.indices.getter in conformance UInt8.Words@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = xmmword_1816ABBD0;
  return result;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance UInt8.Words()
{
  unsigned __int8 *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt8.Words(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unsigned __int8 *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt8_low_UInt8 __swiftcall UInt8.multipliedFullWidth(by:)(Swift::UInt8 by)
{
  Swift::UInt8 v1;
  Swift::UInt8 v2;
  Swift::tuple_high_UInt8_low_UInt8 result;

  v2 = __rev16(v1 * by);
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt8_remainder_UInt8 __swiftcall UInt8.dividingFullWidth(_:)(Swift::tuple_high_UInt8_low_UInt8 a1)
{
  unsigned __int8 v1;
  unsigned __int8 v2;
  unsigned __int16 v3;
  unsigned int v4;
  Swift::tuple_quotient_UInt8_remainder_UInt8 result;

  if (!v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x417uLL, 0);
  if (a1.high >= v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x419uLL, 0);
  v3 = a1.low | (unsigned __int16)(__PAIR16__(v2, a1.high) << 8);
  v4 = (v3 / v1) | ((v3 % v1) << 8);
  result.quotient = v4;
  result.remainder = v3;
  return result;
}

Swift::UInt8 __swiftcall UInt8.signum()()
{
  char v0;

  return v0 != 0;
}

uint64_t static UInt8.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt8(_BYTE *a1@<X8>)
{
  *a1 = -1;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt8(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2;
  uint64_t v3;

  v3 = (*v2 + *a2) >> 8;
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt8(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  int v3;

  v3 = *v2 - *a2;
  *a1 = v3;
  return (v3 & 0xFFFFFF00) != 0;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt8(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  __int16 v3;

  v3 = *v2 * *a2;
  *a1 = v3;
  return (v3 & 0xFF00) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt8(_BYTE *a1, _BYTE *a2)
{
  unsigned __int8 *v2;
  unsigned int v3;
  unsigned int v4;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
    v4 /= v3;
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt8(_BYTE *a1, _BYTE *a2)
{
  unsigned __int8 *v2;
  unsigned int v3;
  unsigned int v4;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
    v4 %= v3;
  *a1 = v4;
  return v3 == 0;
}

_BYTE *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt8(_BYTE *result, _BYTE *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  __int16 v4;

  v4 = *v3 * *a3;
  *result = HIBYTE(v4);
  *a2 = v4;
  return result;
}

Swift::UInt8 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt8(Swift::UInt8 *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  Swift::UInt8 result;
  char v7;

  result = UInt8.dividingFullWidth(_:)((Swift::tuple_high_UInt8_low_UInt8)__PAIR16__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

unsigned __int8 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result >> (*a2 & 7);
  return result;
}

_BYTE *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt8(_BYTE *result, _BYTE *a2)
{
  *result = *result >> (*a2 & 7);
  return result;
}

char *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt8@<X0>(char *result@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  char v3;

  v3 = 0;
  if (a2 <= 0x9FF && (a2 & 1) == 0)
    v3 = *result;
  *a3 = v3;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8 and conformance UInt8, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _BYTE *a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  char v23;
  uint64_t v24;
  unint64_t AssociatedConformanceWitness;
  char *v26;
  char v27;
  void (*v28)(char *, uint64_t);
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  void (*v36)(char *, uint64_t);
  unsigned int v37;
  char *v38;
  unsigned __int8 v39;
  char v40;
  unsigned __int8 v41;
  char v42;
  uint64_t result;
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  _BYTE *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  unsigned __int8 v53;

  v46 = a4;
  v47 = a5;
  v49 = a6;
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v48 = (char *)&v44 - v12;
  v52 = *(_QWORD *)(a2 - 8);
  v13 = MEMORY[0x1E0C80A78](v11);
  v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v51 = (char *)&v44 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v44 - v18;
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v44 - v20;
  v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v23 = v22(a2, a3);
  v50 = a1;
  if ((v23 & 1) != 0)
  {
    v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 32))(v21, v19, a2);
    v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    v28(v21, a2);
    a1 = v50;
  }
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v30 = a1;
  if (v29(a2, a3) >= 8)
  {
    v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    v53 = -1;
    v31 = v22(a2, a3);
    v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 9)
      {
        v33 = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 40))(v51, v19, a2);
        v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        v37 = v53;
        v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        v30 = v50;
        if ((v34 & 1) != 0)
        {
          v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39)
            goto LABEL_14;
        }
        else
        {
          v36(v38, a2);
        }
        goto LABEL_16;
      }
    }
    else if (v32 <= 8)
    {
      v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      v30 = v50;
      if (v53 < v41)
        goto LABEL_14;
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }
    (*(void (**)(unsigned __int8 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    v35 = v51;
    v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v19, v51, a2);
    v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    v30 = v50;
    if ((v40 & 1) != 0)
LABEL_14:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    goto LABEL_16;
  }
LABEL_17:
  v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *v49 = v42;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt8@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt8 and conformance UInt8((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt8()
{
  unsigned __int8 *v0;

  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt8()
{
  unsigned __int8 *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_BYTE *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  *a3 = *result / *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt8(_BYTE *result, _BYTE *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  *result /= *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  *a3 = *result % *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt8(_BYTE *result, _BYTE *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2B4uLL, 0);
  *result %= *a2;
  return result;
}

uint64_t static UInt8.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt8@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t v52;
  char *v53;
  void (*v54)(char *, uint64_t);
  unsigned int v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t (*v63)(char *, uint64_t);
  uint64_t v64;
  void (*v65)(char *, uint64_t, uint64_t);
  char *v66;
  char v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char v86;
  void (*v87)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v88;
  char v89;
  void (**v90)(char *, uint64_t, const char *);
  unint64_t v91;
  unint64_t AssociatedConformanceWitness;
  char *v93;
  char *v94;
  char *v95;
  int64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  char *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  int64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t (*v115)(char *, uint64_t);
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  unsigned int v122;
  char *v123;
  char *v124;
  uint64_t (*v125)(uint64_t, uint64_t);
  _BYTE *v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v126 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v114 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v123 = (char *)&v114 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v117 = (char *)&v114 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v114 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v124 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v122 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v121 = v19;
  v127 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v129 = -8;
      v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -8)
        goto LABEL_24;
    }
LABEL_18:
    v56 = v127(a3, a4);
    v57 = v33(a3, a4);
    v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64)
        goto LABEL_20;
    }
    else if (v57 > 63)
    {
LABEL_20:
      v129 = 8;
      v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
      v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v66 = v124;
        v65(v124, a2, a3);
        v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          v71 = v123;
          v70 = v124;
          v68 = v125;
          v79 = v125(a3, a4);
          goto LABEL_47;
        }
        v68 = v125;
        v69 = v125(a3, a4);
        v63(v26, a3);
        v71 = v123;
        v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          v79 = v68(a3, a4);
LABEL_47:
          v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            v109 = v68(a3, a4);
            v63(v71, a3);
            v110 = v109 == 64;
            v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              result = v63(v70, a3);
              if ((v112 & 0x8000000000000000) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFF8)
                {
                  v55 = v122 << -(char)v112;
                  goto LABEL_64;
                }
              }
              else if (v112 < 8)
              {
                v55 = v122 >> v112;
                goto LABEL_64;
              }
              goto LABEL_24;
            }
          }
          else
          {
            v63(v71, a3);
            v100 = v127;
          }
          v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          v129 = 0x7FFFFFFFFFFFFFFFLL;
          v102 = v100(a3, a4);
          v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              v108 = &v129;
              goto LABEL_59;
            }
          }
          else if (v103 > 63)
          {
            v128 = 0x7FFFFFFFFFFFFFFFLL;
            v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v101, a3);
            v63(v30, a3);
            if ((v111 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_60;
          }
          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }
        v115 = v63;
        v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        v129 = 0x8000000000000000;
        v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            v77 = v72;
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129)
LABEL_69:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
            goto LABEL_44;
          }
          v77 = v72;
          v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v77, v30, a3);
        }
        else
        {
          v80 = v73(a3, a4);
          v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            v63 = v115;
            if (v81 > 64)
            {
              v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }
            v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }
          if (v81 <= 64)
          {
            v91 = AssociatedTypeWitness;
            v90 = (void (**)(char *, uint64_t, const char *))v120;
            AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))(&qword_1816B7DA8, 256, v91, AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v117, v30, a3);
            v115(v30, a3);
            v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }
            v96 = v129;
            v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v95, a3);
            v98 = v97 < v96;
            v70 = v124;
            v77 = v117;
            if (v98)
              goto LABEL_69;
LABEL_44:
            v113 = v77;
            goto LABEL_45;
          }
          v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          v77 = v117;
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
        }
        v89 = v86;
        v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0)
          goto LABEL_69;
        goto LABEL_44;
      }
LABEL_24:
      LOBYTE(v55) = 0;
      goto LABEL_64;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v63(v30, a3);
    if (v64 <= 8)
      goto LABEL_25;
    goto LABEL_24;
  }
  v39 = v31(a3, a4);
  v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      v33 = v125;
      goto LABEL_18;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }
  if (v40 > 64)
  {
    v129 = -8;
    v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    v33 = v125;
    if ((v45 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v50 = AssociatedTypeWitness;
  v51 = v120;
  v52 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))(&qword_1816B7DA8, 256, v50, v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
  v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    v33 = v125;
    if (v49 < -8)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  LOBYTE(v55) = 0;
LABEL_64:
  *v126 = v55;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt8(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t (*v39)(uint64_t, uint64_t);
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unsigned int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t AssociatedConformanceWitness;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unsigned int v130;
  char *v131;
  uint64_t (*v132)(uint64_t, uint64_t);
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v144 = -8;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 < -8)
        goto LABEL_24;
    }
LABEL_18:
    v62 = v141(a3, a4);
    v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64)
        goto LABEL_20;
    }
    else if (v63 >= 64)
    {
LABEL_20:
      v144 = 8;
      v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
      v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v74 = v140;
        v73(v140, a2, a3);
        v75 = v141(a3, a4);
        v76 = v139;
        v77 = v74;
        v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          v80 = v140;
          goto LABEL_42;
        }
        v79 = v32(a3, a4);
        v70(v76, a3);
        v80 = v140;
        if (v79 <= 64)
          goto LABEL_42;
        v81 = v135;
        v78(v135, v140, a3);
        v144 = 0x8000000000000000;
        v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v135, v88, a3);
            v89 = v88;
            v81 = v135;
            v70(v89, a3);
            if ((v86 & 1) != 0)
              goto LABEL_64;
            goto LABEL_41;
          }
        }
        else
        {
          v90 = v82(a3, a4);
          v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              v102 = (void (**)(char *, uint64_t, const char *))v137;
              v103 = v133;
              AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v103, AssociatedConformanceWitness);
              v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                + 16))(v135, v106, a3);
              v108 = v106;
              v81 = v107;
              v70(v108, a3);
              v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }
              v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              v112 = v111 < v110;
              v80 = v140;
              if (v112)
                goto LABEL_64;
            }
            else
            {
              v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              v97 = v135;
              v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
              v99 = v96;
              v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0)
                goto LABEL_64;
            }
            goto LABEL_41;
          }
          if (v91 >= 64)
            goto LABEL_41;
        }
        v100 = v142;
        v78(v142, v81, a3);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144)
LABEL_64:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        v113 = v132;
        v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          v124 = v113(a3, a4);
          v70(v115, a3);
          v125 = v124 == 64;
          v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            result = v70(v80, a3);
            v130 = *(unsigned __int8 *)v39;
            if ((v129 & 0x8000000000000000) != 0)
            {
              if (v129 >= 0xFFFFFFFFFFFFFFF9)
              {
                v61 = v130 << -(char)v129;
                goto LABEL_59;
              }
            }
            else if (v129 < 8)
            {
              v61 = v130 >> v129;
              goto LABEL_59;
            }
            goto LABEL_24;
          }
        }
        else
        {
          v70(v115, a3);
          v116 = v141;
        }
        v78(v40, v80, a3);
        v144 = 0x7FFFFFFFFFFFFFFFLL;
        v117 = v116(a3, a4);
        v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            v123 = &v144;
            goto LABEL_54;
          }
        }
        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          v123 = &v143;
LABEL_54:
          v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
          v70(v127, a3);
          if ((v128 & 1) != 0)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          goto LABEL_55;
        }
        v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }
LABEL_24:
      LOBYTE(v61) = 0;
      goto LABEL_59;
    }
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 8)
      goto LABEL_25;
    goto LABEL_24;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_18;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }
  if (v42 > 64)
  {
    v144 = -8;
    v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    v40 = v131;
    v39 = v132;
    if ((v48 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v55 = v137;
  v56 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v56);
  v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
  v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 < -8)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOBYTE(v61) = 0;
  v39 = v132;
LABEL_59:
  *(_BYTE *)v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt8@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t AssociatedConformanceWitness;
  char *v50;
  void (*v51)(char *, uint64_t);
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void (*v57)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v58;
  uint64_t (*v59)(char *, uint64_t);
  void (*v60)(void);
  char *v61;
  char v62;
  uint64_t v63;
  char *v64;
  char *v65;
  uint64_t (*v66)(uint64_t, uint64_t);
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  unsigned int v73;
  _BYTE *v74;
  uint64_t (*v75)(uint64_t, uint64_t);
  uint64_t v76;
  char *v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v83;
  int64_t *v84;
  uint64_t v85;
  char v86;
  unint64_t v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void (*v92)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v93;
  char v94;
  void (*v95)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v96;
  char v97;
  char *v98;
  uint64_t v99;
  void (**v100)(char *, uint64_t, const char *);
  unint64_t v101;
  unint64_t v102;
  char *v103;
  char *v104;
  char *v105;
  int64_t v106;
  uint64_t v107;
  BOOL v108;
  char *v109;
  char *v110;
  char *v111;
  unint64_t AssociatedTypeWitness;
  char *v113;
  unsigned int v114;
  char *v115;
  char *v116;
  char *v117;
  _BYTE *v118;
  uint64_t (*v119)(uint64_t, uint64_t);
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t v121;
  int64_t v122;

  v118 = a5;
  v113 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v113, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v111 = (char *)&v109 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v109 = (char *)&v109 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v109 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v115 = (char *)&v109 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v110 = (char *)&v109 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v109 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v117 = (char *)&v109 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v109 - v28;
  v114 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v119 = v30;
  if ((v31 & 1) != 0)
  {
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v122 = -8;
      v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v44(&v122, &type metadata for Int, v45, a3, a4);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if ((v44 & 1) != 0)
        goto LABEL_29;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v36 < -8)
        goto LABEL_29;
    }
  }
  else
  {
    v38 = v30(a3, a4);
    v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v120(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 <= 64)
      {
        v47 = AssociatedTypeWitness;
        v48 = v113;
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v113, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v50 = v111;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v47, AssociatedConformanceWitness);
        (*((void (**)(char *, uint64_t, const char *))v48 + 3))(v50, a3, v48);
        LOBYTE(v47) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        v51 = *(void (**)(char *, uint64_t))(v11 + 8);
        v51(v29, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
        if ((v47 & 1) != 0)
        {
          result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
          goto LABEL_29;
        }
        v52 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
        v30 = v119;
        v32 = v120;
        if (v52 < -8)
          goto LABEL_29;
      }
      else
      {
        v122 = -8;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v122, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v119;
        v32 = v120;
        if ((v42 & 1) != 0)
          goto LABEL_29;
      }
    }
    else if (v39 <= 64)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v30 = v119;
      v32 = v120;
      if (v46 < -8)
        goto LABEL_29;
    }
    else
    {
      v30 = v119;
      v32 = v120;
    }
  }
  v120 = v32;
  v53 = v30(a3, a4);
  v54 = v32(a3, a4);
  if ((v53 & 1) != 0)
  {
    if (v54 > 64)
      goto LABEL_20;
  }
  else if (v54 > 63)
  {
LABEL_20:
    v122 = 8;
    v57 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v58 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v57(&v122, &type metadata for Int, v58, a3, a4);
    LOBYTE(v57) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v59(v29, a3);
    if ((v57 & 1) == 0)
      goto LABEL_21;
    goto LABEL_29;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v59(v29, a3);
  if (v72 <= 8)
  {
LABEL_21:
    v60 = *(void (**)(void))(v11 + 16);
    v61 = v117;
    v60();
    v62 = v119(a3, a4);
    ((void (*)(char *, char *, uint64_t))v60)(v25, v61, a3);
    if ((v62 & 1) == 0)
    {
      v71 = v25;
      v64 = v116;
      goto LABEL_31;
    }
    v63 = v120(a3, a4);
    v59(v25, a3);
    v64 = v116;
    if (v63 < 65)
      goto LABEL_32;
    v65 = v110;
    ((void (*)(char *, char *, uint64_t))v60)(v110, v61, a3);
    v122 = 0x8000000000000000;
    v66 = v119;
    if ((v119(a3, a4) & 1) != 0)
    {
      v67 = v120(a3, a4);
      if (v67 < 64)
      {
        ((void (*)(char *, char *, uint64_t))v60)(v29, v65, a3);
        v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v59(v29, a3);
        v71 = v65;
        if (v70 < v122)
          goto LABEL_68;
        goto LABEL_31;
      }
      v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v96 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v95(&v122, &type metadata for Int, v96, a3, a4);
      v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v65, v29, a3);
LABEL_53:
      v97 = v94;
      v59(v29, a3);
      v71 = v65;
      if ((v97 & 1) != 0)
        goto LABEL_68;
LABEL_31:
      v59(v71, a3);
LABEL_32:
      v75 = v120;
      v76 = v120(a3, a4);
      v77 = v115;
      ((void (*)(char *, char *, uint64_t))v60)(v115, v61, a3);
      if (v76 < 65)
      {
        v85 = v75(a3, a4);
        v59(v77, a3);
        if (v85 != 64 || (v119(a3, a4) & 1) != 0)
        {
LABEL_45:
          v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          result = v59(v61, a3);
          if ((v87 & 0x8000000000000000) != 0)
          {
            v74 = v118;
            if (v87 > 0xFFFFFFFFFFFFFFF8)
            {
              v73 = v114 >> -(char)v87;
              goto LABEL_48;
            }
          }
          else
          {
            v74 = v118;
            if (v87 <= 7)
            {
              v73 = v114 << v87;
              goto LABEL_48;
            }
          }
          LOBYTE(v73) = 0;
          goto LABEL_48;
        }
      }
      else
      {
        v59(v77, a3);
      }
      ((void (*)(char *, char *, uint64_t))v60)(v64, v61, a3);
      v122 = 0x7FFFFFFFFFFFFFFFLL;
      v78 = v119(a3, a4);
      v79 = v120(a3, a4);
      if ((v78 & 1) != 0)
      {
        if (v79 > 64)
        {
          v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
          v84 = &v122;
          goto LABEL_43;
        }
      }
      else if (v79 > 63)
      {
        v121 = 0x7FFFFFFFFFFFFFFFLL;
        v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        v84 = &v121;
LABEL_43:
        v82(v84, &type metadata for Int, v83, a3, a4);
        v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v64, a3);
        v59(v29, a3);
        if ((v86 & 1) != 0)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
        goto LABEL_44;
      }
      ((void (*)(char *, char *, uint64_t))v60)(v29, v64, a3);
      (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
LABEL_44:
      v59(v64, a3);
      goto LABEL_45;
    }
    v88 = v66(a3, a4);
    v89 = v120(a3, a4);
    if ((v88 & 1) != 0)
    {
      if (v89 > 64)
      {
        v92 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v93 = lazy protocol witness table accessor for type Int and conformance Int(v89, v90, v91);
        v92(&v122, &type metadata for Int, v93, a3, a4);
        v65 = v110;
        v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v110, v29, a3);
        goto LABEL_53;
      }
      v101 = AssociatedTypeWitness;
      v100 = (void (**)(char *, uint64_t, const char *))v113;
      v102 = swift_getAssociatedConformanceWitness((uint64_t)v113, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v103 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v102 + 8))(&qword_1816B7DA8, 256, v101, v102);
      v100[3](v103, a3, (const char *)v100);
      v104 = v110;
      LOBYTE(v100) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v110, v29, a3);
      v59(v29, a3);
      v105 = v109;
      ((void (*)(char *, char *, uint64_t))v60)(v109, v104, a3);
      if ((v100 & 1) != 0)
      {
        v59(v105, a3);
        goto LABEL_68;
      }
      v106 = v122;
      v107 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v105, a3);
      v108 = v107 < v106;
      v61 = v117;
      v71 = v110;
      if (!v108)
        goto LABEL_31;
    }
    else
    {
      if (v89 > 64)
      {
        v71 = v110;
        goto LABEL_31;
      }
      v98 = v110;
      ((void (*)(char *, char *, uint64_t))v60)(v29, v110, a3);
      v99 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
      v71 = v98;
      if (v99 >= v122)
        goto LABEL_31;
    }
LABEL_68:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
LABEL_29:
  LOBYTE(v73) = 0;
  v74 = v118;
LABEL_48:
  *v74 = v73;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt8(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t (*v39)(uint64_t, uint64_t);
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unsigned int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t AssociatedConformanceWitness;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unsigned int v130;
  char *v131;
  uint64_t (*v132)(uint64_t, uint64_t);
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v144 = -8;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 < -8)
        goto LABEL_24;
    }
LABEL_18:
    v62 = v141(a3, a4);
    v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64)
        goto LABEL_20;
    }
    else if (v63 >= 64)
    {
LABEL_20:
      v144 = 8;
      v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
      v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v74 = v140;
        v73(v140, a2, a3);
        v75 = v141(a3, a4);
        v76 = v139;
        v77 = v74;
        v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          v80 = v140;
          goto LABEL_42;
        }
        v79 = v32(a3, a4);
        v70(v76, a3);
        v80 = v140;
        if (v79 <= 64)
          goto LABEL_42;
        v81 = v135;
        v78(v135, v140, a3);
        v144 = 0x8000000000000000;
        v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v135, v88, a3);
            v89 = v88;
            v81 = v135;
            v70(v89, a3);
            if ((v86 & 1) != 0)
              goto LABEL_64;
            goto LABEL_41;
          }
        }
        else
        {
          v90 = v82(a3, a4);
          v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              v102 = (void (**)(char *, uint64_t, const char *))v137;
              v103 = v133;
              AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v103, AssociatedConformanceWitness);
              v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                + 16))(v135, v106, a3);
              v108 = v106;
              v81 = v107;
              v70(v108, a3);
              v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }
              v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              v112 = v111 < v110;
              v80 = v140;
              if (v112)
                goto LABEL_64;
            }
            else
            {
              v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              v97 = v135;
              v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
              v99 = v96;
              v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0)
                goto LABEL_64;
            }
            goto LABEL_41;
          }
          if (v91 >= 64)
            goto LABEL_41;
        }
        v100 = v142;
        v78(v142, v81, a3);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144)
LABEL_64:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        v113 = v132;
        v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          v124 = v113(a3, a4);
          v70(v115, a3);
          v125 = v124 == 64;
          v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            result = v70(v80, a3);
            v130 = *(unsigned __int8 *)v39;
            if ((v129 & 0x8000000000000000) != 0)
            {
              if (v129 > 0xFFFFFFFFFFFFFFF8)
              {
                v61 = v130 >> -(char)v129;
                goto LABEL_59;
              }
            }
            else if (v129 < 8)
            {
              v61 = v130 << v129;
              goto LABEL_59;
            }
            goto LABEL_24;
          }
        }
        else
        {
          v70(v115, a3);
          v116 = v141;
        }
        v78(v40, v80, a3);
        v144 = 0x7FFFFFFFFFFFFFFFLL;
        v117 = v116(a3, a4);
        v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            v123 = &v144;
            goto LABEL_54;
          }
        }
        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          v123 = &v143;
LABEL_54:
          v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
          v70(v127, a3);
          if ((v128 & 1) != 0)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          goto LABEL_55;
        }
        v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }
LABEL_24:
      LOBYTE(v61) = 0;
      goto LABEL_59;
    }
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 8)
      goto LABEL_25;
    goto LABEL_24;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_18;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }
  if (v42 > 64)
  {
    v144 = -8;
    v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    v40 = v131;
    v39 = v132;
    if ((v48 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v55 = v137;
  v56 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v56);
  v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
  v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 < -8)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOBYTE(v61) = 0;
  v39 = v132;
LABEL_59:
  *(_BYTE *)v39 = v61;
  return result;
}

_BYTE *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt8(_BYTE *result, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3;
  char v4;

  if (!*a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E0uLL, 0);
  v4 = *v3 / *a3;
  *a2 = *v3 % *a3;
  *result = v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt8(unsigned __int8 *a1)
{
  unsigned __int8 *v1;

  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt8(BOOL *a1@<X8>)
{
  _BYTE *v1;

  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char v23;
  void (*v24)(char *, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v26;
  void (*v27)(char *, uint64_t);
  char *v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  _BYTE *v31;
  uint64_t v32;
  _QWORD *v33;
  char *v34;
  uint64_t (*v35)(uint64_t, _QWORD *);
  uint64_t v36;
  char *v37;
  char v38;
  uint64_t result;
  char v40;
  void (*v41)(char *, uint64_t);
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  unsigned int v53;
  char *v54;
  unsigned __int8 v55;
  BOOL v56;
  void (*v57)(unsigned __int8 *, uint64_t, unint64_t, uint64_t, _QWORD *);
  unint64_t v58;
  char *v59;
  char *v60;
  unsigned __int8 v61;
  char *v62;
  unint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  char *v67;
  uint64_t (*v68)(uint64_t, _QWORD *);
  void (*v69)(char *, uint64_t, uint64_t);
  char *v70;
  _BYTE *v71;
  uint64_t v72;
  unsigned __int8 v73;

  v66 = a4;
  v71 = a5;
  v8 = *(_QWORD *)(a3[3] + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v62 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v65 = (char *)&v62 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v70 = (char *)&v62 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v62 - v19;
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v62 - v21;
  v68 = (uint64_t (*)(uint64_t, _QWORD *))a3[8];
  v23 = v68(a2, a3);
  v24 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v72 = a1;
  v69 = v24;
  v24(v22, a1, a2);
  v67 = v20;
  v63 = AssociatedTypeWitness;
  v64 = v8;
  v62 = v12;
  if ((v23 & 1) != 0)
  {
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a2, v8);
    v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(a3[4] + 8) + 16))(v22, v20, a2);
    v27 = *(void (**)(char *, uint64_t))(v13 + 8);
    v27(v20, a2);
    v28 = v22;
    v29 = v27;
    v27(v28, a2);
    v31 = v71;
    v30 = v72;
    v32 = v13;
    v33 = a3;
    if ((v26 & 1) != 0)
      goto LABEL_17;
  }
  else
  {
    v34 = v22;
    v29 = *(void (**)(char *, uint64_t))(v13 + 8);
    v29(v34, a2);
    v30 = v72;
    v32 = v13;
    v33 = a3;
  }
  v35 = (uint64_t (*)(uint64_t, _QWORD *))v33[16];
  v36 = v35(a2, v33);
  v37 = v70;
  v69(v70, v30, a2);
  if (v36 <= 7)
  {
    v29(v37, a2);
    v31 = v71;
    goto LABEL_7;
  }
  v41 = v29;
  v73 = -1;
  v42 = v68(a2, v33);
  v43 = v35(a2, v33);
  if ((v42 & 1) != 0)
  {
    if (v43 < 9)
    {
      v47 = v63;
      v46 = v64;
      v48 = swift_getAssociatedConformanceWitness(v64, a2, v63, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v49 = v62;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v48 + 8))(&qword_1816B7DA8, 256, v47, v48);
      v50 = v67;
      (*(void (**)(char *, uint64_t, uint64_t))(v46 + 24))(v49, a2, v46);
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v33[4] + 8) + 40))(v37, v50, a2);
      v51 = v50;
      v29 = v41;
      v41(v51, a2);
      v52 = v37;
      v53 = v73;
      v54 = v65;
      (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v65, v52, a2);
      if ((v46 & 1) == 0)
      {
        v41(v54, a2);
        v31 = v71;
        v30 = v72;
        goto LABEL_7;
      }
      v55 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
      v41(v54, a2);
      v56 = v53 >= v55;
      goto LABEL_16;
    }
LABEL_13:
    v57 = (void (*)(unsigned __int8 *, uint64_t, unint64_t, uint64_t, _QWORD *))v33[12];
    v58 = lazy protocol witness table accessor for type UInt8 and conformance UInt8(v43, v44, v45);
    v59 = v67;
    v57(&v73, v66, v58, a2, v33);
    LOBYTE(v57) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v33[4] + 8) + 16))(v59, v37, a2);
    v29 = v41;
    v41(v59, a2);
    v41(v37, a2);
    v31 = v71;
    v30 = v72;
    if ((v57 & 1) != 0)
      goto LABEL_17;
    goto LABEL_7;
  }
  if (v43 >= 9)
    goto LABEL_13;
  v60 = v67;
  (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v67, v37, a2);
  v61 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
  v29 = v41;
  v41(v60, a2);
  v56 = v73 >= v61;
LABEL_16:
  v31 = v71;
  v30 = v72;
  if (!v56)
  {
LABEL_17:
    result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
    v38 = 0;
    v40 = 1;
    goto LABEL_18;
  }
LABEL_7:
  v38 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
  result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
  v40 = 0;
LABEL_18:
  *v31 = v38;
  v31[1] = v40;
  return result;
}

_BYTE *protocol witness for static Numeric.* infix(_:_:) in conformance UInt8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  if (((*result * (unsigned __int16)*a2) & 0xFF00) != 0)
    __break(1u);
  else
    *a3 = *result * *a2;
  return result;
}

_BYTE *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt8(_BYTE *result, _BYTE *a2)
{
  if (((*result * (unsigned __int16)*a2) & 0xFF00) != 0)
    __break(1u);
  else
    *result *= *a2;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt8()
{
  unsigned __int8 *v0;

  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

unsigned __int8 *protocol witness for Strideable.distance(to:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  unsigned __int8 *v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;

  v3 = *result;
  v4 = *v2;
  v5 = v4 - v3;
  v6 = v3 >= v4;
  v7 = v3 - v4;
  if (!v6)
    v7 = -v5;
  *a2 = v7;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt8@<X0>(unint64_t *result@<X0>, _BYTE *a2@<X8>)
{
  unsigned __int8 *v2;
  unint64_t v3;
  int v4;
  unint64_t v5;

  v3 = *result;
  v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (v3 >= 0x100)
      goto LABEL_8;
    v4 += v3;
    v3 = v4;
    if (v4 == v4)
    {
LABEL_7:
      *a2 = v4;
      return result;
    }
    __break(1u);
  }
  v5 = -(uint64_t)v3;
  if (v5 >= 0x100)
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  v4 -= v5;
  if ((v4 & 0xFFFFFF00) == 0)
    goto LABEL_7;
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

unsigned __int8 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, unsigned __int8 *a2@<X1>, _BYTE *a3@<X8>)
{
  unsigned int v3;

  v3 = *result + *a2;
  if (((v3 >> 8) & 1) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

uint64_t static UInt8.+ infix(_:_:)(unsigned __int8 a1, unsigned __int8 a2)
{
  uint64_t result;

  result = a1 + a2;
  if (((result >> 8) & 1) != 0)
    __break(1u);
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt8(_BYTE *result, unsigned __int8 *a2)
{
  unsigned int v2;

  v2 = *result + *a2;
  if (((v2 >> 8) & 1) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

unsigned __int8 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt8@<X0>(unsigned __int8 *result@<X0>, unsigned __int8 *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3;

  v3 = *result - *a2;
  if ((v3 & 0xFFFFFF00) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt8(_BYTE *result, unsigned __int8 *a2)
{
  int v2;

  v2 = *result - *a2;
  if ((v2 & 0xFFFFFF00) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

uint64_t UInt8._toCustomAnyHashable()@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt8>);
  *(_QWORD *)(a2 + 24) = result;
  *(_QWORD *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt8@<X0>(uint64_t a1@<X8>)
{
  char *v1;
  char v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt8>);
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a1 = v3;
  return result;
}

uint64_t Int8._value.setter(uint64_t result)
{
  _BYTE *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int8._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int8 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x63BuLL, 0);
  __asm { FCVT            S0, H0 }
  if (_S0 <= -129.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int8 because the result would be less than Int8.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x63EuLL, 0);
  if (_S0 >= 128.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int8 because the result would be greater than Int8.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x641uLL, 0);
  return (int)_S0;
}

uint64_t Int8.init(exactly:)(__n128 _Q0)
{
  BOOL v6;
  int v9;
  char v10;
  int v11;

  __asm { FCVT            S0, H0 }
  v6 = _S0 > -129.0;
  if (_S0 >= 128.0)
    v6 = 0;
  _S1 = truncf(_S0);
  __asm
  {
    FCVT            H1, S1
    FCVT            S1, H1
  }
  v9 = v6 && _S1 == _S0;
  _ZF = v9 == 0;
  v10 = ~(_BYTE)v9;
  if (_ZF)
    v11 = 0;
  else
    v11 = (int)_S0;
  return v11 & 0xFFFFFEFF | ((v10 & 1) << 8);
}

Swift::Int8 __swiftcall Int8.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int8 because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x687uLL, 0);
  if (a1 <= -129.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int8 because the result would be less than Int8.min", 86, 2, "Swift/IntegerTypes.swift", 24, 2, 0x68AuLL, 0);
  if (a1 >= 128.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int8 because the result would be greater than Int8.max", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x68DuLL, 0);
  return (int)a1;
}

Swift::Int8_optional __swiftcall Int8.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  __int16 v5;

  v1 = exactly > -129.0;
  if (exactly >= 128.0)
    v1 = 0;
  v3 = v1 & (truncf(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    v5 = 0;
  else
    v5 = (int)exactly;
  return (Swift::Int8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

Swift::Int8 __swiftcall Int8.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int8 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x6CFuLL, 0);
  if (a1 <= -129.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int8 because the result would be less than Int8.min", 87, 2, "Swift/IntegerTypes.swift", 24, 2, 0x6D2uLL, 0);
  if (a1 >= 128.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int8 because the result would be greater than Int8.max", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x6D5uLL, 0);
  return (int)a1;
}

Swift::Int8_optional __swiftcall Int8.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  __int16 v5;

  v1 = exactly > -129.0;
  if (exactly >= 128.0)
    v1 = 0;
  v3 = v1 & (trunc(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    v5 = 0;
  else
    v5 = (int)exactly;
  return (Swift::Int8_optional)(v5 & 0xFEFF | ((v4 & 1) << 8));
}

BOOL static Int8.< infix(_:_:)(char a1, char a2)
{
  return a1 < a2;
}

_BYTE *static Int8.-= infix(_:_:)(_BYTE *result, char a2)
{
  int v2;

  v2 = (char)*result - a2;
  if ((char)(*result - a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

_BYTE *static Int8.*= infix(_:_:)(_BYTE *result, char a2)
{
  int v2;

  v2 = (char)*result * a2;
  if ((char)(*result * a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

_BYTE *static Int8./= infix(_:_:)(_BYTE *result, char a2)
{
  int v2;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  v2 = *result;
  if (a2 == -1 && v2 == 128)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  *result = (char)v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.addingReportingOverflow(_:)(Swift::Int8 a1)
{
  Swift::Bool v1;
  Swift::Int8 v2;
  Swift::tuple_partialValue_Int8_overflow_Bool result;

  v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.subtractingReportingOverflow(_:)(Swift::Int8 a1)
{
  Swift::Bool v1;
  Swift::Int8 v2;
  Swift::tuple_partialValue_Int8_overflow_Bool result;

  v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.multipliedReportingOverflow(by:)(Swift::Int8 by)
{
  Swift::Bool v1;
  Swift::Int8 v2;
  Swift::tuple_partialValue_Int8_overflow_Bool result;

  v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.dividedReportingOverflow(by:)(Swift::Int8 by)
{
  char v1;
  Swift::Int8 v2;
  Swift::tuple_partialValue_Int8_overflow_Bool result;

  if (by)
  {
    if (by == -1 && v1 == 128)
      v1 = 0x80;
    else
      v1 /= by;
  }
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int8_overflow_Bool __swiftcall Int8.remainderReportingOverflow(dividingBy:)(Swift::Int8 dividingBy)
{
  char v1;
  Swift::Int8 v2;
  Swift::tuple_partialValue_Int8_overflow_Bool result;

  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 128)
      v1 = 0;
    else
      v1 %= dividingBy;
  }
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

_BYTE *static Int8.%= infix(_:_:)(_BYTE *result, char a2)
{
  int v2;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  v2 = *result;
  if (a2 == -1 && v2 == 128)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  *result = (char)v2 % a2;
  return result;
}

_BYTE *static Int8.&= infix(_:_:)(_BYTE *result, char a2)
{
  *result &= a2;
  return result;
}

_BYTE *static Int8.|= infix(_:_:)(_BYTE *result, char a2)
{
  *result |= a2;
  return result;
}

_BYTE *static Int8.^= infix(_:_:)(_BYTE *result, char a2)
{
  *result ^= a2;
  return result;
}

_BYTE *static Int8.&>>= infix(_:_:)(_BYTE *result, char a2)
{
  *result = (char)*result >> (a2 & 7);
  return result;
}

uint64_t static Int8.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

_BYTE *static Int8.&<<= infix(_:_:)(_BYTE *result, char a2)
{
  *result = *result << (a2 & 7);
  return result;
}

uint64_t static Int8.bitWidth.getter()
{
  return 8;
}

uint64_t Int8.leadingZeroBitCount.getter(unsigned __int8 a1)
{
  return (__clz(a1) - 24);
}

uint64_t Int8._lowWord.getter(uint64_t result)
{
  return (char)result;
}

uint64_t Int8.trailingZeroBitCount.getter(int a1)
{
  return __clz(__rbit32(a1 | 0x100));
}

uint64_t Int8.nonzeroBitCount.getter(unsigned __int8 a1)
{
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t Int8.Words._value.setter(uint64_t result)
{
  _BYTE *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int8.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.Words.count.getter()
{
  return 1;
}

uint64_t Int8.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int8.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int8.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int8.Words.index(after:)(Swift::Int after)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFADD__(after, 1);
  result = after + 1;
  if (v1)
    __break(1u);
  return result;
}

Swift::Int __swiftcall Int8.Words.index(before:)(Swift::Int before)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFSUB__(before, 1);
  result = before - 1;
  if (v1)
    __break(1u);
  return result;
}

uint64_t Int8.Words.subscript.getter(uint64_t a1, char a2)
{
  if (a1 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x9AAuLL, 0);
  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x9ABuLL, 0);
  return a2;
}

uint64_t static Int8.&>> infix(_:_:)(char a1, char a2)
{
  return (a1 >> (a2 & 7));
}

unint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance Int8.Words@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result;

  result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2);
  *a3 = result;
  return result;
}

unint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance Int8.Words(unint64_t *a1, unint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int8.Words(uint64_t *a1, uint64_t *a2))()
{
  char *v2;

  *a1 = Int8.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UInt8.Words@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  char *v2;
  uint64_t v3;
  char v4;

  if ((*result & 0x8000000000000000) != 0 || (v3 = result[1], v3 >= 2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  v4 = *v2;
  *(_QWORD *)a2 = *result;
  *(_QWORD *)(a2 + 8) = v3;
  *(_BYTE *)(a2 + 16) = v4;
  return result;
}

uint64_t protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance Int8.Words(uint64_t *a1, uint64_t *a2)
{
  return specialized Collection._failEarlyRangeCheck(_:bounds:)(*a1, *a2, a2[1]);
}

_QWORD *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UInt8.Words(_QWORD *result, _QWORD *a2)
{
  if (*result < *a2 || a2[1] < *result)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  return result;
}

{
  if (*result < *a2 || a2[1] < result[1])
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Int8.Words(uint64_t a1@<X8>)
{
  _BYTE *v1;

  *(_BYTE *)a1 = *v1;
  *(_QWORD *)(a1 + 8) = 0;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance Int8.Words()
{
  char *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int8.Words(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  char *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int8.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5(a1, a2);
}

uint64_t Int8.magnitude.getter(char a1)
{
  if (a1 >= 0)
    return a1;
  else
    return -a1;
}

Swift::tuple_high_Int8_low_UInt8 __swiftcall Int8.multipliedFullWidth(by:)(Swift::Int8 by)
{
  signed __int8 v1;
  unsigned int v2;
  Swift::tuple_high_Int8_low_UInt8 result;

  v2 = bswap32(v1 * by) >> 16;
  result.high = v2;
  result.low = v1;
  return result;
}

Swift::tuple_quotient_Int8_remainder_Int8 __swiftcall Int8.dividingFullWidth(_:)(Swift::tuple_high_Int8_low_UInt8 a1)
{
  char v1;
  unsigned __int8 v2;
  __int16 v3;
  unsigned __int16 v4;
  Swift::tuple_quotient_Int8_remainder_Int8 result;

  if (!v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA29uLL, 0);
  v3 = a1.low | (unsigned __int16)(__PAIR16__(v2, a1.high) << 8);
  if (v1 == -1 && (unsigned __int16)v3 == 0x8000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  v4 = v3 / v1;
  if ((unsigned __int16)(char)v4 != v4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0xA33uLL, 0);
  result.remainder = v3;
  result.quotient = v4;
  return result;
}

uint64_t static Int16.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << (a2 & 0xF));
}

Swift::Int8 __swiftcall Int8.signum()()
{
  char v0;

  return (v0 > 0) | (v0 >> 7);
}

BOOL static Int8.> infix(_:_:)(char a1, char a2)
{
  return a2 < a1;
}

uint64_t static Int8.| infix(_:_:)(unsigned int a1, int a2)
{
  return a2 | a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int8(_BYTE *a1@<X8>)
{
  *a1 = 127;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int8(_BYTE *a1@<X8>)
{
  *a1 = 0x80;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int8(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2;
  int v3;
  _BOOL8 v4;

  v3 = (char)*v2 + (char)*a2;
  v4 = v3 != (char)(*v2 + *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int8(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2;
  int v3;
  _BOOL8 v4;

  v3 = (char)*v2 - (char)*a2;
  v4 = v3 != (char)(*v2 - *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int8(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2;
  int v3;
  _BOOL8 v4;

  v3 = (char)*v2 * (char)*a2;
  v4 = v3 != (char)(*v2 * *a2);
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int8(_BYTE *a1, _BYTE *a2)
{
  unsigned __int8 *v2;
  int v3;
  int v4;
  uint64_t v5;

  v3 = *a2;
  v4 = *v2;
  if (!*a2 || v3 == 255 && v4 == 128)
  {
    v5 = 1;
  }
  else
  {
    v5 = 0;
    LOBYTE(v4) = (char)v4 / (char)v3;
  }
  *a1 = v4;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int8(_BYTE *a1, _BYTE *a2)
{
  unsigned __int8 *v2;
  int v3;
  int v4;
  uint64_t v5;

  v3 = *a2;
  v4 = *v2;
  if (!*a2)
    goto LABEL_7;
  if (v3 == 255 && v4 == 128)
  {
    LOBYTE(v4) = 0;
LABEL_7:
    v5 = 1;
    goto LABEL_5;
  }
  v5 = 0;
  LOBYTE(v4) = (char)v4 % (char)v3;
LABEL_5:
  *a1 = v4;
  return v5;
}

_BYTE *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int8(_BYTE *result, _BYTE *a2, char *a3)
{
  char *v3;
  __int16 v4;

  v4 = *v3 * *a3;
  *result = HIBYTE(v4);
  *a2 = v4;
  return result;
}

Swift::Int8 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int8(Swift::Int8 *a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  Swift::Int8 result;
  char v7;

  result = Int8.dividingFullWidth(_:)((Swift::tuple_high_Int8_low_UInt8)__PAIR16__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int8()
{
  unsigned __int8 *v0;
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int8()
{
  unsigned __int8 *v0;

  return (__clz(*v0) - 24);
}

char *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int8@<X0>(char *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result >> (*a2 & 7);
  return result;
}

_BYTE *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  *result = (char)*result >> (*a2 & 7);
  return result;
}

unsigned __int8 *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result << (*a2 & 7);
  return result;
}

uint64_t static Int8.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << (a2 & 7));
}

_BYTE *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  *result = *result << (*a2 & 7);
  return result;
}

_BYTE *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_BYTE *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_BYTE *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_BYTE *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int8@<X0>(_BYTE *result@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  if (a2 <= 0x8FF)
    *a3 = *result;
  else
    *a3 = 0;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int8 and conformance Int8(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int8@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int8 and conformance Int8, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt8@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _BYTE *a6@<X8>)
{
  Class *v6;
  Class *v8;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t *TypeName;
  uint64_t v17;
  uint8x16_t *v18;
  int64_t v19;
  int64_t v20;
  int64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  Swift::String v26;
  uint64_t *v27;
  uint64_t v28;
  uint8x16_t *v29;
  int64_t v30;
  int64_t v31;
  int64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  Swift::String v37;
  char *v38;
  unint64_t v39;

  v8 = v6;
  v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((BYTE1(v38) & 1) != 0)
  {
    v38 = (char *)static String._createEmpty(withInitialCapacity:)(80);
    v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      v18 = (uint8x16_t *)TypeName;
      v19 = v17;
      v20 = validateUTF8(_:)(TypeName, v17);
      v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x8000000181762940;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        v29 = (uint8x16_t *)v27;
        v30 = v28;
        v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0)
          v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        else
          v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x8000000181762960;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = (_BYTE)v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int8@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _BYTE *a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char v28;
  void (*v29)(char *, char *, uint64_t);
  uint64_t v30;
  void (*v31)(char *, uint64_t);
  void (*v32)(char *, char *, uint64_t);
  char *v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t, uint64_t);
  char *v36;
  char v37;
  BOOL v38;
  uint64_t (*v39)(uint64_t, uint64_t);
  char v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char v44;
  char *v45;
  char *v46;
  char *v47;
  char v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  char v52;
  char *v53;
  int v54;
  char v55;
  uint64_t v56;
  char *v57;
  char v58;
  uint64_t v59;
  void (*v60)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char v65;
  char v66;
  uint64_t result;
  const char *v68;
  char *v69;
  uint64_t (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  _BYTE *v75;
  void (*v76)(char *, char *, uint64_t);
  uint64_t (*v77)(uint64_t, uint64_t);
  char *v78;
  char v79;
  char v80;
  char v81;

  v71 = a4;
  v72 = a5;
  v75 = a6;
  v68 = *(const char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v68, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v68 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v69 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v73 = (char *)&v68 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v68 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v74 = (char *)&v68 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v68 - v24;
  MEMORY[0x1E0C80A78](v23);
  v27 = (char *)&v68 - v26;
  v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v28 = v77(a2, a3);
  v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  v78 = a1;
  v76 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    v70 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v30 = v70(a2, a3);
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 8)
    {
      v32 = v76;
      v76(v25, v78, a2);
      v79 = 0x80;
      v33 = v25;
      v34 = v77;
      if ((v77(a2, a3) & 1) != 0)
      {
        v35 = v70;
        if (v70(a2, a3) < 8)
        {
          v36 = v74;
          v32(v74, v33, a2);
          v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          v38 = v79 <= v37;
LABEL_18:
          v42 = v33;
LABEL_19:
          v46 = v78;
          if (!v38)
LABEL_40:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
          goto LABEL_21;
        }
        v45 = v74;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v33, v45, a2);
        v31(v45, a2);
        v42 = v33;
        goto LABEL_11;
      }
      v40 = v34(a2, a3);
      v41 = v70(a2, a3);
      v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 8)
        {
          v49 = v68;
          AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v68, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
          v51 = v74;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v51, a2);
          v31(v51, a2);
          v53 = v69;
          v33 = v42;
          v32 = v76;
          v76(v69, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_40;
          }
          v54 = v79;
          v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          v38 = v54 <= v55;
          v35 = v70;
          goto LABEL_18;
        }
        v43 = v74;
        (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v43, a2);
        v31(v43, a2);
        v32 = v76;
        v35 = v70;
LABEL_11:
        v46 = v78;
        if ((v44 & 1) != 0)
          goto LABEL_40;
LABEL_21:
        v31(v42, a2);
        v39 = v77;
        goto LABEL_24;
      }
      if (v41 < 8)
      {
        v47 = v74;
        v32 = v76;
        v76(v74, v42, a2);
        v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        v38 = v79 <= v48;
        v35 = v70;
        goto LABEL_19;
      }
      v31(v33, a2);
    }
    v32 = v76;
    v39 = v77;
    v35 = v70;
  }
  else
  {
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v32 = v76;
    v39 = v77;
  }
  v46 = v78;
LABEL_24:
  v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 9)
  {
    v31(v20, a2);
    goto LABEL_26;
  }
  v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 8 && (v39(a2, a3) & 1) == 0)
  {
LABEL_26:
    v57 = v73;
    v32(v73, v46, a2);
    v81 = 127;
    v58 = v39(a2, a3);
    v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 8)
      {
        v60 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        v61 = &v81;
        goto LABEL_35;
      }
    }
    else if (v59 > 7)
    {
      v80 = 127;
      v60 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v61 = &v80;
LABEL_35:
      v64 = v74;
      v60(v61, v71, v72, a2, a3);
      v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v64, v57, a2);
      v31(v64, a2);
      if ((v65 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_36;
    }
    v63 = v74;
    v32(v74, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_36:
    v31(v57, a2);
  }
  v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *v75 = v66;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  char v7;
  uint64_t result;

  v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int8@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int8 and conformance Int8((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int8()
{
  char *v0;

  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int8()
{
  unsigned __int8 *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int8()
{
  unsigned __int8 *v0;

  return __clz(__rbit32(*v0 | 0x100));
}

unsigned __int8 *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3;
  int v4;

  v3 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  v4 = *result;
  if (v4 == 128 && v3 == 255)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  *a3 = (char)v4 / (char)v3;
  return result;
}

uint64_t static Int8./ infix(_:_:)(unsigned __int8 a1, char a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  if (a1 == 128 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  return ((char)a1 / a2);
}

_BYTE *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  int v2;
  int v3;

  v2 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7C3uLL, 0);
  v3 = *result;
  if (v2 == 255 && v3 == 128)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x7CAuLL, 0);
  *result = (char)v3 / (char)v2;
  return result;
}

unsigned __int8 *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3;
  int v4;

  v3 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  v4 = *result;
  if (v4 == 128 && v3 == 255)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  *a3 = (char)v4 % (char)v3;
  return result;
}

uint64_t static Int8.% infix(_:_:)(unsigned __int8 a1, char a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  if (a1 == 128 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  return ((char)a1 % a2);
}

_BYTE *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  int v2;
  int v3;

  v2 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8A8uLL, 0);
  v3 = *result;
  if (v2 == 255 && v3 == 128)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x8ADuLL, 0);
  *result = (char)v3 % (char)v2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  *result &= *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  *result |= *a2;
  return result;
}

_BYTE *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int8.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_BYTE *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int8@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  int v54;
  _BYTE *v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  uint64_t (*v62)(char *, uint64_t);
  void (*v63)(char *, uint64_t, uint64_t);
  char *v64;
  char v65;
  void (*v66)(char *, char *, uint64_t);
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t, uint64_t);
  uint64_t v79;
  char *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v86;
  int64_t *v87;
  uint64_t v88;
  char v89;
  unint64_t v90;
  char v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  void (*v95)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v96;
  char v97;
  void (*v98)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v99;
  char v100;
  char *v101;
  uint64_t v102;
  void (**v103)(char *, uint64_t, const char *);
  unint64_t v104;
  unint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  int64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  unint64_t AssociatedTypeWitness;
  char *v115;
  char *v116;
  char *v117;
  int v118;
  char *v119;
  _BYTE *v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t (*v122)(uint64_t, uint64_t);
  uint64_t v123;
  int64_t v124;

  v120 = a5;
  v115 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v115, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v113 = (char *)&v111 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v111 = (char *)&v111 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v111 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v117 = (char *)&v111 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v112 = (char *)&v111 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v111 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v119 = (char *)&v111 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v111 - v28;
  v118 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v121 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v124 = -8;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v121;
        v32 = v122;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v115;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -8;
    }
    else
    {
      if (v39 > 64)
      {
        v30 = v121;
        v32 = v122;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -8;
    }
    v30 = v121;
    v32 = v122;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 >= -8)
      goto LABEL_20;
LABEL_19:
    LOBYTE(v54) = 0;
    v55 = v120;
    goto LABEL_50;
  }
  v124 = -8;
  v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v44 & 1) != 0)
    goto LABEL_19;
LABEL_20:
  v122 = v32;
  v56 = v30(a3, a4);
  v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64)
      goto LABEL_22;
  }
  else if (v57 > 63)
  {
LABEL_22:
    v124 = 8;
    v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v60) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v62(v29, a3);
    if ((v60 & 1) == 0)
      goto LABEL_23;
LABEL_31:
    v54 = (char)v118 >> 7;
    v55 = v120;
    goto LABEL_50;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v62(v29, a3);
  if (v77 > 8)
    goto LABEL_31;
LABEL_23:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v64 = v119;
  v63(v119, a2, a3);
  v65 = v121(a3, a4);
  v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    v76 = v25;
    v68 = v119;
    v69 = v117;
    goto LABEL_33;
  }
  v67 = v122(a3, a4);
  v62(v25, a3);
  v68 = v119;
  v69 = v117;
  if (v67 < 65)
    goto LABEL_34;
  v70 = v112;
  v66(v112, v119, a3);
  v124 = 0x8000000000000000;
  v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    v91 = v71(a3, a4);
    v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        v70 = v112;
        v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
        goto LABEL_55;
      }
      v104 = AssociatedTypeWitness;
      v103 = (void (**)(char *, uint64_t, const char *))v115;
      v105 = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))(&qword_1816B7DA8, 256, v104, v105);
      v103[3](v106, a3, (const char *)v103);
      v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
      v62(v29, a3);
      v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }
      v109 = v124;
      v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      v47 = v110 < v109;
      v68 = v119;
      v76 = v112;
      if (!v47)
        goto LABEL_33;
    }
    else
    {
      if (v92 > 64)
      {
        v76 = v112;
        goto LABEL_33;
      }
      v101 = v112;
      v66(v29, v112, a3);
      v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      v76 = v101;
      if (v102 >= v124)
        goto LABEL_33;
    }
LABEL_70:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    v76 = v70;
    if (v75 < v124)
      goto LABEL_70;
    goto LABEL_33;
  }
  v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v70, v29, a3);
LABEL_55:
  v100 = v97;
  v62(v29, a3);
  v76 = v70;
  if ((v100 & 1) != 0)
    goto LABEL_70;
LABEL_33:
  v62(v76, a3);
LABEL_34:
  v78 = v122;
  v79 = v122(a3, a4);
  v66(v69, v68, a3);
  if (v79 < 65)
  {
    v88 = v78(a3, a4);
    v62(v69, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0)
      goto LABEL_47;
  }
  else
  {
    v62(v69, a3);
  }
  v80 = v116;
  v66(v116, v68, a3);
  v124 = 0x7FFFFFFFFFFFFFFFLL;
  v81 = v121(a3, a4);
  v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      v87 = &v124;
      goto LABEL_45;
    }
  }
  else if (v82 > 63)
  {
    v123 = 0x7FFFFFFFFFFFFFFFLL;
    v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v80, a3);
    v62(v29, a3);
    if ((v89 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_46;
  }
  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v62(v68, a3);
  if ((v90 & 0x8000000000000000) != 0)
  {
    v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFF8)
      LOBYTE(v54) = 0;
    else
      v54 = v118 << -(char)v90;
  }
  else
  {
    v55 = v120;
    if (v90 >= 8)
      v54 = (char)v118 >> 7;
    else
      v54 = (char)v118 >> v90;
  }
LABEL_50:
  *v55 = v54;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int8(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t (*v39)(uint64_t, uint64_t);
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  void (*v71)(char *, uint64_t, uint64_t);
  char *v72;
  char v73;
  char *v74;
  char *v75;
  void (*v76)(char *, char *, uint64_t);
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t (*v80)(uint64_t, uint64_t);
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  int v130;
  char *v131;
  uint64_t (*v132)(uint64_t, uint64_t);
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v144 = -8;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) == 0)
        goto LABEL_19;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 >= -8)
        goto LABEL_19;
    }
LABEL_18:
    LOBYTE(v61) = 0;
    goto LABEL_59;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_19;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 >= -8)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (v42 <= 64)
  {
    v55 = v137;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
    v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      LOBYTE(v61) = 0;
      v39 = v132;
      goto LABEL_59;
    }
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }
  v144 = -8;
  v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  v40 = v131;
  v39 = v132;
  if ((v48 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
  }
  else if (v63 >= 64)
  {
LABEL_21:
    v144 = 8;
    v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v68, a3);
    if ((v69 & 1) == 0)
      goto LABEL_22;
LABEL_30:
    v61 = *(char *)v39 >> 7;
    goto LABEL_59;
  }
  v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v88, a3);
  if (v89 > 8)
    goto LABEL_30;
LABEL_22:
  v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v72 = v140;
  v71(v140, a2, a3);
  v73 = v141(a3, a4);
  v74 = v139;
  v75 = v72;
  v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  v132 = v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    v78 = v140;
    goto LABEL_42;
  }
  v77 = v32(a3, a4);
  v70(v74, a3);
  v78 = v140;
  if (v77 <= 64)
    goto LABEL_42;
  v79 = v135;
  v76(v135, v140, a3);
  v144 = 0x8000000000000000;
  v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v81 = v132(a3, a4);
    if (v81 >= 64)
    {
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v86, a3);
      v87 = v86;
      v79 = v135;
      v70(v87, a3);
      if ((v84 & 1) != 0)
        goto LABEL_65;
      goto LABEL_41;
    }
  }
  else
  {
    v90 = v80(a3, a4);
    v91 = v132(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v79 = v107;
        v70(v108, a3);
        v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v78 = v140;
        if (v112)
          goto LABEL_65;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_65;
      }
      goto LABEL_41;
    }
    if (v91 >= 64)
      goto LABEL_41;
  }
  v100 = v142;
  v76(v142, v79, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  v113 = v132;
  v114 = v132(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }
  v124 = v113(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    v118 = v132(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        v123 = &v144;
        goto LABEL_54;
      }
    }
    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
      v70(v127, a3);
      if ((v128 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v78, a3);
  v130 = *(unsigned __int8 *)v39;
  if ((v129 & 0x8000000000000000) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFF8)
    {
      v61 = v130 << -(char)v129;
      goto LABEL_59;
    }
    goto LABEL_18;
  }
  if (v129 >= 8)
    v61 = (char)v130 >> 7;
  else
    v61 = (char)v130 >> v129;
LABEL_59:
  *(_BYTE *)v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int8@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  int v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  uint64_t (*v61)(char *, uint64_t);
  uint64_t v62;
  void (*v63)(char *, uint64_t, uint64_t);
  char *v64;
  char v65;
  void (*v66)(char *, char *, uint64_t);
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  uint64_t v78;
  char *v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  int64_t *v86;
  uint64_t v87;
  char v88;
  unint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char v96;
  void (*v97)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v98;
  char v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  unint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  int64_t v108;
  uint64_t v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t AssociatedTypeWitness;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  int v118;
  _BYTE *v119;
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t v122;
  int64_t v123;

  v119 = a5;
  v114 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v112 = (char *)&v110 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v110 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v110 = (char *)&v110 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v115 = (char *)&v110 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v116 = (char *)&v110 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v111 = (char *)&v110 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v110 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v117 = (char *)&v110 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v110 - v28;
  v118 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v120 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v121(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v123 = -8;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v123, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v120;
        v32 = v121;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v114;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -8;
    }
    else
    {
      if (v39 > 64)
      {
        v30 = v120;
        v32 = v121;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -8;
    }
    v30 = v120;
    v32 = v121;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    v123 = -8;
    v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v44(&v123, &type metadata for Int, v45, a3, a4);
    LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if ((v44 & 1) != 0)
      goto LABEL_19;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 <= -9)
      goto LABEL_19;
  }
LABEL_20:
  v121 = v32;
  v55 = v30(a3, a4);
  v56 = v32(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64)
      goto LABEL_22;
LABEL_25:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v61(v29, a3);
    if (v62 <= 8)
      goto LABEL_27;
LABEL_26:
    LOBYTE(v54) = 0;
    goto LABEL_51;
  }
  if (v56 <= 63)
    goto LABEL_25;
LABEL_22:
  v123 = 8;
  v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v123, &type metadata for Int, v60, a3, a4);
  LOBYTE(v59) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
  v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v61(v29, a3);
  if ((v59 & 1) != 0)
    goto LABEL_26;
LABEL_27:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v64 = v117;
  v63(v117, a2, a3);
  v65 = v120(a3, a4);
  v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    v76 = v25;
    v68 = v116;
    v69 = v117;
    goto LABEL_34;
  }
  v67 = v121(a3, a4);
  v61(v25, a3);
  v68 = v116;
  v69 = v117;
  if (v67 < 65)
    goto LABEL_35;
  v70 = v111;
  v66(v111, v117, a3);
  v123 = 0x8000000000000000;
  v71 = v120;
  if ((v120(a3, a4) & 1) == 0)
  {
    v90 = v71(a3, a4);
    v91 = v121(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 > 64)
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v94(&v123, &type metadata for Int, v95, a3, a4);
        v70 = v111;
        v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v29, a3);
        goto LABEL_56;
      }
      v103 = AssociatedTypeWitness;
      v102 = (void (**)(char *, uint64_t, const char *))v114;
      v104 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v105 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
      v102[3](v105, a3, (const char *)v102);
      v106 = v111;
      LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v29, a3);
      v61(v29, a3);
      v107 = v110;
      v66(v110, v106, a3);
      if ((v102 & 1) != 0)
      {
        v61(v107, a3);
        goto LABEL_70;
      }
      v108 = v123;
      v109 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v107, a3);
      v47 = v109 < v108;
      v69 = v117;
      v76 = v111;
      if (!v47)
        goto LABEL_34;
    }
    else
    {
      if (v91 > 64)
      {
        v76 = v111;
        goto LABEL_34;
      }
      v100 = v111;
      v66(v29, v111, a3);
      v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      v76 = v100;
      if (v101 >= v123)
        goto LABEL_34;
    }
LABEL_70:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v72 = v121(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
    v76 = v70;
    if (v75 < v123)
      goto LABEL_70;
    goto LABEL_34;
  }
  v97 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v98 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v97(&v123, &type metadata for Int, v98, a3, a4);
  v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v70, v29, a3);
LABEL_56:
  v99 = v96;
  v61(v29, a3);
  v76 = v70;
  if ((v99 & 1) != 0)
    goto LABEL_70;
LABEL_34:
  v61(v76, a3);
LABEL_35:
  v77 = v121;
  v78 = v121(a3, a4);
  v66(v68, v69, a3);
  if (v78 < 65)
  {
    v87 = v77(a3, a4);
    v61(v68, a3);
    if (v87 != 64 || (v120(a3, a4) & 1) != 0)
      goto LABEL_48;
  }
  else
  {
    v61(v68, a3);
  }
  v79 = v115;
  v66(v115, v69, a3);
  v123 = 0x7FFFFFFFFFFFFFFFLL;
  v80 = v120(a3, a4);
  v81 = v121(a3, a4);
  if ((v80 & 1) != 0)
  {
    if (v81 > 64)
    {
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v86 = &v123;
      goto LABEL_46;
    }
  }
  else if (v81 > 63)
  {
    v122 = 0x7FFFFFFFFFFFFFFFLL;
    v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
    v86 = &v122;
LABEL_46:
    v84(v86, &type metadata for Int, v85, a3, a4);
    v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v79, a3);
    v61(v29, a3);
    if ((v88 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_47;
  }
  v66(v29, v79, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v61(v29, a3);
LABEL_47:
  v61(v79, a3);
LABEL_48:
  v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v61(v69, a3);
  if ((v89 & 0x8000000000000000) == 0)
  {
    if (v89 < 8)
    {
      v54 = v118 << v89;
      goto LABEL_51;
    }
    goto LABEL_26;
  }
  if (v89 > 0xFFFFFFFFFFFFFFF8)
  {
    v54 = (char)v118 >> -(char)v89;
    goto LABEL_51;
  }
LABEL_19:
  v54 = (char)v118 >> 7;
LABEL_51:
  *v119 = v54;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int8(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t (*v39)(uint64_t, uint64_t);
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  int v130;
  char *v131;
  uint64_t (*v132)(uint64_t, uint64_t);
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    v131 = v19;
    v132 = a1;
    v41 = v29(a3, a4);
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        v144 = -8;
        v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        v40 = v131;
        v39 = v132;
        if ((v48 & 1) != 0)
          goto LABEL_18;
        goto LABEL_19;
      }
      v55 = v137;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
      v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        v39 = v132;
        goto LABEL_18;
      }
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }
    else
    {
      if (v42 >= 64)
      {
        v40 = v131;
        v39 = v132;
        goto LABEL_19;
      }
      v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }
    v40 = v131;
    v39 = v132;
    if (v54 >= -8)
      goto LABEL_19;
    goto LABEL_18;
  }
  v31 = v19;
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 < 64)
  {
    v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    v39 = a1;
    v40 = v31;
    if (v37 > -9)
      goto LABEL_19;
LABEL_18:
    v61 = *(char *)v39 >> 7;
    goto LABEL_60;
  }
  v144 = -8;
  v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  v39 = a1;
  v40 = v31;
  if ((v52 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
  }
  else if (v63 >= 64)
  {
LABEL_21:
    v144 = 8;
    v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v68, a3);
    if ((v69 & 1) != 0)
      goto LABEL_25;
    goto LABEL_26;
  }
  v71 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v71, a3);
  if (v72 > 8)
  {
LABEL_25:
    LOBYTE(v61) = 0;
    goto LABEL_60;
  }
LABEL_26:
  v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v74 = v140;
  v73(v140, a2, a3);
  v75 = v141(a3, a4);
  v76 = v139;
  v77 = v74;
  v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  v132 = v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_43;
  }
  v79 = v32(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64)
    goto LABEL_43;
  v81 = v135;
  v78(v135, v140, a3);
  v144 = 0x8000000000000000;
  v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v83 = v132(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v88, a3);
      v89 = v88;
      v81 = v135;
      v70(v89, a3);
      if ((v86 & 1) != 0)
        goto LABEL_65;
      goto LABEL_42;
    }
  }
  else
  {
    v90 = v82(a3, a4);
    v91 = v132(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v81 = v107;
        v70(v108, a3);
        v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v80 = v140;
        if (v112)
          goto LABEL_65;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_65;
      }
      goto LABEL_42;
    }
    if (v91 >= 64)
      goto LABEL_42;
  }
  v100 = v142;
  v78(v142, v81, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_42:
  v70(v81, a3);
LABEL_43:
  v113 = v132;
  v114 = v132(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 < 65)
  {
    v124 = v113(a3, a4);
    v70(v115, a3);
    v125 = v124 == 64;
    v116 = v141;
    if (!v125 || (v141(a3, a4) & 1) != 0)
      goto LABEL_57;
  }
  else
  {
    v70(v115, a3);
    v116 = v141;
  }
  v78(v40, v80, a3);
  v144 = 0x7FFFFFFFFFFFFFFFLL;
  v117 = v116(a3, a4);
  v118 = v132(a3, a4);
  if ((v117 & 1) != 0)
  {
    if (v118 > 64)
    {
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v144;
      goto LABEL_55;
    }
  }
  else if (v118 >= 64)
  {
    v143 = 0x7FFFFFFFFFFFFFFFLL;
    v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
    v123 = &v143;
LABEL_55:
    v127 = v142;
    v121(v123, &type metadata for Int, v122, a3, a4);
    v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
    v70(v127, a3);
    if ((v128 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_56;
  }
  v126 = v142;
  v78(v142, v40, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v126, a3);
LABEL_56:
  v70(v40, a3);
LABEL_57:
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v80, a3);
  v130 = *(unsigned __int8 *)v39;
  if ((v129 & 0x8000000000000000) == 0)
  {
    if (v129 < 8)
    {
      v61 = v130 << v129;
      goto LABEL_60;
    }
    goto LABEL_25;
  }
  if (v129 <= 0xFFFFFFFFFFFFFFF8)
    v61 = (char)v130 >> 7;
  else
    v61 = (char)v130 >> -(char)v129;
LABEL_60:
  *(_BYTE *)v39 = v61;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int8(_BYTE *a1, _BYTE *a2, char *a3)
{
  char *v3;
  uint64_t result;

  result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int8(char *a1)
{
  char *v1;

  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int8(_BYTE *a1@<X8>)
{
  char *v1;

  *a1 = (*v1 > 0) | (*v1 >> 7);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int8(uint64_t a1@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt8(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, _BYTE *a5@<X8>)
{
  uint64_t v7;
  unsigned int v10;
  unsigned int v11;
  int v12;
  char v13;

  v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  if (v7)
  {
    v10 = a3();
    if ((v10 & 0x10000) != 0)
      v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    v11 = v10;
    swift_bridgeObjectRelease(a2);
    v12 = (v11 >> 8) & 1;
    if (v12)
      v13 = 0;
    else
      v13 = v11;
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    v13 = 0;
    LOBYTE(v12) = 1;
  }
  *a5 = v13;
  a5[1] = v12;
}

_BYTE *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X8>)
{
  int v2;

  v2 = (char)*result;
  if (v2 + (char)-*result)
    __break(1u);
  else
    *a2 = -(char)v2;
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int8()
{
  _BYTE *v0;
  int v1;

  v1 = (char)*v0;
  if (v1 + (char)-*v0)
    __break(1u);
  else
    *v0 = -(char)v1;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char v29;
  void (*v30)(char *, uint64_t, uint64_t);
  _BOOL4 v31;
  void (*v32)(char *, uint64_t);
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char v39;
  _BYTE *v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  char v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(char *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v51;
  char *v52;
  char v53;
  char *v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(char *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  char v64;
  uint64_t result;
  char v66;
  void (*v67)(char *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v68;
  char *v69;
  char *v70;
  char v71;
  BOOL v72;
  char *v73;
  uint64_t v74;
  void (*v75)(char *, uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  void (**v80)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v82;
  char *v83;
  int v84;
  char v85;
  uint64_t (*v86)(uint64_t, uint64_t);
  char *v87;
  char *v88;
  char *v89;
  uint64_t v90;
  char *v91;
  char *v92;
  char *v93;
  _BYTE *v94;
  uint64_t (*v95)(uint64_t, uint64_t);
  uint64_t v96;
  char v97;
  char v98;
  char v99;

  v90 = a4;
  v94 = a5;
  v87 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v87, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v86 - v10;
  v12 = *(_QWORD *)(a2 - 8);
  v13 = MEMORY[0x1E0C80A78](v9);
  v88 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v86 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v93 = (char *)&v86 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v92 = (char *)&v86 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v91 = (char *)&v86 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v86 - v25;
  MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v86 - v27;
  v95 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v29 = v95(a2, a3);
  v96 = v12;
  v30 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v30(v28, a1, a2);
  v89 = v17;
  v31 = (v29 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 8;
  v32 = *(void (**)(char *, uint64_t))(v96 + 8);
  v32(v28, a2);
  v30(v26, a1, a2);
  if (!v31)
  {
    v32(v26, a2);
    v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v38 = v93;
    v40 = v94;
    goto LABEL_10;
  }
  v97 = 0x80;
  v33 = v95;
  if ((v95(a2, a3) & 1) != 0)
  {
    v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v35 = v34(a2, a3);
    v38 = v93;
    if (v35 >= 8)
    {
      v67 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v68 = lazy protocol witness table accessor for type Int8 and conformance Int8(v35, v36, v37);
      v86 = v34;
      v69 = v91;
      v67(&v97, v90, v68, a2, a3);
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v69, a2);
      v70 = v69;
      v34 = v86;
      v32(v70, a2);
      v32(v26, a2);
      v40 = v94;
      if ((v67 & 1) != 0)
        goto LABEL_40;
    }
    else
    {
      v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v32(v26, a2);
      v40 = v94;
      if (v97 > v39)
        goto LABEL_40;
    }
    goto LABEL_10;
  }
  v55 = v33(a2, a3);
  v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v56 = v86(a2, a3);
  if ((v55 & 1) != 0)
  {
    if (v56 > 8)
    {
      v59 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v60 = lazy protocol witness table accessor for type Int8 and conformance Int8(v56, v57, v58);
      v61 = v91;
      v59(&v97, v90, v60, a2, a3);
      LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v61, a2);
      v32(v61, a2);
      v32(v26, a2);
      v38 = v93;
      v40 = v94;
      v34 = v86;
      if ((v59 & 1) != 0)
        goto LABEL_40;
      goto LABEL_10;
    }
    v80 = (void (**)(char *, uint64_t, const char *))v87;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v82 = v91;
    v80[3](v11, a2, (const char *)v80);
    LOBYTE(v80) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v82, a2);
    v32(v82, a2);
    v83 = v88;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v88, v26, a2);
    v40 = v94;
    if ((v80 & 1) != 0)
    {
      v32(v83, a2);
LABEL_40:
      result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
      v64 = 0;
      v66 = 1;
      goto LABEL_41;
    }
    v84 = v97;
    v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v83, a2);
    v72 = v84 <= v85;
    v38 = v93;
    goto LABEL_39;
  }
  v38 = v93;
  if (v56 < 8)
  {
    v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v26, a2);
    v72 = v97 <= v71;
    v40 = v94;
LABEL_39:
    v34 = v86;
    if (!v72)
      goto LABEL_40;
LABEL_10:
    v41 = v34(a2, a3);
    goto LABEL_11;
  }
  v32(v26, a2);
  v40 = v94;
  v34 = v86;
  v41 = v86(a2, a3);
LABEL_11:
  v42 = v41;
  v43 = v92;
  v30(v92, a1, a2);
  if (v42 >= 9)
  {
    v32(v43, a2);
    v30(v38, a1, a2);
    goto LABEL_15;
  }
  v44 = v34(a2, a3);
  v32(v43, a2);
  if (v44 != 8)
  {
    v30(v38, a1, a2);
    goto LABEL_25;
  }
  v45 = v95(a2, a3);
  v30(v38, a1, a2);
  if ((v45 & 1) != 0)
  {
LABEL_25:
    v63 = v38;
    goto LABEL_26;
  }
LABEL_15:
  v99 = 127;
  v46 = v95(a2, a3);
  v47 = v34(a2, a3);
  if ((v46 & 1) != 0)
  {
    if (v47 > 8)
    {
      v50 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v51 = lazy protocol witness table accessor for type Int8 and conformance Int8(v47, v48, v49);
      v52 = v91;
      v50(&v99, v90, v51, a2, a3);
      v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v52, v38, a2);
      v32(v52, a2);
      v54 = v38;
      goto LABEL_34;
    }
    goto LABEL_23;
  }
  if (v47 <= 7)
  {
LABEL_23:
    v62 = v91;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v63 = v62;
LABEL_26:
    v32(v63, a2);
    goto LABEL_27;
  }
  v98 = 127;
  v73 = v91;
  v74 = (*(uint64_t (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
  v75 = *(void (**)(char *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v78 = lazy protocol witness table accessor for type Int8 and conformance Int8(v74, v76, v77);
  v79 = v89;
  v75(&v98, v90, v78, a2, a3);
  v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v79, v73, a2);
  v32(v79, a2);
  v54 = v73;
LABEL_34:
  v32(v54, a2);
  if ((v53 & 1) != 0)
    goto LABEL_40;
LABEL_27:
  v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
  v66 = 0;
LABEL_41:
  *v40 = v64;
  v40[1] = v66;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int8(_BYTE *a1@<X8>)
{
  char *v1;
  int v2;

  v2 = *v1;
  if (v2 < 0)
    v2 = -v2;
  *a1 = v2;
}

_BYTE *protocol witness for static Numeric.* infix(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3;

  v3 = (char)*result * (char)*a2;
  if ((char)(*result * *a2) == v3)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

uint64_t static Int8.* infix(_:_:)(char a1, char a2)
{
  uint64_t result;

  result = (a1 * a2);
  if ((char)(a1 * a2) != (_DWORD)result)
    __break(1u);
  return result;
}

_BYTE *protocol witness for static Numeric.*= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  int v2;

  v2 = (char)*result * (char)*a2;
  if ((char)(*result * *a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int8()
{
  char *v0;

  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
}

unsigned __int8 *protocol witness for Strideable.distance(to:) in conformance Int8@<X0>(unsigned __int8 *result@<X0>, uint64_t *a2@<X8>)
{
  _BYTE *v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;

  v3 = *result;
  v4 = (char)*v2;
  if (((v4 ^ v3) & 0x80) == 0)
  {
    v5 = (char)v3 - v4;
    if ((char)v5 == v5)
    {
      *a2 = (char)v5;
      return result;
    }
    __break(1u);
    goto LABEL_15;
  }
  if (v4 >= 0)
    LOBYTE(v6) = *v2;
  else
    v6 = -v4;
  if ((v3 & 0x80u) != 0)
    v3 = -(char)v3;
  v7 = v6 + v3;
  if (((v7 >> 8) & 1) != 0)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v4 < 0)
    v8 = v7;
  else
    v8 = -(uint64_t)v7;
  *a2 = v8;
  return result;
}

_QWORD *protocol witness for Strideable.advanced(by:) in conformance Int8@<X0>(_QWORD *result@<X0>, _BYTE *a2@<X8>)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;

  v3 = *v2;
  v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  if (v4 <= -129)
    goto LABEL_6;
  if (v4 >= 128)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int8(uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt8(uint64_t a1, uint64_t a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, _QWORD *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

_BYTE *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3;

  v3 = (char)*result + (char)*a2;
  if ((char)(*result + *a2) == v3)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  int v2;

  v2 = (char)*result + (char)*a2;
  if ((char)(*result + *a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int8@<X0>(_BYTE *result@<X0>, _BYTE *a2@<X1>, _BYTE *a3@<X8>)
{
  int v3;

  v3 = (char)*result - (char)*a2;
  if ((char)(*result - *a2) == v3)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

uint64_t static Int8.- infix(_:_:)(char a1, char a2)
{
  uint64_t result;

  result = (a1 - a2);
  if ((char)result != (_DWORD)result)
    __break(1u);
  return result;
}

_BYTE *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int8(_BYTE *result, _BYTE *a2)
{
  int v2;

  v2 = (char)*result - (char)*a2;
  if ((char)(*result - *a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a2 >= *a1;
}

BOOL static Int8.<= infix(_:_:)(char a1, char a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a1 >= *a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int8(char *a1, char *a2)
{
  return *a2 < *a1;
}

void Int8.hash(into:)(int a1, Swift::UInt8 a2)
{
  Hasher._combine(_:)(a2);
}

Swift::Int __swiftcall Int8._rawHashValue(seed:)(Swift::Int seed)
{
  unsigned __int8 v1;

  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 1);
}

uint64_t Int8.hashValue.getter(unsigned __int8 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 1);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int8(uint64_t a1)
{
  unsigned __int8 *v1;

  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 1);
}

uint64_t Int8._toCustomAnyHashable()@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int8>);
  *(_QWORD *)(a2 + 24) = result;
  *(_QWORD *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int8@<X0>(uint64_t a1@<X8>)
{
  char *v1;
  char v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int8>);
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_BYTE *)a1 = v3;
  return result;
}

uint64_t UInt16._value.setter(uint64_t result)
{
  _WORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt16 because it is either infinite or NaN", 80, 2, "Swift/IntegerTypes.swift", 24, 2, 0xC57uLL, 0);
  __asm { FCVT            S0, H0 }
  if (_S0 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt16 because the result would be less than UInt16.min", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0xC5AuLL, 0);
  return (int)_S0;
}

uint64_t UInt16.init(exactly:)(float _S0)
{
  float v6;
  int v9;
  int v10;

  __asm { FCVT            S1, H0 }
  if (_S1 <= -1.0)
  {
    v10 = 0;
    v9 = 1;
  }
  else
  {
    v6 = _S0;
    _S0 = truncf(_S1);
    __asm
    {
      FCVT            H0, S0
      FCVT            S0, H0
    }
    v9 = (~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1;
    v10 = (int)_S1;
    if (v9)
      v10 = 0;
  }
  return v10 | (v9 << 16);
}

Swift::UInt16 __swiftcall UInt16.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt16 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCA5uLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt16 because the result would be less than UInt16.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCA8uLL, 0);
  if (a1 >= 65536.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt16 because the result would be greater than UInt16.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCABuLL, 0);
  return (int)a1;
}

Swift::UInt16_optional __swiftcall UInt16.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  int v5;

  v1 = exactly > -1.0;
  if (exactly >= 65536.0)
    v1 = 0;
  v3 = v1 & (truncf(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    v5 = 0;
  else
    v5 = (int)exactly;
  return (Swift::UInt16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

Swift::UInt16 __swiftcall UInt16.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt16 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCEDuLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt16 because the result would be less than UInt16.min", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCF0uLL, 0);
  if (a1 >= 65536.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt16 because the result would be greater than UInt16.max", 94, 2, "Swift/IntegerTypes.swift", 24, 2, 0xCF3uLL, 0);
  return (int)a1;
}

Swift::UInt16_optional __swiftcall UInt16.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  int v5;

  v1 = exactly > -1.0;
  if (exactly >= 65536.0)
    v1 = 0;
  v3 = v1 & (trunc(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    v5 = 0;
  else
    v5 = (int)exactly;
  return (Swift::UInt16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

_WORD *static UInt16.+= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  int v2;

  v2 = (unsigned __int16)*result + a2;
  if ((v2 & 0x10000) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

_WORD *static UInt16.-= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  int v2;

  v2 = (unsigned __int16)*result - a2;
  if ((v2 & 0xFFFF0000) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

_WORD *static UInt16.*= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if ((((unsigned __int16)*result * a2) & 0xFFFF0000) != 0)
    __break(1u);
  else
    *result *= a2;
  return result;
}

_WORD *static UInt16./= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.addingReportingOverflow(_:)(Swift::UInt16 a1)
{
  __int16 v1;
  Swift::UInt16 v2;
  Swift::tuple_partialValue_UInt16_overflow_Bool result;

  v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.subtractingReportingOverflow(_:)(Swift::UInt16 a1)
{
  __int16 v1;
  Swift::UInt16 v2;
  Swift::tuple_partialValue_UInt16_overflow_Bool result;

  v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.multipliedReportingOverflow(by:)(Swift::UInt16 by)
{
  __int16 v1;
  Swift::UInt16 v2;
  Swift::tuple_partialValue_UInt16_overflow_Bool result;

  v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.dividedReportingOverflow(by:)(Swift::UInt16 by)
{
  unsigned __int16 v1;
  Swift::UInt16 v2;
  Swift::tuple_partialValue_UInt16_overflow_Bool result;

  if (by)
    v1 /= by;
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt16_overflow_Bool __swiftcall UInt16.remainderReportingOverflow(dividingBy:)(Swift::UInt16 dividingBy)
{
  unsigned __int16 v1;
  Swift::UInt16 v2;
  Swift::tuple_partialValue_UInt16_overflow_Bool result;

  if (dividingBy)
    v1 %= dividingBy;
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

_WORD *static UInt16.%= infix(_:_:)(_WORD *result, unsigned __int16 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  *result %= a2;
  return result;
}

uint64_t UInt16._lowWord.getter(uint64_t result)
{
  return (unsigned __int16)result;
}

uint64_t UInt16.Words._value.setter(uint64_t result)
{
  _WORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt16.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.Words.count.getter()
{
  return 1;
}

uint64_t UInt16.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt16.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt16.Words.indices.getter()
{
  return 0;
}

uint64_t UInt16.Words.subscript.getter(uint64_t a1, unsigned __int16 a2)
{
  if (a1 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0xFB2uLL, 0);
  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0xFB3uLL, 0);
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt16.Words(uint64_t *a1, uint64_t *a2))()
{
  unsigned __int16 *v2;

  *a1 = UInt16.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance UInt16.Words()
{
  unsigned __int16 *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt16.Words(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unsigned __int16 *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt16_low_UInt16 __swiftcall UInt16.multipliedFullWidth(by:)(Swift::UInt16 by)
{
  Swift::UInt16 v1;
  Swift::UInt16 v2;
  Swift::tuple_high_UInt16_low_UInt16 result;

  v2 = (v1 * by) >> 16;
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt16_remainder_UInt16 __swiftcall UInt16.dividingFullWidth(_:)(Swift::tuple_high_UInt16_low_UInt16 a1)
{
  unsigned __int16 v1;
  unsigned int v2;
  Swift::UInt16 v3;
  Swift::tuple_quotient_UInt16_remainder_UInt16 result;

  if (!v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1018uLL, 0);
  if (a1.high >= v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x101AuLL, 0);
  v2 = a1.low | (a1.high << 16);
  v3 = v2 / v1;
  result.remainder = v2;
  result.quotient = v3;
  return result;
}

BOOL static UInt16.> infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a2 < a1;
}

Swift::UInt16 __swiftcall UInt16.signum()()
{
  __int16 v0;

  return v0 != 0;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt16()
{
  return 16;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = -1;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt16(_WORD *a1, _WORD *a2)
{
  _WORD *v2;
  uint64_t v3;

  v3 = ((unsigned __int16)*v2 + (unsigned __int16)*a2) >> 16;
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt16(_WORD *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  int v3;

  v3 = *v2 - *a2;
  *a1 = v3;
  return (v3 & 0xFFFF0000) != 0;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt16(_WORD *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v2;
  int v3;

  v3 = *v2 * *a2;
  *a1 = v3;
  return (v3 & 0xFFFF0000) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt16(_WORD *a1, _WORD *a2)
{
  unsigned __int16 *v2;
  unsigned int v3;
  unsigned int v4;

  v3 = (unsigned __int16)*a2;
  v4 = *v2;
  if (*a2)
    v4 /= v3;
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt16(_WORD *a1, _WORD *a2)
{
  unsigned __int16 *v2;
  unsigned int v3;
  unsigned int v4;

  v3 = (unsigned __int16)*a2;
  v4 = *v2;
  if (*a2)
    v4 %= v3;
  *a1 = v4;
  return v3 == 0;
}

_WORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt16(_WORD *result, _WORD *a2, unsigned __int16 *a3)
{
  unsigned __int16 *v3;
  int v4;

  v4 = *v3 * *a3;
  *result = HIWORD(v4);
  *a2 = v4;
  return result;
}

Swift::UInt16 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt16(Swift::UInt16 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  Swift::UInt16 result;
  __int16 v7;

  result = UInt16.dividingFullWidth(_:)((Swift::tuple_high_UInt16_low_UInt16)__PAIR32__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

unsigned __int16 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result >> (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt16(_WORD *result, _WORD *a2)
{
  *result = (unsigned __int16)*result >> (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt16@<X0>(_WORD *result@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  if (a2 >> 9 <= 8 && (a2 & 1) == 0)
    *a3 = *result;
  else
    *a3 = 0;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16 and conformance UInt16, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _WORD *a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  char v23;
  uint64_t v24;
  unint64_t AssociatedConformanceWitness;
  char *v26;
  char v27;
  void (*v28)(char *, uint64_t);
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  void (*v36)(char *, uint64_t);
  unsigned int v37;
  char *v38;
  unsigned __int16 v39;
  char v40;
  unsigned __int16 v41;
  __int16 v42;
  uint64_t result;
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  _WORD *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  unsigned __int16 v53;

  v46 = a4;
  v47 = a5;
  v49 = a6;
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v48 = (char *)&v44 - v12;
  v52 = *(_QWORD *)(a2 - 8);
  v13 = MEMORY[0x1E0C80A78](v11);
  v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v51 = (char *)&v44 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v44 - v18;
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v44 - v20;
  v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v23 = v22(a2, a3);
  v50 = a1;
  if ((v23 & 1) != 0)
  {
    v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 32))(v21, v19, a2);
    v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    v28(v21, a2);
    a1 = v50;
  }
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v30 = a1;
  if (v29(a2, a3) >= 16)
  {
    v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    v53 = -1;
    v31 = v22(a2, a3);
    v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 17)
      {
        v33 = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 40))(v51, v19, a2);
        v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        v37 = v53;
        v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        v30 = v50;
        if ((v34 & 1) != 0)
        {
          v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39)
            goto LABEL_14;
        }
        else
        {
          v36(v38, a2);
        }
        goto LABEL_16;
      }
    }
    else if (v32 <= 16)
    {
      v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      v30 = v50;
      if (v53 < v41)
        goto LABEL_14;
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }
    (*(void (**)(unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    v35 = v51;
    v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v19, v51, a2);
    v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    v30 = v50;
    if ((v40 & 1) != 0)
LABEL_14:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    goto LABEL_16;
  }
LABEL_17:
  v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *v49 = v42;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt16@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt16 and conformance UInt16((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt16()
{
  unsigned __int16 *v0;

  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt16()
{
  unsigned __int16 *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_WORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  *a3 = *result / *a2;
  return result;
}

uint64_t static UInt16./ infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  return a1 / a2;
}

_WORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt16(_WORD *result, _WORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  *result /= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  *a3 = *result % *a2;
  return result;
}

uint64_t static UInt16.% infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  return a1 % a2;
}

_WORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt16(_WORD *result, _WORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0xEB5uLL, 0);
  *result %= *a2;
  return result;
}

uint64_t static UInt16.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt16@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t v52;
  char *v53;
  void (*v54)(char *, uint64_t);
  unsigned int v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t (*v63)(char *, uint64_t);
  uint64_t v64;
  void (*v65)(char *, uint64_t, uint64_t);
  char *v66;
  char v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char v86;
  void (*v87)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v88;
  char v89;
  void (**v90)(char *, uint64_t, const char *);
  unint64_t v91;
  unint64_t AssociatedConformanceWitness;
  char *v93;
  char *v94;
  char *v95;
  int64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  char *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  int64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t (*v115)(char *, uint64_t);
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  unsigned int v122;
  char *v123;
  char *v124;
  uint64_t (*v125)(uint64_t, uint64_t);
  _WORD *v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v126 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v114 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v123 = (char *)&v114 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v117 = (char *)&v114 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v114 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v124 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v122 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v121 = v19;
  v127 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v129 = -16;
      v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -16)
        goto LABEL_24;
    }
LABEL_18:
    v56 = v127(a3, a4);
    v57 = v33(a3, a4);
    v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64)
        goto LABEL_20;
    }
    else if (v57 > 63)
    {
LABEL_20:
      v129 = 16;
      v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
      v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v66 = v124;
        v65(v124, a2, a3);
        v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          v71 = v123;
          v70 = v124;
          v68 = v125;
          v79 = v125(a3, a4);
          goto LABEL_47;
        }
        v68 = v125;
        v69 = v125(a3, a4);
        v63(v26, a3);
        v71 = v123;
        v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          v79 = v68(a3, a4);
LABEL_47:
          v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            v109 = v68(a3, a4);
            v63(v71, a3);
            v110 = v109 == 64;
            v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              result = v63(v70, a3);
              if ((v112 & 0x8000000000000000) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFF0)
                {
                  v55 = v122 << -(char)v112;
                  goto LABEL_64;
                }
              }
              else if (v112 < 0x10)
              {
                v55 = v122 >> v112;
                goto LABEL_64;
              }
              goto LABEL_24;
            }
          }
          else
          {
            v63(v71, a3);
            v100 = v127;
          }
          v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          v129 = 0x7FFFFFFFFFFFFFFFLL;
          v102 = v100(a3, a4);
          v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              v108 = &v129;
              goto LABEL_59;
            }
          }
          else if (v103 > 63)
          {
            v128 = 0x7FFFFFFFFFFFFFFFLL;
            v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v101, a3);
            v63(v30, a3);
            if ((v111 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_60;
          }
          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }
        v115 = v63;
        v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        v129 = 0x8000000000000000;
        v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            v77 = v72;
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129)
LABEL_69:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
            goto LABEL_44;
          }
          v77 = v72;
          v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v77, v30, a3);
        }
        else
        {
          v80 = v73(a3, a4);
          v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            v63 = v115;
            if (v81 > 64)
            {
              v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }
            v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }
          if (v81 <= 64)
          {
            v91 = AssociatedTypeWitness;
            v90 = (void (**)(char *, uint64_t, const char *))v120;
            AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))(&qword_1816B7DA8, 256, v91, AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v117, v30, a3);
            v115(v30, a3);
            v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }
            v96 = v129;
            v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v95, a3);
            v98 = v97 < v96;
            v70 = v124;
            v77 = v117;
            if (v98)
              goto LABEL_69;
LABEL_44:
            v113 = v77;
            goto LABEL_45;
          }
          v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          v77 = v117;
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
        }
        v89 = v86;
        v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0)
          goto LABEL_69;
        goto LABEL_44;
      }
LABEL_24:
      LOWORD(v55) = 0;
      goto LABEL_64;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v63(v30, a3);
    if (v64 <= 16)
      goto LABEL_25;
    goto LABEL_24;
  }
  v39 = v31(a3, a4);
  v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      v33 = v125;
      goto LABEL_18;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }
  if (v40 > 64)
  {
    v129 = -16;
    v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    v33 = v125;
    if ((v45 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v50 = AssociatedTypeWitness;
  v51 = v120;
  v52 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))(&qword_1816B7DA8, 256, v50, v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
  v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    v33 = v125;
    if (v49 < -16)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  LOWORD(v55) = 0;
LABEL_64:
  *v126 = v55;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt16(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t (*v39)(uint64_t, uint64_t);
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unsigned int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t AssociatedConformanceWitness;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unsigned int v130;
  char *v131;
  uint64_t (*v132)(uint64_t, uint64_t);
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v144 = -16;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 < -16)
        goto LABEL_24;
    }
LABEL_18:
    v62 = v141(a3, a4);
    v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64)
        goto LABEL_20;
    }
    else if (v63 >= 64)
    {
LABEL_20:
      v144 = 16;
      v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
      v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v74 = v140;
        v73(v140, a2, a3);
        v75 = v141(a3, a4);
        v76 = v139;
        v77 = v74;
        v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          v80 = v140;
          goto LABEL_42;
        }
        v79 = v32(a3, a4);
        v70(v76, a3);
        v80 = v140;
        if (v79 <= 64)
          goto LABEL_42;
        v81 = v135;
        v78(v135, v140, a3);
        v144 = 0x8000000000000000;
        v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v135, v88, a3);
            v89 = v88;
            v81 = v135;
            v70(v89, a3);
            if ((v86 & 1) != 0)
              goto LABEL_64;
            goto LABEL_41;
          }
        }
        else
        {
          v90 = v82(a3, a4);
          v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              v102 = (void (**)(char *, uint64_t, const char *))v137;
              v103 = v133;
              AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v103, AssociatedConformanceWitness);
              v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                + 16))(v135, v106, a3);
              v108 = v106;
              v81 = v107;
              v70(v108, a3);
              v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }
              v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              v112 = v111 < v110;
              v80 = v140;
              if (v112)
                goto LABEL_64;
            }
            else
            {
              v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              v97 = v135;
              v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
              v99 = v96;
              v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0)
                goto LABEL_64;
            }
            goto LABEL_41;
          }
          if (v91 >= 64)
            goto LABEL_41;
        }
        v100 = v142;
        v78(v142, v81, a3);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144)
LABEL_64:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        v113 = v132;
        v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          v124 = v113(a3, a4);
          v70(v115, a3);
          v125 = v124 == 64;
          v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            result = v70(v80, a3);
            v130 = *(unsigned __int16 *)v39;
            if ((v129 & 0x8000000000000000) != 0)
            {
              if (v129 >= 0xFFFFFFFFFFFFFFF1)
              {
                v61 = v130 << -(char)v129;
                goto LABEL_59;
              }
            }
            else if (v129 < 0x10)
            {
              v61 = v130 >> v129;
              goto LABEL_59;
            }
            goto LABEL_24;
          }
        }
        else
        {
          v70(v115, a3);
          v116 = v141;
        }
        v78(v40, v80, a3);
        v144 = 0x7FFFFFFFFFFFFFFFLL;
        v117 = v116(a3, a4);
        v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            v123 = &v144;
            goto LABEL_54;
          }
        }
        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          v123 = &v143;
LABEL_54:
          v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
          v70(v127, a3);
          if ((v128 & 1) != 0)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          goto LABEL_55;
        }
        v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }
LABEL_24:
      LOWORD(v61) = 0;
      goto LABEL_59;
    }
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 16)
      goto LABEL_25;
    goto LABEL_24;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_18;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }
  if (v42 > 64)
  {
    v144 = -16;
    v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    v40 = v131;
    v39 = v132;
    if ((v48 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v55 = v137;
  v56 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v56);
  v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
  v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 < -16)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOWORD(v61) = 0;
  v39 = v132;
LABEL_59:
  *(_WORD *)v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt16@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t AssociatedConformanceWitness;
  char *v50;
  void (*v51)(char *, uint64_t);
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void (*v57)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v58;
  uint64_t (*v59)(char *, uint64_t);
  void (*v60)(void);
  char *v61;
  char v62;
  uint64_t v63;
  char *v64;
  char *v65;
  uint64_t (*v66)(uint64_t, uint64_t);
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  unsigned int v73;
  _WORD *v74;
  uint64_t (*v75)(uint64_t, uint64_t);
  uint64_t v76;
  char *v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v83;
  int64_t *v84;
  uint64_t v85;
  char v86;
  unint64_t v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void (*v92)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v93;
  char v94;
  void (*v95)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v96;
  char v97;
  char *v98;
  uint64_t v99;
  void (**v100)(char *, uint64_t, const char *);
  unint64_t v101;
  unint64_t v102;
  char *v103;
  char *v104;
  char *v105;
  int64_t v106;
  uint64_t v107;
  BOOL v108;
  char *v109;
  char *v110;
  char *v111;
  unint64_t AssociatedTypeWitness;
  char *v113;
  unsigned int v114;
  char *v115;
  char *v116;
  char *v117;
  _WORD *v118;
  uint64_t (*v119)(uint64_t, uint64_t);
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t v121;
  int64_t v122;

  v118 = a5;
  v113 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v113, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v111 = (char *)&v109 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v109 = (char *)&v109 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v109 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v115 = (char *)&v109 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v110 = (char *)&v109 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v109 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v117 = (char *)&v109 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v109 - v28;
  v114 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v119 = v30;
  if ((v31 & 1) != 0)
  {
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v122 = -16;
      v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v44(&v122, &type metadata for Int, v45, a3, a4);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if ((v44 & 1) != 0)
        goto LABEL_29;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v36 < -16)
        goto LABEL_29;
    }
  }
  else
  {
    v38 = v30(a3, a4);
    v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v120(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 <= 64)
      {
        v47 = AssociatedTypeWitness;
        v48 = v113;
        AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v113, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v50 = v111;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v47, AssociatedConformanceWitness);
        (*((void (**)(char *, uint64_t, const char *))v48 + 3))(v50, a3, v48);
        LOBYTE(v47) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        v51 = *(void (**)(char *, uint64_t))(v11 + 8);
        v51(v29, a3);
        (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
        if ((v47 & 1) != 0)
        {
          result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
          goto LABEL_29;
        }
        v52 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        result = ((uint64_t (*)(char *, uint64_t))v51)(v14, a3);
        v30 = v119;
        v32 = v120;
        if (v52 < -16)
          goto LABEL_29;
      }
      else
      {
        v122 = -16;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v122, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v119;
        v32 = v120;
        if ((v42 & 1) != 0)
          goto LABEL_29;
      }
    }
    else if (v39 <= 64)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v30 = v119;
      v32 = v120;
      if (v46 < -16)
        goto LABEL_29;
    }
    else
    {
      v30 = v119;
      v32 = v120;
    }
  }
  v120 = v32;
  v53 = v30(a3, a4);
  v54 = v32(a3, a4);
  if ((v53 & 1) != 0)
  {
    if (v54 > 64)
      goto LABEL_20;
  }
  else if (v54 > 63)
  {
LABEL_20:
    v122 = 16;
    v57 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v58 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v57(&v122, &type metadata for Int, v58, a3, a4);
    LOBYTE(v57) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v59(v29, a3);
    if ((v57 & 1) == 0)
      goto LABEL_21;
    goto LABEL_29;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v59 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v59(v29, a3);
  if (v72 <= 16)
  {
LABEL_21:
    v60 = *(void (**)(void))(v11 + 16);
    v61 = v117;
    v60();
    v62 = v119(a3, a4);
    ((void (*)(char *, char *, uint64_t))v60)(v25, v61, a3);
    if ((v62 & 1) == 0)
    {
      v71 = v25;
      v64 = v116;
      goto LABEL_31;
    }
    v63 = v120(a3, a4);
    v59(v25, a3);
    v64 = v116;
    if (v63 < 65)
      goto LABEL_32;
    v65 = v110;
    ((void (*)(char *, char *, uint64_t))v60)(v110, v61, a3);
    v122 = 0x8000000000000000;
    v66 = v119;
    if ((v119(a3, a4) & 1) != 0)
    {
      v67 = v120(a3, a4);
      if (v67 < 64)
      {
        ((void (*)(char *, char *, uint64_t))v60)(v29, v65, a3);
        v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v59(v29, a3);
        v71 = v65;
        if (v70 < v122)
          goto LABEL_68;
        goto LABEL_31;
      }
      v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v96 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v95(&v122, &type metadata for Int, v96, a3, a4);
      v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v65, v29, a3);
LABEL_53:
      v97 = v94;
      v59(v29, a3);
      v71 = v65;
      if ((v97 & 1) != 0)
        goto LABEL_68;
LABEL_31:
      v59(v71, a3);
LABEL_32:
      v75 = v120;
      v76 = v120(a3, a4);
      v77 = v115;
      ((void (*)(char *, char *, uint64_t))v60)(v115, v61, a3);
      if (v76 < 65)
      {
        v85 = v75(a3, a4);
        v59(v77, a3);
        if (v85 != 64 || (v119(a3, a4) & 1) != 0)
        {
LABEL_45:
          v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          result = v59(v61, a3);
          if ((v87 & 0x8000000000000000) != 0)
          {
            v74 = v118;
            if (v87 > 0xFFFFFFFFFFFFFFF0)
            {
              v73 = v114 >> -(char)v87;
              goto LABEL_48;
            }
          }
          else
          {
            v74 = v118;
            if (v87 <= 0xF)
            {
              v73 = v114 << v87;
              goto LABEL_48;
            }
          }
          LOWORD(v73) = 0;
          goto LABEL_48;
        }
      }
      else
      {
        v59(v77, a3);
      }
      ((void (*)(char *, char *, uint64_t))v60)(v64, v61, a3);
      v122 = 0x7FFFFFFFFFFFFFFFLL;
      v78 = v119(a3, a4);
      v79 = v120(a3, a4);
      if ((v78 & 1) != 0)
      {
        if (v79 > 64)
        {
          v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
          v84 = &v122;
          goto LABEL_43;
        }
      }
      else if (v79 > 63)
      {
        v121 = 0x7FFFFFFFFFFFFFFFLL;
        v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        v84 = &v121;
LABEL_43:
        v82(v84, &type metadata for Int, v83, a3, a4);
        v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v64, a3);
        v59(v29, a3);
        if ((v86 & 1) != 0)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
        goto LABEL_44;
      }
      ((void (*)(char *, char *, uint64_t))v60)(v29, v64, a3);
      (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
LABEL_44:
      v59(v64, a3);
      goto LABEL_45;
    }
    v88 = v66(a3, a4);
    v89 = v120(a3, a4);
    if ((v88 & 1) != 0)
    {
      if (v89 > 64)
      {
        v92 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v93 = lazy protocol witness table accessor for type Int and conformance Int(v89, v90, v91);
        v92(&v122, &type metadata for Int, v93, a3, a4);
        v65 = v110;
        v94 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v110, v29, a3);
        goto LABEL_53;
      }
      v101 = AssociatedTypeWitness;
      v100 = (void (**)(char *, uint64_t, const char *))v113;
      v102 = swift_getAssociatedConformanceWitness((uint64_t)v113, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v103 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v102 + 8))(&qword_1816B7DA8, 256, v101, v102);
      v100[3](v103, a3, (const char *)v100);
      v104 = v110;
      LOBYTE(v100) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v110, v29, a3);
      v59(v29, a3);
      v105 = v109;
      ((void (*)(char *, char *, uint64_t))v60)(v109, v104, a3);
      if ((v100 & 1) != 0)
      {
        v59(v105, a3);
        goto LABEL_68;
      }
      v106 = v122;
      v107 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v105, a3);
      v108 = v107 < v106;
      v61 = v117;
      v71 = v110;
      if (!v108)
        goto LABEL_31;
    }
    else
    {
      if (v89 > 64)
      {
        v71 = v110;
        goto LABEL_31;
      }
      v98 = v110;
      ((void (*)(char *, char *, uint64_t))v60)(v29, v110, a3);
      v99 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v29, a3);
      v71 = v98;
      if (v99 >= v122)
        goto LABEL_31;
    }
LABEL_68:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
LABEL_29:
  LOWORD(v73) = 0;
  v74 = v118;
LABEL_48:
  *v74 = v73;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt16(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t (*v39)(uint64_t, uint64_t);
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unsigned int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t AssociatedConformanceWitness;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unsigned int v130;
  char *v131;
  uint64_t (*v132)(uint64_t, uint64_t);
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v144 = -16;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 < -16)
        goto LABEL_24;
    }
LABEL_18:
    v62 = v141(a3, a4);
    v63 = v32(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64)
        goto LABEL_20;
    }
    else if (v63 >= 64)
    {
LABEL_20:
      v144 = 16;
      v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
      v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v74 = v140;
        v73(v140, a2, a3);
        v75 = v141(a3, a4);
        v76 = v139;
        v77 = v74;
        v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          v80 = v140;
          goto LABEL_42;
        }
        v79 = v32(a3, a4);
        v70(v76, a3);
        v80 = v140;
        if (v79 <= 64)
          goto LABEL_42;
        v81 = v135;
        v78(v135, v140, a3);
        v144 = 0x8000000000000000;
        v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          v83 = v132(a3, a4);
          if (v83 >= 64)
          {
            v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v135, v88, a3);
            v89 = v88;
            v81 = v135;
            v70(v89, a3);
            if ((v86 & 1) != 0)
              goto LABEL_64;
            goto LABEL_41;
          }
        }
        else
        {
          v90 = v82(a3, a4);
          v91 = v132(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              v102 = (void (**)(char *, uint64_t, const char *))v137;
              v103 = v133;
              AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v103, AssociatedConformanceWitness);
              v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                + 16))(v135, v106, a3);
              v108 = v106;
              v81 = v107;
              v70(v108, a3);
              v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }
              v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              v112 = v111 < v110;
              v80 = v140;
              if (v112)
                goto LABEL_64;
            }
            else
            {
              v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              v97 = v135;
              v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
              v99 = v96;
              v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0)
                goto LABEL_64;
            }
            goto LABEL_41;
          }
          if (v91 >= 64)
            goto LABEL_41;
        }
        v100 = v142;
        v78(v142, v81, a3);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144)
LABEL_64:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        v113 = v132;
        v114 = v132(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          v124 = v113(a3, a4);
          v70(v115, a3);
          v125 = v124 == 64;
          v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            result = v70(v80, a3);
            v130 = *(unsigned __int16 *)v39;
            if ((v129 & 0x8000000000000000) != 0)
            {
              if (v129 > 0xFFFFFFFFFFFFFFF0)
              {
                v61 = v130 >> -(char)v129;
                goto LABEL_59;
              }
            }
            else if (v129 < 0x10)
            {
              v61 = v130 << v129;
              goto LABEL_59;
            }
            goto LABEL_24;
          }
        }
        else
        {
          v70(v115, a3);
          v116 = v141;
        }
        v78(v40, v80, a3);
        v144 = 0x7FFFFFFFFFFFFFFFLL;
        v117 = v116(a3, a4);
        v118 = v132(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            v123 = &v144;
            goto LABEL_54;
          }
        }
        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          v123 = &v143;
LABEL_54:
          v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
          v70(v127, a3);
          if ((v128 & 1) != 0)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          goto LABEL_55;
        }
        v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }
LABEL_24:
      LOWORD(v61) = 0;
      goto LABEL_59;
    }
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 16)
      goto LABEL_25;
    goto LABEL_24;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_18;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }
  if (v42 > 64)
  {
    v144 = -16;
    v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    v40 = v131;
    v39 = v132;
    if ((v48 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v55 = v137;
  v56 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v56);
  v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
  v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 < -16)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  LOWORD(v61) = 0;
  v39 = v132;
LABEL_59:
  *(_WORD *)v39 = v61;
  return result;
}

_WORD *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt16(_WORD *result, _WORD *a2, _WORD *a3)
{
  _WORD *v3;
  __int16 v4;

  if (!*a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  v4 = *v3 / *a3;
  *a2 = *v3 % *a3;
  *result = v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt16(unsigned __int16 *a1)
{
  unsigned __int16 *v1;

  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt16(_WORD *a1@<X8>)
{
  _WORD *v1;

  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char v23;
  void (*v24)(char *, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v26;
  void (*v27)(char *, uint64_t);
  char *v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  char *v34;
  uint64_t (*v35)(uint64_t, _QWORD *);
  uint64_t v36;
  char *v37;
  __int16 v38;
  uint64_t result;
  char v40;
  void (*v41)(char *, uint64_t);
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  unsigned int v53;
  char *v54;
  unsigned __int16 v55;
  BOOL v56;
  void (*v57)(unsigned __int16 *, uint64_t, unint64_t, uint64_t, _QWORD *);
  unint64_t v58;
  char *v59;
  char *v60;
  unsigned __int16 v61;
  char *v62;
  unint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  char *v67;
  uint64_t (*v68)(uint64_t, _QWORD *);
  void (*v69)(char *, uint64_t, uint64_t);
  char *v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int16 v73;

  v66 = a4;
  v71 = a5;
  v8 = *(_QWORD *)(a3[3] + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v62 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v65 = (char *)&v62 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v70 = (char *)&v62 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v62 - v19;
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v62 - v21;
  v68 = (uint64_t (*)(uint64_t, _QWORD *))a3[8];
  v23 = v68(a2, a3);
  v24 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v72 = a1;
  v69 = v24;
  v24(v22, a1, a2);
  v67 = v20;
  v63 = AssociatedTypeWitness;
  v64 = v8;
  v62 = v12;
  if ((v23 & 1) != 0)
  {
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a2, v8);
    v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(a3[4] + 8) + 16))(v22, v20, a2);
    v27 = *(void (**)(char *, uint64_t))(v13 + 8);
    v27(v20, a2);
    v28 = v22;
    v29 = v27;
    v27(v28, a2);
    v31 = v71;
    v30 = v72;
    v32 = v13;
    v33 = a3;
    if ((v26 & 1) != 0)
      goto LABEL_17;
  }
  else
  {
    v34 = v22;
    v29 = *(void (**)(char *, uint64_t))(v13 + 8);
    v29(v34, a2);
    v30 = v72;
    v32 = v13;
    v33 = a3;
  }
  v35 = (uint64_t (*)(uint64_t, _QWORD *))v33[16];
  v36 = v35(a2, v33);
  v37 = v70;
  v69(v70, v30, a2);
  if (v36 <= 15)
  {
    v29(v37, a2);
    v31 = v71;
    goto LABEL_7;
  }
  v41 = v29;
  v73 = -1;
  v42 = v68(a2, v33);
  v43 = v35(a2, v33);
  if ((v42 & 1) != 0)
  {
    if (v43 < 17)
    {
      v47 = v63;
      v46 = v64;
      v48 = swift_getAssociatedConformanceWitness(v64, a2, v63, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v49 = v62;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v48 + 8))(&qword_1816B7DA8, 256, v47, v48);
      v50 = v67;
      (*(void (**)(char *, uint64_t, uint64_t))(v46 + 24))(v49, a2, v46);
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v33[4] + 8) + 40))(v37, v50, a2);
      v51 = v50;
      v29 = v41;
      v41(v51, a2);
      v52 = v37;
      v53 = v73;
      v54 = v65;
      (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v65, v52, a2);
      if ((v46 & 1) == 0)
      {
        v41(v54, a2);
        v31 = v71;
        v30 = v72;
        goto LABEL_7;
      }
      v55 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
      v41(v54, a2);
      v56 = v53 >= v55;
      goto LABEL_16;
    }
LABEL_13:
    v57 = (void (*)(unsigned __int16 *, uint64_t, unint64_t, uint64_t, _QWORD *))v33[12];
    v58 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v43, v44, v45);
    v59 = v67;
    v57(&v73, v66, v58, a2, v33);
    LOBYTE(v57) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v33[4] + 8) + 16))(v59, v37, a2);
    v29 = v41;
    v41(v59, a2);
    v41(v37, a2);
    v31 = v71;
    v30 = v72;
    if ((v57 & 1) != 0)
      goto LABEL_17;
    goto LABEL_7;
  }
  if (v43 >= 17)
    goto LABEL_13;
  v60 = v67;
  (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v67, v37, a2);
  v61 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
  v29 = v41;
  v41(v60, a2);
  v56 = v73 >= v61;
LABEL_16:
  v31 = v71;
  v30 = v72;
  if (!v56)
  {
LABEL_17:
    result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
    v38 = 0;
    v40 = 1;
    goto LABEL_18;
  }
LABEL_7:
  v38 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
  result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
  v40 = 0;
LABEL_18:
  *(_WORD *)v31 = v38;
  *(_BYTE *)(v31 + 2) = v40;
  return result;
}

unsigned __int16 *protocol witness for static Numeric.* infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;

  v3 = *result * *a2;
  if ((v3 & 0xFFFF0000) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

uint64_t static UInt16.* infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result;

  result = a1 * a2;
  if ((result & 0xFFFF0000) != 0)
    __break(1u);
  return result;
}

_WORD *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt16(_WORD *result, unsigned __int16 *a2)
{
  int v2;

  v2 = (unsigned __int16)*result * *a2;
  if ((v2 & 0xFFFF0000) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt16()
{
  unsigned __int16 *v0;

  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

unsigned __int16 *protocol witness for Strideable.distance(to:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, uint64_t *a2@<X8>)
{
  unsigned __int16 *v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;

  v3 = *result;
  v4 = *v2;
  v5 = v4 - v3;
  v6 = v3 >= v4;
  v7 = v3 - v4;
  if (!v6)
    v7 = -v5;
  *a2 = v7;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt16@<X0>(unint64_t *result@<X0>, _WORD *a2@<X8>)
{
  unsigned __int16 *v2;
  unint64_t v3;
  int v4;
  unint64_t v5;

  v3 = *result;
  v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (v3 >= 0x10000)
      goto LABEL_8;
    v4 += (unsigned __int16)v3;
    v3 = (unsigned __int16)v4;
    if ((unsigned __int16)v4 == v4)
    {
LABEL_7:
      *a2 = v4;
      return result;
    }
    __break(1u);
  }
  v5 = -(uint64_t)v3;
  if (v5 >= 0x10000)
LABEL_8:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  v4 -= (unsigned __int16)v5;
  if ((v4 & 0xFFFF0000) == 0)
    goto LABEL_7;
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

unsigned __int16 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;

  v3 = *result + *a2;
  if ((v3 & 0x10000) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

_WORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt16(_WORD *result, unsigned __int16 *a2)
{
  int v2;

  v2 = (unsigned __int16)*result + *a2;
  if ((v2 & 0x10000) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

unsigned __int16 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;

  v3 = *result - *a2;
  if ((v3 & 0xFFFF0000) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

_WORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt16(_WORD *result, unsigned __int16 *a2)
{
  int v2;

  v2 = (unsigned __int16)*result - *a2;
  if ((v2 & 0xFFFF0000) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 >= *a2;
}

BOOL static UInt16.>= infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a2 < *a1;
}

uint64_t UInt16.hashValue.getter(unsigned __int16 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 2);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance UInt16()
{
  unsigned __int16 *v0;

  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 2);
}

uint64_t UInt16._toCustomAnyHashable()@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt16>);
  *(_QWORD *)(a2 + 24) = result;
  *(_QWORD *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt16@<X0>(uint64_t a1@<X8>)
{
  __int16 *v1;
  __int16 v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt16>);
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a1 = v3;
  return result;
}

uint64_t Int16._value.setter(uint64_t result)
{
  _WORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int16 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x123CuLL, 0);
  __asm { FCVT            S0, H0 }
  if (_S0 <= -32800.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int16 because the result would be less than Int16.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x123FuLL, 0);
  if (_S0 >= 32768.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int16 because the result would be greater than Int16.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1242uLL, 0);
  return (int)_S0;
}

uint64_t Int16.init(exactly:)(__n128 _Q0)
{
  BOOL v6;
  int v9;
  char v10;
  int v11;

  __asm { FCVT            S0, H0 }
  v6 = _S0 > -32800.0;
  if (_S0 >= 32768.0)
    v6 = 0;
  _S1 = truncf(_S0);
  __asm
  {
    FCVT            H1, S1
    FCVT            S1, H1
  }
  v9 = v6 && _S1 == _S0;
  _ZF = v9 == 0;
  v10 = ~(_BYTE)v9;
  if (_ZF)
    v11 = 0;
  else
    v11 = (unsigned __int16)(int)_S0;
  return v11 & 0xFFFEFFFF | ((v10 & 1) << 16);
}

Swift::Int16 __swiftcall Int16.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int16 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1288uLL, 0);
  if (a1 <= -32769.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int16 because the result would be less than Int16.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x128BuLL, 0);
  if (a1 >= 32768.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int16 because the result would be greater than Int16.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x128EuLL, 0);
  return (int)a1;
}

Swift::Int16_optional __swiftcall Int16.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  int v5;

  v1 = exactly > -32769.0;
  if (exactly >= 32768.0)
    v1 = 0;
  v3 = v1 & (truncf(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    v5 = 0;
  else
    v5 = (unsigned __int16)(int)exactly;
  return (Swift::Int16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

Swift::Int16 __swiftcall Int16.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int16 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x12D0uLL, 0);
  if (a1 <= -32769.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int16 because the result would be less than Int16.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x12D3uLL, 0);
  if (a1 >= 32768.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int16 because the result would be greater than Int16.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x12D6uLL, 0);
  return (int)a1;
}

Swift::Int16_optional __swiftcall Int16.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  char v4;
  int v5;

  v1 = exactly > -32769.0;
  if (exactly >= 32768.0)
    v1 = 0;
  v3 = v1 & (trunc(exactly) == exactly);
  v2 = v3 == 0;
  v4 = ~(_BYTE)v3;
  if (v2)
    v5 = 0;
  else
    v5 = (unsigned __int16)(int)exactly;
  return (Swift::Int16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

BOOL static Int16.== infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 == a2;
}

BOOL static Int16.< infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 < a2;
}

__int16 *static Int16.+= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2;

  v2 = *result + a2;
  if ((__int16)(*result + a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

__int16 *static Int16.-= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2;

  v2 = *result - a2;
  if ((__int16)(*result - a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

__int16 *static Int16.*= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2;

  v2 = *result * a2;
  if ((__int16)(*result * a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

_WORD *static Int16./= infix(_:_:)(_WORD *result, __int16 a2)
{
  int v2;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  v2 = (unsigned __int16)*result;
  if (a2 == -1 && v2 == 0x8000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  *result = (__int16)v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.addingReportingOverflow(_:)(Swift::Int16 a1)
{
  __int16 v1;
  Swift::Int16 v2;
  Swift::tuple_partialValue_Int16_overflow_Bool result;

  v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.subtractingReportingOverflow(_:)(Swift::Int16 a1)
{
  __int16 v1;
  Swift::Int16 v2;
  Swift::tuple_partialValue_Int16_overflow_Bool result;

  v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.multipliedReportingOverflow(by:)(Swift::Int16 by)
{
  __int16 v1;
  Swift::Int16 v2;
  Swift::tuple_partialValue_Int16_overflow_Bool result;

  v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.dividedReportingOverflow(by:)(Swift::Int16 by)
{
  __int16 v1;
  Swift::Int16 v2;
  Swift::tuple_partialValue_Int16_overflow_Bool result;

  if (by)
  {
    if (by == -1 && (unsigned __int16)v1 == 0x8000)
      v1 = 0x8000;
    else
      v1 /= by;
  }
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.remainderReportingOverflow(dividingBy:)(Swift::Int16 dividingBy)
{
  __int16 v1;
  Swift::Int16 v2;
  Swift::tuple_partialValue_Int16_overflow_Bool result;

  if (dividingBy)
  {
    if (dividingBy == -1 && (unsigned __int16)v1 == 0x8000)
      v1 = 0;
    else
      v1 %= dividingBy;
  }
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

_WORD *static Int16.%= infix(_:_:)(_WORD *result, __int16 a2)
{
  int v2;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  v2 = (unsigned __int16)*result;
  if (a2 == -1 && v2 == 0x8000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  *result = (__int16)v2 % a2;
  return result;
}

_WORD *static Int16.&= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result &= a2;
  return result;
}

_WORD *static Int16.|= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result |= a2;
  return result;
}

_WORD *static Int16.^= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result ^= a2;
  return result;
}

__int16 *static Int16.&>>= infix(_:_:)(__int16 *result, char a2)
{
  *result >>= a2 & 0xF;
  return result;
}

uint64_t static Int16.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

_WORD *static Int16.&<<= infix(_:_:)(_WORD *result, char a2)
{
  *result = (unsigned __int16)*result << (a2 & 0xF);
  return result;
}

uint64_t static Int16.bitWidth.getter()
{
  return 16;
}

uint64_t Int16.leadingZeroBitCount.getter(unsigned __int16 a1)
{
  return (unsigned __int16)(__clz(a1) - 16);
}

uint64_t Int16._lowWord.getter(uint64_t result)
{
  return (__int16)result;
}

uint64_t Int16.trailingZeroBitCount.getter(int a1)
{
  return __clz(__rbit32(a1 | 0x10000));
}

uint64_t Int16.nonzeroBitCount.getter(unsigned __int16 a1)
{
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t Int16.Words._value.setter(uint64_t result)
{
  _WORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int16.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.Words.count.getter()
{
  return 1;
}

uint64_t Int16.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int16.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int16.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int16.Words.index(after:)(Swift::Int after)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFADD__(after, 1);
  result = after + 1;
  if (v1)
    __break(1u);
  return result;
}

Swift::Int __swiftcall Int16.Words.index(before:)(Swift::Int before)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFSUB__(before, 1);
  result = before - 1;
  if (v1)
    __break(1u);
  return result;
}

uint64_t Int16.Words.subscript.getter(uint64_t a1, __int16 a2)
{
  if (a1 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x15ABuLL, 0);
  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x15ACuLL, 0);
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int16.Words(uint64_t *a1, uint64_t *a2))()
{
  __int16 *v2;

  *a1 = Int16.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UInt16.Words@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  __int16 *v2;
  uint64_t v3;
  __int16 v4;

  if ((*result & 0x8000000000000000) != 0 || (v3 = result[1], v3 >= 2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  v4 = *v2;
  *(_QWORD *)a2 = *result;
  *(_QWORD *)(a2 + 8) = v3;
  *(_WORD *)(a2 + 16) = v4;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Int16.Words(uint64_t a1@<X8>)
{
  _WORD *v1;

  *(_WORD *)a1 = *v1;
  *(_QWORD *)(a1 + 8) = 0;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance Int16.Words()
{
  __int16 *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int16.Words(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  __int16 *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int16.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5(a1, a2);
}

uint64_t Int16.magnitude.getter(__int16 a1)
{
  if (a1 >= 0)
    return a1;
  else
    return -a1;
}

Swift::tuple_high_Int16_low_UInt16 __swiftcall Int16.multipliedFullWidth(by:)(Swift::Int16 by)
{
  signed __int16 v1;
  Swift::Int16 v2;
  Swift::tuple_high_Int16_low_UInt16 result;

  v2 = (v1 * by) >> 16;
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_Int16_remainder_Int16 __swiftcall Int16.dividingFullWidth(_:)(Swift::tuple_high_Int16_low_UInt16 a1)
{
  __int16 v1;
  int v2;
  int v3;
  Swift::tuple_quotient_Int16_remainder_Int16 result;

  if (!v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x162AuLL, 0);
  v2 = a1.low | ((unsigned __int16)a1.high << 16);
  if (v1 == -1 && v2 == 0x80000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  v3 = v2 / v1;
  if (v3 != (__int16)v3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1634uLL, 0);
  result.remainder = v2;
  result.quotient = v3;
  return result;
}

uint64_t static Int32.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << a2);
}

uint64_t Int16.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1) >> 16;
}

Swift::Int16 __swiftcall Int16.signum()()
{
  __int16 v0;

  return (v0 > 0) | (v0 >> 15);
}

BOOL static Int16.> infix(_:_:)(__int16 a1, __int16 a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = 0x7FFF;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = 0x8000;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int16(_WORD *a1, __int16 *a2)
{
  __int16 *v2;
  int v3;
  _BOOL8 v4;

  v3 = *v2 + *a2;
  v4 = v3 != (__int16)(*v2 + *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int16(_WORD *a1, __int16 *a2)
{
  __int16 *v2;
  int v3;
  _BOOL8 v4;

  v3 = *v2 - *a2;
  v4 = v3 != (__int16)(*v2 - *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int16(_WORD *a1, __int16 *a2)
{
  __int16 *v2;
  int v3;
  _BOOL8 v4;

  v3 = *v2 * *a2;
  v4 = v3 != (__int16)(*v2 * *a2);
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int16(_WORD *a1, _WORD *a2)
{
  unsigned __int16 *v2;
  int v3;
  int v4;
  uint64_t v5;

  v3 = (unsigned __int16)*a2;
  v4 = *v2;
  if (!*a2 || v3 == 0xFFFF && v4 == 0x8000)
  {
    v5 = 1;
  }
  else
  {
    v5 = 0;
    LOWORD(v4) = (__int16)v4 / (__int16)v3;
  }
  *a1 = v4;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int16(_WORD *a1, _WORD *a2)
{
  unsigned __int16 *v2;
  int v3;
  int v4;
  uint64_t v5;

  v3 = (unsigned __int16)*a2;
  v4 = *v2;
  if (!*a2)
    goto LABEL_7;
  if (v3 == 0xFFFF && v4 == 0x8000)
  {
    LOWORD(v4) = 0;
LABEL_7:
    v5 = 1;
    goto LABEL_5;
  }
  v5 = 0;
  LOWORD(v4) = (__int16)v4 % (__int16)v3;
LABEL_5:
  *a1 = v4;
  return v5;
}

_WORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int16(_WORD *result, _WORD *a2, __int16 *a3)
{
  __int16 *v3;
  int v4;

  v4 = *v3 * *a3;
  *result = HIWORD(v4);
  *a2 = v4;
  return result;
}

Swift::Int16 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int16(Swift::Int16 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  Swift::Int16 result;
  __int16 v7;

  result = Int16.dividingFullWidth(_:)((Swift::tuple_high_Int16_low_UInt16)__PAIR32__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int16()
{
  unsigned __int16 *v0;
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int16()
{
  unsigned __int16 *v0;

  return (unsigned __int16)(__clz(*v0) - 16);
}

unsigned __int16 *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = bswap32(*result) >> 16;
  return result;
}

_WORD *protocol witness for FixedWidthInteger.init(littleEndian:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int16(_WORD *a1@<X8>)
{
  unsigned __int16 *v1;

  *a1 = bswap32(*v1) >> 16;
}

void protocol witness for FixedWidthInteger.littleEndian.getter in conformance Int16(_WORD *a1@<X8>)
{
  _WORD *v1;

  *a1 = *v1;
}

__int16 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result >> (*a2 & 0xF);
  return result;
}

__int16 *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int16(__int16 *result, _WORD *a2)
{
  *result >>= *a2 & 0xF;
  return result;
}

unsigned __int16 *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result << (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *result = (unsigned __int16)*result << (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_WORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_WORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_WORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int16@<X0>(_WORD *result@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  if (a2 >> 8 <= 0x10)
    *a3 = *result;
  else
    *a3 = 0;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int16 and conformance Int16(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int16 and conformance Int16, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _WORD *a6@<X8>)
{
  Class *v6;
  Class *v8;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t *TypeName;
  uint64_t v17;
  uint8x16_t *v18;
  int64_t v19;
  int64_t v20;
  int64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  Swift::String v26;
  uint64_t *v27;
  uint64_t v28;
  uint8x16_t *v29;
  int64_t v30;
  int64_t v31;
  int64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  Swift::String v37;
  char *v38;
  unint64_t v39;

  v8 = v6;
  v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((BYTE2(v38) & 1) != 0)
  {
    v38 = (char *)static String._createEmpty(withInitialCapacity:)(80);
    v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      v18 = (uint8x16_t *)TypeName;
      v19 = v17;
      v20 = validateUTF8(_:)(TypeName, v17);
      v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x8000000181762940;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        v29 = (uint8x16_t *)v27;
        v30 = v28;
        v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0)
          v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        else
          v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x8000000181762960;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = (_WORD)v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int16@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _WORD *a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char v28;
  void (*v29)(char *, char *, uint64_t);
  uint64_t v30;
  void (*v31)(char *, uint64_t);
  void (*v32)(char *, char *, uint64_t);
  char *v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t, uint64_t);
  char *v36;
  __int16 v37;
  BOOL v38;
  uint64_t (*v39)(uint64_t, uint64_t);
  char v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char v44;
  char *v45;
  char *v46;
  char *v47;
  __int16 v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  char v52;
  char *v53;
  int v54;
  __int16 v55;
  uint64_t v56;
  char *v57;
  char v58;
  uint64_t v59;
  void (*v60)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t);
  __int16 *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char v65;
  __int16 v66;
  uint64_t result;
  const char *v68;
  char *v69;
  uint64_t (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  uint64_t v72;
  char *v73;
  char *v74;
  _WORD *v75;
  void (*v76)(char *, char *, uint64_t);
  uint64_t (*v77)(uint64_t, uint64_t);
  char *v78;
  __int16 v79;
  __int16 v80;
  __int16 v81;

  v71 = a4;
  v72 = a5;
  v75 = a6;
  v68 = *(const char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v68, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v68 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v69 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v73 = (char *)&v68 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v68 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v74 = (char *)&v68 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v68 - v24;
  MEMORY[0x1E0C80A78](v23);
  v27 = (char *)&v68 - v26;
  v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v28 = v77(a2, a3);
  v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  v78 = a1;
  v76 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    v70 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v30 = v70(a2, a3);
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 16)
    {
      v32 = v76;
      v76(v25, v78, a2);
      v79 = 0x8000;
      v33 = v25;
      v34 = v77;
      if ((v77(a2, a3) & 1) != 0)
      {
        v35 = v70;
        if (v70(a2, a3) < 16)
        {
          v36 = v74;
          v32(v74, v33, a2);
          v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          v38 = v79 <= v37;
LABEL_18:
          v42 = v33;
LABEL_19:
          v46 = v78;
          if (!v38)
LABEL_40:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
          goto LABEL_21;
        }
        v45 = v74;
        (*(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v33, v45, a2);
        v31(v45, a2);
        v42 = v33;
        goto LABEL_11;
      }
      v40 = v34(a2, a3);
      v41 = v70(a2, a3);
      v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 16)
        {
          v49 = v68;
          AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v68, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
          v51 = v74;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v51, a2);
          v31(v51, a2);
          v53 = v69;
          v33 = v42;
          v32 = v76;
          v76(v69, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_40;
          }
          v54 = v79;
          v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          v38 = v54 <= v55;
          v35 = v70;
          goto LABEL_18;
        }
        v43 = v74;
        (*(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v79, v71, v72, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v43, a2);
        v31(v43, a2);
        v32 = v76;
        v35 = v70;
LABEL_11:
        v46 = v78;
        if ((v44 & 1) != 0)
          goto LABEL_40;
LABEL_21:
        v31(v42, a2);
        v39 = v77;
        goto LABEL_24;
      }
      if (v41 < 16)
      {
        v47 = v74;
        v32 = v76;
        v76(v74, v42, a2);
        v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        v38 = v79 <= v48;
        v35 = v70;
        goto LABEL_19;
      }
      v31(v33, a2);
    }
    v32 = v76;
    v39 = v77;
    v35 = v70;
  }
  else
  {
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v32 = v76;
    v39 = v77;
  }
  v46 = v78;
LABEL_24:
  v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 17)
  {
    v31(v20, a2);
    goto LABEL_26;
  }
  v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 16 && (v39(a2, a3) & 1) == 0)
  {
LABEL_26:
    v57 = v73;
    v32(v73, v46, a2);
    v81 = 0x7FFF;
    v58 = v39(a2, a3);
    v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 16)
      {
        v60 = *(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        v61 = &v81;
        goto LABEL_35;
      }
    }
    else if (v59 > 15)
    {
      v80 = 0x7FFF;
      v60 = *(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v61 = &v80;
LABEL_35:
      v64 = v74;
      v60(v61, v71, v72, a2, a3);
      v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v64, v57, a2);
      v31(v64, a2);
      if ((v65 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_36;
    }
    v63 = v74;
    v32(v74, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_36:
    v31(v57, a2);
  }
  v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *v75 = v66;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _WORD *a4@<X8>)
{
  __int16 v7;
  uint64_t result;

  v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int16@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int16 and conformance Int16((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int16()
{
  __int16 *v0;

  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int16()
{
  unsigned __int16 *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int16()
{
  unsigned __int16 *v0;

  return __clz(__rbit32(*v0 | 0x10000));
}

unsigned __int16 *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;
  int v4;

  v3 = (unsigned __int16)*a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  v4 = *result;
  if (v4 == 0x8000 && v3 == 0xFFFF)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  *a3 = (__int16)v4 / (__int16)v3;
  return result;
}

uint64_t static Int16./ infix(_:_:)(unsigned __int16 a1, __int16 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  if (a1 == 0x8000 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  return ((__int16)a1 / a2);
}

_WORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  int v2;
  int v3;

  v2 = (unsigned __int16)*a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  v3 = (unsigned __int16)*result;
  if (v2 == 0xFFFF && v3 == 0x8000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  *result = (__int16)v3 / (__int16)v2;
  return result;
}

unsigned __int16 *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;
  int v4;

  v3 = (unsigned __int16)*a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  v4 = *result;
  if (v4 == 0x8000 && v3 == 0xFFFF)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  *a3 = (__int16)v4 % (__int16)v3;
  return result;
}

uint64_t static Int16.% infix(_:_:)(unsigned __int16 a1, __int16 a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  if (a1 == 0x8000 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  return ((__int16)a1 % a2);
}

_WORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  int v2;
  int v3;

  v2 = (unsigned __int16)*a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  v3 = (unsigned __int16)*result;
  if (v2 == 0xFFFF && v3 == 0x8000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  *result = (__int16)v3 % (__int16)v2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *result &= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *result |= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int16.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_WORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int16@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  int v54;
  _WORD *v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  uint64_t (*v62)(char *, uint64_t);
  void (*v63)(char *, uint64_t, uint64_t);
  char *v64;
  char v65;
  void (*v66)(char *, char *, uint64_t);
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t, uint64_t);
  uint64_t v79;
  char *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v86;
  int64_t *v87;
  uint64_t v88;
  char v89;
  unint64_t v90;
  char v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  void (*v95)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v96;
  char v97;
  void (*v98)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v99;
  char v100;
  char *v101;
  uint64_t v102;
  void (**v103)(char *, uint64_t, const char *);
  unint64_t v104;
  unint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  int64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  unint64_t AssociatedTypeWitness;
  char *v115;
  char *v116;
  char *v117;
  int v118;
  char *v119;
  _WORD *v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t (*v122)(uint64_t, uint64_t);
  uint64_t v123;
  int64_t v124;

  v120 = a5;
  v115 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v115, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v113 = (char *)&v111 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v111 = (char *)&v111 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v111 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v117 = (char *)&v111 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v112 = (char *)&v111 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v111 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v119 = (char *)&v111 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v111 - v28;
  v118 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v121 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v124 = -16;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v121;
        v32 = v122;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v115;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -16;
    }
    else
    {
      if (v39 > 64)
      {
        v30 = v121;
        v32 = v122;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -16;
    }
    v30 = v121;
    v32 = v122;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 >= -16)
      goto LABEL_20;
LABEL_19:
    LOWORD(v54) = 0;
    v55 = v120;
    goto LABEL_50;
  }
  v124 = -16;
  v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v44 & 1) != 0)
    goto LABEL_19;
LABEL_20:
  v122 = v32;
  v56 = v30(a3, a4);
  v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64)
      goto LABEL_22;
  }
  else if (v57 > 63)
  {
LABEL_22:
    v124 = 16;
    v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v60) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v62(v29, a3);
    if ((v60 & 1) == 0)
      goto LABEL_23;
LABEL_31:
    v54 = (__int16)v118 >> 15;
    v55 = v120;
    goto LABEL_50;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v62(v29, a3);
  if (v77 > 16)
    goto LABEL_31;
LABEL_23:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v64 = v119;
  v63(v119, a2, a3);
  v65 = v121(a3, a4);
  v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    v76 = v25;
    v68 = v119;
    v69 = v117;
    goto LABEL_33;
  }
  v67 = v122(a3, a4);
  v62(v25, a3);
  v68 = v119;
  v69 = v117;
  if (v67 < 65)
    goto LABEL_34;
  v70 = v112;
  v66(v112, v119, a3);
  v124 = 0x8000000000000000;
  v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    v91 = v71(a3, a4);
    v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        v70 = v112;
        v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
        goto LABEL_55;
      }
      v104 = AssociatedTypeWitness;
      v103 = (void (**)(char *, uint64_t, const char *))v115;
      v105 = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))(&qword_1816B7DA8, 256, v104, v105);
      v103[3](v106, a3, (const char *)v103);
      v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
      v62(v29, a3);
      v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }
      v109 = v124;
      v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      v47 = v110 < v109;
      v68 = v119;
      v76 = v112;
      if (!v47)
        goto LABEL_33;
    }
    else
    {
      if (v92 > 64)
      {
        v76 = v112;
        goto LABEL_33;
      }
      v101 = v112;
      v66(v29, v112, a3);
      v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      v76 = v101;
      if (v102 >= v124)
        goto LABEL_33;
    }
LABEL_70:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    v76 = v70;
    if (v75 < v124)
      goto LABEL_70;
    goto LABEL_33;
  }
  v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v70, v29, a3);
LABEL_55:
  v100 = v97;
  v62(v29, a3);
  v76 = v70;
  if ((v100 & 1) != 0)
    goto LABEL_70;
LABEL_33:
  v62(v76, a3);
LABEL_34:
  v78 = v122;
  v79 = v122(a3, a4);
  v66(v69, v68, a3);
  if (v79 < 65)
  {
    v88 = v78(a3, a4);
    v62(v69, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0)
      goto LABEL_47;
  }
  else
  {
    v62(v69, a3);
  }
  v80 = v116;
  v66(v116, v68, a3);
  v124 = 0x7FFFFFFFFFFFFFFFLL;
  v81 = v121(a3, a4);
  v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      v87 = &v124;
      goto LABEL_45;
    }
  }
  else if (v82 > 63)
  {
    v123 = 0x7FFFFFFFFFFFFFFFLL;
    v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v80, a3);
    v62(v29, a3);
    if ((v89 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_46;
  }
  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v62(v68, a3);
  if ((v90 & 0x8000000000000000) != 0)
  {
    v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFF0)
      LOWORD(v54) = 0;
    else
      v54 = v118 << -(char)v90;
  }
  else
  {
    v55 = v120;
    if (v90 >= 0x10)
      v54 = (__int16)v118 >> 15;
    else
      v54 = (__int16)v118 >> v90;
  }
LABEL_50:
  *v55 = v54;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int16(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  unsigned __int16 *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  void (*v71)(char *, uint64_t, uint64_t);
  char *v72;
  char v73;
  char *v74;
  char *v75;
  void (*v76)(char *, char *, uint64_t);
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t (*v80)(uint64_t, uint64_t);
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  unsigned __int16 *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  int v130;
  char *v131;
  unsigned __int16 *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v144 = -16;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) == 0)
        goto LABEL_19;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 >= -16)
        goto LABEL_19;
    }
LABEL_18:
    LOWORD(v61) = 0;
    goto LABEL_59;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v42 = v32(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_19;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 >= -16)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (v42 <= 64)
  {
    v55 = v137;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
    v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      LOWORD(v61) = 0;
      v39 = v132;
      goto LABEL_59;
    }
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }
  v144 = -16;
  v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  v40 = v131;
  v39 = v132;
  if ((v48 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
  }
  else if (v63 >= 64)
  {
LABEL_21:
    v144 = 16;
    v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v68, a3);
    if ((v69 & 1) == 0)
      goto LABEL_22;
LABEL_30:
    v61 = (__int16)*v39 >> 15;
    goto LABEL_59;
  }
  v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v88, a3);
  if (v89 > 16)
    goto LABEL_30;
LABEL_22:
  v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v72 = v140;
  v71(v140, a2, a3);
  v73 = v141(a3, a4);
  v74 = v139;
  v75 = v72;
  v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  v132 = (unsigned __int16 *)v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    v78 = v140;
    goto LABEL_42;
  }
  v77 = v32(a3, a4);
  v70(v74, a3);
  v78 = v140;
  if (v77 <= 64)
    goto LABEL_42;
  v79 = v135;
  v76(v135, v140, a3);
  v144 = 0x8000000000000000;
  v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v81 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v81 >= 64)
    {
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v86, a3);
      v87 = v86;
      v79 = v135;
      v70(v87, a3);
      if ((v84 & 1) != 0)
        goto LABEL_65;
      goto LABEL_41;
    }
  }
  else
  {
    v90 = v80(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v79 = v107;
        v70(v108, a3);
        v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v78 = v140;
        if (v112)
          goto LABEL_65;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_65;
      }
      goto LABEL_41;
    }
    if (v91 >= 64)
      goto LABEL_41;
  }
  v100 = v142;
  v76(v142, v79, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }
  v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        v123 = &v144;
        goto LABEL_54;
      }
    }
    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
      v70(v127, a3);
      if ((v128 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v78, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFF0)
    {
      v61 = v130 << -(char)v129;
      goto LABEL_59;
    }
    goto LABEL_18;
  }
  if (v129 >= 0x10)
    v61 = (__int16)v130 >> 15;
  else
    v61 = (__int16)v130 >> v129;
LABEL_59:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int16@<X0>(unsigned __int16 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  int v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  uint64_t (*v61)(char *, uint64_t);
  uint64_t v62;
  void (*v63)(char *, uint64_t, uint64_t);
  char *v64;
  char v65;
  void (*v66)(char *, char *, uint64_t);
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  uint64_t v78;
  char *v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  int64_t *v86;
  uint64_t v87;
  char v88;
  unint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char v96;
  void (*v97)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v98;
  char v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  unint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  int64_t v108;
  uint64_t v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t AssociatedTypeWitness;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  int v118;
  _WORD *v119;
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t v122;
  int64_t v123;

  v119 = a5;
  v114 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v114, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v112 = (char *)&v110 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v110 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v110 = (char *)&v110 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v115 = (char *)&v110 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v116 = (char *)&v110 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v111 = (char *)&v110 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v110 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v117 = (char *)&v110 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v110 - v28;
  v118 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v120 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v121 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v121(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v123 = -16;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v123, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v120;
        v32 = v121;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v114;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -16;
    }
    else
    {
      if (v39 > 64)
      {
        v30 = v120;
        v32 = v121;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -16;
    }
    v30 = v120;
    v32 = v121;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    v123 = -16;
    v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v44(&v123, &type metadata for Int, v45, a3, a4);
    LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if ((v44 & 1) != 0)
      goto LABEL_19;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 <= -17)
      goto LABEL_19;
  }
LABEL_20:
  v121 = v32;
  v55 = v30(a3, a4);
  v56 = v32(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64)
      goto LABEL_22;
LABEL_25:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v61(v29, a3);
    if (v62 <= 16)
      goto LABEL_27;
LABEL_26:
    LOWORD(v54) = 0;
    goto LABEL_51;
  }
  if (v56 <= 63)
    goto LABEL_25;
LABEL_22:
  v123 = 16;
  v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v123, &type metadata for Int, v60, a3, a4);
  LOBYTE(v59) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
  v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v61(v29, a3);
  if ((v59 & 1) != 0)
    goto LABEL_26;
LABEL_27:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v64 = v117;
  v63(v117, a2, a3);
  v65 = v120(a3, a4);
  v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    v76 = v25;
    v68 = v116;
    v69 = v117;
    goto LABEL_34;
  }
  v67 = v121(a3, a4);
  v61(v25, a3);
  v68 = v116;
  v69 = v117;
  if (v67 < 65)
    goto LABEL_35;
  v70 = v111;
  v66(v111, v117, a3);
  v123 = 0x8000000000000000;
  v71 = v120;
  if ((v120(a3, a4) & 1) == 0)
  {
    v90 = v71(a3, a4);
    v91 = v121(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 > 64)
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v94(&v123, &type metadata for Int, v95, a3, a4);
        v70 = v111;
        v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v29, a3);
        goto LABEL_56;
      }
      v103 = AssociatedTypeWitness;
      v102 = (void (**)(char *, uint64_t, const char *))v114;
      v104 = swift_getAssociatedConformanceWitness((uint64_t)v114, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v105 = v112;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
      v102[3](v105, a3, (const char *)v102);
      v106 = v111;
      LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v111, v29, a3);
      v61(v29, a3);
      v107 = v110;
      v66(v110, v106, a3);
      if ((v102 & 1) != 0)
      {
        v61(v107, a3);
        goto LABEL_70;
      }
      v108 = v123;
      v109 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v107, a3);
      v47 = v109 < v108;
      v69 = v117;
      v76 = v111;
      if (!v47)
        goto LABEL_34;
    }
    else
    {
      if (v91 > 64)
      {
        v76 = v111;
        goto LABEL_34;
      }
      v100 = v111;
      v66(v29, v111, a3);
      v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      v76 = v100;
      if (v101 >= v123)
        goto LABEL_34;
    }
LABEL_70:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v72 = v121(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
    v76 = v70;
    if (v75 < v123)
      goto LABEL_70;
    goto LABEL_34;
  }
  v97 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v98 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v97(&v123, &type metadata for Int, v98, a3, a4);
  v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v70, v29, a3);
LABEL_56:
  v99 = v96;
  v61(v29, a3);
  v76 = v70;
  if ((v99 & 1) != 0)
    goto LABEL_70;
LABEL_34:
  v61(v76, a3);
LABEL_35:
  v77 = v121;
  v78 = v121(a3, a4);
  v66(v68, v69, a3);
  if (v78 < 65)
  {
    v87 = v77(a3, a4);
    v61(v68, a3);
    if (v87 != 64 || (v120(a3, a4) & 1) != 0)
      goto LABEL_48;
  }
  else
  {
    v61(v68, a3);
  }
  v79 = v115;
  v66(v115, v69, a3);
  v123 = 0x7FFFFFFFFFFFFFFFLL;
  v80 = v120(a3, a4);
  v81 = v121(a3, a4);
  if ((v80 & 1) != 0)
  {
    if (v81 > 64)
    {
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v86 = &v123;
      goto LABEL_46;
    }
  }
  else if (v81 > 63)
  {
    v122 = 0x7FFFFFFFFFFFFFFFLL;
    v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
    v86 = &v122;
LABEL_46:
    v84(v86, &type metadata for Int, v85, a3, a4);
    v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v79, a3);
    v61(v29, a3);
    if ((v88 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_47;
  }
  v66(v29, v79, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v61(v29, a3);
LABEL_47:
  v61(v79, a3);
LABEL_48:
  v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v61(v69, a3);
  if ((v89 & 0x8000000000000000) == 0)
  {
    if (v89 < 0x10)
    {
      v54 = v118 << v89;
      goto LABEL_51;
    }
    goto LABEL_26;
  }
  if (v89 > 0xFFFFFFFFFFFFFFF0)
  {
    v54 = (__int16)v118 >> -(char)v89;
    goto LABEL_51;
  }
LABEL_19:
  v54 = (__int16)v118 >> 15;
LABEL_51:
  *v119 = v54;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int16(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  unsigned __int16 *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  unsigned __int16 *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  int v130;
  char *v131;
  unsigned __int16 *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    v131 = v19;
    v132 = a1;
    v41 = v29(a3, a4);
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        v144 = -16;
        v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        v40 = v131;
        v39 = v132;
        if ((v48 & 1) != 0)
          goto LABEL_18;
        goto LABEL_19;
      }
      v55 = v137;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
      v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        v39 = v132;
        goto LABEL_18;
      }
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }
    else
    {
      if (v42 >= 64)
      {
        v40 = v131;
        v39 = v132;
        goto LABEL_19;
      }
      v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }
    v40 = v131;
    v39 = v132;
    if (v54 >= -16)
      goto LABEL_19;
    goto LABEL_18;
  }
  v31 = v19;
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 < 64)
  {
    v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    v39 = a1;
    v40 = v31;
    if (v37 > -17)
      goto LABEL_19;
LABEL_18:
    v61 = (__int16)*v39 >> 15;
    goto LABEL_60;
  }
  v144 = -16;
  v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  v39 = a1;
  v40 = v31;
  if ((v52 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
  }
  else if (v63 >= 64)
  {
LABEL_21:
    v144 = 16;
    v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v68, a3);
    if ((v69 & 1) != 0)
      goto LABEL_25;
    goto LABEL_26;
  }
  v71 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v71, a3);
  if (v72 > 16)
  {
LABEL_25:
    LOWORD(v61) = 0;
    goto LABEL_60;
  }
LABEL_26:
  v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v74 = v140;
  v73(v140, a2, a3);
  v75 = v141(a3, a4);
  v76 = v139;
  v77 = v74;
  v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  v132 = (unsigned __int16 *)v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_43;
  }
  v79 = v32(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64)
    goto LABEL_43;
  v81 = v135;
  v78(v135, v140, a3);
  v144 = 0x8000000000000000;
  v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v88, a3);
      v89 = v88;
      v81 = v135;
      v70(v89, a3);
      if ((v86 & 1) != 0)
        goto LABEL_65;
      goto LABEL_42;
    }
  }
  else
  {
    v90 = v82(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v81 = v107;
        v70(v108, a3);
        v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v80 = v140;
        if (v112)
          goto LABEL_65;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_65;
      }
      goto LABEL_42;
    }
    if (v91 >= 64)
      goto LABEL_42;
  }
  v100 = v142;
  v78(v142, v81, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_42:
  v70(v81, a3);
LABEL_43:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 < 65)
  {
    v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
    v70(v115, a3);
    v125 = v124 == 64;
    v116 = v141;
    if (!v125 || (v141(a3, a4) & 1) != 0)
      goto LABEL_57;
  }
  else
  {
    v70(v115, a3);
    v116 = v141;
  }
  v78(v40, v80, a3);
  v144 = 0x7FFFFFFFFFFFFFFFLL;
  v117 = v116(a3, a4);
  v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  if ((v117 & 1) != 0)
  {
    if (v118 > 64)
    {
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v144;
      goto LABEL_55;
    }
  }
  else if (v118 >= 64)
  {
    v143 = 0x7FFFFFFFFFFFFFFFLL;
    v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
    v123 = &v143;
LABEL_55:
    v127 = v142;
    v121(v123, &type metadata for Int, v122, a3, a4);
    v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
    v70(v127, a3);
    if ((v128 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_56;
  }
  v126 = v142;
  v78(v142, v40, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v126, a3);
LABEL_56:
  v70(v40, a3);
LABEL_57:
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) == 0)
  {
    if (v129 < 0x10)
    {
      v61 = v130 << v129;
      goto LABEL_60;
    }
    goto LABEL_25;
  }
  if (v129 <= 0xFFFFFFFFFFFFFFF0)
    v61 = (__int16)v130 >> 15;
  else
    v61 = (__int16)v130 >> -(char)v129;
LABEL_60:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int16(_WORD *a1, _WORD *a2, __int16 *a3)
{
  __int16 *v3;
  uint64_t result;

  result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int16(__int16 *a1)
{
  __int16 *v1;

  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int16(_WORD *a1@<X8>)
{
  __int16 *v1;

  *a1 = (*v1 > 0) | (unsigned __int16)(*v1 >> 15);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int16(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7;
  int v10;
  unsigned int v11;
  __int16 v12;

  v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  if (v7)
  {
    v10 = a3();
    if ((v10 & 0x1000000) != 0)
      v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    swift_bridgeObjectRelease(a2);
    v11 = (v10 & 0x10000u) >> 16;
    if ((v10 & 0x10000) != 0)
      v12 = 0;
    else
      v12 = v10;
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    v12 = 0;
    LOBYTE(v11) = 1;
  }
  *(_WORD *)a5 = v12;
  *(_BYTE *)(a5 + 2) = v11 & 1;
}

__int16 *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int16@<X0>(__int16 *result@<X0>, _WORD *a2@<X8>)
{
  int v2;

  v2 = *result;
  if (v2 + (__int16)-*result)
    __break(1u);
  else
    *a2 = -(__int16)v2;
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int16()
{
  __int16 *v0;
  int v1;

  v1 = *v0;
  if (v1 + (__int16)-*v0)
    __break(1u);
  else
    *v0 = -(__int16)v1;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char v29;
  void (*v30)(char *, uint64_t, uint64_t);
  _BOOL4 v31;
  void (*v32)(char *, uint64_t);
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  char v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v51;
  char *v52;
  char v53;
  char *v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  __int16 v64;
  uint64_t result;
  char v66;
  void (*v67)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v68;
  char *v69;
  char *v70;
  __int16 v71;
  BOOL v72;
  char *v73;
  uint64_t v74;
  void (*v75)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  void (**v80)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v82;
  char *v83;
  int v84;
  __int16 v85;
  uint64_t (*v86)(uint64_t, uint64_t);
  char *v87;
  char *v88;
  char *v89;
  uint64_t v90;
  char *v91;
  char *v92;
  char *v93;
  uint64_t v94;
  uint64_t (*v95)(uint64_t, uint64_t);
  uint64_t v96;
  __int16 v97;
  __int16 v98;
  __int16 v99;

  v90 = a4;
  v94 = a5;
  v87 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v87, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v86 - v10;
  v12 = *(_QWORD *)(a2 - 8);
  v13 = MEMORY[0x1E0C80A78](v9);
  v88 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v86 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v93 = (char *)&v86 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v92 = (char *)&v86 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v91 = (char *)&v86 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v86 - v25;
  MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v86 - v27;
  v95 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v29 = v95(a2, a3);
  v96 = v12;
  v30 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v30(v28, a1, a2);
  v89 = v17;
  v31 = (v29 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 16;
  v32 = *(void (**)(char *, uint64_t))(v96 + 8);
  v32(v28, a2);
  v30(v26, a1, a2);
  if (!v31)
  {
    v32(v26, a2);
    v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v38 = v93;
    v40 = v94;
    goto LABEL_10;
  }
  v97 = 0x8000;
  v33 = v95;
  if ((v95(a2, a3) & 1) != 0)
  {
    v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v35 = v34(a2, a3);
    v38 = v93;
    if (v35 >= 16)
    {
      v67 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v68 = lazy protocol witness table accessor for type Int16 and conformance Int16(v35, v36, v37);
      v86 = v34;
      v69 = v91;
      v67(&v97, v90, v68, a2, a3);
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v69, a2);
      v70 = v69;
      v34 = v86;
      v32(v70, a2);
      v32(v26, a2);
      v40 = v94;
      if ((v67 & 1) != 0)
        goto LABEL_40;
    }
    else
    {
      v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v32(v26, a2);
      v40 = v94;
      if (v97 > v39)
        goto LABEL_40;
    }
    goto LABEL_10;
  }
  v55 = v33(a2, a3);
  v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v56 = v86(a2, a3);
  if ((v55 & 1) != 0)
  {
    if (v56 > 16)
    {
      v59 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v60 = lazy protocol witness table accessor for type Int16 and conformance Int16(v56, v57, v58);
      v61 = v91;
      v59(&v97, v90, v60, a2, a3);
      LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v61, a2);
      v32(v61, a2);
      v32(v26, a2);
      v38 = v93;
      v40 = v94;
      v34 = v86;
      if ((v59 & 1) != 0)
        goto LABEL_40;
      goto LABEL_10;
    }
    v80 = (void (**)(char *, uint64_t, const char *))v87;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v82 = v91;
    v80[3](v11, a2, (const char *)v80);
    LOBYTE(v80) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v82, a2);
    v32(v82, a2);
    v83 = v88;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v88, v26, a2);
    v40 = v94;
    if ((v80 & 1) != 0)
    {
      v32(v83, a2);
LABEL_40:
      result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
      v64 = 0;
      v66 = 1;
      goto LABEL_41;
    }
    v84 = v97;
    v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v83, a2);
    v72 = v84 <= v85;
    v38 = v93;
    goto LABEL_39;
  }
  v38 = v93;
  if (v56 < 16)
  {
    v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v26, a2);
    v72 = v97 <= v71;
    v40 = v94;
LABEL_39:
    v34 = v86;
    if (!v72)
      goto LABEL_40;
LABEL_10:
    v41 = v34(a2, a3);
    goto LABEL_11;
  }
  v32(v26, a2);
  v40 = v94;
  v34 = v86;
  v41 = v86(a2, a3);
LABEL_11:
  v42 = v41;
  v43 = v92;
  v30(v92, a1, a2);
  if (v42 >= 17)
  {
    v32(v43, a2);
    v30(v38, a1, a2);
    goto LABEL_15;
  }
  v44 = v34(a2, a3);
  v32(v43, a2);
  if (v44 != 16)
  {
    v30(v38, a1, a2);
    goto LABEL_25;
  }
  v45 = v95(a2, a3);
  v30(v38, a1, a2);
  if ((v45 & 1) != 0)
  {
LABEL_25:
    v63 = v38;
    goto LABEL_26;
  }
LABEL_15:
  v99 = 0x7FFF;
  v46 = v95(a2, a3);
  v47 = v34(a2, a3);
  if ((v46 & 1) != 0)
  {
    if (v47 > 16)
    {
      v50 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v51 = lazy protocol witness table accessor for type Int16 and conformance Int16(v47, v48, v49);
      v52 = v91;
      v50(&v99, v90, v51, a2, a3);
      v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v52, v38, a2);
      v32(v52, a2);
      v54 = v38;
      goto LABEL_34;
    }
    goto LABEL_23;
  }
  if (v47 <= 15)
  {
LABEL_23:
    v62 = v91;
    (*(void (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v63 = v62;
LABEL_26:
    v32(v63, a2);
    goto LABEL_27;
  }
  v98 = 0x7FFF;
  v73 = v91;
  v74 = (*(uint64_t (**)(char *, char *, uint64_t))(v96 + 32))(v91, v38, a2);
  v75 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v78 = lazy protocol witness table accessor for type Int16 and conformance Int16(v74, v76, v77);
  v79 = v89;
  v75(&v98, v90, v78, a2, a3);
  v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v79, v73, a2);
  v32(v79, a2);
  v54 = v73;
LABEL_34:
  v32(v54, a2);
  if ((v53 & 1) != 0)
    goto LABEL_40;
LABEL_27:
  v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
  v66 = 0;
LABEL_41:
  *(_WORD *)v40 = v64;
  *(_BYTE *)(v40 + 2) = v66;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int16(_WORD *a1@<X8>)
{
  __int16 *v1;
  int v2;

  v2 = *v1;
  if (v2 < 0)
    v2 = -v2;
  *a1 = v2;
}

__int16 *protocol witness for static Numeric.* infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;

  v3 = *result * *a2;
  if ((__int16)(*result * *a2) == v3)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

uint64_t static Int16.* infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result;

  result = (a1 * a2);
  if ((__int16)(a1 * a2) != (_DWORD)result)
    __break(1u);
  return result;
}

__int16 *protocol witness for static Numeric.*= infix(_:_:) in conformance Int16(__int16 *result, __int16 *a2)
{
  int v2;

  v2 = *result * *a2;
  if ((__int16)(*result * *a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int16()
{
  __int16 *v0;

  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
}

unsigned __int16 *protocol witness for Strideable.distance(to:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, uint64_t *a2@<X8>)
{
  __int16 *v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;

  v3 = *result;
  v4 = *v2;
  if (((v4 ^ v3) & 0x8000) == 0)
  {
    v5 = (__int16)v3 - v4;
    if ((__int16)v5 == v5)
    {
      *a2 = (__int16)v5;
      return result;
    }
    __break(1u);
    goto LABEL_15;
  }
  if (v4 >= 0)
    LOWORD(v6) = *v2;
  else
    v6 = -v4;
  if ((v3 & 0x8000u) != 0)
    v3 = -(__int16)v3;
  v7 = (unsigned __int16)v6 + (unsigned __int16)v3;
  if ((v7 & 0x10000) != 0)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v4 < 0)
    v8 = (unsigned __int16)v7;
  else
    v8 = -(uint64_t)(unsigned __int16)v7;
  *a2 = v8;
  return result;
}

_QWORD *protocol witness for Strideable.advanced(by:) in conformance Int16@<X0>(_QWORD *result@<X0>, _WORD *a2@<X8>)
{
  __int16 *v2;
  uint64_t v3;
  uint64_t v4;

  v3 = *v2;
  v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  if (v4 <= -32769)
    goto LABEL_6;
  if (v4 >= 0x8000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int16(uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, _QWORD *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

__int16 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;

  v3 = *result + *a2;
  if ((__int16)(*result + *a2) == v3)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

uint64_t static Int16.+ infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result;

  result = (a1 + a2);
  if ((__int16)result != (_DWORD)result)
    __break(1u);
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int16(__int16 *result, __int16 *a2)
{
  int v2;

  v2 = *result + *a2;
  if ((__int16)(*result + *a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3;

  v3 = *result - *a2;
  if ((__int16)(*result - *a2) == v3)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

uint64_t static Int16.- infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result;

  result = (a1 - a2);
  if ((__int16)result != (_DWORD)result)
    __break(1u);
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int16(__int16 *result, __int16 *a2)
{
  int v2;

  v2 = *result - *a2;
  if ((__int16)(*result - *a2) == v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a2 >= *a1;
}

BOOL static Int16.<= infix(_:_:)(__int16 a1, __int16 a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a1 >= *a2;
}

BOOL static Int16.>= infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a2 < *a1;
}

void Int16.hash(into:)(int a1, Swift::UInt16 a2)
{
  Hasher._combine(_:)(a2);
}

Swift::Int __swiftcall Int16._rawHashValue(seed:)(Swift::Int seed)
{
  unsigned __int16 v1;

  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 2);
}

uint64_t Int16.hashValue.getter(unsigned __int16 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 2);
}

void protocol witness for Hashable.hash(into:) in conformance Int16()
{
  Swift::UInt16 *v0;

  Hasher._combine(_:)(*v0);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int16(uint64_t a1)
{
  unsigned __int16 *v1;

  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Int16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 == *a2;
}

uint64_t Int16._toCustomAnyHashable()@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int16>);
  *(_QWORD *)(a2 + 24) = result;
  *(_QWORD *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int16@<X0>(uint64_t a1@<X8>)
{
  __int16 *v1;
  __int16 v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int16>);
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a1 = v3;
  return result;
}

uint64_t UInt32._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt32._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt32 because it is either infinite or NaN", 80, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1858uLL, 0);
  __asm { FCVT            S0, H0 }
  if (_S0 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt32 because the result would be less than UInt32.min", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x185BuLL, 0);
  return _S0;
}

unint64_t UInt32.init(exactly:)(float _S0)
{
  float v6;
  _BOOL4 v9;
  uint64_t v10;

  __asm { FCVT            S1, H0 }
  if (_S1 <= -1.0)
  {
    v10 = 0;
    LOBYTE(v9) = 1;
  }
  else
  {
    v6 = _S0;
    _S0 = truncf(_S1);
    __asm
    {
      FCVT            H0, S0
      FCVT            S0, H0
    }
    v9 = (~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1;
    v10 = _S1;
    if (v9)
      v10 = 0;
  }
  return v10 | ((unint64_t)v9 << 32);
}

Swift::UInt32 __swiftcall UInt32.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt32 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18A6uLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt32 because the result would be less than UInt32.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18A9uLL, 0);
  if (a1 >= 4295000000.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt32 because the result would be greater than UInt32.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18ACuLL, 0);
  return a1;
}

Swift::UInt32_optional __swiftcall UInt32.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = exactly > -1.0;
  if (exactly >= 4295000000.0)
    v1 = 0;
  v3 = v1 & (truncf(exactly) == exactly);
  v2 = v3 == 0;
  v4 = (v3 & 1) == 0;
  if (v2)
    v5 = 0;
  else
    v5 = exactly;
  return (Swift::UInt32_optional)(v5 | (v4 << 32));
}

Swift::UInt32 __swiftcall UInt32.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt32 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18EEuLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt32 because the result would be less than UInt32.min", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18F1uLL, 0);
  if (a1 >= 4294967300.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt32 because the result would be greater than UInt32.max", 94, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18F4uLL, 0);
  return a1;
}

Swift::UInt32_optional __swiftcall UInt32.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = exactly > -1.0;
  if (exactly >= 4294967300.0)
    v1 = 0;
  v3 = v1 & (trunc(exactly) == exactly);
  v2 = v3 == 0;
  v4 = (v3 & 1) == 0;
  if (v2)
    v5 = 0;
  else
    v5 = exactly;
  return (Swift::UInt32_optional)(v5 | (v4 << 32));
}

unsigned int *static UInt32.-= infix(_:_:)(unsigned int *result, unsigned int a2)
{
  if (*result < a2)
    __break(1u);
  else
    *result -= a2;
  return result;
}

_DWORD *static UInt32.*= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  unint64_t v2;

  v2 = *result * (unint64_t)a2;
  if ((v2 & 0xFFFFFFFF00000000) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

_DWORD *static UInt32./= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.subtractingReportingOverflow(_:)(Swift::UInt32 a1)
{
  _BOOL4 v1;
  Swift::UInt32 v2;
  Swift::tuple_partialValue_UInt32_overflow_Bool result;

  v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.multipliedReportingOverflow(by:)(Swift::UInt32 by)
{
  _BOOL4 v1;
  Swift::UInt32 v2;
  Swift::tuple_partialValue_UInt32_overflow_Bool result;

  v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.dividedReportingOverflow(by:)(Swift::UInt32 by)
{
  Swift::UInt32 v1;
  Swift::UInt32 v2;
  Swift::tuple_partialValue_UInt32_overflow_Bool result;

  if (by)
    v1 /= by;
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.remainderReportingOverflow(dividingBy:)(Swift::UInt32 dividingBy)
{
  Swift::UInt32 v1;
  Swift::UInt32 v2;
  Swift::tuple_partialValue_UInt32_overflow_Bool result;

  if (dividingBy)
    v1 %= dividingBy;
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

_DWORD *static UInt32.%= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1AB6uLL, 0);
  *result %= a2;
  return result;
}

uint64_t UInt32._lowWord.getter(uint64_t result)
{
  return result;
}

uint64_t UInt32.Words._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt32.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.Words.count.getter()
{
  return 1;
}

uint64_t UInt32.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt32.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt32.Words.indices.getter()
{
  return 0;
}

uint64_t UInt32.Words.subscript.getter(uint64_t a1, unsigned int a2)
{
  if (a1 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1BB3uLL, 0);
  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1BB4uLL, 0);
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt32.Words(uint64_t *a1, uint64_t *a2))()
{
  unsigned int *v2;

  *a1 = UInt32.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance UInt32.Words()
{
  unsigned int *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt32.Words(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unsigned int *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt32_low_UInt32 __swiftcall UInt32.multipliedFullWidth(by:)(Swift::UInt32 by)
{
  Swift::UInt32 v1;
  Swift::UInt32 v2;
  Swift::tuple_high_UInt32_low_UInt32 result;

  v2 = __ROR8__(v1 * (unint64_t)by, 32);
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt32_remainder_UInt32 __swiftcall UInt32.dividingFullWidth(_:)(Swift::tuple_quotient_UInt32_remainder_UInt32 result)
{
  Swift::UInt32 v1;
  unsigned int v2;
  Swift::UInt32 v3;

  if (!v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1C19uLL, 0);
  if (result.quotient >= v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1C1BuLL, 0);
  v3 = (result.remainder | (__PAIR64__(v2, result.quotient) << 32)) / v1;
  result.quotient = v3;
  return result;
}

Swift::UInt32 __swiftcall UInt32.signum()()
{
  int v0;

  return v0 != 0;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt32()
{
  return 32;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt32(_DWORD *a1@<X8>)
{
  *a1 = -1;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt32(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2;
  _BOOL8 v3;

  v3 = __CFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt32(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2;
  _BOOL8 v3;

  v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt32(_DWORD *a1, unsigned int *a2)
{
  unsigned int *v2;
  unint64_t v3;

  v3 = *v2 * (unint64_t)*a2;
  *a1 = v3;
  return (v3 & 0xFFFFFFFF00000000) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt32(_DWORD *a1, unsigned int *a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
    v4 /= v3;
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt32(_DWORD *a1, unsigned int *a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
    v4 %= v3;
  *a1 = v4;
  return v3 == 0;
}

_DWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt32(_DWORD *result, _DWORD *a2, unsigned int *a3)
{
  unsigned int *v3;
  unint64_t v4;

  v4 = *v3 * (unint64_t)*a3;
  *result = HIDWORD(v4);
  *a2 = v4;
  return result;
}

Swift::UInt32 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt32(Swift::UInt32 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  Swift::UInt32 result;
  int v7;

  result = UInt32.dividingFullWidth(_:)((Swift::tuple_high_UInt32_low_UInt32)__PAIR64__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  *result >>= *a2;
  return result;
}

_DWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt32@<X0>(_DWORD *result@<X0>, unint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  if (a2 >> 9 <= 0x10 && (a2 & 1) == 0)
    *a3 = *result;
  else
    *a3 = 0;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _DWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32 and conformance UInt32, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  char v23;
  uint64_t v24;
  unint64_t AssociatedConformanceWitness;
  char *v26;
  char v27;
  void (*v28)(char *, uint64_t);
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  void (*v36)(char *, uint64_t);
  unsigned int v37;
  char *v38;
  unsigned int v39;
  char v40;
  unsigned int v41;
  int v42;
  uint64_t result;
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  _DWORD *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  unsigned int v53;

  v46 = a4;
  v47 = a5;
  v49 = a6;
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v48 = (char *)&v44 - v12;
  v52 = *(_QWORD *)(a2 - 8);
  v13 = MEMORY[0x1E0C80A78](v11);
  v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v51 = (char *)&v44 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v44 - v18;
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v44 - v20;
  v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v23 = v22(a2, a3);
  v50 = a1;
  if ((v23 & 1) != 0)
  {
    v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 32))(v21, v19, a2);
    v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    v28(v21, a2);
    a1 = v50;
  }
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v30 = a1;
  if (v29(a2, a3) >= 32)
  {
    v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    v53 = -1;
    v31 = v22(a2, a3);
    v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 33)
      {
        v33 = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 40))(v51, v19, a2);
        v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        v37 = v53;
        v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        v30 = v50;
        if ((v34 & 1) != 0)
        {
          v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39)
            goto LABEL_14;
        }
        else
        {
          v36(v38, a2);
        }
        goto LABEL_16;
      }
    }
    else if (v32 <= 32)
    {
      v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      v30 = v50;
      if (v53 < v41)
        goto LABEL_14;
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }
    (*(void (**)(unsigned int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    v35 = v51;
    v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v19, v51, a2);
    v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    v30 = v50;
    if ((v40 & 1) != 0)
LABEL_14:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    goto LABEL_16;
  }
LABEL_17:
  v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *v49 = v42;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt32@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt32 and conformance UInt32((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt32()
{
  unsigned int *v0;

  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt32()
{
  unsigned int *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_DWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  *a3 = *result / *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  *result /= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1AB6uLL, 0);
  *a3 = *result % *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1AB6uLL, 0);
  *result %= *a2;
  return result;
}

uint64_t static UInt32.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt32@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t v52;
  char *v53;
  void (*v54)(char *, uint64_t);
  unsigned int v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t (*v63)(char *, uint64_t);
  uint64_t v64;
  void (*v65)(char *, uint64_t, uint64_t);
  char *v66;
  char v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char v86;
  void (*v87)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v88;
  char v89;
  void (**v90)(char *, uint64_t, const char *);
  unint64_t v91;
  unint64_t AssociatedConformanceWitness;
  char *v93;
  char *v94;
  char *v95;
  int64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  char *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  int64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t (*v115)(char *, uint64_t);
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  unsigned int v122;
  char *v123;
  char *v124;
  uint64_t (*v125)(uint64_t, uint64_t);
  unsigned int *v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v126 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v114 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v123 = (char *)&v114 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v117 = (char *)&v114 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v114 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v124 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v122 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v121 = v19;
  v127 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v129 = -32;
      v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -32)
        goto LABEL_24;
    }
LABEL_18:
    v56 = v127(a3, a4);
    v57 = v33(a3, a4);
    v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64)
        goto LABEL_20;
    }
    else if (v57 > 63)
    {
LABEL_20:
      v129 = 32;
      v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
      v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v66 = v124;
        v65(v124, a2, a3);
        v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          v71 = v123;
          v70 = v124;
          v68 = v125;
          v79 = v125(a3, a4);
          goto LABEL_47;
        }
        v68 = v125;
        v69 = v125(a3, a4);
        v63(v26, a3);
        v71 = v123;
        v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          v79 = v68(a3, a4);
LABEL_47:
          v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            v109 = v68(a3, a4);
            v63(v71, a3);
            v110 = v109 == 64;
            v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              result = v63(v70, a3);
              if ((v112 & 0x8000000000000000) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFE0)
                {
                  v55 = v122 << -(char)v112;
                  goto LABEL_64;
                }
              }
              else if (v112 < 0x20)
              {
                v55 = v122 >> v112;
                goto LABEL_64;
              }
              goto LABEL_24;
            }
          }
          else
          {
            v63(v71, a3);
            v100 = v127;
          }
          v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          v129 = 0x7FFFFFFFFFFFFFFFLL;
          v102 = v100(a3, a4);
          v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              v108 = &v129;
              goto LABEL_59;
            }
          }
          else if (v103 > 63)
          {
            v128 = 0x7FFFFFFFFFFFFFFFLL;
            v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v101, a3);
            v63(v30, a3);
            if ((v111 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_60;
          }
          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }
        v115 = v63;
        v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        v129 = 0x8000000000000000;
        v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            v77 = v72;
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129)
LABEL_69:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
            goto LABEL_44;
          }
          v77 = v72;
          v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v77, v30, a3);
        }
        else
        {
          v80 = v73(a3, a4);
          v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            v63 = v115;
            if (v81 > 64)
            {
              v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }
            v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }
          if (v81 <= 64)
          {
            v91 = AssociatedTypeWitness;
            v90 = (void (**)(char *, uint64_t, const char *))v120;
            AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))(&qword_1816B7DA8, 256, v91, AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v117, v30, a3);
            v115(v30, a3);
            v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }
            v96 = v129;
            v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v95, a3);
            v98 = v97 < v96;
            v70 = v124;
            v77 = v117;
            if (v98)
              goto LABEL_69;
LABEL_44:
            v113 = v77;
            goto LABEL_45;
          }
          v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          v77 = v117;
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
        }
        v89 = v86;
        v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0)
          goto LABEL_69;
        goto LABEL_44;
      }
LABEL_24:
      v55 = 0;
      goto LABEL_64;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v63(v30, a3);
    if (v64 <= 32)
      goto LABEL_25;
    goto LABEL_24;
  }
  v39 = v31(a3, a4);
  v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      v33 = v125;
      goto LABEL_18;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }
  if (v40 > 64)
  {
    v129 = -32;
    v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    v33 = v125;
    if ((v45 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v50 = AssociatedTypeWitness;
  v51 = v120;
  v52 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))(&qword_1816B7DA8, 256, v50, v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
  v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    v33 = v125;
    if (v49 < -32)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  v55 = 0;
LABEL_64:
  *v126 = v55;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt32(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  unsigned int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  unsigned int *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unsigned int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t AssociatedConformanceWitness;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  unsigned int *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unsigned int v130;
  char *v131;
  unsigned int *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(unsigned int **)(a4 + 128);
    v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      v144 = -32;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 < -32)
        goto LABEL_24;
    }
LABEL_18:
    v62 = v141(a3, a4);
    v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64)
        goto LABEL_20;
    }
    else if (v63 >= 64)
    {
LABEL_20:
      v144 = 32;
      v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
      v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v74 = v140;
        v73(v140, a2, a3);
        v75 = v141(a3, a4);
        v76 = v139;
        v77 = v74;
        v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          v80 = v140;
          goto LABEL_42;
        }
        v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
        v70(v76, a3);
        v80 = v140;
        if (v79 <= 64)
          goto LABEL_42;
        v81 = v135;
        v78(v135, v140, a3);
        v144 = 0x8000000000000000;
        v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if (v83 >= 64)
          {
            v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v135, v88, a3);
            v89 = v88;
            v81 = v135;
            v70(v89, a3);
            if ((v86 & 1) != 0)
              goto LABEL_64;
            goto LABEL_41;
          }
        }
        else
        {
          v90 = v82(a3, a4);
          v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              v102 = (void (**)(char *, uint64_t, const char *))v137;
              v103 = v133;
              AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v103, AssociatedConformanceWitness);
              v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                + 16))(v135, v106, a3);
              v108 = v106;
              v81 = v107;
              v70(v108, a3);
              v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }
              v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              v112 = v111 < v110;
              v80 = v140;
              if (v112)
                goto LABEL_64;
            }
            else
            {
              v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              v97 = v135;
              v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
              v99 = v96;
              v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0)
                goto LABEL_64;
            }
            goto LABEL_41;
          }
          if (v91 >= 64)
            goto LABEL_41;
        }
        v100 = v142;
        v78(v142, v81, a3);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144)
LABEL_64:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        v113 = v132;
        v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
          v70(v115, a3);
          v125 = v124 == 64;
          v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            result = v70(v80, a3);
            v130 = *v39;
            if ((v129 & 0x8000000000000000) != 0)
            {
              if (v129 >= 0xFFFFFFFFFFFFFFE1)
              {
                v61 = v130 << -(char)v129;
                goto LABEL_59;
              }
            }
            else if (v129 < 0x20)
            {
              v61 = v130 >> v129;
              goto LABEL_59;
            }
            goto LABEL_24;
          }
        }
        else
        {
          v70(v115, a3);
          v116 = v141;
        }
        v78(v40, v80, a3);
        v144 = 0x7FFFFFFFFFFFFFFFLL;
        v117 = v116(a3, a4);
        v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            v123 = &v144;
            goto LABEL_54;
          }
        }
        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          v123 = &v143;
LABEL_54:
          v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
          v70(v127, a3);
          if ((v128 & 1) != 0)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          goto LABEL_55;
        }
        v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }
LABEL_24:
      v61 = 0;
      goto LABEL_59;
    }
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 32)
      goto LABEL_25;
    goto LABEL_24;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(unsigned int **)(a4 + 128);
  v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_18;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }
  if (v42 > 64)
  {
    v144 = -32;
    v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    v40 = v131;
    v39 = v132;
    if ((v48 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v55 = v137;
  v56 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v56);
  v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
  v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 < -32)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  v61 = 0;
  v39 = v132;
LABEL_59:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt32@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t v52;
  char *v53;
  void (*v54)(char *, uint64_t);
  unsigned int v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t (*v63)(char *, uint64_t);
  uint64_t v64;
  void (*v65)(char *, uint64_t, uint64_t);
  char *v66;
  char v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char v86;
  void (*v87)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v88;
  char v89;
  void (**v90)(char *, uint64_t, const char *);
  unint64_t v91;
  unint64_t AssociatedConformanceWitness;
  char *v93;
  char *v94;
  char *v95;
  int64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  char *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  int64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t (*v115)(char *, uint64_t);
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  unsigned int v122;
  char *v123;
  char *v124;
  uint64_t (*v125)(uint64_t, uint64_t);
  unsigned int *v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v126 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v114 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v123 = (char *)&v114 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v117 = (char *)&v114 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v114 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v124 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v122 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v121 = v19;
  v127 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v129 = -32;
      v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -32)
        goto LABEL_24;
    }
LABEL_18:
    v56 = v127(a3, a4);
    v57 = v33(a3, a4);
    v125 = v33;
    if ((v56 & 1) != 0)
    {
      if (v57 > 64)
        goto LABEL_20;
    }
    else if (v57 > 63)
    {
LABEL_20:
      v129 = 32;
      v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
      v60(&v129, &type metadata for Int, v61, a3, a4);
      v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
      v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v63(v30, a3);
      if ((v62 & 1) == 0)
      {
LABEL_25:
        v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v66 = v124;
        v65(v124, a2, a3);
        v67 = v127(a3, a4);
        v65(v26, (uint64_t)v66, a3);
        if ((v67 & 1) == 0)
        {
          v63(v26, a3);
          v71 = v123;
          v70 = v124;
          v68 = v125;
          v79 = v125(a3, a4);
          goto LABEL_47;
        }
        v68 = v125;
        v69 = v125(a3, a4);
        v63(v26, a3);
        v71 = v123;
        v70 = v124;
        if (v69 <= 64)
        {
LABEL_46:
          v79 = v68(a3, a4);
LABEL_47:
          v99 = v79;
          v65(v71, (uint64_t)v70, a3);
          if (v99 < 65)
          {
            v109 = v68(a3, a4);
            v63(v71, a3);
            v110 = v109 == 64;
            v100 = v127;
            if (!v110 || (v127(a3, a4) & 1) != 0)
            {
LABEL_61:
              v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              result = v63(v70, a3);
              if ((v112 & 0x8000000000000000) != 0)
              {
                if (v112 > 0xFFFFFFFFFFFFFFE0)
                {
                  v55 = v122 >> -(char)v112;
                  goto LABEL_64;
                }
              }
              else if (v112 <= 0x1F)
              {
                v55 = v122 << v112;
                goto LABEL_64;
              }
              goto LABEL_24;
            }
          }
          else
          {
            v63(v71, a3);
            v100 = v127;
          }
          v101 = v121;
          v65(v121, (uint64_t)v70, a3);
          v129 = 0x7FFFFFFFFFFFFFFFLL;
          v102 = v100(a3, a4);
          v103 = v68(a3, a4);
          if ((v102 & 1) != 0)
          {
            if (v103 > 64)
            {
              v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              v108 = &v129;
              goto LABEL_59;
            }
          }
          else if (v103 > 63)
          {
            v128 = 0x7FFFFFFFFFFFFFFFLL;
            v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
            v108 = &v128;
LABEL_59:
            v106(v108, &type metadata for Int, v107, a3, a4);
            v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v101, a3);
            v63(v30, a3);
            if ((v111 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_60;
          }
          v65(v30, (uint64_t)v101, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v63(v30, a3);
LABEL_60:
          v63(v101, a3);
          goto LABEL_61;
        }
        v115 = v63;
        v72 = v117;
        v65(v117, (uint64_t)v124, a3);
        v129 = 0x8000000000000000;
        v73 = v127;
        if ((v127(a3, a4) & 1) != 0)
        {
          v74 = v68(a3, a4);
          if (v74 < 64)
          {
            v65(v30, (uint64_t)v72, a3);
            v77 = v72;
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v30, a3);
LABEL_40:
            if (v78 < v129)
LABEL_69:
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
            goto LABEL_44;
          }
          v77 = v72;
          v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
          v87(&v129, &type metadata for Int, v88, a3, a4);
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v77, v30, a3);
        }
        else
        {
          v80 = v73(a3, a4);
          v81 = v68(a3, a4);
          if ((v80 & 1) == 0)
          {
            v63 = v115;
            if (v81 > 64)
            {
              v113 = v117;
LABEL_45:
              v63(v113, a3);
              goto LABEL_46;
            }
            v77 = v117;
            v65(v30, (uint64_t)v117, a3);
            v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
            goto LABEL_40;
          }
          if (v81 <= 64)
          {
            v91 = AssociatedTypeWitness;
            v90 = (void (**)(char *, uint64_t, const char *))v120;
            AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v93 = v118;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                           + 8))(&qword_1816B7DA8, 256, v91, AssociatedConformanceWitness);
            v90[3](v93, a3, (const char *)v90);
            v94 = v117;
            LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v117, v30, a3);
            v115(v30, a3);
            v95 = v116;
            v65(v116, (uint64_t)v94, a3);
            if ((v90 & 1) != 0)
            {
              v115(v95, a3);
              goto LABEL_69;
            }
            v96 = v129;
            v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63 = v115;
            v115(v95, a3);
            v98 = v97 < v96;
            v70 = v124;
            v77 = v117;
            if (v98)
              goto LABEL_69;
LABEL_44:
            v113 = v77;
            goto LABEL_45;
          }
          v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
          v84(&v129, &type metadata for Int, v85, a3, a4);
          v77 = v117;
          v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
        }
        v89 = v86;
        v63 = v115;
        v115(v30, a3);
        if ((v89 & 1) != 0)
          goto LABEL_69;
        goto LABEL_44;
      }
LABEL_24:
      v55 = 0;
      goto LABEL_64;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v63(v30, a3);
    if (v64 <= 32)
      goto LABEL_25;
    goto LABEL_24;
  }
  v39 = v31(a3, a4);
  v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 > 64)
    {
      v33 = v125;
      goto LABEL_18;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    goto LABEL_17;
  }
  if (v40 > 64)
  {
    v129 = -32;
    v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    v33 = v125;
    if ((v45 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v50 = AssociatedTypeWitness;
  v51 = v120;
  v52 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))(&qword_1816B7DA8, 256, v50, v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
  v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
LABEL_17:
    v33 = v125;
    if (v49 < -32)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  v55 = 0;
LABEL_64:
  *v126 = v55;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt32(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  unsigned int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  unsigned int *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t v56;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unsigned int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t AssociatedConformanceWitness;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  unsigned int *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unsigned int v130;
  char *v131;
  unsigned int *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(unsigned int **)(a4 + 128);
    v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      v144 = -32;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 < -32)
        goto LABEL_24;
    }
LABEL_18:
    v62 = v141(a3, a4);
    v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v62 & 1) != 0)
    {
      if (v63 > 64)
        goto LABEL_20;
    }
    else if (v63 >= 64)
    {
LABEL_20:
      v144 = 32;
      v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
      v68 = v142;
      v66(&v144, &type metadata for Int, v67, a3, a4);
      v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
      v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v70(v68, a3);
      if ((v69 & 1) == 0)
      {
LABEL_25:
        v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
        v74 = v140;
        v73(v140, a2, a3);
        v75 = v141(a3, a4);
        v76 = v139;
        v77 = v74;
        v78 = (void (*)(char *, char *, uint64_t))v73;
        v73(v139, (uint64_t)v77, a3);
        v132 = v32;
        if ((v75 & 1) == 0)
        {
          v70(v76, a3);
          v80 = v140;
          goto LABEL_42;
        }
        v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
        v70(v76, a3);
        v80 = v140;
        if (v79 <= 64)
          goto LABEL_42;
        v81 = v135;
        v78(v135, v140, a3);
        v144 = 0x8000000000000000;
        v82 = v141;
        if ((v141(a3, a4) & 1) != 0)
        {
          v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if (v83 >= 64)
          {
            v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
            v88 = v142;
            v86(&v144, &type metadata for Int, v87, a3, a4);
            LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                             + 16))(v135, v88, a3);
            v89 = v88;
            v81 = v135;
            v70(v89, a3);
            if ((v86 & 1) != 0)
              goto LABEL_64;
            goto LABEL_41;
          }
        }
        else
        {
          v90 = v82(a3, a4);
          v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
          if ((v90 & 1) != 0)
          {
            if (v91 <= 64)
            {
              v102 = (void (**)(char *, uint64_t, const char *))v137;
              v103 = v133;
              AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v105 = v136;
              (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v103, AssociatedConformanceWitness);
              v106 = v142;
              v102[3](v105, a3, (const char *)v102);
              v107 = v135;
              LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                + 16))(v135, v106, a3);
              v108 = v106;
              v81 = v107;
              v70(v108, a3);
              v109 = v134;
              v78(v134, v107, a3);
              if ((v102 & 1) != 0)
              {
                v70(v109, a3);
                goto LABEL_64;
              }
              v110 = v144;
              v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v70(v109, a3);
              v112 = v111 < v110;
              v80 = v140;
              if (v112)
                goto LABEL_64;
            }
            else
            {
              v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
              v96 = v142;
              v94(&v144, &type metadata for Int, v95, a3, a4);
              v97 = v135;
              v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
              v99 = v96;
              v81 = v97;
              v70(v99, a3);
              if ((v98 & 1) != 0)
                goto LABEL_64;
            }
            goto LABEL_41;
          }
          if (v91 >= 64)
            goto LABEL_41;
        }
        v100 = v142;
        v78(v142, v81, a3);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v100, a3);
        if (v101 < v144)
LABEL_64:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
        v70(v81, a3);
LABEL_42:
        v113 = v132;
        v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        v115 = v138;
        v78(v138, v80, a3);
        if (v114 < 65)
        {
          v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
          v70(v115, a3);
          v125 = v124 == 64;
          v116 = v141;
          if (!v125 || (v141(a3, a4) & 1) != 0)
          {
LABEL_56:
            v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            result = v70(v80, a3);
            v130 = *v39;
            if ((v129 & 0x8000000000000000) != 0)
            {
              if (v129 > 0xFFFFFFFFFFFFFFE0)
              {
                v61 = v130 >> -(char)v129;
                goto LABEL_59;
              }
            }
            else if (v129 < 0x20)
            {
              v61 = v130 << v129;
              goto LABEL_59;
            }
            goto LABEL_24;
          }
        }
        else
        {
          v70(v115, a3);
          v116 = v141;
        }
        v78(v40, v80, a3);
        v144 = 0x7FFFFFFFFFFFFFFFLL;
        v117 = v116(a3, a4);
        v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
        if ((v117 & 1) != 0)
        {
          if (v118 > 64)
          {
            v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
            v123 = &v144;
            goto LABEL_54;
          }
        }
        else if (v118 >= 64)
        {
          v143 = 0x7FFFFFFFFFFFFFFFLL;
          v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
          v123 = &v143;
LABEL_54:
          v127 = v142;
          v121(v123, &type metadata for Int, v122, a3, a4);
          v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
          v70(v127, a3);
          if ((v128 & 1) != 0)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          goto LABEL_55;
        }
        v126 = v142;
        v78(v142, v40, a3);
        (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v126, a3);
LABEL_55:
        v70(v40, a3);
        goto LABEL_56;
      }
LABEL_24:
      v61 = 0;
      goto LABEL_59;
    }
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 32)
      goto LABEL_25;
    goto LABEL_24;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(unsigned int **)(a4 + 128);
  v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_18;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    goto LABEL_17;
  }
  if (v42 > 64)
  {
    v144 = -32;
    v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
    v47 = v142;
    v45(&v144, &type metadata for Int, v46, a3, a4);
    v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
    v40 = v131;
    v39 = v132;
    if ((v48 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v55 = v137;
  v56 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v57 = v136;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v56 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v56);
  v58 = v142;
  (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
  v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
  v60 = *(void (**)(char *, uint64_t))(v11 + 8);
  v60(v58, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v59 & 1) == 0)
  {
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 < -32)
      goto LABEL_24;
    goto LABEL_18;
  }
  result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
  v61 = 0;
  v39 = v132;
LABEL_59:
  *v39 = v61;
  return result;
}

int *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt32(int *result, int *a2, unsigned int *a3)
{
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v4 = *a3;
  if (!*a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  v5 = *v3;
  *a2 = *v3 % v4;
  *result = v5 / v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt32(unsigned int *a1)
{
  unsigned int *v1;

  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt32(_DWORD *a1@<X8>)
{
  _DWORD *v1;

  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char v23;
  void (*v24)(char *, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  char v26;
  void (*v27)(char *, uint64_t);
  char *v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  char *v34;
  uint64_t (*v35)(uint64_t, _QWORD *);
  uint64_t v36;
  char *v37;
  int v38;
  uint64_t result;
  char v40;
  void (*v41)(char *, uint64_t);
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  unsigned int v53;
  char *v54;
  unsigned int v55;
  BOOL v56;
  void (*v57)(unsigned int *, uint64_t, unint64_t, uint64_t, _QWORD *);
  unint64_t v58;
  char *v59;
  char *v60;
  unsigned int v61;
  char *v62;
  unint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  char *v67;
  uint64_t (*v68)(uint64_t, _QWORD *);
  void (*v69)(char *, uint64_t, uint64_t);
  char *v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;

  v66 = a4;
  v71 = a5;
  v8 = *(_QWORD *)(a3[3] + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v62 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v65 = (char *)&v62 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v70 = (char *)&v62 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v62 - v19;
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v62 - v21;
  v68 = (uint64_t (*)(uint64_t, _QWORD *))a3[8];
  v23 = v68(a2, a3);
  v24 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v72 = a1;
  v69 = v24;
  v24(v22, a1, a2);
  v67 = v20;
  v63 = AssociatedTypeWitness;
  v64 = v8;
  v62 = v12;
  if ((v23 & 1) != 0)
  {
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v12, a2, v8);
    v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(a3[4] + 8) + 16))(v22, v20, a2);
    v27 = *(void (**)(char *, uint64_t))(v13 + 8);
    v27(v20, a2);
    v28 = v22;
    v29 = v27;
    v27(v28, a2);
    v31 = v71;
    v30 = v72;
    v32 = v13;
    v33 = a3;
    if ((v26 & 1) != 0)
      goto LABEL_17;
  }
  else
  {
    v34 = v22;
    v29 = *(void (**)(char *, uint64_t))(v13 + 8);
    v29(v34, a2);
    v30 = v72;
    v32 = v13;
    v33 = a3;
  }
  v35 = (uint64_t (*)(uint64_t, _QWORD *))v33[16];
  v36 = v35(a2, v33);
  v37 = v70;
  v69(v70, v30, a2);
  if (v36 <= 31)
  {
    v29(v37, a2);
    v31 = v71;
    goto LABEL_7;
  }
  v41 = v29;
  v73 = -1;
  v42 = v68(a2, v33);
  v43 = v35(a2, v33);
  if ((v42 & 1) != 0)
  {
    if (v43 < 33)
    {
      v47 = v63;
      v46 = v64;
      v48 = swift_getAssociatedConformanceWitness(v64, a2, v63, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v49 = v62;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v48 + 8))(&qword_1816B7DA8, 256, v47, v48);
      v50 = v67;
      (*(void (**)(char *, uint64_t, uint64_t))(v46 + 24))(v49, a2, v46);
      LOBYTE(v46) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v33[4] + 8) + 40))(v37, v50, a2);
      v51 = v50;
      v29 = v41;
      v41(v51, a2);
      v52 = v37;
      v53 = v73;
      v54 = v65;
      (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v65, v52, a2);
      if ((v46 & 1) == 0)
      {
        v41(v54, a2);
        v31 = v71;
        v30 = v72;
        goto LABEL_7;
      }
      v55 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
      v41(v54, a2);
      v56 = v53 >= v55;
      goto LABEL_16;
    }
LABEL_13:
    v57 = (void (*)(unsigned int *, uint64_t, unint64_t, uint64_t, _QWORD *))v33[12];
    v58 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v43, v44, v45);
    v59 = v67;
    v57(&v73, v66, v58, a2, v33);
    LOBYTE(v57) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v33[4] + 8) + 16))(v59, v37, a2);
    v29 = v41;
    v41(v59, a2);
    v41(v37, a2);
    v31 = v71;
    v30 = v72;
    if ((v57 & 1) != 0)
      goto LABEL_17;
    goto LABEL_7;
  }
  if (v43 >= 33)
    goto LABEL_13;
  v60 = v67;
  (*(void (**)(char *, char *, uint64_t))(v32 + 32))(v67, v37, a2);
  v61 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
  v29 = v41;
  v41(v60, a2);
  v56 = v73 >= v61;
LABEL_16:
  v31 = v71;
  v30 = v72;
  if (!v56)
  {
LABEL_17:
    result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
    v38 = 0;
    v40 = 1;
    goto LABEL_18;
  }
LABEL_7:
  v38 = ((uint64_t (*)(uint64_t, _QWORD *))v33[15])(a2, v33);
  result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v30, a2);
  v40 = 0;
LABEL_18:
  *(_DWORD *)v31 = v38;
  *(_BYTE *)(v31 + 4) = v40;
  return result;
}

unsigned int *protocol witness for static Numeric.* infix(_:_:) in conformance UInt32@<X0>(unsigned int *result@<X0>, unsigned int *a2@<X1>, _DWORD *a3@<X8>)
{
  unint64_t v3;

  v3 = *result * (unint64_t)*a2;
  if ((v3 & 0xFFFFFFFF00000000) != 0)
    __break(1u);
  else
    *a3 = v3;
  return result;
}

unint64_t static UInt32.* infix(_:_:)(unsigned int a1, unsigned int a2)
{
  unint64_t result;

  result = a1 * (unint64_t)a2;
  if ((result & 0xFFFFFFFF00000000) != 0)
    __break(1u);
  return result;
}

_DWORD *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt32(_DWORD *result, unsigned int *a2)
{
  unint64_t v2;

  v2 = *result * (unint64_t)*a2;
  if ((v2 & 0xFFFFFFFF00000000) != 0)
    __break(1u);
  else
    *result = v2;
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt32()
{
  unsigned int *v0;

  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

_DWORD *protocol witness for Strideable.distance(to:) in conformance UInt32@<X0>(_DWORD *result@<X0>, uint64_t *a2@<X8>)
{
  _DWORD *v2;
  uint64_t v3;

  v3 = (*result - *v2);
  if (*result < *v2)
    v3 = -(uint64_t)(*v2 - *result);
  *a2 = v3;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt32@<X0>(unint64_t *result@<X0>, unsigned int *a2@<X8>)
{
  unsigned int *v2;
  unint64_t v3;
  unsigned int v4;
  BOOL v5;
  unint64_t v6;

  v3 = *result;
  v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (HIDWORD(v3))
      goto LABEL_10;
    v5 = __CFADD__(v4, (_DWORD)v3);
    v4 += v3;
    if (!v5)
      goto LABEL_9;
    __break(1u);
  }
  v6 = -(uint64_t)v3;
  if (HIDWORD(v6))
LABEL_10:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  v5 = v4 >= v6;
  v4 -= v6;
  if (!v5)
  {
    __break(1u);
    return result;
  }
LABEL_9:
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

_DWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__CFADD__(*result, *a2))
    __break(1u);
  else
    *a3 = *result + *a2;
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (__CFADD__(*result, *a2))
    __break(1u);
  else
    *result += *a2;
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (*result < *a2)
    __break(1u);
  else
    *a3 = *result - *a2;
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (*result < *a2)
    __break(1u);
  else
    *result -= *a2;
  return result;
}

uint64_t UInt32.hashValue.getter(unsigned int a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 4);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance UInt32()
{
  unsigned int *v0;

  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 4);
}

uint64_t UInt32._toCustomAnyHashable()@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt32>);
  *(_QWORD *)(a2 + 24) = result;
  *(_QWORD *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt32@<X0>(uint64_t a1@<X8>)
{
  int *v1;
  int v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt32>);
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a1 = v3;
  return result;
}

uint64_t Int32._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int32._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int32 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E43uLL, 0);
  __asm { FCVT            S0, H0 }
  return (int)_S0;
}

uint64_t Int32.init(exactly:)(float _S0)
{
  float v6;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;

  __asm { FCVT            S1, H0 }
  v6 = _S0;
  _S0 = truncf(_S1);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }
  v9 = (~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1;
  v10 = v9;
  if (v9)
    v11 = 0;
  else
    v11 = (int)_S1;
  return v11 | (v10 << 32);
}

Swift::Int32 __swiftcall Int32.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int32 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E8EuLL, 0);
  if (a1 <= -2147500000.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int32 because the result would be less than Int32.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E91uLL, 0);
  if (a1 >= 2147500000.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int32 because the result would be greater than Int32.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E94uLL, 0);
  return (int)a1;
}

Swift::Int32_optional __swiftcall Int32.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = exactly > -2147500000.0;
  if (exactly >= 2147500000.0)
    v1 = 0;
  v3 = v1 & (truncf(exactly) == exactly);
  v2 = v3 == 0;
  v4 = (v3 & 1) == 0;
  if (v2)
    v5 = 0;
  else
    v5 = (int)exactly;
  return (Swift::Int32_optional)(v5 | (v4 << 32));
}

Swift::Int32 __swiftcall Int32.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int32 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1ED6uLL, 0);
  if (a1 <= -2147483650.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int32 because the result would be less than Int32.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1ED9uLL, 0);
  if (a1 >= 2147483650.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int32 because the result would be greater than Int32.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1EDCuLL, 0);
  return (int)a1;
}

Swift::Int32_optional __swiftcall Int32.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  BOOL v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = exactly > -2147483650.0;
  if (exactly >= 2147483650.0)
    v1 = 0;
  v3 = v1 & (trunc(exactly) == exactly);
  v2 = v3 == 0;
  v4 = (v3 & 1) == 0;
  if (v2)
    v5 = 0;
  else
    v5 = (int)exactly;
  return (Swift::Int32_optional)(v5 | (v4 << 32));
}

_DWORD *static Int32.-= infix(_:_:)(_DWORD *result, int a2)
{
  if (__OFSUB__(*result, a2))
    __break(1u);
  else
    *result -= a2;
  return result;
}

int *static Int32.*= infix(_:_:)(int *result, int a2)
{
  uint64_t v2;

  v2 = *result * (uint64_t)a2;
  if (v2 == (int)v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

int *static Int32./= infix(_:_:)(int *result, int a2)
{
  int v2;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  v2 = *result;
  if (a2 == -1 && v2 == 0x80000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  *result = v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.addingReportingOverflow(_:)(Swift::Int32 a1)
{
  _BOOL4 v1;
  Swift::Int32 v2;
  Swift::tuple_partialValue_Int32_overflow_Bool result;

  v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.subtractingReportingOverflow(_:)(Swift::Int32 a1)
{
  _BOOL4 v1;
  Swift::Int32 v2;
  Swift::tuple_partialValue_Int32_overflow_Bool result;

  v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.multipliedReportingOverflow(by:)(Swift::Int32 by)
{
  _BOOL4 v1;
  Swift::Int32 v2;
  Swift::tuple_partialValue_Int32_overflow_Bool result;

  v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.dividedReportingOverflow(by:)(Swift::Int32 by)
{
  signed int v1;
  Swift::Int32 v2;
  Swift::tuple_partialValue_Int32_overflow_Bool result;

  if (by)
  {
    if (by == -1 && v1 == 0x80000000)
      v1 = 0x80000000;
    else
      v1 /= by;
  }
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.remainderReportingOverflow(dividingBy:)(Swift::Int32 dividingBy)
{
  Swift::Int32 v1;
  Swift::Int32 v2;
  Swift::tuple_partialValue_Int32_overflow_Bool result;

  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 0x80000000)
      v1 = 0;
    else
      v1 %= dividingBy;
  }
  v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

int *static Int32.%= infix(_:_:)(int *result, int a2)
{
  int v2;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  v2 = *result;
  if (a2 == -1 && v2 == 0x80000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  *result = v2 % a2;
  return result;
}

_DWORD *static Int32.&= infix(_:_:)(_DWORD *result, int a2)
{
  *result &= a2;
  return result;
}

_DWORD *static Int32.|= infix(_:_:)(_DWORD *result, int a2)
{
  *result |= a2;
  return result;
}

_DWORD *static Int32.^= infix(_:_:)(_DWORD *result, int a2)
{
  *result ^= a2;
  return result;
}

int *static Int32.&>>= infix(_:_:)(int *result, char a2)
{
  *result >>= a2;
  return result;
}

_DWORD *static Int32.&<<= infix(_:_:)(_DWORD *result, char a2)
{
  *result <<= a2;
  return result;
}

uint64_t static Int32.bitWidth.getter()
{
  return 32;
}

uint64_t Int32.leadingZeroBitCount.getter(unsigned int a1)
{
  return __clz(a1);
}

uint64_t Int32._lowWord.getter(uint64_t result)
{
  return (int)result;
}

uint64_t Int32.trailingZeroBitCount.getter(unsigned int a1)
{
  return __clz(__rbit32(a1));
}

uint64_t Int32.nonzeroBitCount.getter(__int32 a1, int8x8_t a2)
{
  uint8x8_t v2;

  a2.i32[0] = a1;
  v2 = (uint8x8_t)vcnt_s8(a2);
  v2.i16[0] = vaddlv_u8(v2);
  return v2.u32[0];
}

uint64_t Int32.Words._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int32.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.Words.count.getter()
{
  return 1;
}

uint64_t Int32.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int32.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int32.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int32.Words.index(after:)(Swift::Int after)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFADD__(after, 1);
  result = after + 1;
  if (v1)
    __break(1u);
  return result;
}

Swift::Int __swiftcall Int32.Words.index(before:)(Swift::Int before)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFSUB__(before, 1);
  result = before - 1;
  if (v1)
    __break(1u);
  return result;
}

uint64_t Int32.Words.subscript.getter(uint64_t a1, int a2)
{
  if (a1 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x21B1uLL, 0);
  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x21B2uLL, 0);
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int32.Words(uint64_t *a1, uint64_t *a2))()
{
  int *v2;

  *a1 = Int32.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UInt32.Words@<X0>(_QWORD *result@<X0>, uint64_t a2@<X8>)
{
  int *v2;
  uint64_t v3;
  int v4;

  if ((*result & 0x8000000000000000) != 0 || (v3 = result[1], v3 >= 2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  v4 = *v2;
  *(_QWORD *)a2 = *result;
  *(_QWORD *)(a2 + 8) = v3;
  *(_DWORD *)(a2 + 16) = v4;
  return result;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance Int32.Words()
{
  int *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int32.Words(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  int *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t Int32.magnitude.getter(uint64_t result)
{
  if ((int)result >= 0)
    return result;
  else
    return -(int)result;
}

Swift::tuple_high_Int32_low_UInt32 __swiftcall Int32.multipliedFullWidth(by:)(Swift::Int32 by)
{
  signed __int32 v1;
  Swift::Int32 v2;
  Swift::tuple_high_Int32_low_UInt32 result;

  v2 = __ROR8__(v1 * (uint64_t)by, 32);
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_Int32_remainder_Int32 __swiftcall Int32.dividingFullWidth(_:)(Swift::tuple_quotient_Int32_remainder_Int32 result)
{
  int v1;
  unsigned int v2;
  uint64_t v3;

  if (!v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2230uLL, 0);
  if (v1 == -1 && (result.remainder | (__PAIR64__(v2, result.quotient) << 32)) == 0x8000000000000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2BEEuLL, 0);
  v3 = (uint64_t)(result.remainder | (__PAIR64__(v2, result.quotient) << 32)) / v1;
  if (v3 != (int)v3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x223AuLL, 0);
  result.quotient = v3;
  return result;
}

uint64_t Int32.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1);
}

Swift::Int32 __swiftcall Int32.signum()()
{
  int v0;

  return (v0 > 0) | (v0 >> 31);
}

BOOL static Int32.> infix(_:_:)(int a1, int a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = 0x7FFFFFFF;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = 0x80000000;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2;
  _BOOL8 v3;

  v3 = __OFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2;
  _BOOL8 v3;

  v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int32(_DWORD *a1, int *a2)
{
  int *v2;
  uint64_t v3;

  v3 = *v2 * (uint64_t)*a2;
  *a1 = v3;
  return v3 != (int)v3;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int32(signed int *a1, int *a2)
{
  signed int *v2;
  int v3;
  signed int v4;
  uint64_t v6;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
  {
    if (v3 == -1 && v4 == 0x80000000)
    {
      v6 = 1;
      v4 = 0x80000000;
    }
    else
    {
      v6 = 0;
      v4 /= v3;
    }
  }
  else
  {
    v6 = 1;
  }
  *a1 = v4;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int32(_DWORD *a1, int *a2)
{
  int *v2;
  int v3;
  int v4;
  uint64_t v6;

  v3 = *a2;
  v4 = *v2;
  if (!*a2)
    goto LABEL_9;
  if (v3 == -1 && v4 == 0x80000000)
  {
    v4 = 0;
LABEL_9:
    v6 = 1;
    goto LABEL_7;
  }
  v6 = 0;
  v4 %= v3;
LABEL_7:
  *a1 = v4;
  return v6;
}

_DWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int32(_DWORD *result, _DWORD *a2, int *a3)
{
  int *v3;
  uint64_t v4;

  v4 = *v3 * (uint64_t)*a3;
  *result = HIDWORD(v4);
  *a2 = v4;
  return result;
}

Swift::Int32 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int32(Swift::Int32 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  Swift::Int32 result;
  int v7;

  result = Int32.dividingFullWidth(_:)((Swift::tuple_high_Int32_low_UInt32)__PAIR64__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int32()
{
  unsigned int *v0;
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int32()
{
  unsigned int *v0;

  return __clz(*v0);
}

unsigned int *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int32@<X0>(unsigned int *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = bswap32(*result);
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int32(_DWORD *a1@<X8>)
{
  unsigned int *v1;

  *a1 = bswap32(*v1);
}

int *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int32@<X0>(int *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

int *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int32(int *result, _DWORD *a2)
{
  *result >>= *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result << *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result <<= *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_DWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_DWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_DWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int32@<X0>(_DWORD *result@<X0>, unint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  if (a2 >> 8 <= 0x20)
    *a3 = *result;
  else
    *a3 = 0;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int32 and conformance Int32(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int32@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _DWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int32 and conformance Int32, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _DWORD *a6@<X8>)
{
  Class *v6;
  Class *v8;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t *TypeName;
  uint64_t v17;
  uint8x16_t *v18;
  int64_t v19;
  int64_t v20;
  int64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  Swift::String v26;
  uint64_t *v27;
  uint64_t v28;
  uint8x16_t *v29;
  int64_t v30;
  int64_t v31;
  int64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  Swift::String v37;
  char *v38;
  unint64_t v39;

  v8 = v6;
  v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((BYTE4(v38) & 1) != 0)
  {
    v38 = (char *)static String._createEmpty(withInitialCapacity:)(80);
    v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      v18 = (uint8x16_t *)TypeName;
      v19 = v17;
      v20 = validateUTF8(_:)(TypeName, v17);
      v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x8000000181762940;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        v29 = (uint8x16_t *)v27;
        v30 = v28;
        v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0)
          v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        else
          v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x8000000181762960;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = (_DWORD)v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int32@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char v28;
  void (*v29)(char *, char *, uint64_t);
  uint64_t v30;
  void (*v31)(char *, uint64_t);
  void (*v32)(char *, char *, uint64_t);
  char *v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t, uint64_t);
  char *v36;
  signed int v37;
  BOOL v38;
  uint64_t (*v39)(uint64_t, uint64_t);
  char v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char v44;
  char *v45;
  char *v46;
  char *v47;
  signed int v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  char v52;
  char *v53;
  signed int v54;
  signed int v55;
  uint64_t v56;
  char *v57;
  char v58;
  uint64_t v59;
  void (*v60)(int *, uint64_t, uint64_t, uint64_t, uint64_t);
  int *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char v65;
  int v66;
  uint64_t result;
  uint64_t v68;
  const char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char *v75;
  _DWORD *v76;
  void (*v77)(char *, char *, uint64_t);
  uint64_t (*v78)(uint64_t, uint64_t);
  char *v79;
  signed int v80;
  int v81;
  int v82;

  v72 = a4;
  v73 = a5;
  v76 = a6;
  v69 = *(const char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v69, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v68 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v70 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v74 = (char *)&v68 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v68 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v75 = (char *)&v68 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v68 - v24;
  MEMORY[0x1E0C80A78](v23);
  v27 = (char *)&v68 - v26;
  v78 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v28 = v78(a2, a3);
  v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  v79 = a1;
  v77 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    v71 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v30 = v71(a2, a3);
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 32)
    {
      v32 = v77;
      v77(v25, v79, a2);
      v80 = 0x80000000;
      v33 = v25;
      v34 = v78;
      if ((v78(a2, a3) & 1) != 0)
      {
        v35 = v71;
        if (v71(a2, a3) < 32)
        {
          v36 = v75;
          v32(v75, v33, a2);
          v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          v38 = v80 <= v37;
LABEL_18:
          v42 = v33;
LABEL_19:
          v46 = v79;
          if (!v38)
LABEL_40:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
          goto LABEL_21;
        }
        v45 = v75;
        (*(void (**)(signed int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v80, v72, v73, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v33, v45, a2);
        v31(v45, a2);
        v42 = v33;
        goto LABEL_11;
      }
      v40 = v34(a2, a3);
      v41 = v71(a2, a3);
      v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 32)
        {
          v49 = v69;
          AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v69, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
          v51 = v75;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v51, a2);
          v31(v51, a2);
          v53 = v70;
          v33 = v42;
          v32 = v77;
          v77(v70, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_40;
          }
          v54 = v80;
          v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          v38 = v54 <= v55;
          v35 = v71;
          goto LABEL_18;
        }
        v43 = v75;
        (*(void (**)(signed int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v80, v72, v73, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v43, a2);
        v31(v43, a2);
        v32 = v77;
        v35 = v71;
LABEL_11:
        v46 = v79;
        if ((v44 & 1) != 0)
          goto LABEL_40;
LABEL_21:
        v31(v42, a2);
        v39 = v78;
        goto LABEL_24;
      }
      if (v41 < 32)
      {
        v47 = v75;
        v32 = v77;
        v77(v75, v42, a2);
        v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        v38 = v80 <= v48;
        v35 = v71;
        goto LABEL_19;
      }
      v31(v33, a2);
    }
    v32 = v77;
    v39 = v78;
    v35 = v71;
  }
  else
  {
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v32 = v77;
    v39 = v78;
  }
  v46 = v79;
LABEL_24:
  v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 33)
  {
    v31(v20, a2);
    goto LABEL_26;
  }
  v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 32 && (v39(a2, a3) & 1) == 0)
  {
LABEL_26:
    v57 = v74;
    v32(v74, v46, a2);
    v82 = 0x7FFFFFFF;
    v58 = v39(a2, a3);
    v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 32)
      {
        v60 = *(void (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        v61 = &v82;
        goto LABEL_35;
      }
    }
    else if (v59 > 31)
    {
      v81 = 0x7FFFFFFF;
      v60 = *(void (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v61 = &v81;
LABEL_35:
      v64 = v75;
      v60(v61, v72, v73, a2, a3);
      v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v64, v57, a2);
      v31(v64, a2);
      if ((v65 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_36;
    }
    v63 = v75;
    v32(v75, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_36:
    v31(v57, a2);
  }
  v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *v76 = v66;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  int v7;
  uint64_t result;

  v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int32@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int32 and conformance Int32((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int32()
{
  int *v0;

  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int32()
{
  signed int *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int32()
{
  unsigned int *v0;

  return __clz(__rbit32(*v0));
}

_DWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, int *a2@<X1>, int *a3@<X8>)
{
  int v3;

  v3 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  if (*result == 0x80000000 && v3 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  *a3 = *result / v3;
  return result;
}

uint64_t static Int32./ infix(_:_:)(int a1, int a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  if (a1 == 0x80000000 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  return (a1 / a2);
}

int *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  int v2;
  int v3;

  v2 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  v3 = *result;
  if (v2 == -1 && v3 == 0x80000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  *result = v3 / v2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, int *a2@<X1>, int *a3@<X8>)
{
  int v3;

  v3 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  if (*result == 0x80000000 && v3 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  *a3 = *result % v3;
  return result;
}

uint64_t static Int32.% infix(_:_:)(int a1, int a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  if (a1 == 0x80000000 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  return (a1 % a2);
}

int *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  int v2;
  int v3;

  v2 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  v3 = *result;
  if (v2 == -1 && v3 == 0x80000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  *result = v3 % v2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int32@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result &= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result |= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int32.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_DWORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int32@<X0>(int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  int v54;
  int *v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  uint64_t (*v62)(char *, uint64_t);
  void (*v63)(char *, uint64_t, uint64_t);
  char *v64;
  char v65;
  void (*v66)(char *, char *, uint64_t);
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t, uint64_t);
  uint64_t v79;
  char *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v86;
  int64_t *v87;
  uint64_t v88;
  char v89;
  unint64_t v90;
  char v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  void (*v95)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v96;
  char v97;
  void (*v98)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v99;
  char v100;
  char *v101;
  uint64_t v102;
  void (**v103)(char *, uint64_t, const char *);
  unint64_t v104;
  unint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  int64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  unint64_t AssociatedTypeWitness;
  char *v115;
  char *v116;
  char *v117;
  int v118;
  char *v119;
  int *v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t (*v122)(uint64_t, uint64_t);
  uint64_t v123;
  int64_t v124;

  v120 = a5;
  v115 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v115, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v113 = (char *)&v111 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v111 = (char *)&v111 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v111 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v117 = (char *)&v111 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v112 = (char *)&v111 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v111 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v119 = (char *)&v111 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v111 - v28;
  v118 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v121 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v124 = -32;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v121;
        v32 = v122;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v115;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -32;
    }
    else
    {
      if (v39 > 64)
      {
        v30 = v121;
        v32 = v122;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -32;
    }
    v30 = v121;
    v32 = v122;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 >= -32)
      goto LABEL_20;
LABEL_19:
    v54 = 0;
    v55 = v120;
    goto LABEL_50;
  }
  v124 = -32;
  v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v44 & 1) != 0)
    goto LABEL_19;
LABEL_20:
  v122 = v32;
  v56 = v30(a3, a4);
  v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64)
      goto LABEL_22;
  }
  else if (v57 > 63)
  {
LABEL_22:
    v124 = 32;
    v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v60) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v62(v29, a3);
    if ((v60 & 1) == 0)
      goto LABEL_23;
LABEL_31:
    v54 = v118 >> 31;
    v55 = v120;
    goto LABEL_50;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v62(v29, a3);
  if (v77 > 32)
    goto LABEL_31;
LABEL_23:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v64 = v119;
  v63(v119, a2, a3);
  v65 = v121(a3, a4);
  v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    v76 = v25;
    v68 = v119;
    v69 = v117;
    goto LABEL_33;
  }
  v67 = v122(a3, a4);
  v62(v25, a3);
  v68 = v119;
  v69 = v117;
  if (v67 < 65)
    goto LABEL_34;
  v70 = v112;
  v66(v112, v119, a3);
  v124 = 0x8000000000000000;
  v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    v91 = v71(a3, a4);
    v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        v70 = v112;
        v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
        goto LABEL_55;
      }
      v104 = AssociatedTypeWitness;
      v103 = (void (**)(char *, uint64_t, const char *))v115;
      v105 = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))(&qword_1816B7DA8, 256, v104, v105);
      v103[3](v106, a3, (const char *)v103);
      v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
      v62(v29, a3);
      v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }
      v109 = v124;
      v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      v47 = v110 < v109;
      v68 = v119;
      v76 = v112;
      if (!v47)
        goto LABEL_33;
    }
    else
    {
      if (v92 > 64)
      {
        v76 = v112;
        goto LABEL_33;
      }
      v101 = v112;
      v66(v29, v112, a3);
      v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      v76 = v101;
      if (v102 >= v124)
        goto LABEL_33;
    }
LABEL_70:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    v76 = v70;
    if (v75 < v124)
      goto LABEL_70;
    goto LABEL_33;
  }
  v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v70, v29, a3);
LABEL_55:
  v100 = v97;
  v62(v29, a3);
  v76 = v70;
  if ((v100 & 1) != 0)
    goto LABEL_70;
LABEL_33:
  v62(v76, a3);
LABEL_34:
  v78 = v122;
  v79 = v122(a3, a4);
  v66(v69, v68, a3);
  if (v79 < 65)
  {
    v88 = v78(a3, a4);
    v62(v69, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0)
      goto LABEL_47;
  }
  else
  {
    v62(v69, a3);
  }
  v80 = v116;
  v66(v116, v68, a3);
  v124 = 0x7FFFFFFFFFFFFFFFLL;
  v81 = v121(a3, a4);
  v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      v87 = &v124;
      goto LABEL_45;
    }
  }
  else if (v82 > 63)
  {
    v123 = 0x7FFFFFFFFFFFFFFFLL;
    v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v80, a3);
    v62(v29, a3);
    if ((v89 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_46;
  }
  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v62(v68, a3);
  if ((v90 & 0x8000000000000000) != 0)
  {
    v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFE0)
      v54 = 0;
    else
      v54 = v118 << -(char)v90;
  }
  else
  {
    v55 = v120;
    if (v90 >= 0x20)
      v54 = v118 >> 31;
    else
      v54 = v118 >> v90;
  }
LABEL_50:
  *v55 = v54;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int32(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  int *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  void (*v71)(char *, uint64_t, uint64_t);
  char *v72;
  char v73;
  char *v74;
  char *v75;
  void (*v76)(char *, char *, uint64_t);
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t (*v80)(uint64_t, uint64_t);
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  int *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  int v130;
  char *v131;
  int *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(int **)(a4 + 128);
    v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      v144 = -32;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) == 0)
        goto LABEL_19;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 >= -32)
        goto LABEL_19;
    }
LABEL_18:
    v61 = 0;
    goto LABEL_59;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(int **)(a4 + 128);
  v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_19;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 >= -32)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (v42 <= 64)
  {
    v55 = v137;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
    v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      v61 = 0;
      v39 = v132;
      goto LABEL_59;
    }
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }
  v144 = -32;
  v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  v40 = v131;
  v39 = v132;
  if ((v48 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
  }
  else if (v63 >= 64)
  {
LABEL_21:
    v144 = 32;
    v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v68, a3);
    if ((v69 & 1) == 0)
      goto LABEL_22;
LABEL_30:
    v61 = *v39 >> 31;
    goto LABEL_59;
  }
  v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v88, a3);
  if (v89 > 32)
    goto LABEL_30;
LABEL_22:
  v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v72 = v140;
  v71(v140, a2, a3);
  v73 = v141(a3, a4);
  v74 = v139;
  v75 = v72;
  v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  v132 = v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    v78 = v140;
    goto LABEL_42;
  }
  v77 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v74, a3);
  v78 = v140;
  if (v77 <= 64)
    goto LABEL_42;
  v79 = v135;
  v76(v135, v140, a3);
  v144 = 0x8000000000000000;
  v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v81 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v81 >= 64)
    {
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v86, a3);
      v87 = v86;
      v79 = v135;
      v70(v87, a3);
      if ((v84 & 1) != 0)
        goto LABEL_65;
      goto LABEL_41;
    }
  }
  else
  {
    v90 = v80(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v79 = v107;
        v70(v108, a3);
        v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v78 = v140;
        if (v112)
          goto LABEL_65;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_65;
      }
      goto LABEL_41;
    }
    if (v91 >= 64)
      goto LABEL_41;
  }
  v100 = v142;
  v76(v142, v79, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }
  v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        v123 = &v144;
        goto LABEL_54;
      }
    }
    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
      v70(v127, a3);
      if ((v128 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v78, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFE0)
    {
      v61 = v130 << -(char)v129;
      goto LABEL_59;
    }
    goto LABEL_18;
  }
  if (v129 >= 0x20)
    v61 = v130 >> 31;
  else
    v61 = v130 >> v129;
LABEL_59:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int32@<X0>(int *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  int v54;
  int *v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  uint64_t (*v62)(char *, uint64_t);
  void (*v63)(char *, uint64_t, uint64_t);
  char *v64;
  char v65;
  void (*v66)(char *, char *, uint64_t);
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t, uint64_t);
  uint64_t v79;
  char *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v86;
  int64_t *v87;
  uint64_t v88;
  char v89;
  unint64_t v90;
  char v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  void (*v95)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v96;
  char v97;
  void (*v98)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v99;
  char v100;
  char *v101;
  uint64_t v102;
  void (**v103)(char *, uint64_t, const char *);
  unint64_t v104;
  unint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  int64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  unint64_t AssociatedTypeWitness;
  char *v115;
  char *v116;
  char *v117;
  char *v118;
  int v119;
  int *v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t (*v122)(uint64_t, uint64_t);
  uint64_t v123;
  int64_t v124;

  v120 = a5;
  v115 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v115, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v113 = (char *)&v111 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v111 = (char *)&v111 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v111 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v117 = (char *)&v111 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v112 = (char *)&v111 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v111 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v118 = (char *)&v111 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v111 - v28;
  v119 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v121 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v124 = -32;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v121;
        v32 = v122;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v115;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -32;
    }
    else
    {
      if (v39 > 64)
      {
        v30 = v121;
        v32 = v122;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -32;
    }
    v30 = v121;
    v32 = v122;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 > -33)
      goto LABEL_20;
LABEL_19:
    v54 = v119 >> 31;
    v55 = v120;
    goto LABEL_50;
  }
  v124 = -32;
  v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v44 & 1) != 0)
    goto LABEL_19;
LABEL_20:
  v122 = v32;
  v56 = v30(a3, a4);
  v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64)
      goto LABEL_22;
  }
  else if (v57 > 63)
  {
LABEL_22:
    v124 = 32;
    v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v60) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v62(v29, a3);
    if ((v60 & 1) == 0)
      goto LABEL_23;
LABEL_31:
    v54 = 0;
    v55 = v120;
    goto LABEL_50;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v62(v29, a3);
  if (v77 > 32)
    goto LABEL_31;
LABEL_23:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v64 = v118;
  v63(v118, a2, a3);
  v65 = v121(a3, a4);
  v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    v76 = v25;
    v68 = v117;
    v69 = v118;
    goto LABEL_33;
  }
  v67 = v122(a3, a4);
  v62(v25, a3);
  v68 = v117;
  v69 = v118;
  if (v67 < 65)
    goto LABEL_34;
  v70 = v112;
  v66(v112, v118, a3);
  v124 = 0x8000000000000000;
  v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    v91 = v71(a3, a4);
    v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        v70 = v112;
        v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
        goto LABEL_55;
      }
      v104 = AssociatedTypeWitness;
      v103 = (void (**)(char *, uint64_t, const char *))v115;
      v105 = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))(&qword_1816B7DA8, 256, v104, v105);
      v103[3](v106, a3, (const char *)v103);
      v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
      v62(v29, a3);
      v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_70;
      }
      v109 = v124;
      v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      v47 = v110 < v109;
      v69 = v118;
      v76 = v112;
      if (!v47)
        goto LABEL_33;
    }
    else
    {
      if (v92 > 64)
      {
        v76 = v112;
        goto LABEL_33;
      }
      v101 = v112;
      v66(v29, v112, a3);
      v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      v76 = v101;
      if (v102 >= v124)
        goto LABEL_33;
    }
LABEL_70:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    v76 = v70;
    if (v75 < v124)
      goto LABEL_70;
    goto LABEL_33;
  }
  v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v70, v29, a3);
LABEL_55:
  v100 = v97;
  v62(v29, a3);
  v76 = v70;
  if ((v100 & 1) != 0)
    goto LABEL_70;
LABEL_33:
  v62(v76, a3);
LABEL_34:
  v78 = v122;
  v79 = v122(a3, a4);
  v66(v68, v69, a3);
  if (v79 < 65)
  {
    v88 = v78(a3, a4);
    v62(v68, a3);
    if (v88 != 64 || (v121(a3, a4) & 1) != 0)
      goto LABEL_47;
  }
  else
  {
    v62(v68, a3);
  }
  v80 = v116;
  v66(v116, v69, a3);
  v124 = 0x7FFFFFFFFFFFFFFFLL;
  v81 = v121(a3, a4);
  v82 = v122(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      v87 = &v124;
      goto LABEL_45;
    }
  }
  else if (v82 > 63)
  {
    v123 = 0x7FFFFFFFFFFFFFFFLL;
    v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
    v87 = &v123;
LABEL_45:
    v85(v87, &type metadata for Int, v86, a3, a4);
    v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v80, a3);
    v62(v29, a3);
    if ((v89 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_46;
  }
  v66(v29, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62(v29, a3);
LABEL_46:
  v62(v80, a3);
LABEL_47:
  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v62(v69, a3);
  if ((v90 & 0x8000000000000000) != 0)
  {
    v55 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFE0)
      v54 = v119 >> 31;
    else
      v54 = v119 >> -(char)v90;
  }
  else
  {
    v55 = v120;
    if (v90 >= 0x20)
      v54 = 0;
    else
      v54 = v119 << v90;
  }
LABEL_50:
  *v55 = v54;
  return result;
}

