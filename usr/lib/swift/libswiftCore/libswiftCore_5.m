uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int32(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  int *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  int v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  int *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  int v130;
  char *v131;
  int *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    v131 = v19;
    v132 = a1;
    v41 = v29(a3, a4);
    v32 = *(int **)(a4 + 128);
    v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        v144 = -32;
        v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        v40 = v131;
        v39 = v132;
        if ((v48 & 1) != 0)
          goto LABEL_18;
        goto LABEL_19;
      }
      v55 = v137;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
      v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        v39 = v132;
        goto LABEL_18;
      }
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }
    else
    {
      if (v42 >= 64)
      {
        v40 = v131;
        v39 = v132;
        goto LABEL_19;
      }
      v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }
    v40 = v131;
    v39 = v132;
    if (v54 >= -32)
      goto LABEL_19;
    goto LABEL_18;
  }
  v31 = v19;
  v32 = *(int **)(a4 + 128);
  v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if (v33 < 64)
  {
    v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    v39 = a1;
    v40 = v31;
    if (v37 > -33)
      goto LABEL_19;
LABEL_18:
    v61 = *v39 >> 31;
    goto LABEL_60;
  }
  v144 = -32;
  v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  v39 = a1;
  v40 = v31;
  if ((v52 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
  }
  else if (v63 >= 64)
  {
LABEL_21:
    v144 = 32;
    v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v68, a3);
    if ((v69 & 1) != 0)
      goto LABEL_25;
    goto LABEL_26;
  }
  v71 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v71, a3);
  if (v72 > 32)
  {
LABEL_25:
    v61 = 0;
    goto LABEL_60;
  }
LABEL_26:
  v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v74 = v140;
  v73(v140, a2, a3);
  v75 = v141(a3, a4);
  v76 = v139;
  v77 = v74;
  v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  v132 = v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_43;
  }
  v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64)
    goto LABEL_43;
  v81 = v135;
  v78(v135, v140, a3);
  v144 = 0x8000000000000000;
  v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v88, a3);
      v89 = v88;
      v81 = v135;
      v70(v89, a3);
      if ((v86 & 1) != 0)
        goto LABEL_65;
      goto LABEL_42;
    }
  }
  else
  {
    v90 = v82(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v81 = v107;
        v70(v108, a3);
        v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v80 = v140;
        if (v112)
          goto LABEL_65;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_65;
      }
      goto LABEL_42;
    }
    if (v91 >= 64)
      goto LABEL_42;
  }
  v100 = v142;
  v78(v142, v81, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_42:
  v70(v81, a3);
LABEL_43:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 < 65)
  {
    v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
    v70(v115, a3);
    v125 = v124 == 64;
    v116 = v141;
    if (!v125 || (v141(a3, a4) & 1) != 0)
      goto LABEL_57;
  }
  else
  {
    v70(v115, a3);
    v116 = v141;
  }
  v78(v40, v80, a3);
  v144 = 0x7FFFFFFFFFFFFFFFLL;
  v117 = v116(a3, a4);
  v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  if ((v117 & 1) != 0)
  {
    if (v118 > 64)
    {
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v144;
      goto LABEL_55;
    }
  }
  else if (v118 >= 64)
  {
    v143 = 0x7FFFFFFFFFFFFFFFLL;
    v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
    v123 = &v143;
LABEL_55:
    v127 = v142;
    v121(v123, &type metadata for Int, v122, a3, a4);
    v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
    v70(v127, a3);
    if ((v128 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_56;
  }
  v126 = v142;
  v78(v142, v40, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v126, a3);
LABEL_56:
  v70(v40, a3);
LABEL_57:
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) == 0)
  {
    if (v129 < 0x20)
    {
      v61 = v130 << v129;
      goto LABEL_60;
    }
    goto LABEL_25;
  }
  if (v129 <= 0xFFFFFFFFFFFFFFE0)
    v61 = v130 >> 31;
  else
    v61 = v130 >> -(char)v129;
LABEL_60:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int32(_DWORD *a1, int *a2, int *a3)
{
  int *v3;
  uint64_t result;

  result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int32(int *a1)
{
  int *v1;

  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int32(int *a1@<X8>)
{
  int *v1;

  *a1 = (*v1 > 0) | (*v1 >> 31);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int32(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7;
  uint64_t v10;
  unint64_t v11;
  int v12;

  v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  if (v7)
  {
    v10 = a3();
    if ((v10 & 0x10000000000) != 0)
      v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    swift_bridgeObjectRelease(a2);
    v11 = (v10 & 0x100000000uLL) >> 32;
    if ((v10 & 0x100000000) != 0)
      v12 = 0;
    else
      v12 = v10;
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    v12 = 0;
    LOBYTE(v11) = 1;
  }
  *(_DWORD *)a5 = v12;
  *(_BYTE *)(a5 + 4) = v11 & 1;
}

_DWORD *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  if (__OFSUB__(0, *result))
    __break(1u);
  else
    *a2 = -*result;
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int32()
{
  _DWORD *v0;

  if (__OFSUB__(0, *v0))
    __break(1u);
  else
    *v0 = -*v0;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char v29;
  void (*v30)(char *, uint64_t, uint64_t);
  _BOOL4 v31;
  void (*v32)(char *, uint64_t);
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  signed int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  char v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(int *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v51;
  char *v52;
  char v53;
  char *v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  int v64;
  uint64_t result;
  char v66;
  void (*v67)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t);
  unint64_t v68;
  char *v69;
  char *v70;
  signed int v71;
  BOOL v72;
  char *v73;
  uint64_t v74;
  void (*v75)(int *, uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  void (**v80)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v82;
  char *v83;
  signed int v84;
  signed int v85;
  uint64_t v86;
  uint64_t (*v87)(uint64_t, uint64_t);
  char *v88;
  char *v89;
  char *v90;
  uint64_t v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  uint64_t (*v96)(uint64_t, uint64_t);
  uint64_t v97;
  signed int v98;
  int v99;
  int v100;

  v91 = a4;
  v95 = a5;
  v88 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v88, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v86 - v10;
  v12 = *(_QWORD *)(a2 - 8);
  v13 = MEMORY[0x1E0C80A78](v9);
  v89 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v86 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v94 = (char *)&v86 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v93 = (char *)&v86 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v92 = (char *)&v86 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v86 - v25;
  MEMORY[0x1E0C80A78](v24);
  v28 = (char *)&v86 - v27;
  v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v29 = v96(a2, a3);
  v97 = v12;
  v30 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v30(v28, a1, a2);
  v90 = v17;
  v31 = (v29 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 32;
  v32 = *(void (**)(char *, uint64_t))(v97 + 8);
  v32(v28, a2);
  v30(v26, a1, a2);
  if (!v31)
  {
    v32(v26, a2);
    v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v38 = v94;
    v40 = v95;
    goto LABEL_10;
  }
  v98 = 0x80000000;
  v33 = v96;
  if ((v96(a2, a3) & 1) != 0)
  {
    v34 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v35 = v34(a2, a3);
    v38 = v94;
    if (v35 >= 32)
    {
      v67 = *(void (**)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v68 = lazy protocol witness table accessor for type Int32 and conformance Int32(v35, v36, v37);
      v87 = v34;
      v69 = v92;
      v67(&v98, v91, v68, a2, a3);
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v69, a2);
      v70 = v69;
      v34 = v87;
      v32(v70, a2);
      v32(v26, a2);
      v40 = v95;
      if ((v67 & 1) != 0)
        goto LABEL_40;
    }
    else
    {
      v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v32(v26, a2);
      v40 = v95;
      if (v98 > v39)
        goto LABEL_40;
    }
    goto LABEL_10;
  }
  v55 = v33(a2, a3);
  v87 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v56 = v87(a2, a3);
  if ((v55 & 1) != 0)
  {
    if (v56 > 32)
    {
      v59 = *(void (**)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v60 = lazy protocol witness table accessor for type Int32 and conformance Int32(v56, v57, v58);
      v61 = v92;
      v59(&v98, v91, v60, a2, a3);
      LOBYTE(v59) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v61, a2);
      v32(v61, a2);
      v32(v26, a2);
      v38 = v94;
      v40 = v95;
      v34 = v87;
      if ((v59 & 1) != 0)
        goto LABEL_40;
      goto LABEL_10;
    }
    v80 = (void (**)(char *, uint64_t, const char *))v88;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v88, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v82 = v92;
    v80[3](v11, a2, (const char *)v80);
    LOBYTE(v80) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v26, v82, a2);
    v32(v82, a2);
    v83 = v89;
    (*(void (**)(char *, char *, uint64_t))(v97 + 32))(v89, v26, a2);
    v40 = v95;
    if ((v80 & 1) != 0)
    {
      v32(v83, a2);
LABEL_40:
      result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
      v64 = 0;
      v66 = 1;
      goto LABEL_41;
    }
    v84 = v98;
    v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v83, a2);
    v72 = v84 <= v85;
    v38 = v94;
    goto LABEL_39;
  }
  v38 = v94;
  if (v56 < 32)
  {
    v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v32(v26, a2);
    v72 = v98 <= v71;
    v40 = v95;
LABEL_39:
    v34 = v87;
    if (!v72)
      goto LABEL_40;
LABEL_10:
    v41 = v34(a2, a3);
    goto LABEL_11;
  }
  v32(v26, a2);
  v40 = v95;
  v34 = v87;
  v41 = v87(a2, a3);
LABEL_11:
  v42 = v41;
  v43 = v93;
  v30(v93, a1, a2);
  if (v42 >= 33)
  {
    v32(v43, a2);
    v30(v38, a1, a2);
    goto LABEL_15;
  }
  v44 = v34(a2, a3);
  v32(v43, a2);
  if (v44 != 32)
  {
    v30(v38, a1, a2);
    goto LABEL_25;
  }
  v45 = v96(a2, a3);
  v30(v38, a1, a2);
  if ((v45 & 1) != 0)
  {
LABEL_25:
    v63 = v38;
    goto LABEL_26;
  }
LABEL_15:
  v100 = 0x7FFFFFFF;
  v46 = v96(a2, a3);
  v47 = v34(a2, a3);
  if ((v46 & 1) != 0)
  {
    if (v47 > 32)
    {
      v50 = *(void (**)(int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      v51 = lazy protocol witness table accessor for type Int32 and conformance Int32(v47, v48, v49);
      v52 = v92;
      v50(&v100, v91, v51, a2, a3);
      v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v52, v38, a2);
      v32(v52, a2);
      v54 = v38;
      goto LABEL_34;
    }
    goto LABEL_23;
  }
  if (v47 <= 31)
  {
LABEL_23:
    v62 = v92;
    (*(void (**)(char *, char *, uint64_t))(v97 + 32))(v92, v38, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v63 = v62;
LABEL_26:
    v32(v63, a2);
    goto LABEL_27;
  }
  v99 = 0x7FFFFFFF;
  v73 = v92;
  v74 = (*(uint64_t (**)(char *, char *, uint64_t))(v97 + 32))(v92, v38, a2);
  v75 = *(void (**)(int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  v78 = lazy protocol witness table accessor for type Int32 and conformance Int32(v74, v76, v77);
  v79 = v90;
  v75(&v99, v91, v78, a2, a3);
  v53 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v79, v73, a2);
  v32(v79, a2);
  v54 = v73;
LABEL_34:
  v32(v54, a2);
  if ((v53 & 1) != 0)
    goto LABEL_40;
LABEL_27:
  v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = ((uint64_t (*)(uint64_t, uint64_t))v32)(a1, a2);
  v66 = 0;
LABEL_41:
  *(_DWORD *)v40 = v64;
  *(_BYTE *)(v40 + 4) = v66;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int32(int *a1@<X8>)
{
  int *v1;
  int v2;

  v2 = *v1;
  if (*v1 < 0)
    v2 = -v2;
  *a1 = v2;
}

int *protocol witness for static Numeric.* infix(_:_:) in conformance Int32@<X0>(int *result@<X0>, int *a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t v3;

  v3 = *result * (uint64_t)*a2;
  if (v3 == (int)v3)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

uint64_t static Int32.* infix(_:_:)(int a1, int a2)
{
  uint64_t result;

  result = a1 * (uint64_t)a2;
  if (result != (int)result)
    __break(1u);
  return result;
}

int *protocol witness for static Numeric.*= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  uint64_t v2;

  v2 = *result * (uint64_t)*a2;
  if (v2 == (int)v2)
    *result = v2;
  else
    __break(1u);
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int32()
{
  int *v0;

  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
}

int *protocol witness for Strideable.distance(to:) in conformance Int32@<X0>(int *result@<X0>, uint64_t *a2@<X8>)
{
  int *v2;
  int v3;
  int v4;
  BOOL v5;
  int v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *result;
  v4 = *v2;
  if (((*v2 ^ *result) & 0x80000000) == 0)
  {
    v5 = __OFSUB__(v3, v4);
    v6 = v3 - v4;
    if (!v5)
    {
      *a2 = v6;
      return result;
    }
    __break(1u);
    goto LABEL_15;
  }
  if (v4 >= 0)
    v7 = *v2;
  else
    v7 = -v4;
  if (v3 < 0)
    v3 = -v3;
  v8 = __CFADD__(v7, v3);
  v9 = (v7 + v3);
  if (v8)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v4 < 0)
    v10 = v9;
  else
    v10 = -v9;
  *a2 = v10;
  return result;
}

_QWORD *protocol witness for Strideable.advanced(by:) in conformance Int32@<X0>(_QWORD *result@<X0>, _DWORD *a2@<X8>)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;

  v3 = *v2;
  v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  if (v4 <= (uint64_t)0xFFFFFFFF7FFFFFFFLL)
    goto LABEL_6;
  if (v4 >= 0x80000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int32(uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, _QWORD *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

_DWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFADD__(*result, *a2))
    __break(1u);
  else
    *a3 = *result + *a2;
  return result;
}

uint64_t static Int32.+ infix(_:_:)(int a1, int a2)
{
  BOOL v2;
  uint64_t result;

  v2 = __OFADD__(a1, a2);
  result = (a1 + a2);
  if (v2)
    __break(1u);
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  if (__OFADD__(*result, *a2))
    __break(1u);
  else
    *result += *a2;
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2))
    __break(1u);
  else
    *a3 = *result - *a2;
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  if (__OFSUB__(*result, *a2))
    __break(1u);
  else
    *result -= *a2;
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL static Int32.<= infix(_:_:)(int a1, int a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL static Int32.>= infix(_:_:)(int a1, int a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a2 < *a1;
}

void Int32.hash(into:)(int a1, Swift::UInt32 a2)
{
  Hasher._combine(_:)(a2);
}

Swift::Int __swiftcall Int32._rawHashValue(seed:)(Swift::Int seed)
{
  unsigned int v1;

  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 4);
}

uint64_t Int32.hashValue.getter(unsigned int a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 4);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int32(uint64_t a1)
{
  unsigned int *v1;

  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 4);
}

uint64_t Int32._toCustomAnyHashable()@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int32>);
  *(_QWORD *)(a2 + 24) = result;
  *(_QWORD *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int32@<X0>(uint64_t a1@<X8>)
{
  int *v1;
  int v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int32>);
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a1 = v3;
  return result;
}

uint64_t UInt64._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt64._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t UInt64.init(_:)(float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt64 because it is either infinite or NaN", 80, 2, "Swift/IntegerTypes.swift", 24, 2, 0x245EuLL, 0);
  __asm { FCVT            S0, H0 }
  if (_S0 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt64 because the result would be less than UInt64.min", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2461uLL, 0);
  return (unint64_t)_S0;
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt64 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24ACuLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt64 because the result would be less than UInt64.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24AFuLL, 0);
  if (a1 >= 1.8447e19)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt64 because the result would be greater than UInt64.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24B2uLL, 0);
  return (unint64_t)a1;
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt64 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24F4uLL, 0);
  if (a1 <= -1.0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt64 because the result would be less than UInt64.min", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24F7uLL, 0);
  if (a1 >= 1.84467441e19)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt64 because the result would be greater than UInt64.max", 94, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24FAuLL, 0);
  return (unint64_t)a1;
}

_QWORD *static UInt64./= infix(_:_:)(_QWORD *result, unint64_t a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.addingReportingOverflow(_:)(Swift::UInt64 a1)
{
  uint64_t v1;
  BOOL v2;
  Swift::UInt64 v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_UInt64_overflow_Bool result;

  v2 = __CFADD__(v1, a1);
  v3 = v1 + a1;
  v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.subtractingReportingOverflow(_:)(Swift::UInt64 a1)
{
  Swift::UInt64 v1;
  BOOL v2;
  Swift::UInt64 v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_UInt64_overflow_Bool result;

  v2 = v1 >= a1;
  v3 = v1 - a1;
  v4 = !v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.multipliedReportingOverflow(by:)(Swift::UInt64 by)
{
  unint64_t v1;
  Swift::UInt64 v2;
  Swift::Bool v3;
  Swift::UInt64 v4;
  Swift::tuple_partialValue_UInt64_overflow_Bool result;

  v2 = v1 * by;
  v3 = !is_mul_ok(v1, by);
  v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

_QWORD *static UInt64.%= infix(_:_:)(_QWORD *result, unint64_t a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  *result %= a2;
  return result;
}

uint64_t UInt64.Words._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt64.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.Words.count.getter()
{
  return 1;
}

uint64_t UInt64.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt64.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt64.Words.indices.getter()
{
  return 0;
}

uint64_t UInt64.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x27B9uLL, 0x27BAuLL);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt64.Words@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance [A](a1, a2, a3, (uint64_t (*)(_QWORD, uint64_t, _QWORD))specialized RandomAccessCollection.index(_:offsetBy:limitedBy:), a4);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt64.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t *v2;
  uint64_t v4;

  v4 = *v2;
  UInt64.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

Swift::tuple_quotient_UInt64_remainder_UInt64 __swiftcall UInt64.dividingFullWidth(_:)(Swift::tuple_high_UInt64_low_UInt64 a1)
{
  unint64_t v1;
  Swift::UInt64 v2;
  Swift::UInt64 v3;
  Swift::tuple_quotient_UInt64_remainder_UInt64 result;

  v2 = UInt64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x282DuLL, 0x282FuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt64()
{
  return 64;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt64(_QWORD *a1@<X8>)
{
  *a1 = -1;
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt64(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 *a3)
{
  Swift::UInt64 result;
  Swift::tuple_quotient_UInt64_remainder_UInt64 v6;

  v6 = UInt64.dividingFullWidth(_:)(*a3);
  result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64 and conformance UInt64, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt64@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt64 and conformance UInt64((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

_QWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt64@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  *a3 = *result / *a2;
  return result;
}

unint64_t static UInt64./ infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  return a1 / a2;
}

_QWORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt64(_QWORD *result, _QWORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  *result /= *a2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt64@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  *a3 = *result % *a2;
  return result;
}

unint64_t static UInt64.% infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  return a1 % a2;
}

_QWORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt64(_QWORD *result, _QWORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  *result %= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt64@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t AssociatedConformanceWitness;
  char *v53;
  void (*v54)(char *, uint64_t);
  unint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t (*v63)(char *, uint64_t);
  uint64_t v64;
  void (*v65)(char *, uint64_t, uint64_t);
  char *v66;
  char v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char v86;
  void (*v87)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v88;
  char v89;
  void (**v90)(char *, uint64_t, const char *);
  unint64_t v91;
  unint64_t v92;
  char *v93;
  char *v94;
  char *v95;
  int64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  char *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  int64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t (*v115)(char *, uint64_t);
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  unint64_t v122;
  char *v123;
  char *v124;
  uint64_t (*v125)(uint64_t, uint64_t);
  unint64_t *v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v126 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v114 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v123 = (char *)&v114 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v117 = (char *)&v114 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v114 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v124 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v122 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v121 = v19;
  v127 = v31;
  if ((v32 & 1) == 0)
  {
    v39 = v31(a3, a4);
    v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v40 = v125(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v40 > 64)
      {
        v129 = -64;
        v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
        v43(&v129, &type metadata for Int, v44, a3, a4);
        v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
        v33 = v125;
        if ((v45 & 1) != 0)
          goto LABEL_24;
        goto LABEL_18;
      }
      v50 = AssociatedTypeWitness;
      v51 = v120;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v53 = v118;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v50, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
      LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      v54 = *(void (**)(char *, uint64_t))(v11 + 8);
      v54(v30, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v50 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
        v55 = 0;
        goto LABEL_64;
      }
      v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
    }
    else
    {
      if (v40 >= 64)
      {
        v33 = v125;
        goto LABEL_18;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    }
    v33 = v125;
    if (v49 < -64)
      goto LABEL_24;
    goto LABEL_18;
  }
  v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v34 = v33(a3, a4);
  if (v34 >= 64)
  {
    v129 = -64;
    v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v46(&v129, &type metadata for Int, v47, a3, a4);
    v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    if ((v48 & 1) != 0)
      goto LABEL_24;
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    if (v37 < -64)
      goto LABEL_24;
  }
LABEL_18:
  v56 = v127(a3, a4);
  v57 = v33(a3, a4);
  v125 = v33;
  if ((v56 & 1) != 0)
  {
    if (v57 > 64)
      goto LABEL_20;
    goto LABEL_23;
  }
  if (v57 <= 63)
  {
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v63(v30, a3);
    if (v64 <= 64)
      goto LABEL_25;
LABEL_24:
    v55 = 0;
    goto LABEL_64;
  }
LABEL_20:
  v129 = 64;
  v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
  v60(&v129, &type metadata for Int, v61, a3, a4);
  v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
  v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v63(v30, a3);
  if ((v62 & 1) != 0)
    goto LABEL_24;
LABEL_25:
  v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v66 = v124;
  v65(v124, a2, a3);
  v67 = v127(a3, a4);
  v65(v26, (uint64_t)v66, a3);
  if ((v67 & 1) == 0)
  {
    v63(v26, a3);
    v71 = v123;
    v70 = v124;
    v68 = v125;
    v79 = v125(a3, a4);
    goto LABEL_47;
  }
  v68 = v125;
  v69 = v125(a3, a4);
  v63(v26, a3);
  v71 = v123;
  v70 = v124;
  if (v69 > 64)
  {
    v115 = v63;
    v72 = v117;
    v65(v117, (uint64_t)v124, a3);
    v129 = 0x8000000000000000;
    v73 = v127;
    if ((v127(a3, a4) & 1) != 0)
    {
      v74 = v68(a3, a4);
      if (v74 < 64)
      {
        v65(v30, (uint64_t)v72, a3);
        v77 = v72;
        v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v63 = v115;
        v115(v30, a3);
LABEL_40:
        if (v78 < v129)
LABEL_69:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_44;
      }
      v77 = v72;
      v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      v87(&v129, &type metadata for Int, v88, a3, a4);
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v77, v30, a3);
    }
    else
    {
      v80 = v73(a3, a4);
      v81 = v68(a3, a4);
      if ((v80 & 1) == 0)
      {
        v63 = v115;
        if (v81 >= 64)
        {
          v113 = v117;
LABEL_45:
          v63(v113, a3);
          goto LABEL_46;
        }
        v77 = v117;
        v65(v30, (uint64_t)v117, a3);
        v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v63(v30, a3);
        goto LABEL_40;
      }
      if (v81 <= 64)
      {
        v91 = AssociatedTypeWitness;
        v90 = (void (**)(char *, uint64_t, const char *))v120;
        v92 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v93 = v118;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v92 + 8))(&qword_1816B7DA8, 256, v91, v92);
        v90[3](v93, a3, (const char *)v90);
        v94 = v117;
        LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
        v115(v30, a3);
        v95 = v116;
        v65(v116, (uint64_t)v94, a3);
        if ((v90 & 1) != 0)
        {
          v115(v95, a3);
          goto LABEL_69;
        }
        v96 = v129;
        v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v63 = v115;
        v115(v95, a3);
        v98 = v97 < v96;
        v70 = v124;
        v77 = v117;
        if (v98)
          goto LABEL_69;
LABEL_44:
        v113 = v77;
        goto LABEL_45;
      }
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v84(&v129, &type metadata for Int, v85, a3, a4);
      v77 = v117;
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
    }
    v89 = v86;
    v63 = v115;
    v115(v30, a3);
    if ((v89 & 1) != 0)
      goto LABEL_69;
    goto LABEL_44;
  }
LABEL_46:
  v79 = v68(a3, a4);
LABEL_47:
  v99 = v79;
  v65(v71, (uint64_t)v70, a3);
  if (v99 >= 65)
  {
    v63(v71, a3);
    v100 = v127;
    goto LABEL_49;
  }
  v109 = v68(a3, a4);
  v63(v71, a3);
  v110 = v109 == 64;
  v100 = v127;
  if (v110 && (v127(a3, a4) & 1) == 0)
  {
LABEL_49:
    v101 = v121;
    v65(v121, (uint64_t)v70, a3);
    v129 = 0x7FFFFFFFFFFFFFFFLL;
    v102 = v100(a3, a4);
    v103 = v68(a3, a4);
    if ((v102 & 1) != 0)
    {
      if (v103 > 64)
      {
        v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
        v108 = &v129;
        goto LABEL_59;
      }
    }
    else if (v103 > 63)
    {
      v128 = 0x7FFFFFFFFFFFFFFFLL;
      v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
      v108 = &v128;
LABEL_59:
      v106(v108, &type metadata for Int, v107, a3, a4);
      v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v101, a3);
      v63(v30, a3);
      if ((v111 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_60;
    }
    v65(v30, (uint64_t)v101, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v63(v30, a3);
LABEL_60:
    v63(v101, a3);
  }
  v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v63(v70, a3);
  if ((v112 & 0x8000000000000000) != 0)
  {
    if (v112 > 0xFFFFFFFFFFFFFFC0)
    {
      v55 = v122 >> -(char)v112;
      goto LABEL_64;
    }
    goto LABEL_24;
  }
  v55 = v122 << v112;
  if (v112 >= 0x40)
    v55 = 0;
LABEL_64:
  *v126 = v55;
  return result;
}

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(a1, a2, a3, a4, a5, 0x25E8uLL);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64 and conformance UInt64, a5);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt64()
{
  Swift::UInt64 *v0;

  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

uint64_t *protocol witness for Strideable.distance(to:) in conformance UInt64@<X0>(uint64_t *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *result;
  v4 = *v2;
  v5 = *result - *v2;
  if (*result >= (unint64_t)*v2)
  {
    if (*result - *v2 >= 0)
      goto LABEL_5;
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
  }
  if (v4 - v3 < 0)
    goto LABEL_6;
  v5 = v3 - v4;
LABEL_5:
  *a2 = v5;
  return result;
}

uint64_t UInt64.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0, a1);
}

void protocol witness for Hashable.hash(into:) in conformance UInt64()
{
  Swift::UInt64 *v0;

  Hasher._combine(_:)(*v0);
}

uint64_t UInt64._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt64@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t Int64._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int64._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.init(_:)(float a1)
{
  return Int.init(_:)("Float16 value cannot be converted to Int64 because it is either infinite or NaN", 79, 0x2A60uLL, a1);
}

uint64_t Int.init(_:)(const char *a1, uint64_t a2, unint64_t a3, float _S0)
{
  if ((~LODWORD(_S0) & 0x7C00) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a1, a2, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  __asm { FCVT            S0, H0 }
  return (uint64_t)_S0;
}

Swift::Int64 __swiftcall Int64.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int64 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AABuLL, 0);
  if (a1 <= -9.2234e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int64 because the result would be less than Int64.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AAEuLL, 0);
  if (a1 >= 9.2234e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int64 because the result would be greater than Int64.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AB1uLL, 0);
  return (uint64_t)a1;
}

Swift::Int64 __swiftcall Int64.init(_:)(Swift::Double a1)
{
  if ((~*(_QWORD *)&a1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int64 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AF3uLL, 0);
  if (a1 <= -9.22337204e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int64 because the result would be less than Int64.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AF6uLL, 0);
  if (a1 >= 9.22337204e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int64 because the result would be greater than Int64.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AF9uLL, 0);
  return (uint64_t)a1;
}

BOOL static Int64.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

uint64_t *static Int64./= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64./= infix(_:_:)(a1, a2, 0x2BE7uLL, 0x2BEEuLL);
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.addingReportingOverflow(_:)(Swift::Int64 a1)
{
  uint64_t v1;
  BOOL v2;
  Swift::Int64 v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_Int64_overflow_Bool result;

  v2 = __OFADD__(v1, a1);
  v3 = v1 + a1;
  v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.subtractingReportingOverflow(_:)(Swift::Int64 a1)
{
  uint64_t v1;
  BOOL v2;
  Swift::Int64 v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_Int64_overflow_Bool result;

  v2 = __OFSUB__(v1, a1);
  v3 = v1 - a1;
  v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.multipliedReportingOverflow(by:)(Swift::Int64 by)
{
  uint64_t v1;
  Swift::Int64 v2;
  Swift::Bool v3;
  Swift::Int64 v4;
  Swift::tuple_partialValue_Int64_overflow_Bool result;

  v2 = v1 * by;
  v3 = (unsigned __int128)(v1 * (__int128)by) >> 64 != (v1 * by) >> 63;
  v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

uint64_t *static Int64.%= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64.%= infix(_:_:)(a1, a2, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int64.& infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 & a1;
}

uint64_t static Int64.bitWidth.getter()
{
  return 64;
}

uint64_t Int64.Words._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int64.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.Words.count.getter()
{
  return 1;
}

uint64_t Int64.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int64.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int64.Words.indices.getter()
{
  return 0;
}

uint64_t Int64.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x2DCEuLL, 0x2DCFuLL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int64.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t *v2;
  uint64_t v4;

  v4 = *v2;
  Int64.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.magnitude.getter(uint64_t result)
{
  if (result < 0)
    return -result;
  return result;
}

Swift::tuple_quotient_Int64_remainder_Int64 __swiftcall Int64.dividingFullWidth(_:)(Swift::tuple_high_Int64_low_UInt64 a1)
{
  uint64_t v1;
  Swift::Int64 v2;
  Swift::Int64 v3;
  Swift::tuple_quotient_Int64_remainder_Int64 result;

  v2 = Int64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x2E5BuLL, 0x2E6CuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

BOOL static Int64.> infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int64(_QWORD *a1@<X8>)
{
  *a1 = 0x7FFFFFFFFFFFFFFFLL;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int64(_QWORD *a1@<X8>)
{
  *a1 = 0x8000000000000000;
}

Swift::Int64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int64(Swift::Int64 *a1, Swift::Int64 *a2, Swift::tuple_high_Int64_low_UInt64 *a3)
{
  Swift::Int64 result;
  Swift::tuple_quotient_Int64_remainder_Int64 v6;

  v6 = Int64.dividingFullWidth(_:)(*a3);
  result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int64 and conformance Int64(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int64@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64 and conformance Int64, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int64@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int64 and conformance Int64((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

_QWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int64@<X0>(_QWORD *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3;

  v3 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2BE7uLL, 0);
  if (*result == 0x8000000000000000 && v3 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2BEEuLL, 0);
  *a3 = *result / v3;
  return result;
}

uint64_t static Int64./ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int./ infix(_:_:)(a1, a2, 0x2BE7uLL, 0x2BEEuLL);
}

uint64_t static Int./ infix(_:_:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  if (a1 == 0x8000000000000000 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  return a1 / a2;
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x2BE7uLL, 0x2BEEuLL);
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64(a1, a2, 0x2CCCuLL, 0x2CD1uLL, a3);
}

uint64_t static Int64.% infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int.% infix(_:_:)(a1, a2, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int.% infix(_:_:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  if (a1 == 0x8000000000000000 && a2 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  return a1 % a2;
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int64.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int64@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t v52;
  char *v53;
  void (*v54)(char *, uint64_t);
  uint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t (*v63)(char *, uint64_t);
  uint64_t v64;
  void (*v65)(char *, uint64_t, uint64_t);
  char *v66;
  char v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char v86;
  void (*v87)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v88;
  char v89;
  void (**v90)(char *, uint64_t, const char *);
  unint64_t v91;
  unint64_t AssociatedConformanceWitness;
  char *v93;
  char *v94;
  char *v95;
  int64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  char *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  int64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t (*v115)(char *, uint64_t);
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  char *v122;
  uint64_t v123;
  char *v124;
  uint64_t (*v125)(uint64_t, uint64_t);
  uint64_t *v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v126 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v114 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v122 = (char *)&v114 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v117 = (char *)&v114 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v114 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v124 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v123 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v121 = v19;
  v127 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v129 = -64;
      v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) == 0)
        goto LABEL_19;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 >= -64)
        goto LABEL_19;
    }
    goto LABEL_18;
  }
  v39 = v31(a3, a4);
  v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v40 = v125(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 >= 64)
    {
      v33 = v125;
      goto LABEL_19;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
LABEL_17:
    v33 = v125;
    if (v49 >= -64)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (v40 > 64)
  {
    v129 = -64;
    v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v129, &type metadata for Int, v44, a3, a4);
    v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    v33 = v125;
    if ((v45 & 1) == 0)
    {
LABEL_19:
      v56 = v127(a3, a4);
      v57 = v33(a3, a4);
      v125 = v33;
      if ((v56 & 1) != 0)
      {
        if (v57 > 64)
          goto LABEL_21;
      }
      else if (v57 > 63)
      {
LABEL_21:
        v129 = 64;
        v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
        v60(&v129, &type metadata for Int, v61, a3, a4);
        v62 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
        v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
        result = v63(v30, a3);
        if ((v62 & 1) == 0)
        {
LABEL_26:
          v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
          v66 = v124;
          v65(v124, a2, a3);
          v67 = v127(a3, a4);
          v65(v26, (uint64_t)v66, a3);
          if ((v67 & 1) == 0)
          {
            v63(v26, a3);
            v70 = v124;
            v68 = v125;
            v71 = v122;
            v79 = v125(a3, a4);
            goto LABEL_48;
          }
          v68 = v125;
          v69 = v125(a3, a4);
          v63(v26, a3);
          v70 = v124;
          v71 = v122;
          if (v69 <= 64)
          {
LABEL_47:
            v79 = v68(a3, a4);
LABEL_48:
            v99 = v79;
            v65(v71, (uint64_t)v70, a3);
            if (v99 < 65)
            {
              v109 = v68(a3, a4);
              v63(v71, a3);
              v110 = v109 == 64;
              v100 = v127;
              if (!v110 || (v127(a3, a4) & 1) != 0)
                goto LABEL_62;
            }
            else
            {
              v63(v71, a3);
              v100 = v127;
            }
            v101 = v121;
            v65(v121, (uint64_t)v70, a3);
            v129 = 0x7FFFFFFFFFFFFFFFLL;
            v102 = v100(a3, a4);
            v103 = v68(a3, a4);
            if ((v102 & 1) != 0)
            {
              if (v103 > 64)
              {
                v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
                v108 = &v129;
                goto LABEL_60;
              }
            }
            else if (v103 > 63)
            {
              v128 = 0x7FFFFFFFFFFFFFFFLL;
              v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              v108 = &v128;
LABEL_60:
              v106(v108, &type metadata for Int, v107, a3, a4);
              v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v101, a3);
              v63(v30, a3);
              if ((v111 & 1) != 0)
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
              goto LABEL_61;
            }
            v65(v30, (uint64_t)v101, a3);
            (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v63(v30, a3);
LABEL_61:
            v63(v101, a3);
LABEL_62:
            v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            result = v63(v70, a3);
            if ((v112 & 0x8000000000000000) == 0)
            {
              if (v112 < 0x40)
              {
                v55 = v123 >> v112;
                goto LABEL_65;
              }
              goto LABEL_25;
            }
            if (v112 > 0xFFFFFFFFFFFFFFC0)
            {
              v55 = v123 << -(char)v112;
              goto LABEL_65;
            }
            goto LABEL_18;
          }
          v115 = v63;
          v72 = v117;
          v65(v117, (uint64_t)v124, a3);
          v129 = 0x8000000000000000;
          v73 = v127;
          if ((v127(a3, a4) & 1) != 0)
          {
            v74 = v68(a3, a4);
            if (v74 < 64)
            {
              v65(v30, (uint64_t)v72, a3);
              v77 = v72;
              v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v63 = v115;
              v115(v30, a3);
LABEL_41:
              if (v78 < v129)
LABEL_70:
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
              goto LABEL_45;
            }
            v77 = v72;
            v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
            v87(&v129, &type metadata for Int, v88, a3, a4);
            v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v77, v30, a3);
          }
          else
          {
            v80 = v73(a3, a4);
            v81 = v68(a3, a4);
            if ((v80 & 1) == 0)
            {
              v63 = v115;
              if (v81 >= 64)
              {
                v113 = v117;
LABEL_46:
                v63(v113, a3);
                goto LABEL_47;
              }
              v77 = v117;
              v65(v30, (uint64_t)v117, a3);
              v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v63(v30, a3);
              goto LABEL_41;
            }
            if (v81 <= 64)
            {
              v91 = AssociatedTypeWitness;
              v90 = (void (**)(char *, uint64_t, const char *))v120;
              AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v93 = v118;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 8))(&qword_1816B7DA8, 256, v91, AssociatedConformanceWitness);
              v90[3](v93, a3, (const char *)v90);
              v94 = v117;
              LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                               + 16))(v117, v30, a3);
              v115(v30, a3);
              v95 = v116;
              v65(v116, (uint64_t)v94, a3);
              if ((v90 & 1) != 0)
              {
                v115(v95, a3);
                goto LABEL_70;
              }
              v96 = v129;
              v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v63 = v115;
              v115(v95, a3);
              v98 = v97 < v96;
              v70 = v124;
              v77 = v117;
              if (v98)
                goto LABEL_70;
LABEL_45:
              v113 = v77;
              goto LABEL_46;
            }
            v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
            v84(&v129, &type metadata for Int, v85, a3, a4);
            v77 = v117;
            v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
          }
          v89 = v86;
          v63 = v115;
          v115(v30, a3);
          if ((v89 & 1) != 0)
            goto LABEL_70;
          goto LABEL_45;
        }
LABEL_25:
        v55 = v123 >> 63;
        goto LABEL_65;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v63 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
      result = v63(v30, a3);
      if (v64 <= 64)
        goto LABEL_26;
      goto LABEL_25;
    }
LABEL_18:
    v55 = 0;
    goto LABEL_65;
  }
  v50 = AssociatedTypeWitness;
  v51 = v120;
  v52 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v53 = v118;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v52 + 8))(&qword_1816B7DA8, 256, v50, v52);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
  v54 = *(void (**)(char *, uint64_t))(v11 + 8);
  v54(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
  if ((v50 & 1) == 0)
  {
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
    goto LABEL_17;
  }
  result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
  v55 = 0;
LABEL_65:
  *v126 = v55;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int64(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  uint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  void (*v71)(char *, uint64_t, uint64_t);
  char *v72;
  char v73;
  char *v74;
  char *v75;
  void (*v76)(char *, char *, uint64_t);
  uint64_t v77;
  char *v78;
  char *v79;
  uint64_t (*v80)(uint64_t, uint64_t);
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  uint64_t v130;
  char *v131;
  uint64_t *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) != 0)
  {
    v31 = v19;
    v32 = *(uint64_t **)(a4 + 128);
    v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if (v33 >= 64)
    {
      v144 = -64;
      v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v51 = v142;
      v49(&v144, &type metadata for Int, v50, a3, a4);
      v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
      v39 = a1;
      v40 = v31;
      if ((v52 & 1) == 0)
        goto LABEL_19;
    }
    else
    {
      v36 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
      v39 = a1;
      v40 = v31;
      if (v37 >= -64)
        goto LABEL_19;
    }
LABEL_18:
    v61 = 0;
    goto LABEL_59;
  }
  v131 = v19;
  v132 = a1;
  v41 = v29(a3, a4);
  v32 = *(uint64_t **)(a4 + 128);
  v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v41 & 1) == 0)
  {
    if (v42 >= 64)
    {
      v40 = v131;
      v39 = v132;
      goto LABEL_19;
    }
    v53 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
LABEL_17:
    v40 = v131;
    v39 = v132;
    if (v54 >= -64)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (v42 <= 64)
  {
    v55 = v137;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v57 = v136;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v58 = v142;
    (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
    v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
    v60 = *(void (**)(char *, uint64_t))(v11 + 8);
    v60(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
    if ((v59 & 1) != 0)
    {
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
      v61 = 0;
      v39 = v132;
      goto LABEL_59;
    }
    v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    goto LABEL_17;
  }
  v144 = -64;
  v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
  v47 = v142;
  v45(&v144, &type metadata for Int, v46, a3, a4);
  v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
  v40 = v131;
  v39 = v132;
  if ((v48 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
  }
  else if (v63 >= 64)
  {
LABEL_21:
    v144 = 64;
    v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
    v68 = v142;
    v66(&v144, &type metadata for Int, v67, a3, a4);
    v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v68, a3);
    if ((v69 & 1) == 0)
      goto LABEL_22;
LABEL_30:
    v61 = *v39 >> 63;
    goto LABEL_59;
  }
  v88 = v142;
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
  v89 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v88, a3);
  if (v89 > 64)
    goto LABEL_30;
LABEL_22:
  v71 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v72 = v140;
  v71(v140, a2, a3);
  v73 = v141(a3, a4);
  v74 = v139;
  v75 = v72;
  v76 = (void (*)(char *, char *, uint64_t))v71;
  v71(v139, (uint64_t)v75, a3);
  v132 = v32;
  if ((v73 & 1) == 0)
  {
    v70(v74, a3);
    v78 = v140;
    goto LABEL_42;
  }
  v77 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v74, a3);
  v78 = v140;
  if (v77 <= 64)
    goto LABEL_42;
  v79 = v135;
  v76(v135, v140, a3);
  v144 = 0x8000000000000000;
  v80 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v81 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v81 >= 64)
    {
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v86 = v142;
      v84(&v144, &type metadata for Int, v85, a3, a4);
      LOBYTE(v84) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v86, a3);
      v87 = v86;
      v79 = v135;
      v70(v87, a3);
      if ((v84 & 1) != 0)
        goto LABEL_65;
      goto LABEL_41;
    }
  }
  else
  {
    v90 = v80(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v79 = v107;
        v70(v108, a3);
        v109 = v134;
        v76(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_65;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v78 = v140;
        if (v112)
          goto LABEL_65;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v79 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_65;
      }
      goto LABEL_41;
    }
    if (v91 >= 64)
      goto LABEL_41;
  }
  v100 = v142;
  v76(v142, v79, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_65:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
  v70(v79, a3);
LABEL_42:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v76(v138, v78, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }
  v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v76(v40, v78, a3);
    v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        v123 = &v144;
        goto LABEL_54;
      }
    }
    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
      v70(v127, a3);
      if ((v128 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v126 = v142;
    v76(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v78, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFC0)
    {
      v61 = v130 << -(char)v129;
      goto LABEL_59;
    }
    goto LABEL_18;
  }
  if (v129 >= 0x40)
    v61 = v130 >> 63;
  else
    v61 = v130 >> v129;
LABEL_59:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int64@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v61;
  uint64_t (*v62)(char *, uint64_t);
  void (*v63)(char *, uint64_t, uint64_t);
  char *v64;
  char v65;
  void (*v66)(char *, char *, uint64_t);
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t, uint64_t);
  uint64_t v79;
  char *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v86;
  int64_t *v87;
  uint64_t v88;
  char v89;
  unint64_t v90;
  char v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  void (*v95)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v96;
  char v97;
  void (*v98)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v99;
  char v100;
  char *v101;
  uint64_t v102;
  void (**v103)(char *, uint64_t, const char *);
  unint64_t v104;
  unint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  int64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  unint64_t AssociatedTypeWitness;
  char *v115;
  char *v116;
  char *v117;
  char *v118;
  uint64_t v119;
  uint64_t *v120;
  uint64_t (*v121)(uint64_t, uint64_t);
  uint64_t (*v122)(uint64_t, uint64_t);
  uint64_t v123;
  int64_t v124;

  v120 = a5;
  v115 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v115, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v113 = (char *)&v111 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v111 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v111 = (char *)&v111 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v111 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v117 = (char *)&v111 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v112 = (char *)&v111 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v111 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v118 = (char *)&v111 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v111 - v28;
  v119 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v121 = v30;
  if ((v31 & 1) == 0)
  {
    v38 = v30(a3, a4);
    v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v122(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v124 = -64;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v124, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v121;
        v32 = v122;
        if ((v42 & 1) != 0)
          goto LABEL_19;
        goto LABEL_20;
      }
      v48 = AssociatedTypeWitness;
      v49 = v115;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        goto LABEL_19;
      }
      v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v53 < -64;
    }
    else
    {
      if (v39 >= 64)
      {
        v30 = v121;
        v32 = v122;
        goto LABEL_20;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -64;
    }
    v30 = v121;
    v32 = v122;
    if (v47)
      goto LABEL_19;
    goto LABEL_20;
  }
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
    v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v36 > -65)
      goto LABEL_20;
LABEL_19:
    v54 = v120;
    v55 = v119 >> 63;
    goto LABEL_50;
  }
  v124 = -64;
  v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v44(&v124, &type metadata for Int, v45, a3, a4);
  LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v44 & 1) != 0)
    goto LABEL_19;
LABEL_20:
  v122 = v32;
  v56 = v30(a3, a4);
  v57 = v32(a3, a4);
  if ((v56 & 1) != 0)
  {
    if (v57 > 64)
      goto LABEL_22;
  }
  else if (v57 > 63)
  {
LABEL_22:
    v124 = 64;
    v60 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v61 = lazy protocol witness table accessor for type Int and conformance Int(v57, v58, v59);
    v60(&v124, &type metadata for Int, v61, a3, a4);
    LOBYTE(v60) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v62(v29, a3);
    if ((v60 & 1) == 0)
      goto LABEL_23;
LABEL_31:
    v55 = 0;
    v54 = v120;
    goto LABEL_50;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v62(v29, a3);
  if (v77 > 64)
    goto LABEL_31;
LABEL_23:
  v63 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v64 = v118;
  v63(v118, a2, a3);
  v65 = v121(a3, a4);
  v66 = (void (*)(char *, char *, uint64_t))v63;
  v63(v25, (uint64_t)v64, a3);
  if ((v65 & 1) == 0)
  {
    v76 = v25;
    v68 = v117;
    v69 = v118;
    goto LABEL_33;
  }
  v67 = v122(a3, a4);
  v62(v25, a3);
  v68 = v117;
  v69 = v118;
  if (v67 < 65)
    goto LABEL_34;
  v70 = v112;
  v66(v112, v118, a3);
  v124 = 0x8000000000000000;
  v71 = v121;
  if ((v121(a3, a4) & 1) == 0)
  {
    v91 = v71(a3, a4);
    v92 = v122(a3, a4);
    if ((v91 & 1) != 0)
    {
      if (v92 > 64)
      {
        v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
        v95(&v124, &type metadata for Int, v96, a3, a4);
        v70 = v112;
        v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
        goto LABEL_55;
      }
      v104 = AssociatedTypeWitness;
      v103 = (void (**)(char *, uint64_t, const char *))v115;
      v105 = swift_getAssociatedConformanceWitness((uint64_t)v115, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v106 = v113;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v105 + 8))(&qword_1816B7DA8, 256, v104, v105);
      v103[3](v106, a3, (const char *)v103);
      v107 = v112;
      LOBYTE(v103) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v112, v29, a3);
      v62(v29, a3);
      v108 = v111;
      v66(v111, v107, a3);
      if ((v103 & 1) != 0)
      {
        v62(v108, a3);
        goto LABEL_69;
      }
      v109 = v124;
      v110 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v108, a3);
      v47 = v110 < v109;
      v69 = v118;
      v76 = v112;
      if (!v47)
        goto LABEL_33;
    }
    else
    {
      if (v92 >= 64)
      {
        v76 = v112;
        goto LABEL_33;
      }
      v101 = v112;
      v66(v29, v112, a3);
      v102 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v29, a3);
      v76 = v101;
      if (v102 >= v124)
        goto LABEL_33;
    }
LABEL_69:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v72 = v122(a3, a4);
  if (v72 < 64)
  {
    v66(v29, v70, a3);
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
    v76 = v70;
    if (v75 < v124)
      goto LABEL_69;
    goto LABEL_33;
  }
  v98 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v99 = lazy protocol witness table accessor for type Int and conformance Int(v72, v73, v74);
  v98(&v124, &type metadata for Int, v99, a3, a4);
  v97 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v70, v29, a3);
LABEL_55:
  v100 = v97;
  v62(v29, a3);
  v76 = v70;
  if ((v100 & 1) != 0)
    goto LABEL_69;
LABEL_33:
  v62(v76, a3);
LABEL_34:
  v78 = v122;
  v79 = v122(a3, a4);
  v66(v68, v69, a3);
  if (v79 >= 65)
  {
    v62(v68, a3);
    goto LABEL_36;
  }
  v88 = v78(a3, a4);
  v62(v68, a3);
  if (v88 == 64 && (v121(a3, a4) & 1) == 0)
  {
LABEL_36:
    v80 = v116;
    v66(v116, v69, a3);
    v124 = 0x7FFFFFFFFFFFFFFFLL;
    v81 = v121(a3, a4);
    v82 = v122(a3, a4);
    if ((v81 & 1) != 0)
    {
      if (v82 > 64)
      {
        v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
        v87 = &v124;
        goto LABEL_45;
      }
    }
    else if (v82 > 63)
    {
      v123 = 0x7FFFFFFFFFFFFFFFLL;
      v85 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v86 = lazy protocol witness table accessor for type Int and conformance Int(v82, v83, v84);
      v87 = &v123;
LABEL_45:
      v85(v87, &type metadata for Int, v86, a3, a4);
      v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v80, a3);
      v62(v29, a3);
      if ((v89 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_46;
    }
    v66(v29, v80, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v29, a3);
LABEL_46:
    v62(v80, a3);
  }
  v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v62(v69, a3);
  if ((v90 & 0x8000000000000000) != 0)
  {
    v54 = v120;
    if (v90 <= 0xFFFFFFFFFFFFFFC0)
      v55 = v119 >> 63;
    else
      v55 = v119 >> -(char)v90;
  }
  else
  {
    v54 = v120;
    v55 = v119 << v90;
    if (v90 >= 0x40)
      v55 = 0;
  }
LABEL_50:
  *v54 = v55;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int64(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  uint64_t *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  uint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  uint64_t *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  uint64_t v130;
  char *v131;
  uint64_t *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    v131 = v19;
    v132 = a1;
    v41 = v29(a3, a4);
    v32 = *(uint64_t **)(a4 + 128);
    v42 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        v144 = -64;
        v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        v40 = v131;
        v39 = v132;
        if ((v48 & 1) != 0)
          goto LABEL_18;
        goto LABEL_19;
      }
      v55 = v137;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
      v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        v39 = v132;
        goto LABEL_18;
      }
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }
    else
    {
      if (v42 >= 64)
      {
        v40 = v131;
        v39 = v132;
        goto LABEL_19;
      }
      v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }
    v40 = v131;
    v39 = v132;
    if (v54 >= -64)
      goto LABEL_19;
    goto LABEL_18;
  }
  v31 = v19;
  v32 = *(uint64_t **)(a4 + 128);
  v33 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if (v33 < 64)
  {
    v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    v39 = a1;
    v40 = v31;
    if (v37 > -65)
      goto LABEL_19;
LABEL_18:
    v61 = *v39 >> 63;
    goto LABEL_59;
  }
  v144 = -64;
  v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
  v51 = v142;
  v49(&v144, &type metadata for Int, v50, a3, a4);
  v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
  v39 = a1;
  v40 = v31;
  if ((v52 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v62 = v141(a3, a4);
  v63 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_21;
LABEL_24:
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 > 64)
      goto LABEL_22;
    goto LABEL_25;
  }
  if (v63 < 64)
    goto LABEL_24;
LABEL_21:
  v144 = 64;
  v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
  v68 = v142;
  v66(&v144, &type metadata for Int, v67, a3, a4);
  v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v68, a3);
  if ((v69 & 1) != 0)
  {
LABEL_22:
    v61 = 0;
    goto LABEL_59;
  }
LABEL_25:
  v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v74 = v140;
  v73(v140, a2, a3);
  v75 = v141(a3, a4);
  v76 = v139;
  v77 = v74;
  v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  v132 = v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_42;
  }
  v79 = ((uint64_t (*)(uint64_t, uint64_t))v32)(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64)
    goto LABEL_42;
  v81 = v135;
  v78(v135, v140, a3);
  v144 = 0x8000000000000000;
  v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v88, a3);
      v89 = v88;
      v81 = v135;
      v70(v89, a3);
      if ((v86 & 1) != 0)
        goto LABEL_64;
      goto LABEL_41;
    }
  }
  else
  {
    v90 = v82(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v81 = v107;
        v70(v108, a3);
        v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_64;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v80 = v140;
        if (v112)
          goto LABEL_64;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_64;
      }
      goto LABEL_41;
    }
    if (v91 >= 64)
      goto LABEL_41;
  }
  v100 = v142;
  v78(v142, v81, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_64:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
  v70(v81, a3);
LABEL_42:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }
  v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v78(v40, v80, a3);
    v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        v123 = &v144;
        goto LABEL_54;
      }
    }
    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
      v70(v127, a3);
      if ((v128 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v126 = v142;
    v78(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) != 0)
  {
    if (v129 <= 0xFFFFFFFFFFFFFFC0)
      v61 = v130 >> 63;
    else
      v61 = v130 >> -(char)v129;
  }
  else
  {
    v61 = v130 << v129;
    if (v129 >= 0x40)
      v61 = 0;
  }
LABEL_59:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int64(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v3;
  uint64_t result;

  result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3, 0x2BE7uLL, 0x2BEEuLL);
  *a1 = result;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int64(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  char v13;
  int v14;
  char v15;
  char v16;
  uint64_t v17;

  v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  if (v7)
  {
    v10 = a3();
    if ((v11 & 0x100) != 0)
    {
      v12 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
      v16 = v15;
      swift_bridgeObjectRelease(a2);
      v14 = v16 & 1;
    }
    else
    {
      v12 = v10;
      v13 = v11;
      swift_bridgeObjectRelease(a2);
      v14 = v13 & 1;
    }
    if (v14)
      v17 = 0;
    else
      v17 = v12;
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    v17 = 0;
    LOBYTE(v14) = 1;
  }
  *(_QWORD *)a5 = v17;
  *(_BYTE *)(a5 + 8) = v14;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64 and conformance Int64, a5);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int64()
{
  uint64_t *v0;

  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
}

uint64_t *protocol witness for Strideable.distance(to:) in conformance Int64@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;

  v3 = *result;
  v4 = *v2;
  if (((*v2 ^ *result) & 0x8000000000000000) == 0)
  {
    v5 = __OFSUB__(v3, v4);
    v4 = v3 - v4;
    if (!v5)
      goto LABEL_15;
    __break(1u);
  }
  if (v4 >= 0)
    v6 = v4;
  else
    v6 = -v4;
  if (v3 < 0)
    v3 = -v3;
  v7 = __CFADD__(v6, v3);
  v8 = v6 + v3;
  if (v7)
  {
    __break(1u);
LABEL_17:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
  }
  if (v8 < 0)
    goto LABEL_17;
  if (v4 < 0)
    v4 = v8;
  else
    v4 = -v8;
LABEL_15:
  *a2 = v4;
  return result;
}

_QWORD *protocol witness for Strideable.advanced(by:) in conformance Int64@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  if (__OFADD__(*v2, *result))
    __break(1u);
  else
    *a2 = *v2 + *result;
  return result;
}

BOOL static Int64.<= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 >= a1;
}

void Int64.hash(into:)(int a1, Swift::UInt64 a2)
{
  Hasher._combine(_:)(a2);
}

uint64_t Int64._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int64@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t UInt._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t UInt64.init(exactly:)(float _S0)
{
  float v6;

  __asm { FCVT            S1, H0 }
  if (_S1 <= -1.0)
    return 0;
  v6 = _S0;
  _S0 = truncf(_S1);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }
  if ((~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1)
    return 0;
  else
    return (unint64_t)_S1;
}

Swift::UInt_optional __swiftcall UInt.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  int v2;
  Swift::UInt v3;
  char v4;
  Swift::UInt_optional result;

  v1 = exactly > -1.0;
  if (exactly >= 1.8447e19)
    v1 = 0;
  v2 = v1 & (truncf(exactly) == exactly);
  if (v2)
    v3 = (unint64_t)exactly;
  else
    v3 = 0;
  v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

Swift::UInt_optional __swiftcall UInt.init(exactly:)(Swift::Double exactly)
{
  BOOL v1;
  int v2;
  Swift::UInt v3;
  char v4;
  Swift::UInt_optional result;

  v1 = exactly > -1.0;
  if (exactly >= 1.84467441e19)
    v1 = 0;
  v2 = v1 & (trunc(exactly) == exactly);
  if (v2)
    v3 = (unint64_t)exactly;
  else
    v3 = 0;
  v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

_QWORD *static UInt.+= infix(_:_:)(_QWORD *result, uint64_t a2)
{
  if (__CFADD__(*result, a2))
    __break(1u);
  else
    *result += a2;
  return result;
}

unint64_t *static UInt.-= infix(_:_:)(unint64_t *result, unint64_t a2)
{
  if (*result < a2)
    __break(1u);
  else
    *result -= a2;
  return result;
}

unint64_t *static UInt.*= infix(_:_:)(unint64_t *result, unint64_t a2)
{
  if (is_mul_ok(*result, a2))
    *result *= a2;
  else
    __break(1u);
  return result;
}

_QWORD *static UInt./= infix(_:_:)(_QWORD *result, unint64_t a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x321DuLL, 0);
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.addingReportingOverflow(_:)(Swift::UInt a1)
{
  uint64_t v1;
  BOOL v2;
  Swift::UInt v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_UInt_overflow_Bool result;

  v2 = __CFADD__(v1, a1);
  v3 = v1 + a1;
  v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.subtractingReportingOverflow(_:)(Swift::UInt a1)
{
  Swift::UInt v1;
  BOOL v2;
  Swift::UInt v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_UInt_overflow_Bool result;

  v2 = v1 >= a1;
  v3 = v1 - a1;
  v4 = !v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.multipliedReportingOverflow(by:)(Swift::UInt by)
{
  unint64_t v1;
  Swift::UInt v2;
  Swift::Bool v3;
  Swift::UInt v4;
  Swift::tuple_partialValue_UInt_overflow_Bool result;

  v2 = v1 * by;
  v3 = !is_mul_ok(v1, by);
  v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.dividedReportingOverflow(by:)(Swift::UInt by)
{
  Swift::UInt v1;
  Swift::UInt v2;
  Swift::Bool v3;
  Swift::UInt v4;
  Swift::tuple_partialValue_UInt_overflow_Bool result;

  v2 = v1;
  if (by)
    v2 = v1 / by;
  v3 = by == 0;
  v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.remainderReportingOverflow(dividingBy:)(Swift::UInt dividingBy)
{
  Swift::UInt v1;
  Swift::UInt v2;
  Swift::Bool v3;
  Swift::UInt v4;
  Swift::tuple_partialValue_UInt_overflow_Bool result;

  v2 = v1;
  if (dividingBy)
    v2 = v1 % dividingBy;
  v3 = dividingBy == 0;
  v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

_QWORD *static UInt.%= infix(_:_:)(_QWORD *result, unint64_t a2)
{
  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x32F1uLL, 0);
  *result %= a2;
  return result;
}

_QWORD *static UInt.&>>= infix(_:_:)(_QWORD *result, char a2)
{
  *result >>= a2;
  return result;
}

uint64_t UInt.Words._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.Words.count.getter()
{
  return 1;
}

uint64_t UInt.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt.Words.indices.getter()
{
  return 0;
}

uint64_t UInt.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x33EFuLL, 0x33F0uLL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t *v2;
  uint64_t v4;

  v4 = *v2;
  UInt.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.multipliedFullWidth(by:)(unint64_t a1, unint64_t a2)
{
  return (a2 * (unsigned __int128)a1) >> 64;
}

Swift::tuple_quotient_UInt_remainder_UInt __swiftcall UInt.dividingFullWidth(_:)(Swift::tuple_high_UInt_low_UInt a1)
{
  unint64_t v1;
  Swift::UInt v2;
  Swift::UInt v3;
  Swift::tuple_quotient_UInt_remainder_UInt result;

  v2 = UInt64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x3463uLL, 0x3465uLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t UInt64.dividingFullWidth(_:)(unint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  if (a1 >= a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  return __udivti3();
}

unint64_t UInt.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

Swift::UInt __swiftcall UInt.signum()()
{
  uint64_t v0;

  return v0 != 0;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  _BOOL8 v3;

  v3 = __CFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  _BOOL8 v3;

  v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt(_QWORD *a1, unint64_t *a2)
{
  unint64_t *v2;
  _BOOL8 v3;

  v3 = !is_mul_ok(*v2, *a2);
  *a1 = *v2 * *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt(_QWORD *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
    v4 /= v3;
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt(_QWORD *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
    v4 %= v3;
  *a1 = v4;
  return v3 == 0;
}

_QWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt64(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v3;
  uint64_t v4;

  v4 = *v3 * *a3;
  *result = ((unint64_t)*v3 * (unsigned __int128)(unint64_t)*a3) >> 64;
  *a2 = v4;
  return result;
}

Swift::UInt protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt(Swift::UInt *a1, Swift::UInt *a2, Swift::tuple_high_UInt_low_UInt *a3)
{
  Swift::UInt result;
  Swift::tuple_quotient_UInt_remainder_UInt v6;

  v6 = UInt.dividingFullWidth(_:)(*a3);
  result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt(_QWORD *result, _QWORD *a2)
{
  *result >>= *a2;
  return result;
}

_QWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt@<X0>(_QWORD *result@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  if (a2 >> 9 <= 0x20 && (a2 & 1) == 0)
    *a3 = *result;
  else
    *a3 = 0;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt and conformance UInt(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt and conformance UInt, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  char v23;
  uint64_t v24;
  unint64_t AssociatedConformanceWitness;
  char *v26;
  char v27;
  void (*v28)(char *, uint64_t);
  uint64_t (*v29)(uint64_t, uint64_t);
  uint64_t v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  void (*v36)(char *, uint64_t);
  unint64_t v37;
  char *v38;
  unint64_t v39;
  char v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t result;
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;

  v46 = a4;
  v47 = a5;
  v49 = a6;
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v48 = (char *)&v44 - v12;
  v52 = *(_QWORD *)(a2 - 8);
  v13 = MEMORY[0x1E0C80A78](v11);
  v45 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v51 = (char *)&v44 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v44 - v18;
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v44 - v20;
  v22 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v23 = v22(a2, a3);
  v50 = a1;
  if ((v23 & 1) != 0)
  {
    v24 = v52;
    (*(void (**)(char *, uint64_t, uint64_t))(v52 + 16))(v21, a1, a2);
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v26 = v48;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v26, a2, v9);
    v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 32))(v21, v19, a2);
    v28 = *(void (**)(char *, uint64_t))(v24 + 8);
    v28(v19, a2);
    if ((v27 & 1) == 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    v28(v21, a2);
    a1 = v50;
  }
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v30 = a1;
  if (v29(a2, a3) >= 64)
  {
    v44 = *(void (**)(char *, uint64_t, uint64_t))(v52 + 16);
    v44(v51, a1, a2);
    v53 = -1;
    v31 = v22(a2, a3);
    v32 = v29(a2, a3);
    if ((v31 & 1) != 0)
    {
      if (v32 < 65)
      {
        v33 = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v34 = v48;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v33 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v33);
        (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v34, a2, v9);
        v35 = v51;
        LOBYTE(v34) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 40))(v51, v19, a2);
        v36 = *(void (**)(char *, uint64_t))(v52 + 8);
        v36(v19, a2);
        v37 = v53;
        v38 = v45;
        v44(v45, (uint64_t)v35, a2);
        v30 = v50;
        if ((v34 & 1) != 0)
        {
          v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v36(v38, a2);
          if (v37 < v39)
            goto LABEL_14;
        }
        else
        {
          v36(v38, a2);
        }
        goto LABEL_16;
      }
    }
    else if (v32 <= 64)
    {
      v35 = v51;
      v44(v19, (uint64_t)v51, a2);
      v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v36 = *(void (**)(char *, uint64_t))(v52 + 8);
      v36(v19, a2);
      v30 = v50;
      if (v53 < v41)
        goto LABEL_14;
LABEL_16:
      v36(v35, a2);
      goto LABEL_17;
    }
    (*(void (**)(unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v53, v46, v47, a2, a3);
    v35 = v51;
    v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v19, v51, a2);
    v36 = *(void (**)(char *, uint64_t))(v52 + 8);
    v36(v19, a2);
    v30 = v50;
    if ((v40 & 1) != 0)
LABEL_14:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    goto LABEL_16;
  }
LABEL_17:
  v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(v52 + 8))(v30, a2);
  *v49 = v42;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type UInt and conformance UInt((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt()
{
  unint64_t *v0;

  if (!*v0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  return __clz(*v0) ^ 0x3F;
}

_QWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x321DuLL, 0);
  *a3 = *result / *a2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt(_QWORD *result, _QWORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x321DuLL, 0);
  *result /= *a2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x32F1uLL, 0);
  *a3 = *result % *a2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt(_QWORD *result, _QWORD *a2)
{
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x32F1uLL, 0);
  *result %= *a2;
  return result;
}

uint64_t static UInt.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt64@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t result;
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t AssociatedConformanceWitness;
  char *v53;
  void (*v54)(char *, uint64_t);
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  char v61;
  uint64_t (*v62)(char *, uint64_t);
  uint64_t v63;
  unint64_t v64;
  void (*v65)(char *, uint64_t, uint64_t);
  char *v66;
  char v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  char v86;
  void (*v87)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v88;
  char v89;
  void (**v90)(char *, uint64_t, const char *);
  unint64_t v91;
  unint64_t v92;
  char *v93;
  char *v94;
  char *v95;
  int64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  char *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  int64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char *v113;
  uint64_t v114;
  uint64_t (*v115)(char *, uint64_t);
  char *v116;
  char *v117;
  char *v118;
  unint64_t AssociatedTypeWitness;
  char *v120;
  char *v121;
  unint64_t v122;
  char *v123;
  char *v124;
  uint64_t (*v125)(uint64_t, uint64_t);
  unint64_t *v126;
  uint64_t (*v127)(uint64_t, uint64_t);
  uint64_t v128;
  int64_t v129;

  v126 = a5;
  v120 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v120, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v118 = (char *)&v114 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v116 = (char *)&v114 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v114 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v123 = (char *)&v114 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v117 = (char *)&v114 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v114 - v25;
  v27 = MEMORY[0x1E0C80A78](v24);
  v124 = (char *)&v114 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v114 - v29;
  v122 = *a1;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v121 = v19;
  v127 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v129 = -64;
      v46 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v129, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if ((v48 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
      if (v37 < -64)
        goto LABEL_24;
    }
  }
  else
  {
    v39 = v31(a3, a4);
    v125 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v40 = v125(a3, a4);
    if ((v39 & 1) != 0)
    {
      if (v40 > 64)
      {
        v129 = -64;
        v43 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
        v43(&v129, &type metadata for Int, v44, a3, a4);
        v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
        v33 = v125;
        if ((v45 & 1) != 0)
          goto LABEL_24;
        goto LABEL_18;
      }
      v50 = AssociatedTypeWitness;
      v51 = v120;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v53 = v118;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v50, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
      LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      v54 = *(void (**)(char *, uint64_t))(v11 + 8);
      v54(v30, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v50 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
        goto LABEL_24;
      }
      v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v54)(v14, a3);
    }
    else
    {
      if (v40 >= 64)
      {
        v33 = v125;
        goto LABEL_18;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
      v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v30, a3);
    }
    v33 = v125;
    if (v49 < -64)
      goto LABEL_24;
  }
LABEL_18:
  v55 = v127(a3, a4);
  v56 = v33(a3, a4);
  v125 = v33;
  if ((v55 & 1) != 0)
  {
    if (v56 > 64)
      goto LABEL_20;
    goto LABEL_23;
  }
  if (v56 <= 63)
  {
LABEL_23:
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v30, a2, a3);
    v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v62(v30, a3);
    if (v63 <= 64)
      goto LABEL_25;
LABEL_24:
    v64 = 0;
    goto LABEL_64;
  }
LABEL_20:
  v129 = 64;
  v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
  v59(&v129, &type metadata for Int, v60, a3, a4);
  v61 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
  v62 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v62(v30, a3);
  if ((v61 & 1) != 0)
    goto LABEL_24;
LABEL_25:
  v65 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v66 = v124;
  v65(v124, a2, a3);
  v67 = v127(a3, a4);
  v65(v26, (uint64_t)v66, a3);
  if ((v67 & 1) == 0)
  {
    v62(v26, a3);
    v71 = v123;
    v70 = v124;
    v68 = v125;
    v79 = v125(a3, a4);
    goto LABEL_47;
  }
  v68 = v125;
  v69 = v125(a3, a4);
  v62(v26, a3);
  v71 = v123;
  v70 = v124;
  if (v69 > 64)
  {
    v115 = v62;
    v72 = v117;
    v65(v117, (uint64_t)v124, a3);
    v129 = 0x8000000000000000;
    v73 = v127;
    if ((v127(a3, a4) & 1) != 0)
    {
      v74 = v68(a3, a4);
      if (v74 < 64)
      {
        v65(v30, (uint64_t)v72, a3);
        v77 = v72;
        v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v62 = v115;
        v115(v30, a3);
LABEL_40:
        if (v78 < v129)
LABEL_69:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_44;
      }
      v77 = v72;
      v87 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v88 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
      v87(&v129, &type metadata for Int, v88, a3, a4);
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v77, v30, a3);
    }
    else
    {
      v80 = v73(a3, a4);
      v81 = v68(a3, a4);
      if ((v80 & 1) == 0)
      {
        v62 = v115;
        if (v81 >= 64)
        {
          v113 = v117;
LABEL_45:
          v62(v113, a3);
          goto LABEL_46;
        }
        v77 = v117;
        v65(v30, (uint64_t)v117, a3);
        v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v62(v30, a3);
        goto LABEL_40;
      }
      if (v81 <= 64)
      {
        v91 = AssociatedTypeWitness;
        v90 = (void (**)(char *, uint64_t, const char *))v120;
        v92 = swift_getAssociatedConformanceWitness((uint64_t)v120, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v93 = v118;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v92 + 8))(&qword_1816B7DA8, 256, v91, v92);
        v90[3](v93, a3, (const char *)v90);
        v94 = v117;
        LOBYTE(v90) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
        v115(v30, a3);
        v95 = v116;
        v65(v116, (uint64_t)v94, a3);
        if ((v90 & 1) != 0)
        {
          v115(v95, a3);
          goto LABEL_69;
        }
        v96 = v129;
        v97 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v62 = v115;
        v115(v95, a3);
        v98 = v97 < v96;
        v70 = v124;
        v77 = v117;
        if (v98)
          goto LABEL_69;
LABEL_44:
        v113 = v77;
        goto LABEL_45;
      }
      v84 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
      v84(&v129, &type metadata for Int, v85, a3, a4);
      v77 = v117;
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v117, v30, a3);
    }
    v89 = v86;
    v62 = v115;
    v115(v30, a3);
    if ((v89 & 1) != 0)
      goto LABEL_69;
    goto LABEL_44;
  }
LABEL_46:
  v79 = v68(a3, a4);
LABEL_47:
  v99 = v79;
  v65(v71, (uint64_t)v70, a3);
  if (v99 >= 65)
  {
    v62(v71, a3);
    v100 = v127;
    goto LABEL_49;
  }
  v109 = v68(a3, a4);
  v62(v71, a3);
  v110 = v109 == 64;
  v100 = v127;
  if (v110 && (v127(a3, a4) & 1) == 0)
  {
LABEL_49:
    v101 = v121;
    v65(v121, (uint64_t)v70, a3);
    v129 = 0x7FFFFFFFFFFFFFFFLL;
    v102 = v100(a3, a4);
    v103 = v68(a3, a4);
    if ((v102 & 1) != 0)
    {
      if (v103 > 64)
      {
        v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
        v108 = &v129;
        goto LABEL_59;
      }
    }
    else if (v103 > 63)
    {
      v128 = 0x7FFFFFFFFFFFFFFFLL;
      v106 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
      v108 = &v128;
LABEL_59:
      v106(v108, &type metadata for Int, v107, a3, a4);
      v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v101, a3);
      v62(v30, a3);
      if ((v111 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_60;
    }
    v65(v30, (uint64_t)v101, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v62(v30, a3);
LABEL_60:
    v62(v101, a3);
  }
  v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v62(v70, a3);
  if ((v112 & 0x8000000000000000) != 0)
  {
    if (v112 > 0xFFFFFFFFFFFFFFC0)
    {
      v64 = v122 << -(char)v112;
      goto LABEL_64;
    }
    goto LABEL_24;
  }
  v64 = v122 >> v112;
  if (v112 >= 0x40)
    v64 = 0;
LABEL_64:
  *v126 = v64;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt64(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  unint64_t *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  unint64_t *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unint64_t v130;
  char *v131;
  unint64_t *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    v131 = v19;
    v132 = a1;
    v41 = v29(a3, a4);
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        v144 = -64;
        v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        v40 = v131;
        v39 = v132;
        if ((v48 & 1) != 0)
          goto LABEL_24;
        goto LABEL_18;
      }
      v55 = v137;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
      v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        v61 = 0;
        v39 = v132;
        goto LABEL_59;
      }
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }
    else
    {
      if (v42 >= 64)
      {
        v40 = v131;
        v39 = v132;
        goto LABEL_18;
      }
      v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }
    v40 = v131;
    v39 = v132;
    if (v54 < -64)
      goto LABEL_24;
    goto LABEL_18;
  }
  v31 = v19;
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    v144 = -64;
    v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v51 = v142;
    v49(&v144, &type metadata for Int, v50, a3, a4);
    v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
    v39 = a1;
    v40 = v31;
    if ((v52 & 1) != 0)
      goto LABEL_24;
  }
  else
  {
    v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    v39 = a1;
    v40 = v31;
    if (v37 < -64)
      goto LABEL_24;
  }
LABEL_18:
  v62 = v141(a3, a4);
  v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_20;
    goto LABEL_23;
  }
  if (v63 < 64)
  {
LABEL_23:
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 64)
      goto LABEL_25;
LABEL_24:
    v61 = 0;
    goto LABEL_59;
  }
LABEL_20:
  v144 = 64;
  v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
  v68 = v142;
  v66(&v144, &type metadata for Int, v67, a3, a4);
  v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v68, a3);
  if ((v69 & 1) != 0)
    goto LABEL_24;
LABEL_25:
  v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v74 = v140;
  v73(v140, a2, a3);
  v75 = v141(a3, a4);
  v76 = v139;
  v77 = v74;
  v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  v132 = (unint64_t *)v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_42;
  }
  v79 = v32(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64)
    goto LABEL_42;
  v81 = v135;
  v78(v135, v140, a3);
  v144 = 0x8000000000000000;
  v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v88, a3);
      v89 = v88;
      v81 = v135;
      v70(v89, a3);
      if ((v86 & 1) != 0)
        goto LABEL_64;
      goto LABEL_41;
    }
  }
  else
  {
    v90 = v82(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v81 = v107;
        v70(v108, a3);
        v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_64;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v80 = v140;
        if (v112)
          goto LABEL_64;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_64;
      }
      goto LABEL_41;
    }
    if (v91 >= 64)
      goto LABEL_41;
  }
  v100 = v142;
  v78(v142, v81, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_64:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
  v70(v81, a3);
LABEL_42:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }
  v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v78(v40, v80, a3);
    v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        v123 = &v144;
        goto LABEL_54;
      }
    }
    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
      v70(v127, a3);
      if ((v128 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v126 = v142;
    v78(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) != 0)
  {
    if (v129 >= 0xFFFFFFFFFFFFFFC1)
    {
      v61 = v130 << -(char)v129;
      goto LABEL_59;
    }
    goto LABEL_24;
  }
  v61 = v130 >> v129;
  if (v129 >= 0x40)
    v61 = 0;
LABEL_59:
  *v39 = v61;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t (*v30)(uint64_t, uint64_t);
  char v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v43;
  void (*v44)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  uint64_t v46;
  BOOL v47;
  unint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  void (*v52)(char *, uint64_t);
  unint64_t v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void (*v59)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v60;
  uint64_t (*v61)(char *, uint64_t);
  void (*v62)(void);
  char *v63;
  char v64;
  uint64_t v65;
  char *v66;
  char *v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t (*v75)(uint64_t, uint64_t);
  uint64_t v76;
  char *v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v83;
  int64_t *v84;
  uint64_t v85;
  char v86;
  unint64_t v87;
  unint64_t *v88;
  char v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void (*v93)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v94;
  char v95;
  void (*v96)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v97;
  char v98;
  char *v99;
  uint64_t v100;
  void (**v101)(char *, uint64_t, const char *);
  unint64_t v102;
  unint64_t v103;
  char *v104;
  char *v105;
  char *v106;
  int64_t v107;
  uint64_t v108;
  char *v109;
  char *v110;
  char *v111;
  unint64_t AssociatedTypeWitness;
  char *v113;
  unint64_t v114;
  char *v115;
  char *v116;
  char *v117;
  unint64_t *v118;
  uint64_t (*v119)(uint64_t, uint64_t);
  uint64_t (*v120)(uint64_t, uint64_t);
  uint64_t v121;
  int64_t v122;

  v118 = a5;
  v113 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v113, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v111 = (char *)&v109 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v109 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v109 = (char *)&v109 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v116 = (char *)&v109 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v115 = (char *)&v109 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v110 = (char *)&v109 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v109 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v117 = (char *)&v109 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v109 - v28;
  v114 = *a1;
  v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v31 = v30(a3, a4);
  v119 = v30;
  if ((v31 & 1) != 0)
  {
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v33 = v32(a3, a4);
    if (v33 >= 64)
    {
      v122 = -64;
      v44 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v45 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v44(&v122, &type metadata for Int, v45, a3, a4);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if ((v44 & 1) != 0)
        goto LABEL_29;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v36 < -64)
        goto LABEL_29;
    }
  }
  else
  {
    v38 = v30(a3, a4);
    v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v120(a3, a4);
    if ((v38 & 1) != 0)
    {
      if (v39 > 64)
      {
        v122 = -64;
        v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        v42(&v122, &type metadata for Int, v43, a3, a4);
        LOBYTE(v42) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(a2, v29, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
        v30 = v119;
        v32 = v120;
        if ((v42 & 1) != 0)
          goto LABEL_29;
        goto LABEL_18;
      }
      v48 = AssociatedTypeWitness;
      v49 = v113;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v113, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v51 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v48, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v51, a3, v49);
      LOBYTE(v48) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v52 = *(void (**)(char *, uint64_t))(v11 + 8);
      v52(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v48 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
        v53 = 0;
LABEL_48:
        v88 = v118;
        goto LABEL_49;
      }
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v52)(v14, a3);
      v47 = v54 < -64;
    }
    else
    {
      if (v39 >= 64)
      {
        v30 = v119;
        v32 = v120;
        goto LABEL_18;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      v47 = v46 < -64;
    }
    v30 = v119;
    v32 = v120;
    if (v47)
      goto LABEL_29;
  }
LABEL_18:
  v120 = v32;
  v55 = v30(a3, a4);
  v56 = v32(a3, a4);
  if ((v55 & 1) != 0)
  {
    if (v56 > 64)
      goto LABEL_20;
  }
  else if (v56 > 63)
  {
LABEL_20:
    v122 = 64;
    v59 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v60 = lazy protocol witness table accessor for type Int and conformance Int(v56, v57, v58);
    v59(&v122, &type metadata for Int, v60, a3, a4);
    LOBYTE(v59) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v61(v29, a3);
    if ((v59 & 1) == 0)
      goto LABEL_21;
LABEL_29:
    v53 = 0;
    goto LABEL_48;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v61 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v61(v29, a3);
  if (v74 > 64)
    goto LABEL_29;
LABEL_21:
  v62 = *(void (**)(void))(v11 + 16);
  v63 = v117;
  v62();
  v64 = v119(a3, a4);
  ((void (*)(char *, char *, uint64_t))v62)(v25, v63, a3);
  if ((v64 & 1) == 0)
  {
    v73 = v25;
    v66 = v116;
    goto LABEL_31;
  }
  v65 = v120(a3, a4);
  v61(v25, a3);
  v66 = v116;
  if (v65 < 65)
    goto LABEL_32;
  v67 = v110;
  ((void (*)(char *, char *, uint64_t))v62)(v110, v63, a3);
  v122 = 0x8000000000000000;
  v68 = v119;
  if ((v119(a3, a4) & 1) == 0)
  {
    v89 = v68(a3, a4);
    v90 = v120(a3, a4);
    if ((v89 & 1) != 0)
    {
      if (v90 > 64)
      {
        v93 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v94 = lazy protocol witness table accessor for type Int and conformance Int(v90, v91, v92);
        v93(&v122, &type metadata for Int, v94, a3, a4);
        v67 = v110;
        v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v110, v29, a3);
        goto LABEL_54;
      }
      v102 = AssociatedTypeWitness;
      v101 = (void (**)(char *, uint64_t, const char *))v113;
      v103 = swift_getAssociatedConformanceWitness((uint64_t)v113, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v104 = v111;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v103 + 8))(&qword_1816B7DA8, 256, v102, v103);
      v101[3](v104, a3, (const char *)v101);
      v105 = v110;
      LOBYTE(v101) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v110, v29, a3);
      v61(v29, a3);
      v106 = v109;
      ((void (*)(char *, char *, uint64_t))v62)(v109, v105, a3);
      if ((v101 & 1) != 0)
      {
        v61(v106, a3);
        goto LABEL_68;
      }
      v107 = v122;
      v108 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v106, a3);
      v47 = v108 < v107;
      v63 = v117;
      v73 = v110;
      if (!v47)
        goto LABEL_31;
    }
    else
    {
      if (v90 >= 64)
      {
        v73 = v110;
        goto LABEL_31;
      }
      v99 = v110;
      ((void (*)(char *, char *, uint64_t))v62)(v29, v110, a3);
      v100 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v29, a3);
      v73 = v99;
      if (v100 >= v122)
        goto LABEL_31;
    }
LABEL_68:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  v69 = v120(a3, a4);
  if (v69 < 64)
  {
    ((void (*)(char *, char *, uint64_t))v62)(v29, v67, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
    v73 = v67;
    if (v72 < v122)
      goto LABEL_68;
    goto LABEL_31;
  }
  v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v97 = lazy protocol witness table accessor for type Int and conformance Int(v69, v70, v71);
  v96(&v122, &type metadata for Int, v97, a3, a4);
  v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v67, v29, a3);
LABEL_54:
  v98 = v95;
  v61(v29, a3);
  v73 = v67;
  if ((v98 & 1) != 0)
    goto LABEL_68;
LABEL_31:
  v61(v73, a3);
LABEL_32:
  v75 = v120;
  v76 = v120(a3, a4);
  v77 = v115;
  ((void (*)(char *, char *, uint64_t))v62)(v115, v63, a3);
  if (v76 >= 65)
  {
    v61(v77, a3);
    goto LABEL_34;
  }
  v85 = v75(a3, a4);
  v61(v77, a3);
  if (v85 == 64 && (v119(a3, a4) & 1) == 0)
  {
LABEL_34:
    ((void (*)(char *, char *, uint64_t))v62)(v66, v63, a3);
    v122 = 0x7FFFFFFFFFFFFFFFLL;
    v78 = v119(a3, a4);
    v79 = v120(a3, a4);
    if ((v78 & 1) != 0)
    {
      if (v79 > 64)
      {
        v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        v84 = &v122;
        goto LABEL_43;
      }
    }
    else if (v79 > 63)
    {
      v121 = 0x7FFFFFFFFFFFFFFFLL;
      v82 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
      v84 = &v121;
LABEL_43:
      v82(v84, &type metadata for Int, v83, a3, a4);
      v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v66, a3);
      v61(v29, a3);
      if ((v86 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_44;
    }
    ((void (*)(char *, char *, uint64_t))v62)(v29, v66, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v61(v29, a3);
LABEL_44:
    v61(v66, a3);
  }
  v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v61(v63, a3);
  if ((v87 & 0x8000000000000000) == 0)
  {
    v53 = v114 << v87;
    if (v87 >= 0x40)
      v53 = 0;
    goto LABEL_48;
  }
  v88 = v118;
  if (v87 <= 0xFFFFFFFFFFFFFFC0)
    v53 = 0;
  else
    v53 = v114 >> -(char)v87;
LABEL_49:
  *v88 = v53;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt64(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  char *v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t result;
  unint64_t *v39;
  char *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char *v47;
  char v48;
  void (*v49)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v50;
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  const char *v55;
  unint64_t AssociatedConformanceWitness;
  char *v57;
  char *v58;
  char v59;
  void (*v60)(char *, uint64_t);
  unint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v67;
  char *v68;
  char v69;
  uint64_t (*v70)(char *, uint64_t);
  char *v71;
  uint64_t v72;
  void (*v73)(char *, uint64_t, uint64_t);
  char *v74;
  char v75;
  char *v76;
  char *v77;
  void (*v78)(char *, char *, uint64_t);
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t (*v82)(uint64_t, uint64_t);
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void (*v86)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v87;
  char *v88;
  char *v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void (*v94)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  char *v99;
  char *v100;
  uint64_t v101;
  void (**v102)(char *, uint64_t, const char *);
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  int64_t v110;
  uint64_t v111;
  BOOL v112;
  unint64_t *v113;
  uint64_t v114;
  char *v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  void (*v121)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v122;
  int64_t *v123;
  uint64_t v124;
  BOOL v125;
  char *v126;
  char *v127;
  char v128;
  unint64_t v129;
  unint64_t v130;
  char *v131;
  unint64_t *v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  char *v140;
  uint64_t (*v141)(uint64_t, uint64_t);
  char *v142;
  uint64_t v143;
  int64_t v144;

  v137 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v137, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v136 = (char *)&v131 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v131 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v134 = (char *)&v131 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v19 = (char *)&v131 - v18;
  v20 = MEMORY[0x1E0C80A78](v17);
  v138 = (char *)&v131 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v135 = (char *)&v131 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v139 = (char *)&v131 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v140 = (char *)&v131 - v27;
  MEMORY[0x1E0C80A78](v26);
  v142 = (char *)&v131 - v28;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v141 = v29;
  v133 = AssociatedTypeWitness;
  if ((v30 & 1) == 0)
  {
    v131 = v19;
    v132 = a1;
    v41 = v29(a3, a4);
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v42 = v32(a3, a4);
    if ((v41 & 1) != 0)
    {
      if (v42 > 64)
      {
        v144 = -64;
        v45 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
        v47 = v142;
        v45(&v144, &type metadata for Int, v46, a3, a4);
        v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v47, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v47, a3);
        v40 = v131;
        v39 = v132;
        if ((v48 & 1) != 0)
          goto LABEL_24;
        goto LABEL_18;
      }
      v55 = v137;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v57 = v136;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      v58 = v142;
      (*((void (**)(char *, uint64_t, const char *))v55 + 3))(v57, a3, v55);
      v59 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v58, a3);
      v60 = *(void (**)(char *, uint64_t))(v11 + 8);
      v60(v58, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v59 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
        v61 = 0;
        v39 = v132;
        goto LABEL_59;
      }
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v60)(v14, a3);
    }
    else
    {
      if (v42 >= 64)
      {
        v40 = v131;
        v39 = v132;
        goto LABEL_18;
      }
      v53 = v142;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
      v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v53, a3);
    }
    v40 = v131;
    v39 = v132;
    if (v54 < -64)
      goto LABEL_24;
    goto LABEL_18;
  }
  v31 = v19;
  v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v33 = v32(a3, a4);
  if (v33 >= 64)
  {
    v144 = -64;
    v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v50 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    v51 = v142;
    v49(&v144, &type metadata for Int, v50, a3, a4);
    v52 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v51, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v51, a3);
    v39 = a1;
    v40 = v31;
    if ((v52 & 1) != 0)
      goto LABEL_24;
  }
  else
  {
    v36 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v11 + 8))(v36, a3);
    v39 = a1;
    v40 = v31;
    if (v37 < -64)
      goto LABEL_24;
  }
LABEL_18:
  v62 = v141(a3, a4);
  v63 = v32(a3, a4);
  if ((v62 & 1) != 0)
  {
    if (v63 > 64)
      goto LABEL_20;
    goto LABEL_23;
  }
  if (v63 < 64)
  {
LABEL_23:
    v71 = v142;
    (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v142, a2, a3);
    v72 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
    result = v70(v71, a3);
    if (v72 <= 64)
      goto LABEL_25;
LABEL_24:
    v61 = 0;
    goto LABEL_59;
  }
LABEL_20:
  v144 = 64;
  v66 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v67 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
  v68 = v142;
  v66(&v144, &type metadata for Int, v67, a3, a4);
  v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v68, a2, a3);
  v70 = *(uint64_t (**)(char *, uint64_t))(v11 + 8);
  result = v70(v68, a3);
  if ((v69 & 1) != 0)
    goto LABEL_24;
LABEL_25:
  v73 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v74 = v140;
  v73(v140, a2, a3);
  v75 = v141(a3, a4);
  v76 = v139;
  v77 = v74;
  v78 = (void (*)(char *, char *, uint64_t))v73;
  v73(v139, (uint64_t)v77, a3);
  v132 = (unint64_t *)v32;
  if ((v75 & 1) == 0)
  {
    v70(v76, a3);
    v80 = v140;
    goto LABEL_42;
  }
  v79 = v32(a3, a4);
  v70(v76, a3);
  v80 = v140;
  if (v79 <= 64)
    goto LABEL_42;
  v81 = v135;
  v78(v135, v140, a3);
  v144 = 0x8000000000000000;
  v82 = v141;
  if ((v141(a3, a4) & 1) != 0)
  {
    v83 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if (v83 >= 64)
    {
      v86 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v87 = lazy protocol witness table accessor for type Int and conformance Int(v83, v84, v85);
      v88 = v142;
      v86(&v144, &type metadata for Int, v87, a3, a4);
      LOBYTE(v86) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v88, a3);
      v89 = v88;
      v81 = v135;
      v70(v89, a3);
      if ((v86 & 1) != 0)
        goto LABEL_64;
      goto LABEL_41;
    }
  }
  else
  {
    v90 = v82(a3, a4);
    v91 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v90 & 1) != 0)
    {
      if (v91 <= 64)
      {
        v102 = (void (**)(char *, uint64_t, const char *))v137;
        v103 = v133;
        v104 = swift_getAssociatedConformanceWitness((uint64_t)v137, a3, v133, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v105 = v136;
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v104 + 8))(&qword_1816B7DA8, 256, v103, v104);
        v106 = v142;
        v102[3](v105, a3, (const char *)v102);
        v107 = v135;
        LOBYTE(v102) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                          + 16))(v135, v106, a3);
        v108 = v106;
        v81 = v107;
        v70(v108, a3);
        v109 = v134;
        v78(v134, v107, a3);
        if ((v102 & 1) != 0)
        {
          v70(v109, a3);
          goto LABEL_64;
        }
        v110 = v144;
        v111 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v70(v109, a3);
        v112 = v111 < v110;
        v80 = v140;
        if (v112)
          goto LABEL_64;
      }
      else
      {
        v94 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v95 = lazy protocol witness table accessor for type Int and conformance Int(v91, v92, v93);
        v96 = v142;
        v94(&v144, &type metadata for Int, v95, a3, a4);
        v97 = v135;
        v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v135, v96, a3);
        v99 = v96;
        v81 = v97;
        v70(v99, a3);
        if ((v98 & 1) != 0)
          goto LABEL_64;
      }
      goto LABEL_41;
    }
    if (v91 >= 64)
      goto LABEL_41;
  }
  v100 = v142;
  v78(v142, v81, a3);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v100, a3);
  if (v101 < v144)
LABEL_64:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_41:
  v70(v81, a3);
LABEL_42:
  v113 = v132;
  v114 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
  v115 = v138;
  v78(v138, v80, a3);
  if (v114 >= 65)
  {
    v70(v115, a3);
    v116 = v141;
    goto LABEL_44;
  }
  v124 = ((uint64_t (*)(uint64_t, uint64_t))v113)(a3, a4);
  v70(v115, a3);
  v125 = v124 == 64;
  v116 = v141;
  if (v125 && (v141(a3, a4) & 1) == 0)
  {
LABEL_44:
    v78(v40, v80, a3);
    v144 = 0x7FFFFFFFFFFFFFFFLL;
    v117 = v116(a3, a4);
    v118 = ((uint64_t (*)(uint64_t, uint64_t))v132)(a3, a4);
    if ((v117 & 1) != 0)
    {
      if (v118 > 64)
      {
        v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
        v123 = &v144;
        goto LABEL_54;
      }
    }
    else if (v118 >= 64)
    {
      v143 = 0x7FFFFFFFFFFFFFFFLL;
      v121 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v122 = lazy protocol witness table accessor for type Int and conformance Int(v118, v119, v120);
      v123 = &v143;
LABEL_54:
      v127 = v142;
      v121(v123, &type metadata for Int, v122, a3, a4);
      v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v127, v40, a3);
      v70(v127, a3);
      if ((v128 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v126 = v142;
    v78(v142, v40, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v70(v126, a3);
LABEL_55:
    v70(v40, a3);
  }
  v129 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v70(v80, a3);
  v130 = *v39;
  if ((v129 & 0x8000000000000000) != 0)
  {
    if (v129 > 0xFFFFFFFFFFFFFFC0)
    {
      v61 = v130 >> -(char)v129;
      goto LABEL_59;
    }
    goto LABEL_24;
  }
  v61 = v130 << v129;
  if (v129 >= 0x40)
    v61 = 0;
LABEL_59:
  *v39 = v61;
  return result;
}

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(a1, a2, a3, a4, a5, 0x321DuLL);
}

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(unint64_t *result, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;

  v7 = *a3;
  if (!*a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a6, 0);
  v8 = *v6 / v7;
  *a2 = *v6 % v7;
  *result = v8;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt(_QWORD *a1)
{
  unint64_t *v1;
  unint64_t v2;

  v2 = *v1;
  if (*a1)
    v2 %= *a1;
  return v2 == 0;
}

void protocol witness for BinaryInteger.signum() in conformance UInt(_QWORD *a1@<X8>)
{
  _QWORD *v1;

  *a1 = *v1 != 0;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt and conformance UInt, a5);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, uint64_t a6@<X8>)
{
  uint64_t v9;
  unint64_t AssociatedTypeWitness;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  char v24;
  void (*v25)(char *, uint64_t, uint64_t);
  unint64_t AssociatedConformanceWitness;
  uint64_t v27;
  char v28;
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t (*v36)(uint64_t, _QWORD *);
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  char v48;
  unint64_t v49;
  char *v50;
  unint64_t v51;
  BOOL v52;
  void (*v53)(unint64_t *, uint64_t, uint64_t, uint64_t, _QWORD *);
  uint64_t v54;
  char *v55;
  char *v56;
  char *v57;
  unint64_t v58;
  uint64_t result;
  uint64_t v60;
  char *v61;
  uint64_t (*v62)(void);
  uint64_t v63;
  char *v64;
  uint64_t (*v65)(uint64_t, _QWORD *);
  void (*v66)(char *, uint64_t);
  void (*v67)(char *, uint64_t, uint64_t);
  char *v68;
  unint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;

  v62 = a5;
  v63 = a4;
  v70 = a6;
  v9 = *(_QWORD *)(a3[3] + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v9, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v11 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v13 = (char *)&v60 - v12;
  v14 = *(_QWORD *)(a2 - 8);
  v15 = MEMORY[0x1E0C80A78](v11);
  v61 = (char *)&v60 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = MEMORY[0x1E0C80A78](v15);
  v71 = (char *)&v60 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v60 - v20;
  MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v60 - v22;
  v65 = (uint64_t (*)(uint64_t, _QWORD *))a3[8];
  v24 = v65(a2, a3);
  v25 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  v72 = a1;
  v67 = v25;
  v25(v23, a1, a2);
  v64 = v21;
  v68 = v13;
  v69 = AssociatedTypeWitness;
  if ((v24 & 1) == 0)
  {
    v27 = v9;
    v66 = *(void (**)(char *, uint64_t))(v14 + 8);
    v66(v23, a2);
    v32 = v72;
    v34 = v14;
    v35 = a3;
    goto LABEL_6;
  }
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  v27 = v9;
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v13, a2, v9);
  v28 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(a3[4] + 8) + 16))(v23, v21, a2);
  v29 = *(void (**)(char *, uint64_t))(v14 + 8);
  v29(v21, a2);
  v29(v23, a2);
  if ((v28 & 1) == 0)
  {
    v34 = v14;
    v35 = a3;
    v66 = v29;
    v32 = v72;
LABEL_6:
    v36 = (uint64_t (*)(uint64_t, _QWORD *))v35[16];
    v37 = v36(a2, v35);
    v38 = v71;
    v67(v71, v32, a2);
    v39 = v27;
    v41 = v68;
    v40 = v69;
    if (v37 <= 63)
    {
      v29 = v66;
      v66(v38, a2);
      v33 = v70;
LABEL_8:
      v30 = ((uint64_t (*)(uint64_t, _QWORD *))v35[15])(a2, v35);
      v31 = 0;
      goto LABEL_19;
    }
    v73 = -1;
    v42 = v65(a2, v35);
    v43 = v36(a2, v35);
    if ((v42 & 1) != 0)
    {
      if (v43 < 65)
      {
        v44 = swift_getAssociatedConformanceWitness(v39, a2, v40, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        (*(void (**)(uint64_t *, uint64_t, uint64_t, unint64_t))(v44 + 8))(&qword_1816B7DA8, 256, v40, v44);
        v45 = v41;
        v46 = v64;
        (*(void (**)(char *, uint64_t, uint64_t))(v39 + 24))(v45, a2, v39);
        v47 = v71;
        v48 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35[4] + 8) + 40))(v71, v46, a2);
        v29 = v66;
        v66(v46, a2);
        v49 = v73;
        v50 = v61;
        (*(void (**)(char *, char *, uint64_t))(v34 + 32))(v61, v47, a2);
        if ((v48 & 1) == 0)
        {
          v29(v50, a2);
          v33 = v70;
          v32 = v72;
          goto LABEL_8;
        }
        v51 = ((uint64_t (*)(uint64_t, _QWORD *))v35[15])(a2, v35);
        v29(v50, a2);
        v52 = v49 >= v51;
LABEL_17:
        v33 = v70;
        v32 = v72;
        if (v52)
          goto LABEL_8;
        goto LABEL_18;
      }
    }
    else if (v43 < 65)
    {
      v57 = v64;
      (*(void (**)(char *, char *, uint64_t))(v34 + 32))(v64, v71, a2);
      v58 = ((uint64_t (*)(uint64_t, _QWORD *))v35[15])(a2, v35);
      v29 = v66;
      v66(v57, a2);
      v52 = v73 >= v58;
      goto LABEL_17;
    }
    v53 = (void (*)(unint64_t *, uint64_t, uint64_t, uint64_t, _QWORD *))v35[12];
    v54 = v62();
    v55 = v64;
    v53(&v73, v63, v54, a2, v35);
    v56 = v71;
    LOBYTE(v53) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35[4] + 8) + 16))(v55, v71, a2);
    v29 = v66;
    v66(v55, a2);
    v29(v56, a2);
    v33 = v70;
    v32 = v72;
    if ((v53 & 1) == 0)
      goto LABEL_8;
LABEL_18:
    v30 = 0;
    v31 = 1;
    goto LABEL_19;
  }
  v30 = 0;
  v31 = 1;
  v32 = v72;
  v33 = v70;
LABEL_19:
  result = ((uint64_t (*)(uint64_t, uint64_t))v29)(v32, a2);
  *(_QWORD *)v33 = v30;
  *(_BYTE *)(v33 + 8) = v31;
  return result;
}

unint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance UInt64@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  if (is_mul_ok(*result, *a2))
    *a3 = *result * *a2;
  else
    __break(1u);
  return result;
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt64(unint64_t *result, unint64_t *a2)
{
  if (is_mul_ok(*result, *a2))
    *result *= *a2;
  else
    __break(1u);
  return result;
}

uint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt64@<X0>(uint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;

  v3 = *result;
  v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    v5 = __CFADD__(v4, v3);
    v3 += v4;
    if (!v5)
      goto LABEL_7;
    __break(1u);
  }
  v6 = -(uint64_t)v3;
  v5 = v4 >= v6;
  v3 = v4 - v6;
  if (!v5)
  {
    __break(1u);
    return result;
  }
LABEL_7:
  *a2 = v3;
  return result;
}

unint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt64(uint64_t *a1, uint64_t a2, char a3, unint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  return specialized static Strideable<>._step(after:from:by:)(a1, a2, a3 & 1, *a4, *a5, *a6);
}

_QWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt64@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (__CFADD__(*result, *a2))
    __break(1u);
  else
    *a3 = *result + *a2;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt64(_QWORD *result, _QWORD *a2)
{
  if (__CFADD__(*result, *a2))
    __break(1u);
  else
    *result += *a2;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt64@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (*result < *a2)
    __break(1u);
  else
    *a3 = *result - *a2;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt64(_QWORD *result, _QWORD *a2)
{
  if (*result < *a2)
    __break(1u);
  else
    *result -= *a2;
  return result;
}

BOOL static UInt.<= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 >= a1;
}

BOOL static UInt.>= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 >= a2;
}

uint64_t UInt._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t Int._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.init(exactly:)(float _S0)
{
  float v6;

  __asm { FCVT            S1, H0 }
  v6 = _S0;
  _S0 = truncf(_S1);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }
  if ((~LODWORD(v6) & 0x7C00) == 0 || _S0 != _S1)
    return 0;
  else
    return (uint64_t)_S1;
}

Swift::Int_optional __swiftcall Int.init(exactly:)(Swift::Float exactly)
{
  BOOL v1;
  int v2;
  Swift::Int v3;
  char v4;
  Swift::Int_optional result;

  v1 = exactly > -9.2234e18;
  if (exactly >= 9.2234e18)
    v1 = 0;
  v2 = v1 & (truncf(exactly) == exactly);
  if (v2)
    v3 = (uint64_t)exactly;
  else
    v3 = 0;
  v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

uint64_t *static Int.*= infix(_:_:)(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result * a2;
  if ((unsigned __int128)(*result * (__int128)a2) >> 64 == v2 >> 63)
    *result = v2;
  else
    __break(1u);
  return result;
}

uint64_t *static Int./= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64./= infix(_:_:)(a1, a2, 0x3829uLL, 0x3830uLL);
}

uint64_t *static Int64./= infix(_:_:)(uint64_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  v4 = *result;
  if (a2 == -1 && v4 == 0x8000000000000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  *result = v4 / a2;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.addingReportingOverflow(_:)(Swift::Int a1)
{
  uint64_t v1;
  BOOL v2;
  Swift::Int v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_Int_overflow_Bool result;

  v2 = __OFADD__(v1, a1);
  v3 = v1 + a1;
  v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.subtractingReportingOverflow(_:)(Swift::Int a1)
{
  uint64_t v1;
  BOOL v2;
  Swift::Int v3;
  Swift::Bool v4;
  Swift::tuple_partialValue_Int_overflow_Bool result;

  v2 = __OFSUB__(v1, a1);
  v3 = v1 - a1;
  v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.dividedReportingOverflow(by:)(Swift::Int by)
{
  Swift::Int v1;
  Swift::Int v2;
  Swift::Bool v3;
  Swift::Int v4;
  Swift::tuple_partialValue_Int_overflow_Bool result;

  v2 = v1;
  if (by)
  {
    if (by == -1 && v1 == 0x8000000000000000)
    {
      v3 = 1;
      v4 = 0x8000000000000000;
    }
    else
    {
      v3 = 0;
      v4 = v2 / by;
    }
  }
  else
  {
    v3 = 1;
    v4 = v2;
  }
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.remainderReportingOverflow(dividingBy:)(Swift::Int dividingBy)
{
  Swift::Int v1;
  Swift::Int v2;
  Swift::Bool v3;
  Swift::Int v4;
  Swift::tuple_partialValue_Int_overflow_Bool result;

  v2 = v1;
  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 0x8000000000000000)
    {
      v3 = 1;
      v4 = 0;
    }
    else
    {
      v3 = 0;
      v4 = v2 % dividingBy;
    }
  }
  else
  {
    v3 = 1;
    v4 = v2;
  }
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

uint64_t *static Int.%= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64.%= infix(_:_:)(a1, a2, 0x390EuLL, 0x3913uLL);
}

uint64_t *static Int64.%= infix(_:_:)(uint64_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;

  if (!a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  v4 = *result;
  if (a2 == -1 && v4 == 0x8000000000000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  *result = v4 % a2;
  return result;
}

_QWORD *static Int.&= infix(_:_:)(_QWORD *result, uint64_t a2)
{
  *result &= a2;
  return result;
}

_QWORD *static Int.|= infix(_:_:)(_QWORD *result, uint64_t a2)
{
  *result |= a2;
  return result;
}

uint64_t *static Int.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  *result >>= a2;
  return result;
}

_QWORD *static Int.&<<= infix(_:_:)(_QWORD *result, char a2)
{
  *result <<= a2;
  return result;
}

uint64_t Int.Words._value.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.Words.count.getter()
{
  return 1;
}

uint64_t Int.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int.Words.index(after:)(Swift::Int after)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFADD__(after, 1);
  result = after + 1;
  if (v1)
    __break(1u);
  return result;
}

Swift::Int __swiftcall Int.Words.index(before:)(Swift::Int before)
{
  BOOL v1;
  Swift::Int result;

  v1 = __OFSUB__(before, 1);
  result = before - 1;
  if (v1)
    __break(1u);
  return result;
}

uint64_t Int.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x3A11uLL, 0x3A12uLL);
}

uint64_t UInt64.Words.subscript.getter(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a1 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  if (a1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t *v2;
  uint64_t v4;

  v4 = *v2;
  Int.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UInt64.Words@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  if ((*result & 0x8000000000000000) != 0 || (v3 = result[1], v3 >= 2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  v4 = *v2;
  *a2 = *result;
  a2[1] = v3;
  a2[2] = v4;
  return result;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance Int.Words()
{
  uint64_t *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int.Words(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySiqd__Isgyrzo_s13_UnsafeBitsetV4WordVABsAG_pAKRszr__lIetMgyrzo_Tpq5(a1, a2);
}

uint64_t Int64.multipliedFullWidth(by:)(uint64_t a1, uint64_t a2)
{
  return (unsigned __int128)(a2 * (__int128)a1) >> 64;
}

Swift::tuple_quotient_Int_remainder_Int __swiftcall Int.dividingFullWidth(_:)(Swift::tuple_high_Int_low_UInt a1)
{
  uint64_t v1;
  Swift::Int v2;
  Swift::Int v3;
  Swift::tuple_quotient_Int_remainder_Int result;

  v2 = Int64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x3A9EuLL, 0x3AAFuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t Int64.dividingFullWidth(_:)(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t result;
  uint64_t v7;

  if (!a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  result = __divti3();
  if (v7 != result >> 63)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  return result;
}

unint64_t Int.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  _BOOL8 v3;

  v3 = __OFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  _BOOL8 v3;

  v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  _BOOL8 v4;

  v3 = *v2 * *a2;
  v4 = (unsigned __int128)(*v2 * (__int128)*a2) >> 64 != v3 >> 63;
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int(int64_t *a1, uint64_t *a2)
{
  int64_t *v2;
  uint64_t v3;
  int64_t v4;
  uint64_t v6;

  v3 = *a2;
  v4 = *v2;
  if (*a2)
  {
    if (v3 == -1 && v4 == 0x8000000000000000)
    {
      v6 = 1;
      v4 = 0x8000000000000000;
    }
    else
    {
      v6 = 0;
      v4 /= v3;
    }
  }
  else
  {
    v6 = 1;
  }
  *a1 = v4;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v3 = *a2;
  v4 = *v2;
  if (!*a2)
    goto LABEL_9;
  if (v3 == -1 && v4 == 0x8000000000000000)
  {
    v4 = 0;
LABEL_9:
    v6 = 1;
    goto LABEL_7;
  }
  v6 = 0;
  v4 %= v3;
LABEL_7:
  *a1 = v4;
  return v6;
}

_QWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int64(_QWORD *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v3;
  uint64_t v4;

  v4 = *v3 * *a3;
  *result = (unsigned __int128)(*v3 * (__int128)*a3) >> 64;
  *a2 = v4;
  return result;
}

Swift::Int protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int(Swift::Int *a1, Swift::Int *a2, Swift::tuple_high_Int_low_UInt *a3)
{
  Swift::Int result;
  Swift::tuple_quotient_Int_remainder_Int v6;

  v6 = Int.dividingFullWidth(_:)(*a3);
  result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int()
{
  int8x8_t *v0;
  uint8x8_t v1;

  v1 = (uint8x8_t)vcnt_s8(*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int()
{
  unint64_t *v0;

  return __clz(*v0);
}

unint64_t *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int@<X0>(unint64_t *result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = bswap64(*result);
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int(_QWORD *a1@<X8>)
{
  unint64_t *v1;

  *a1 = bswap64(*v1);
}

uint64_t *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int@<X0>(uint64_t *result@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int(uint64_t *result, _QWORD *a2)
{
  *result >>= *a2;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *result << *a2;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int(_QWORD *result, _QWORD *a2)
{
  *result <<= *a2;
  return result;
}

_QWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_QWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_QWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_QWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int@<X0>(_QWORD *result@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  if (a2 >> 8 <= 0x40)
    *a3 = *result;
  else
    *a3 = 0;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int and conformance Int, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _QWORD *a6@<X8>)
{
  Class *v6;
  Class *v8;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t *TypeName;
  uint64_t v17;
  uint8x16_t *v18;
  int64_t v19;
  int64_t v20;
  int64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  Swift::String v26;
  uint64_t *v27;
  uint64_t v28;
  uint8x16_t *v29;
  int64_t v30;
  int64_t v31;
  int64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  Swift::String v37;
  char *v38;
  unint64_t v39;

  v8 = v6;
  v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((v39 & 1) != 0)
  {
    v38 = (char *)static String._createEmpty(withInitialCapacity:)(80);
    v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      v18 = (uint8x16_t *)TypeName;
      v19 = v17;
      v20 = validateUTF8(_:)(TypeName, v17);
      v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x8000000181762940;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        v29 = (uint8x16_t *)v27;
        v30 = v28;
        v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0)
          v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        else
          v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x8000000181762960;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int64@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char v28;
  void (*v29)(char *, char *, uint64_t);
  uint64_t v30;
  void (*v31)(char *, uint64_t);
  void (*v32)(char *, char *, uint64_t);
  char *v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t, uint64_t);
  char *v36;
  uint64_t v37;
  BOOL v38;
  uint64_t (*v39)(uint64_t, uint64_t);
  char v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char v44;
  char *v45;
  char *v46;
  char *v47;
  uint64_t v48;
  const char *v49;
  unint64_t AssociatedConformanceWitness;
  char *v51;
  char v52;
  char *v53;
  int64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char v58;
  uint64_t v59;
  void (*v60)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  int64_t *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char v65;
  uint64_t v66;
  uint64_t result;
  uint64_t v68;
  const char *v69;
  char *v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char *v75;
  uint64_t *v76;
  void (*v77)(char *, char *, uint64_t);
  uint64_t (*v78)(uint64_t, uint64_t);
  char *v79;
  uint64_t v80;
  int64_t v81;

  v72 = a4;
  v73 = a5;
  v76 = a6;
  v69 = *(const char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v69, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v68 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v70 = (char *)&v68 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v74 = (char *)&v68 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v68 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v75 = (char *)&v68 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v68 - v24;
  MEMORY[0x1E0C80A78](v23);
  v27 = (char *)&v68 - v26;
  v78 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v28 = v78(a2, a3);
  v29 = *(void (**)(char *, char *, uint64_t))(v13 + 16);
  v79 = a1;
  v77 = v29;
  v29(v27, a1, a2);
  if ((v28 & 1) != 0)
  {
    v71 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v30 = v71(a2, a3);
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    if (v30 > 64)
    {
      v32 = v77;
      v77(v25, v79, a2);
      v81 = 0x8000000000000000;
      v33 = v25;
      v34 = v78;
      if ((v78(a2, a3) & 1) != 0)
      {
        v35 = v71;
        if (v71(a2, a3) < 64)
        {
          v36 = v75;
          v32(v75, v33, a2);
          v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v36, a2);
          v38 = v37 < v81;
LABEL_18:
          v42 = v33;
LABEL_19:
          v46 = v79;
          if (!v38)
            goto LABEL_20;
          goto LABEL_39;
        }
        v45 = v75;
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v81, v72, v73, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v33, v45, a2);
        v31(v45, a2);
        v42 = v33;
        goto LABEL_11;
      }
      v40 = v34(a2, a3);
      v41 = v71(a2, a3);
      v42 = v33;
      if ((v40 & 1) != 0)
      {
        if (v41 <= 64)
        {
          v49 = v69;
          AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v69, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
          v51 = v75;
          (*((void (**)(char *, uint64_t, const char *))v49 + 3))(v12, a2, v49);
          v52 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v51, a2);
          v31(v51, a2);
          v53 = v70;
          v33 = v42;
          v32 = v77;
          v77(v70, v42, a2);
          if ((v52 & 1) != 0)
          {
            v31(v53, a2);
            goto LABEL_39;
          }
          v54 = v81;
          v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v31(v53, a2);
          v38 = v55 < v54;
          v35 = v71;
          goto LABEL_18;
        }
        v43 = v75;
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v81, v72, v73, a2, a3);
        v44 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v42, v43, a2);
        v31(v43, a2);
        v32 = v77;
        v35 = v71;
LABEL_11:
        v46 = v79;
        if ((v44 & 1) == 0)
        {
LABEL_20:
          v31(v42, a2);
          v39 = v78;
          goto LABEL_23;
        }
LABEL_39:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      }
      if (v41 < 64)
      {
        v47 = v75;
        v32 = v77;
        v77(v75, v42, a2);
        v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v31(v47, a2);
        v38 = v48 < v81;
        v35 = v71;
        goto LABEL_19;
      }
      v31(v33, a2);
    }
    v32 = v77;
    v39 = v78;
    v35 = v71;
  }
  else
  {
    v31 = *(void (**)(char *, uint64_t))(v13 + 8);
    v31(v27, a2);
    v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v32 = v77;
    v39 = v78;
  }
  v46 = v79;
LABEL_23:
  v56 = v35(a2, a3);
  v32(v20, v46, a2);
  if (v56 >= 65)
  {
    v31(v20, a2);
    goto LABEL_25;
  }
  v62 = v35(a2, a3);
  v31(v20, a2);
  if (v62 == 64 && (v39(a2, a3) & 1) == 0)
  {
LABEL_25:
    v57 = v74;
    v32(v74, v46, a2);
    v81 = 0x7FFFFFFFFFFFFFFFLL;
    v58 = v39(a2, a3);
    v59 = v35(a2, a3);
    if ((v58 & 1) != 0)
    {
      if (v59 > 64)
      {
        v60 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
        v61 = &v81;
        goto LABEL_34;
      }
    }
    else if (v59 > 63)
    {
      v80 = 0x7FFFFFFFFFFFFFFFLL;
      v60 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v61 = &v80;
LABEL_34:
      v64 = v75;
      v60(v61, v72, v73, a2, a3);
      v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v64, v57, a2);
      v31(v64, a2);
      if ((v65 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_35;
    }
    v63 = v75;
    v32(v75, v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v31(v63, a2);
LABEL_35:
    v31(v57, a2);
  }
  v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = ((uint64_t (*)(char *, uint64_t))v31)(v46, a2);
  *v76 = v66;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7;
  uint64_t result;

  v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type Int and conformance Int((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int()
{
  unint64_t *v0;

  if ((uint64_t)*v0 <= 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  return __clz(*v0) ^ 0x3F;
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int()
{
  unint64_t *v0;

  return __clz(__rbit64(*v0));
}

_QWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3;

  v3 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  if (*result == 0x8000000000000000 && v3 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  *a3 = *result / v3;
  return result;
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x3829uLL, 0x3830uLL);
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v7;

  v6 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  v7 = *result;
  if (v6 == -1 && v7 == 0x8000000000000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, a6, 0);
  *result = v7 / v6;
  return result;
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64(a1, a2, 0x390EuLL, 0x3913uLL, a3);
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X4>, unint64_t a4@<X5>, uint64_t *a5@<X8>)
{
  uint64_t v5;

  v5 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  if (*result == 0x8000000000000000 && v5 == -1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  *a5 = *result % v5;
  return result;
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x390EuLL, 0x3913uLL);
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v7;

  v6 = *a2;
  if (!*a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  v7 = *result;
  if (v6 == -1 && v7 == 0x8000000000000000)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a6, 0);
  *result = v7 % v6;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int(_QWORD *result, _QWORD *a2)
{
  *result &= *a2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int(_QWORD *result, _QWORD *a2)
{
  *result |= *a2;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int(_QWORD *result, _QWORD *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t (*v33)(_QWORD, _QWORD);
  uint64_t v34;
  uint64_t result;
  uint64_t v36;
  char v37;
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  char v40;
  char v41;
  uint64_t v42;
  BOOL v43;
  unint64_t v44;
  const char *v45;
  unint64_t AssociatedConformanceWitness;
  char *v47;
  void (*v48)(char *, uint64_t);
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  char v53;
  uint64_t v54;
  char v55;
  uint64_t (*v56)(char *, uint64_t);
  void (*v57)(void);
  char *v58;
  char v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t (*v63)(uint64_t, uint64_t);
  uint64_t v64;
  char *v65;
  char v66;
  uint64_t v67;
  char v68;
  uint64_t v69;
  void (**v70)(char *, uint64_t, const char *);
  unint64_t v71;
  unint64_t v72;
  char *v73;
  char *v74;
  int64_t v75;
  uint64_t v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  uint64_t v78;
  char *v79;
  char *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  unint64_t AssociatedTypeWitness;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  char *v97;
  uint64_t (*v98)(_QWORD, _QWORD);
  uint64_t v99;
  uint64_t *v100;
  uint64_t (*v101)(uint64_t, uint64_t);
  uint64_t v102;
  int64_t v103;

  v100 = a7;
  v93 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v93, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v13 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v91 = (char *)&v86 - v14;
  v15 = *(_QWORD *)(a3 - 8);
  v16 = MEMORY[0x1E0C80A78](v13);
  v18 = (char *)&v86 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v16);
  v89 = (char *)&v86 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v94 = (char *)&v86 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v95 = (char *)&v86 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v90 = (char *)&v86 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v96 = (char *)&v86 - v28;
  v29 = MEMORY[0x1E0C80A78](v27);
  v97 = (char *)&v86 - v30;
  MEMORY[0x1E0C80A78](v29);
  v32 = (char *)&v86 - v31;
  v99 = *a1;
  v33 = *(uint64_t (**)(_QWORD, _QWORD))(a4 + 64);
  if ((v33(a3, a4) & 1) == 0)
  {
    v88 = a5;
    v36 = a6;
    v98 = v33;
    v37 = v33(a3, a4);
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v38(a3, a4);
    v101 = v38;
    if ((v37 & 1) != 0)
    {
      if (v39 > 64)
      {
        v103 = -64;
        a6 = v36;
        a5 = v88;
        (*(void (**)(int64_t *))(a4 + 96))(&v103);
        v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v32, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
        v33 = v98;
        if ((v40 & 1) == 0)
          goto LABEL_20;
LABEL_19:
        v51 = 0;
        v52 = v100;
        goto LABEL_60;
      }
      v44 = AssociatedTypeWitness;
      v45 = v93;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v93, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v47 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v44, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v45 + 3))(v47, a3, v45);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v32, a3);
      v48 = *(void (**)(char *, uint64_t))(v15 + 8);
      v48(v32, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v18, a2, a3);
      if ((v44 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
        goto LABEL_19;
      }
      v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
      v43 = v50 < -64;
    }
    else
    {
      if (v39 >= 64)
      {
        a6 = v36;
        a5 = v88;
        v33 = v98;
        v49 = v98(a3, a4);
        goto LABEL_21;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
      v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
      v43 = v42 < -64;
    }
    a6 = v36;
    a5 = v88;
    v33 = v98;
    if (!v43)
      goto LABEL_20;
    goto LABEL_19;
  }
  v101 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  if (v101(a3, a4) >= 64)
  {
    v103 = -64;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v32, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
    if ((v41 & 1) == 0)
      goto LABEL_20;
    goto LABEL_19;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
  if (v34 < -64)
    goto LABEL_19;
LABEL_20:
  v49 = v33(a3, a4);
LABEL_21:
  v53 = v49;
  v54 = v101(a3, a4);
  v87 = a6;
  if ((v53 & 1) != 0)
  {
    if (v54 > 64)
      goto LABEL_23;
  }
  else if (v54 > 63)
  {
LABEL_23:
    v103 = 64;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    v55 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v32, a2, a3);
    v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
    result = v56(v32, a3);
    if ((v55 & 1) == 0)
      goto LABEL_24;
LABEL_31:
    v52 = v100;
    v51 = v99 >> 63;
    goto LABEL_60;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
  result = v56(v32, a3);
  if (v64 > 64)
    goto LABEL_31;
LABEL_24:
  v57 = *(void (**)(void))(v15 + 16);
  v58 = v97;
  v57();
  v98 = v33;
  v59 = v33(a3, a4);
  v60 = v96;
  ((void (*)(char *, char *, uint64_t))v57)(v96, v58, a3);
  if ((v59 & 1) != 0)
  {
    v61 = v101(a3, a4);
    v56(v60, a3);
    if (v61 <= 64)
      goto LABEL_44;
    v62 = v90;
    ((void (*)(char *, char *, uint64_t))v57)(v90, v58, a3);
    v103 = 0x8000000000000000;
    v63 = v98;
    if ((v98(a3, a4) & 1) != 0)
    {
      if (v101(a3, a4) < 64)
      {
LABEL_38:
        ((void (*)(char *, char *, uint64_t))v57)(v32, v62, a3);
        v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v56(v32, a3);
        if (v69 < v103)
LABEL_66:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_42;
      }
      goto LABEL_35;
    }
    v66 = v63(a3, a4);
    v67 = v101(a3, a4);
    if ((v66 & 1) != 0)
    {
      if (v67 > 64)
      {
LABEL_35:
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
        v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v62, v32, a3);
        v56(v32, a3);
        if ((v68 & 1) != 0)
          goto LABEL_66;
        goto LABEL_42;
      }
      v71 = AssociatedTypeWitness;
      v70 = (void (**)(char *, uint64_t, const char *))v93;
      v72 = swift_getAssociatedConformanceWitness((uint64_t)v93, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v73 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v72 + 8))(&qword_1816B7DA8, 256, v71, v72);
      v70[3](v73, a3, (const char *)v70);
      LOBYTE(v70) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v62, v32, a3);
      v56(v32, a3);
      v74 = v89;
      ((void (*)(char *, char *, uint64_t))v57)(v89, v62, a3);
      if ((v70 & 1) != 0)
      {
        v56(v74, a3);
        goto LABEL_66;
      }
      v75 = v103;
      v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v56(v74, a3);
      v43 = v76 < v75;
      v58 = v97;
      if (v43)
        goto LABEL_66;
    }
    else if (v67 < 64)
    {
      goto LABEL_38;
    }
LABEL_42:
    v65 = v62;
    goto LABEL_43;
  }
  v65 = v60;
LABEL_43:
  v56(v65, a3);
LABEL_44:
  v77 = v101;
  v78 = v101(a3, a4);
  v79 = v95;
  ((void (*)(char *, char *, uint64_t))v57)(v95, v58, a3);
  if (v78 < 65)
  {
    v83 = v77(a3, a4);
    v56(v79, a3);
    if (v83 != 64 || (v98(a3, a4) & 1) != 0)
      goto LABEL_57;
  }
  else
  {
    v56(v79, a3);
  }
  v80 = v94;
  ((void (*)(char *, char *, uint64_t))v57)(v94, v58, a3);
  v103 = 0x7FFFFFFFFFFFFFFFLL;
  v81 = v98(a3, a4);
  v82 = v101(a3, a4);
  if ((v81 & 1) != 0)
  {
    if (v82 > 64)
    {
      (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
      goto LABEL_55;
    }
  }
  else if (v82 > 63)
  {
    v102 = 0x7FFFFFFFFFFFFFFFLL;
    (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, a5, v87, a3, a4);
LABEL_55:
    v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v32, v80, a3);
    v56(v32, a3);
    if ((v84 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    goto LABEL_56;
  }
  ((void (*)(char *, char *, uint64_t))v57)(v32, v80, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v56(v32, a3);
LABEL_56:
  v56(v80, a3);
LABEL_57:
  v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v56(v58, a3);
  if ((v85 & 0x8000000000000000) != 0)
  {
    v52 = v100;
    if (v85 <= 0xFFFFFFFFFFFFFFC0)
      v51 = 0;
    else
      v51 = v99 << -(char)v85;
  }
  else
  {
    v52 = v100;
    if (v85 >= 0x40)
      v51 = v99 >> 63;
    else
      v51 = v99 >> v85;
  }
LABEL_60:
  *v52 = v51;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  char v33;
  uint64_t v34;
  char v35;
  uint64_t result;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  const char *v41;
  unint64_t AssociatedConformanceWitness;
  char *v43;
  void (*v44)(char *, uint64_t);
  char v45;
  uint64_t (*v46)(uint64_t, uint64_t);
  uint64_t v47;
  char v48;
  uint64_t (*v49)(char *, uint64_t);
  void (*v50)(char *, uint64_t, uint64_t);
  char *v51;
  char v52;
  char *v53;
  uint64_t v54;
  char *v55;
  uint64_t (*v56)(uint64_t, uint64_t);
  char *v57;
  char *v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  char v62;
  char v63;
  uint64_t v64;
  uint64_t *v65;
  void (**v66)(char *, uint64_t, const char *);
  unint64_t v67;
  unint64_t v68;
  char *v69;
  char *v70;
  char *v71;
  int64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t v75;
  char *v76;
  char *v77;
  char v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  char v82;
  unint64_t v83;
  uint64_t v84;
  char *v85;
  void (*v86)(char *, char *, uint64_t);
  char *v87;
  char *v88;
  char *v89;
  unint64_t AssociatedTypeWitness;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t (*v95)(uint64_t, uint64_t);
  char *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t (*v99)(uint64_t, uint64_t);
  uint64_t v100;
  int64_t v101;

  v97 = a5;
  v98 = a6;
  v91 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v91, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v89 = (char *)&v86 - v11;
  v12 = *(_QWORD *)(a3 - 8);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v86 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v87 = (char *)&v86 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v86 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v93 = (char *)&v86 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v88 = (char *)&v86 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v94 = (char *)&v86 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v96 = (char *)&v86 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v86 - v29;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v92 = v20;
  v99 = v31;
  if ((v32 & 1) != 0)
  {
    v95 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    if (v95(a3, a4) < 64)
    {
LABEL_10:
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
      v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      goto LABEL_11;
    }
    goto LABEL_6;
  }
  v33 = v31(a3, a4);
  v95 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v34 = v95(a3, a4);
  if ((v33 & 1) == 0)
  {
    if (v34 >= 64)
    {
      v37 = a1;
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  if (v34 > 64)
  {
LABEL_6:
    v101 = -64;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    v37 = a1;
    if ((v35 & 1) != 0)
      goto LABEL_12;
    goto LABEL_15;
  }
  v40 = AssociatedTypeWitness;
  v41 = v91;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v91, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v43 = v89;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v40, AssociatedConformanceWitness);
  (*((void (**)(char *, uint64_t, const char *))v41 + 3))(v43, a3, v41);
  LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
  v44 = *(void (**)(char *, uint64_t))(v12 + 8);
  v44(v30, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
  if ((v40 & 1) != 0)
  {
    result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
    v39 = 0;
    v37 = a1;
    goto LABEL_59;
  }
  v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
LABEL_11:
  v37 = a1;
  if (v38 < -64)
  {
LABEL_12:
    v39 = 0;
    goto LABEL_59;
  }
LABEL_15:
  v45 = v99(a3, a4);
  v46 = v95;
  v47 = v95(a3, a4);
  if ((v45 & 1) != 0)
  {
    if (v47 > 64)
      goto LABEL_17;
  }
  else if (v47 >= 64)
  {
LABEL_17:
    v101 = 64;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    v48 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
    v49 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    result = v49(v30, a3);
    if ((v48 & 1) == 0)
      goto LABEL_18;
LABEL_25:
    v39 = *v37 >> 63;
    goto LABEL_59;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
  v59 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v49 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  result = v49(v30, a3);
  if (v59 > 64)
    goto LABEL_25;
LABEL_18:
  v50 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v51 = v96;
  v50(v96, a2, a3);
  v52 = v99(a3, a4);
  v53 = v94;
  v86 = (void (*)(char *, char *, uint64_t))v50;
  v50(v94, (uint64_t)v51, a3);
  if ((v52 & 1) == 0)
  {
    v49(v53, a3);
    v55 = v96;
    v56 = v99;
    goto LABEL_43;
  }
  v54 = v46(a3, a4);
  v49(v53, a3);
  v55 = v96;
  v56 = v99;
  if (v54 <= 64)
    goto LABEL_43;
  v57 = v88;
  v86(v88, v96, a3);
  v101 = 0x8000000000000000;
  if ((v56(a3, a4) & 1) != 0)
  {
    if (v46(a3, a4) < 64)
    {
      v58 = v30;
      goto LABEL_37;
    }
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    v62 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v57, v30, a3);
    goto LABEL_32;
  }
  v60 = v56(a3, a4);
  v61 = v46(a3, a4);
  if ((v60 & 1) != 0)
  {
    if (v61 <= 64)
    {
      v65 = v37;
      v67 = AssociatedTypeWitness;
      v66 = (void (**)(char *, uint64_t, const char *))v91;
      v68 = swift_getAssociatedConformanceWitness((uint64_t)v91, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v69 = v89;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v68 + 8))(&qword_1816B7DA8, 256, v67, v68);
      v66[3](v69, a3, (const char *)v66);
      v70 = v88;
      LOBYTE(v66) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v88, v30, a3);
      v49(v30, a3);
      v71 = v87;
      v86(v87, v70, a3);
      if ((v66 & 1) != 0)
      {
        v49(v71, a3);
        goto LABEL_65;
      }
      v72 = v101;
      v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v49(v71, a3);
      v74 = v73 < v72;
      v37 = v65;
      v46 = v95;
      v55 = v96;
      v57 = v88;
      if (v74)
        goto LABEL_65;
LABEL_41:
      v85 = v57;
      goto LABEL_42;
    }
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
    v57 = v88;
    v62 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v88, v30, a3);
LABEL_32:
    v63 = v62;
    v49(v30, a3);
    if ((v63 & 1) != 0)
      goto LABEL_65;
    goto LABEL_41;
  }
  if (v61 < 64)
  {
    v58 = v30;
    v57 = v88;
LABEL_37:
    v86(v58, v57, a3);
    v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v49(v30, a3);
    if (v64 < v101)
LABEL_65:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_41;
  }
  v85 = v88;
LABEL_42:
  v49(v85, a3);
LABEL_43:
  v75 = v46(a3, a4);
  v76 = v93;
  v86(v93, v55, a3);
  if (v75 >= 65)
  {
    v49(v76, a3);
    goto LABEL_45;
  }
  v81 = v46(a3, a4);
  v49(v76, a3);
  if (v81 == 64 && (v56(a3, a4) & 1) == 0)
  {
LABEL_45:
    v77 = v92;
    v86(v92, v55, a3);
    v101 = 0x7FFFFFFFFFFFFFFFLL;
    v78 = v56(a3, a4);
    v79 = v77;
    LOBYTE(v77) = v78;
    v80 = v46(a3, a4);
    if ((v77 & 1) != 0)
    {
      if (v80 > 64)
      {
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v97, v98, a3, a4);
        goto LABEL_54;
      }
    }
    else if (v80 >= 64)
    {
      v100 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v100, v97, v98, a3, a4);
LABEL_54:
      v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v79, a3);
      v49(v30, a3);
      if ((v82 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_55;
    }
    v86(v30, v79, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v49(v30, a3);
LABEL_55:
    v49(v79, a3);
  }
  v83 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v49(v55, a3);
  v84 = *v37;
  if ((v83 & 0x8000000000000000) != 0)
  {
    if (v83 > 0xFFFFFFFFFFFFFFC0)
    {
      v39 = v84 << -(char)v83;
      goto LABEL_59;
    }
    goto LABEL_12;
  }
  if (v83 >= 0x40)
    v39 = v84 >> 63;
  else
    v39 = v84 >> v83;
LABEL_59:
  *v37 = v39;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t (*v33)(_QWORD, _QWORD);
  uint64_t v34;
  uint64_t result;
  uint64_t v36;
  char v37;
  uint64_t (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  char v40;
  char v41;
  uint64_t v42;
  BOOL v43;
  unint64_t v44;
  const char *v45;
  unint64_t AssociatedConformanceWitness;
  char *v47;
  void (*v48)(char *, uint64_t);
  char v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  char v55;
  uint64_t (*v56)(char *, uint64_t);
  void (*v57)(void);
  char *v58;
  char v59;
  char *v60;
  uint64_t v61;
  char *v62;
  uint64_t (*v63)(uint64_t, uint64_t);
  uint64_t v64;
  char *v65;
  char v66;
  uint64_t v67;
  char v68;
  uint64_t v69;
  void (**v70)(char *, uint64_t, const char *);
  unint64_t v71;
  unint64_t v72;
  char *v73;
  char *v74;
  int64_t v75;
  uint64_t v76;
  uint64_t (*v77)(uint64_t, uint64_t);
  uint64_t v78;
  char *v79;
  char *v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  unint64_t AssociatedTypeWitness;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  char *v97;
  uint64_t (*v98)(_QWORD, _QWORD);
  uint64_t v99;
  uint64_t *v100;
  uint64_t (*v101)(uint64_t, uint64_t);
  uint64_t v102;
  int64_t v103;

  v100 = a7;
  v93 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v93, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v13 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v91 = (char *)&v86 - v14;
  v15 = *(_QWORD *)(a3 - 8);
  v16 = MEMORY[0x1E0C80A78](v13);
  v18 = (char *)&v86 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v16);
  v89 = (char *)&v86 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v94 = (char *)&v86 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v95 = (char *)&v86 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v90 = (char *)&v86 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v96 = (char *)&v86 - v28;
  v29 = MEMORY[0x1E0C80A78](v27);
  v97 = (char *)&v86 - v30;
  MEMORY[0x1E0C80A78](v29);
  v32 = (char *)&v86 - v31;
  v99 = *a1;
  v33 = *(uint64_t (**)(_QWORD, _QWORD))(a4 + 64);
  if ((v33(a3, a4) & 1) == 0)
  {
    v88 = a5;
    v36 = a6;
    v98 = v33;
    v37 = v33(a3, a4);
    v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v39 = v38(a3, a4);
    v101 = v38;
    if ((v37 & 1) != 0)
    {
      if (v39 > 64)
      {
        v103 = -64;
        a6 = v36;
        a5 = v88;
        (*(void (**)(int64_t *))(a4 + 96))(&v103);
        v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v32, a3);
        result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
        v33 = v98;
        if ((v40 & 1) == 0)
          goto LABEL_20;
LABEL_19:
        v51 = v100;
        v52 = v99 >> 63;
        goto LABEL_60;
      }
      v44 = AssociatedTypeWitness;
      v45 = v93;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v93, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v47 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v44, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v45 + 3))(v47, a3, v45);
      LOBYTE(v44) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v32, a3);
      v48 = *(void (**)(char *, uint64_t))(v15 + 8);
      v48(v32, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v18, a2, a3);
      if ((v44 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
        goto LABEL_19;
      }
      v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v48)(v18, a3);
      v43 = v50 < -64;
    }
    else
    {
      if (v39 >= 64)
      {
        a6 = v36;
        a5 = v88;
        v33 = v98;
        v49 = v98(a3, a4);
        goto LABEL_21;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
      v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
      v43 = v42 < -64;
    }
    a6 = v36;
    a5 = v88;
    v33 = v98;
    if (!v43)
      goto LABEL_20;
    goto LABEL_19;
  }
  v101 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  if (v101(a3, a4) >= 64)
  {
    v103 = -64;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    v41 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v32, a3);
    result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
    if ((v41 & 1) == 0)
      goto LABEL_20;
    goto LABEL_19;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = (*(uint64_t (**)(char *, uint64_t))(v15 + 8))(v32, a3);
  if (v34 <= -65)
    goto LABEL_19;
LABEL_20:
  v49 = v33(a3, a4);
LABEL_21:
  v53 = v49;
  v54 = v101(a3, a4);
  v87 = a6;
  if ((v53 & 1) != 0)
  {
    if (v54 > 64)
      goto LABEL_23;
  }
  else if (v54 >= 64)
  {
LABEL_23:
    v103 = 64;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, a6, a3, a4);
    v55 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v32, a2, a3);
    v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
    result = v56(v32, a3);
    if ((v55 & 1) == 0)
      goto LABEL_24;
LABEL_31:
    v52 = 0;
    v51 = v100;
    goto LABEL_60;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v15 + 16))(v32, a2, a3);
  v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v56 = *(uint64_t (**)(char *, uint64_t))(v15 + 8);
  result = v56(v32, a3);
  if (v64 > 64)
    goto LABEL_31;
LABEL_24:
  v57 = *(void (**)(void))(v15 + 16);
  v58 = v97;
  v57();
  v98 = v33;
  v59 = v33(a3, a4);
  v60 = v96;
  ((void (*)(char *, char *, uint64_t))v57)(v96, v58, a3);
  if ((v59 & 1) != 0)
  {
    v61 = v101(a3, a4);
    v56(v60, a3);
    if (v61 <= 64)
      goto LABEL_44;
    v62 = v90;
    ((void (*)(char *, char *, uint64_t))v57)(v90, v58, a3);
    v103 = 0x8000000000000000;
    v63 = v98;
    if ((v98(a3, a4) & 1) != 0)
    {
      if (v101(a3, a4) < 64)
      {
LABEL_38:
        ((void (*)(char *, char *, uint64_t))v57)(v32, v62, a3);
        v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v56(v32, a3);
        if (v69 < v103)
LABEL_65:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_42;
      }
      goto LABEL_35;
    }
    v66 = v63(a3, a4);
    v67 = v101(a3, a4);
    if ((v66 & 1) != 0)
    {
      if (v67 > 64)
      {
LABEL_35:
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
        v68 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v62, v32, a3);
        v56(v32, a3);
        if ((v68 & 1) != 0)
          goto LABEL_65;
        goto LABEL_42;
      }
      v71 = AssociatedTypeWitness;
      v70 = (void (**)(char *, uint64_t, const char *))v93;
      v72 = swift_getAssociatedConformanceWitness((uint64_t)v93, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v73 = v91;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v72 + 8))(&qword_1816B7DA8, 256, v71, v72);
      v70[3](v73, a3, (const char *)v70);
      LOBYTE(v70) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v62, v32, a3);
      v56(v32, a3);
      v74 = v89;
      ((void (*)(char *, char *, uint64_t))v57)(v89, v62, a3);
      if ((v70 & 1) != 0)
      {
        v56(v74, a3);
        goto LABEL_65;
      }
      v75 = v103;
      v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v56(v74, a3);
      v43 = v76 < v75;
      v58 = v97;
      if (v43)
        goto LABEL_65;
    }
    else if (v67 < 64)
    {
      goto LABEL_38;
    }
LABEL_42:
    v65 = v62;
    goto LABEL_43;
  }
  v65 = v60;
LABEL_43:
  v56(v65, a3);
LABEL_44:
  v77 = v101;
  v78 = v101(a3, a4);
  v79 = v95;
  ((void (*)(char *, char *, uint64_t))v57)(v95, v58, a3);
  if (v78 >= 65)
  {
    v56(v79, a3);
    goto LABEL_46;
  }
  v83 = v77(a3, a4);
  v56(v79, a3);
  if (v83 == 64 && (v98(a3, a4) & 1) == 0)
  {
LABEL_46:
    v80 = v94;
    ((void (*)(char *, char *, uint64_t))v57)(v94, v58, a3);
    v103 = 0x7FFFFFFFFFFFFFFFLL;
    v81 = v98(a3, a4);
    v82 = v101(a3, a4);
    if ((v81 & 1) != 0)
    {
      if (v82 > 64)
      {
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v103, a5, v87, a3, a4);
        goto LABEL_55;
      }
    }
    else if (v82 >= 64)
    {
      v102 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, a5, v87, a3, a4);
LABEL_55:
      v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v32, v80, a3);
      v56(v32, a3);
      if ((v84 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_56;
    }
    ((void (*)(char *, char *, uint64_t))v57)(v32, v80, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v56(v32, a3);
LABEL_56:
    v56(v80, a3);
  }
  v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v56(v58, a3);
  if ((v85 & 0x8000000000000000) != 0)
  {
    v51 = v100;
    if (v85 <= 0xFFFFFFFFFFFFFFC0)
      v52 = v99 >> 63;
    else
      v52 = v99 >> -(char)v85;
  }
  else
  {
    v51 = v100;
    v52 = v99 << v85;
    if (v85 >= 0x40)
      v52 = 0;
  }
LABEL_60:
  *v51 = v52;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t v33;
  uint64_t result;
  uint64_t *v35;
  char v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  unint64_t v40;
  const char *v41;
  unint64_t AssociatedConformanceWitness;
  char *v43;
  void (*v44)(char *, uint64_t);
  uint64_t v45;
  char v46;
  uint64_t (*v47)(uint64_t, uint64_t);
  uint64_t v48;
  char v49;
  uint64_t (*v50)(char *, uint64_t);
  void (*v51)(char *, uint64_t, uint64_t);
  char *v52;
  char v53;
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t (*v57)(uint64_t, uint64_t);
  char *v58;
  char *v59;
  uint64_t v60;
  char v61;
  uint64_t v62;
  char v63;
  char v64;
  uint64_t v65;
  uint64_t *v66;
  void (**v67)(char *, uint64_t, const char *);
  unint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  int64_t v73;
  uint64_t v74;
  BOOL v75;
  uint64_t v76;
  char *v77;
  char *v78;
  char v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  char v83;
  unint64_t v84;
  uint64_t v85;
  char *v86;
  void (*v87)(char *, char *, uint64_t);
  char *v88;
  char *v89;
  char *v90;
  unint64_t AssociatedTypeWitness;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  uint64_t (*v96)(uint64_t, uint64_t);
  char *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t (*v100)(uint64_t, uint64_t);
  uint64_t v101;
  int64_t v102;

  v98 = a5;
  v99 = a6;
  v92 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v92, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v90 = (char *)&v87 - v11;
  v12 = *(_QWORD *)(a3 - 8);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v87 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v88 = (char *)&v87 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v87 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v94 = (char *)&v87 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v89 = (char *)&v87 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v95 = (char *)&v87 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v97 = (char *)&v87 - v28;
  MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v87 - v29;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v93 = v20;
  v100 = v31;
  if ((v32 & 1) == 0)
  {
    v36 = v31(a3, a4);
    v96 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v37 = v96(a3, a4);
    if ((v36 & 1) != 0)
    {
      if (v37 > 64)
        goto LABEL_7;
      v40 = AssociatedTypeWitness;
      v41 = v92;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v92, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v43 = v90;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v40, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v41 + 3))(v43, a3, v41);
      LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
      v44 = *(void (**)(char *, uint64_t))(v12 + 8);
      v44(v30, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
      if ((v40 & 1) != 0)
      {
        result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
        v35 = a1;
        v45 = *a1 >> 63;
        goto LABEL_60;
      }
      v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
    }
    else
    {
      if (v37 >= 64)
      {
        v35 = a1;
        goto LABEL_17;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
      v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    }
    v35 = a1;
    if (v39 >= -64)
      goto LABEL_17;
    goto LABEL_16;
  }
  v96 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  if (v96(a3, a4) < 64)
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
    v33 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    v35 = a1;
    if (v33 > -65)
      goto LABEL_17;
LABEL_16:
    v45 = *v35 >> 63;
    goto LABEL_60;
  }
LABEL_7:
  v102 = -64;
  (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
  v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v30, a3);
  result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
  v35 = a1;
  if ((v38 & 1) != 0)
    goto LABEL_16;
LABEL_17:
  v46 = v100(a3, a4);
  v47 = v96;
  v48 = v96(a3, a4);
  if ((v46 & 1) != 0)
  {
    if (v48 > 64)
      goto LABEL_19;
  }
  else if (v48 >= 64)
  {
LABEL_19:
    v102 = 64;
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
    v49 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, a2, a3);
    v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    result = v50(v30, a3);
    if ((v49 & 1) == 0)
      goto LABEL_20;
LABEL_27:
    v45 = 0;
    goto LABEL_60;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v30, a2, a3);
  v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  result = v50(v30, a3);
  if (v60 > 64)
    goto LABEL_27;
LABEL_20:
  v51 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v52 = v97;
  v51(v97, a2, a3);
  v53 = v100(a3, a4);
  v54 = v95;
  v87 = (void (*)(char *, char *, uint64_t))v51;
  v51(v95, (uint64_t)v52, a3);
  if ((v53 & 1) == 0)
  {
    v50(v54, a3);
    v56 = v97;
    v57 = v100;
    goto LABEL_44;
  }
  v55 = v47(a3, a4);
  v50(v54, a3);
  v56 = v97;
  v57 = v100;
  if (v55 <= 64)
    goto LABEL_44;
  v58 = v89;
  v87(v89, v97, a3);
  v102 = 0x8000000000000000;
  if ((v57(a3, a4) & 1) != 0)
  {
    if (v47(a3, a4) < 64)
    {
      v59 = v30;
      goto LABEL_38;
    }
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
    v63 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v58, v30, a3);
    goto LABEL_33;
  }
  v61 = v57(a3, a4);
  v62 = v47(a3, a4);
  if ((v61 & 1) != 0)
  {
    if (v62 <= 64)
    {
      v66 = v35;
      v68 = AssociatedTypeWitness;
      v67 = (void (**)(char *, uint64_t, const char *))v92;
      v69 = swift_getAssociatedConformanceWitness((uint64_t)v92, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v70 = v90;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v69 + 8))(&qword_1816B7DA8, 256, v68, v69);
      v67[3](v70, a3, (const char *)v67);
      v71 = v89;
      LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v89, v30, a3);
      v50(v30, a3);
      v72 = v88;
      v87(v88, v71, a3);
      if ((v67 & 1) != 0)
      {
        v50(v72, a3);
        goto LABEL_65;
      }
      v73 = v102;
      v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v50(v72, a3);
      v75 = v74 < v73;
      v35 = v66;
      v47 = v96;
      v56 = v97;
      v58 = v89;
      if (v75)
        goto LABEL_65;
LABEL_42:
      v86 = v58;
      goto LABEL_43;
    }
    (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
    v58 = v89;
    v63 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v89, v30, a3);
LABEL_33:
    v64 = v63;
    v50(v30, a3);
    if ((v64 & 1) != 0)
      goto LABEL_65;
    goto LABEL_42;
  }
  if (v62 < 64)
  {
    v59 = v30;
    v58 = v89;
LABEL_38:
    v87(v59, v58, a3);
    v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v50(v30, a3);
    if (v65 < v102)
LABEL_65:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_42;
  }
  v86 = v89;
LABEL_43:
  v50(v86, a3);
LABEL_44:
  v76 = v47(a3, a4);
  v77 = v94;
  v87(v94, v56, a3);
  if (v76 >= 65)
  {
    v50(v77, a3);
    goto LABEL_46;
  }
  v82 = v47(a3, a4);
  v50(v77, a3);
  if (v82 == 64 && (v57(a3, a4) & 1) == 0)
  {
LABEL_46:
    v78 = v93;
    v87(v93, v56, a3);
    v102 = 0x7FFFFFFFFFFFFFFFLL;
    v79 = v57(a3, a4);
    v80 = v78;
    LOBYTE(v78) = v79;
    v81 = v47(a3, a4);
    if ((v78 & 1) != 0)
    {
      if (v81 > 64)
      {
        (*(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v102, v98, v99, a3, a4);
        goto LABEL_55;
      }
    }
    else if (v81 >= 64)
    {
      v101 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v101, v98, v99, a3, a4);
LABEL_55:
      v83 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v30, v80, a3);
      v50(v30, a3);
      if ((v83 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_56;
    }
    v87(v30, v80, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v50(v30, a3);
LABEL_56:
    v50(v80, a3);
  }
  v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  result = v50(v56, a3);
  v85 = *v35;
  if ((v84 & 0x8000000000000000) != 0)
  {
    if (v84 <= 0xFFFFFFFFFFFFFFC0)
      v45 = v85 >> 63;
    else
      v45 = v85 >> -(char)v84;
  }
  else
  {
    v45 = v85 << v84;
    if (v84 >= 0x40)
      v45 = 0;
  }
LABEL_60:
  *v35 = v45;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v3;
  uint64_t result;

  result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3, 0x3829uLL, 0x3830uLL);
  *a1 = result;
  return result;
}

uint64_t protocol witness for BinaryInteger.isMultiple(of:) in conformance Int(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;

  v2 = *a1;
  if (*a1 == -1)
    return 1;
  v3 = *v1;
  if (v2)
    return v3 % v2 == 0;
  else
    return v3 == 0;
}

void protocol witness for BinaryInteger.signum() in conformance Int(unint64_t *a1@<X8>)
{
  uint64_t *v1;

  *a1 = (*v1 > 0) | (unint64_t)(*v1 >> 63);
}

_QWORD *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  if (__OFSUB__(0, *result))
    __break(1u);
  else
    *a2 = -*result;
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int()
{
  _QWORD *v0;

  if (__OFSUB__(0, *v0))
    __break(1u);
  else
    *v0 = -*v0;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int and conformance Int, a5);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, uint64_t a6@<X8>)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  char v30;
  void (*v31)(char *, uint64_t, uint64_t);
  _BOOL4 v32;
  void (*v33)(char *, uint64_t);
  uint64_t (*v34)(uint64_t, uint64_t);
  uint64_t (*v35)(uint64_t, uint64_t);
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  char v44;
  uint64_t v45;
  void (*v46)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v47;
  char *v48;
  char v49;
  char *v50;
  char v51;
  uint64_t v52;
  void (*v53)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v54;
  char *v55;
  char *v56;
  char *v57;
  uint64_t v58;
  char v59;
  void (*v60)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v61;
  char *v62;
  uint64_t v63;
  BOOL v64;
  char *v65;
  uint64_t v66;
  void (*v67)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v68;
  char *v69;
  void (**v70)(char *, uint64_t, const char *);
  unint64_t AssociatedConformanceWitness;
  char *v72;
  char *v73;
  int64_t v74;
  uint64_t v75;
  uint64_t result;
  uint64_t (*v77)(uint64_t, uint64_t);
  char *v78;
  char *v79;
  char *v80;
  uint64_t (*v81)(void);
  uint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  uint64_t (*v86)(uint64_t, uint64_t);
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int64_t v90;

  v81 = a5;
  v82 = a4;
  v85 = a6;
  v78 = *(char **)(*(_QWORD *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v78, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v77 - v11;
  v13 = *(_QWORD *)(a2 - 8);
  v14 = MEMORY[0x1E0C80A78](v10);
  v79 = (char *)&v77 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v80 = (char *)&v77 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v84 = (char *)&v77 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v77 - v21;
  v23 = MEMORY[0x1E0C80A78](v20);
  v83 = (char *)&v77 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v27 = (char *)&v77 - v26;
  MEMORY[0x1E0C80A78](v25);
  v29 = (char *)&v77 - v28;
  v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v30 = v86(a2, a3);
  v87 = v13;
  v88 = a1;
  v31 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v31(v29, a1, a2);
  v32 = (v30 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  v33 = *(void (**)(char *, uint64_t))(v87 + 8);
  v33(v29, a2);
  v31(v27, v88, a2);
  if (!v32)
  {
    v33(v27, a2);
    v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v37 = v88;
LABEL_10:
    v38 = v35(a2, a3);
    goto LABEL_11;
  }
  v90 = 0x8000000000000000;
  v34 = v86;
  if ((v86(a2, a3) & 1) != 0)
  {
    v35 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    if (v35(a2, a3) >= 64)
    {
      v60 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v61 = v81();
      v62 = v83;
      v60(&v90, v82, v61, a2, a3);
      LOBYTE(v60) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v27, v62, a2);
      v33(v62, a2);
      v33(v27, a2);
      v37 = v88;
      if ((v60 & 1) != 0)
        goto LABEL_41;
    }
    else
    {
      v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v33(v27, a2);
      v37 = v88;
      if (v36 < v90)
        goto LABEL_41;
    }
    goto LABEL_10;
  }
  v51 = v34(a2, a3);
  v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v52 = v77(a2, a3);
  if ((v51 & 1) != 0)
  {
    if (v52 > 64)
    {
      v53 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v54 = v81();
      v55 = v83;
      v53(&v90, v82, v54, a2, a3);
      LOBYTE(v53) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v27, v55, a2);
      v33(v55, a2);
      v33(v27, a2);
      v37 = v88;
      v35 = v77;
      if ((v53 & 1) != 0)
        goto LABEL_41;
      goto LABEL_10;
    }
    v70 = (void (**)(char *, uint64_t, const char *))v78;
    AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v78, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
    v72 = v83;
    v70[3](v12, a2, (const char *)v70);
    LOBYTE(v70) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v27, v72, a2);
    v33(v72, a2);
    v73 = v79;
    (*(void (**)(char *, char *, uint64_t))(v87 + 32))(v79, v27, a2);
    if ((v70 & 1) != 0)
    {
      v33(v73, a2);
      v58 = 0;
      v59 = 1;
      v41 = v85;
      v37 = v88;
      goto LABEL_42;
    }
    v74 = v90;
    v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v33(v73, a2);
    v64 = v75 < v74;
LABEL_39:
    v37 = v88;
    v35 = v77;
    if (v64)
    {
LABEL_41:
      v58 = 0;
      v59 = 1;
      v41 = v85;
      goto LABEL_42;
    }
    goto LABEL_10;
  }
  if (v52 < 64)
  {
    v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v33(v27, a2);
    v64 = v63 < v90;
    goto LABEL_39;
  }
  v33(v27, a2);
  v37 = v88;
  v35 = v77;
  v38 = v77(a2, a3);
LABEL_11:
  v39 = v38;
  v31(v22, v37, a2);
  if (v39 >= 65)
  {
    v33(v22, a2);
    v40 = v84;
    v31(v84, v37, a2);
    v41 = v85;
    goto LABEL_15;
  }
  v42 = v35(a2, a3);
  v33(v22, a2);
  if (v42 != 64)
  {
    v40 = v84;
    v31(v84, v37, a2);
    v41 = v85;
    goto LABEL_25;
  }
  v43 = v86(a2, a3);
  v40 = v84;
  v31(v84, v37, a2);
  v41 = v85;
  if ((v43 & 1) != 0)
  {
LABEL_25:
    v57 = v40;
    goto LABEL_26;
  }
LABEL_15:
  v90 = 0x7FFFFFFFFFFFFFFFLL;
  v44 = v86(a2, a3);
  v45 = v35(a2, a3);
  if ((v44 & 1) != 0)
  {
    if (v45 > 64)
    {
      v46 = *(void (**)(int64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v47 = v81();
      v48 = v83;
      v46(&v90, v82, v47, a2, a3);
      v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v48, v40, a2);
      v33(v48, a2);
      v50 = v40;
      goto LABEL_34;
    }
    goto LABEL_23;
  }
  if (v45 <= 63)
  {
LABEL_23:
    v56 = v83;
    (*(void (**)(char *, char *, uint64_t))(v87 + 32))(v83, v40, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v57 = v56;
LABEL_26:
    v33(v57, a2);
    goto LABEL_27;
  }
  v89 = 0x7FFFFFFFFFFFFFFFLL;
  v65 = v83;
  v66 = (*(uint64_t (**)(char *, char *, uint64_t))(v87 + 32))(v83, v40, a2);
  v67 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
  v68 = ((uint64_t (*)(uint64_t))v81)(v66);
  v69 = v80;
  v67(&v89, v82, v68, a2, a3);
  v49 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v69, v65, a2);
  v33(v69, a2);
  v50 = v65;
LABEL_34:
  v33(v50, a2);
  if ((v49 & 1) != 0)
  {
    v58 = 0;
    v59 = 1;
    goto LABEL_42;
  }
LABEL_27:
  v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v59 = 0;
LABEL_42:
  result = ((uint64_t (*)(uint64_t, uint64_t))v33)(v37, a2);
  *(_QWORD *)v41 = v58;
  *(_BYTE *)(v41 + 8) = v59;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int(uint64_t *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v2;

  v2 = *v1;
  if (*v1 < 0)
    v2 = -v2;
  *a1 = v2;
}

uint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance Int64@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3;

  v3 = *result * *a2;
  if ((unsigned __int128)(*result * (__int128)*a2) >> 64 == v3 >> 63)
    *a3 = v3;
  else
    __break(1u);
  return result;
}

uint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance Int64(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *result * *a2;
  if ((unsigned __int128)(*result * (__int128)*a2) >> 64 == v2 >> 63)
    *result = v2;
  else
    __break(1u);
  return result;
}

_QWORD *protocol witness for Strideable.distance(to:) in conformance Int@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v2;

  if (__OFSUB__(*result, *v2))
    __break(1u);
  else
    *a2 = *result - *v2;
  return result;
}

unint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int64(int64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, _QWORD *a6)
{
  int64_t v6;
  unint64_t v7;

  v6 = *a4 + *a6;
  v7 = 0x8000000000000000;
  if (__OFADD__(*a4, *a6))
    v6 = (v6 >> 63) ^ 0x8000000000000000;
  else
    v7 = 0;
  *a1 = v6;
  return v7;
}

_QWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int64@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (__OFADD__(*result, *a2))
    __break(1u);
  else
    *a3 = *result + *a2;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int64(_QWORD *result, _QWORD *a2)
{
  if (__OFADD__(*result, *a2))
    __break(1u);
  else
    *result += *a2;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int64@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2))
    __break(1u);
  else
    *a3 = *result - *a2;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int64(_QWORD *result, _QWORD *a2)
{
  if (__OFSUB__(*result, *a2))
    __break(1u);
  else
    *result -= *a2;
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int(_QWORD *a1, _QWORD *a2)
{
  return *a1 < *a2;
}

void Int.hash(into:)(int a1, Swift::UInt a2)
{
  Hasher._combine(_:)(a2);
}

uint64_t type metadata accessor for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for IndexingIterator);
}

uint64_t type metadata accessor for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for EnumeratedSequence.Iterator);
}

uint64_t type metadata accessor for Optional(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Optional, &flag for loading of canonical specialized generic type metadata for Optional);
}

uint64_t Int._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int@<X0>(_QWORD *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t result;

  v3 = *v1;
  result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

Swift::Int __swiftcall _unsafePlus(_:_:)(Swift::Int a1, Swift::Int a2)
{
  return a2 + a1;
}

Swift::Int __swiftcall _unsafeMinus(_:_:)(Swift::Int a1, Swift::Int a2)
{
  return a1 - a2;
}

uint64_t _IntegerAnyHashableBox._canonicalBox.getter@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t, uint64_t);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  void (*v24)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v25;
  void (*v26)(char *, uint64_t);
  uint64_t v27;
  unint64_t AssociatedConformanceWitness;
  char v29;
  uint64_t v30;
  void (*v31)(char *, char *, uint64_t);
  char *v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t result;
  uint64_t v37;
  char *v38;
  void (*v39)(char *, uint64_t, uint64_t);
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;

  v41 = a2;
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v5, v3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v9 = (char *)&v38 - v8;
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v38 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v38 - v14;
  MEMORY[0x1E0C80A78](v13);
  v17 = (char *)&v38 - v16;
  v42 = v18;
  v39 = *(void (**)(char *, uint64_t, uint64_t))(v18 + 16);
  v40 = v2;
  v39((char *)&v38 - v16, v2, v3);
  v19 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  if ((v19(v3, v4) & 1) != 0)
  {
    v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 128))(v3, v4);
    if (v20 < 64)
    {
LABEL_10:
      v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
      v26 = *(void (**)(char *, uint64_t))(v42 + 8);
      v26(v17, v3);
      if (v27 < 0)
        goto LABEL_14;
      goto LABEL_16;
    }
  }
  else
  {
    v38 = v12;
    v23 = v19(v3, v4);
    v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 128))(v3, v4);
    if ((v23 & 1) == 0)
    {
      if (v20 < 64)
        goto LABEL_10;
      v26 = *(void (**)(char *, uint64_t))(v42 + 8);
      v26(v17, v3);
LABEL_16:
      v34 = v41;
      goto LABEL_17;
    }
    if (v20 <= 64)
    {
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      (*(void (**)(char *, uint64_t, uint64_t))(v5 + 24))(v9, v3, v5);
      v29 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 16))(v17, v15, v3);
      v30 = v42;
      v26 = *(void (**)(char *, uint64_t))(v42 + 8);
      v26(v15, v3);
      v31 = *(void (**)(char *, char *, uint64_t))(v30 + 32);
      v32 = v38;
      v31(v38, v17, v3);
      if ((v29 & 1) == 0)
      {
        v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
        v26(v32, v3);
        v34 = v41;
        if (v37 < 0)
        {
          v33 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
          goto LABEL_15;
        }
LABEL_17:
        v33 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
        v39(v15, v40, v3);
        goto LABEL_18;
      }
      v26(v32, v3);
      goto LABEL_14;
    }
  }
  v43 = 0;
  v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
  v25 = lazy protocol witness table accessor for type Int and conformance Int(v20, v21, v22);
  v24(&v43, &type metadata for Int, v25, v3, v4);
  LOBYTE(v24) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 16))(v17, v15, v3);
  v26 = *(void (**)(char *, uint64_t))(v42 + 8);
  v26(v15, v3);
  v26(v17, v3);
  if ((v24 & 1) == 0)
    goto LABEL_16;
LABEL_14:
  v33 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
  v34 = v41;
LABEL_15:
  v39(v15, v40, v3);
LABEL_18:
  v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
  v26(v15, v3);
  result = __swift_instantiateConcreteTypeFromMangledName(v33);
  v34[3] = result;
  v34[4] = (uint64_t)&protocol witness table for _IntegerAnyHashableBox<A>;
  *v34 = v35;
  return result;
}

uint64_t _IntegerAnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  ValueMetadata *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  Class *v25;
  Class *v26;
  uint64_t v27;
  uint64_t (*v28)(ValueMetadata *, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  Class *v32;
  Class *v33;
  uint64_t v34;
  void (**v35)(char *, _QWORD, ValueMetadata *);
  uint64_t (*v36)(ValueMetadata *, uint64_t);
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  unint64_t AssociatedConformanceWitness;
  char *v43;
  char *v44;
  char v45;
  void (*v46)(char *, ValueMetadata *);
  uint64_t v47;
  char v49;
  void (*v50)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t);
  unint64_t v51;
  ValueMetadata *v52;
  char *v53;
  char v54;
  void (*v55)(char *, ValueMetadata *);
  char *v56;
  BOOL v57;
  uint64_t v58;
  char v59;
  void (*v60)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t);
  unint64_t v61;
  char *v62;
  const char *v63;
  unint64_t v64;
  char *v65;
  char *v66;
  char v67;
  void (**v68)(char *, _QWORD, ValueMetadata *);
  void (*v69)(char *, ValueMetadata *);
  BOOL v70;
  void (**v71)(char *, _QWORD, ValueMetadata *);
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void (*v75)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t);
  unint64_t v76;
  char *v77;
  char *v78;
  const char *v79;
  char *v80;
  void (**Description)(char *, _QWORD, ValueMetadata *);
  uint64_t v82;
  uint64_t v83[5];

  v4 = *(ValueMetadata **)(a2 + 16);
  v5 = *(_QWORD *)(*(_QWORD *)(a2 + 24) + 8);
  v79 = *(const char **)(*(_QWORD *)(v5 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v79, (uint64_t)v4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v78 = (char *)&v78 - v8;
  Description = (void (**)(char *, _QWORD, ValueMetadata *))v4[-1].Description;
  v9 = MEMORY[0x1E0C80A78](v7);
  v11 = (char *)&v78 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v78 - v13;
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v78 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v78 - v19;
  v21 = MEMORY[0x1E0C80A78](v18);
  v80 = (char *)&v78 - v22;
  MEMORY[0x1E0C80A78](v21);
  v24 = (char *)&v78 - v23;
  if (v4 == &type metadata for UInt64)
  {
    outlined init with copy of MirrorPath(a1, (uint64_t)v83);
    v32 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
    v33 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
    if (!swift_dynamicCast((char *)&v82, v83, v32, v33, 6uLL))
      return 2;
    v35 = Description;
    v34 = v82;
    Description[2](v24, v2, &type metadata for UInt64);
    v36 = *(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 64);
    if ((v36(&type metadata for UInt64, v5) & 1) != 0)
    {
      v37 = v36(&type metadata for UInt64, v5);
      v38 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for UInt64, v5);
      if ((v37 & 1) != 0)
      {
        if (v38 <= 64)
        {
          v41 = v79;
          AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v79, (uint64_t)&type metadata for UInt64, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v43 = v78;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
          v44 = v80;
          (*((void (**)(char *, ValueMetadata *, const char *))v41 + 3))(v43, &type metadata for UInt64, v41);
          v45 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8)
                                                                           + 32))(v24, v44, &type metadata for UInt64);
          v46 = (void (*)(char *, ValueMetadata *))v35[1];
          v46(v44, &type metadata for UInt64);
          ((void (**)(char *, char *, ValueMetadata *))v35)[4](v20, v24, &type metadata for UInt64);
          if ((v45 & 1) == 0)
          {
            v46(v20, &type metadata for UInt64);
            return 0;
          }
          v47 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for UInt64, v5);
          v46(v20, &type metadata for UInt64);
LABEL_19:
          v57 = v47 == v34;
LABEL_23:
          v59 = v57;
          return v59 & 1;
        }
LABEL_28:
        v83[0] = v34;
        v60 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
        v61 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v38, v39, v40);
        v52 = &type metadata for UInt64;
        v62 = v80;
        v60(v83, &type metadata for UInt64, v61, &type metadata for UInt64, v5);
        v54 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(_QWORD *)(*(_QWORD *)(v5 + 16) + 8) + 8))(v24, v62, &type metadata for UInt64);
        v55 = (void (*)(char *, ValueMetadata *))v35[1];
        v55(v62, &type metadata for UInt64);
        v56 = v24;
        goto LABEL_33;
      }
      if (v38 >= 64)
        goto LABEL_28;
    }
    else
    {
      v38 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for UInt64, v5);
      if (v38 >= 64)
        goto LABEL_28;
    }
    v47 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for UInt64, v5);
    ((void (*)(char *, ValueMetadata *))v35[1])(v24, &type metadata for UInt64);
    goto LABEL_19;
  }
  if (v4 != &type metadata for Int64)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "self isn't canonical", 20, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3CF6uLL, 0);
  outlined init with copy of MirrorPath(a1, (uint64_t)v83);
  v25 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  v26 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  if (!swift_dynamicCast((char *)&v82, v83, v25, v26, 6uLL))
    return 2;
  v27 = v82;
  Description[2](v17, v2, &type metadata for Int64);
  v28 = *(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 64);
  if ((v28(&type metadata for Int64, v5) & 1) != 0)
  {
    v29 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for Int64, v5);
    if (v29 < 64)
      goto LABEL_22;
    goto LABEL_16;
  }
  v49 = v28(&type metadata for Int64, v5);
  v29 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for Int64, v5);
  if ((v49 & 1) == 0)
  {
    if (v29 < 64)
    {
LABEL_22:
      v58 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for Int64, v5);
      ((void (*)(char *, ValueMetadata *))Description[1])(v17, &type metadata for Int64);
      v57 = v58 == v27;
      goto LABEL_23;
    }
    v71 = Description;
    v72 = ((uint64_t (*)(char *, char *, ValueMetadata *))Description[4])(v11, v17, &type metadata for Int64);
    if ((v27 & 0x8000000000000000) == 0)
    {
      v83[0] = v27;
      v75 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
      v76 = lazy protocol witness table accessor for type Int64 and conformance Int64(v72, v73, v74);
      v52 = &type metadata for Int64;
      v77 = v80;
      v75(v83, &type metadata for Int64, v76, &type metadata for Int64, v5);
      v54 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(_QWORD *)(*(_QWORD *)(v5 + 16) + 8) + 8))(v11, v77, &type metadata for Int64);
      v55 = (void (*)(char *, ValueMetadata *))v71[1];
      v55(v77, &type metadata for Int64);
      v56 = v11;
      goto LABEL_33;
    }
    ((void (*)(char *, ValueMetadata *))v71[1])(v11, &type metadata for Int64);
    return 0;
  }
  if (v29 > 64)
  {
LABEL_16:
    v83[0] = v27;
    v50 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
    v51 = lazy protocol witness table accessor for type Int64 and conformance Int64(v29, v30, v31);
    v52 = &type metadata for Int64;
    v53 = v80;
    v50(v83, &type metadata for Int64, v51, &type metadata for Int64, v5);
    v54 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(_QWORD *)(*(_QWORD *)(v5 + 16) + 8) + 8))(v17, v53, &type metadata for Int64);
    v55 = (void (*)(char *, ValueMetadata *))Description[1];
    v55(v53, &type metadata for Int64);
    v56 = v17;
LABEL_33:
    v55(v56, v52);
    return v54 & 1;
  }
  v63 = v79;
  v64 = swift_getAssociatedConformanceWitness((uint64_t)v79, (uint64_t)&type metadata for Int64, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v65 = v78;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v64 + 8))(&qword_1816B7DA8, 256, AssociatedTypeWitness, v64);
  v66 = v80;
  (*((void (**)(char *, ValueMetadata *, const char *))v63 + 3))(v65, &type metadata for Int64, v63);
  v67 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 32))(v17, v66, &type metadata for Int64);
  v68 = Description;
  v69 = (void (*)(char *, ValueMetadata *))Description[1];
  v69(v66, &type metadata for Int64);
  ((void (**)(char *, char *, ValueMetadata *))v68)[4](v14, v17, &type metadata for Int64);
  v70 = (v67 & 1) != 0
     && (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for Int64, v5) == v27;
  v69(v14, &type metadata for Int64);
  return v70;
}

uint64_t _IntegerAnyHashableBox._hashValue.getter(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8) + 16) + 16))(*(_QWORD *)(a1 + 16));
}

uint64_t _IntegerAnyHashableBox._hash(into:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 24) + 8) + 16) + 24))(a1, *(_QWORD *)(a2 + 16));
}

Swift::Int __swiftcall _IntegerAnyHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  uint64_t v1;

  return (*(uint64_t (**)(Swift::Int, _QWORD))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 24) + 8) + 16)
                                                       + 32))(_seed, *(_QWORD *)(v1 + 16));
}

uint64_t _IntegerAnyHashableBox._unbox<A>()@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, char *a3@<X8>)
{
  uint64_t v3;
  Class *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v12;

  v6 = *(Class **)(a1 + 16);
  MEMORY[0x1E0C80A78](a1);
  v8 = (uint64_t *)((char *)&v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
  (*(void (**)(uint64_t *, uint64_t, Class *))(v9 + 16))(v8, v3, v6);
  v10 = swift_dynamicCast(a3, v8, v6, a2, 6uLL);
  return (*((uint64_t (**)(char *, _QWORD, uint64_t, Class *))*(a2 - 1) + 7))(a3, v10 ^ 1u, 1, a2);
}

uint64_t _ConcreteHashableBox._downCastConditional<A>(into:)(char *a1, uint64_t a2, Class *a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  Class *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(char *, uint64_t, uint64_t, Class *);
  void (*v24)(char *, char *, Class *);
  uint64_t v26;

  v5 = v4;
  v9 = type metadata accessor for Optional(0, (uint64_t)a3, (uint64_t)a3, a4);
  v10 = *(_QWORD *)(v9 - 8);
  v11 = MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v26 - v12;
  v14 = *(Class **)(a2 + 16);
  v15 = MEMORY[0x1E0C80A78](v11);
  v17 = (uint64_t *)((char *)&v26 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0));
  v18 = (uint64_t)*(a3 - 1);
  MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v26 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(uint64_t *, uint64_t, Class *))(v21 + 16))(v17, v5, v14);
  v22 = swift_dynamicCast(v13, v17, v14, a3, 6uLL);
  v23 = *(void (**)(char *, uint64_t, uint64_t, Class *))(v18 + 56);
  if ((_DWORD)v22)
  {
    v23(v13, 0, 1, a3);
    v24 = *(void (**)(char *, char *, Class *))(v18 + 32);
    v24(v20, v13, a3);
    v24(a1, v20, a3);
  }
  else
  {
    v23(v13, 1, 1, a3);
    (*(void (**)(char *, uint64_t))(v10 + 8))(v13, v9);
  }
  return v22;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _IntegerAnyHashableBox<A>@<X0>(Class *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return _IntegerAnyHashableBox._unbox<A>()(a2, a1, a3);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, _QWORD, _QWORD, _QWORD))specialized BinaryInteger._description(radix:uppercase:));
}

uint64_t < infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *TupleTypeMetadata2;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  void (*v19)(char *, uint64_t, uint64_t);
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char v25;
  char v26;
  void (*v27)(char *, unint64_t *);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v29 = a8;
  v30 = a3;
  v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  v32 = *(TupleTypeMetadata2 - 1);
  v14 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  v19 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 16);
  v19((char *)&v29 - v17, a1, a5);
  v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a6 - 8) + 16);
  v22 = a2;
  v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v23 + 8) + 8))(v18, v16, a5) & 1) != 0)
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v29 + 16))(v20, v24, a6);
  else
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 16))(v18, v16, a5);
  v26 = v25;
  v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance _UInt128(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v2 == v3;
  v5 = v2 < v3;
  if (v4)
    return *a1 < *a2;
  else
    return v5;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _UInt128(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v3 == v2;
  v5 = v3 >= v2;
  if (v4)
    return *a2 >= *a1;
  else
    return v5;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _UInt128(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v2 == v3;
  v5 = v2 >= v3;
  if (v4)
    return *a1 >= *a2;
  else
    return v5;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _UInt128(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = a1[1];
  v3 = a2[1];
  v4 = v3 == v2;
  v5 = v3 < v2;
  if (v4)
    return *a2 < *a1;
  else
    return v5;
}

_QWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance _UInt128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;

  v3 = result[1];
  v4 = a2[1];
  v5 = __CFADD__(*result, *a2);
  v6 = __CFADD__(v3, v4);
  v7 = v3 + v4;
  if (v6 || (v5 ? (v8 = v7 == -1) : (v8 = 0), v8))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x6BuLL, 0);
  *a3 = *result + *a2;
  a3[1] = v7 + v5;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance _UInt128(_QWORD *a1, uint64_t *a2)
{
  return specialized static _UInt128.+= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance _UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  int v9;
  unint64_t v10;

  v4 = *result;
  v3 = result[1];
  v6 = *a2;
  v5 = a2[1];
  v7 = v3 >= v5;
  v8 = v3 - v5;
  v9 = !v7;
  v7 = v4 >= v6;
  v10 = v4 - v6;
  if (v7)
  {
    if (v9)
      goto LABEL_8;
  }
  else
  {
    if (!v8)
      LOBYTE(v9) = 1;
    if ((v9 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x5FuLL, 0);
    --v8;
  }
  *a3 = v10;
  a3[1] = v8;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  return specialized static _UInt128.-= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t _UInt128.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  void (*v51)(char *, char *, uint64_t);
  uint64_t (*v52)(uint64_t, uint64_t);
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(char *, uint64_t);
  char *v59;
  unint64_t v60;
  char v61;
  void (*v62)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v63;
  char *v64;
  char v65;
  uint64_t v66;
  unint64_t v67;
  const char *v68;
  unint64_t AssociatedConformanceWitness;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  unint64_t v77;
  uint64_t (*v78)(unint64_t *);
  char v79;
  void (*v80)(char *, char *, unint64_t *);
  char *v81;
  const char *v82;
  unint64_t v83;
  unint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  unint64_t v88;
  void (*v89)(char *, unint64_t *);
  char *v90;
  unint64_t v91;
  uint64_t (*v92)(unint64_t *, unint64_t);
  uint64_t v93;
  char *v94;
  void (*v95)(char *, uint64_t);
  uint64_t v96;
  char *v97;
  uint64_t v98;
  void (*v99)(uint64_t);
  char *v100;
  uint64_t (*v101)(char *, char *, uint64_t);
  char *v102;
  char v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void (*v107)(char *, unint64_t *);
  unint64_t v108;
  void (*v109)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t);
  unint64_t v110;
  char *v111;
  unint64_t v112;
  char v113;
  char *v114;
  void (*v115)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t);
  unint64_t v116;
  void (*v117)(char *, unint64_t *);
  char *v118;
  unint64_t v119;
  char v120;
  char *v121;
  const char *v122;
  unint64_t v123;
  unint64_t v124;
  char *v125;
  char *v126;
  unint64_t v127;
  unint64_t v128;
  void (*v129)(char *, char *, unint64_t *);
  char *v130;
  unint64_t v131;
  BOOL v132;
  char *v133;
  unint64_t v134;
  uint64_t v135;
  uint64_t v136;
  void (*v137)(unint64_t *, ValueMetadata *);
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  char *v141;
  char *v142;
  char *v143;
  void (*v144)(char *, uint64_t);
  uint64_t v145;
  void (*v146)(void (*)(_QWORD, _QWORD, _QWORD), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  char *v150;
  uint64_t (*v151)(uint64_t, uint64_t);
  char v152;
  char *v153;
  void (*v154)(char *, char *, uint64_t);
  char *v155;
  char *v156;
  unint64_t v157;
  const char *v158;
  unint64_t v159;
  char *v160;
  char *v161;
  char *v162;
  uint64_t (*v163)(uint64_t, uint64_t);
  char v164;
  uint64_t v165;
  unint64_t v166;
  const char *v167;
  unint64_t v168;
  char *v169;
  char *v170;
  char *v171;
  char *v172;
  unint64_t v173;
  char *v174;
  unint64_t v175;
  char *v176;
  char *v177;
  char v178;
  char *v179;
  unint64_t v180;
  uint64_t v181;
  char *v182;
  char *v183;
  char v184;
  unint64_t v185;
  const char *v186;
  unint64_t v187;
  uint64_t (*v188)(uint64_t, uint64_t);
  char *v189;
  char *v190;
  char *v191;
  char *v192;
  char *v193;
  char *v194;
  uint64_t v195;
  char *v196;
  char v198;
  uint64_t (*v199)(uint64_t, uint64_t);
  char v200;
  uint64_t v201;
  unint64_t v202;
  const char *v203;
  unint64_t v204;
  char *v205;
  char *v206;
  char *v207;
  void (*v208)(char *, uint64_t);
  char *v209;
  unint64_t v210;
  unint64_t v211;
  char *v212;
  char *v213;
  char v214;
  char *v215;
  unint64_t v216;
  char *v217;
  uint64_t v218;
  uint64_t (*v219)(unint64_t *, unint64_t);
  char *v220;
  char *v221;
  char *v222;
  unint64_t v223;
  char *v224;
  char *v225;
  uint64_t (*v226)(uint64_t, uint64_t);
  char *v227;
  uint64_t v228;
  char *v229;
  char *v230;
  unint64_t v231;
  const char *v232;
  char *v233;
  void (*v234)(char *, char *, uint64_t);
  uint64_t (*v235)(uint64_t, uint64_t);
  char *v236;
  unint64_t v237;
  const char *v238;
  char *v239;
  char *v240;
  char *v241;
  char *v242;
  char *v243;
  char *v244;
  void (*v245)(char *, uint64_t);
  char *v246;
  unint64_t v247;
  uint64_t v248;
  uint64_t v249;
  char *v250;
  char *v251;
  unint64_t v252;

  v6 = *(_QWORD *)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  v232 = *(const char **)(swift_getAssociatedConformanceWitness(v6, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  v231 = swift_getAssociatedTypeWitness(0, v232, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v231);
  v230 = (char *)&v218 - v8;
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v247 = *(v9 - 1);
  v10 = MEMORY[0x1E0C80A78](v9);
  v222 = (char *)&v218 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v239 = (char *)&v218 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v243 = (char *)&v218 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v244 = (char *)&v218 - v17;
  MEMORY[0x1E0C80A78](v16);
  v246 = (char *)&v218 - v18;
  v249 = v6;
  v238 = *(const char **)(v6 + 16);
  v237 = swift_getAssociatedTypeWitness(0, v238, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v19 = MEMORY[0x1E0C80A78](v237);
  v236 = (char *)&v218 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v218 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v24 = MEMORY[0x1E0C80A78](v21);
  v240 = (char *)&v218 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v221 = (char *)&v218 - v27;
  v28 = MEMORY[0x1E0C80A78](v26);
  v233 = (char *)&v218 - v29;
  v30 = MEMORY[0x1E0C80A78](v28);
  v32 = (char *)&v218 - v31;
  v33 = MEMORY[0x1E0C80A78](v30);
  v229 = (char *)&v218 - v34;
  v35 = MEMORY[0x1E0C80A78](v33);
  v224 = (char *)&v218 - v36;
  v37 = MEMORY[0x1E0C80A78](v35);
  v241 = (char *)&v218 - v38;
  v39 = MEMORY[0x1E0C80A78](v37);
  v242 = (char *)&v218 - v40;
  v41 = MEMORY[0x1E0C80A78](v39);
  v225 = (char *)&v218 - v42;
  v43 = MEMORY[0x1E0C80A78](v41);
  v45 = (char *)&v218 - v44;
  v46 = MEMORY[0x1E0C80A78](v43);
  v250 = (char *)&v218 - v47;
  MEMORY[0x1E0C80A78](v46);
  v49 = (char *)&v218 - v48;
  v248 = v50;
  v51 = *(void (**)(char *, char *, uint64_t))(v50 + 16);
  v251 = a1;
  v234 = v51;
  v51((char *)&v218 - v48, a1, a2);
  v52 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  v53 = v52(a2, a3);
  v220 = v23;
  v226 = v52;
  if ((v53 & 1) != 0)
  {
    v235 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    v54 = v235(a2, a3);
    if (v54 < 64)
    {
      v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v58 = *(void (**)(char *, uint64_t))(v248 + 8);
      v59 = v49;
      goto LABEL_4;
    }
    goto LABEL_8;
  }
  v61 = v52(a2, a3);
  v235 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  v54 = v235(a2, a3);
  if ((v61 & 1) == 0)
  {
    v60 = v247;
    if (v54 < 64)
    {
      v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      v58 = *(void (**)(char *, uint64_t))(v248 + 8);
      v58(v49, a2);
      if (v66 < 0)
        goto LABEL_16;
    }
    else
    {
      v58 = *(void (**)(char *, uint64_t))(v248 + 8);
      v58(v49, a2);
    }
    goto LABEL_18;
  }
  if (v54 > 64)
  {
LABEL_8:
    v252 = 0;
    v62 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    v63 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v64 = v250;
    v62(&v252, &type metadata for Int, v63, a2, a3);
    v65 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v49, v64, a2);
    v58 = *(void (**)(char *, uint64_t))(v248 + 8);
    v58(v64, a2);
    v58(v49, a2);
    v60 = v247;
    if ((v65 & 1) == 0)
      goto LABEL_18;
LABEL_16:
    v58(v251, a2);
    return 0;
  }
  v67 = v237;
  v68 = v238;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v238, a2, v237, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v70 = v236;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v67, AssociatedConformanceWitness);
  v71 = v250;
  (*((void (**)(char *, uint64_t, const char *))v68 + 3))(v70, a2, v68);
  LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 32) + 8) + 16))(v49, v71, a2);
  v72 = v248;
  v58 = *(void (**)(char *, uint64_t))(v248 + 8);
  v58(v71, a2);
  (*(void (**)(char *, char *, uint64_t))(v72 + 32))(v45, v49, a2);
  if ((v67 & 1) != 0)
  {
    v58(v45, a2);
    goto LABEL_16;
  }
  v57 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v59 = v45;
LABEL_4:
  v58(v59, a2);
  v60 = v247;
  if (v57 < 0)
    goto LABEL_16;
LABEL_18:
  v245 = v58;
  v227 = v32;
  v74 = v249;
  v75 = a3;
  v76 = v246;
  (*(void (**)(uint64_t, uint64_t))(v249 + 56))(a2, v249);
  v228 = v75;
  v77 = swift_getAssociatedConformanceWitness(v75, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for BinaryInteger, (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  v78 = *(uint64_t (**)(unint64_t *))(v77 + 64);
  v223 = v77;
  v79 = v78(v9);
  v80 = *(void (**)(char *, char *, unint64_t *))(v60 + 16);
  v81 = v244;
  v80(v244, v76, v9);
  v219 = (uint64_t (*)(unint64_t *, unint64_t))v78;
  if ((v79 & 1) != 0)
  {
    v82 = v232;
    v83 = v231;
    v84 = swift_getAssociatedConformanceWitness((uint64_t)v232, (uint64_t)v9, v231, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v85 = v81;
    v86 = v230;
    (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v84 + 8))(&qword_1816B7DA8, 256, v83, v84);
    v87 = v243;
    (*((void (**)(char *, unint64_t *, const char *))v82 + 3))(v86, v9, v82);
    v88 = swift_getAssociatedConformanceWitness(v249, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    LOBYTE(v83) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v88 + 16))(v85, v87, v9, v88);
    v89 = *(void (**)(char *, unint64_t *))(v60 + 8);
    v89(v87, v9);
    v90 = v85;
    v74 = v249;
    v89(v90, v9);
    if ((v83 & 1) != 0)
    {
LABEL_40:
      v135 = ((uint64_t (*)(char *, unint64_t *))v89)(v76, v9);
      v252 = -1;
      v136 = v228;
      v137 = *(void (**)(unint64_t *, ValueMetadata *))(v228 + 88);
      v140 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v135, v138, v139);
      v141 = v250;
      v247 = v140;
      v137(&v252, &type metadata for UInt64);
      v142 = v225;
      v143 = v251;
      (*(void (**)(char *, char *, uint64_t, uint64_t))(v136 + 192))(v251, v141, a2, v136);
      v144 = v245;
      v145 = ((uint64_t (*)(char *, uint64_t))v245)(v141, a2);
      v252 = 64;
      v146 = *(void (**)(void (*)(_QWORD, _QWORD, _QWORD), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v136 + 240);
      v149 = lazy protocol witness table accessor for type Int and conformance Int(v145, v147, v148);
      v146((void (*)(_QWORD, _QWORD, _QWORD))v143, &v252, &type metadata for Int, v149, a2, v136);
      v144(v143, a2);
      v150 = v241;
      v251 = *(char **)(v248 + 32);
      ((void (*)(char *, char *, uint64_t))v251)(v241, v142, a2);
      v151 = v226;
      v152 = v226(a2, v136);
      v153 = v233;
      v154 = v234;
      if ((v152 & 1) != 0)
      {
        v155 = v233;
        v156 = v224;
        v234(v224, v150, a2);
        v157 = v237;
        v158 = v238;
        v159 = swift_getAssociatedConformanceWitness((uint64_t)v238, a2, v237, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v160 = v236;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v159 + 8))(&qword_1816B7DA8, 256, v157, v159);
        v161 = v250;
        v162 = v160;
        v144 = v245;
        (*((void (**)(char *, uint64_t, const char *))v158 + 3))(v162, a2, v158);
        LOBYTE(v157) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v136 + 32) + 8)
                                                                          + 32))(v156, v161, a2);
        v144(v161, a2);
        if ((v157 & 1) == 0)
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
        v144(v156, a2);
        v150 = v241;
        v153 = v155;
      }
      v163 = v235;
      if (v235(a2, v136) < 64)
      {
LABEL_57:
        v249 = *(_QWORD *)(v136 + 120);
        v181 = ((uint64_t (*)(uint64_t, uint64_t))v249)(a2, v136);
        v182 = v150;
        v73 = v181;
        v144(v182, a2);
        v183 = v227;
        ((void (*)(char *, char *, uint64_t))v251)(v227, v242, a2);
        v184 = v151(a2, v136);
        v154(v153, v183, a2);
        if ((v184 & 1) != 0)
        {
          v185 = v237;
          v186 = v238;
          v187 = swift_getAssociatedConformanceWitness((uint64_t)v238, a2, v237, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v188 = v151;
          v189 = v153;
          v190 = v236;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v187 + 8))(&qword_1816B7DA8, 256, v185, v187);
          v191 = v250;
          (*((void (**)(char *, uint64_t, const char *))v186 + 3))(v190, a2, v186);
          LOBYTE(v185) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v136 + 32) + 8)
                                                                            + 16))(v189, v191, a2);
          v192 = v191;
          v163 = v235;
          v144 = v245;
          v245(v192, a2);
          v193 = v189;
          v151 = v188;
          v154 = v234;
          v144(v193, a2);
          if ((v185 & 1) != 0)
            goto LABEL_74;
        }
        else
        {
          v144(v153, a2);
        }
        v194 = v227;
        v195 = v163(a2, v136);
        v154(v240, v194, a2);
        if (v195 <= 63)
        {
          v144(v240, a2);
          goto LABEL_63;
        }
        v252 = -1;
        v198 = v151(a2, v136);
        v199 = v163;
        v200 = v198;
        v201 = v199(a2, v136);
        if ((v200 & 1) != 0)
        {
          if (v201 < 65)
          {
            v202 = v237;
            v203 = v238;
            v204 = swift_getAssociatedConformanceWitness((uint64_t)v238, a2, v237, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v205 = v236;
            (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v204 + 8))(&qword_1816B7DA8, 256, v202, v204);
            v206 = v250;
            (*((void (**)(char *, uint64_t, const char *))v203 + 3))(v205, a2, v203);
            v207 = v240;
            LOBYTE(v202) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v136 + 32) + 8)
                                                                              + 40))(v240, v206, a2);
            v208 = v245;
            v245(v206, a2);
            v209 = v220;
            v210 = v252;
            ((void (*)(char *, char *, uint64_t))v251)(v220, v207, a2);
            if ((v202 & 1) != 0)
            {
              v211 = ((uint64_t (*)(uint64_t, uint64_t))v249)(a2, v136);
              v208(v209, a2);
              v132 = v210 >= v211;
              v144 = v208;
              if (!v132)
                goto LABEL_74;
            }
            else
            {
              v208(v209, a2);
              v144 = v208;
            }
            goto LABEL_63;
          }
        }
        else if (v201 < 65)
        {
          v215 = v250;
          ((void (*)(char *, char *, uint64_t))v251)(v250, v240, a2);
          v216 = ((uint64_t (*)(uint64_t, uint64_t))v249)(a2, v136);
          v217 = v215;
          v144 = v245;
          v245(v217, a2);
          if (v252 < v216)
          {
LABEL_74:
            v144(v227, a2);
            return 0;
          }
LABEL_63:
          v196 = v227;
          ((void (*)(uint64_t, uint64_t))v249)(a2, v136);
          v144(v196, a2);
          return v73;
        }
        v212 = v250;
        (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v136 + 96))(&v252, &type metadata for UInt64, v247, a2, v136);
        v213 = v240;
        v214 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v136 + 32) + 8) + 16))(v212, v240, a2);
        v144 = v245;
        v245(v212, a2);
        v144(v213, a2);
        if ((v214 & 1) != 0)
          goto LABEL_74;
        goto LABEL_63;
      }
      v154(v229, v150, a2);
      v252 = -1;
      v164 = v151(a2, v136);
      v165 = v163(a2, v136);
      if ((v164 & 1) != 0)
      {
        if (v165 < 65)
        {
          v166 = v237;
          v167 = v238;
          v168 = swift_getAssociatedConformanceWitness((uint64_t)v238, a2, v237, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v169 = v236;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v168 + 8))(&qword_1816B7DA8, 256, v166, v168);
          v170 = v250;
          v171 = v169;
          v144 = v245;
          (*((void (**)(char *, uint64_t, const char *))v167 + 3))(v171, a2, v167);
          v172 = v229;
          LOBYTE(v166) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v136 + 32) + 8)
                                                                            + 40))(v229, v170, a2);
          v144(v170, a2);
          v173 = v252;
          v174 = v221;
          v154(v221, v172, a2);
          if ((v166 & 1) != 0)
          {
            v175 = (*(uint64_t (**)(uint64_t, uint64_t))(v136 + 120))(a2, v136);
            v144(v174, a2);
            v163 = v235;
            v176 = v229;
            if (v173 < v175)
              goto LABEL_53;
          }
          else
          {
            v144(v174, a2);
            v163 = v235;
            v176 = v229;
          }
          goto LABEL_56;
        }
      }
      else if (v165 <= 64)
      {
        v179 = v250;
        v176 = v229;
        v154(v250, v229, a2);
        v180 = (*(uint64_t (**)(uint64_t, uint64_t))(v136 + 120))(a2, v136);
        v144(v179, a2);
        if (v252 < v180)
          goto LABEL_53;
LABEL_56:
        v144(v176, a2);
        v150 = v241;
        v153 = v233;
        goto LABEL_57;
      }
      v177 = v250;
      (*(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v136 + 96))(&v252, &type metadata for UInt64, v247, a2, v136);
      v176 = v229;
      v178 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v136 + 32) + 8) + 16))(v177, v229, a2);
      v144(v177, a2);
      if ((v178 & 1) != 0)
LABEL_53:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
      goto LABEL_56;
    }
  }
  else
  {
    v89 = *(void (**)(char *, unint64_t *))(v60 + 8);
    v89(v81, v9);
  }
  v91 = v223;
  v92 = *(uint64_t (**)(unint64_t *, unint64_t))(v223 + 128);
  v93 = v92(v9, v223);
  v94 = v239;
  v80(v239, v76, v9);
  if (v93 <= 63)
  {
    v89(v94, v9);
    v95 = v245;
    v96 = v228;
    goto LABEL_24;
  }
  v252 = -1;
  v103 = v219(v9, v91);
  v104 = v92(v9, v91);
  v96 = v228;
  if ((v103 & 1) != 0)
  {
    v107 = v89;
    v108 = v247;
    if (v104 < 65)
    {
      v122 = v232;
      v123 = v231;
      v124 = swift_getAssociatedConformanceWitness((uint64_t)v232, (uint64_t)v9, v231, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v125 = v230;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v124 + 8))(&qword_1816B7DA8, 256, v123, v124);
      v126 = v243;
      (*((void (**)(char *, unint64_t *, const char *))v122 + 3))(v125, v9, v122);
      v127 = swift_getAssociatedConformanceWitness(v249, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      LOBYTE(v123) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v127 + 40))(v94, v126, v9, v127);
      v107(v126, v9);
      v128 = v252;
      v129 = *(void (**)(char *, char *, unint64_t *))(v108 + 32);
      v130 = v222;
      v129(v222, v94, v9);
      v95 = v245;
      if ((v123 & 1) != 0)
      {
        v91 = v223;
        v131 = (*(uint64_t (**)(unint64_t *, unint64_t))(v223 + 120))(v9, v223);
        v107(v130, v9);
        v132 = v128 >= v131;
        v74 = v249;
        v89 = v107;
        if (!v132)
          goto LABEL_39;
      }
      else
      {
        v107(v130, v9);
        v74 = v249;
        v91 = v223;
        v89 = v107;
      }
    }
    else
    {
      v109 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v91 + 96);
      v110 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v104, v105, v106);
      v111 = v243;
      v109(&v252, &type metadata for UInt64, v110, v9, v91);
      v74 = v249;
      v112 = swift_getAssociatedConformanceWitness(v249, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      v113 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v112 + 16))(v111, v94, v9, v112);
      v114 = v111;
      v89 = v107;
      v107(v114, v9);
      v107(v94, v9);
      v95 = v245;
      if ((v113 & 1) != 0)
        goto LABEL_39;
    }
  }
  else if (v104 < 65)
  {
    v133 = v243;
    (*(void (**)(char *, char *, unint64_t *))(v247 + 32))(v243, v94, v9);
    v134 = (*(uint64_t (**)(unint64_t *, unint64_t))(v91 + 120))(v9, v91);
    v89(v133, v9);
    v95 = v245;
    v74 = v249;
    if (v252 < v134)
    {
LABEL_39:
      v76 = v246;
      goto LABEL_40;
    }
  }
  else
  {
    v115 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v91 + 96);
    v116 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v104, v105, v106);
    v117 = v89;
    v118 = v243;
    v115(&v252, &type metadata for UInt64, v116, v9, v91);
    v74 = v249;
    v119 = swift_getAssociatedConformanceWitness(v249, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    v120 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v119 + 16))(v118, v94, v9, v119);
    v121 = v118;
    v89 = v117;
    v117(v121, v9);
    v117(v94, v9);
    v95 = v245;
    if ((v120 & 1) != 0)
      goto LABEL_39;
  }
LABEL_24:
  v97 = v246;
  v98 = (*(uint64_t (**)(unint64_t *, unint64_t))(v91 + 120))(v9, v91);
  v89(v97, v9);
  v99 = *(void (**)(uint64_t))(*(_QWORD *)(v74 + 8) + 16);
  v100 = v250;
  v99(a2);
  v101 = *(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v96 + 32) + 8) + 16);
  v102 = v251;
  LOBYTE(v97) = v101(v251, v100, a2);
  v95(v102, a2);
  v95(v100, a2);
  if ((v97 & 1) != 0)
    return -v98;
  else
    return v98;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance _UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))_UInt128.init<A>(exactly:), a1);
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))specialized static _UInt128.* infix(_:_:), a3);
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  return specialized static _UInt128.*= infix(_:_:)(a1, *a2, a2[1]);
}

_QWORD *protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance _UInt128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  if ((*result & 0x8000000000000000) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000028, 0x8000000181763C20, "Swift/LegacyInt128.swift", 24, 2, 0x85uLL, 0);
  *a2 = *result;
  a2[1] = 0;
  return result;
}

unint64_t specialized _wideMaskedShiftRight<A>(_:_:)(unint64_t *a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((a4 & 0x7Fu) >= 0x40uLL)
  {
    *a1 = a2 >> a4;
    return 0;
  }
  else if ((a4 & 0x7F) != 0)
  {
    *a1 = (a3 >> a4) | (a2 << -a4);
    return a2 >> a4;
  }
  else
  {
    *a1 = a3;
    return a2;
  }
}

uint64_t specialized _wideMaskedShiftRight<A>(_:_:)(uint64_t *a1, uint64_t a2, unint64_t a3, char a4)
{
  if ((a4 & 0x7Fu) >= 0x40uLL)
  {
    *a1 = a2 >> a4;
    return a2 >> 63;
  }
  else if ((a4 & 0x7F) != 0)
  {
    *a1 = (a3 >> a4) | (a2 << -a4);
    return a2 >> a4;
  }
  else
  {
    *a1 = a3;
    return a2;
  }
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _UInt128.Words(uint64_t *a1, unint64_t *a2))()
{
  uint64_t *v2;

  *a1 = _UInt128.Words.subscript.getter(*a2, *v2, v2[1], 0xC7uLL);
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 specialized _wideDivide22<A>(_:by:)(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 a3, Swift::UInt64 a4, unint64_t a5, unint64_t a6)
{
  _QWORD *high;
  BOOL v9;
  unint64_t v10;
  Swift::UInt64 v11;
  Swift::UInt64 v12;
  unint64_t v13;
  BOOL v14;
  Swift::UInt64 v15;
  Swift::tuple_high_UInt64_low_UInt64 v16;
  Swift::UInt64 quotient;
  Swift::UInt64 remainder;
  Swift::tuple_quotient_UInt64_remainder_UInt64 v19;
  Swift::UInt64 v20;
  Swift::UInt64 v21;
  unint64_t v22;
  unint64_t v24;
  Swift::UInt64 v25;

  if (!(a5 | a6))
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000010, 0x8000000181760560, "Swift/LegacyInt128.swift", 24, 2, 0x4CFuLL, 0);
  high = (_QWORD *)a3.high;
  v9 = a6 < a4;
  if (a5 != a3.low)
    v9 = a5 < a3.low;
  if (v9)
  {
    if (a3.low)
    {
      if (a5)
      {
        v10 = __clz(a5);
        if (v10)
        {
          a5 = (a6 >> -(char)v10) | (a5 << v10);
          a6 <<= v10;
          if (((0x80 - (_BYTE)v10) & 0x7F) != 0)
            v11 = (a4 >> (0x80 - v10)) | (a3.low << v10);
          else
            v11 = a4;
          v12 = a4 >> (-(char)v10 & 0x3F);
          v13 = a4 << v10;
          if (((0x80 - (_BYTE)v10) & 0x7Fu) <= 0x3FuLL)
            a4 = v11;
          else
            a4 = a3.low >> (0x80 - v10);
          a3.low = v12 | (a3.low << v10);
        }
        else
        {
          v13 = a4;
        }
        a3.high = a4;
        v20 = specialized _wideDivide32<A>(_:by:)(&v25, &v24, a3, v13, a5, a6);
        v15 = 0;
        v22 = v24;
        v21 = v25;
        *a1 = v20;
        if (v10)
        {
          v22 = (v22 >> v10) | (v21 << -(char)v10);
          v21 >>= v10;
        }
        *high = v22;
        *a2 = v21;
        return v15;
      }
      if (a6)
      {
        v15 = a3.low / a6;
        if (a3.low % a6)
        {
          v16.low = a4;
          v16.high = a3.low % a6;
          v19 = UInt64.dividingFullWidth(_:)(v16);
          remainder = v19.remainder;
          quotient = v19.quotient;
        }
        else
        {
          quotient = a4 / a6;
          remainder = a4 % a6;
        }
        *a1 = quotient;
        *high = remainder;
        goto LABEL_30;
      }
    }
    else if (a6)
    {
      v15 = 0;
      *(_QWORD *)a3.high = a4 % a6;
      *a1 = a4 / a6;
LABEL_30:
      *a2 = 0;
      return v15;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  }
  v14 = a3.low < a5;
  v15 = 0;
  if (a5 == a3.low)
    v14 = a4 < a6;
  if (v14)
  {
    *a1 = 0;
    *a2 = a3.low;
    *(_QWORD *)a3.high = a4;
  }
  else
  {
    *a1 = 1;
    *a2 = 0;
    *(_QWORD *)a3.high = 0;
  }
  return v15;
}

Swift::tuple_high__UInt128_low__UInt128 __swiftcall _UInt128.multipliedFullWidth(by:)(Swift::_UInt128 by)
{
  unint64_t v1;
  unint64_t v2;
  Swift::UInt64 v3;
  unint64_t v4;
  _BOOL8 v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  _BOOL8 v10;
  unsigned __int128 v11;
  uint64_t v12;
  unint64_t v13;
  Swift::UInt64 v14;
  Swift::UInt64 v15;
  Swift::UInt64 v16;
  Swift::UInt64 v17;
  Swift::tuple_high__UInt128_low__UInt128 result;

  v3 = v1 * by.low;
  v4 = (__PAIR128__(v2, v1) * by.low) >> 64;
  v5 = __CFADD__((v1 * (unsigned __int128)by.low) >> 64, v2 * by.low);
  v6 = (v2 * (unsigned __int128)by.high) >> 64;
  v7 = (v1 * (unsigned __int128)by.high) >> 64;
  v8 = (v2 * (unsigned __int128)by.low) >> 64;
  v11 = __PAIR128__(v2 * by.high, v4) + v1 * by.high;
  v9 = __CFADD__(__CFADD__(v4, v1 * by.high), v2 * by.high) | __CFADD__(v5, *((_QWORD *)&v11 + 1));
  v10 = v5 + *((_QWORD *)&v11 + 1);
  v12 = v9;
  v9 = __CFADD__(v8, v7);
  v13 = v8 + v7;
  if (v9)
    ++v6;
  v15 = (__PAIR128__(v6, v13) + __PAIR128__(v12, v10)) >> 64;
  v14 = v13 + v10;
  v16 = v3;
  v17 = v11;
  result.low.high = v17;
  result.low.low = v16;
  result.high.high = v15;
  result.high.low = v14;
  return result;
}

Swift::UInt64 specialized _wideDivide42<A>(_:by:)(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 a3, Swift::UInt64 a4, Swift::UInt64 a5, Swift::UInt64 a6, Swift::UInt64 a7, unint64_t a8)
{
  unint64_t v8;
  Swift::UInt64 v9;
  BOOL v10;
  unint64_t v11;
  Swift::UInt64 v12;
  _QWORD *high;
  unint64_t v17;
  char v18;
  unint64_t v19;
  Swift::UInt64 v20;
  Swift::UInt64 v21;
  Swift::UInt64 v22;
  BOOL v23;
  Swift::UInt64 v24;
  Swift::UInt64 v25;
  Swift::tuple_high_UInt64_low_UInt64 v26;
  Swift::UInt64 remainder;
  Swift::UInt64 v28;
  Swift::tuple_quotient_UInt64_remainder_UInt64 v29;
  Swift::UInt64 quotient;
  Swift::UInt64 v31;
  unint64_t v32;
  Swift::UInt64 v33;
  unint64_t v34;
  Swift::tuple_quotient_UInt64_remainder_UInt64 v35;
  _BOOL4 v36;
  Swift::UInt64 v37;
  Swift::UInt64 v38;
  Swift::UInt64 v39;
  Swift::UInt64 v40;
  BOOL v41;
  Swift::UInt64 v42;
  Swift::UInt64 v43;
  Swift::UInt64 v44;
  Swift::UInt64 v45;
  Swift::tuple_high_UInt64_low_UInt64 v46;
  Swift::tuple_high_UInt64_low_UInt64 v47;

  v8 = a8;
  if (!(a7 | a8))
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000010, 0x8000000181760560 | 0x8000000000000000, "Swift/LegacyInt128.swift", 24, 2, 0x4F7uLL, 0);
  v9 = a7;
  v10 = a8 >= a4;
  if (a7 != a3.low)
    v10 = a7 >= a3.low;
  if (!v10)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD00000000000001FLL, 0x8000000181760520 | 0x8000000000000000, "Swift/LegacyInt128.swift", 24, 2, 0x4FAuLL, 0);
  v11 = a6;
  v12 = a5;
  high = (_QWORD *)a3.high;
  if (!(a3.low | a4))
  {
    a3.low = a5;
    return specialized _wideDivide22<A>(_:by:)(a1, a2, a3, a6, a7, a8);
  }
  if (a7)
  {
    v17 = __clz(a7);
    if (v17)
    {
      v18 = 0x80 - v17;
      v8 = a8 << v17;
      v9 = (a8 >> -(char)v17) | (a7 << v17);
      a3.high = (a4 >> -(char)v17) | (a3.low << v17);
      v19 = (128 - v17) & 0x7F;
      v20 = a5 << v17;
      if (v19 > 0x3F)
      {
        v25 = a5 >> v18;
      }
      else
      {
        v21 = (a6 >> v18) | v20;
        v22 = a5 >> v18;
        v23 = v19 == 0;
        if (v19)
          v24 = v22;
        else
          v24 = a5;
        if (v23)
          v25 = a6;
        else
          v25 = v21;
        a3.high |= v24;
      }
      a3.low = v25 | (a4 << v17);
      v12 = (a6 >> (-(char)v17 & 0x3F)) | v20;
      v11 = a6 << v17;
      if (a3.high)
        goto LABEL_30;
    }
    else
    {
      a3.high = a5 | a3.low;
      a3.low = a6 | a4;
      if (a3.high)
        goto LABEL_30;
    }
    v36 = v12 < v8;
    if (a3.low != v9)
      v36 = a3.low < v9;
    if (v36)
    {
      v46.high = a3.low;
      v46.low = v12;
      v37 = specialized _wideDivide32<A>(_:by:)(&v45, &v44, v46, v11, v9, v8);
      quotient = 0;
      v39 = v44;
      v38 = v45;
      *a1 = v37;
      v40 = (v39 >> v17) | (v38 << -(char)v17);
      v41 = v17 == 0;
      v42 = v38 >> v17;
LABEL_31:
      if (!v41)
      {
        v39 = v40;
        v38 = v42;
      }
      *high = v39;
      *a2 = v38;
      return quotient;
    }
LABEL_30:
    quotient = specialized _wideDivide32<A>(_:by:)(&v45, &v44, a3, v12, v9, v8);
    v47.low = v44;
    v47.high = v45;
    v43 = specialized _wideDivide32<A>(_:by:)(&v45, &v44, v47, v11, v9, v8);
    v39 = v44;
    v38 = v45;
    *a1 = v43;
    v40 = (v39 >> v17) | (v38 << -(char)v17);
    v42 = v38 >> v17;
    v41 = v17 == 0;
    goto LABEL_31;
  }
  if (!a8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  if (a3.low % a8)
  {
    v26.low = a4;
    v26.high = a3.low % a8;
    remainder = UInt64.dividingFullWidth(_:)(v26).remainder;
    if (remainder)
      goto LABEL_20;
LABEL_35:
    quotient = v12 / a8;
    v31 = v12 % a8;
    if (v12 % a8)
      goto LABEL_21;
LABEL_36:
    v33 = v11 / a8;
    v34 = v11 % a8;
    goto LABEL_37;
  }
  remainder = a4 % a8;
  if (!(a4 % a8))
    goto LABEL_35;
LABEL_20:
  v28 = v12;
  v29 = UInt64.dividingFullWidth(_:)(*(Swift::tuple_high_UInt64_low_UInt64 *)&remainder);
  quotient = v29.quotient;
  v31 = v29.remainder;
  if (!v29.remainder)
    goto LABEL_36;
LABEL_21:
  v32 = v11;
  v35 = UInt64.dividingFullWidth(_:)(*(Swift::tuple_high_UInt64_low_UInt64 *)&v31);
  v34 = v35.remainder;
  v33 = v35.quotient;
LABEL_37:
  *a1 = v33;
  *high = v34;
  *a2 = 0;
  return quotient;
}

uint64_t specialized _wideMaskedShiftLeft<A>(_:_:)(uint64_t *a1, unint64_t a2, unint64_t a3, char a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (a2 << a4) | (a3 >> -a4);
  if ((a4 & 0x7F) != 0)
    v5 = a3 << a4;
  else
    v5 = a3;
  if ((a4 & 0x7F) == 0)
    v4 = a2;
  if ((a4 & 0x7Fu) <= 0x3FuLL)
  {
    v6 = v4;
  }
  else
  {
    v5 = 0;
    v6 = a3 << a4;
  }
  *a1 = v5;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance _UInt128(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = a2[1];
  v4 = v2[1];
  v5 = __CFADD__(*v2, *a2);
  v6 = __CFADD__(v4, v3);
  v7 = v4 + v3;
  if (v6)
  {
    v8 = 1;
    if (!v5)
    {
LABEL_12:
      v9 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    v8 = v7 == -1 && v5;
    if (!v5)
      goto LABEL_12;
  }
  v9 = 1;
LABEL_13:
  *a1 = *v2 + *a2;
  a1[1] = v9 + v7;
  return v8;
}

unint64_t protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;

  v3 = *a2;
  v4 = a2[1];
  v5 = *v2;
  v6 = v2[1];
  v7 = v6 >= v4;
  v8 = v6 - v4;
  v9 = !v7;
  v7 = v5 >= v3;
  v10 = v5 - v3;
  LODWORD(v3) = v5 < v3;
  if (v7)
  {
    if (v9)
    {
      v3 = 1;
      v11 = v8;
      goto LABEL_13;
    }
    v11 = v8;
  }
  else
  {
    v11 = v8 - 1;
    if ((v9 & 1) != 0)
    {
      v3 = 1;
      goto LABEL_13;
    }
  }
  if (v8)
    v3 = 0;
  else
    v3 = v3;
LABEL_13:
  *a1 = v10;
  a1[1] = v11;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  _BOOL4 v9;
  unint64_t v10;
  _BOOL4 v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BOOL4 v15;
  BOOL v16;
  uint64_t v17;
  unsigned int v18;

  v3 = *a2;
  v4 = a2[1];
  v5 = *v2;
  v6 = v2[1];
  v7 = !is_mul_ok(v6, *a2);
  v8 = v6 * *a2;
  v9 = !is_mul_ok(*v2, v4);
  v10 = v8 + *v2 * v4;
  v11 = __CFADD__(v8, *v2 * v4);
  v12 = v5 * v3;
  v13 = (v5 * (unsigned __int128)v3) >> 64;
  v14 = v10 + v13;
  v15 = __CFADD__(v10, v13);
  if (v4)
    v16 = v6 == 0;
  else
    v16 = 1;
  v17 = 1;
  if (v16)
  {
    v18 = v9 || v11 || v15;
    if (v7)
      v17 = 1;
    else
      v17 = v18;
  }
  *a1 = v12;
  a1[1] = v14;
  return v17;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  Swift::UInt64 *v2;
  unint64_t v4;
  Swift::tuple_high_UInt64_low_UInt64 v5;
  Swift::UInt64 v6;
  unint64_t v7;
  _BOOL8 v8;
  char v10;
  Swift::UInt64 v11;
  Swift::UInt64 v12;

  v4 = a2[1];
  v6 = *v2;
  v5.low = v2[1];
  v7 = v4 | *a2;
  v8 = v7 == 0;
  if (v7)
  {
    v5.high = (Swift::UInt64)&v10;
    v5.low = specialized _wideDivide22<A>(_:by:)(&v12, &v11, v5, v6, v4, *a2);
    v6 = v12;
  }
  *a1 = v6;
  a1[1] = v5.low;
  return v8;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  Swift::UInt64 *v2;
  unint64_t v4;
  Swift::tuple_high_UInt64_low_UInt64 v5;
  Swift::UInt64 v6;
  unint64_t v7;
  _BOOL8 v8;
  Swift::UInt64 v10;
  Swift::UInt64 v11;
  Swift::UInt64 v12;

  v4 = a2[1];
  v6 = *v2;
  v5.low = v2[1];
  v7 = v4 | *a2;
  v8 = v7 == 0;
  if (v7)
  {
    v5.high = (Swift::UInt64)&v10;
    specialized _wideDivide22<A>(_:by:)(&v12, &v11, v5, v6, v4, *a2);
    v6 = v10;
    v5.low = v11;
  }
  *a1 = v6;
  a1[1] = v5.low;
  return v8;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(uint64_t *a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(a1, a2, a3, a4, a5, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))_UInt128.multipliedFullWidth(by:));
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance _UInt128(_QWORD *a1, _QWORD *a2, Swift::UInt64 *a3, Swift::UInt64 *a4)
{
  unint64_t *v4;
  Swift::UInt64 v7;
  Swift::UInt64 v8;
  Swift::UInt64 v9;
  Swift::UInt64 v10;
  Swift::UInt64 result;
  Swift::UInt64 v12;
  uint64_t v13;
  uint64_t v14;
  Swift::UInt64 v15;
  Swift::UInt64 v16;
  Swift::tuple_high_UInt64_low_UInt64 v17;

  v7 = *a3;
  v8 = a3[1];
  v10 = *a4;
  v9 = a4[1];
  v17.high = (Swift::UInt64)&v14;
  v17.low = v8;
  result = specialized _wideDivide42<A>(_:by:)(&v16, &v15, v17, v7, v9, v10, v4[1], *v4);
  v12 = v15;
  v13 = v14;
  *a1 = v16;
  a1[1] = result;
  *a2 = v13;
  a2[1] = v12;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  return protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, _QWORD, _QWORD, _QWORD))specialized _wideMaskedShiftRight<A>(_:_:), a3);
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance _UInt128(uint64_t *a1, _QWORD *a2)
{
  return specialized static _UInt128.&>>= infix(_:_:)(a1, *a2);
}

uint64_t protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance _Int128@<X0>(unint64_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result;

  result = specialized _wideMaskedShiftLeft<A>(_:_:)(a3, a1[1], *a1, *a2);
  a3[1] = result;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance _UInt128(uint64_t *a1, _QWORD *a2)
{
  return specialized static _Int128.&<<= infix(_:_:)(a1, *a2);
}

_OWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance _UInt128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  v3 = (*a2 * *result) >> 64;
  *a3 = *(_QWORD *)a2 * *(_QWORD *)result;
  a3[1] = v3;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<D0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type _UInt128 and conformance _UInt128, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, _UInt128.init<A>(exactly:), 0x85uLL, a4);
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized static FixedWidthInteger._truncatingInit<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance _UInt128@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance _UInt128()
{
  unint64_t *v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance _UInt128@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))specialized static _UInt128./ infix(_:_:), a3);
}

Swift::UInt64 protocol witness for static BinaryInteger./= infix(_:_:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  return specialized static _UInt128./= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance _UInt128@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, specialized static _UInt128.% infix(_:_:), a3);
}

Swift::UInt64 protocol witness for static BinaryInteger.%= infix(_:_:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  return specialized static _UInt128.%= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance _UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, uint64_t);
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t AssociatedConformanceWitness;
  char *v53;
  void (*v54)(char *, uint64_t);
  unint64_t result;
  uint64_t v56;
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v62;
  char v63;
  void (*v64)(char *, uint64_t);
  uint64_t v65;
  void (*v66)(char *, uint64_t, uint64_t);
  char *v67;
  char v68;
  char *v69;
  uint64_t v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v83;
  char v84;
  void (*v85)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v86;
  char v87;
  uint64_t v88;
  void (**v89)(char *, uint64_t, const char *);
  unint64_t v90;
  unint64_t v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  uint64_t v96;
  BOOL v97;
  uint64_t (*v98)(uint64_t, uint64_t);
  uint64_t v99;
  char *v100;
  uint64_t (*v101)(uint64_t, uint64_t);
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char v113;
  char *v114;
  char v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char *v117;
  char *v118;
  char *v119;
  unint64_t AssociatedTypeWitness;
  char *v121;
  unint64_t v122;
  unint64_t v123;
  char *v124;
  char *v125;
  char *v126;
  char *v127;
  uint64_t *v128;
  uint64_t (*v129)(uint64_t, uint64_t);
  uint64_t v130;
  uint64_t v131;

  v121 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v121, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v119 = (char *)&v116 - v11;
  v12 = *(_QWORD *)(a3 - 8);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v116 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v117 = (char *)&v116 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v126 = (char *)&v116 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v124 = (char *)&v116 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v118 = (char *)&v116 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v125 = (char *)&v116 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v127 = (char *)&v116 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v116 - v28;
  v30 = *a1;
  v122 = a1[1];
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v123 = v30;
  v129 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v131 = -128;
      v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v131, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = v33;
      if ((v48 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = v33;
      if (v37 < -128)
        goto LABEL_24;
    }
    goto LABEL_18;
  }
  v128 = a5;
  v39 = v31(a3, a4);
  v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v40 = v38(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 >= 64)
    {
      a5 = v128;
      goto LABEL_18;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    goto LABEL_17;
  }
  if (v40 > 64)
  {
    v131 = -128;
    v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v131, &type metadata for Int, v44, a3, a4);
    v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    a5 = v128;
    if ((v45 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v50 = AssociatedTypeWitness;
  v51 = v121;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v121, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v53 = v119;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v50, AssociatedConformanceWitness);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  v54 = *(void (**)(char *, uint64_t))(v12 + 8);
  v54(v29, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
  if ((v50 & 1) == 0)
  {
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v54(v15, a3);
LABEL_17:
    a5 = v128;
    if (v49 < -128)
      goto LABEL_24;
LABEL_18:
    v57 = v129(a3, a4);
    v58 = v38(a3, a4);
    if ((v57 & 1) != 0)
    {
      if (v58 > 64)
        goto LABEL_20;
    }
    else if (v58 > 63)
    {
LABEL_20:
      v131 = 128;
      v61 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v62 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
      v61(&v131, &type metadata for Int, v62, a3, a4);
      v63 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
      v64 = *(void (**)(char *, uint64_t))(v12 + 8);
      v64(v29, a3);
      if ((v63 & 1) != 0)
        goto LABEL_24;
LABEL_25:
      v128 = a5;
      v66 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
      v67 = v127;
      v66(v127, a2, a3);
      v68 = v129(a3, a4);
      v69 = v125;
      v66(v125, (uint64_t)v67, a3);
      v116 = v38;
      if ((v68 & 1) == 0)
      {
        v64(v69, a3);
        v71 = v126;
        goto LABEL_46;
      }
      v70 = v38(a3, a4);
      v64(v69, a3);
      v71 = v126;
      if (v70 <= 64)
        goto LABEL_46;
      v72 = v118;
      v66(v118, (uint64_t)v67, a3);
      v131 = 0x8000000000000000;
      v73 = v129;
      if ((v129(a3, a4) & 1) != 0)
      {
        v74 = v116(a3, a4);
        if (v74 < 64)
        {
          v77 = v29;
LABEL_40:
          v66(v77, (uint64_t)v72, a3);
          v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v29, a3);
          if (v88 < v131)
LABEL_69:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
          goto LABEL_44;
        }
        v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v86 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
        v85(&v131, &type metadata for Int, v86, a3, a4);
        v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v72, v29, a3);
      }
      else
      {
        v78 = v73(a3, a4);
        v79 = v116(a3, a4);
        if ((v78 & 1) == 0)
        {
          if (v79 >= 64)
          {
            v114 = v118;
LABEL_45:
            v64(v114, a3);
LABEL_46:
            v98 = v116;
            v99 = v116(a3, a4);
            v100 = v124;
            v66(v124, (uint64_t)v67, a3);
            if (v99 < 65)
            {
              v109 = v98(a3, a4);
              v64(v100, a3);
              v110 = v109 == 64;
              v101 = v129;
              if (!v110 || (v129(a3, a4) & 1) != 0)
              {
LABEL_60:
                v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v64(v67, a3);
                if ((v112 & 0x8000000000000000) != 0)
                {
                  a5 = v128;
                  if (v112 > 0xFFFFFFFFFFFFFF80)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v131, v122, v123, v115);
                    goto LABEL_63;
                  }
                }
                else
                {
                  a5 = v128;
                  if (v112 < 0x80)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v131, v122, v123, v113);
LABEL_63:
                    v56 = v131;
                    goto LABEL_64;
                  }
                }
LABEL_24:
                result = 0;
                v56 = 0;
                goto LABEL_64;
              }
            }
            else
            {
              v64(v100, a3);
              v101 = v129;
            }
            v66(v71, (uint64_t)v67, a3);
            v131 = 0x7FFFFFFFFFFFFFFFLL;
            v102 = v101(a3, a4);
            v103 = v116(a3, a4);
            if ((v102 & 1) != 0)
            {
              if (v103 > 64)
              {
                v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
                v108 = &v131;
                goto LABEL_58;
              }
            }
            else if (v103 > 63)
            {
              v130 = 0x7FFFFFFFFFFFFFFFLL;
              v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              v108 = &v130;
LABEL_58:
              v106(v108, &type metadata for Int, v107, a3, a4);
              v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v71, a3);
              v64(v29, a3);
              if ((v111 & 1) != 0)
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
              goto LABEL_59;
            }
            v66(v29, (uint64_t)v71, a3);
            (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v64(v29, a3);
LABEL_59:
            v64(v71, a3);
            goto LABEL_60;
          }
          v77 = v29;
          v72 = v118;
          goto LABEL_40;
        }
        if (v79 <= 64)
        {
          v90 = AssociatedTypeWitness;
          v89 = (void (**)(char *, uint64_t, const char *))v121;
          v91 = swift_getAssociatedConformanceWitness((uint64_t)v121, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v92 = v119;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v91 + 8))(&qword_1816B7DA8, 256, v90, v91);
          v89[3](v92, a3, (const char *)v89);
          v93 = v118;
          LOBYTE(v89) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                           + 16))(v118, v29, a3);
          v64(v29, a3);
          v94 = v117;
          v66(v117, (uint64_t)v93, a3);
          if ((v89 & 1) != 0)
          {
            v64(v94, a3);
            goto LABEL_69;
          }
          v95 = v131;
          v96 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v94, a3);
          v97 = v96 < v95;
          v67 = v127;
          v72 = v118;
          if (v97)
            goto LABEL_69;
LABEL_44:
          v114 = v72;
          goto LABEL_45;
        }
        v82 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        v82(&v131, &type metadata for Int, v83, a3, a4);
        v72 = v118;
        v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v118, v29, a3);
      }
      v87 = v84;
      v64(v29, a3);
      if ((v87 & 1) != 0)
        goto LABEL_69;
      goto LABEL_44;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v64 = *(void (**)(char *, uint64_t))(v12 + 8);
    v64(v29, a3);
    if (v65 > 128)
      goto LABEL_24;
    goto LABEL_25;
  }
  v54(v15, a3);
  result = 0;
  v56 = 0;
  a5 = v128;
LABEL_64:
  *a5 = v56;
  a5[1] = result;
  return result;
}

unint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance _UInt128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  void (*v32)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v40;
  void (*v41)(char *, uint64_t);
  uint64_t v42;
  void (*v43)(char *, uint64_t, uint64_t);
  char *v44;
  char v45;
  char *v46;
  void (*v47)(char *, char *, uint64_t);
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  unint64_t v55;
  const char *v56;
  unint64_t AssociatedConformanceWitness;
  char *v58;
  void (*v59)(char *, uint64_t);
  uint64_t v60;
  unint64_t result;
  uint64_t v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void (*v67)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v68;
  char v69;
  void (*v70)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v71;
  char v72;
  uint64_t v73;
  void (**v74)(char *, uint64_t, const char *);
  unint64_t v75;
  unint64_t v76;
  char *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  BOOL v82;
  char *v83;
  uint64_t (*v84)(uint64_t, uint64_t);
  uint64_t v85;
  char *v86;
  char v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  void (*v91)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v92;
  uint64_t *v93;
  uint64_t v94;
  char *v95;
  char v96;
  char *v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  char v101;
  unint64_t *v102;
  char v103;
  uint64_t (*v104)(uint64_t, uint64_t);
  char *v105;
  char *v106;
  char *v107;
  unint64_t AssociatedTypeWitness;
  char *v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  uint64_t (*v114)(uint64_t, uint64_t);
  unint64_t *v115;
  uint64_t v116;
  uint64_t v117;

  v115 = a1;
  v109 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v109, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v107 = (char *)&v104 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v104 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v105 = (char *)&v104 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v112 = (char *)&v104 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v110 = (char *)&v104 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v106 = (char *)&v104 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v111 = (char *)&v104 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v113 = (char *)&v104 - v24;
  MEMORY[0x1E0C80A78](v23);
  v26 = (char *)&v104 - v25;
  v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    v31 = v27(a3, a4);
    v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v28 = v114(a3, a4);
    if ((v31 & 1) == 0)
    {
      if (v28 >= 64)
        goto LABEL_10;
      goto LABEL_9;
    }
    if (v28 <= 64)
    {
      v104 = v27;
      v55 = AssociatedTypeWitness;
      v56 = v109;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v58 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v55, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v56 + 3))(v58, a3, v56);
      LOBYTE(v55) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      v59 = *(void (**)(char *, uint64_t))(v9 + 8);
      v59(v26, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v55 & 1) != 0)
      {
        v59(v12, a3);
        goto LABEL_25;
      }
      v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v12, a3);
      v27 = v104;
      if (v60 < -128)
        goto LABEL_25;
      goto LABEL_10;
    }
LABEL_6:
    v117 = -128;
    v32 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v33 = lazy protocol witness table accessor for type Int and conformance Int(v28, v29, v30);
    v32(&v117, &type metadata for Int, v33, a3, a4);
    LOBYTE(v32) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
    if ((v32 & 1) != 0)
      goto LABEL_25;
    goto LABEL_10;
  }
  v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v28 = v114(a3, a4);
  if (v28 >= 64)
    goto LABEL_6;
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
  if (v34 < -128)
    goto LABEL_25;
LABEL_10:
  v35 = v27(a3, a4);
  v36 = v114(a3, a4);
  if ((v35 & 1) != 0)
  {
    if (v36 > 64)
      goto LABEL_12;
  }
  else if (v36 >= 64)
  {
LABEL_12:
    v117 = 128;
    v39 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
    v39(&v117, &type metadata for Int, v40, a3, a4);
    LOBYTE(v39) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    v41 = *(void (**)(char *, uint64_t))(v9 + 8);
    v41(v26, a3);
    if ((v39 & 1) != 0)
      goto LABEL_25;
    goto LABEL_16;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v41 = *(void (**)(char *, uint64_t))(v9 + 8);
  v41(v26, a3);
  if (v42 > 128)
    goto LABEL_25;
LABEL_16:
  v43 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v44 = v113;
  v43(v113, a2, a3);
  v45 = v27(a3, a4);
  v46 = v111;
  v47 = (void (*)(char *, char *, uint64_t))v43;
  v43(v111, (uint64_t)v44, a3);
  if ((v45 & 1) != 0)
  {
    v48 = v114(a3, a4);
    v41(v46, a3);
    if (v48 <= 64)
      goto LABEL_41;
    v49 = v106;
    v47(v106, v113, a3);
    v117 = 0x8000000000000000;
    if ((v27(a3, a4) & 1) != 0)
    {
      v50 = v114(a3, a4);
      if (v50 < 64)
      {
        v53 = v26;
        goto LABEL_35;
      }
      v70 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v71 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
      v70(&v117, &type metadata for Int, v71, a3, a4);
      v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v49, v26, a3);
      goto LABEL_30;
    }
    v63 = v27(a3, a4);
    v64 = v114(a3, a4);
    if ((v63 & 1) != 0)
    {
      if (v64 <= 64)
      {
        v75 = AssociatedTypeWitness;
        v74 = (void (**)(char *, uint64_t, const char *))v109;
        v76 = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v77 = v107;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))(&qword_1816B7DA8, 256, v75, v76);
        v74[3](v77, a3, (const char *)v74);
        v78 = v106;
        LOBYTE(v74) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v106, v26, a3);
        v41(v26, a3);
        v79 = v105;
        v47(v105, v78, a3);
        if ((v74 & 1) != 0)
        {
          v41(v79, a3);
          goto LABEL_61;
        }
        v80 = v117;
        v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v41(v79, a3);
        v82 = v81 < v80;
        v49 = v106;
        if (v82)
          goto LABEL_61;
LABEL_39:
        v54 = v49;
        goto LABEL_40;
      }
      v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v68 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
      v67(&v117, &type metadata for Int, v68, a3, a4);
      v49 = v106;
      v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v106, v26, a3);
LABEL_30:
      v72 = v69;
      v41(v26, a3);
      if ((v72 & 1) != 0)
        goto LABEL_61;
      goto LABEL_39;
    }
    if (v64 < 64)
    {
      v53 = v26;
      v49 = v106;
LABEL_35:
      v47(v53, v49, a3);
      v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v41(v26, a3);
      if (v73 < v117)
LABEL_61:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_39;
    }
    v54 = v106;
  }
  else
  {
    v54 = v46;
  }
LABEL_40:
  v41(v54, a3);
LABEL_41:
  v83 = v113;
  v84 = v114;
  v85 = v114(a3, a4);
  v86 = v110;
  v47(v110, v83, a3);
  if (v85 >= 65)
  {
    v41(v86, a3);
    goto LABEL_43;
  }
  v94 = v84(a3, a4);
  v41(v86, a3);
  if (v94 == 64 && (v27(a3, a4) & 1) == 0)
  {
LABEL_43:
    v47(v112, v113, a3);
    v117 = 0x7FFFFFFFFFFFFFFFLL;
    v87 = v27(a3, a4);
    v88 = v114(a3, a4);
    if ((v87 & 1) != 0)
    {
      if (v88 > 64)
      {
        v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
        v93 = &v117;
        goto LABEL_52;
      }
    }
    else if (v88 >= 64)
    {
      v116 = 0x7FFFFFFFFFFFFFFFLL;
      v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
      v93 = &v116;
LABEL_52:
      v91(v93, &type metadata for Int, v92, a3, a4);
      v95 = v112;
      v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v26, v112, a3);
      v41(v26, a3);
      if ((v96 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_53;
    }
    v95 = v112;
    v47(v26, v112, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v41(v26, a3);
LABEL_53:
    v41(v95, a3);
  }
  v97 = v113;
  v98 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v41(v97, a3);
  v99 = *v115;
  v100 = v115[1];
  if ((v98 & 0x8000000000000000) != 0)
  {
    if (v98 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v117, v100, v99, v103);
      goto LABEL_57;
    }
  }
  else if (v98 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v117, v100, v99, v101);
LABEL_57:
    v62 = v117;
    goto LABEL_58;
  }
LABEL_25:
  result = 0;
  v62 = 0;
LABEL_58:
  v102 = v115;
  *v115 = v62;
  v102[1] = result;
  return result;
}

unint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance _UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  char v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, uint64_t);
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v44;
  char v45;
  void (*v46)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  const char *v51;
  unint64_t AssociatedConformanceWitness;
  char *v53;
  void (*v54)(char *, uint64_t);
  unint64_t result;
  uint64_t v56;
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v62;
  char v63;
  void (*v64)(char *, uint64_t);
  uint64_t v65;
  void (*v66)(char *, uint64_t, uint64_t);
  char *v67;
  char v68;
  char *v69;
  uint64_t v70;
  char *v71;
  char *v72;
  uint64_t (*v73)(uint64_t, uint64_t);
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void (*v82)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v83;
  char v84;
  void (*v85)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v86;
  char v87;
  uint64_t v88;
  void (**v89)(char *, uint64_t, const char *);
  unint64_t v90;
  unint64_t v91;
  char *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  uint64_t v96;
  BOOL v97;
  uint64_t (*v98)(uint64_t, uint64_t);
  uint64_t v99;
  char *v100;
  uint64_t (*v101)(uint64_t, uint64_t);
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void (*v106)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  BOOL v110;
  char v111;
  unint64_t v112;
  char v113;
  char *v114;
  char v115;
  uint64_t (*v116)(uint64_t, uint64_t);
  char *v117;
  char *v118;
  char *v119;
  unint64_t AssociatedTypeWitness;
  char *v121;
  unint64_t v122;
  unint64_t v123;
  char *v124;
  char *v125;
  char *v126;
  char *v127;
  uint64_t *v128;
  uint64_t (*v129)(uint64_t, uint64_t);
  uint64_t v130;
  uint64_t v131;

  v121 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v121, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v119 = (char *)&v116 - v11;
  v12 = *(_QWORD *)(a3 - 8);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v116 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v117 = (char *)&v116 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v126 = (char *)&v116 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v124 = (char *)&v116 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v118 = (char *)&v116 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v125 = (char *)&v116 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v127 = (char *)&v116 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v116 - v28;
  v30 = *a1;
  v122 = a1[1];
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v32 = v31(a3, a4);
  v123 = v30;
  v129 = v31;
  if ((v32 & 1) != 0)
  {
    v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v34 = v33(a3, a4);
    if (v34 >= 64)
    {
      v131 = -128;
      v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v47 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
      v46(&v131, &type metadata for Int, v47, a3, a4);
      v48 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = v33;
      if ((v48 & 1) != 0)
        goto LABEL_24;
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      v38 = v33;
      if (v37 < -128)
        goto LABEL_24;
    }
    goto LABEL_18;
  }
  v128 = a5;
  v39 = v31(a3, a4);
  v38 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v40 = v38(a3, a4);
  if ((v39 & 1) == 0)
  {
    if (v40 >= 64)
    {
      a5 = v128;
      goto LABEL_18;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    goto LABEL_17;
  }
  if (v40 > 64)
  {
    v131 = -128;
    v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v44 = lazy protocol witness table accessor for type Int and conformance Int(v40, v41, v42);
    v43(&v131, &type metadata for Int, v44, a3, a4);
    v45 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    a5 = v128;
    if ((v45 & 1) != 0)
      goto LABEL_24;
    goto LABEL_18;
  }
  v50 = AssociatedTypeWitness;
  v51 = v121;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v121, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v53 = v119;
  (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v50, AssociatedConformanceWitness);
  (*((void (**)(char *, uint64_t, const char *))v51 + 3))(v53, a3, v51);
  LOBYTE(v50) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  v54 = *(void (**)(char *, uint64_t))(v12 + 8);
  v54(v29, a3);
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
  if ((v50 & 1) == 0)
  {
    v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v54(v15, a3);
LABEL_17:
    a5 = v128;
    if (v49 < -128)
      goto LABEL_24;
LABEL_18:
    v57 = v129(a3, a4);
    v58 = v38(a3, a4);
    if ((v57 & 1) != 0)
    {
      if (v58 > 64)
        goto LABEL_20;
    }
    else if (v58 > 63)
    {
LABEL_20:
      v131 = 128;
      v61 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v62 = lazy protocol witness table accessor for type Int and conformance Int(v58, v59, v60);
      v61(&v131, &type metadata for Int, v62, a3, a4);
      v63 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
      v64 = *(void (**)(char *, uint64_t))(v12 + 8);
      v64(v29, a3);
      if ((v63 & 1) != 0)
        goto LABEL_24;
LABEL_25:
      v128 = a5;
      v66 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
      v67 = v127;
      v66(v127, a2, a3);
      v68 = v129(a3, a4);
      v69 = v125;
      v66(v125, (uint64_t)v67, a3);
      v116 = v38;
      if ((v68 & 1) == 0)
      {
        v64(v69, a3);
        v71 = v126;
        goto LABEL_46;
      }
      v70 = v38(a3, a4);
      v64(v69, a3);
      v71 = v126;
      if (v70 <= 64)
        goto LABEL_46;
      v72 = v118;
      v66(v118, (uint64_t)v67, a3);
      v131 = 0x8000000000000000;
      v73 = v129;
      if ((v129(a3, a4) & 1) != 0)
      {
        v74 = v116(a3, a4);
        if (v74 < 64)
        {
          v77 = v29;
LABEL_40:
          v66(v77, (uint64_t)v72, a3);
          v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v29, a3);
          if (v88 < v131)
LABEL_69:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
          goto LABEL_44;
        }
        v85 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v86 = lazy protocol witness table accessor for type Int and conformance Int(v74, v75, v76);
        v85(&v131, &type metadata for Int, v86, a3, a4);
        v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v72, v29, a3);
      }
      else
      {
        v78 = v73(a3, a4);
        v79 = v116(a3, a4);
        if ((v78 & 1) == 0)
        {
          if (v79 >= 64)
          {
            v114 = v118;
LABEL_45:
            v64(v114, a3);
LABEL_46:
            v98 = v116;
            v99 = v116(a3, a4);
            v100 = v124;
            v66(v124, (uint64_t)v67, a3);
            if (v99 < 65)
            {
              v109 = v98(a3, a4);
              v64(v100, a3);
              v110 = v109 == 64;
              v101 = v129;
              if (!v110 || (v129(a3, a4) & 1) != 0)
              {
LABEL_60:
                v112 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v64(v67, a3);
                if ((v112 & 0x8000000000000000) != 0)
                {
                  a5 = v128;
                  if (v112 > 0xFFFFFFFFFFFFFF80)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v131, v122, v123, v115);
                    goto LABEL_63;
                  }
                }
                else
                {
                  a5 = v128;
                  if (v112 < 0x80)
                  {
                    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
                    result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v131, v122, v123, v113);
LABEL_63:
                    v56 = v131;
                    goto LABEL_64;
                  }
                }
LABEL_24:
                result = 0;
                v56 = 0;
                goto LABEL_64;
              }
            }
            else
            {
              v64(v100, a3);
              v101 = v129;
            }
            v66(v71, (uint64_t)v67, a3);
            v131 = 0x7FFFFFFFFFFFFFFFLL;
            v102 = v101(a3, a4);
            v103 = v116(a3, a4);
            if ((v102 & 1) != 0)
            {
              if (v103 > 64)
              {
                v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
                v108 = &v131;
                goto LABEL_58;
              }
            }
            else if (v103 > 63)
            {
              v130 = 0x7FFFFFFFFFFFFFFFLL;
              v106 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v107 = lazy protocol witness table accessor for type Int and conformance Int(v103, v104, v105);
              v108 = &v130;
LABEL_58:
              v106(v108, &type metadata for Int, v107, a3, a4);
              v111 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v71, a3);
              v64(v29, a3);
              if ((v111 & 1) != 0)
                _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
              goto LABEL_59;
            }
            v66(v29, (uint64_t)v71, a3);
            (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
            v64(v29, a3);
LABEL_59:
            v64(v71, a3);
            goto LABEL_60;
          }
          v77 = v29;
          v72 = v118;
          goto LABEL_40;
        }
        if (v79 <= 64)
        {
          v90 = AssociatedTypeWitness;
          v89 = (void (**)(char *, uint64_t, const char *))v121;
          v91 = swift_getAssociatedConformanceWitness((uint64_t)v121, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v92 = v119;
          (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v91 + 8))(&qword_1816B7DA8, 256, v90, v91);
          v89[3](v92, a3, (const char *)v89);
          v93 = v118;
          LOBYTE(v89) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                           + 16))(v118, v29, a3);
          v64(v29, a3);
          v94 = v117;
          v66(v117, (uint64_t)v93, a3);
          if ((v89 & 1) != 0)
          {
            v64(v94, a3);
            goto LABEL_69;
          }
          v95 = v131;
          v96 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v64(v94, a3);
          v97 = v96 < v95;
          v67 = v127;
          v72 = v118;
          if (v97)
            goto LABEL_69;
LABEL_44:
          v114 = v72;
          goto LABEL_45;
        }
        v82 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v83 = lazy protocol witness table accessor for type Int and conformance Int(v79, v80, v81);
        v82(&v131, &type metadata for Int, v83, a3, a4);
        v72 = v118;
        v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v118, v29, a3);
      }
      v87 = v84;
      v64(v29, a3);
      if ((v87 & 1) != 0)
        goto LABEL_69;
      goto LABEL_44;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v64 = *(void (**)(char *, uint64_t))(v12 + 8);
    v64(v29, a3);
    if (v65 > 128)
      goto LABEL_24;
    goto LABEL_25;
  }
  v54(v15, a3);
  result = 0;
  v56 = 0;
  a5 = v128;
LABEL_64:
  *a5 = v56;
  a5[1] = result;
  return result;
}

unint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance _UInt128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  void (*v32)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v40;
  void (*v41)(char *, uint64_t);
  uint64_t v42;
  void (*v43)(char *, uint64_t, uint64_t);
  char *v44;
  char v45;
  char *v46;
  void (*v47)(char *, char *, uint64_t);
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  unint64_t v55;
  const char *v56;
  unint64_t AssociatedConformanceWitness;
  char *v58;
  void (*v59)(char *, uint64_t);
  uint64_t v60;
  unint64_t result;
  uint64_t v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void (*v67)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v68;
  char v69;
  void (*v70)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v71;
  char v72;
  uint64_t v73;
  void (**v74)(char *, uint64_t, const char *);
  unint64_t v75;
  unint64_t v76;
  char *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  BOOL v82;
  char *v83;
  uint64_t (*v84)(uint64_t, uint64_t);
  uint64_t v85;
  char *v86;
  char v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  void (*v91)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v92;
  uint64_t *v93;
  uint64_t v94;
  char *v95;
  char v96;
  char *v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  char v101;
  unint64_t *v102;
  char v103;
  uint64_t (*v104)(uint64_t, uint64_t);
  char *v105;
  char *v106;
  char *v107;
  unint64_t AssociatedTypeWitness;
  char *v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  uint64_t (*v114)(uint64_t, uint64_t);
  unint64_t *v115;
  uint64_t v116;
  uint64_t v117;

  v115 = a1;
  v109 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v109, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v107 = (char *)&v104 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v104 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v105 = (char *)&v104 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v112 = (char *)&v104 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v110 = (char *)&v104 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v106 = (char *)&v104 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v111 = (char *)&v104 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v113 = (char *)&v104 - v24;
  MEMORY[0x1E0C80A78](v23);
  v26 = (char *)&v104 - v25;
  v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    v31 = v27(a3, a4);
    v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v28 = v114(a3, a4);
    if ((v31 & 1) == 0)
    {
      if (v28 >= 64)
        goto LABEL_10;
      goto LABEL_9;
    }
    if (v28 <= 64)
    {
      v104 = v27;
      v55 = AssociatedTypeWitness;
      v56 = v109;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v58 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v55, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v56 + 3))(v58, a3, v56);
      LOBYTE(v55) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      v59 = *(void (**)(char *, uint64_t))(v9 + 8);
      v59(v26, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v55 & 1) != 0)
      {
        v59(v12, a3);
        goto LABEL_25;
      }
      v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v59(v12, a3);
      v27 = v104;
      if (v60 < -128)
        goto LABEL_25;
      goto LABEL_10;
    }
LABEL_6:
    v117 = -128;
    v32 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v33 = lazy protocol witness table accessor for type Int and conformance Int(v28, v29, v30);
    v32(&v117, &type metadata for Int, v33, a3, a4);
    LOBYTE(v32) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
    if ((v32 & 1) != 0)
      goto LABEL_25;
    goto LABEL_10;
  }
  v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  v28 = v114(a3, a4);
  if (v28 >= 64)
    goto LABEL_6;
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v26, a3);
  if (v34 < -128)
    goto LABEL_25;
LABEL_10:
  v35 = v27(a3, a4);
  v36 = v114(a3, a4);
  if ((v35 & 1) != 0)
  {
    if (v36 > 64)
      goto LABEL_12;
  }
  else if (v36 >= 64)
  {
LABEL_12:
    v117 = 128;
    v39 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    v40 = lazy protocol witness table accessor for type Int and conformance Int(v36, v37, v38);
    v39(&v117, &type metadata for Int, v40, a3, a4);
    LOBYTE(v39) = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    v41 = *(void (**)(char *, uint64_t))(v9 + 8);
    v41(v26, a3);
    if ((v39 & 1) != 0)
      goto LABEL_25;
    goto LABEL_16;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v26, a2, a3);
  v42 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v41 = *(void (**)(char *, uint64_t))(v9 + 8);
  v41(v26, a3);
  if (v42 > 128)
    goto LABEL_25;
LABEL_16:
  v43 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
  v44 = v113;
  v43(v113, a2, a3);
  v45 = v27(a3, a4);
  v46 = v111;
  v47 = (void (*)(char *, char *, uint64_t))v43;
  v43(v111, (uint64_t)v44, a3);
  if ((v45 & 1) != 0)
  {
    v48 = v114(a3, a4);
    v41(v46, a3);
    if (v48 <= 64)
      goto LABEL_41;
    v49 = v106;
    v47(v106, v113, a3);
    v117 = 0x8000000000000000;
    if ((v27(a3, a4) & 1) != 0)
    {
      v50 = v114(a3, a4);
      if (v50 < 64)
      {
        v53 = v26;
        goto LABEL_35;
      }
      v70 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v71 = lazy protocol witness table accessor for type Int and conformance Int(v50, v51, v52);
      v70(&v117, &type metadata for Int, v71, a3, a4);
      v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v49, v26, a3);
      goto LABEL_30;
    }
    v63 = v27(a3, a4);
    v64 = v114(a3, a4);
    if ((v63 & 1) != 0)
    {
      if (v64 <= 64)
      {
        v75 = AssociatedTypeWitness;
        v74 = (void (**)(char *, uint64_t, const char *))v109;
        v76 = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v77 = v107;
        (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))(&qword_1816B7DA8, 256, v75, v76);
        v74[3](v77, a3, (const char *)v74);
        v78 = v106;
        LOBYTE(v74) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v106, v26, a3);
        v41(v26, a3);
        v79 = v105;
        v47(v105, v78, a3);
        if ((v74 & 1) != 0)
        {
          v41(v79, a3);
          goto LABEL_61;
        }
        v80 = v117;
        v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v41(v79, a3);
        v82 = v81 < v80;
        v49 = v106;
        if (v82)
          goto LABEL_61;
LABEL_39:
        v54 = v49;
        goto LABEL_40;
      }
      v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v68 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
      v67(&v117, &type metadata for Int, v68, a3, a4);
      v49 = v106;
      v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v106, v26, a3);
LABEL_30:
      v72 = v69;
      v41(v26, a3);
      if ((v72 & 1) != 0)
        goto LABEL_61;
      goto LABEL_39;
    }
    if (v64 < 64)
    {
      v53 = v26;
      v49 = v106;
LABEL_35:
      v47(v53, v49, a3);
      v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v41(v26, a3);
      if (v73 < v117)
LABEL_61:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_39;
    }
    v54 = v106;
  }
  else
  {
    v54 = v46;
  }
LABEL_40:
  v41(v54, a3);
LABEL_41:
  v83 = v113;
  v84 = v114;
  v85 = v114(a3, a4);
  v86 = v110;
  v47(v110, v83, a3);
  if (v85 >= 65)
  {
    v41(v86, a3);
    goto LABEL_43;
  }
  v94 = v84(a3, a4);
  v41(v86, a3);
  if (v94 == 64 && (v27(a3, a4) & 1) == 0)
  {
LABEL_43:
    v47(v112, v113, a3);
    v117 = 0x7FFFFFFFFFFFFFFFLL;
    v87 = v27(a3, a4);
    v88 = v114(a3, a4);
    if ((v87 & 1) != 0)
    {
      if (v88 > 64)
      {
        v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
        v93 = &v117;
        goto LABEL_52;
      }
    }
    else if (v88 >= 64)
    {
      v116 = 0x7FFFFFFFFFFFFFFFLL;
      v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      v92 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
      v93 = &v116;
LABEL_52:
      v91(v93, &type metadata for Int, v92, a3, a4);
      v95 = v112;
      v96 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v26, v112, a3);
      v41(v26, a3);
      if ((v96 & 1) != 0)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      goto LABEL_53;
    }
    v95 = v112;
    v47(v26, v112, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v41(v26, a3);
LABEL_53:
    v41(v95, a3);
  }
  v97 = v113;
  v98 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v41(v97, a3);
  v99 = *v115;
  v100 = v115[1];
  if ((v98 & 0x8000000000000000) != 0)
  {
    if (v98 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)&v117, v100, v99, v103);
      goto LABEL_57;
    }
  }
  else if (v98 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v117, v100, v99, v101);
LABEL_57:
    v62 = v117;
    goto LABEL_58;
  }
LABEL_25:
  result = 0;
  v62 = 0;
LABEL_58:
  v102 = v115;
  *v115 = v62;
  v102[1] = result;
  return result;
}

Swift::UInt64 protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance _UInt128(_QWORD *a1, _QWORD *a2, unint64_t *a3)
{
  Swift::UInt64 *v3;
  unint64_t v6;
  unint64_t v7;
  Swift::UInt64 result;
  Swift::UInt64 v9;
  uint64_t v10;
  uint64_t v11;
  Swift::UInt64 v12;
  Swift::UInt64 v13;
  Swift::tuple_high_UInt64_low_UInt64 v14;

  v7 = *a3;
  v6 = a3[1];
  v14.low = v3[1];
  v14.high = (Swift::UInt64)&v11;
  result = specialized _wideDivide22<A>(_:by:)(&v13, &v12, v14, *v3, v6, v7);
  v9 = v12;
  v10 = v11;
  *a1 = v13;
  a1[1] = result;
  *a2 = v10;
  a2[1] = v9;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance _UInt128(unint64_t *a1)
{
  Swift::UInt64 *v1;
  unint64_t v2;
  unint64_t v3;
  Swift::UInt64 v4;
  Swift::UInt64 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;

  v2 = *a1;
  v3 = a1[1];
  v5 = *v1;
  v4 = v1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  if (v3 == v7 && v2 == v6)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    v13 = v5 == v16;
    v15 = v4 == v17;
  }
  else
  {
    v9 = specialized static _UInt128.% infix(_:_:)(v5, v4, v2, v3);
    v11 = v10;
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    v13 = v9 == v12;
    v15 = v11 == v14;
  }
  return v15 && v13;
}

void protocol witness for BinaryInteger.signum() in conformance _UInt128(_QWORD *a1@<X8>)
{
  _OWORD *v1;

  *a1 = *v1 != 0;
  a1[1] = 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

void protocol witness for Strideable.distance(to:) in conformance _UInt128(unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _BOOL4 v8;
  unint64_t v9;
  unint64_t v10;
  _BOOL4 v11;
  unint64_t v12;
  _BOOL4 v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v5 = *a1;
  v4 = a1[1];
  v7 = *v2;
  v6 = v2[1];
  v8 = *a1 < *v2;
  if (v4 != v6)
    v8 = v4 < v6;
  if (v8)
  {
    v9 = v7 - v5;
    v10 = v6 - v4;
    v11 = v6 < v4;
    if (v7 >= v5)
    {
      if (v11)
        goto LABEL_13;
      goto LABEL_15;
    }
    if (!v10)
      LOBYTE(v11) = 1;
    if (!v11)
    {
      --v10;
LABEL_15:
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      v13 = v15 < v9;
      if (v14 != v10)
        v13 = v14 < v10;
      if (v13)
LABEL_28:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
      v16 = __OFSUB__(0, v9);
      v12 = -(uint64_t)v9;
      if (!v16)
        goto LABEL_27;
      __break(1u);
      goto LABEL_21;
    }
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x5FuLL, 0);
  }
  v12 = v5 - v7;
  v10 = v4 - v6;
  v13 = v4 < v6;
  if (v5 < v7)
  {
    if (!v10)
      LOBYTE(v13) = 1;
    if (!v13)
    {
      --v10;
      goto LABEL_24;
    }
    goto LABEL_13;
  }
LABEL_21:
  if (v13)
    goto LABEL_13;
LABEL_24:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  v19 = v18 < v12;
  if (v17 != v10)
    v19 = v17 < v10;
  if (v19)
    goto LABEL_28;
LABEL_27:
  *a2 = v12;
}

uint64_t *protocol witness for Strideable.advanced(by:) in conformance _UInt128@<X0>(uint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v3 = *result;
  v5 = *v2;
  v4 = v2[1];
  if (*result < 0)
  {
    v9 = -v3;
    v6 = v5 >= v9;
    v7 = v5 - v9;
    v10 = !v6;
    v8 = v10 << 63 >> 63;
    if (!v4 && (v10 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x5FuLL, 0);
  }
  else
  {
    v6 = __CFADD__(v5, v3);
    v7 = v5 + v3;
    v8 = v6;
    if (v4 == -1 && (v8 & 1) != 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x6BuLL, 0);
  }
  *a2 = v7;
  a2[1] = v8 + v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(uint64_t a1, uint64_t a2, char a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _Int128(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, _QWORD, _QWORD, _QWORD))specialized BinaryInteger._description(radix:uppercase:));
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, _QWORD, _QWORD))
{
  _QWORD *v3;

  return a3(10, 0, *v3, v3[1]);
}

_QWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance _Int128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  BOOL v6;
  uint64_t v7;
  BOOL v8;

  v3 = result[1];
  v4 = a2[1];
  v5 = __CFADD__(*result, *a2);
  v6 = __OFADD__(v3, v4);
  v7 = v3 + v4;
  if (v6 || (v5 ? (v8 = v7 == 0x7FFFFFFFFFFFFFFFLL) : (v8 = 0), v8))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  *a3 = *result + *a2;
  a3[1] = v7 + v5;
  return result;
}

_QWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance _Int128(_QWORD *a1, uint64_t *a2)
{
  return specialized static _Int128.+= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance _Int128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  int v9;
  BOOL v10;
  unint64_t v11;

  v4 = *result;
  v3 = result[1];
  v6 = *a2;
  v5 = a2[1];
  v7 = __OFSUB__(v3, v5);
  v8 = v3 - v5;
  v9 = v7;
  v10 = v4 >= v6;
  v11 = v4 - v6;
  if (v10)
  {
    if (v9)
      goto LABEL_8;
  }
  else
  {
    if (v8 == 0x8000000000000000)
      LOBYTE(v9) = 1;
    if ((v9 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v8;
  }
  *a3 = v11;
  a3[1] = v8;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance _Int128(unint64_t *a1, uint64_t a2)
{
  return specialized static _Int128.-= infix(_:_:)(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8));
}

uint64_t _Int128.init<A>(exactly:)(void (*a1)(char *, char *, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  char *v52;
  void (*v53)(void);
  uint64_t v54;
  uint64_t v55;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v57)(unint64_t *, unint64_t);
  void (*v58)(char *, void (*)(_QWORD, _QWORD), unint64_t *);
  const char *v59;
  unint64_t v60;
  unint64_t v61;
  char v62;
  char *v63;
  void (*v64)(char *, unint64_t *);
  char *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t (*v68)(unint64_t *, unint64_t);
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void (*v77)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t);
  unint64_t v78;
  char *v79;
  unint64_t v80;
  char *v81;
  char v82;
  char *v83;
  void (*v84)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t);
  unint64_t v85;
  void (*v86)(char *, unint64_t *);
  char *v87;
  unint64_t v88;
  char *v89;
  const char *v90;
  uint64_t v91;
  unint64_t v92;
  char *v93;
  char *v94;
  unint64_t v95;
  char *v96;
  void (*v97)(char *, unint64_t *);
  unint64_t v98;
  char *v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  BOOL v103;
  char *v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  void (*v108)(unint64_t *, ValueMetadata *);
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  char *v112;
  char *v113;
  char *v114;
  uint64_t v115;
  uint64_t (*v116)(char *, uint64_t);
  uint64_t v117;
  void (*v118)(void (*)(_QWORD, _QWORD, _QWORD), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  void (*v122)(char *, char *, uint64_t);
  char *v123;
  char *v124;
  char v125;
  char *v126;
  char *v127;
  const char *v128;
  unint64_t v129;
  unint64_t v130;
  char *v131;
  char *v132;
  void (*v133)(char *, char *, uint64_t);
  char v134;
  uint64_t v135;
  const char *v136;
  unint64_t v137;
  unint64_t v138;
  char *v139;
  char *v140;
  char *v141;
  unint64_t v142;
  char *v143;
  unint64_t v144;
  char *v145;
  char *v146;
  char v147;
  char *v148;
  char *v149;
  unint64_t v150;
  char *v151;
  uint64_t v152;
  char *v153;
  uint64_t (*v154)(_QWORD, char *, uint64_t);
  void (*v155)(char *, char *, uint64_t);
  char v156;
  void (*v157)(void (*)(char *, char *, uint64_t), uint64_t);
  uint64_t v158;
  char v159;
  uint64_t v160;
  void (*v161)(char *, char *, uint64_t);
  char *v162;
  uint64_t (*v163)(uint64_t, uint64_t);
  uint64_t v164;
  char *v165;
  uint64_t v166;
  char *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  char *v175;
  void (*v176)(uint64_t, uint64_t);
  uint64_t v177;
  char v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  void (*v182)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v183;
  char *v184;
  char *v185;
  char v186;
  char *v187;
  uint64_t v188;
  char v189;
  char *v190;
  char *v191;
  char *v192;
  uint64_t v193;
  void (*v194)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v195;
  uint64_t v196;
  unint64_t v197;
  char *v198;
  char v199;
  unint64_t v200;
  char *v201;
  char v202;
  uint64_t v203;
  const char *v204;
  unint64_t v205;
  unint64_t v206;
  char *v207;
  char *v208;
  uint64_t v209;
  char *v210;
  char *v211;
  int64_t v212;
  uint64_t v213;
  uint64_t v215;
  char *v216;
  char *v217;
  char *v218;
  char *v219;
  unint64_t v220;
  char *v221;
  char *v222;
  char *v223;
  unint64_t AssociatedTypeWitness;
  const char *v225;
  char *v226;
  char *v227;
  uint64_t (*v228)(unint64_t *, unint64_t);
  char *v229;
  char *v230;
  char *v231;
  char *v232;
  char *v233;
  char *v234;
  const char *v235;
  void (*v236)(char *, void (*)(_QWORD, _QWORD), unint64_t *);
  uint64_t v237;
  char *v238;
  char *v239;
  char *v240;
  void (*v241)(char *, char *, uint64_t);
  uint64_t v242;
  uint64_t v243;
  unint64_t v244;
  char *v245;
  char *v246;
  uint64_t v247;
  uint64_t v248;
  unint64_t v249;

  v247 = a3;
  v4 = *(_QWORD *)(a3 + 24);
  v225 = *(const char **)(v4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v225, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v6 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v223 = (char *)&v215 - v7;
  v243 = *(_QWORD *)(a2 - 8);
  v8 = MEMORY[0x1E0C80A78](v6);
  v216 = (char *)&v215 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = MEMORY[0x1E0C80A78](v8);
  v218 = (char *)&v215 - v11;
  v12 = MEMORY[0x1E0C80A78](v10);
  v234 = (char *)&v215 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v226 = (char *)&v215 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v229 = (char *)&v215 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v217 = (char *)&v215 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v230 = (char *)&v215 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v233 = (char *)&v215 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v232 = (char *)&v215 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v222 = (char *)&v215 - v27;
  v28 = MEMORY[0x1E0C80A78](v26);
  v239 = (char *)&v215 - v29;
  v30 = MEMORY[0x1E0C80A78](v28);
  v238 = (char *)&v215 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v246 = (char *)&v215 - v33;
  MEMORY[0x1E0C80A78](v32);
  v231 = (char *)&v215 - v34;
  v242 = a2;
  v35 = swift_getAssociatedTypeWitness(255, (const char *)v4, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  v235 = *(const char **)(swift_getAssociatedConformanceWitness(v4, a2, v35, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  v36 = swift_getAssociatedTypeWitness(0, v235, v35, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1E0C80A78](v36);
  v38 = (char *)&v215 - v37;
  v39 = swift_checkMetadataState(0, v35);
  v40 = *(v39 - 1);
  v41 = MEMORY[0x1E0C80A78](v39);
  v221 = (char *)&v215 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0);
  v43 = MEMORY[0x1E0C80A78](v41);
  v245 = (char *)&v215 - v44;
  v45 = MEMORY[0x1E0C80A78](v43);
  v47 = (char *)&v215 - v46;
  v48 = MEMORY[0x1E0C80A78](v45);
  v50 = (char *)&v215 - v49;
  MEMORY[0x1E0C80A78](v48);
  v52 = (char *)&v215 - v51;
  v53 = *(void (**)(void))(v4 + 56);
  v241 = a1;
  v54 = v4;
  v55 = v242;
  v53();
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v247, v55, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for BinaryInteger, (uint64_t)&associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  v57 = *(uint64_t (**)(unint64_t *, unint64_t))(AssociatedConformanceWitness + 64);
  v244 = AssociatedConformanceWitness;
  v228 = v57;
  LOBYTE(a1) = ((uint64_t (*)(unint64_t *))v57)(v39);
  v58 = *(void (**)(char *, void (*)(_QWORD, _QWORD), unint64_t *))(v40 + 16);
  v240 = v52;
  v236 = v58;
  v58(v50, (void (*)(_QWORD, _QWORD))v52, v39);
  v237 = v54;
  v227 = v47;
  v220 = v36;
  v219 = v38;
  if ((a1 & 1) != 0)
  {
    v59 = v235;
    v60 = swift_getAssociatedConformanceWitness((uint64_t)v235, (uint64_t)v39, v36, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v60 + 8))(&unk_1816B7DA8, 256, v36, v60);
    (*((void (**)(char *, unint64_t *, const char *))v59 + 3))(v38, v39, v59);
    v61 = swift_getAssociatedConformanceWitness(v54, v55, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    v62 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v61 + 16))(v50, v47, v39, v61);
    v63 = v47;
    v64 = *(void (**)(char *, unint64_t *))(v40 + 8);
    v64(v63, v39);
    v64(v50, v39);
    v65 = v240;
    v66 = v55;
    if ((v62 & 1) != 0)
      goto LABEL_19;
  }
  else
  {
    v64 = *(void (**)(char *, unint64_t *))(v40 + 8);
    v64(v50, v39);
    v65 = v240;
    v66 = v55;
  }
  v67 = v244;
  v68 = *(uint64_t (**)(unint64_t *, unint64_t))(v244 + 128);
  v69 = v68(v39, v244);
  v70 = v245;
  v236(v245, (void (*)(_QWORD, _QWORD))v65, v39);
  if (v69 <= 63)
  {
    v64(v70, v39);
    v71 = v247;
    v72 = v237;
    goto LABEL_34;
  }
  v249 = -1;
  v73 = v228(v39, v67);
  v74 = v68(v39, v67);
  if ((v73 & 1) != 0)
  {
    v240 = (char *)v64;
    v71 = v247;
    v72 = v237;
    if (v74 >= 65)
    {
      v67 = v244;
      v77 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v244 + 96);
      v78 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v74, v75, v76);
      v79 = v227;
      v77(&v249, &type metadata for UInt64, v78, v39, v67);
      v80 = swift_getAssociatedConformanceWitness(v72, v66, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      v81 = v245;
      v82 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v80 + 16))(v79, v245, v39, v80);
      v83 = v79;
      v64 = (void (*)(char *, unint64_t *))v240;
      ((void (*)(char *, unint64_t *))v240)(v83, v39);
      goto LABEL_12;
    }
    v90 = v235;
    v91 = v220;
    v92 = swift_getAssociatedConformanceWitness((uint64_t)v235, (uint64_t)v39, v220, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    v93 = v219;
    (*(void (**)(void *, uint64_t, uint64_t, unint64_t))(v92 + 8))(&unk_1816B7DA8, 256, v91, v92);
    v94 = v227;
    (*((void (**)(char *, unint64_t *, const char *))v90 + 3))(v93, v39, v90);
    v95 = swift_getAssociatedConformanceWitness(v72, v66, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    v96 = v245;
    LODWORD(v236) = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v95 + 40))(v245, v94, v39, v95);
    v97 = (void (*)(char *, unint64_t *))v240;
    ((void (*)(char *, unint64_t *))v240)(v94, v39);
    v98 = v249;
    v99 = v221;
    (*(void (**)(char *, char *, unint64_t *))(v40 + 32))(v221, v96, v39);
    if ((v236 & 1) != 0)
    {
      v100 = v71;
      v101 = v244;
      v102 = (*(uint64_t (**)(unint64_t *, unint64_t))(v244 + 120))(v39, v244);
      v97(v99, v39);
      v103 = v98 >= v102;
      v64 = v97;
      v67 = v101;
      v71 = v100;
      if (!v103)
      {
LABEL_19:
        v106 = ((uint64_t (*)(char *, unint64_t *))v64)(v65, v39);
        v249 = -1;
        v107 = v247;
        v108 = *(void (**)(unint64_t *, ValueMetadata *))(v247 + 88);
        v111 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v106, v109, v110);
        v112 = v246;
        v240 = (char *)v111;
        v108(&v249, &type metadata for UInt64);
        v113 = v231;
        v114 = (char *)v241;
        (*(void (**)(void (*)(char *, char *, uint64_t), char *, uint64_t, uint64_t))(v107 + 192))(v241, v112, v66, v107);
        v115 = v243;
        v116 = *(uint64_t (**)(char *, uint64_t))(v243 + 8);
        v117 = v116(v112, v66);
        v249 = 64;
        v118 = *(void (**)(void (*)(_QWORD, _QWORD, _QWORD), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v107 + 240);
        v121 = lazy protocol witness table accessor for type Int and conformance Int(v117, v119, v120);
        v118((void (*)(_QWORD, _QWORD, _QWORD))v114, &v249, &type metadata for Int, v121, v66, v107);
        v116(v114, v66);
        v122 = *(void (**)(char *, char *, uint64_t))(v115 + 32);
        v123 = v239;
        v122(v239, v113, v66);
        v124 = *(char **)(v107 + 64);
        v125 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v66, v107);
        v126 = v233;
        v245 = v124;
        v241 = v122;
        if ((v125 & 1) != 0)
        {
          v127 = v222;
          (*(void (**)(char *, char *, uint64_t))(v115 + 16))(v222, v123, v66);
          v128 = v225;
          v129 = AssociatedTypeWitness;
          v130 = swift_getAssociatedConformanceWitness((uint64_t)v225, v66, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v131 = v223;
          (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v130 + 8))(&unk_1816B7DA8, 256, v129, v130);
          v132 = v246;
          (*((void (**)(char *, uint64_t, const char *))v128 + 3))(v131, v66, v128);
          LOBYTE(v129) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v107 + 32) + 8)
                                                                            + 32))(v127, v132, v66);
          v116(v132, v66);
          if ((v129 & 1) == 0)
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
          v116(v127, v66);
          v123 = v239;
          v122 = v241;
          v124 = v245;
        }
        v244 = *(_QWORD *)(v107 + 128);
        if (((uint64_t (*)(uint64_t, uint64_t))v244)(v66, v107) < 64)
        {
LABEL_39:
          v243 = *(_QWORD *)(v107 + 120);
          v158 = ((uint64_t (*)(uint64_t, uint64_t))v243)(v66, v107);
          v116(v123, v66);
          v122(v126, v238, v66);
          v159 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v66, v107);
          v160 = v107;
          v161 = *(void (**)(char *, char *, uint64_t))(v115 + 16);
          v162 = v230;
          v161(v230, v126, v66);
          if ((v159 & 1) != 0)
          {
            v163 = (uint64_t (*)(uint64_t, uint64_t))v244;
            v164 = ((uint64_t (*)(uint64_t, uint64_t))v244)(v66, v160);
            v116(v162, v66);
            v165 = v229;
            v161(v229, v126, v66);
            if (v164 >= 65)
            {
              v249 = 0x8000000000000000;
              v166 = v247;
              v167 = v245;
              if ((((uint64_t (*)(uint64_t, uint64_t))v245)(v66, v247) & 1) != 0)
              {
                v168 = v163(v66, v166);
                if (v168 < 64)
                {
                  v171 = v66;
                  v172 = v166;
LABEL_69:
                  v203 = ((uint64_t (*)(uint64_t, uint64_t))v243)(v171, v172);
                  v116(v165, v66);
                  v126 = v233;
                  if (v203 < (uint64_t)v249)
                    goto LABEL_74;
                  goto LABEL_46;
                }
              }
              else
              {
                v199 = ((uint64_t (*)(uint64_t, uint64_t))v167)(v66, v166);
                v168 = v163(v66, v166);
                if ((v199 & 1) == 0)
                {
                  if (v168 >= 64)
                  {
                    v116(v165, v66);
                    v126 = v233;
                    goto LABEL_46;
                  }
                  v171 = v66;
                  v172 = v247;
                  goto LABEL_69;
                }
                if (v168 <= 64)
                {
                  v204 = v225;
                  v205 = AssociatedTypeWitness;
                  v206 = swift_getAssociatedConformanceWitness((uint64_t)v225, v66, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                  v207 = v223;
                  (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v206 + 8))(&unk_1816B7DA8, 256, v205, v206);
                  v208 = v246;
                  (*((void (**)(char *, uint64_t, const char *))v204 + 3))(v207, v66, v204);
                  v209 = v247;
                  LOBYTE(v205) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v247 + 32)
                                                                                                + 8)
                                                                                    + 16))(v165, v208, v66);
                  v116(v208, v66);
                  v210 = v216;
                  v122(v216, v165, v66);
                  if ((v205 & 1) != 0)
                  {
                    v116(v210, v66);
                    v126 = v233;
                    goto LABEL_74;
                  }
                  v211 = v210;
                  v212 = v249;
                  v213 = ((uint64_t (*)(uint64_t, uint64_t))v243)(v66, v209);
                  v116(v211, v66);
                  v126 = v233;
                  v163 = (uint64_t (*)(uint64_t, uint64_t))v244;
                  if (v213 < v212)
                    goto LABEL_74;
LABEL_46:
                  v173 = v247;
                  v174 = v163(v66, v247);
                  v175 = v226;
                  v161(v226, v126, v66);
                  if (v174 >= 65)
                  {
                    v116(v175, v66);
                    v161(v234, v126, v66);
                    v176 = (void (*)(uint64_t, uint64_t))v243;
LABEL_48:
                    v249 = 0x7FFFFFFFFFFFFFFFLL;
                    v177 = v247;
                    v178 = ((uint64_t (*)(uint64_t, uint64_t))v245)(v66, v247);
                    v179 = v163(v66, v177);
                    if ((v178 & 1) != 0)
                    {
                      if (v179 > 64)
                      {
                        v182 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v177 + 96);
                        v183 = lazy protocol witness table accessor for type Int64 and conformance Int64(v179, v180, v181);
                        v184 = v246;
                        v182(&v249, &type metadata for Int64, v183, v66, v177);
                        v185 = v234;
                        v186 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v177 + 32)
                                                                                              + 8)
                                                                                  + 16))(v184, v234, v66);
                        v116(v184, v66);
                        v187 = v185;
                        goto LABEL_59;
                      }
                    }
                    else if (v179 > 63)
                    {
                      v248 = 0x7FFFFFFFFFFFFFFFLL;
                      v192 = v246;
                      v193 = ((uint64_t (*)(char *, char *, uint64_t))v122)(v246, v234, v66);
                      v194 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v177 + 96);
                      v197 = lazy protocol witness table accessor for type Int64 and conformance Int64(v193, v195, v196);
                      v198 = v218;
                      v194(&v248, &type metadata for Int64, v197, v66, v177);
                      v186 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v177 + 32)
                                                                                            + 8)
                                                                                + 16))(v198, v192, v66);
                      v116(v198, v66);
                      v187 = v192;
LABEL_59:
                      v116(v187, v66);
                      if ((v186 & 1) == 0)
                        goto LABEL_60;
LABEL_74:
                      v116(v126, v66);
                      return 0;
                    }
                    v191 = v246;
                    v122(v246, v234, v66);
                    v176(v66, v177);
                    v116(v191, v66);
LABEL_60:
                    v176(v66, v177);
                    v116(v126, v66);
                    return v158;
                  }
                  v188 = v163(v66, v173);
                  v116(v175, v66);
                  if (v188 == 64)
                  {
                    v189 = ((uint64_t (*)(uint64_t, uint64_t))v245)(v66, v173);
                    v190 = v234;
                    v161(v234, v126, v66);
                    v176 = (void (*)(uint64_t, uint64_t))v243;
                    if ((v189 & 1) == 0)
                      goto LABEL_48;
                  }
                  else
                  {
                    v190 = v234;
                    v161(v234, v126, v66);
                    v176 = (void (*)(uint64_t, uint64_t))v243;
                  }
                  v116(v190, v66);
                  v177 = v247;
                  goto LABEL_60;
                }
                v166 = v247;
              }
              v240 = *(char **)(v166 + 96);
              v200 = lazy protocol witness table accessor for type Int64 and conformance Int64(v168, v169, v170);
              v201 = v246;
              ((void (*)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))v240)(&v249, &type metadata for Int64, v200, v66, v166);
              v202 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v166 + 32) + 8)
                                                                        + 16))(v165, v201, v66);
              v116(v201, v66);
              v116(v165, v66);
              v126 = v233;
              if ((v202 & 1) != 0)
                goto LABEL_74;
              goto LABEL_46;
            }
          }
          else
          {
            v116(v162, v66);
            v165 = v229;
            v161(v229, v126, v66);
            v163 = (uint64_t (*)(uint64_t, uint64_t))v244;
          }
          v116(v165, v66);
          goto LABEL_46;
        }
        v133 = *(void (**)(char *, char *, uint64_t))(v115 + 16);
        v133(v232, v123, v66);
        v249 = -1;
        v134 = ((uint64_t (*)(uint64_t, uint64_t))v124)(v66, v107);
        v135 = ((uint64_t (*)(uint64_t, uint64_t))v244)(v66, v107);
        if ((v134 & 1) != 0)
        {
          if (v135 < 65)
          {
            v136 = v225;
            v137 = AssociatedTypeWitness;
            v138 = swift_getAssociatedConformanceWitness((uint64_t)v225, v66, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
            v139 = v223;
            (*(void (**)(void *, uint64_t, unint64_t, unint64_t))(v138 + 8))(&unk_1816B7DA8, 256, v137, v138);
            v140 = v246;
            (*((void (**)(char *, uint64_t, const char *))v136 + 3))(v139, v66, v136);
            v141 = v232;
            LOBYTE(v137) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v107 + 32) + 8)
                                                                              + 40))(v232, v140, v66);
            v116(v140, v66);
            v142 = v249;
            v143 = v217;
            v133(v217, v141, v66);
            v122 = v241;
            if ((v137 & 1) != 0)
            {
              v144 = (*(uint64_t (**)(uint64_t, uint64_t))(v107 + 120))(v66, v107);
              v116(v143, v66);
              v103 = v142 >= v144;
              v115 = v243;
              v123 = v239;
              v145 = v232;
              if (!v103)
                goto LABEL_32;
            }
            else
            {
              v116(v143, v66);
              v115 = v243;
              v123 = v239;
              v145 = v232;
            }
            goto LABEL_38;
          }
        }
        else if (v135 < 65)
        {
          v148 = v246;
          v149 = v232;
          v133(v246, v232, v66);
          v150 = (*(uint64_t (**)(uint64_t, uint64_t))(v107 + 120))(v66, v107);
          v151 = v148;
          v145 = v149;
          v116(v151, v66);
          v123 = v239;
          v122 = v241;
          if (v249 < v150)
            goto LABEL_32;
LABEL_38:
          v116(v145, v66);
          v124 = v245;
          goto LABEL_39;
        }
        v146 = v246;
        (*(void (**)(unint64_t *, ValueMetadata *, char *, uint64_t, uint64_t))(v107 + 96))(&v249, &type metadata for UInt64, v240, v66, v107);
        v145 = v232;
        v147 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v107 + 32) + 8) + 16))(v146, v232, v66);
        v116(v146, v66);
        v123 = v239;
        v122 = v241;
        if ((v147 & 1) != 0)
LABEL_32:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        goto LABEL_38;
      }
    }
    else
    {
      v97(v99, v39);
      v64 = v97;
      v67 = v244;
    }
  }
  else
  {
    v71 = v247;
    v72 = v237;
    if (v74 >= 65)
    {
      v84 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, unint64_t *, unint64_t))(v67 + 96);
      v85 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v74, v75, v76);
      v86 = v64;
      v87 = v227;
      v84(&v249, &type metadata for UInt64, v85, v39, v244);
      v88 = swift_getAssociatedConformanceWitness(v72, v66, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for Numeric, (uint64_t)&associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
      v81 = v245;
      v82 = (*(uint64_t (**)(char *, char *, unint64_t *, unint64_t))(v88 + 16))(v87, v245, v39, v88);
      v89 = v87;
      v64 = v86;
      v67 = v244;
      v64(v89, v39);
LABEL_12:
      v64(v81, v39);
      if ((v82 & 1) != 0)
        goto LABEL_19;
      goto LABEL_34;
    }
    v104 = v227;
    (*(void (**)(char *, char *, unint64_t *))(v40 + 32))(v227, v245, v39);
    v105 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v39, v67);
    v64(v104, v39);
    if (v249 < v105)
      goto LABEL_19;
  }
LABEL_34:
  v152 = (*(uint64_t (**)(unint64_t *, unint64_t))(v67 + 120))(v39, v67);
  v64(v65, v39);
  v153 = v246;
  (*(void (**)(uint64_t))(*(_QWORD *)(v72 + 8) + 16))(v66);
  v154 = *(uint64_t (**)(_QWORD, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(v71 + 32) + 8) + 16);
  v155 = v241;
  v156 = v154(v241, v153, v66);
  v157 = *(void (**)(void (*)(char *, char *, uint64_t), uint64_t))(v243 + 8);
  v157(v155, v66);
  v157((void (*)(char *, char *, uint64_t))v153, v66);
  if ((v156 & 1) != 0)
    return -v152;
  else
    return v152;
}

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.multipliedReportingOverflow(by:)(Swift::_Int128 by)
{
  unint64_t v1;
  int64_t v2;
  unint64_t v3;
  int64_t v4;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  _BOOL4 v8;
  Swift::UInt64 v9;
  uint64_t v10;
  BOOL v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int128 v17;
  char v18;
  Swift::UInt64 v19;
  Swift::Int64 v20;
  Swift::tuple_partialValue__Int128_overflow_Bool result;

  if (v2)
  {
    if (!by.high)
    {
      v4 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
      by.high = 0;
      if (v2 >= 0)
      {
        LODWORD(v4) = 0;
      }
      else
      {
        v1 = -(uint64_t)v1;
        v2 = v4;
        LODWORD(v4) = by.low != 0;
      }
      goto LABEL_19;
    }
    if (((v2 ^ by.high) & 0x8000000000000000) == 0)
    {
      if (v2 < 0)
      {
LABEL_17:
        v4 = ((unint64_t)v2 ^ by.high) >> 63;
        v5 = v1 == 0;
        v1 = -(uint64_t)v1;
        v2 = -(v2 + !v5);
        if ((by.high & 0x8000000000000000) == 0)
          goto LABEL_19;
        goto LABEL_18;
      }
      goto LABEL_9;
    }
    if (v2 < 0)
      goto LABEL_17;
    LODWORD(v4) = 1;
    if ((by.high & 0x8000000000000000) == 0)
      goto LABEL_19;
  }
  else
  {
    if ((by.high & 0x8000000000000000) == 0 || !v1)
    {
LABEL_9:
      LODWORD(v4) = 0;
      if ((by.high & 0x8000000000000000) == 0)
        goto LABEL_19;
      goto LABEL_18;
    }
    v2 = 0;
    LODWORD(v4) = 1;
  }
LABEL_18:
  v5 = by.low == 0;
  by.low = -by.low;
  by.high = -(by.high + !v5);
LABEL_19:
  v6 = !is_mul_ok(v2, by.low);
  v7 = !is_mul_ok(v1, by.high);
  v8 = __CFADD__(v2 * by.low, v1 * by.high);
  v9 = v1 * by.low;
  v10 = (*(_OWORD *)&by * __PAIR128__(v2, v1)) >> 64;
  v11 = __CFADD__(v2 * by.low + v1 * by.high, (v1 * (unsigned __int128)by.low) >> 64);
  if (by.high)
    v12 = v2 == 0;
  else
    v12 = 1;
  if (!v12 || v6 || v7 || v8)
  {
    if ((_DWORD)v4)
    {
      v13 = -v10;
      v11 = 1;
      v5 = v9 == 0;
      v14 = -(uint64_t)v9;
      if (v5)
        goto LABEL_40;
      goto LABEL_39;
    }
  }
  else
  {
    if ((_DWORD)v4)
    {
      v13 = -v10;
      v5 = v9 == 0;
      v14 = -(uint64_t)v9;
      if (v5)
      {
LABEL_40:
        v5 = v14 != 0;
        v15 = v14 - 1;
        v16 = !v5;
        v17 = __PAIR128__(v13, v15) + __PAIR128__(v16 << 63 >> 63, 1);
        v10 = (__PAIR128__(v13, v15) + __PAIR128__(v16 << 63 >> 63, 1)) >> 64;
        v9 = v17;
        if (v11)
          goto LABEL_44;
LABEL_46:
        v18 = v4 ^ (v10 < 0);
        goto LABEL_47;
      }
LABEL_39:
      --v13;
      goto LABEL_40;
    }
    if (!v11)
      goto LABEL_46;
  }
LABEL_44:
  v18 = 1;
LABEL_47:
  v19 = v9;
  v20 = v10;
  result.partialValue.high = v20;
  result.partialValue.low = v19;
  result.overflow = v18;
  return result;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance _Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int128((uint64_t (*)(void))_Int128.init<A>(exactly:), a1);
}

void protocol witness for Numeric.magnitude.getter in conformance _Int128(_QWORD *a1@<X8>)
{
  unint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *v2;
  v4 = v2[1];
  v5 = (unsigned __int128)-(__int128)__PAIR128__(v1, *v2) >> 64;
  if (v4 < 0)
  {
    v3 = -*v2;
    v4 = v5;
  }
  *a1 = v3;
  a1[1] = v4;
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance _Int128@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Duration(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))specialized static _Int128.* infix(_:_:), a3);
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t))_Int128.multipliedReportingOverflow(by:), "Overflow in *=", 0x2A0uLL);
}

uint64_t *protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance _Int128@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  v2 = *result >> 63;
  *a2 = *result;
  a2[1] = v2;
  return result;
}

uint64_t _UInt128.Words.subscript.getter(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a1 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/LegacyInt128.swift", 24, 2, a4, 0);
  if (a1)
    return a3;
  else
    return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _Int128.Words(uint64_t *a1, unint64_t *a2))()
{
  uint64_t *v2;

  *a1 = _UInt128.Words.subscript.getter(*a2, *v2, v2[1], 0x2BEuLL);
  return EnumeratedSequence._base.modify;
}

__n128 protocol witness for Collection.subscript.getter in conformance _UInt128.Words@<Q0>(unint64_t *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 *v2;
  uint64_t v3;
  __n128 result;

  if ((*a1 & 0x8000000000000000) != 0 || (v3 = a1[1], v3 >= 3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  a2->n128_u64[0] = *a1;
  a2->n128_u64[1] = v3;
  result = *v2;
  a2[1] = *v2;
  return result;
}

_QWORD *protocol witness for Sequence._copyToContiguousArray() in conformance _Int128.Words()
{
  uint64_t *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _Int128.Words(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.multipliedReportingOverflow(by:)(Swift::UInt64 by)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _BOOL4 v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  Swift::UInt64 v9;
  Swift::UInt64 v10;
  uint64_t v11;
  Swift::Int64 v12;
  BOOL v13;
  Swift::Int64 v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  Swift::tuple_partialValue__Int128_overflow_Bool result;

  v5 = by != 0;
  v6 = -(uint64_t)v1;
  v7 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
  if (v2 >= 0)
  {
    v6 = v1;
    v7 = v2;
    v5 = 0;
  }
  v8 = (v7 * (unsigned __int128)by) >> 64;
  v9 = v7 * by;
  v10 = v6 * by;
  v11 = ((unint64_t)v6 * (unsigned __int128)by) >> 64;
  v12 = v9 + v11;
  v13 = __CFADD__(v9, v11);
  if (v8)
  {
    if (v5)
    {
      v14 = -v12;
      v13 = 1;
      v15 = -(uint64_t)v10;
      if (!v10)
      {
LABEL_13:
        v16 = v15 != 0;
        v17 = v15 - 1;
        v18 = !v16;
        v12 = (__PAIR128__(v14, v17) + __PAIR128__(v18 << 63 >> 63, 1)) >> 64;
        v10 = v17 + 1;
        if (v13)
          goto LABEL_17;
LABEL_19:
        v19 = v5 ^ (v12 < 0);
        goto LABEL_20;
      }
LABEL_12:
      --v14;
      goto LABEL_13;
    }
  }
  else
  {
    if (v5)
    {
      v14 = -v12;
      v15 = -(uint64_t)v10;
      if (!v10)
        goto LABEL_13;
      goto LABEL_12;
    }
    if (!v13)
      goto LABEL_19;
  }
LABEL_17:
  v19 = 1;
LABEL_20:
  result.partialValue.high = v12;
  result.partialValue.low = v10;
  result.overflow = v19;
  return result;
}

Swift::tuple_quotient__Int128_remainder__Int128 __swiftcall _Int128.quotientAndRemainder(dividingBy:)(Swift::_Int128 dividingBy)
{
  Swift::tuple_high_UInt64_low_UInt64 v1;
  unint64_t v2;
  Swift::UInt64 low;
  Swift::UInt64 v4;
  int v5;
  Swift::UInt64 high;
  Swift::Int64 v7;
  int v8;
  Swift::UInt64 v9;
  Swift::Int64 v10;
  Swift::Int64 v11;
  Swift::UInt64 v12;
  Swift::Int64 v13;
  Swift::UInt64 v14;
  Swift::UInt64 v15;
  uint64_t v16;
  uint64_t v17;
  Swift::tuple_quotient__Int128_remainder__Int128 result;

  low = v1.low;
  v4 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1.high) >> 64;
  v5 = (v1.low & 0x8000000000000000) != 0;
  if ((v1.low & 0x8000000000000000) == 0)
    high = v1.high;
  else
    high = -v1.high;
  if ((v1.low & 0x8000000000000000) != 0)
    v1.low = v4;
  v7 = (unsigned __int128)-(__int128)__PAIR128__(v4, dividingBy.low) >> 64;
  v8 = dividingBy.high < 0;
  if (dividingBy.high >= 0)
    v9 = dividingBy.low;
  else
    v9 = -dividingBy.low;
  if (dividingBy.high >= 0)
    v10 = dividingBy.high;
  else
    v10 = v7;
  v1.high = (Swift::UInt64)&v15;
  v11 = specialized _wideDivide22<A>(_:by:)((Swift::UInt64 *)&v17, (Swift::UInt64 *)&v16, v1, high, v10, v9);
  v13 = v16;
  v12 = v17;
  v14 = v15;
  if (v8 == v5)
  {
    if (v11 < 0)
      goto LABEL_31;
    if ((low & 0x8000000000000000) == 0)
      goto LABEL_19;
  }
  else
  {
    if (v11 == 0x8000000000000000 && !v17)
    {
      v11 = 0x8000000000000000;
      if ((low & 0x8000000000000000) != 0)
        goto LABEL_26;
LABEL_19:
      if ((v16 & 0x8000000000000000) == 0)
        goto LABEL_32;
LABEL_31:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    }
    if (v11 < 0)
      goto LABEL_31;
    v12 = -v17;
    if (v17)
      v11 = ~v11;
    else
      v11 = -v11;
    if ((low & 0x8000000000000000) == 0)
      goto LABEL_19;
  }
LABEL_26:
  if (v16 < 0)
    goto LABEL_31;
  v14 = -(uint64_t)v15;
  if (v15)
    v13 = ~v16;
  else
    v13 = -v16;
LABEL_32:
  result.remainder.high = v13;
  result.remainder.low = v14;
  result.quotient.high = v11;
  result.quotient.low = v12;
  return result;
}

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.remainderReportingOverflow(dividingBy:)(Swift::_Int128 dividingBy)
{
  Swift::tuple_high_UInt64_low_UInt64 v1;
  unint64_t v2;
  Swift::UInt64 low;
  char v4;
  Swift::UInt64 v5;
  int v6;
  Swift::UInt64 high;
  Swift::Int64 v8;
  int v9;
  Swift::UInt64 v10;
  Swift::Int64 v11;
  Swift::UInt64 v12;
  BOOL v14;
  Swift::UInt64 v15;
  Swift::Int64 v16;
  Swift::Bool v17;
  Swift::UInt64 v18;
  uint64_t v19;
  Swift::UInt64 v20;
  Swift::tuple_partialValue__Int128_overflow_Bool result;

  low = v1.low;
  if (dividingBy.high == -1)
  {
    if (dividingBy.low == -1 && v1.low == 0x8000000000000000 && !v1.high)
    {
      low = 0;
      v4 = 1;
      goto LABEL_38;
    }
  }
  else if (!dividingBy.high && !dividingBy.low)
  {
    v4 = 1;
    goto LABEL_38;
  }
  v5 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1.high) >> 64;
  v6 = (v1.low & 0x8000000000000000) != 0;
  if ((v1.low & 0x8000000000000000) == 0)
    high = v1.high;
  else
    high = -v1.high;
  if ((v1.low & 0x8000000000000000) != 0)
    v1.low = v5;
  v8 = (unsigned __int128)-(__int128)__PAIR128__(v5, dividingBy.low) >> 64;
  v9 = dividingBy.high < 0;
  if (dividingBy.high >= 0)
    v10 = dividingBy.low;
  else
    v10 = -dividingBy.low;
  if (dividingBy.high >= 0)
    v11 = dividingBy.high;
  else
    v11 = v8;
  v1.high = (Swift::UInt64)&v18;
  v12 = specialized _wideDivide22<A>(_:by:)(&v20, (Swift::UInt64 *)&v19, v1, high, v11, v10);
  v1.high = v18;
  if (v9 == v6)
  {
    if ((v12 & 0x8000000000000000) != 0)
      goto LABEL_39;
  }
  else
  {
    v14 = v12 != 0x8000000000000000 || v20 != 0;
    if ((v12 & 0x8000000000000000) != 0 && v14)
      goto LABEL_39;
  }
  if ((low & 0x8000000000000000) == 0)
  {
    if ((v19 & 0x8000000000000000) == 0)
    {
      v4 = 0;
      low = v19;
      goto LABEL_38;
    }
LABEL_39:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  if (v19 < 0)
    goto LABEL_39;
  v4 = 0;
  v1.high = -(uint64_t)v18;
  if (v18)
    low = ~v19;
  else
    low = -v19;
LABEL_38:
  v15 = v1.high;
  v16 = low;
  v17 = v4;
  result.partialValue.high = v16;
  result.partialValue.low = v15;
  result.overflow = v17;
  return result;
}

Swift::tuple_high__Int128_low__UInt128 __swiftcall _Int128.multipliedFullWidth(by:)(Swift::_Int128 by)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  Swift::Int64 high;
  Swift::Int64 v8;
  Swift::UInt64 v9;
  _BOOL8 v10;
  BOOL v11;
  Swift::UInt64 v12;
  uint64_t v13;
  Swift::Int64 v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  Swift::UInt64 v18;
  Swift::Int64 v19;
  Swift::UInt64 v20;
  uint64_t v21;
  _BOOL4 v22;
  uint64_t v23;
  Swift::Int64 v24;
  _BOOL4 v25;
  uint64_t v26;
  Swift::tuple_high__Int128_low__UInt128 result;

  v4 = v1;
  if (v2)
  {
    v5 = v2;
    if (by.high)
    {
      v6 = ((v2 ^ by.high) & 0x8000000000000000) == 0;
      if ((v2 & 0x8000000000000000) == 0)
        goto LABEL_12;
      goto LABEL_11;
    }
    if ((v2 & 0x8000000000000000) != 0)
    {
      v6 = 0;
LABEL_11:
      v4 = -(uint64_t)v1;
      v5 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1) >> 64;
LABEL_12:
      v8 = (unsigned __int128)-(__int128)__PAIR128__(v3, by.low) >> 64;
      if (by.high >= 0)
      {
        high = by.high;
      }
      else
      {
        by.low = -by.low;
        high = v8;
      }
      goto LABEL_15;
    }
    high = 0;
    v6 = 1;
  }
  else
  {
    if (by.high)
    {
      v5 = 0;
      v6 = by.high >= 0;
      goto LABEL_12;
    }
    high = 0;
    v5 = 0;
    v6 = 1;
  }
LABEL_15:
  v9 = (__PAIR128__(high, by.low) * __PAIR128__(v5, v4)) >> 64;
  v10 = __CFADD__((__PAIR128__(v5, v4) * by.low) >> 64, v4 * high);
  v11 = __CFADD__((v4 * (unsigned __int128)by.low) >> 64, v5 * by.low);
  v12 = v4 * by.low;
  v13 = (v5 * (unsigned __int128)by.low) >> 64;
  v14 = v5 * high;
  v15 = (v5 * (unsigned __int128)(unint64_t)high) >> 64;
  v16 = v13 + ((v4 * (unsigned __int128)(unint64_t)high) >> 64);
  if (__CFADD__(v11, v14) | __CFADD__(v10, v11 + v14))
    v17 = 1;
  else
    v17 = 0;
  v19 = (__PAIR128__(v17, v16) + __PAIR128__(v15, v10 + (unint64_t)v11 + v14)) >> 64;
  v18 = v16 + v10 + v11 + v14;
  if (!v6)
  {
    v20 = -(uint64_t)v9;
    if (v12)
      v20 = ~v9;
    v21 = -(uint64_t)v12 - 1;
    v9 = (__PAIR128__(v20, v12) - 1) >> 64;
    v12 = -(uint64_t)v12;
    v22 = v21 == -1;
    if (v9 == -1)
    {
      v23 = v21 == -1;
    }
    else
    {
      if (v21 != -1)
      {
        v22 = 0;
        v25 = 0;
        v24 = -v19;
        v26 = -(uint64_t)v18;
        if (!v18)
          goto LABEL_30;
        goto LABEL_29;
      }
      v22 = 0;
      v23 = 1;
    }
    v9 += v23;
    v24 = -v19;
    v25 = v22;
    v26 = -(uint64_t)v18;
    if (!v18)
    {
LABEL_30:
      v19 = (__PAIR128__(v24, v26 - 1) + __PAIR128__((uint64_t)((unint64_t)(v26 == 0) << 63) >> 63, v25)) >> 64;
      v18 = v26 - 1 + v25;
      goto LABEL_34;
    }
LABEL_29:
    --v24;
    v25 = v22;
    goto LABEL_30;
  }
LABEL_34:
  result.low.high = v9;
  result.low.low = v12;
  result.high.high = v19;
  result.high.low = v18;
  return result;
}

Swift::tuple_quotient__Int128_remainder__Int128 __swiftcall _Int128.dividingFullWidth(_:)(Swift::tuple_high__Int128_low__UInt128 a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t high;
  Swift::UInt64 low;
  Swift::Int64 v6;
  Swift::UInt64 v7;
  Swift::Int64 v8;
  uint64_t v9;
  Swift::UInt64 v10;
  uint64_t v11;
  BOOL v12;
  Swift::UInt64 v13;
  int v14;
  unint64_t v15;
  Swift::UInt64 v16;
  int v17;
  Swift::UInt64 v18;
  Swift::Int64 v19;
  Swift::UInt64 v20;
  Swift::Int64 v21;
  Swift::UInt64 v22;
  Swift::UInt64 v23;
  uint64_t v24;
  uint64_t v25;
  Swift::tuple_quotient__Int128_remainder__Int128 result;

  high = a1.low.high;
  low = a1.low.low;
  v6 = a1.high.high;
  v7 = a1.high.low;
  if (a1.high.high < 0)
  {
    v8 = -a1.high.high;
    if (a1.high.low)
    {
      v8 = ~a1.high.high;
      v9 = 0;
    }
    else
    {
      v9 = 1;
    }
    v3 = v9 << 63 >> 63;
    if (a1.low.low)
      v10 = ~a1.low.high;
    else
      v10 = -a1.low.high;
    v13 = -a1.low.low - 1;
    v11 = (__PAIR128__(v10, a1.low.low) - 1) >> 64;
    v12 = __CFADD__(v13, 1);
    low = -a1.low.low;
    LODWORD(v13) = v13 == -1;
    high = ((uint64_t)((unint64_t)(a1.low.low == 0) << 63) >> 63) + v12 + v10;
    if (v11 == -1)
      v13 = v13;
    else
      v13 = 0;
    a1.low.high = (__PAIR128__(v8, -a1.high.low - 1) + __PAIR128__(v3, v13)) >> 64;
    v7 = -a1.high.low - 1 + v13;
  }
  else
  {
    a1.low.high = a1.high.high;
  }
  v14 = a1.high.high < 0;
  v15 = -(uint64_t)v1;
  v16 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
  v17 = v2 < 0;
  if (v2 < 0)
  {
    v18 = v16;
  }
  else
  {
    v15 = v1;
    v18 = v2;
  }
  a1.low.low = (Swift::UInt64)&v23;
  v19 = specialized _wideDivide42<A>(_:by:)((Swift::UInt64 *)&v25, (Swift::UInt64 *)&v24, (Swift::tuple_high_UInt64_low_UInt64)a1.low, v7, high, low, v18, v15);
  v21 = v24;
  v20 = v25;
  v22 = v23;
  if (v14 == v17)
  {
    if (v19 < 0)
      goto LABEL_35;
    if ((v6 & 0x8000000000000000) == 0)
      goto LABEL_23;
  }
  else
  {
    if (v19 == 0x8000000000000000 && !v25)
    {
      v19 = 0x8000000000000000;
      if (v6 < 0)
        goto LABEL_30;
LABEL_23:
      if ((v24 & 0x8000000000000000) == 0)
        goto LABEL_36;
LABEL_35:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    }
    if (v19 < 0)
      goto LABEL_35;
    v20 = -v25;
    if (v25)
      v19 = ~v19;
    else
      v19 = -v19;
    if ((v6 & 0x8000000000000000) == 0)
      goto LABEL_23;
  }
LABEL_30:
  if (v24 < 0)
    goto LABEL_35;
  v22 = -(uint64_t)v23;
  if (v23)
    v21 = ~v24;
  else
    v21 = -v24;
LABEL_36:
  result.remainder.high = v21;
  result.remainder.low = v22;
  result.quotient.high = v19;
  result.quotient.low = v20;
  return result;
}

double protocol witness for static FixedWidthInteger.max.getter in conformance _Int128@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = NAN;
  *a1 = xmmword_1816ABF20;
  return result;
}

double protocol witness for static FixedWidthInteger.min.getter in conformance _Int128@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = xmmword_1816ABF30;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance _Int128(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = a2[1];
  v4 = v2[1];
  v5 = __CFADD__(*v2, *a2);
  v6 = __OFADD__(v4, v3);
  v7 = v4 + v3;
  if (v6)
  {
    v8 = 1;
    if (v5)
    {
LABEL_12:
      v9 = 1;
      goto LABEL_13;
    }
  }
  else
  {
    v8 = v7 == 0x7FFFFFFFFFFFFFFFLL && v5;
    if (v5)
      goto LABEL_12;
  }
  v9 = 0;
LABEL_13:
  *a1 = *v2 + *a2;
  a1[1] = v9 + v7;
  return v8;
}

unint64_t protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance _Int128(unint64_t *a1, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  int v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;

  v3 = *a2;
  v4 = a2[1];
  v5 = *v2;
  v6 = v2[1];
  v7 = __OFSUB__(v6, v4);
  v8 = v6 - v4;
  v9 = v7;
  v10 = v5 >= v3;
  v11 = v5 - v3;
  LODWORD(v3) = v5 < v3;
  if (v10)
  {
    if (v9)
    {
      v3 = 1;
      v12 = v8;
      goto LABEL_13;
    }
    v12 = v8;
  }
  else
  {
    v12 = v8 - 1;
    if ((v9 & 1) != 0)
    {
      v3 = 1;
      goto LABEL_13;
    }
  }
  if (v8 == 0x8000000000000000)
    v3 = v3;
  else
    v3 = 0;
LABEL_13:
  *a1 = v11;
  a1[1] = v12;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance _Int128(Swift::UInt64 *a1, Swift::_Int128 *a2)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4;

  v4 = _Int128.multipliedReportingOverflow(by:)(*a2);
  *a1 = v4.partialValue.low;
  a1[1] = v4.partialValue.high;
  return v4.overflow;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance _Int128(_QWORD *a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  uint64_t result;
  unsigned __int128 v12;

  v4 = *a2;
  v5 = a2[1];
  v6 = *v2;
  v7 = v2[1];
  if (v5 == -1)
  {
    if (v4 == -1 && v7 == 0x8000000000000000 && v6 == 0)
    {
      v6 = 0;
      result = 1;
      v7 = 0x8000000000000000;
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (v5)
    v8 = 0;
  else
    v8 = v4 == 0;
  if (!v8)
  {
LABEL_15:
    v12 = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(*(Swift::_Int128 *)&v4);
    v6 = v12;
    v7 = *((_QWORD *)&v12 + 1);
    result = 0;
    goto LABEL_16;
  }
  result = 1;
LABEL_16:
  *a1 = v6;
  a1[1] = v7;
  return result;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance _Int128(Swift::UInt64 *a1, Swift::_Int128 *a2)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4;

  v4 = _Int128.remainderReportingOverflow(dividingBy:)(*a2);
  *a1 = v4.partialValue.low;
  a1[1] = v4.partialValue.high;
  return v4.overflow;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _Int128(uint64_t *a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(a1, a2, a3, a4, a5, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))_Int128.multipliedFullWidth(by:));
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(uint64_t *a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(_QWORD, _QWORD, _QWORD, _QWORD))
{
  _QWORD *v6;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = a6(*a3, a3[1], *v6, v6[1]);
  *a1 = result;
  a1[1] = v10;
  *a2 = v11;
  a2[1] = v12;
  return result;
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance _Int128(Swift::UInt64 *a1, Swift::UInt64 *a2, uint64_t a3, Swift::UInt64 *a4)
{
  Swift::tuple_high__Int128_low__UInt128 v7;
  Swift::tuple_quotient__Int128_remainder__Int128 v8;

  v7.high.low = *(_QWORD *)a3;
  v7.high.high = *(_QWORD *)(a3 + 8);
  v7.low.low = *a4;
  v7.low.high = a4[1];
  v8 = _Int128.dividingFullWidth(_:)(v7);
  *a1 = v8.quotient.low;
  a1[1] = v8.quotient.high;
  *a2 = v8.remainder.low;
  a2[1] = v8.remainder.high;
  return v8.quotient.low;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance _Int128()
{
  int8x16_t *v0;

  return vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v0)))));
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance _Int128()
{
  unint64_t *v0;
  unint64_t v1;

  v1 = v0[1];
  if (v1)
    return __clz(v1);
  else
    return __clz(*v0) + 64;
}

int8x16_t protocol witness for FixedWidthInteger.init(bigEndian:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X8>)
{
  int8x16_t v2;
  int8x16_t result;

  v2 = vrev64q_s8(*a1);
  result = vextq_s8(v2, v2, 8uLL);
  *a2 = result;
  return result;
}

__n128 protocol witness for FixedWidthInteger.init(littleEndian:) in conformance _Int128@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

int8x16_t protocol witness for FixedWidthInteger.bigEndian.getter in conformance _Int128@<Q0>(int8x16_t *a1@<X8>)
{
  int8x16_t *v1;
  int8x16_t v2;
  int8x16_t result;

  v2 = vrev64q_s8(*v1);
  result = vextq_s8(v2, v2, 8uLL);
  *a1 = result;
  return result;
}

__n128 protocol witness for FixedWidthInteger.littleEndian.getter in conformance _Int128@<Q0>(__n128 *a1@<X8>)
{
  __n128 *v1;
  __n128 result;

  result = *v1;
  *a1 = *v1;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _Int128@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  return protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, _QWORD, _QWORD, _QWORD))specialized _wideMaskedShiftRight<A>(_:_:), a3);
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X1>, uint64_t (*a3)(uint64_t, _QWORD, _QWORD, _QWORD)@<X4>, uint64_t a4@<X8>)
{
  uint64_t result;

  result = a3(a4, a1[1], *a1, *a2);
  *(_QWORD *)(a4 + 8) = result;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance _Int128(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;

  result = specialized _wideMaskedShiftRight<A>(_:_:)(a1, a1[1], *a1, *a2);
  a1[1] = result;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance _Int128@<X0>(uint64_t *result@<X0>, unint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _BOOL8 v8;
  _BOOL4 v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *result;
  v5 = result[1];
  v6 = *a2;
  v7 = a2[1];
  if (!v7)
  {
    if ((v5 & 0x8000000000000000) == 0 || !v6)
    {
LABEL_9:
      LODWORD(v8) = 0;
      v9 = 0;
      if ((v5 & 0x8000000000000000) == 0)
        goto LABEL_19;
      goto LABEL_18;
    }
    v7 = 0;
    LODWORD(v8) = 1;
LABEL_18:
    v11 = v4 == 0;
    v4 = -v4;
    v5 = -(v5 + !v11);
    v9 = v8;
    goto LABEL_19;
  }
  if (v5)
  {
    if (((v7 ^ v5) & 0x8000000000000000) == 0)
    {
      if (v7 < 0)
      {
LABEL_17:
        v8 = (v7 ^ (unint64_t)v5) >> 63;
        v11 = v6 == 0;
        v6 = -(uint64_t)v6;
        v7 = -(v7 + !v11);
        v9 = v8;
        if ((v5 & 0x8000000000000000) == 0)
          goto LABEL_19;
        goto LABEL_18;
      }
      goto LABEL_9;
    }
    if (v7 < 0)
      goto LABEL_17;
    LODWORD(v8) = 1;
    v9 = 1;
    if ((v5 & 0x8000000000000000) == 0)
      goto LABEL_19;
    goto LABEL_18;
  }
  v10 = (unsigned __int128)-(__int128)__PAIR128__(v3, v6) >> 64;
  v5 = 0;
  if (v7 >= 0)
  {
    v9 = 0;
  }
  else
  {
    v6 = -(uint64_t)v6;
    v7 = v10;
    v9 = v4 != 0;
  }
LABEL_19:
  v12 = v6 * v5 + v7 * v4;
  v13 = v6 * v4;
  v14 = v12 + ((v6 * (unsigned __int128)(unint64_t)v4) >> 64);
  v15 = -v14;
  if (v13)
    v15 = ~v14;
  v16 = (__PAIR128__(v15, -v13 - 1) + __PAIR128__((uint64_t)((unint64_t)(v13 == 0) << 63) >> 63, 1)) >> 64;
  v17 = -v13;
  if (v9)
    v14 = v16;
  else
    v17 = v13;
  *a3 = v17;
  a3[1] = v14;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance _Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type _Int128 and conformance _Int128(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _Int128@<D0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type _Int128 and conformance _Int128, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<D0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _OWORD *a6@<X8>)
{
  Class *v6;
  Class *v8;
  uint64_t v13;
  double result;
  uint64_t v15;
  uint64_t *TypeName;
  uint64_t v17;
  uint8x16_t *v18;
  int64_t v19;
  int64_t v20;
  int64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  Swift::String v26;
  uint64_t *v27;
  uint64_t v28;
  uint8x16_t *v29;
  int64_t v30;
  int64_t v31;
  int64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  Swift::String v37;
  __int128 v38;
  char v39;

  v8 = v6;
  v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((v39 & 1) != 0)
  {
    *(_QWORD *)&v38 = static String._createEmpty(withInitialCapacity:)(80);
    *((_QWORD *)&v38 + 1) = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      v18 = (uint8x16_t *)TypeName;
      v19 = v17;
      v20 = validateUTF8(_:)(TypeName, v17);
      v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x8000000181762940;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        v29 = (uint8x16_t *)v27;
        v30 = v28;
        v31 = validateUTF8(_:)(v27, v28);
        if ((v33 & 1) != 0)
          v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        else
          v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x8000000181762960;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)v38, *((unint64_t *)&v38 + 1), "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  (*((void (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  result = *(double *)&v38;
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, (uint64_t (*)(char *, uint64_t, uint64_t))_Int128.init<A>(exactly:), 0x27CuLL, a4);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t (*a4)(char *, uint64_t, uint64_t)@<X5>, unint64_t a5@<X6>, uint64_t *a6@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  v9 = specialized _UInt128.init<A>(_:)(a1, a2, a3, a4, a5);
  v11 = v10;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 8))(a1, a2);
  *a6 = v9;
  a6[1] = v11;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance Int128(a1, a2, (uint64_t (*)(void))specialized static FixedWidthInteger._truncatingInit<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance _Int128@<X0>(void (*a1)(_QWORD, _QWORD)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10;

  v10 = lazy protocol witness table accessor for type _Int128 and conformance _Int128((uint64_t)a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance _Int128()
{
  uint64_t v0;

  return specialized FixedWidthInteger._binaryLogarithm()(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance _Int128()
{
  unint64_t *v0;

  if (*v0)
    return __clz(__rbit64(*v0));
  else
    return __clz(__rbit64(v0[1])) + 64;
}

double protocol witness for static BinaryInteger./ infix(_:_:) in conformance _Int128@<D0>(__int128 *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  Swift::UInt64 v4;
  double result;
  __int128 v6;
  Swift::_Int128 v7;

  v4 = *(_QWORD *)a2;
  v7.high = *(_QWORD *)(a2 + 8);
  v6 = *a1;
  v7.low = v4;
  specialized static _Int128./= infix(_:_:)(&v6, v7);
  result = *(double *)&v6;
  *a3 = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance _Int128(_QWORD *a1, Swift::_Int128 *a2)
{
  return specialized static _Int128./= infix(_:_:)(a1, *a2);
}

Swift::UInt64 protocol witness for static BinaryInteger.% infix(_:_:) in conformance _Int128@<X0>(Swift::_Int128 *a1@<X1>, Swift::UInt64 *a2@<X8>)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4;

  v4 = _Int128.remainderReportingOverflow(dividingBy:)(*a1);
  if (v4.overflow)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in %=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3DCuLL, 0);
  *a2 = v4.partialValue.low;
  a2[1] = v4.partialValue.high;
  return v4.partialValue.low;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance _Int128(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t))_Int128.remainderReportingOverflow(dividingBy:), "Overflow in %=", 0x3DCuLL);
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(uint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD, _QWORD, uint64_t, uint64_t), const char *a6, unint64_t a7)
{
  uint64_t result;
  uint64_t v11;
  char v12;

  result = a5(*a2, a2[1], *a1, a1[1]);
  if ((v12 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a6, 14, 2, "Swift/LegacyInt128.swift", 24, 2, a7, 0);
  *a1 = result;
  a1[1] = v11;
  return result;
}

_QWORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance _UInt128@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  _BOOL8 v4;

  v2 = result[1];
  if (*result)
    v3 = ~v2;
  else
    v3 = -v2;
  v4 = *result == 0;
  *a2 = -*result - 1;
  a2[1] = v3 - v4;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.& infix(_:_:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result;

  result = vandq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.&= infix(_:_:) in conformance _Int128(int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result;

  result = vandq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.| infix(_:_:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result;

  result = vorrq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.|= infix(_:_:) in conformance _Int128(int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result;

  result = vorrq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.^ infix(_:_:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result;

  result = veorq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.^= infix(_:_:) in conformance _Int128(int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result;

  result = veorq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance _Int128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  unint64_t v36;
  void (*v37)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v38;
  char v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char v47;
  void (*v48)(char *, uint64_t);
  uint64_t v49;
  void (*v50)(char *, uint64_t, uint64_t);
  char *v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t AssociatedConformanceWitness;
  char *v60;
  void (*v61)(char *, uint64_t);
  uint64_t v62;
  char v63;
  void (*v64)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v65;
  uint64_t v66;
  void (**v67)(char *, uint64_t, const char *);
  unint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t (*v75)(uint64_t, uint64_t);
  uint64_t v76;
  char *v77;
  uint64_t v78;
  char *v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void (*v84)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v85;
  uint64_t *v86;
  char v87;
  unint64_t v88;
  uint64_t v89;
  char v90;
  uint64_t result;
  char v92;
  uint64_t v93;
  uint64_t *v94;
  char v95;
  uint64_t v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  char *v98;
  char *v99;
  char *v100;
  unint64_t AssociatedTypeWitness;
  char *v102;
  char *v103;
  char *v104;
  char *v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t *v108;
  uint64_t (*v109)(uint64_t, uint64_t);
  uint64_t v110;
  uint64_t v111;

  v108 = a5;
  v102 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v102, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v100 = (char *)&v96 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v96 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v98 = (char *)&v96 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v103 = (char *)&v96 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v104 = (char *)&v96 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v99 = (char *)&v96 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v96 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v105 = (char *)&v96 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v96 - v28;
  v30 = *a1;
  v106 = a1[1];
  v107 = v30;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v31(a3, a4) & 1) != 0)
  {
    v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v32 = v109(a3, a4);
    if (v32 < 64)
      goto LABEL_9;
  }
  else
  {
    v35 = v31(a3, a4);
    v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v32 = v109(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v32 >= 64)
        goto LABEL_10;
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v40 >= -128)
        goto LABEL_10;
      goto LABEL_25;
    }
    if (v32 <= 64)
    {
      v97 = v31;
      v57 = AssociatedTypeWitness;
      v58 = v102;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v102, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v60 = v100;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v57, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v58 + 3))(v60, a3, v58);
      LOBYTE(v57) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v61 = *(void (**)(char *, uint64_t))(v11 + 8);
      v61(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v57 & 1) != 0)
      {
        v61(v14, a3);
      }
      else
      {
        v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v61(v14, a3);
        v31 = v97;
        if (v62 >= -128)
        {
LABEL_10:
          v41 = v31(a3, a4);
          v42 = v109(a3, a4);
          if ((v41 & 1) != 0)
          {
            if (v42 > 64)
              goto LABEL_12;
          }
          else if (v42 > 63)
          {
LABEL_12:
            v36 = 128;
            v111 = 128;
            v45 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
            v45(&v111, &type metadata for Int, v46, a3, a4);
            v47 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
            v48 = *(void (**)(char *, uint64_t))(v11 + 8);
            v48(v29, a3);
            if ((v47 & 1) != 0)
              goto LABEL_49;
            goto LABEL_17;
          }
          (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
          v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48 = *(void (**)(char *, uint64_t))(v11 + 8);
          v48(v29, a3);
          if (v49 > 128)
          {
            v36 = 128;
            goto LABEL_49;
          }
LABEL_17:
          v50 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
          v51 = v105;
          v50(v105, a2, a3);
          v52 = v31(a3, a4);
          v50(v25, (uint64_t)v51, a3);
          if ((v52 & 1) != 0)
          {
            v53 = v109(a3, a4);
            v48(v25, a3);
            if (v53 < 65)
              goto LABEL_36;
            v25 = v99;
            v50(v99, (uint64_t)v51, a3);
            v111 = 0x8000000000000000;
            if ((v31(a3, a4) & 1) != 0)
            {
              v54 = v109(a3, a4);
              if (v54 < 64)
              {
LABEL_31:
                v50(v29, (uint64_t)v25, a3);
                v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v48(v29, a3);
                if (v66 < v111)
LABEL_58:
                  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
                goto LABEL_35;
              }
              goto LABEL_28;
            }
            v63 = v31(a3, a4);
            v54 = v109(a3, a4);
            if ((v63 & 1) != 0)
            {
              if (v54 > 64)
              {
LABEL_28:
                v64 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                v65 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
                v64(&v111, &type metadata for Int, v65, a3, a4);
                LOBYTE(v64) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                 + 16))(v25, v29, a3);
                v48(v29, a3);
                if ((v64 & 1) != 0)
                  goto LABEL_58;
                goto LABEL_35;
              }
              v68 = AssociatedTypeWitness;
              v67 = (void (**)(char *, uint64_t, const char *))v102;
              v69 = swift_getAssociatedConformanceWitness((uint64_t)v102, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v70 = v100;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v69 + 8))(&qword_1816B7DA8, 256, v68, v69);
              v67[3](v70, a3, (const char *)v67);
              LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                               + 16))(v25, v29, a3);
              v48(v29, a3);
              v71 = v98;
              v50(v98, (uint64_t)v25, a3);
              if ((v67 & 1) != 0)
              {
                v48(v71, a3);
                goto LABEL_58;
              }
              v72 = v111;
              v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v48(v71, a3);
              v74 = v73 < v72;
              v51 = v105;
              if (v74)
                goto LABEL_58;
            }
            else if (v54 < 64)
            {
              goto LABEL_31;
            }
          }
LABEL_35:
          v48(v25, a3);
LABEL_36:
          v75 = v109;
          v76 = v109(a3, a4);
          v77 = v104;
          v50(v104, (uint64_t)v51, a3);
          if (v76 < 65)
          {
            v78 = v75(a3, a4);
            v48(v77, a3);
            if (v78 != 64 || (v31(a3, a4) & 1) != 0)
              goto LABEL_48;
          }
          else
          {
            v48(v77, a3);
          }
          v79 = v103;
          v50(v103, (uint64_t)v51, a3);
          v111 = 0x7FFFFFFFFFFFFFFFLL;
          v80 = v31(a3, a4);
          v81 = v109(a3, a4);
          if ((v80 & 1) != 0)
          {
            if (v81 > 64)
            {
              v84 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
              v86 = &v111;
              goto LABEL_46;
            }
          }
          else if (v81 > 63)
          {
            v110 = 0x7FFFFFFFFFFFFFFFLL;
            v84 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v85 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
            v86 = &v110;
LABEL_46:
            v84(v86, &type metadata for Int, v85, a3, a4);
            v87 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v79, a3);
            v48(v29, a3);
            if ((v87 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_47;
          }
          v50(v29, (uint64_t)v79, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v29, a3);
LABEL_47:
          v48(v79, a3);
LABEL_48:
          v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v51, a3);
          goto LABEL_49;
        }
      }
LABEL_25:
      v36 = -128;
      goto LABEL_49;
    }
  }
  v36 = -128;
  v111 = -128;
  v37 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v38 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
  v37(&v111, &type metadata for Int, v38, a3, a4);
  v39 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v39 & 1) == 0)
    goto LABEL_10;
LABEL_49:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  v89 = v106;
  v88 = v107;
  result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v106, v107, v90);
  if ((v36 & 0x8000000000000000) != 0)
  {
    if (v36 <= 0xFFFFFFFFFFFFFF80)
    {
      result = 0;
      v93 = 0;
      goto LABEL_53;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v111, v89, v88, v95);
  }
  else if (v36 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v89, v88, v92);
  }
  v93 = v111;
LABEL_53:
  v94 = v108;
  *v108 = v93;
  v94[1] = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance _Int128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  unint64_t v35;
  void (*v36)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v37;
  char v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  char v46;
  void (*v47)(char *, uint64_t);
  uint64_t v48;
  void (*v49)(char *, uint64_t, uint64_t);
  char *v50;
  char v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v59;
  char v60;
  unint64_t v61;
  const char *v62;
  unint64_t AssociatedConformanceWitness;
  char *v64;
  void (*v65)(char *, uint64_t);
  uint64_t v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void (*v71)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v72;
  char v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  char *v78;
  uint64_t v79;
  BOOL v80;
  uint64_t (*v81)(uint64_t, uint64_t);
  uint64_t v82;
  uint64_t v83;
  char *v84;
  char v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void (*v89)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v90;
  uint64_t *v91;
  char v92;
  uint64_t v93;
  char *v94;
  _QWORD *v95;
  unint64_t v96;
  unint64_t v97;
  char v98;
  uint64_t result;
  char v100;
  uint64_t v101;
  char v102;
  uint64_t v103;
  uint64_t (*v104)(uint64_t, uint64_t);
  char *v105;
  char *v106;
  char *v107;
  unint64_t AssociatedTypeWitness;
  const char *v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t *v113;
  uint64_t (*v114)(uint64_t, uint64_t);
  uint64_t v115;
  uint64_t v116;

  v113 = a1;
  v109 = *(const char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v109, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v107 = (char *)&v103 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v103 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v103 - v14;
  v16 = MEMORY[0x1E0C80A78](v13);
  v110 = (char *)&v103 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v112 = (char *)&v103 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v106 = (char *)&v103 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v24 = (char *)&v103 - v23;
  v25 = MEMORY[0x1E0C80A78](v22);
  v111 = (char *)&v103 - v26;
  MEMORY[0x1E0C80A78](v25);
  v28 = (char *)&v103 - v27;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v105 = v15;
  if ((v30 & 1) != 0)
  {
    v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v31 = v114(a3, a4);
    if (v31 < 64)
      goto LABEL_9;
  }
  else
  {
    v34 = v29(a3, a4);
    v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v31 = v114(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v31 >= 64)
        goto LABEL_10;
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
      v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
      if (v39 >= -128)
        goto LABEL_10;
      goto LABEL_27;
    }
    if (v31 <= 64)
    {
      v104 = v29;
      v61 = AssociatedTypeWitness;
      v62 = v109;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v64 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v61, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v62 + 3))(v64, a3, v62);
      LOBYTE(v61) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v28, a3);
      v65 = *(void (**)(char *, uint64_t))(v9 + 8);
      v65(v28, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v61 & 1) != 0)
      {
        v65(v12, a3);
      }
      else
      {
        v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v65(v12, a3);
        v29 = v104;
        if (v66 >= -128)
        {
LABEL_10:
          v40 = v29(a3, a4);
          v41 = v114(a3, a4);
          if ((v40 & 1) != 0)
          {
            if (v41 > 64)
              goto LABEL_12;
          }
          else if (v41 >= 64)
          {
LABEL_12:
            v35 = 128;
            v116 = 128;
            v44 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
            v44(&v116, &type metadata for Int, v45, a3, a4);
            v46 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v28, a2, a3);
            v47 = *(void (**)(char *, uint64_t))(v9 + 8);
            v47(v28, a3);
            if ((v46 & 1) != 0)
              goto LABEL_51;
            goto LABEL_17;
          }
          (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
          v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47 = *(void (**)(char *, uint64_t))(v9 + 8);
          v47(v28, a3);
          if (v48 > 128)
          {
            v35 = 128;
            goto LABEL_51;
          }
LABEL_17:
          v49 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
          v50 = v111;
          v49(v111, a2, a3);
          v51 = v29(a3, a4);
          v49(v24, (uint64_t)v50, a3);
          if ((v51 & 1) == 0)
          {
            v47(v24, a3);
            v53 = v112;
            goto LABEL_38;
          }
          v52 = v114(a3, a4);
          v47(v24, a3);
          v53 = v112;
          if (v52 <= 64)
            goto LABEL_38;
          v54 = v106;
          v49(v106, (uint64_t)v50, a3);
          v116 = 0x8000000000000000;
          if ((v29(a3, a4) & 1) != 0)
          {
            v55 = v114(a3, a4);
            if (v55 >= 64)
            {
              v58 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v59 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
              v58(&v116, &type metadata for Int, v59, a3, a4);
              v53 = v112;
              v60 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v54, v28, a3);
              v47(v28, a3);
              if ((v60 & 1) != 0)
                goto LABEL_60;
              goto LABEL_37;
            }
          }
          else
          {
            v67 = v29(a3, a4);
            v68 = v114(a3, a4);
            if ((v67 & 1) != 0)
            {
              if (v68 <= 64)
              {
                v75 = AssociatedTypeWitness;
                v76 = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                v77 = v107;
                (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))(&qword_1816B7DA8, 256, v75, v76);
                (*((void (**)(char *, uint64_t))v109 + 3))(v77, a3);
                LOBYTE(v77) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                 + 16))(v54, v28, a3);
                v47(v28, a3);
                v78 = v105;
                v49(v105, (uint64_t)v54, a3);
                if ((v77 & 1) != 0)
                {
                  v47(v78, a3);
                  goto LABEL_60;
                }
                v109 = (const char *)v116;
                v79 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v47(v78, a3);
                v80 = v79 < (uint64_t)v109;
                v53 = v112;
                if (v80)
                  goto LABEL_60;
              }
              else
              {
                v71 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
                v71(&v116, &type metadata for Int, v72, a3, a4);
                v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v54, v28, a3);
                v47(v28, a3);
                v53 = v112;
                if ((v73 & 1) != 0)
                  goto LABEL_60;
              }
              goto LABEL_37;
            }
            v53 = v112;
            if (v68 >= 64)
              goto LABEL_37;
          }
          v49(v28, (uint64_t)v54, a3);
          v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
          if (v74 < v116)
LABEL_60:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_37:
          v47(v54, a3);
LABEL_38:
          v81 = v114;
          v82 = v114(a3, a4);
          v49(v53, (uint64_t)v50, a3);
          if (v82 < 65)
          {
            v83 = v81(a3, a4);
            v47(v53, a3);
            if (v83 != 64 || (v29(a3, a4) & 1) != 0)
              goto LABEL_50;
          }
          else
          {
            v47(v53, a3);
          }
          v84 = v110;
          v49(v110, (uint64_t)v50, a3);
          v116 = 0x7FFFFFFFFFFFFFFFLL;
          v85 = v29(a3, a4);
          v86 = v114(a3, a4);
          if ((v85 & 1) != 0)
          {
            if (v86 > 64)
            {
              v89 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v90 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
              v91 = &v116;
              goto LABEL_48;
            }
          }
          else if (v86 >= 64)
          {
            v115 = 0x7FFFFFFFFFFFFFFFLL;
            v89 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v90 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
            v91 = &v115;
LABEL_48:
            v89(v91, &type metadata for Int, v90, a3, a4);
            v92 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v28, v84, a3);
            v47(v28, a3);
            if ((v92 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_49;
          }
          v49(v28, (uint64_t)v84, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
LABEL_49:
          v47(v84, a3);
LABEL_50:
          v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v94 = v50;
          v35 = v93;
          v47(v94, a3);
          goto LABEL_51;
        }
      }
LABEL_27:
      v35 = -128;
      goto LABEL_51;
    }
  }
  v35 = -128;
  v116 = -128;
  v36 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v37 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
  v36(&v116, &type metadata for Int, v37, a3, a4);
  v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v28, a3);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
  if ((v38 & 1) == 0)
    goto LABEL_10;
LABEL_51:
  v95 = v113;
  v96 = *v113;
  v97 = v113[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v98);
  if ((v35 & 0x8000000000000000) != 0)
  {
    if (v35 <= 0xFFFFFFFFFFFFFF80)
    {
      result = 0;
      v101 = 0;
      goto LABEL_55;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v116, v97, v96, v102);
  }
  else if (v35 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v100);
  }
  v101 = v116;
LABEL_55:
  *v95 = v101;
  v95[1] = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance _Int128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  unint64_t v36;
  void (*v37)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v38;
  char v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v46;
  char v47;
  void (*v48)(char *, uint64_t);
  uint64_t v49;
  void (*v50)(char *, uint64_t, uint64_t);
  char *v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t AssociatedConformanceWitness;
  char *v60;
  void (*v61)(char *, uint64_t);
  uint64_t v62;
  char v63;
  void (*v64)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v65;
  uint64_t v66;
  void (**v67)(char *, uint64_t, const char *);
  unint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  uint64_t (*v75)(uint64_t, uint64_t);
  uint64_t v76;
  char *v77;
  char *v78;
  char v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void (*v83)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  char v87;
  unint64_t v88;
  uint64_t v89;
  char v90;
  uint64_t result;
  char v92;
  uint64_t v93;
  uint64_t *v94;
  char v95;
  uint64_t v96;
  uint64_t (*v97)(uint64_t, uint64_t);
  char *v98;
  char *v99;
  char *v100;
  unint64_t AssociatedTypeWitness;
  char *v102;
  char *v103;
  char *v104;
  char *v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t *v108;
  uint64_t (*v109)(uint64_t, uint64_t);
  uint64_t v110;
  uint64_t v111;

  v108 = a5;
  v102 = *(char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v102, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v100 = (char *)&v96 - v10;
  v11 = *(_QWORD *)(a3 - 8);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v96 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v98 = (char *)&v96 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v103 = (char *)&v96 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v104 = (char *)&v96 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v99 = (char *)&v96 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v25 = (char *)&v96 - v24;
  v26 = MEMORY[0x1E0C80A78](v23);
  v105 = (char *)&v96 - v27;
  MEMORY[0x1E0C80A78](v26);
  v29 = (char *)&v96 - v28;
  v30 = *a1;
  v106 = a1[1];
  v107 = v30;
  v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v31(a3, a4) & 1) != 0)
  {
    v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v32 = v109(a3, a4);
    if (v32 < 64)
      goto LABEL_9;
  }
  else
  {
    v35 = v31(a3, a4);
    v109 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v32 = v109(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v32 >= 64)
        goto LABEL_10;
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
      v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
      if (v40 >= -128)
        goto LABEL_10;
      goto LABEL_25;
    }
    if (v32 <= 64)
    {
      v97 = v31;
      v57 = AssociatedTypeWitness;
      v58 = v102;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v102, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v60 = v100;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v57, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v58 + 3))(v60, a3, v58);
      LOBYTE(v57) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      v61 = *(void (**)(char *, uint64_t))(v11 + 8);
      v61(v29, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if ((v57 & 1) != 0)
      {
        v61(v14, a3);
      }
      else
      {
        v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v61(v14, a3);
        v31 = v97;
        if (v62 >= -128)
        {
LABEL_10:
          v41 = v31(a3, a4);
          v42 = v109(a3, a4);
          if ((v41 & 1) != 0)
          {
            if (v42 > 64)
              goto LABEL_12;
          }
          else if (v42 > 63)
          {
LABEL_12:
            v36 = 128;
            v111 = 128;
            v45 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v46 = lazy protocol witness table accessor for type Int and conformance Int(v42, v43, v44);
            v45(&v111, &type metadata for Int, v46, a3, a4);
            v47 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, a2, a3);
            v48 = *(void (**)(char *, uint64_t))(v11 + 8);
            v48(v29, a3);
            if ((v47 & 1) != 0)
              goto LABEL_50;
            goto LABEL_17;
          }
          (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
          v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48 = *(void (**)(char *, uint64_t))(v11 + 8);
          v48(v29, a3);
          if (v49 > 128)
          {
            v36 = 128;
            goto LABEL_50;
          }
LABEL_17:
          v50 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
          v51 = v105;
          v50(v105, a2, a3);
          v52 = v31(a3, a4);
          v50(v25, (uint64_t)v51, a3);
          if ((v52 & 1) != 0)
          {
            v53 = v109(a3, a4);
            v48(v25, a3);
            if (v53 < 65)
              goto LABEL_36;
            v25 = v99;
            v50(v99, (uint64_t)v51, a3);
            v111 = 0x8000000000000000;
            if ((v31(a3, a4) & 1) != 0)
            {
              v54 = v109(a3, a4);
              if (v54 < 64)
              {
LABEL_31:
                v50(v29, (uint64_t)v25, a3);
                v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v48(v29, a3);
                if (v66 < v111)
LABEL_60:
                  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
                goto LABEL_35;
              }
              goto LABEL_28;
            }
            v63 = v31(a3, a4);
            v54 = v109(a3, a4);
            if ((v63 & 1) != 0)
            {
              if (v54 > 64)
              {
LABEL_28:
                v64 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                v65 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
                v64(&v111, &type metadata for Int, v65, a3, a4);
                LOBYTE(v64) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                 + 16))(v25, v29, a3);
                v48(v29, a3);
                if ((v64 & 1) != 0)
                  goto LABEL_60;
                goto LABEL_35;
              }
              v68 = AssociatedTypeWitness;
              v67 = (void (**)(char *, uint64_t, const char *))v102;
              v69 = swift_getAssociatedConformanceWitness((uint64_t)v102, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v70 = v100;
              (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v69 + 8))(&qword_1816B7DA8, 256, v68, v69);
              v67[3](v70, a3, (const char *)v67);
              LOBYTE(v67) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                               + 16))(v25, v29, a3);
              v48(v29, a3);
              v71 = v98;
              v50(v98, (uint64_t)v25, a3);
              if ((v67 & 1) != 0)
              {
                v48(v71, a3);
                goto LABEL_60;
              }
              v72 = v111;
              v73 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v48(v71, a3);
              v74 = v73 < v72;
              v51 = v105;
              if (v74)
                goto LABEL_60;
            }
            else if (v54 < 64)
            {
              goto LABEL_31;
            }
          }
LABEL_35:
          v48(v25, a3);
LABEL_36:
          v75 = v109;
          v76 = v109(a3, a4);
          v77 = v104;
          v50(v104, (uint64_t)v51, a3);
          if (v76 < 65)
          {
            v86 = v75(a3, a4);
            v48(v77, a3);
            if (v86 != 64 || (v31(a3, a4) & 1) != 0)
              goto LABEL_49;
          }
          else
          {
            v48(v77, a3);
          }
          v78 = v103;
          v50(v103, (uint64_t)v51, a3);
          v111 = 0x7FFFFFFFFFFFFFFFLL;
          v79 = v31(a3, a4);
          v80 = v109(a3, a4);
          if ((v79 & 1) != 0)
          {
            if (v80 > 64)
            {
              v83 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v84 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
              v85 = &v111;
              goto LABEL_47;
            }
          }
          else if (v80 > 63)
          {
            v110 = 0x7FFFFFFFFFFFFFFFLL;
            v83 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v84 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
            v85 = &v110;
LABEL_47:
            v83(v85, &type metadata for Int, v84, a3, a4);
            v87 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v29, v78, a3);
            v48(v29, a3);
            if ((v87 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_48;
          }
          v50(v29, (uint64_t)v78, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v29, a3);
LABEL_48:
          v48(v78, a3);
LABEL_49:
          v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v48(v51, a3);
          goto LABEL_50;
        }
      }
LABEL_25:
      v36 = -128;
      goto LABEL_50;
    }
  }
  v36 = -128;
  v111 = -128;
  v37 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v38 = lazy protocol witness table accessor for type Int and conformance Int(v32, v33, v34);
  v37(&v111, &type metadata for Int, v38, a3, a4);
  v39 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v29, a3);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if ((v39 & 1) == 0)
    goto LABEL_10;
LABEL_50:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  v89 = v106;
  v88 = v107;
  result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v106, v107, v90);
  if ((v36 & 0x8000000000000000) != 0)
  {
    if (v36 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      result = specialized _wideMaskedShiftRight<A>(_:_:)(&v111, v89, v88, v95);
    }
  }
  else
  {
    if (v36 >= 0x80)
    {
      result = 0;
      v93 = 0;
      goto LABEL_54;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v111, v89, v88, v92);
  }
  v93 = v111;
LABEL_54:
  v94 = v108;
  *v108 = v93;
  v94[1] = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance _Int128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  unint64_t v35;
  void (*v36)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v37;
  char v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v45;
  char v46;
  void (*v47)(char *, uint64_t);
  uint64_t v48;
  void (*v49)(char *, uint64_t, uint64_t);
  char *v50;
  char v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v59;
  char v60;
  unint64_t v61;
  const char *v62;
  unint64_t AssociatedConformanceWitness;
  char *v64;
  void (*v65)(char *, uint64_t);
  uint64_t v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void (*v71)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v72;
  char v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  char *v78;
  uint64_t v79;
  BOOL v80;
  uint64_t (*v81)(uint64_t, uint64_t);
  uint64_t v82;
  char *v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void (*v88)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  unint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  char v92;
  uint64_t v93;
  char *v94;
  _QWORD *v95;
  unint64_t v96;
  unint64_t v97;
  char v98;
  uint64_t result;
  char v100;
  uint64_t v101;
  char v102;
  uint64_t v103;
  uint64_t (*v104)(uint64_t, uint64_t);
  char *v105;
  char *v106;
  char *v107;
  unint64_t AssociatedTypeWitness;
  const char *v109;
  char *v110;
  char *v111;
  char *v112;
  unint64_t *v113;
  uint64_t (*v114)(uint64_t, uint64_t);
  uint64_t v115;
  uint64_t v116;

  v113 = a1;
  v109 = *(const char **)(*(_QWORD *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v109, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  v7 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v107 = (char *)&v103 - v8;
  v9 = *(_QWORD *)(a3 - 8);
  v10 = MEMORY[0x1E0C80A78](v7);
  v12 = (char *)&v103 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v103 - v14;
  v16 = MEMORY[0x1E0C80A78](v13);
  v110 = (char *)&v103 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v112 = (char *)&v103 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v106 = (char *)&v103 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v24 = (char *)&v103 - v23;
  v25 = MEMORY[0x1E0C80A78](v22);
  v111 = (char *)&v103 - v26;
  MEMORY[0x1E0C80A78](v25);
  v28 = (char *)&v103 - v27;
  v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  v30 = v29(a3, a4);
  v105 = v15;
  if ((v30 & 1) != 0)
  {
    v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v31 = v114(a3, a4);
    if (v31 < 64)
      goto LABEL_9;
  }
  else
  {
    v34 = v29(a3, a4);
    v114 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v31 = v114(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v31 >= 64)
        goto LABEL_10;
LABEL_9:
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
      v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
      if (v39 >= -128)
        goto LABEL_10;
      goto LABEL_27;
    }
    if (v31 <= 64)
    {
      v104 = v29;
      v61 = AssociatedTypeWitness;
      v62 = v109;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v64 = v107;
      (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 8))(&qword_1816B7DA8, 256, v61, AssociatedConformanceWitness);
      (*((void (**)(char *, uint64_t, const char *))v62 + 3))(v64, a3, v62);
      LOBYTE(v61) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v28, a3);
      v65 = *(void (**)(char *, uint64_t))(v9 + 8);
      v65(v28, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v12, a2, a3);
      if ((v61 & 1) != 0)
      {
        v65(v12, a3);
      }
      else
      {
        v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v65(v12, a3);
        v29 = v104;
        if (v66 >= -128)
        {
LABEL_10:
          v40 = v29(a3, a4);
          v41 = v114(a3, a4);
          if ((v40 & 1) != 0)
          {
            if (v41 > 64)
              goto LABEL_12;
          }
          else if (v41 >= 64)
          {
LABEL_12:
            v35 = 128;
            v116 = 128;
            v44 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
            v44(&v116, &type metadata for Int, v45, a3, a4);
            v46 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v28, a2, a3);
            v47 = *(void (**)(char *, uint64_t))(v9 + 8);
            v47(v28, a3);
            if ((v46 & 1) != 0)
              goto LABEL_52;
            goto LABEL_17;
          }
          (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v28, a2, a3);
          v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47 = *(void (**)(char *, uint64_t))(v9 + 8);
          v47(v28, a3);
          if (v48 > 128)
          {
            v35 = 128;
            goto LABEL_52;
          }
LABEL_17:
          v49 = *(void (**)(char *, uint64_t, uint64_t))(v9 + 16);
          v50 = v111;
          v49(v111, a2, a3);
          v51 = v29(a3, a4);
          v49(v24, (uint64_t)v50, a3);
          if ((v51 & 1) == 0)
          {
            v47(v24, a3);
            v53 = v112;
            goto LABEL_38;
          }
          v52 = v114(a3, a4);
          v47(v24, a3);
          v53 = v112;
          if (v52 <= 64)
            goto LABEL_38;
          v54 = v106;
          v49(v106, (uint64_t)v50, a3);
          v116 = 0x8000000000000000;
          if ((v29(a3, a4) & 1) != 0)
          {
            v55 = v114(a3, a4);
            if (v55 >= 64)
            {
              v58 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v59 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
              v58(&v116, &type metadata for Int, v59, a3, a4);
              v53 = v112;
              v60 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v54, v28, a3);
              v47(v28, a3);
              if ((v60 & 1) != 0)
                goto LABEL_62;
              goto LABEL_37;
            }
          }
          else
          {
            v67 = v29(a3, a4);
            v68 = v114(a3, a4);
            if ((v67 & 1) != 0)
            {
              if (v68 <= 64)
              {
                v75 = AssociatedTypeWitness;
                v76 = swift_getAssociatedConformanceWitness((uint64_t)v109, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, (uint64_t)&associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                v77 = v107;
                (*(void (**)(uint64_t *, uint64_t, unint64_t, unint64_t))(v76 + 8))(&qword_1816B7DA8, 256, v75, v76);
                (*((void (**)(char *, uint64_t))v109 + 3))(v77, a3);
                LOBYTE(v77) = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8)
                                                                                 + 16))(v54, v28, a3);
                v47(v28, a3);
                v78 = v105;
                v49(v105, (uint64_t)v54, a3);
                if ((v77 & 1) != 0)
                {
                  v47(v78, a3);
                  goto LABEL_62;
                }
                v109 = (const char *)v116;
                v79 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v47(v78, a3);
                v80 = v79 < (uint64_t)v109;
                v53 = v112;
                if (v80)
                  goto LABEL_62;
              }
              else
              {
                v71 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                v72 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
                v71(&v116, &type metadata for Int, v72, a3, a4);
                v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v54, v28, a3);
                v47(v28, a3);
                v53 = v112;
                if ((v73 & 1) != 0)
                  goto LABEL_62;
              }
              goto LABEL_37;
            }
            v53 = v112;
            if (v68 >= 64)
              goto LABEL_37;
          }
          v49(v28, (uint64_t)v54, a3);
          v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
          if (v74 < v116)
LABEL_62:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
LABEL_37:
          v47(v54, a3);
LABEL_38:
          v81 = v114;
          v82 = v114(a3, a4);
          v49(v53, (uint64_t)v50, a3);
          if (v82 < 65)
          {
            v91 = v81(a3, a4);
            v47(v53, a3);
            if (v91 != 64 || (v29(a3, a4) & 1) != 0)
              goto LABEL_51;
          }
          else
          {
            v47(v53, a3);
          }
          v83 = v110;
          v49(v110, (uint64_t)v50, a3);
          v116 = 0x7FFFFFFFFFFFFFFFLL;
          v84 = v29(a3, a4);
          v85 = v114(a3, a4);
          if ((v84 & 1) != 0)
          {
            if (v85 > 64)
            {
              v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
              v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
              v90 = &v116;
              goto LABEL_49;
            }
          }
          else if (v85 >= 64)
          {
            v115 = 0x7FFFFFFFFFFFFFFFLL;
            v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
            v90 = &v115;
LABEL_49:
            v88(v90, &type metadata for Int, v89, a3, a4);
            v92 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(v28, v83, a3);
            v47(v28, a3);
            if ((v92 & 1) != 0)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            goto LABEL_50;
          }
          v49(v28, (uint64_t)v83, a3);
          (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v47(v28, a3);
LABEL_50:
          v47(v83, a3);
LABEL_51:
          v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v94 = v50;
          v35 = v93;
          v47(v94, a3);
          goto LABEL_52;
        }
      }
LABEL_27:
      v35 = -128;
      goto LABEL_52;
    }
  }
  v35 = -128;
  v116 = -128;
  v36 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  v37 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
  v36(&v116, &type metadata for Int, v37, a3, a4);
  v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*(_QWORD *)(a4 + 32) + 8) + 16))(a2, v28, a3);
  (*(void (**)(char *, uint64_t))(v9 + 8))(v28, a3);
  if ((v38 & 1) == 0)
    goto LABEL_10;
LABEL_52:
  v95 = v113;
  v96 = *v113;
  v97 = v113[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v98);
  if ((v35 & 0x8000000000000000) != 0)
  {
    if (v35 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      result = specialized _wideMaskedShiftRight<A>(_:_:)(&v116, v97, v96, v102);
    }
  }
  else
  {
    if (v35 >= 0x80)
    {
      result = 0;
      v101 = 0;
      goto LABEL_56;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    result = specialized _wideMaskedShiftLeft<A>(_:_:)(&v116, v97, v96, v100);
  }
  v101 = v116;
LABEL_56:
  *v95 = v101;
  v95[1] = result;
  return result;
}

Swift::UInt64 protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance _Int128(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::_Int128 *a3)
{
  Swift::tuple_quotient__Int128_remainder__Int128 v6;

  v6 = _Int128.quotientAndRemainder(dividingBy:)(*a3);
  *a1 = v6.quotient.low;
  a1[1] = v6.quotient.high;
  *a2 = v6.remainder.low;
  a2[1] = v6.remainder.high;
  return v6.quotient.low;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance _Int128(uint64_t *a1)
{
  uint64_t *v1;

  return specialized SignedInteger<>.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

BOOL protocol witness for BinaryInteger.signum() in conformance _Int128@<W0>(_BOOL8 *a1@<X8>)
{
  uint64_t v1;
  _BOOL8 result;
  _BOOL8 v4;

  result = specialized BinaryInteger.signum()(*(_QWORD *)v1, *(_QWORD *)(v1 + 8));
  *a1 = result;
  a1[1] = v4;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _Int128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128(a1, a2, (uint64_t (*)(void))specialized String.UTF8View.withContiguousStorageIfAvailable<A>(_:), (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:), a3);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, char *a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  int v16;
  uint64_t v17;
  char v18;
  char v19;
  uint64_t v20;
  uint64_t v21;

  v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  if (v7)
  {
    v10 = a3();
    if ((v12 & 0x100) != 0)
    {
      v13 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
      v14 = v17;
      v19 = v18;
      swift_bridgeObjectRelease(a2);
      v16 = v19 & 1;
    }
    else
    {
      v13 = v10;
      v14 = v11;
      v15 = v12;
      swift_bridgeObjectRelease(a2);
      v16 = v15 & 1;
    }
    if (v16)
      v20 = 0;
    else
      v20 = v13;
    if (v16)
      v21 = 0;
    else
      v21 = v14;
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    v20 = 0;
    v21 = 0;
    LOBYTE(v16) = 1;
  }
  *(_QWORD *)a5 = v20;
  *(_QWORD *)(a5 + 8) = v21;
  *(_BYTE *)(a5 + 16) = v16;
}

void protocol witness for Strideable.distance(to:) in conformance _Int128(unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t *v2;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  BOOL v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  BOOL v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  BOOL v27;

  v4 = *a1;
  v5 = a1[1];
  v6 = *v2;
  v7 = v2[1];
  if (v7)
  {
    if (v5)
    {
      if (v5 < 0 != v7 < 0)
      {
        if (v7 < 0)
        {
          v11 = v6 == 0;
          v6 = -(uint64_t)v6;
          if (v11)
            v7 = -v7;
          else
            v7 = ~v7;
          v8 = 1;
          if ((v5 & 0x8000000000000000) == 0)
            goto LABEL_38;
        }
        else
        {
          v8 = 0;
          if ((v5 & 0x8000000000000000) == 0)
          {
            v9 = v7 + v5;
            v10 = v6 + v4;
            if (!__CFADD__(v6, v4))
              goto LABEL_45;
            goto LABEL_44;
          }
        }
LABEL_10:
        v11 = v4 == 0;
        v4 = -(uint64_t)v4;
        v5 = -(v5 + !v11);
LABEL_38:
        v10 = v6 + v4;
        v21 = __CFADD__(v6, v4);
        v11 = __CFADD__(v7, v5);
        v9 = v7 + v5;
        if (v11)
          goto LABEL_54;
        if (!v21)
        {
LABEL_45:
          v22 = 0;
LABEL_46:
          v23 = v22 + v9;
          specialized static FixedWidthInteger._truncatingInit<A>(_:)();
          v26 = v25 < v10;
          if (v24 != v23)
            v26 = v24 < v23;
          if (!v26)
          {
            if ((v8 & 1) != 0)
              goto LABEL_51;
            v27 = __OFSUB__(0, v10);
            v10 = -(uint64_t)v10;
            if (!v27)
              goto LABEL_51;
            __break(1u);
          }
LABEL_53:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
        }
        if (v9 == -1)
LABEL_54:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x6BuLL, 0);
LABEL_44:
        v22 = 1;
        goto LABEL_46;
      }
    }
    else if (v7 < 0)
    {
      v11 = v6 == 0;
      v6 = -(uint64_t)v6;
      v5 = 0;
      if (v11)
        v7 = -v7;
      else
        v7 = ~v7;
      v8 = 1;
      goto LABEL_38;
    }
  }
  else if (v5 < 0)
  {
    v7 = 0;
    v8 = 0;
    goto LABEL_10;
  }
  v10 = v4 - v6;
  v12 = v4 < v6;
  v13 = v5 - v7;
  v14 = __OFSUB__(v5, v7);
  if (v12)
  {
    if (v13 == 0x8000000000000000)
      LOBYTE(v14) = 1;
    if (v14)
LABEL_19:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v13;
  }
  else if (v14)
  {
    goto LABEL_19;
  }
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  v17 = v10 < v16;
  if (v13 != v15)
    v17 = v13 < v15;
  if (v17)
    goto LABEL_53;
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  v20 = v19 < v10;
  if (v18 != v13)
    v20 = v18 < v13;
  if (v20)
    goto LABEL_53;
LABEL_51:
  *a2 = v10;
}

void protocol witness for Strideable.advanced(by:) in conformance _Int128(_QWORD *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t v8;
  BOOL v9;

  v4 = *v1;
  v3 = v1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  v7 = __CFADD__(v4, v5);
  v8 = v3 + v6;
  if (__OFADD__(v3, v6) || (v7 ? (v9 = v8 == 0x7FFFFFFFFFFFFFFFLL) : (v9 = 0), v9))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  *a1 = v4 + v5;
  a1[1] = v8 + v7;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _Int128(uint64_t a1, uint64_t a2, char a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(uint64_t a1, uint64_t a2, char a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  return a9(a1, a2, a3 & 1, *a4, a4[1], *a5, a5[1], *a6);
}

Swift::UInt64 specialized _wideDivide32<A>(_:by:)(_QWORD *a1, unint64_t *a2, Swift::tuple_high_UInt64_low_UInt64 a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  Swift::UInt64 low;
  Swift::UInt64 high;
  Swift::UInt64 result;
  unint64_t v14;
  Swift::UInt64 v15;
  Swift::UInt64 v16;
  BOOL v17;
  _BOOL4 v18;
  Swift::UInt64 v19;
  unint64_t v20;
  uint64_t v21;

  low = a3.low;
  high = a3.high;
  if (a3.high == a5)
    result = -1;
  else
    result = UInt64.dividingFullWidth(_:)(a3).quotient;
  v14 = result * a6;
  v15 = (__PAIR128__(a5, a6) * result) >> 64;
  if (__CFADD__((result * (unsigned __int128)a6) >> 64, result * a5))
    v16 = ((result * (unsigned __int128)a5) >> 64) + 1;
  else
    v16 = (result * (unsigned __int128)a5) >> 64;
  v17 = high >= v16;
  if (high != v16)
    goto LABEL_14;
LABEL_11:
  v17 = low >= v15;
  if (low != v15)
  {
    while (1)
    {
LABEL_14:
      if (v17)
        goto LABEL_26;
LABEL_15:
      v18 = __CFADD__(a4, a6);
      v19 = low + a5;
      if (__CFADD__(low, a5))
        break;
      if (v19 == -1)
      {
        if (!v18)
        {
          low = -1;
          goto LABEL_10;
        }
        low = 0;
LABEL_24:
        ++high;
        --result;
        a4 += a6;
        v17 = high >= v16;
        if (high == v16)
          goto LABEL_11;
      }
      else
      {
        low = v19 + v18;
LABEL_10:
        a4 += a6;
        --result;
        v17 = high >= v16;
        if (high == v16)
          goto LABEL_11;
      }
    }
    low = v19 + v18;
    goto LABEL_24;
  }
  if (a4 < v14)
    goto LABEL_15;
  low = v15;
LABEL_26:
  v17 = a4 >= v14;
  v20 = a4 - v14;
  v21 = !v17;
  *a1 = low - v15 - v21;
  *a2 = v20;
  return result;
}

uint64_t < infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t *TupleTypeMetadata3;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  void (*v22)(void);
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  void (*v30)(char *, unint64_t *);
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v35 = a4;
  v36 = a5;
  v34 = a3;
  v37 = a10;
  v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  v39 = *(TupleTypeMetadata3 - 1);
  v16 = MEMORY[0x1E0C80A78](TupleTypeMetadata3);
  v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v32 - v19;
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a7 - 8) + 16);
  v21((char *)&v32 - v19, a1, a7);
  v22 = *(void (**)(void))(*(_QWORD *)(a8 - 8) + 16);
  v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  v27 = v37;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v37 + 8) + 8))(v20, v18, a7) & 1) != 0)
    v28 = < infix<A, B>(_:_:)((uint64_t)v33, v23, v25, v26, a8, a9, a11, a12);
  else
    v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 16))(v20, v18, a7, v27);
  v29 = v28;
  v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t > infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *TupleTypeMetadata2;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  void (*v19)(char *, uint64_t, uint64_t);
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char v25;
  char v26;
  void (*v27)(char *, unint64_t *);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v29 = a8;
  v30 = a3;
  v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  v32 = *(TupleTypeMetadata2 - 1);
  v14 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  v19 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 16);
  v19((char *)&v29 - v17, a1, a5);
  v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a6 - 8) + 16);
  v22 = a2;
  v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v23 + 8) + 8))(v18, v16, a5) & 1) != 0)
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v29 + 40))(v20, v24, a6);
  else
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 40))(v18, v16, a5);
  v26 = v25;
  v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

uint64_t >= infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *TupleTypeMetadata2;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  void (*v19)(char *, uint64_t, uint64_t);
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char v25;
  char v26;
  void (*v27)(char *, unint64_t *);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v29 = a8;
  v30 = a3;
  v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  v32 = *(TupleTypeMetadata2 - 1);
  v14 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  v19 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 16);
  v19((char *)&v29 - v17, a1, a5);
  v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a6 - 8) + 16);
  v22 = a2;
  v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v23 + 8) + 8))(v18, v16, a5) & 1) != 0)
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v29 + 32))(v20, v24, a6);
  else
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 32))(v18, v16, a5);
  v26 = v25;
  v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

uint64_t *protocol witness for static SignedNumeric.- prefix(_:) in conformance _Int128@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  uint64_t v8;

  v3 = *result;
  v2 = result[1];
  v4 = __OFSUB__(0, v2);
  v5 = -v2;
  v6 = v4;
  v7 = v3 == 0;
  v8 = -v3;
  if (v7)
  {
    if (v6)
      goto LABEL_8;
  }
  else
  {
    if (v5 == 0x8000000000000000)
      LOBYTE(v6) = 1;
    if ((v6 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v5;
  }
  *a2 = v8;
  a2[1] = v5;
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance _Int128()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  uint64_t v7;

  v2 = *v0;
  v1 = v0[1];
  v3 = __OFSUB__(0, v1);
  v4 = -v1;
  v5 = v3;
  v6 = v2 == 0;
  v7 = -v2;
  if (v6)
  {
    if (v5)
      goto LABEL_8;
  }
  else
  {
    if (v4 == 0x8000000000000000)
      LOBYTE(v5) = 1;
    if ((v5 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v4;
  }
  *v0 = v7;
  v0[1] = v4;
}

_OWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance _Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result + *a2;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance _Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

uint64_t UnsafeMutableBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

char *UnsafeMutableBufferPointer._copyContents(initializing:)(char *__dst, uint64_t a2, char *__src, uint64_t a4, uint64_t a5)
{
  char *v6;
  uint64_t v7;

  v6 = __src;
  if (a4 && a2)
  {
    if (a4 >= a2)
      v7 = a2;
    else
      v7 = a4;
    UnsafeMutablePointer.initialize(from:count:)(__src, v7, __dst, a5);
    v6 += *(_QWORD *)(*(_QWORD *)(a5 - 8) + 72) * v7;
  }
  return v6;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(_QWORD, _QWORD, _QWORD))UnsafeMutableBufferPointer.makeIterator(), a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(a1, a2, (uint64_t)&protocol conformance descriptor for UnsafeMutableBufferPointer<A>);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))UnsafeMutableBufferPointer._copyContents(initializing:));
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.index(after:)(Swift::Int after)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  return UnsafeMutableBufferPointer.index(after:)(after, v1, v2, v3, 0xC9uLL);
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.formIndex(after:)(Swift::Int *after)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  UnsafeMutableBufferPointer.formIndex(after:)(after, v1, v2, v3, 0xD7uLL);
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.index(before:)(Swift::Int before)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  return UnsafeMutableBufferPointer.index(before:)(before, v1, v2, v3, 0xE5uLL);
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.formIndex(before:)(Swift::Int *before)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  UnsafeMutableBufferPointer.formIndex(before:)(before, v1, v2, v3, 0xF3uLL);
}

Swift::Int_optional __swiftcall UnsafeMutableBufferPointer.index(_:offsetBy:limitedBy:)(Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3;
  char v4;
  Swift::Bool v5;
  Swift::Int_optional result;

  v3 = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy, 0x10FuLL, 0x117uLL);
  v5 = v4 & 1;
  result.value = v3;
  result.is_nil = v5;
  return result;
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.swapAt(_:_:)(Swift::Int a1, Swift::Int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  void (*v14)(char *, char *, uint64_t);
  uint64_t v15;

  v3 = v2;
  v4 = MEMORY[0x1E0C80A78](a1);
  v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v4 != v5)
  {
    if ((v5 | v4) < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x17AuLL, 0);
    if (v7 <= v4 || v7 <= v5)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x17BuLL, 0);
    if (!v6)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x17CuLL, 0);
    v11 = *(_QWORD *)(v8 + 72);
    v12 = (char *)(v6 + v11 * v4);
    v13 = (char *)(v6 + v11 * v5);
    v14 = *(void (**)(char *, char *, uint64_t))(v8 + 32);
    v14(v10, v12, v3);
    UnsafeMutablePointer.moveInitialize(from:count:)(v13, 1, v12, v3);
    v14(v13, v10, v3);
  }
}

uint64_t UnsafeMutableBufferPointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return UnsafeBufferPointer.subscript.getter(a1, a2, a3, a4, 0x206uLL, 0x207uLL, a5);
}

uint64_t UnsafeBufferPointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  if (a1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  if (a3 <= a1)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 16))(a7, a2 + *(_QWORD *)(*(_QWORD *)(a4 - 8) + 72) * a1, a4);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *a2;
  if (*a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x206uLL, 0);
  if (v4 >= a1[1])
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x207uLL, 0);
  v5 = *(_QWORD *)(*(uint64_t *)((char *)a2 + a3 - 8) - 8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 16))(a4, *a1 + *(_QWORD *)(v5 + 72) * v4);
}

uint64_t key path setter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A(uint64_t a1, _QWORD *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *a3;
  if (*a3 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  if (v4 >= a2[1])
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  v5 = *(_QWORD *)(*(uint64_t *)((char *)a3 + a4 - 8) - 8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 24))(*a2 + *(_QWORD *)(v5 + 72) * v4, a1);
}

uint64_t UnsafeMutableBufferPointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;

  v10 = *(_QWORD *)(a5 - 8);
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)&v15 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, a1, v13);
  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  if (a4 <= a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  (*(void (**)(uint64_t, uint64_t))(v10 + 8))(a1, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v10 + 40))(a3 + *(_QWORD *)(v10 + 72) * a2, v12, a5);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 40))(a3 + *(_QWORD *)(*(_QWORD *)(a5 - 8) + 72) * a2, a1, a5);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_unchecked:) : <A>UnsafeMutableBufferPointer<A>A(_QWORD *a1, _QWORD *a2)
{
  return UnsafeBufferPointer.subscript.getter(*a2, *a1);
}

uint64_t key path setter for UnsafeMutableBufferPointer.subscript(_unchecked:) : <A>UnsafeMutableBufferPointer<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t (*v6)();
  uint64_t v7;
  uint64_t v9;

  v5 = *(_QWORD *)(a4 + a3 - 8);
  v6 = UnsafeMutableBufferPointer.subscript.modify();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 24))(v7, a1, v5);
  return ((uint64_t (*)(uint64_t *, _QWORD))v6)(&v9, 0);
}

uint64_t (*UnsafeMutableBufferPointer.subscript.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, 0x234uLL, 0x235uLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, a7, 0x23BuLL, 0x23CuLL);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = UnsafeMutableBufferPointer.subscript.getter(*a2, a2[1], *a1, a1[1], a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

char *key path setter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a3, a3[1], *a2, a2[1], *(uint64_t *)((char *)a3 + a4 - 8));
}

char *UnsafeMutableBufferPointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  char *v10;
  uint64_t v15;
  uint64_t v16;
  uint64_t WitnessTable;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *result;
  unint64_t v23;

  if (a5 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x26CuLL, 0);
  if (a8 < a6)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x26DuLL, 0);
  v10 = (char *)(a6 - a5);
  if (__OFSUB__(a6, a5))
  {
    __break(1u);
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x26EuLL, 0);
  }
  v15 = type metadata accessor for UnsafeMutableBufferPointer(255, a9, a3, a4);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v15, v16);
  v19 = type metadata accessor for Slice(0, v15, WitnessTable, v18);
  v21 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v19, v20);
  result = (char *)Collection.count.getter(v19, v21);
  if (v10 != result)
    goto LABEL_14;
  if (a1 == a2)
    return result;
  if (!a7)
  {
    v23 = 626;
    goto LABEL_18;
  }
  if (!a3)
  {
    v23 = 627;
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v23, 0);
  }
  if (__OFSUB__(a2, a1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x129uLL, 0);
  return UnsafeMutablePointer.assign(from:count:)((char *)(a3 + *(_QWORD *)(*(_QWORD *)(a9 - 8) + 72) * a1), a2 - a1, (char *)(a7 + *(_QWORD *)(*(_QWORD *)(a9 - 8) + 72) * a5), a9);
}

void (*UnsafeMutableBufferPointer.subscript.modify(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6))(uint64_t **a1)
{
  _QWORD *v12;

  v12 = malloc(0x48uLL);
  *a1 = v12;
  v12[7] = a5;
  v12[8] = a6;
  v12[5] = a3;
  v12[6] = a4;
  v12[4] = a2;
  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x265uLL, 0);
  if (a5 < a3)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x266uLL, 0);
  *v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  return UnsafeMutableBufferPointer.subscript.modify;
}

void UnsafeMutableBufferPointer.subscript.modify(uint64_t **a1)
{
  uint64_t *v1;

  v1 = *a1;
  UnsafeMutableBufferPointer.subscript.setter(**a1, v1[1], v1[2], (*a1)[3], (*a1)[4], (*a1)[5], (*a1)[6], (*a1)[7], (*a1)[8]);
  free(v1);
}

uint64_t UnsafeMutableBufferPointer._withUnsafeMutableBufferPointerIfSupported<A>(_:)@<X0>(uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  result = a1(v3);
  if (!v4)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a2 - 8) + 56))(a3, 0, 1, a2);
  return result;
}

BOOL UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<W0>(void (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _UNKNOWN ***v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t WitnessTable;
  _BOOL8 result;
  _UNKNOWN **v29;
  _UNKNOWN **v30;
  uint64_t v31;
  uint64_t v32;

  v6 = v4;
  v11 = *v4;
  v10 = v4[1];
  a1(v4);
  if (v5)
  {
    v14 = v4[1];
    v15 = *(_QWORD *)(a2 + 16);
    v31 = *v6;
    v32 = v11;
    v16 = type metadata accessor for UnsafeMutablePointer(255, v15, v12, v13);
    v19 = type metadata accessor for Optional(0, v16, v17, v18);
    v30 = &protocol witness table for UnsafeMutablePointer<A>;
    v20 = &v30;
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 56))(a4, 0, 1, a3);
    v14 = v4[1];
    v21 = *(_QWORD *)(a2 + 16);
    v31 = *v6;
    v32 = v11;
    v24 = type metadata accessor for UnsafeMutablePointer(255, v21, v22, v23);
    v19 = type metadata accessor for Optional(0, v24, v25, v26);
    v29 = &protocol witness table for UnsafeMutablePointer<A>;
    v20 = &v29;
  }
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, v19, v20);
  result = specialized == infix<A, B>(_:_:)((uint64_t)&v32, v10, (uint64_t)&v31, v14, v19, WitnessTable);
  if (!result)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed", 103, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x289uLL, 0);
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t *v3;
  _QWORD *v7;

  v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = UnsafeMutableBufferPointer.subscript.read(v7, *a2, *v3, v3[1], *(_QWORD *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*UnsafeMutableBufferPointer.subscript.read(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v7;

  v7 = *(_QWORD *)(a5 - 8);
  *a1 = a5;
  a1[1] = v7;
  a1[2] = malloc(*(_QWORD *)(v7 + 64));
  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x206uLL, 0);
  if (a4 <= a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x207uLL, 0);
  (*(void (**)(void))(v7 + 16))();
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))UnsafeMutableBufferPointer.subscript.getter, a2);
}

_QWORD *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, 0x101uLL, a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>(a1, a2, a3, 0x10FuLL, 0x117uLL, a4);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, unint64_t a4@<X5>, unint64_t a5@<X6>, uint64_t a6@<X8>)
{
  uint64_t result;
  char v8;

  result = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(*a1, a2, *a3, a4, a5);
  *(_QWORD *)a6 = result;
  *(_BYTE *)(a6 + 8) = v8 & 1;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x129uLL);
}

_QWORD *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x234uLL, 0x235uLL);
}

{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x23BuLL, 0x23CuLL);
}

_QWORD *protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>(a1, 0xC9uLL, a2);
}

_QWORD *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0xD7uLL);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = *v9;
  v12 = *v3;
  v11 = v3[1];
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, v5);
  if (v10 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  if (v10 >= v11)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v6 + 40))(v12 + *(_QWORD *)(v6 + 72) * v10, v8, v5);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableBufferPointer<A>(uint64_t a1, _QWORD *a2))()
{
  uint64_t v2;

  if ((*a2 & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  if (*a2 >= *(_QWORD *)(v2 + 8))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  return EnumeratedSequence._base.modify;
}

char *protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableBufferPointer<A>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v3;

  return UnsafeMutableBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a2, a2[1], *v3, v3[1], *(_QWORD *)(a3 + 16));
}

void (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, uint64_t *a2, uint64_t a3))(uint64_t **a1)
{
  uint64_t *v3;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v7 = malloc(0x48uLL);
  *a1 = v7;
  v8 = *a2;
  v9 = a2[1];
  v7[4] = *a2;
  v7[5] = v9;
  v10 = *v3;
  v11 = v3[1];
  v7[6] = *v3;
  v7[7] = v11;
  v7[8] = *(_QWORD *)(a3 + 16);
  if (v8 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x265uLL, 0);
  if (v11 < v9)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x266uLL, 0);
  *v7 = v8;
  v7[1] = v9;
  v7[2] = v10;
  v7[3] = v11;
  return UnsafeMutableBufferPointer.subscript.modify;
}

_QWORD *protocol witness for MutableCollection.partition(by:) in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a3, a3);
  return MutableCollection<>.partition(by:)(a1, a2, a3, WitnessTable, a4, a5);
}

void protocol witness for MutableCollection.swapAt(_:_:) in conformance UnsafeMutableBufferPointer<A>(Swift::Int *a1, Swift::Int *a2)
{
  UnsafeMutableBufferPointer.swapAt(_:_:)(*a1, *a2);
}

uint64_t protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeMutableBufferPointer._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3);
}

BOOL protocol witness for MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<W0>(void (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a3, a2, a4);
}

_QWORD *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>(a1, 0xE5uLL, a2);
}

_QWORD *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0xF3uLL);
}

uint64_t UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t)partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error), (uint64_t (*)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_sSrsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_Sryqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSryxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5);
}

unint64_t UnsafeMutableBufferPointer.debugDescription.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  Swift::Int v25;
  unint64_t v26;
  int64_t v27;
  char v28;
  int64_t v29;
  char v30;
  BOOL v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  unint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  size_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  unsigned __int8 *v56;
  Swift::String::Index v57;
  Swift::String::Index v58;
  Swift::String::Index v59;
  Swift::String::Index v60;
  int64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  char v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  Class *v79;
  unint64_t v80;
  uint64_t countAndFlagsBits;
  unint64_t object;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  char *v90;
  BOOL v91;
  Swift::Int v92;
  uint64_t v93;
  int64_t v94;
  char v95;
  int64_t v96;
  char v97;
  uint64_t v99;
  char v100;
  uint64_t v101;
  uint64_t v102;
  char *v103;
  size_t v104;
  int v105;
  char v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  char v113;
  uint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  id v118;
  uint64_t v119;
  char *v120;
  size_t v121;
  Swift::String::Index v122;
  Swift::String::Index v123;
  Swift::String::Index v124;
  Swift::String::Index v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  char v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  char v138;
  uint64_t v139;
  unint64_t v140;
  Swift::Int v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  uint64_t v145;
  char *v146;
  Swift::String v147;
  uint64_t v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  uint64_t v152;
  char *v153;
  Swift::Int v154;
  uint64_t v155;
  uint64_t v156;
  int64_t v157;
  char v158;
  char *v159;
  size_t v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  Swift::String::Index v168;
  Swift::String::Index v169;
  Swift::String::Index v170;
  Swift::String::Index v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  void *v179;
  uint64_t v180;
  char v181;
  uint64_t v182;
  void *v183;
  unint64_t v184;
  unint64_t v185;
  uint64_t v186;
  char *v187;
  unint64_t v188;
  unint64_t v189;
  Swift::Int v190;
  int64_t v191;
  unint64_t v192;
  int64_t v193;
  char v194;
  char *v195;
  size_t v196;
  uint64_t v197;
  uint64_t v198;
  char *v199;
  unint64_t v200;
  uint64_t v201;
  uint64_t v202;
  char *v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  Swift::String::Index v207;
  Swift::String::Index v208;
  Swift::String::Index v209;
  Swift::String::Index v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  void *v218;
  char v219;
  uint64_t v220;
  void *v221;
  char v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  char v229;
  uint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  char v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  char v241;
  uint64_t v242;
  unint64_t v243;
  unint64_t v244;
  unint64_t v245;
  id v246;
  uint64_t v247;
  char *v248;
  size_t v249;
  id v250;
  uint64_t v251;
  char *v252;
  size_t v253;
  unint64_t v254;
  unint64_t v255;
  void *v256;
  unint64_t v257;
  unint64_t v258;
  uint64_t v259;
  uint64_t v260;
  unint64_t v261;
  Swift::String::Index v263;
  Swift::String::Index v264;
  Swift::String::Index v265;
  Swift::String::Index v266;
  Swift::Int v267;
  Swift::String::Index v268;
  Swift::String::Index v269;
  Swift::String::Index v270;
  Swift::String::Index v271;
  Swift::Int v272;
  Swift::String::Index v273;
  Swift::String::Index v274;
  Swift::String::Index v275;
  Swift::String::Index v276;
  Swift::Int v277;
  Swift::Int v278;
  unsigned __int8 *v279;
  uint64_t v280;
  unsigned __int8 *v281;
  uint64_t v282;
  unsigned __int8 *v283;
  uint64_t v284;
  unint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  unint64_t v289;
  Swift::Int v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t v293;
  unint64_t v294;
  uint64_t v295;
  uint64_t v296;
  __int128 v297;
  Swift::String v298;

  v6 = specialized static String._createEmpty(withInitialCapacity:)(22);
  v10 = v6;
  v11 = v7;
  v298._countAndFlagsBits = v6;
  v298._object = (void *)v7;
  v12 = HIBYTE(v7) & 0xF;
  v13 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000) != 0)
    v14 = HIBYTE(v7) & 0xF;
  else
    v14 = v6 & 0xFFFFFFFFFFFFLL;
  if (!v14 && (v6 & ~v7 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v298._countAndFlagsBits = 0x203A747261747328;
    v298._object = (void *)0xE800000000000000;
    if (a1)
      goto LABEL_80;
    goto LABEL_58;
  }
  if ((v7 & 0x2000000000000000) == 0 || v12 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6, v8, v9);
    if ((v11 & 0x1000000000000000) == 0)
    {
      v25 = v14 + 8;
      if (!__OFADD__(v14, 8))
        goto LABEL_13;
      goto LABEL_310;
    }
    goto LABEL_308;
  }
  v15 = 8 * HIBYTE(v7);
  v16 = (40 << (v15 & 0x38)) | ((-255 << (v15 & 0x38)) - 1) & v6;
  v17 = (v15 + 8) & 0x38;
  v18 = (-255 << v17) - 1;
  v19 = 115 << v17;
  if (v12 >= 7)
  {
    v21 = v19 | v18 & v7;
    v20 = 8;
    goto LABEL_32;
  }
  v16 = v19 | v18 & v16;
  if (v12 == 6)
  {
    v20 = 0;
    v21 = v7;
LABEL_32:
    v33 = (116 << v20) | ((-255 << v20) - 1) & v21;
    v34 = v12 + 3;
LABEL_33:
    v35 = (97 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v33;
    v36 = v12 + 4;
LABEL_34:
    v37 = (114 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v35;
    v38 = v12 + 5;
LABEL_35:
    v39 = (116 << (8 * (v38 & 7u))) | ((-255 << (8 * (v38 & 7u))) - 1) & v37;
    v40 = v12 + 6;
LABEL_36:
    v41 = (58 << (8 * (v40 & 7u))) | ((-255 << (8 * (v40 & 7u))) - 1) & v39;
    v42 = v12 + 7;
    goto LABEL_37;
  }
  v16 = (116 << ((v15 + 16) & 0x38)) | ((-255 << ((v15 + 16) & 0x38)) - 1) & v16;
  if (v12 >= 5)
  {
    v34 = 8;
    v33 = v7;
    goto LABEL_33;
  }
  v16 = (97 << ((v15 + 24) & 0x38)) | ((-255 << ((v15 + 24) & 0x38)) - 1) & v16;
  if (v12 == 4)
  {
    v36 = 8;
    v35 = v7;
    goto LABEL_34;
  }
  v16 = (114 << ((v15 + 32) & 0x38)) | ((-255 << ((v15 + 32) & 0x38)) - 1) & v16;
  if (v12 >= 3)
  {
    v38 = 8;
    v37 = v7;
    goto LABEL_35;
  }
  v16 = (116 << ((v15 + 40) & 0x38)) | ((-255 << ((v15 + 40) & 0x38)) - 1) & v16;
  if (v12 == 2)
  {
    v40 = 8;
    v39 = v7;
    goto LABEL_36;
  }
  v16 = (58 << ((v15 + 48) & 0x38)) | ((-255 << ((v15 + 48) & 0x38)) - 1) & v16;
  if (!v12)
  {
    v16 = (32 << ((v15 + 56) & 0x38)) | ((-255 << ((v15 + 56) & 0x38)) - 1) & v16;
    v43 = v7;
    goto LABEL_38;
  }
  v42 = 8;
  v41 = v7;
LABEL_37:
  v43 = (32 << (8 * (v42 & 7u))) | ((-255 << (8 * (v42 & 7u))) - 1) & v41;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000);
  v46 = 0xA000000000000000;
  if (!(v16 & 0x8080808080808080 | v43 & 0x80808080808080))
    v46 = 0xE000000000000000;
  v298._countAndFlagsBits = v16;
  v298._object = (void *)((v46 & 0xFF00000000000000 | (v12 << 56) | v43 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  if (a1)
    goto LABEL_80;
LABEL_58:
  a3 = 0xE300000000000000;
  a1 = 7104878;
  while (1)
  {
    countAndFlagsBits = v298._countAndFlagsBits;
    object = (unint64_t)v298._object;
    v83 = ((unint64_t)v298._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      v84 = ((unint64_t)v298._object >> 56) & 0xF;
    else
      v84 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    v296 = a2;
    if (!v84 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._countAndFlagsBits = a1;
      v298._object = (void *)a3;
      goto LABEL_170;
    }
    v10 = a3 & 0x2000000000000000;
    v13 = HIBYTE(a3) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0 && v10)
    {
      v85 = v83 + v13;
      if (v83 + v13 <= 0xF)
      {
        if (v13)
        {
          v106 = 0;
          v107 = 0;
          v108 = (unint64_t)v298._object;
          do
          {
            v109 = v83 + v107;
            v110 = v107 + 1;
            if (v107 >= 8)
              v111 = a3;
            else
              v111 = a1;
            v112 = v111 >> (v106 & 0x38);
            v113 = (8 * v83 + v106) & 0x38;
            v114 = (-255 << v113) - 1;
            v115 = (unint64_t)v112 << v113;
            v116 = v115 | v114 & v108;
            v117 = v115 | v114 & countAndFlagsBits;
            if (v109 < 8)
              countAndFlagsBits = v117;
            else
              v108 = v116;
            v106 += 8;
            v107 = v110;
          }
          while (v13 != v110);
        }
        else
        {
          v108 = (unint64_t)v298._object;
        }
        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(a3);
        v144 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v108 & 0x80808080808080))
          v144 = 0xE000000000000000;
        v298._countAndFlagsBits = countAndFlagsBits;
        v298._object = (void *)(v144 & 0xFF00000000000000 | (v85 << 56) | v108 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      v10 = 1;
    }
    v61 = a1 & 0xFFFFFFFFFFFFLL;
    v86 = v10 ? HIBYTE(a3) & 0xF : a1 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a3, 2, v44, v45);
    if ((a3 & 0x1000000000000000) != 0)
      break;
    swift_bridgeObjectRetain_n(a3, 4, v87, v88);
    a2 = v86;
    if ((object & 0x1000000000000000) != 0)
      goto LABEL_293;
LABEL_95:
    v91 = __OFADD__(v84, a2);
    v92 = v84 + a2;
    if (v91)
      goto LABEL_295;
LABEL_96:
    v295 = v86;
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v92 >= 16)
      {
        v93 = v298._countAndFlagsBits;
        v11 = (unint64_t)v298._object;
        goto LABEL_105;
      }
      v25 = (Swift::Int)v298._object;
      if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      {
        v105 = 0;
        v11 = (unint64_t)v298._object;
      }
      else
      {
        v11 = (unint64_t)v298._object;
LABEL_128:
        v105 = 1;
      }
LABEL_147:
      swift_bridgeObjectRelease_n(a3, 5);
      v13 = v298._countAndFlagsBits;
      if (v105)
      {
LABEL_311:
        if ((v25 & 0x1000000000000000) != 0)
        {
          v13 = _StringGuts._foreignConvertedToSmall()(v13, v11);
          v25 = v290;
        }
        else
        {
          if ((v13 & 0x1000000000000000) != 0)
          {
            v279 = (unsigned __int8 *)((v25 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v280 = v13 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            v279 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v13, v11);
            v280 = v22;
          }
          swift_bridgeObjectRetain(v11, v22, v23, v24);
          closure #1 in _StringGuts._convertedToSmall()(v279, v280, &v297);
          swift_bridgeObjectRelease(v11);
          v25 = *((_QWORD *)&v297 + 1);
          v13 = v297;
        }
      }
      v122._rawBits = (v295 << 16) | 1;
      v123._rawBits = 1;
      v124._rawBits = _StringGuts.validateScalarRange(_:)(v123, v122, a1, a3);
      if (v124._rawBits < 0x10000)
        v124._rawBits |= 3;
      v126 = specialized String.init(_:)(v124, v125, a1, a3);
      v128 = v127;
      swift_bridgeObjectRelease(a3);
      if ((v128 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v128);
      }
      else if ((v128 & 0x1000000000000000) != 0)
      {
        v126 = _StringGuts._foreignConvertedToSmall()(v126, v128);
        v292 = v291;
        swift_bridgeObjectRelease(v128);
        v128 = v292;
      }
      else
      {
        if ((v126 & 0x1000000000000000) != 0)
        {
          v281 = (unsigned __int8 *)((v128 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v282 = v126 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v281 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v126, v128);
        }
        closure #1 in _StringGuts._convertedToSmall()(v281, v282, &v297);
        swift_bridgeObjectRelease(v128);
        v128 = *((_QWORD *)&v297 + 1);
        v126 = v297;
      }
      v129 = HIBYTE(v25) & 0xF;
      v130 = HIBYTE(v128) & 0xF;
      v131 = v130 + v129;
      if ((unint64_t)(v130 + v129) > 0xF)
        goto LABEL_333;
      if (v130)
      {
        v132 = 0;
        v133 = 0;
        do
        {
          v134 = v129 + v133;
          v135 = v133 + 1;
          if (v133 >= 8)
            v136 = v128;
          else
            v136 = v126;
          v137 = v136 >> (v132 & 0x38);
          v138 = (8 * v129 + v132) & 0x38;
          v139 = (-255 << v138) - 1;
          v140 = (unint64_t)v137 << v138;
          v141 = v140 | v139 & v25;
          v142 = v140 | v139 & v13;
          if (v134 < 8)
            v13 = v142;
          else
            v25 = v141;
          v132 += 8;
          v133 = v135;
        }
        while (v130 != v135);
      }
      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(a3);
      v143 = 0xA000000000000000;
      if (!(v13 & 0x8080808080808080 | v25 & 0x80808080808080))
        v143 = 0xE000000000000000;
      v298._countAndFlagsBits = v13;
      v298._object = (void *)(v143 & 0xFF00000000000000 | (v131 << 56) | v25 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    v93 = v298._countAndFlagsBits;
    v11 = (unint64_t)v298._object;
    v94 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v95 & 1) != 0)
      goto LABEL_334;
    if (v92 <= 15)
    {
      if ((v11 & 0x2000000000000000) != 0)
      {
        v105 = 0;
        v25 = v11;
        goto LABEL_147;
      }
      v25 = v11;
      if (v94 < a2)
        goto LABEL_128;
    }
LABEL_105:
    v96 = _StringGuts.nativeUnusedCapacity.getter(v93, v11);
    v63 = (v97 & 1) == 0 && v96 >= a2;
    if ((v93 & ~v11 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v63 & 1) != 0)
        goto LABEL_123;
LABEL_116:
      v99 = _StringGuts.nativeCapacity.getter(v93, v11);
      if ((v100 & 1) != 0)
        v101 = 0;
      else
        v101 = v99;
      if (v101 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_320;
      }
      v102 = 2 * v101;
      if (v102 > v92)
        v92 = v102;
      goto LABEL_122;
    }
    if ((v63 & 1) == 0)
      goto LABEL_116;
LABEL_122:
    _StringGuts.grow(_:)(v92);
LABEL_123:
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v295);
    }
    else
    {
      if (v10)
      {
        swift_bridgeObjectRelease_n(a3, 2);
        *(_QWORD *)&v297 = a1;
        *((_QWORD *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
        v103 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(a3) & 0xF, (uint64_t)&v297, HIBYTE(a3) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v103, v104, (a3 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(a3);
        goto LABEL_170;
      }
      if ((a1 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(a3);
        v118 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v119 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v118 = _StringObject.sharedUTF8.getter(a1, a3);
        v119 = v288;
        swift_bridgeObjectRelease(a3);
        if (v119 < v61)
          goto LABEL_332;
      }
      v120 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1 & 0xFFFFFFFFFFFFLL, (uint64_t)v118, v119);
      _StringGuts.appendInPlace(_:isASCII:)(v120, v121, a1 < 0);
    }
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_170:
    v147 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    a1 = v147._countAndFlagsBits;
    a3 = (unint64_t)v147._object;
    v148 = v298._countAndFlagsBits;
    v11 = (unint64_t)v298._object;
    v149 = ((unint64_t)v298._object >> 56) & 0xF;
    v150 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      v150 = ((unint64_t)v298._object >> 56) & 0xF;
    if (!v150 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298 = v147;
      goto LABEL_204;
    }
    a2 = (uint64_t)v147._object & 0x2000000000000000;
    v10 = ((unint64_t)v147._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0 && a2)
    {
      v151 = v149 + v10;
      if (v149 + v10 <= 0xF)
      {
        v180 = v296;
        if (v10)
        {
          v222 = 0;
          v223 = 0;
          v224 = (unint64_t)v298._object;
          do
          {
            v225 = v149 + v223;
            v226 = v223 + 1;
            if (v223 >= 8)
              v227 = (unint64_t)v147._object;
            else
              v227 = v147._countAndFlagsBits;
            v228 = v227 >> (v222 & 0x38);
            v229 = (8 * v149 + v222) & 0x38;
            v230 = (-255 << v229) - 1;
            v231 = (unint64_t)v228 << v229;
            v232 = v231 | v230 & v224;
            v233 = v231 | v230 & v148;
            if (v225 < 8)
              v148 = v233;
            else
              v224 = v232;
            v222 += 8;
            v223 = v226;
          }
          while (v10 != v226);
        }
        else
        {
          v224 = (unint64_t)v298._object;
        }
        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease((uint64_t)v147._object);
        v254 = 0xA000000000000000;
        if (!(v148 & 0x8080808080808080 | v224 & 0x80808080808080))
          v254 = 0xE000000000000000;
        v298._countAndFlagsBits = v148;
        v298._object = (void *)(v254 & 0xFF00000000000000 | (v151 << 56) | v224 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_205;
      }
      a2 = 1;
    }
    v13 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a2)
      v61 = ((unint64_t)v147._object >> 56) & 0xF;
    else
      v61 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 2, v145, v146);
    if (((uint64_t)v147._object & 0x1000000000000000) != 0)
      goto LABEL_296;
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 4, v89, v90);
    v154 = v61;
    if ((v11 & 0x1000000000000000) != 0)
      goto LABEL_299;
LABEL_183:
    if ((v11 & 0x2000000000000000) != 0)
    {
      v156 = HIBYTE(v11) & 0xF;
      v155 = v156 + v154;
      if (__OFADD__(v156, v154))
        goto LABEL_301;
    }
    else
    {
      v155 = (v148 & 0xFFFFFFFFFFFFLL) + v154;
      if (__OFADD__(v148 & 0xFFFFFFFFFFFFLL, v154))
        goto LABEL_301;
    }
LABEL_188:
    if ((v148 & ~v11 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      v157 = _StringGuts.nativeUnusedCapacity.getter(v148, v11);
      if ((v158 & 1) != 0)
        goto LABEL_334;
      if (v155 <= 15 && ((v11 & 0x2000000000000000) != 0 || v157 < v154))
      {
LABEL_198:
        swift_bridgeObjectRelease_n(a3, 5);
        v161 = v298._countAndFlagsBits;
        swift_bridgeObjectRetain(v11, v162, v163, v164);
        v165 = _StringGuts._convertedToSmall()(v161, v11);
        v167 = v166;
        swift_bridgeObjectRelease(v11);
        v168._rawBits = (v61 << 16) | 1;
        v169._rawBits = 1;
        v170._rawBits = _StringGuts.validateScalarRange(_:)(v169, v168, a1, a3);
        if (v170._rawBits < 0x10000)
          v170._rawBits |= 3;
        v172 = specialized String.init(_:)(v170, v171, a1, a3);
        v174 = v173;
        swift_bridgeObjectRelease(a3);
        v175 = _StringGuts._convertedToSmall()(v172, v174);
        v177 = v176;
        swift_bridgeObjectRelease(v174);
        v178 = specialized _SmallString.init(_:appending:)(v165, v167, v175, v177);
        v180 = v296;
        if ((v181 & 1) != 0)
          goto LABEL_333;
        v182 = v178;
        v183 = v179;
        swift_bridgeObjectRelease(v11);
        swift_bridgeObjectRelease(a3);
        v298._countAndFlagsBits = v182;
        v298._object = v183;
        goto LABEL_205;
      }
    }
    else if (v155 <= 15)
    {
      goto LABEL_198;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v155, v154);
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v61);
      swift_bridgeObjectRelease_n(a3, 2);
      goto LABEL_204;
    }
    if (a2)
    {
      swift_bridgeObjectRelease_n(a3, 2);
      *(_QWORD *)&v297 = a1;
      *((_QWORD *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
      v159 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v10, (uint64_t)&v297, v10);
      _StringGuts.appendInPlace(_:isASCII:)(v159, v160, (a3 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(a3);
LABEL_204:
      v180 = v296;
      goto LABEL_205;
    }
    if ((a1 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      v246 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v247 = v13;
    }
    else
    {
      v246 = _StringObject.sharedUTF8.getter(a1, a3);
      v247 = v286;
      swift_bridgeObjectRelease(a3);
      if (v247 < (uint64_t)v13)
        goto LABEL_332;
    }
    v180 = v296;
    v248 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v13, (uint64_t)v246, v247);
    _StringGuts.appendInPlace(_:isASCII:)(v248, v249, a1 < 0);
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_205:
    v184 = _int64ToString(_:radix:uppercase:)(v180, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
    a3 = v184;
    v155 = v185;
    v11 = v298._countAndFlagsBits;
    v10 = (uint64_t)v298._object;
    v188 = ((unint64_t)v298._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      v61 = ((unint64_t)v298._object >> 56) & 0xF;
    else
      v61 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v61 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._countAndFlagsBits = a3;
      v298._object = (void *)v155;
      goto LABEL_273;
    }
    a2 = v185 & 0x2000000000000000;
    a1 = HIBYTE(v185) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0 && a2)
    {
      v189 = v188 + a1;
      if (v188 + a1 <= 0xF)
      {
        if (a1)
        {
          v234 = 0;
          v235 = 0;
          v236 = (unint64_t)v298._object;
          do
          {
            v237 = v188 + v235;
            v238 = v235 + 1;
            if (v235 >= 8)
              v239 = v185;
            else
              v239 = v184;
            v240 = v239 >> (v234 & 0x38);
            v241 = (8 * v188 + v234) & 0x38;
            v242 = (-255 << v241) - 1;
            v243 = (unint64_t)v240 << v241;
            v244 = v243 | v242 & v236;
            v245 = v243 | v242 & v11;
            if (v237 < 8)
              v11 = v245;
            else
              v236 = v244;
            v234 += 8;
            v235 = v238;
          }
          while (a1 != v238);
        }
        else
        {
          v236 = (unint64_t)v298._object;
        }
        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(v155);
        v255 = 0xA000000000000000;
        if (!(v11 & 0x8080808080808080 | v236 & 0x80808080808080))
          v255 = 0xE000000000000000;
        v298._countAndFlagsBits = v11;
        v298._object = (void *)(v255 & 0xFF00000000000000 | (v189 << 56) | v236 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_273;
      }
      a2 = 1;
    }
    v148 = v184 & 0xFFFFFFFFFFFFLL;
    if (a2)
      v13 = HIBYTE(v185) & 0xF;
    else
      v13 = v184 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v185, 2, v186, v187);
    if ((v155 & 0x1000000000000000) != 0)
      goto LABEL_302;
    swift_bridgeObjectRetain_n(v155, 4, v152, v153);
    v190 = v13;
    if ((v10 & 0x1000000000000000) != 0)
      goto LABEL_305;
LABEL_219:
    v91 = __OFADD__(v61, v190);
    v191 = v61 + v190;
    if (!v91)
      goto LABEL_220;
LABEL_307:
    __break(1u);
LABEL_308:
    v278 = String.UTF8View._foreignCount()();
    v25 = v278 + 8;
    if (__OFADD__(v278, 8))
    {
LABEL_310:
      __break(1u);
      goto LABEL_311;
    }
LABEL_13:
    v26 = v10 & ~v11;
    if ((v26 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      v27 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
      if ((v28 & 1) != 0)
        goto LABEL_334;
      if (v25 > 15)
        goto LABEL_21;
      if ((v11 & 0x2000000000000000) != 0)
        goto LABEL_62;
      if (v27 > 7)
      {
LABEL_21:
        v29 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
        v32 = (v30 & 1) == 0 && v29 > 7;
        if ((v26 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v32)
            goto LABEL_50;
        }
        else if (v32)
        {
          goto LABEL_49;
        }
        v47 = _StringGuts.nativeCapacity.getter(v10, v11);
        if ((v48 & 1) != 0)
          v49 = 0;
        else
          v49 = v47;
        if (v49 + 0x4000000000000000 >= 0)
        {
          v50 = 2 * v49;
          if (v50 > v25)
            v25 = v50;
LABEL_49:
          _StringGuts.grow(_:)(v25);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          v297 = xmmword_1816ABF40;
          v51 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v297, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v51, v52, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          if (!a1)
            goto LABEL_58;
          goto LABEL_80;
        }
        __break(1u);
LABEL_325:
        v10 = _StringGuts._foreignConvertedToSmall()(v10, v11);
        v13 = v285;
        goto LABEL_63;
      }
    }
    else
    {
      if (v25 > 15)
        goto LABEL_21;
      if ((v11 & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        v13 = v11;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((v11 & 0x1000000000000000) != 0)
      goto LABEL_325;
    if ((v10 & 0x1000000000000000) != 0)
    {
      v56 = (unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v56 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v11);
      v13 = v53;
    }
    swift_bridgeObjectRetain(v11, v53, v54, v55);
    closure #1 in _StringGuts._convertedToSmall()(v56, v13, &v297);
    swift_bridgeObjectRelease(v11);
    v13 = *((_QWORD *)&v297 + 1);
    v10 = v297;
LABEL_63:
    v57._rawBits = 1;
    v58._rawBits = 524289;
    v59._rawBits = _StringGuts.validateScalarRange(_:)(v57, v58, 0x203A747261747328uLL, 0xE800000000000000);
    if (v59._rawBits < 0x10000)
      v59._rawBits |= 3;
    v61 = specialized String.init(_:)(v59, v60, 0x203A747261747328uLL, 0xE800000000000000);
    v63 = v62;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v63 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v63);
      goto LABEL_67;
    }
LABEL_320:
    if ((v63 & 0x1000000000000000) != 0)
    {
      v61 = _StringGuts._foreignConvertedToSmall()(v61, v63);
      v294 = v293;
      swift_bridgeObjectRelease(v63);
      v63 = v294;
    }
    else
    {
      if ((v61 & 0x1000000000000000) != 0)
      {
        v283 = (unsigned __int8 *)((v63 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v284 = v61 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v283 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v61, v63);
      }
      closure #1 in _StringGuts._convertedToSmall()(v283, v284, &v297);
      swift_bridgeObjectRelease(v63);
      v63 = *((_QWORD *)&v297 + 1);
      v61 = v297;
    }
LABEL_67:
    v64 = HIBYTE(v13) & 0xF;
    v65 = HIBYTE(v63) & 0xF;
    v66 = v65 + v64;
    if ((unint64_t)(v65 + v64) > 0xF)
      goto LABEL_333;
    if (v65)
    {
      v67 = 0;
      v68 = 0;
      do
      {
        v69 = v64 + v68;
        v70 = v68 + 1;
        if (v68 >= 8)
          v71 = v63;
        else
          v71 = v61;
        v72 = v71 >> (v67 & 0x38);
        v73 = (8 * v64 + v67) & 0x38;
        v74 = (-255 << v73) - 1;
        v75 = (unint64_t)v72 << v73;
        v76 = v75 | v74 & v13;
        v77 = v75 | v74 & v10;
        if (v69 < 8)
          v10 = v77;
        else
          v13 = v76;
        v67 += 8;
        v68 = v70;
      }
      while (v65 != v70);
    }
    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(0xE800000000000000);
    v78 = 0xA000000000000000;
    if (!(v10 & 0x8080808080808080 | v13 & 0x80808080808080))
      v78 = 0xE000000000000000;
    v298._countAndFlagsBits = v10;
    v298._object = (void *)(v78 & 0xFF00000000000000 | (v66 << 56) | v13 & 0xFFFFFFFFFFFFFFLL);
    if (!a1)
      goto LABEL_58;
LABEL_80:
    *(_QWORD *)&v297 = a1;
    v79 = (Class *)type metadata accessor for UnsafeMutablePointer(0, a3, v44, (uint64_t)v45);
    a1 = String.init<A>(describing:)((uint64_t)&v297, v79);
    a3 = v80;
  }
  swift_bridgeObjectRetain_n(a3, 5, v87, v88);
  v263._rawBits = 1;
  v264._rawBits = (v86 << 16) | 1;
  v265._rawBits = _StringGuts.validateScalarRange(_:)(v263, v264, a1, a3);
  if (v265._rawBits < 0x10000)
    v265._rawBits |= 3;
  a2 = specialized Collection.count.getter(v265, v266, a1, a3);
  swift_bridgeObjectRelease(a3);
  if ((object & 0x1000000000000000) == 0)
    goto LABEL_95;
LABEL_293:
  v267 = String.UTF8View._foreignCount()();
  v92 = v267 + a2;
  if (!__OFADD__(v267, a2))
    goto LABEL_96;
LABEL_295:
  __break(1u);
LABEL_296:
  swift_bridgeObjectRetain_n(a3, 5, v89, v90);
  v268._rawBits = 1;
  v269._rawBits = (v61 << 16) | 1;
  v270._rawBits = _StringGuts.validateScalarRange(_:)(v268, v269, a1, a3);
  if (v270._rawBits < 0x10000)
    v270._rawBits |= 3;
  v154 = specialized Collection.count.getter(v270, v271, a1, a3);
  swift_bridgeObjectRelease(a3);
  v148 = v298._countAndFlagsBits;
  v11 = (unint64_t)v298._object;
  if (((uint64_t)v298._object & 0x1000000000000000) == 0)
    goto LABEL_183;
LABEL_299:
  v272 = String.UTF8View._foreignCount()();
  v155 = v272 + v154;
  if (!__OFADD__(v272, v154))
    goto LABEL_188;
LABEL_301:
  __break(1u);
LABEL_302:
  swift_bridgeObjectRetain_n(v155, 5, v152, v153);
  v273._rawBits = 1;
  v274._rawBits = (v13 << 16) | 1;
  v275._rawBits = _StringGuts.validateScalarRange(_:)(v273, v274, a3, v155);
  if (v275._rawBits < 0x10000)
    v275._rawBits |= 3;
  v190 = specialized Collection.count.getter(v275, v276, a3, v155);
  swift_bridgeObjectRelease(v155);
  if ((v10 & 0x1000000000000000) == 0)
    goto LABEL_219;
LABEL_305:
  v277 = String.UTF8View._foreignCount()();
  v191 = v277 + v190;
  if (__OFADD__(v277, v190))
    goto LABEL_307;
LABEL_220:
  if ((v11 & ~v10 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
  {
    v192 = (unint64_t)v298._object;
    v193 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v194 & 1) != 0)
    {
LABEL_334:
      v289 = 258;
      goto LABEL_335;
    }
    if (v191 <= 15 && ((v192 & 0x2000000000000000) != 0 || v193 < v190))
    {
LABEL_232:
      swift_bridgeObjectRelease_n(v155, 5);
      v200 = v298._countAndFlagsBits;
      swift_bridgeObjectRetain(v192, v201, v202, v203);
      v204 = _StringGuts._convertedToSmall()(v200, v192);
      v206 = v205;
      swift_bridgeObjectRelease(v192);
      v207._rawBits = (v13 << 16) | 1;
      v208._rawBits = 1;
      v209._rawBits = _StringGuts.validateScalarRange(_:)(v208, v207, a3, v155);
      if (v209._rawBits < 0x10000)
        v209._rawBits |= 3;
      v211 = specialized String.init(_:)(v209, v210, a3, v155);
      v213 = v212;
      swift_bridgeObjectRelease(v155);
      v214 = _StringGuts._convertedToSmall()(v211, v213);
      v216 = v215;
      swift_bridgeObjectRelease(v213);
      v217 = specialized _SmallString.init(_:appending:)(v204, v206, v214, v216);
      if ((v219 & 1) == 0)
      {
        v220 = v217;
        v221 = v218;
        swift_bridgeObjectRelease(v192);
        swift_bridgeObjectRelease(v155);
        v298._countAndFlagsBits = v220;
        v298._object = v221;
        goto LABEL_273;
      }
LABEL_333:
      v289 = 266;
LABEL_335:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v289, 0);
    }
  }
  else if (v191 <= 15)
  {
    v192 = (unint64_t)v298._object;
    goto LABEL_232;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v191, v190);
  swift_bridgeObjectRelease_n(v155, 4);
  if ((v155 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v155);
    _StringGuts._foreignAppendInPlace(_:)(a3, v155, 0, v13);
  }
  else
  {
    if (a2)
    {
      swift_bridgeObjectRelease_n(v155, 2);
      *(_QWORD *)&v297 = a3;
      *((_QWORD *)&v297 + 1) = v155 & 0xFFFFFFFFFFFFFFLL;
      v195 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1, (uint64_t)&v297, a1);
      _StringGuts.appendInPlace(_:isASCII:)(v195, v196, (v155 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(v155);
      goto LABEL_273;
    }
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v155);
      v250 = (id)((v155 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v251 = v148;
    }
    else
    {
      v250 = _StringObject.sharedUTF8.getter(a3, v155);
      v251 = v287;
      swift_bridgeObjectRelease(v155);
      if (v251 < v148)
LABEL_332:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    v252 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v148, (uint64_t)v250, v251);
    _StringGuts.appendInPlace(_:isASCII:)(v252, v253, (a3 & 0x8000000000000000) != 0);
  }
  swift_bridgeObjectRelease_n(v155, 2);
LABEL_273:
  v256 = v298._object;
  v257 = ((unint64_t)v298._object >> 56) & 0xF;
  if (((uint64_t)v298._object & 0x2000000000000000) == 0)
    v257 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v257 || (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v298._object & 0x2000000000000000) == 0
      || (v258 = specialized _SmallString.init(_:appending:)(v298._countAndFlagsBits, (unint64_t)v298._object, 0x29uLL, 0xE100000000000000), (v198 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000, v197, v198, v199);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      v259 = v298._countAndFlagsBits;
      v260 = (uint64_t)v298._object;
    }
    else
    {
      v259 = v258;
      v260 = v197;
      swift_bridgeObjectRelease((uint64_t)v256);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v298._object);
    v260 = 0xE100000000000000;
    v259 = 41;
  }
  v261 = specialized static String.+ infix(_:_:)(0xD00000000000001ALL, 0x80000001816AC590 | 0x8000000000000000, v259, v260);
  swift_bridgeObjectRelease(0x80000001816AC590 | 0x8000000000000000);
  swift_bridgeObjectRelease(v260);
  return v261;
}

unint64_t _sSryxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1)
{
  uint64_t *v1;

  return UnsafeMutableBufferPointer.debugDescription.getter(*v1, v1[1], *(_QWORD *)(a1 + 16));
}

uint64_t UnsafeBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeBufferPointer.init(_empty:)()
{
  return 0;
}

uint64_t UnsafeBufferPointer.Iterator._position.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UnsafeBufferPointer.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeBufferPointer.Iterator._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeBufferPointer.Iterator._end.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = result;
  return result;
}

uint64_t (*UnsafeBufferPointer.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a3, a4, a5);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeBufferPointer<A>@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(_QWORD, _QWORD, _QWORD))UnsafeBufferPointer.makeIterator(), a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t a1@<X0>, uint64_t (*a2)(_QWORD, _QWORD, _QWORD)@<X2>, uint64_t *a3@<X8>)
{
  _QWORD *v3;
  uint64_t result;
  uint64_t v6;

  result = a2(*v3, v3[1], *(_QWORD *)(a1 + 16));
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a1, a3);
  return Collection.underestimatedCount.getter(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeBufferPointer<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(a1, a2, (uint64_t)&protocol conformance descriptor for UnsafeBufferPointer<A>);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(a3, a1, a3);
  return Collection._copyToContiguousArray()(a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeBufferPointer<A>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))UnsafeBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))
{
  _QWORD *v6;
  uint64_t v8;
  uint64_t v9;

  *a1 = a6(a2, a3, *v6, v6[1], *(_QWORD *)(a4 + 16));
  a1[1] = v8;
  return v9;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeBufferPointer<A>@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  return UnsafeBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

Swift::Int __swiftcall UnsafeBufferPointer.index(after:)(Swift::Int after)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  return UnsafeMutableBufferPointer.index(after:)(after, v1, v2, v3, 0x5E7uLL);
}

uint64_t UnsafeMutableBufferPointer.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5;
  uint64_t result;

  v5 = __OFADD__(a1, 1);
  result = a1 + 1;
  if (v5)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.formIndex(after:)(Swift::Int *after)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  UnsafeMutableBufferPointer.formIndex(after:)(after, v1, v2, v3, 0x5F5uLL);
}

_QWORD *UnsafeMutableBufferPointer.formIndex(after:)(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (__OFADD__(*result, 1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  ++*result;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.index(before:)(Swift::Int before)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  return UnsafeMutableBufferPointer.index(before:)(before, v1, v2, v3, 0x603uLL);
}

uint64_t UnsafeMutableBufferPointer.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5;
  uint64_t result;

  v5 = __OFSUB__(a1, 1);
  result = a1 - 1;
  if (v5)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.formIndex(before:)(Swift::Int *before)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  UnsafeMutableBufferPointer.formIndex(before:)(before, v1, v2, v3, 0x611uLL);
}

_QWORD *UnsafeMutableBufferPointer.formIndex(before:)(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (__OFSUB__(*result, 1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  --*result;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.index(_:offsetBy:)(Swift::Int _, Swift::Int offsetBy)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  return UnsafeMutableBufferPointer.index(_:offsetBy:)(_, offsetBy, v2, v3, v4, 0x61FuLL);
}

uint64_t UnsafeMutableBufferPointer.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  BOOL v6;
  uint64_t result;

  v6 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v6)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  return result;
}

Swift::Int_optional __swiftcall UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3;
  char v4;
  Swift::Bool v5;
  Swift::Int_optional result;

  v3 = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy, 0x62DuLL, 0x635uLL);
  v5 = v4 & 1;
  result.value = v3;
  result.is_nil = v5;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.distance(from:to:)(Swift::Int from, Swift::Int to)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  return UnsafeMutableBufferPointer.distance(from:to:)(from, to, v2, v3, v4, 0x647uLL);
}

uint64_t UnsafeMutableBufferPointer.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  BOOL v6;
  uint64_t result;

  v6 = __OFSUB__(a2, a1);
  result = a2 - a1;
  if (v6)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  return result;
}

uint64_t UnsafeMutableBufferPointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a3 - 8) + 16))(a4, a2 + *(_QWORD *)(*(_QWORD *)(a3 - 8) + 72) * a1, a3);
}

uint64_t UnsafeBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, 0x714uLL, 0x715uLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8)
{
  if (result < a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a7, 0);
  if (result >= a3)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a8, 0);
  return result;
}

uint64_t UnsafeBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, a7, 0x71BuLL, 0x71CuLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  if (result < a3)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a8, 0);
  if (a4 < a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a9, 0);
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeBufferPointer<A>(_QWORD *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t *v3;
  _QWORD *v7;

  v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = UnsafeBufferPointer.subscript.read(v7, *a2, *v3, v3[1], *(_QWORD *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>(_QWORD *a1)
{
  void *v1;

  v1 = (void *)*a1;
  (*(void (**)(_QWORD))(*a1 + 32))(*a1);
  free(v1);
}

uint64_t (*UnsafeBufferPointer.subscript.read(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v7;

  v7 = *(_QWORD *)(a5 - 8);
  *a1 = a5;
  a1[1] = v7;
  a1[2] = malloc(*(_QWORD *)(v7 + 64));
  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
  if (a4 <= a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  (*(void (**)(void))(v7 + 16))();
  return _ArrayBuffer.subscript.read;
}

void _ArrayBuffer.subscript.read(_QWORD *a1)
{
  void *v1;

  v1 = (void *)a1[2];
  (*(void (**)(void *, _QWORD))(a1[1] + 8))(v1, *a1);
  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeBufferPointer<A>@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))UnsafeBufferPointer.subscript.getter, a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *a1@<X0>, uint64_t (*a2)(_QWORD, _QWORD, _QWORD, _QWORD)@<X3>, uint64_t *a3@<X8>)
{
  _QWORD *v3;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = a2(*a1, a1[1], *v3, v3[1]);
  *a3 = result;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance UnsafeBufferPointer<A>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;

  result = UnsafeBufferPointer.indices.getter(a1, *(_QWORD *)(v2 + 8));
  *a2 = 0;
  a2[1] = v5;
  return result;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance UnsafeBufferPointer<A>()
{
  uint64_t *v0;

  return UnsafeBufferPointer.isEmpty.getter(*v0, v0[1]);
}

_QWORD *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeBufferPointer<A>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, 0x61FuLL, a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>(a1, a2, a3, 0x62DuLL, 0x635uLL, a4);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeBufferPointer<A>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x647uLL);
}

_QWORD *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeBufferPointer<A>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x714uLL, 0x715uLL);
}

{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x71BuLL, 0x71CuLL);
}

_QWORD *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *result, _QWORD *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  if (*result < *a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  if (*result >= a2[1])
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  return result;
}

{
  if (*result < *a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  if (a2[1] < result[1])
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  return result;
}

_QWORD *protocol witness for Collection.index(after:) in conformance UnsafeBufferPointer<A>@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>(a1, 0x5E7uLL, a2);
}

_QWORD *protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *result@<X0>, unint64_t a2@<X3>, _QWORD *a3@<X8>)
{
  if (__OFADD__(*result, 1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a2, 0);
  *a3 = *result + 1;
  return result;
}

_QWORD *protocol witness for Collection.formIndex(after:) in conformance UnsafeBufferPointer<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0x5F5uLL);
}

_QWORD *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (__OFADD__(*result, 1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a4, 0);
  ++*result;
  return result;
}

_QWORD *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeBufferPointer<A>@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>(a1, 0x603uLL, a2);
}

_QWORD *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *result@<X0>, unint64_t a2@<X3>, _QWORD *a3@<X8>)
{
  if (__OFSUB__(*result, 1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a2, 0);
  *a3 = *result - 1;
  return result;
}

_QWORD *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeBufferPointer<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0x611uLL);
}

_QWORD *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (__OFSUB__(*result, 1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a4, 0);
  --*result;
  return result;
}

_QWORD *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>(_QWORD *result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X4>, _QWORD *a4@<X8>)
{
  if (__OFADD__(*result, a2))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a3, 0);
  *a4 = *result + a2;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5;
  uint64_t result;

  v5 = __OFSUB__(*a2, *a1);
  result = *a2 - *a1;
  if (v5)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.deallocate()()
{
  void *v0;

  if (v0)
    swift_slowDealloc(v0);
}

uint64_t UnsafeBufferPointer.withMemoryRebound<A, B>(to:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t)partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error), (uint64_t (*)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5);
}

uint64_t UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t (*a10)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  _QWORD v11[8];

  v11[2] = a6;
  v11[3] = a7;
  v11[4] = a8;
  v11[5] = a2;
  v11[6] = a3;
  return a10(a9, v11, a4, a5, a6, a7, a8);
}

unint64_t UnsafeBufferPointer.debugDescription.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  Swift::Int v25;
  unint64_t v26;
  int64_t v27;
  char v28;
  int64_t v29;
  char v30;
  BOOL v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  unint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  size_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  unsigned __int8 *v56;
  Swift::String::Index v57;
  Swift::String::Index v58;
  Swift::String::Index v59;
  Swift::String::Index v60;
  int64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  char v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  Class *v79;
  unint64_t v80;
  uint64_t countAndFlagsBits;
  unint64_t object;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  char *v90;
  BOOL v91;
  Swift::Int v92;
  uint64_t v93;
  int64_t v94;
  char v95;
  int64_t v96;
  char v97;
  uint64_t v99;
  char v100;
  uint64_t v101;
  uint64_t v102;
  char *v103;
  size_t v104;
  int v105;
  char v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  char v113;
  uint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  id v118;
  uint64_t v119;
  char *v120;
  size_t v121;
  Swift::String::Index v122;
  Swift::String::Index v123;
  Swift::String::Index v124;
  Swift::String::Index v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  char v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  char v138;
  uint64_t v139;
  unint64_t v140;
  Swift::Int v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  uint64_t v145;
  char *v146;
  Swift::String v147;
  uint64_t v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  uint64_t v152;
  char *v153;
  Swift::Int v154;
  uint64_t v155;
  uint64_t v156;
  int64_t v157;
  char v158;
  char *v159;
  size_t v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  Swift::String::Index v168;
  Swift::String::Index v169;
  Swift::String::Index v170;
  Swift::String::Index v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  void *v179;
  uint64_t v180;
  char v181;
  uint64_t v182;
  void *v183;
  unint64_t v184;
  unint64_t v185;
  uint64_t v186;
  char *v187;
  unint64_t v188;
  unint64_t v189;
  Swift::Int v190;
  int64_t v191;
  unint64_t v192;
  int64_t v193;
  char v194;
  char *v195;
  size_t v196;
  uint64_t v197;
  uint64_t v198;
  char *v199;
  unint64_t v200;
  uint64_t v201;
  uint64_t v202;
  char *v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  Swift::String::Index v207;
  Swift::String::Index v208;
  Swift::String::Index v209;
  Swift::String::Index v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  void *v218;
  char v219;
  uint64_t v220;
  void *v221;
  char v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  char v229;
  uint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  char v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  char v241;
  uint64_t v242;
  unint64_t v243;
  unint64_t v244;
  unint64_t v245;
  id v246;
  uint64_t v247;
  char *v248;
  size_t v249;
  id v250;
  uint64_t v251;
  char *v252;
  size_t v253;
  unint64_t v254;
  unint64_t v255;
  void *v256;
  unint64_t v257;
  unint64_t v258;
  uint64_t v259;
  uint64_t v260;
  unint64_t v261;
  Swift::String::Index v263;
  Swift::String::Index v264;
  Swift::String::Index v265;
  Swift::String::Index v266;
  Swift::Int v267;
  Swift::String::Index v268;
  Swift::String::Index v269;
  Swift::String::Index v270;
  Swift::String::Index v271;
  Swift::Int v272;
  Swift::String::Index v273;
  Swift::String::Index v274;
  Swift::String::Index v275;
  Swift::String::Index v276;
  Swift::Int v277;
  Swift::Int v278;
  unsigned __int8 *v279;
  uint64_t v280;
  unsigned __int8 *v281;
  uint64_t v282;
  unsigned __int8 *v283;
  uint64_t v284;
  unint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  unint64_t v289;
  Swift::Int v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t v293;
  unint64_t v294;
  uint64_t v295;
  uint64_t v296;
  __int128 v297;
  Swift::String v298;

  v6 = specialized static String._createEmpty(withInitialCapacity:)(22);
  v10 = v6;
  v11 = v7;
  v298._countAndFlagsBits = v6;
  v298._object = (void *)v7;
  v12 = HIBYTE(v7) & 0xF;
  v13 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000) != 0)
    v14 = HIBYTE(v7) & 0xF;
  else
    v14 = v6 & 0xFFFFFFFFFFFFLL;
  if (!v14 && (v6 & ~v7 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v298._countAndFlagsBits = 0x203A747261747328;
    v298._object = (void *)0xE800000000000000;
    if (a1)
      goto LABEL_80;
    goto LABEL_58;
  }
  if ((v7 & 0x2000000000000000) == 0 || v12 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6, v8, v9);
    if ((v11 & 0x1000000000000000) == 0)
    {
      v25 = v14 + 8;
      if (!__OFADD__(v14, 8))
        goto LABEL_13;
      goto LABEL_310;
    }
    goto LABEL_308;
  }
  v15 = 8 * HIBYTE(v7);
  v16 = (40 << (v15 & 0x38)) | ((-255 << (v15 & 0x38)) - 1) & v6;
  v17 = (v15 + 8) & 0x38;
  v18 = (-255 << v17) - 1;
  v19 = 115 << v17;
  if (v12 >= 7)
  {
    v21 = v19 | v18 & v7;
    v20 = 8;
    goto LABEL_32;
  }
  v16 = v19 | v18 & v16;
  if (v12 == 6)
  {
    v20 = 0;
    v21 = v7;
LABEL_32:
    v33 = (116 << v20) | ((-255 << v20) - 1) & v21;
    v34 = v12 + 3;
LABEL_33:
    v35 = (97 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v33;
    v36 = v12 + 4;
LABEL_34:
    v37 = (114 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v35;
    v38 = v12 + 5;
LABEL_35:
    v39 = (116 << (8 * (v38 & 7u))) | ((-255 << (8 * (v38 & 7u))) - 1) & v37;
    v40 = v12 + 6;
LABEL_36:
    v41 = (58 << (8 * (v40 & 7u))) | ((-255 << (8 * (v40 & 7u))) - 1) & v39;
    v42 = v12 + 7;
    goto LABEL_37;
  }
  v16 = (116 << ((v15 + 16) & 0x38)) | ((-255 << ((v15 + 16) & 0x38)) - 1) & v16;
  if (v12 >= 5)
  {
    v34 = 8;
    v33 = v7;
    goto LABEL_33;
  }
  v16 = (97 << ((v15 + 24) & 0x38)) | ((-255 << ((v15 + 24) & 0x38)) - 1) & v16;
  if (v12 == 4)
  {
    v36 = 8;
    v35 = v7;
    goto LABEL_34;
  }
  v16 = (114 << ((v15 + 32) & 0x38)) | ((-255 << ((v15 + 32) & 0x38)) - 1) & v16;
  if (v12 >= 3)
  {
    v38 = 8;
    v37 = v7;
    goto LABEL_35;
  }
  v16 = (116 << ((v15 + 40) & 0x38)) | ((-255 << ((v15 + 40) & 0x38)) - 1) & v16;
  if (v12 == 2)
  {
    v40 = 8;
    v39 = v7;
    goto LABEL_36;
  }
  v16 = (58 << ((v15 + 48) & 0x38)) | ((-255 << ((v15 + 48) & 0x38)) - 1) & v16;
  if (!v12)
  {
    v16 = (32 << ((v15 + 56) & 0x38)) | ((-255 << ((v15 + 56) & 0x38)) - 1) & v16;
    v43 = v7;
    goto LABEL_38;
  }
  v42 = 8;
  v41 = v7;
LABEL_37:
  v43 = (32 << (8 * (v42 & 7u))) | ((-255 << (8 * (v42 & 7u))) - 1) & v41;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000);
  v46 = 0xA000000000000000;
  if (!(v16 & 0x8080808080808080 | v43 & 0x80808080808080))
    v46 = 0xE000000000000000;
  v298._countAndFlagsBits = v16;
  v298._object = (void *)((v46 & 0xFF00000000000000 | (v12 << 56) | v43 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  if (a1)
    goto LABEL_80;
LABEL_58:
  a3 = 0xE300000000000000;
  a1 = 7104878;
  while (1)
  {
    countAndFlagsBits = v298._countAndFlagsBits;
    object = (unint64_t)v298._object;
    v83 = ((unint64_t)v298._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      v84 = ((unint64_t)v298._object >> 56) & 0xF;
    else
      v84 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    v296 = a2;
    if (!v84 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._countAndFlagsBits = a1;
      v298._object = (void *)a3;
      goto LABEL_170;
    }
    v10 = a3 & 0x2000000000000000;
    v13 = HIBYTE(a3) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0 && v10)
    {
      v85 = v83 + v13;
      if (v83 + v13 <= 0xF)
      {
        if (v13)
        {
          v106 = 0;
          v107 = 0;
          v108 = (unint64_t)v298._object;
          do
          {
            v109 = v83 + v107;
            v110 = v107 + 1;
            if (v107 >= 8)
              v111 = a3;
            else
              v111 = a1;
            v112 = v111 >> (v106 & 0x38);
            v113 = (8 * v83 + v106) & 0x38;
            v114 = (-255 << v113) - 1;
            v115 = (unint64_t)v112 << v113;
            v116 = v115 | v114 & v108;
            v117 = v115 | v114 & countAndFlagsBits;
            if (v109 < 8)
              countAndFlagsBits = v117;
            else
              v108 = v116;
            v106 += 8;
            v107 = v110;
          }
          while (v13 != v110);
        }
        else
        {
          v108 = (unint64_t)v298._object;
        }
        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(a3);
        v144 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v108 & 0x80808080808080))
          v144 = 0xE000000000000000;
        v298._countAndFlagsBits = countAndFlagsBits;
        v298._object = (void *)(v144 & 0xFF00000000000000 | (v85 << 56) | v108 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      v10 = 1;
    }
    v61 = a1 & 0xFFFFFFFFFFFFLL;
    v86 = v10 ? HIBYTE(a3) & 0xF : a1 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a3, 2, v44, v45);
    if ((a3 & 0x1000000000000000) != 0)
      break;
    swift_bridgeObjectRetain_n(a3, 4, v87, v88);
    a2 = v86;
    if ((object & 0x1000000000000000) != 0)
      goto LABEL_293;
LABEL_95:
    v91 = __OFADD__(v84, a2);
    v92 = v84 + a2;
    if (v91)
      goto LABEL_295;
LABEL_96:
    v295 = v86;
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v92 >= 16)
      {
        v93 = v298._countAndFlagsBits;
        v11 = (unint64_t)v298._object;
        goto LABEL_105;
      }
      v25 = (Swift::Int)v298._object;
      if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      {
        v105 = 0;
        v11 = (unint64_t)v298._object;
      }
      else
      {
        v11 = (unint64_t)v298._object;
LABEL_128:
        v105 = 1;
      }
LABEL_147:
      swift_bridgeObjectRelease_n(a3, 5);
      v13 = v298._countAndFlagsBits;
      if (v105)
      {
LABEL_311:
        if ((v25 & 0x1000000000000000) != 0)
        {
          v13 = _StringGuts._foreignConvertedToSmall()(v13, v11);
          v25 = v290;
        }
        else
        {
          if ((v13 & 0x1000000000000000) != 0)
          {
            v279 = (unsigned __int8 *)((v25 & 0xFFFFFFFFFFFFFFFLL) + 32);
            v280 = v13 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            v279 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v13, v11);
            v280 = v22;
          }
          swift_bridgeObjectRetain(v11, v22, v23, v24);
          closure #1 in _StringGuts._convertedToSmall()(v279, v280, &v297);
          swift_bridgeObjectRelease(v11);
          v25 = *((_QWORD *)&v297 + 1);
          v13 = v297;
        }
      }
      v122._rawBits = (v295 << 16) | 1;
      v123._rawBits = 1;
      v124._rawBits = _StringGuts.validateScalarRange(_:)(v123, v122, a1, a3);
      if (v124._rawBits < 0x10000)
        v124._rawBits |= 3;
      v126 = specialized String.init(_:)(v124, v125, a1, a3);
      v128 = v127;
      swift_bridgeObjectRelease(a3);
      if ((v128 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v128);
      }
      else if ((v128 & 0x1000000000000000) != 0)
      {
        v126 = _StringGuts._foreignConvertedToSmall()(v126, v128);
        v292 = v291;
        swift_bridgeObjectRelease(v128);
        v128 = v292;
      }
      else
      {
        if ((v126 & 0x1000000000000000) != 0)
        {
          v281 = (unsigned __int8 *)((v128 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v282 = v126 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v281 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v126, v128);
        }
        closure #1 in _StringGuts._convertedToSmall()(v281, v282, &v297);
        swift_bridgeObjectRelease(v128);
        v128 = *((_QWORD *)&v297 + 1);
        v126 = v297;
      }
      v129 = HIBYTE(v25) & 0xF;
      v130 = HIBYTE(v128) & 0xF;
      v131 = v130 + v129;
      if ((unint64_t)(v130 + v129) > 0xF)
        goto LABEL_333;
      if (v130)
      {
        v132 = 0;
        v133 = 0;
        do
        {
          v134 = v129 + v133;
          v135 = v133 + 1;
          if (v133 >= 8)
            v136 = v128;
          else
            v136 = v126;
          v137 = v136 >> (v132 & 0x38);
          v138 = (8 * v129 + v132) & 0x38;
          v139 = (-255 << v138) - 1;
          v140 = (unint64_t)v137 << v138;
          v141 = v140 | v139 & v25;
          v142 = v140 | v139 & v13;
          if (v134 < 8)
            v13 = v142;
          else
            v25 = v141;
          v132 += 8;
          v133 = v135;
        }
        while (v130 != v135);
      }
      swift_bridgeObjectRelease(v11);
      swift_bridgeObjectRelease(a3);
      v143 = 0xA000000000000000;
      if (!(v13 & 0x8080808080808080 | v25 & 0x80808080808080))
        v143 = 0xE000000000000000;
      v298._countAndFlagsBits = v13;
      v298._object = (void *)(v143 & 0xFF00000000000000 | (v131 << 56) | v25 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    v93 = v298._countAndFlagsBits;
    v11 = (unint64_t)v298._object;
    v94 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v95 & 1) != 0)
      goto LABEL_334;
    if (v92 <= 15)
    {
      if ((v11 & 0x2000000000000000) != 0)
      {
        v105 = 0;
        v25 = v11;
        goto LABEL_147;
      }
      v25 = v11;
      if (v94 < a2)
        goto LABEL_128;
    }
LABEL_105:
    v96 = _StringGuts.nativeUnusedCapacity.getter(v93, v11);
    v63 = (v97 & 1) == 0 && v96 >= a2;
    if ((v93 & ~v11 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v63 & 1) != 0)
        goto LABEL_123;
LABEL_116:
      v99 = _StringGuts.nativeCapacity.getter(v93, v11);
      if ((v100 & 1) != 0)
        v101 = 0;
      else
        v101 = v99;
      if (v101 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_320;
      }
      v102 = 2 * v101;
      if (v102 > v92)
        v92 = v102;
      goto LABEL_122;
    }
    if ((v63 & 1) == 0)
      goto LABEL_116;
LABEL_122:
    _StringGuts.grow(_:)(v92);
LABEL_123:
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v295);
    }
    else
    {
      if (v10)
      {
        swift_bridgeObjectRelease_n(a3, 2);
        *(_QWORD *)&v297 = a1;
        *((_QWORD *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
        v103 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(a3) & 0xF, (uint64_t)&v297, HIBYTE(a3) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v103, v104, (a3 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(a3);
        goto LABEL_170;
      }
      if ((a1 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(a3);
        v118 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v119 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v118 = _StringObject.sharedUTF8.getter(a1, a3);
        v119 = v288;
        swift_bridgeObjectRelease(a3);
        if (v119 < v61)
          goto LABEL_332;
      }
      v120 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1 & 0xFFFFFFFFFFFFLL, (uint64_t)v118, v119);
      _StringGuts.appendInPlace(_:isASCII:)(v120, v121, a1 < 0);
    }
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_170:
    v147 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    a1 = v147._countAndFlagsBits;
    a3 = (unint64_t)v147._object;
    v148 = v298._countAndFlagsBits;
    v11 = (unint64_t)v298._object;
    v149 = ((unint64_t)v298._object >> 56) & 0xF;
    v150 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      v150 = ((unint64_t)v298._object >> 56) & 0xF;
    if (!v150 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298 = v147;
      goto LABEL_204;
    }
    a2 = (uint64_t)v147._object & 0x2000000000000000;
    v10 = ((unint64_t)v147._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0 && a2)
    {
      v151 = v149 + v10;
      if (v149 + v10 <= 0xF)
      {
        v180 = v296;
        if (v10)
        {
          v222 = 0;
          v223 = 0;
          v224 = (unint64_t)v298._object;
          do
          {
            v225 = v149 + v223;
            v226 = v223 + 1;
            if (v223 >= 8)
              v227 = (unint64_t)v147._object;
            else
              v227 = v147._countAndFlagsBits;
            v228 = v227 >> (v222 & 0x38);
            v229 = (8 * v149 + v222) & 0x38;
            v230 = (-255 << v229) - 1;
            v231 = (unint64_t)v228 << v229;
            v232 = v231 | v230 & v224;
            v233 = v231 | v230 & v148;
            if (v225 < 8)
              v148 = v233;
            else
              v224 = v232;
            v222 += 8;
            v223 = v226;
          }
          while (v10 != v226);
        }
        else
        {
          v224 = (unint64_t)v298._object;
        }
        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease((uint64_t)v147._object);
        v254 = 0xA000000000000000;
        if (!(v148 & 0x8080808080808080 | v224 & 0x80808080808080))
          v254 = 0xE000000000000000;
        v298._countAndFlagsBits = v148;
        v298._object = (void *)(v254 & 0xFF00000000000000 | (v151 << 56) | v224 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_205;
      }
      a2 = 1;
    }
    v13 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a2)
      v61 = ((unint64_t)v147._object >> 56) & 0xF;
    else
      v61 = v147._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 2, v145, v146);
    if (((uint64_t)v147._object & 0x1000000000000000) != 0)
      goto LABEL_296;
    swift_bridgeObjectRetain_n((uint64_t)v147._object, 4, v89, v90);
    v154 = v61;
    if ((v11 & 0x1000000000000000) != 0)
      goto LABEL_299;
LABEL_183:
    if ((v11 & 0x2000000000000000) != 0)
    {
      v156 = HIBYTE(v11) & 0xF;
      v155 = v156 + v154;
      if (__OFADD__(v156, v154))
        goto LABEL_301;
    }
    else
    {
      v155 = (v148 & 0xFFFFFFFFFFFFLL) + v154;
      if (__OFADD__(v148 & 0xFFFFFFFFFFFFLL, v154))
        goto LABEL_301;
    }
LABEL_188:
    if ((v148 & ~v11 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      v157 = _StringGuts.nativeUnusedCapacity.getter(v148, v11);
      if ((v158 & 1) != 0)
        goto LABEL_334;
      if (v155 <= 15 && ((v11 & 0x2000000000000000) != 0 || v157 < v154))
      {
LABEL_198:
        swift_bridgeObjectRelease_n(a3, 5);
        v161 = v298._countAndFlagsBits;
        swift_bridgeObjectRetain(v11, v162, v163, v164);
        v165 = _StringGuts._convertedToSmall()(v161, v11);
        v167 = v166;
        swift_bridgeObjectRelease(v11);
        v168._rawBits = (v61 << 16) | 1;
        v169._rawBits = 1;
        v170._rawBits = _StringGuts.validateScalarRange(_:)(v169, v168, a1, a3);
        if (v170._rawBits < 0x10000)
          v170._rawBits |= 3;
        v172 = specialized String.init(_:)(v170, v171, a1, a3);
        v174 = v173;
        swift_bridgeObjectRelease(a3);
        v175 = _StringGuts._convertedToSmall()(v172, v174);
        v177 = v176;
        swift_bridgeObjectRelease(v174);
        v178 = specialized _SmallString.init(_:appending:)(v165, v167, v175, v177);
        v180 = v296;
        if ((v181 & 1) != 0)
          goto LABEL_333;
        v182 = v178;
        v183 = v179;
        swift_bridgeObjectRelease(v11);
        swift_bridgeObjectRelease(a3);
        v298._countAndFlagsBits = v182;
        v298._object = v183;
        goto LABEL_205;
      }
    }
    else if (v155 <= 15)
    {
      goto LABEL_198;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v155, v154);
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v61);
      swift_bridgeObjectRelease_n(a3, 2);
      goto LABEL_204;
    }
    if (a2)
    {
      swift_bridgeObjectRelease_n(a3, 2);
      *(_QWORD *)&v297 = a1;
      *((_QWORD *)&v297 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
      v159 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v10, (uint64_t)&v297, v10);
      _StringGuts.appendInPlace(_:isASCII:)(v159, v160, (a3 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(a3);
LABEL_204:
      v180 = v296;
      goto LABEL_205;
    }
    if ((a1 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      v246 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v247 = v13;
    }
    else
    {
      v246 = _StringObject.sharedUTF8.getter(a1, a3);
      v247 = v286;
      swift_bridgeObjectRelease(a3);
      if (v247 < (uint64_t)v13)
        goto LABEL_332;
    }
    v180 = v296;
    v248 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v13, (uint64_t)v246, v247);
    _StringGuts.appendInPlace(_:isASCII:)(v248, v249, a1 < 0);
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_205:
    v184 = _int64ToString(_:radix:uppercase:)(v180, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
    a3 = v184;
    v155 = v185;
    v11 = v298._countAndFlagsBits;
    v10 = (uint64_t)v298._object;
    v188 = ((unint64_t)v298._object >> 56) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0)
      v61 = ((unint64_t)v298._object >> 56) & 0xF;
    else
      v61 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v61 && (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v298._object);
      v298._countAndFlagsBits = a3;
      v298._object = (void *)v155;
      goto LABEL_273;
    }
    a2 = v185 & 0x2000000000000000;
    a1 = HIBYTE(v185) & 0xF;
    if (((uint64_t)v298._object & 0x2000000000000000) != 0 && a2)
    {
      v189 = v188 + a1;
      if (v188 + a1 <= 0xF)
      {
        if (a1)
        {
          v234 = 0;
          v235 = 0;
          v236 = (unint64_t)v298._object;
          do
          {
            v237 = v188 + v235;
            v238 = v235 + 1;
            if (v235 >= 8)
              v239 = v185;
            else
              v239 = v184;
            v240 = v239 >> (v234 & 0x38);
            v241 = (8 * v188 + v234) & 0x38;
            v242 = (-255 << v241) - 1;
            v243 = (unint64_t)v240 << v241;
            v244 = v243 | v242 & v236;
            v245 = v243 | v242 & v11;
            if (v237 < 8)
              v11 = v245;
            else
              v236 = v244;
            v234 += 8;
            v235 = v238;
          }
          while (a1 != v238);
        }
        else
        {
          v236 = (unint64_t)v298._object;
        }
        swift_bridgeObjectRelease((uint64_t)v298._object);
        swift_bridgeObjectRelease(v155);
        v255 = 0xA000000000000000;
        if (!(v11 & 0x8080808080808080 | v236 & 0x80808080808080))
          v255 = 0xE000000000000000;
        v298._countAndFlagsBits = v11;
        v298._object = (void *)(v255 & 0xFF00000000000000 | (v189 << 56) | v236 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_273;
      }
      a2 = 1;
    }
    v148 = v184 & 0xFFFFFFFFFFFFLL;
    if (a2)
      v13 = HIBYTE(v185) & 0xF;
    else
      v13 = v184 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v185, 2, v186, v187);
    if ((v155 & 0x1000000000000000) != 0)
      goto LABEL_302;
    swift_bridgeObjectRetain_n(v155, 4, v152, v153);
    v190 = v13;
    if ((v10 & 0x1000000000000000) != 0)
      goto LABEL_305;
LABEL_219:
    v91 = __OFADD__(v61, v190);
    v191 = v61 + v190;
    if (!v91)
      goto LABEL_220;
LABEL_307:
    __break(1u);
LABEL_308:
    v278 = String.UTF8View._foreignCount()();
    v25 = v278 + 8;
    if (__OFADD__(v278, 8))
    {
LABEL_310:
      __break(1u);
      goto LABEL_311;
    }
LABEL_13:
    v26 = v10 & ~v11;
    if ((v26 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
    {
      v27 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
      if ((v28 & 1) != 0)
        goto LABEL_334;
      if (v25 > 15)
        goto LABEL_21;
      if ((v11 & 0x2000000000000000) != 0)
        goto LABEL_62;
      if (v27 > 7)
      {
LABEL_21:
        v29 = _StringGuts.nativeUnusedCapacity.getter(v10, v11);
        v32 = (v30 & 1) == 0 && v29 > 7;
        if ((v26 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v11 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v32)
            goto LABEL_50;
        }
        else if (v32)
        {
          goto LABEL_49;
        }
        v47 = _StringGuts.nativeCapacity.getter(v10, v11);
        if ((v48 & 1) != 0)
          v49 = 0;
        else
          v49 = v47;
        if (v49 + 0x4000000000000000 >= 0)
        {
          v50 = 2 * v49;
          if (v50 > v25)
            v25 = v50;
LABEL_49:
          _StringGuts.grow(_:)(v25);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          v297 = xmmword_1816ABF40;
          v51 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v297, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v51, v52, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          if (!a1)
            goto LABEL_58;
          goto LABEL_80;
        }
        __break(1u);
LABEL_325:
        v10 = _StringGuts._foreignConvertedToSmall()(v10, v11);
        v13 = v285;
        goto LABEL_63;
      }
    }
    else
    {
      if (v25 > 15)
        goto LABEL_21;
      if ((v11 & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        v13 = v11;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((v11 & 0x1000000000000000) != 0)
      goto LABEL_325;
    if ((v10 & 0x1000000000000000) != 0)
    {
      v56 = (unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v56 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v10, v11);
      v13 = v53;
    }
    swift_bridgeObjectRetain(v11, v53, v54, v55);
    closure #1 in _StringGuts._convertedToSmall()(v56, v13, &v297);
    swift_bridgeObjectRelease(v11);
    v13 = *((_QWORD *)&v297 + 1);
    v10 = v297;
LABEL_63:
    v57._rawBits = 1;
    v58._rawBits = 524289;
    v59._rawBits = _StringGuts.validateScalarRange(_:)(v57, v58, 0x203A747261747328uLL, 0xE800000000000000);
    if (v59._rawBits < 0x10000)
      v59._rawBits |= 3;
    v61 = specialized String.init(_:)(v59, v60, 0x203A747261747328uLL, 0xE800000000000000);
    v63 = v62;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v63 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v63);
      goto LABEL_67;
    }
LABEL_320:
    if ((v63 & 0x1000000000000000) != 0)
    {
      v61 = _StringGuts._foreignConvertedToSmall()(v61, v63);
      v294 = v293;
      swift_bridgeObjectRelease(v63);
      v63 = v294;
    }
    else
    {
      if ((v61 & 0x1000000000000000) != 0)
      {
        v283 = (unsigned __int8 *)((v63 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v284 = v61 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v283 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v61, v63);
      }
      closure #1 in _StringGuts._convertedToSmall()(v283, v284, &v297);
      swift_bridgeObjectRelease(v63);
      v63 = *((_QWORD *)&v297 + 1);
      v61 = v297;
    }
LABEL_67:
    v64 = HIBYTE(v13) & 0xF;
    v65 = HIBYTE(v63) & 0xF;
    v66 = v65 + v64;
    if ((unint64_t)(v65 + v64) > 0xF)
      goto LABEL_333;
    if (v65)
    {
      v67 = 0;
      v68 = 0;
      do
      {
        v69 = v64 + v68;
        v70 = v68 + 1;
        if (v68 >= 8)
          v71 = v63;
        else
          v71 = v61;
        v72 = v71 >> (v67 & 0x38);
        v73 = (8 * v64 + v67) & 0x38;
        v74 = (-255 << v73) - 1;
        v75 = (unint64_t)v72 << v73;
        v76 = v75 | v74 & v13;
        v77 = v75 | v74 & v10;
        if (v69 < 8)
          v10 = v77;
        else
          v13 = v76;
        v67 += 8;
        v68 = v70;
      }
      while (v65 != v70);
    }
    swift_bridgeObjectRelease(v11);
    swift_bridgeObjectRelease(0xE800000000000000);
    v78 = 0xA000000000000000;
    if (!(v10 & 0x8080808080808080 | v13 & 0x80808080808080))
      v78 = 0xE000000000000000;
    v298._countAndFlagsBits = v10;
    v298._object = (void *)(v78 & 0xFF00000000000000 | (v66 << 56) | v13 & 0xFFFFFFFFFFFFFFLL);
    if (!a1)
      goto LABEL_58;
LABEL_80:
    *(_QWORD *)&v297 = a1;
    v79 = (Class *)type metadata accessor for UnsafePointer(0, a3, v44, (uint64_t)v45);
    a1 = String.init<A>(describing:)((uint64_t)&v297, v79);
    a3 = v80;
  }
  swift_bridgeObjectRetain_n(a3, 5, v87, v88);
  v263._rawBits = 1;
  v264._rawBits = (v86 << 16) | 1;
  v265._rawBits = _StringGuts.validateScalarRange(_:)(v263, v264, a1, a3);
  if (v265._rawBits < 0x10000)
    v265._rawBits |= 3;
  a2 = specialized Collection.count.getter(v265, v266, a1, a3);
  swift_bridgeObjectRelease(a3);
  if ((object & 0x1000000000000000) == 0)
    goto LABEL_95;
LABEL_293:
  v267 = String.UTF8View._foreignCount()();
  v92 = v267 + a2;
  if (!__OFADD__(v267, a2))
    goto LABEL_96;
LABEL_295:
  __break(1u);
LABEL_296:
  swift_bridgeObjectRetain_n(a3, 5, v89, v90);
  v268._rawBits = 1;
  v269._rawBits = (v61 << 16) | 1;
  v270._rawBits = _StringGuts.validateScalarRange(_:)(v268, v269, a1, a3);
  if (v270._rawBits < 0x10000)
    v270._rawBits |= 3;
  v154 = specialized Collection.count.getter(v270, v271, a1, a3);
  swift_bridgeObjectRelease(a3);
  v148 = v298._countAndFlagsBits;
  v11 = (unint64_t)v298._object;
  if (((uint64_t)v298._object & 0x1000000000000000) == 0)
    goto LABEL_183;
LABEL_299:
  v272 = String.UTF8View._foreignCount()();
  v155 = v272 + v154;
  if (!__OFADD__(v272, v154))
    goto LABEL_188;
LABEL_301:
  __break(1u);
LABEL_302:
  swift_bridgeObjectRetain_n(v155, 5, v152, v153);
  v273._rawBits = 1;
  v274._rawBits = (v13 << 16) | 1;
  v275._rawBits = _StringGuts.validateScalarRange(_:)(v273, v274, a3, v155);
  if (v275._rawBits < 0x10000)
    v275._rawBits |= 3;
  v190 = specialized Collection.count.getter(v275, v276, a3, v155);
  swift_bridgeObjectRelease(v155);
  if ((v10 & 0x1000000000000000) == 0)
    goto LABEL_219;
LABEL_305:
  v277 = String.UTF8View._foreignCount()();
  v191 = v277 + v190;
  if (__OFADD__(v277, v190))
    goto LABEL_307;
LABEL_220:
  if ((v11 & ~v10 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v10 & 0xFFFFFFFFFFFFFFFLL))
  {
    v192 = (unint64_t)v298._object;
    v193 = _StringGuts.nativeUnusedCapacity.getter(v298._countAndFlagsBits, (uint64_t)v298._object);
    if ((v194 & 1) != 0)
    {
LABEL_334:
      v289 = 258;
      goto LABEL_335;
    }
    if (v191 <= 15 && ((v192 & 0x2000000000000000) != 0 || v193 < v190))
    {
LABEL_232:
      swift_bridgeObjectRelease_n(v155, 5);
      v200 = v298._countAndFlagsBits;
      swift_bridgeObjectRetain(v192, v201, v202, v203);
      v204 = _StringGuts._convertedToSmall()(v200, v192);
      v206 = v205;
      swift_bridgeObjectRelease(v192);
      v207._rawBits = (v13 << 16) | 1;
      v208._rawBits = 1;
      v209._rawBits = _StringGuts.validateScalarRange(_:)(v208, v207, a3, v155);
      if (v209._rawBits < 0x10000)
        v209._rawBits |= 3;
      v211 = specialized String.init(_:)(v209, v210, a3, v155);
      v213 = v212;
      swift_bridgeObjectRelease(v155);
      v214 = _StringGuts._convertedToSmall()(v211, v213);
      v216 = v215;
      swift_bridgeObjectRelease(v213);
      v217 = specialized _SmallString.init(_:appending:)(v204, v206, v214, v216);
      if ((v219 & 1) == 0)
      {
        v220 = v217;
        v221 = v218;
        swift_bridgeObjectRelease(v192);
        swift_bridgeObjectRelease(v155);
        v298._countAndFlagsBits = v220;
        v298._object = v221;
        goto LABEL_273;
      }
LABEL_333:
      v289 = 266;
LABEL_335:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v289, 0);
    }
  }
  else if (v191 <= 15)
  {
    v192 = (unint64_t)v298._object;
    goto LABEL_232;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v191, v190);
  swift_bridgeObjectRelease_n(v155, 4);
  if ((v155 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v155);
    _StringGuts._foreignAppendInPlace(_:)(a3, v155, 0, v13);
  }
  else
  {
    if (a2)
    {
      swift_bridgeObjectRelease_n(v155, 2);
      *(_QWORD *)&v297 = a3;
      *((_QWORD *)&v297 + 1) = v155 & 0xFFFFFFFFFFFFFFLL;
      v195 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1, (uint64_t)&v297, a1);
      _StringGuts.appendInPlace(_:isASCII:)(v195, v196, (v155 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(v155);
      goto LABEL_273;
    }
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v155);
      v250 = (id)((v155 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v251 = v148;
    }
    else
    {
      v250 = _StringObject.sharedUTF8.getter(a3, v155);
      v251 = v287;
      swift_bridgeObjectRelease(v155);
      if (v251 < v148)
LABEL_332:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    v252 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v148, (uint64_t)v250, v251);
    _StringGuts.appendInPlace(_:isASCII:)(v252, v253, (a3 & 0x8000000000000000) != 0);
  }
  swift_bridgeObjectRelease_n(v155, 2);
LABEL_273:
  v256 = v298._object;
  v257 = ((unint64_t)v298._object >> 56) & 0xF;
  if (((uint64_t)v298._object & 0x2000000000000000) == 0)
    v257 = v298._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v257 || (v298._countAndFlagsBits & ~(uint64_t)v298._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v298._object & 0x2000000000000000) == 0
      || (v258 = specialized _SmallString.init(_:appending:)(v298._countAndFlagsBits, (unint64_t)v298._object, 0x29uLL, 0xE100000000000000), (v198 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000, v197, v198, v199);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      v259 = v298._countAndFlagsBits;
      v260 = (uint64_t)v298._object;
    }
    else
    {
      v259 = v258;
      v260 = v197;
      swift_bridgeObjectRelease((uint64_t)v256);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v298._object);
    v260 = 0xE100000000000000;
    v259 = 41;
  }
  v261 = specialized static String.+ infix(_:_:)(0xD000000000000013, 0x80000001816AC5B0 | 0x8000000000000000, v259, v260);
  swift_bridgeObjectRelease(0x80000001816AC5B0 | 0x8000000000000000);
  swift_bridgeObjectRelease(v260);
  return v261;
}

unint64_t _sSRyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1)
{
  uint64_t *v1;

  return UnsafeBufferPointer.debugDescription.getter(*v1, v1[1], *(_QWORD *)(a1 + 16));
}

uint64_t UnsafeMutableRawBufferPointer._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

char *UnsafeMutableRawBufferPointer._copyContents(initializing:)(void *a1, int64_t a2, char *__src, unint64_t a4)
{
  char *v4;
  size_t v5;

  v4 = __src;
  if (__src && a4 && (unint64_t)__src < a4 && a2)
  {
    if ((uint64_t)(a4 - (_QWORD)__src) >= a2)
      v5 = a2;
    else
      v5 = a4 - (_QWORD)__src;
    if ((v5 & 0x8000000000000000) != 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
    memmove(a1, __src, v5);
    v4 += v5;
  }
  return v4;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableRawBufferPointer()
{
  uint64_t *v0;

  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1], (void (*)(__objc2_class **, uint64_t, uint64_t, uint64_t))UnsafeMutableRawBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD))UnsafeMutableRawBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeMutableRawBufferPointer@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  return UnsafeMutableRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeMutableRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  if (a2)
  {
    v9 = a3 - a2;
    if (a3 - a2 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
    v10 = a2;
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  result = a1(v10, v9);
  if (!v5)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 56))(a5, 0, 1, a4);
  return result;
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, 0xBBuLL, 0xBCuLL);
}

uint64_t key path getter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = UnsafeMutableRawBufferPointer.subscript.getter(*a2, *a1, a1[1]);
  *a3 = result;
  return result;
}

uint64_t key path setter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer(unsigned __int8 *a1, uint64_t *a2, uint64_t *a3)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, *a3, *a2, a2[1]);
}

uint64_t (*UnsafeMutableRawBufferPointer.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t a1)
{
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 24) = UnsafeMutableRawBufferPointer.subscript.getter(a2, a3, a4);
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

uint64_t UnsafeMutableRawBufferPointer.subscript.modify(uint64_t a1)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*(unsigned __int8 *)(a1 + 24), *(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16));
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, a4, 0xCFuLL, 0xD0uLL);
}

uint64_t *key path getter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer@<X0>(uint64_t *result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if ((*a2 & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xCFuLL, 0);
  v3 = *result;
  v4 = result[1];
  v5 = a2[1];
  if (!*result)
  {
    if (v5 < 1)
      goto LABEL_4;
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD0uLL, 0);
  }
  if (v4 - v3 < v5)
    goto LABEL_6;
LABEL_4:
  *a3 = *a2;
  a3[1] = v5;
  a3[2] = v3;
  a3[3] = v4;
  return result;
}

void *key path setter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a3, a3[1], *a2, a2[1]);
}

void *UnsafeMutableRawBufferPointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v14;
  void *result;
  size_t v16;
  unint64_t v17;

  if (a5 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD5uLL, 0);
  if (a7)
  {
    if (a8 - a7 >= a6)
      goto LABEL_4;
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD6uLL, 0);
  }
  if (a6 >= 1)
    goto LABEL_12;
LABEL_4:
  v14 = (void *)(a6 - a5);
  if (__OFSUB__(a6, a5))
  {
    __break(1u);
LABEL_15:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD7uLL, 0);
  }
  result = (void *)specialized RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, a4);
  if (v14 != result)
    goto LABEL_15;
  if (a1 == a2)
    return result;
  if (!a7)
  {
    v17 = 218;
    goto LABEL_19;
  }
  if (!a3)
  {
    v17 = 219;
LABEL_19:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, v17, 0);
  }
  v16 = specialized RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, a4);
  if ((v16 & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
  return memmove((void *)(a7 + a5), (const void *)(a3 + a1), v16);
}

void (*UnsafeMutableRawBufferPointer.subscript.modify(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t **a1)
{
  _QWORD *v10;

  v10 = malloc(0x40uLL);
  *a1 = v10;
  v10[6] = a4;
  v10[7] = a5;
  v10[4] = a2;
  v10[5] = a3;
  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xCFuLL, 0);
  if (!a4)
  {
    if (a3 < 1)
      goto LABEL_4;
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD0uLL, 0);
  }
  if (a5 - a4 < a3)
    goto LABEL_6;
LABEL_4:
  *v10 = a2;
  v10[1] = a3;
  v10[2] = a4;
  v10[3] = a5;
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

void UnsafeMutableRawBufferPointer.subscript.modify(uint64_t **a1)
{
  uint64_t *v1;

  v1 = *a1;
  UnsafeMutableRawBufferPointer.subscript.setter(**a1, v1[1], v1[2], v1[3], (*a1)[4], (*a1)[5], (*a1)[6], (*a1)[7]);
  free(v1);
}

Swift::Void __swiftcall UnsafeMutableRawBufferPointer.swapAt(_:_:)(Swift::Int a1, Swift::Int a2)
{
  uint64_t v2;
  uint64_t v3;
  char v4;

  if (a1 != a2)
  {
    if ((a2 | a1) < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xF0uLL, 0);
    if (!v2 || v3 - v2 <= a1 || v3 - v2 <= a2)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xF1uLL, 0);
    v4 = *(_BYTE *)(v2 + a1);
    *(_BYTE *)(v2 + a1) = *(_BYTE *)(v2 + a2);
    *(_BYTE *)(v2 + a2) = v4;
  }
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableRawBufferPointer(unsigned __int8 *a1, uint64_t *a2)
{
  uint64_t *v2;

  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, *a2, *v2, v2[1]);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableRawBufferPointer(uint64_t a1, uint64_t *a2))(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *a2;
  v5 = *v2;
  v6 = v2[1];
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + 8) = v5;
  *(_QWORD *)(a1 + 16) = v6;
  *(_BYTE *)(a1 + 24) = UnsafeMutableRawBufferPointer.subscript.getter(v4, v5, v6);
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

void *protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableRawBufferPointer(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v2;

  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a2, a2[1], *v2, v2[1]);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableRawBufferPointer(_QWORD *a1, uint64_t *a2))(uint64_t **a1)
{
  uint64_t *v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = malloc(0x40uLL);
  *a1 = v5;
  v6 = *a2;
  v7 = a2[1];
  v5[4] = *a2;
  v5[5] = v7;
  v8 = *v2;
  v9 = v2[1];
  v5[6] = *v2;
  v5[7] = v9;
  if (v6 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xCFuLL, 0);
  if (!v8)
  {
    if (v7 < 1)
      goto LABEL_4;
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD0uLL, 0);
  }
  if (v9 - v8 < v7)
    goto LABEL_6;
LABEL_4:
  *v5 = v6;
  v5[1] = v7;
  v5[2] = v8;
  v5[3] = v9;
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

uint64_t protocol witness for MutableCollection.partition(by:) in conformance UnsafeMutableRawBufferPointer@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  char v9;

  v6 = *v2;
  v7 = v2[1];
  result = (uint64_t)_sSw17withMemoryRebound2to_q0_xm_q0_SryxGq_YKXEtq_YKs5ErrorR_Ri_zRi_0_r1_lFACq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys5UInt8VsAD_pq0_Isgyrzr_Swq0_sAD_pAFRszsAD_pRs_Ri_0_r1_lIetMgyrzo_Tpq5SiSg_Tgq5055_sSw39withContiguousMutableStorageIfAvailableyxSgxSrys5F25VGzKXEKlFAbEKXEfU_Si_TGq5SryAFGxsAD_pRi_zRi0_zlySiIsglrzo_Tf1cn_n(*v2, v7, (_QWORD *(*)(uint64_t *__return_ptr, uint64_t *))partial apply for specialized closure #1 in MutableCollection<>.partition(by:));
  if (!v3)
  {
    if ((v9 & 1) != 0)
      result = specialized MutableCollection<>._partitionImpl(by:)(a1);
    else
      result = specialized RandomAccessCollection<>.index(_:offsetBy:)(0, result, v6, v7);
    *a2 = result;
  }
  return result;
}

void protocol witness for MutableCollection.swapAt(_:_:) in conformance UnsafeMutableRawBufferPointer(Swift::Int *a1, Swift::Int *a2)
{
  UnsafeMutableRawBufferPointer.swapAt(_:_:)(*a1, *a2);
}

uint64_t protocol witness for MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:) in conformance UnsafeMutableRawBufferPointer@<X0>(uint64_t (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  return UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  if (a2)
  {
    v6 = a3 - a2;
    if (a3 - a2 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
    v7 = a2;
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  return closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(v7, v6, a1, a4, &v9, a5);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeMutableRawBufferPointer(_BYTE *a1, uint64_t *a2))()
{
  uint64_t *v2;

  *a1 = UnsafeMutableRawBufferPointer.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer(a1, 0xCFuLL, 0xD0uLL, a2);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t *v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;

  v7 = *a1;
  v8 = *v4;
  v9 = v4[1];
  v10 = specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a3, *v4, v9);
  if (a2 < 1)
  {
    if (v10 <= 0 && v10 > a2)
      goto LABEL_4;
LABEL_10:
    result = specialized RandomAccessCollection<>.index(_:offsetBy:)(v7, a2, v8, v9);
    v12 = 0;
    goto LABEL_11;
  }
  if (v10 < 0 || v10 >= (unint64_t)a2)
    goto LABEL_10;
LABEL_4:
  result = 0;
  v12 = 1;
LABEL_11:
  *(_QWORD *)a4 = result;
  *(_BYTE *)(a4 + 8) = v12;
  return result;
}

void *UnsafeMutableRawBufferPointer.storeBytes<A>(of:toByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  BOOL v7;
  uint64_t v8;

  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes with negative offset", 61, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1CCuLL, 0);
  v6 = *(_QWORD *)(*(_QWORD *)(a6 - 8) + 64);
  v7 = __OFADD__(a2, v6);
  v8 = a2 + v6;
  if (v7)
  {
    __break(1u);
LABEL_8:
    if (v8 < 1)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1D0uLL, 0);
LABEL_10:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes out of bounds", 54, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1CDuLL, 0);
  }
  if (!a4)
    goto LABEL_8;
  if (a5 - a4 < v8)
    goto LABEL_10;
  return UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(a1, a2, a6, a4, a6);
}

void *closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(const void *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *result;
  uint64_t v21;
  void *v22;

  v22 = a6;
  v14 = *(_QWORD *)(a7 - 8);
  MEMORY[0x1E0C80A78](a1);
  v16 = (char *)&v21 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v16, v17, v18);
  v19 = (*(uint64_t (**)(uint64_t, uint64_t))(a8 + 112))(a7, a8);
  if (a4)
  {
    if (a5 - a4 >= v19)
      goto LABEL_3;
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.copyBytes source has too many elements", 68, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x205uLL, 0);
  }
  if (v19 >= 1)
    goto LABEL_8;
LABEL_3:
  result = (void *)(*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, a7);
  if (a1)
  {
    if ((a2 & 0x8000000000000000) != 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
    return memmove(v22, a1, a2);
  }
  return result;
}

_QWORD *specialized closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(uint64_t a1, uint64_t a2, _QWORD *(*a3)(uint64_t *__return_ptr, uint64_t *))
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v7 = a1;
  v8 = a2;
  result = a3(&v9, &v7);
  if (v3)
  {
    if (a1)
    {
      if (!v7 || a1 != v7)
        goto LABEL_17;
    }
    else if (v7)
    {
      goto LABEL_17;
    }
    if (v8 != a2)
      goto LABEL_17;
  }
  else
  {
    if (a1)
    {
      if (!v7 || a1 != v7)
LABEL_17:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed", 106, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x401uLL, 0);
    }
    else if (v7)
    {
      goto LABEL_17;
    }
    if (v8 != a2)
      goto LABEL_17;
    return (_QWORD *)v9;
  }
  return result;
}

uint64_t closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(uint64_t *)@<X2>, uint64_t a4@<X4>, _QWORD *a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;

  v14 = a2;
  v13 = a1;
  result = a3(&v13);
  if (v6)
  {
    if (a1)
    {
      if (!v13 || a1 != v13)
        goto LABEL_15;
    }
    else if (v13)
    {
      goto LABEL_15;
    }
    if (v14 != a2)
      goto LABEL_15;
    *a5 = v6;
  }
  else
  {
    result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 56))(a6, 0, 1, a4);
    if (a1)
    {
      if (!v13 || a1 != v13)
LABEL_15:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed", 106, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x401uLL, 0);
    }
    else if (v13)
    {
      goto LABEL_15;
    }
    if (v14 != a2)
      goto LABEL_15;
  }
  return result;
}

unint64_t UnsafeMutableRawBufferPointer.debugDescription.getter(int64_t a1, unint64_t object)
{
  unint64_t v2;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t countAndFlagsBits;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  Swift::Int v24;
  unint64_t v25;
  int64_t v26;
  char v27;
  int64_t v28;
  char v29;
  BOOL v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  unint64_t v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  size_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  unsigned __int8 *v55;
  Swift::String::Index v56;
  Swift::String::Index v57;
  Swift::String::Index v58;
  Swift::String::Index v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  char v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  char *v86;
  BOOL v87;
  Swift::Int v88;
  uint64_t v89;
  int64_t v90;
  char v91;
  int64_t v92;
  char v93;
  uint64_t v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  size_t v100;
  int v101;
  char v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  id v114;
  uint64_t v115;
  char *v116;
  size_t v117;
  Swift::String::Index v118;
  Swift::String::Index v119;
  Swift::String::Index v120;
  Swift::String::Index v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  char v134;
  uint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  uint64_t v141;
  char *v142;
  Swift::String v143;
  unint64_t v144;
  unint64_t v145;
  int64_t v146;
  unint64_t v147;
  int64_t v148;
  char v149;
  char *v150;
  size_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  char *v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  Swift::String::Index v159;
  Swift::String::Index v160;
  Swift::String::Index v161;
  Swift::String::Index v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  void *v170;
  int64_t v171;
  char v172;
  uint64_t v173;
  void *v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  char *v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unint64_t v190;
  unint64_t v192;
  char v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  char v200;
  uint64_t v201;
  unint64_t v202;
  unint64_t v203;
  unint64_t v204;
  char v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  char v212;
  uint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  id v217;
  uint64_t v218;
  uint64_t v219;
  char *v220;
  size_t v221;
  unint64_t v222;
  unint64_t v223;
  Swift::String::Index v224;
  Swift::String::Index v225;
  Swift::String::Index v226;
  Swift::String::Index v227;
  Swift::Int v228;
  Swift::String::Index v229;
  Swift::String::Index v230;
  Swift::String::Index v231;
  Swift::String::Index v232;
  Swift::Int v233;
  Swift::Int v234;
  unsigned __int8 *v235;
  uint64_t v236;
  unsigned __int8 *v237;
  uint64_t v238;
  unsigned __int8 *v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  unint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  unint64_t v248;
  unint64_t v249;
  uint64_t v250;
  unint64_t v251;
  int64_t v252;
  __int128 v253;
  Swift::String v254;

  v5 = specialized static String._createEmpty(withInitialCapacity:)(22);
  v9 = v5;
  countAndFlagsBits = v6;
  v254._countAndFlagsBits = v5;
  v254._object = (void *)v6;
  v11 = HIBYTE(v6) & 0xF;
  v12 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000) != 0)
    v13 = HIBYTE(v6) & 0xF;
  else
    v13 = v5 & 0xFFFFFFFFFFFFLL;
  if (!v13 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    v254._countAndFlagsBits = 0x203A747261747328;
    v254._object = (void *)0xE800000000000000;
    v251 = object;
    if (a1)
      goto LABEL_80;
    goto LABEL_58;
  }
  if ((v6 & 0x2000000000000000) == 0 || v11 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6, v7, v8);
    if ((countAndFlagsBits & 0x1000000000000000) == 0)
    {
      v24 = v13 + 8;
      if (!__OFADD__(v13, 8))
        goto LABEL_13;
      goto LABEL_281;
    }
    goto LABEL_279;
  }
  v14 = 8 * HIBYTE(v6);
  v15 = (40 << (v14 & 0x38)) | ((-255 << (v14 & 0x38)) - 1) & v5;
  v16 = (v14 + 8) & 0x38;
  v17 = (-255 << v16) - 1;
  v18 = 115 << v16;
  if (v11 >= 7)
  {
    v20 = v18 | v17 & v6;
    v19 = 8;
    goto LABEL_32;
  }
  v15 = v18 | v17 & v15;
  if (v11 == 6)
  {
    v19 = 0;
    v20 = v6;
LABEL_32:
    v32 = (116 << v19) | ((-255 << v19) - 1) & v20;
    v33 = v11 + 3;
LABEL_33:
    v34 = (97 << (8 * (v33 & 7u))) | ((-255 << (8 * (v33 & 7u))) - 1) & v32;
    v35 = v11 + 4;
LABEL_34:
    v36 = (114 << (8 * (v35 & 7u))) | ((-255 << (8 * (v35 & 7u))) - 1) & v34;
    v37 = v11 + 5;
LABEL_35:
    v38 = (116 << (8 * (v37 & 7u))) | ((-255 << (8 * (v37 & 7u))) - 1) & v36;
    v39 = v11 + 6;
LABEL_36:
    v40 = (58 << (8 * (v39 & 7u))) | ((-255 << (8 * (v39 & 7u))) - 1) & v38;
    v41 = v11 + 7;
    goto LABEL_37;
  }
  v15 = (116 << ((v14 + 16) & 0x38)) | ((-255 << ((v14 + 16) & 0x38)) - 1) & v15;
  if (v11 >= 5)
  {
    v33 = 8;
    v32 = v6;
    goto LABEL_33;
  }
  v15 = (97 << ((v14 + 24) & 0x38)) | ((-255 << ((v14 + 24) & 0x38)) - 1) & v15;
  if (v11 == 4)
  {
    v35 = 8;
    v34 = v6;
    goto LABEL_34;
  }
  v15 = (114 << ((v14 + 32) & 0x38)) | ((-255 << ((v14 + 32) & 0x38)) - 1) & v15;
  if (v11 >= 3)
  {
    v37 = 8;
    v36 = v6;
    goto LABEL_35;
  }
  v15 = (116 << ((v14 + 40) & 0x38)) | ((-255 << ((v14 + 40) & 0x38)) - 1) & v15;
  if (v11 == 2)
  {
    v39 = 8;
    v38 = v6;
    goto LABEL_36;
  }
  v15 = (58 << ((v14 + 48) & 0x38)) | ((-255 << ((v14 + 48) & 0x38)) - 1) & v15;
  if (!v11)
  {
    v15 = (32 << ((v14 + 56) & 0x38)) | ((-255 << ((v14 + 56) & 0x38)) - 1) & v15;
    v42 = v6;
    goto LABEL_38;
  }
  v41 = 8;
  v40 = v6;
LABEL_37:
  v42 = (32 << (8 * (v41 & 7u))) | ((-255 << (8 * (v41 & 7u))) - 1) & v40;
LABEL_38:
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE800000000000000);
  v45 = 0xA000000000000000;
  if (!(v15 & 0x8080808080808080 | v42 & 0x80808080808080))
    v45 = 0xE000000000000000;
  v254._countAndFlagsBits = v15;
  v254._object = (void *)((v45 & 0xFF00000000000000 | (v11 << 56) | v42 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  v251 = object;
  if (a1)
    goto LABEL_80;
LABEL_58:
  v9 = 0xE300000000000000;
  v12 = 7104878;
  while (1)
  {
    countAndFlagsBits = v254._countAndFlagsBits;
    object = (unint64_t)v254._object;
    v78 = ((unint64_t)v254._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0)
      v79 = ((unint64_t)v254._object >> 56) & 0xF;
    else
      v79 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    v252 = a1;
    if (!v79 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254._countAndFlagsBits = v12;
      v254._object = (void *)v9;
      goto LABEL_170;
    }
    v80 = v9 & 0x2000000000000000;
    v2 = HIBYTE(v9) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0 && v80)
    {
      v81 = v78 + v2;
      if (v78 + v2 <= 0xF)
      {
        if (v2)
        {
          v102 = 0;
          v103 = 0;
          v104 = (unint64_t)v254._object;
          do
          {
            v105 = v78 + v103;
            v106 = v103 + 1;
            if (v103 >= 8)
              v107 = v9;
            else
              v107 = v12;
            v108 = v107 >> (v102 & 0x38);
            v109 = (8 * v78 + v102) & 0x38;
            v110 = (-255 << v109) - 1;
            v111 = (unint64_t)v108 << v109;
            v112 = v111 | v110 & v104;
            v113 = v111 | v110 & countAndFlagsBits;
            if (v105 < 8)
              countAndFlagsBits = v113;
            else
              v104 = v112;
            v102 += 8;
            v103 = v106;
          }
          while (v2 != v106);
        }
        else
        {
          v104 = (unint64_t)v254._object;
        }
        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease(v9);
        v140 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v104 & 0x80808080808080))
          v140 = 0xE000000000000000;
        v254._countAndFlagsBits = countAndFlagsBits;
        v254._object = (void *)(v140 & 0xFF00000000000000 | (v81 << 56) | v104 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      v80 = 1;
    }
    a1 = v12 & 0xFFFFFFFFFFFFLL;
    v82 = v80 ? HIBYTE(v9) & 0xF : v12 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v9, 2, v43, v44);
    v250 = v82;
    if ((v9 & 0x1000000000000000) != 0)
      break;
    swift_bridgeObjectRetain_n(v9, 4, v83, v84);
    if ((object & 0x1000000000000000) != 0)
      goto LABEL_270;
LABEL_95:
    v87 = __OFADD__(v79, v82);
    v88 = v79 + v82;
    if (v87)
      goto LABEL_272;
LABEL_96:
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v88 >= 16)
      {
        v89 = v254._countAndFlagsBits;
        countAndFlagsBits = (uint64_t)v254._object;
        goto LABEL_105;
      }
      object = (unint64_t)v254._object;
      if (((uint64_t)v254._object & 0x2000000000000000) != 0)
      {
        v101 = 0;
        countAndFlagsBits = (uint64_t)v254._object;
      }
      else
      {
        countAndFlagsBits = (uint64_t)v254._object;
LABEL_128:
        v101 = 1;
      }
LABEL_147:
      v11 = v250;
      swift_bridgeObjectRelease_n(v9, 5);
      v2 = v254._countAndFlagsBits;
      if (v101)
      {
LABEL_282:
        if ((object & 0x1000000000000000) != 0)
        {
          v2 = _StringGuts._foreignConvertedToSmall()(v2, countAndFlagsBits);
          object = v245;
        }
        else
        {
          if ((v2 & 0x1000000000000000) != 0)
          {
            v235 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
            v236 = v2 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            v235 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, countAndFlagsBits);
            v236 = v21;
          }
          swift_bridgeObjectRetain(countAndFlagsBits, v21, v22, v23);
          closure #1 in _StringGuts._convertedToSmall()(v235, v236, &v253);
          swift_bridgeObjectRelease(countAndFlagsBits);
          object = *((_QWORD *)&v253 + 1);
          v2 = v253;
        }
      }
      v118._rawBits = (v11 << 16) | 1;
      v119._rawBits = 1;
      v120._rawBits = _StringGuts.validateScalarRange(_:)(v119, v118, v12, v9);
      if (v120._rawBits < 0x10000)
        v120._rawBits |= 3;
      v122 = specialized String.init(_:)(v120, v121, v12, v9);
      v124 = v123;
      swift_bridgeObjectRelease(v9);
      if ((v124 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v124);
      }
      else if ((v124 & 0x1000000000000000) != 0)
      {
        v122 = _StringGuts._foreignConvertedToSmall()(v122, v124);
        v247 = v246;
        swift_bridgeObjectRelease(v124);
        v124 = v247;
      }
      else
      {
        if ((v122 & 0x1000000000000000) != 0)
        {
          v237 = (unsigned __int8 *)((v124 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v238 = v122 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v237 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v122, v124);
        }
        closure #1 in _StringGuts._convertedToSmall()(v237, v238, &v253);
        swift_bridgeObjectRelease(v124);
        v124 = *((_QWORD *)&v253 + 1);
        v122 = v253;
      }
      v125 = HIBYTE(object) & 0xF;
      v126 = HIBYTE(v124) & 0xF;
      v127 = v126 + v125;
      if ((unint64_t)(v126 + v125) > 0xF)
        goto LABEL_302;
      if (v126)
      {
        v128 = 0;
        v129 = 0;
        do
        {
          v130 = v125 + v129;
          v131 = v129 + 1;
          if (v129 >= 8)
            v132 = v124;
          else
            v132 = v122;
          v133 = v132 >> (v128 & 0x38);
          v134 = (8 * v125 + v128) & 0x38;
          v135 = (-255 << v134) - 1;
          v136 = (unint64_t)v133 << v134;
          v137 = v136 | v135 & object;
          v138 = v136 | v135 & v2;
          if (v130 < 8)
            v2 = v138;
          else
            object = v137;
          v128 += 8;
          v129 = v131;
        }
        while (v126 != v131);
      }
      swift_bridgeObjectRelease(countAndFlagsBits);
      swift_bridgeObjectRelease(v9);
      v139 = 0xA000000000000000;
      if (!(v2 & 0x8080808080808080 | object & 0x80808080808080))
        v139 = 0xE000000000000000;
      v254._countAndFlagsBits = v2;
      v254._object = (void *)(v139 & 0xFF00000000000000 | (v127 << 56) | object & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    v89 = v254._countAndFlagsBits;
    countAndFlagsBits = (uint64_t)v254._object;
    v90 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v91 & 1) != 0)
      goto LABEL_303;
    if (v88 <= 15)
    {
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
        v101 = 0;
        object = countAndFlagsBits;
        goto LABEL_147;
      }
      object = countAndFlagsBits;
      if (v90 < v82)
        goto LABEL_128;
    }
LABEL_105:
    v92 = _StringGuts.nativeUnusedCapacity.getter(v89, countAndFlagsBits);
    v61 = (v93 & 1) == 0 && v92 >= v82;
    if ((v89 & ~countAndFlagsBits & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v61 & 1) != 0)
        goto LABEL_123;
LABEL_116:
      v95 = _StringGuts.nativeCapacity.getter(v89, countAndFlagsBits);
      if ((v96 & 1) != 0)
        v97 = 0;
      else
        v97 = v95;
      if (v97 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_291;
      }
      v98 = 2 * v97;
      if (v98 > v88)
        v88 = v98;
      goto LABEL_122;
    }
    if ((v61 & 1) == 0)
      goto LABEL_116;
LABEL_122:
    _StringGuts.grow(_:)(v88);
LABEL_123:
    swift_bridgeObjectRelease_n(v9, 4);
    if ((v9 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v9);
      _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0, v250);
    }
    else
    {
      if (v80)
      {
        swift_bridgeObjectRelease_n(v9, 2);
        *(_QWORD *)&v253 = v12;
        *((_QWORD *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
        v99 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v9) & 0xF, (uint64_t)&v253, HIBYTE(v9) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v99, v100, (v9 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(v9);
        goto LABEL_170;
      }
      if ((v12 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v9);
        v114 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v115 = v12 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v114 = _StringObject.sharedUTF8.getter(v12, v9);
        v115 = v243;
        swift_bridgeObjectRelease(v9);
        if (v115 < a1)
          goto LABEL_301;
      }
      v116 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v12 & 0xFFFFFFFFFFFFLL, (uint64_t)v114, v115);
      _StringGuts.appendInPlace(_:isASCII:)(v116, v117, v12 < 0);
    }
    swift_bridgeObjectRelease_n(v9, 2);
LABEL_170:
    v143 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    v12 = v143._countAndFlagsBits;
    v9 = (unint64_t)v143._object;
    countAndFlagsBits = v254._countAndFlagsBits;
    v2 = (unint64_t)v254._object;
    v144 = ((unint64_t)v254._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0)
      v88 = ((unint64_t)v254._object >> 56) & 0xF;
    else
      v88 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v88 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254 = v143;
LABEL_203:
      v171 = v252;
      goto LABEL_204;
    }
    a1 = (uint64_t)v143._object & 0x2000000000000000;
    v82 = ((unint64_t)v143._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0 && a1)
    {
      v145 = v144 + v82;
      if (v144 + v82 <= 0xF)
      {
        v171 = v252;
        if (v82)
        {
          v205 = 0;
          v206 = 0;
          v207 = (unint64_t)v254._object;
          do
          {
            v208 = v144 + v206;
            v209 = v206 + 1;
            if (v206 >= 8)
              v210 = (unint64_t)v143._object;
            else
              v210 = v143._countAndFlagsBits;
            v211 = v210 >> (v205 & 0x38);
            v212 = (8 * v144 + v205) & 0x38;
            v213 = (-255 << v212) - 1;
            v214 = (unint64_t)v211 << v212;
            v215 = v214 | v213 & v207;
            v216 = v214 | v213 & countAndFlagsBits;
            if (v208 < 8)
              countAndFlagsBits = v216;
            else
              v207 = v215;
            v205 += 8;
            v206 = v209;
          }
          while (v82 != v209);
        }
        else
        {
          v207 = (unint64_t)v254._object;
        }
        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease((uint64_t)v143._object);
        v222 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v207 & 0x80808080808080))
          v222 = 0xE000000000000000;
        v254._countAndFlagsBits = countAndFlagsBits;
        v254._object = (void *)(v222 & 0xFF00000000000000 | (v145 << 56) | v207 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_204;
      }
      a1 = 1;
    }
    v250 = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a1)
      object = ((unint64_t)v143._object >> 56) & 0xF;
    else
      object = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 2, v141, v142);
    if (((uint64_t)v143._object & 0x1000000000000000) != 0)
      goto LABEL_273;
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 4, v85, v86);
    v11 = object;
    if ((v2 & 0x1000000000000000) != 0)
      goto LABEL_276;
LABEL_184:
    v146 = v88 + v11;
    if (!__OFADD__(v88, v11))
      goto LABEL_185;
LABEL_278:
    __break(1u);
LABEL_279:
    v234 = String.UTF8View._foreignCount()();
    v24 = v234 + 8;
    if (__OFADD__(v234, 8))
    {
LABEL_281:
      __break(1u);
      goto LABEL_282;
    }
LABEL_13:
    v25 = v9 & ~countAndFlagsBits;
    if ((v25 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      v26 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
      if ((v27 & 1) != 0)
        goto LABEL_303;
      if (v24 > 15)
        goto LABEL_21;
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
        goto LABEL_62;
      if (v26 > 7)
      {
LABEL_21:
        v28 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
        v31 = (v29 & 1) == 0 && v28 > 7;
        if ((v25 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v31)
            goto LABEL_50;
        }
        else if (v31)
        {
          goto LABEL_49;
        }
        v46 = _StringGuts.nativeCapacity.getter(v9, countAndFlagsBits);
        if ((v47 & 1) != 0)
          v48 = 0;
        else
          v48 = v46;
        if (v48 + 0x4000000000000000 >= 0)
        {
          v49 = 2 * v48;
          if (v49 > v24)
            v24 = v49;
LABEL_49:
          _StringGuts.grow(_:)(v24);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          v253 = xmmword_1816ABF40;
          v50 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v253, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v50, v51, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          v251 = object;
          if (!a1)
            goto LABEL_58;
          goto LABEL_80;
        }
        __break(1u);
LABEL_296:
        v9 = _StringGuts._foreignConvertedToSmall()(v9, countAndFlagsBits);
        v12 = v241;
        goto LABEL_63;
      }
    }
    else
    {
      if (v24 > 15)
        goto LABEL_21;
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        v12 = countAndFlagsBits;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((countAndFlagsBits & 0x1000000000000000) != 0)
      goto LABEL_296;
    if ((v9 & 0x1000000000000000) != 0)
    {
      v55 = (unsigned __int8 *)((countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v55 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, countAndFlagsBits);
      v12 = v52;
    }
    swift_bridgeObjectRetain(countAndFlagsBits, v52, v53, v54);
    closure #1 in _StringGuts._convertedToSmall()(v55, v12, &v253);
    swift_bridgeObjectRelease(countAndFlagsBits);
    v12 = *((_QWORD *)&v253 + 1);
    v9 = v253;
LABEL_63:
    v56._rawBits = 1;
    v57._rawBits = 524289;
    v58._rawBits = _StringGuts.validateScalarRange(_:)(v56, v57, 0x203A747261747328uLL, 0xE800000000000000);
    if (v58._rawBits < 0x10000)
      v58._rawBits |= 3;
    v2 = specialized String.init(_:)(v58, v59, 0x203A747261747328uLL, 0xE800000000000000);
    v61 = v60;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v61 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v61);
      goto LABEL_67;
    }
LABEL_291:
    if ((v61 & 0x1000000000000000) != 0)
    {
      v2 = _StringGuts._foreignConvertedToSmall()(v2, v61);
      v249 = v248;
      swift_bridgeObjectRelease(v61);
      v61 = v249;
    }
    else
    {
      if ((v2 & 0x1000000000000000) != 0)
      {
        v239 = (unsigned __int8 *)((v61 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v240 = v2 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v239 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, v61);
      }
      closure #1 in _StringGuts._convertedToSmall()(v239, v240, &v253);
      swift_bridgeObjectRelease(v61);
      v61 = *((_QWORD *)&v253 + 1);
      v2 = v253;
    }
LABEL_67:
    v62 = HIBYTE(v12) & 0xF;
    v63 = HIBYTE(v61) & 0xF;
    v64 = v63 + v62;
    if ((unint64_t)(v63 + v62) > 0xF)
      goto LABEL_302;
    if (v63)
    {
      v65 = 0;
      v66 = 0;
      do
      {
        v67 = v62 + v66;
        v68 = v66 + 1;
        if (v66 >= 8)
          v69 = v61;
        else
          v69 = v2;
        v70 = v69 >> (v65 & 0x38);
        v71 = (8 * v62 + v65) & 0x38;
        v72 = (-255 << v71) - 1;
        v73 = (unint64_t)v70 << v71;
        v74 = v73 | v72 & v12;
        v75 = v73 | v72 & v9;
        if (v67 < 8)
          v9 = v75;
        else
          v12 = v74;
        v65 += 8;
        v66 = v68;
      }
      while (v63 != v68);
    }
    swift_bridgeObjectRelease(countAndFlagsBits);
    swift_bridgeObjectRelease(0xE800000000000000);
    v76 = 0xA000000000000000;
    if (!(v9 & 0x8080808080808080 | v12 & 0x80808080808080))
      v76 = 0xE000000000000000;
    v254._countAndFlagsBits = v9;
    v254._object = (void *)(v76 & 0xFF00000000000000 | (v64 << 56) | v12 & 0xFFFFFFFFFFFFFFLL);
    v251 = object;
    if (!a1)
      goto LABEL_58;
LABEL_80:
    v12 = specialized String.init<A>(describing:)(a1);
    v9 = v77;
  }
  swift_bridgeObjectRetain_n(v9, 5, v83, v84);
  v224._rawBits = 1;
  v225._rawBits = (v82 << 16) | 1;
  v226._rawBits = _StringGuts.validateScalarRange(_:)(v224, v225, v12, v9);
  if (v226._rawBits < 0x10000)
    v226._rawBits |= 3;
  v82 = specialized Collection.count.getter(v226, v227, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((object & 0x1000000000000000) == 0)
    goto LABEL_95;
LABEL_270:
  v228 = String.UTF8View._foreignCount()();
  v88 = v228 + v82;
  if (!__OFADD__(v228, v82))
    goto LABEL_96;
LABEL_272:
  __break(1u);
LABEL_273:
  swift_bridgeObjectRetain_n(v9, 5, v85, v86);
  v229._rawBits = 1;
  v230._rawBits = (object << 16) | 1;
  v231._rawBits = _StringGuts.validateScalarRange(_:)(v229, v230, v12, v9);
  if (v231._rawBits < 0x10000)
    v231._rawBits |= 3;
  v11 = specialized Collection.count.getter(v231, v232, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((v2 & 0x1000000000000000) == 0)
    goto LABEL_184;
LABEL_276:
  v233 = String.UTF8View._foreignCount()();
  v146 = v233 + v11;
  if (__OFADD__(v233, v11))
    goto LABEL_278;
LABEL_185:
  if ((countAndFlagsBits & ~v2 & 0x2000000000000000) != 0
    && swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
  {
    v147 = (unint64_t)v254._object;
    v148 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v149 & 1) != 0)
    {
LABEL_303:
      v244 = 258;
      goto LABEL_304;
    }
    if (v146 <= 15 && ((v147 & 0x2000000000000000) != 0 || v148 < (uint64_t)v11))
    {
LABEL_197:
      swift_bridgeObjectRelease_n(v9, 5);
      v152 = v254._countAndFlagsBits;
      swift_bridgeObjectRetain(v147, v153, v154, v155);
      v156 = _StringGuts._convertedToSmall()(v152, v147);
      v158 = v157;
      swift_bridgeObjectRelease(v147);
      v159._rawBits = (object << 16) | 1;
      v160._rawBits = 1;
      v161._rawBits = _StringGuts.validateScalarRange(_:)(v160, v159, v12, v9);
      if (v161._rawBits < 0x10000)
        v161._rawBits |= 3;
      v163 = specialized String.init(_:)(v161, v162, v12, v9);
      v165 = v164;
      swift_bridgeObjectRelease(v9);
      v166 = _StringGuts._convertedToSmall()(v163, v165);
      v168 = v167;
      swift_bridgeObjectRelease(v165);
      v169 = specialized _SmallString.init(_:appending:)(v156, v158, v166, v168);
      v171 = v252;
      if ((v172 & 1) == 0)
      {
        v173 = v169;
        v174 = v170;
        swift_bridgeObjectRelease(v147);
        swift_bridgeObjectRelease(v9);
        v254._countAndFlagsBits = v173;
        v254._object = v174;
        goto LABEL_204;
      }
LABEL_302:
      v244 = 266;
LABEL_304:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v244, 0);
    }
  }
  else if (v146 <= 15)
  {
    v147 = (unint64_t)v254._object;
    goto LABEL_197;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v146, v11);
  swift_bridgeObjectRelease_n(v9, 4);
  if ((v9 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v9);
    _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0, object);
    swift_bridgeObjectRelease_n(v9, 2);
    goto LABEL_203;
  }
  if (a1)
  {
    swift_bridgeObjectRelease_n(v9, 2);
    *(_QWORD *)&v253 = v12;
    *((_QWORD *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
    v150 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v82, (uint64_t)&v253, v82);
    _StringGuts.appendInPlace(_:isASCII:)(v150, v151, (v9 & 0x4000000000000000) != 0);
    swift_bridgeObjectRelease(v9);
    goto LABEL_203;
  }
  if ((v12 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v9);
    v217 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    v218 = v250;
    v219 = v250;
    v171 = v252;
  }
  else
  {
    v217 = _StringObject.sharedUTF8.getter(v12, v9);
    v219 = v242;
    swift_bridgeObjectRelease(v9);
    if (v219 < v250)
LABEL_301:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    v171 = v252;
    v218 = v250;
  }
  v220 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v218, (uint64_t)v217, v219);
  _StringGuts.appendInPlace(_:isASCII:)(v220, v221, v12 < 0);
  swift_bridgeObjectRelease_n(v9, 2);
LABEL_204:
  if (v171)
    v175 = v251 - v171;
  else
    v175 = 0;
  v177 = _int64ToString(_:radix:uppercase:)(v175, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
  v178 = v176;
  v179 = v254._countAndFlagsBits;
  v180 = ((unint64_t)v254._object >> 56) & 0xF;
  v181 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v254._object & 0x2000000000000000) != 0)
    v181 = ((unint64_t)v254._object >> 56) & 0xF;
  if (v181 || (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v254._object & 0x2000000000000000) == 0)
    {
      if ((v176 & 0x2000000000000000) != 0)
      {
        v182 = HIBYTE(v176) & 0xF;
        goto LABEL_216;
      }
LABEL_215:
      v182 = v177 & 0xFFFFFFFFFFFFLL;
      goto LABEL_216;
    }
    if ((v176 & 0x2000000000000000) == 0)
      goto LABEL_215;
    v182 = HIBYTE(v176) & 0xF;
    v192 = v180 + v182;
    if (v180 + v182 > 0xF)
    {
LABEL_216:
      _StringGuts.append(_:)(v177, v176, 0, v182);
      swift_bridgeObjectRelease(v178);
      v177 = v254._countAndFlagsBits;
      v178 = (unint64_t)v254._object;
    }
    else
    {
      if (v182)
      {
        v193 = 0;
        v194 = 0;
        v195 = (unint64_t)v254._object;
        do
        {
          v196 = v180 + v194;
          v197 = v194 + 1;
          if (v194 >= 8)
            v198 = v176;
          else
            v198 = v177;
          v199 = v198 >> (v193 & 0x38);
          v200 = (8 * v180 + v193) & 0x38;
          v201 = (-255 << v200) - 1;
          v202 = (unint64_t)v199 << v200;
          v203 = v202 | v201 & v195;
          v204 = v202 | v201 & v179;
          if (v196 < 8)
            v179 = v204;
          else
            v195 = v203;
          v193 += 8;
          v194 = v197;
        }
        while (v182 != v197);
      }
      else
      {
        v195 = (unint64_t)v254._object;
      }
      swift_bridgeObjectRelease((uint64_t)v254._object);
      swift_bridgeObjectRelease(v178);
      v223 = 0xA000000000000000;
      if (!(v179 & 0x8080808080808080 | v195 & 0x80808080808080))
        v223 = 0xE000000000000000;
      v178 = v223 & 0xFF00000000000000 | (v192 << 56) | v195 & 0xFFFFFFFFFFFFFFLL;
      v254._countAndFlagsBits = v179;
      v254._object = (void *)v178;
      v177 = v179;
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v254._object);
    v254._countAndFlagsBits = v177;
    v254._object = (void *)v178;
  }
  v186 = HIBYTE(v178) & 0xF;
  if ((v178 & 0x2000000000000000) == 0)
    v186 = v177 & 0xFFFFFFFFFFFFLL;
  if (v186 || (v177 & ~v178 & 0x2000000000000000) != 0)
  {
    if ((v178 & 0x2000000000000000) == 0
      || (v187 = specialized _SmallString.init(_:appending:)(v177, v178, 0x29uLL, 0xE100000000000000), (v184 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000, v183, v184, v185);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      v188 = v254._countAndFlagsBits;
      v189 = (uint64_t)v254._object;
    }
    else
    {
      v188 = v187;
      v189 = v183;
      swift_bridgeObjectRelease(v178);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v178);
    v189 = 0xE100000000000000;
    v188 = 41;
  }
  v190 = specialized static String.+ infix(_:_:)(0xD00000000000001DLL, 0x80000001816AC5D0 | 0x8000000000000000, v188, v189);
  swift_bridgeObjectRelease(0x80000001816AC5D0 | 0x8000000000000000);
  swift_bridgeObjectRelease(v189);
  return v190;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeMutableRawBufferPointer()
{
  uint64_t v0;

  return UnsafeMutableRawBufferPointer.debugDescription.getter(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
}

uint64_t (*UnsafeMutableRawBufferPointer.subscript.modify(_QWORD *a1))()
{
  *a1 = 0;
  a1[1] = 0;
  return EnumeratedSequence._base.modify;
}

{
  *a1 = 0;
  a1[1] = 0;
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawBufferPointer._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeRawBufferPointer.Iterator._position.setter(uint64_t result)
{
  _QWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UnsafeRawBufferPointer.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawBufferPointer.Iterator._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeRawBufferPointer.Iterator._end.setter(uint64_t result)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 8) = result;
  return result;
}

uint64_t (*UnsafeRawBufferPointer.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt8_optional __swiftcall UnsafeRawBufferPointer.Iterator.next()()
{
  unsigned __int8 **v0;
  unsigned __int8 *v1;
  unsigned __int8 *v2;
  BOOL v3;
  __int16 v4;
  __int16 v5;

  v2 = *v0;
  v1 = v0[1];
  if (!*v0)
  {
    if (v1)
LABEL_13:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
LABEL_10:
    v5 = 0;
    v4 = 1;
    return (Swift::UInt8_optional)(v5 | (v4 << 8));
  }
  if (v1)
    v3 = v2 == v1;
  else
    v3 = 0;
  if (v3)
    goto LABEL_10;
  if (!v1)
    goto LABEL_13;
  if (v2 >= v1)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
  v4 = 0;
  v5 = *v2;
  *v0 = v2 + 1;
  return (Swift::UInt8_optional)(v5 | (v4 << 8));
}

Swift::UInt8_optional protocol witness for IteratorProtocol.next() in conformance UnsafeRawBufferPointer.Iterator@<W0>(Swift::UInt8 *a1@<X8>)
{
  Swift::UInt8_optional result;

  result = UnsafeRawBufferPointer.Iterator.next()();
  *a1 = result.value;
  a1[1] = result.is_nil;
  return result;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeRawBufferPointer.Iterator()
{
  char **v0;

  return specialized _copySequenceToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeRawBufferPointer.Iterator(char **a1, uint64_t a2, uint64_t a3)
{
  char **v3;

  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeRawBufferPointer()
{
  _QWORD *v0;

  if (*v0)
    return v0[1] - *v0;
  else
    return 0;
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, _QWORD, _QWORD))
{
  _QWORD *v6;
  uint64_t v8;
  uint64_t v9;

  *a1 = a6(a2, a3, *v6, v6[1]);
  a1[1] = v8;
  return v9;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  return UnsafeRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  if (a2)
  {
    v9 = a3 - a2;
    if (a3 - a2 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    v10 = a2;
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  result = a1(v10, v9);
  if (!v5)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(a4 - 8) + 56))(a5, 0, 1, a4);
  return result;
}

uint64_t UnsafeRawBufferPointer.startIndex.getter()
{
  return 0;
}

uint64_t UnsafeRawBufferPointer.endIndex.getter(uint64_t a1, uint64_t a2)
{
  if (a1)
    return a2 - a1;
  else
    return 0;
}

uint64_t UnsafeRawBufferPointer.indices.getter()
{
  return 0;
}

uint64_t UnsafeRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, 0x505uLL, 0x506uLL);
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a4, 0);
  if (!a2 || a3 - a2 <= a1)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a5, 0);
  return *(unsigned __int8 *)(a2 + a1);
}

uint64_t UnsafeRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, a4, 0x513uLL, 0x514uLL);
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  if (result < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a5, 0);
  if (a3)
  {
    if (a4 - a3 >= a2)
      return result;
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a6, 0);
  }
  if (a2 >= 1)
    goto LABEL_6;
  return result;
}

void protocol witness for Collection.endIndex.getter in conformance UnsafeRawBufferPointer(_QWORD *a1@<X8>)
{
  uint64_t *v1;
  uint64_t v2;

  v2 = *v1;
  if (*v1)
    v2 = v1[1] - v2;
  *a1 = v2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeRawBufferPointer(_BYTE *a1, uint64_t *a2))()
{
  uint64_t *v2;

  *a1 = UnsafeRawBufferPointer.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UnsafeRawBufferPointer@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer(a1, 0x513uLL, 0x514uLL, a2);
}

_QWORD *protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer@<X0>(_QWORD *result@<X0>, unint64_t a2@<X3>, unint64_t a3@<X4>, _QWORD *a4@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if ((*result & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a2, 0);
  v5 = result[1];
  v6 = *v4;
  v7 = v4[1];
  if (!*v4)
  {
    if (v5 < 1)
      goto LABEL_4;
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a3, 0);
  }
  if (v7 - v6 < v5)
    goto LABEL_6;
LABEL_4:
  *a4 = *result;
  a4[1] = v5;
  a4[2] = v6;
  a4[3] = v7;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance UnsafeRawBufferPointer@<X0>(_QWORD *a1@<X8>)
{
  uint64_t result;
  uint64_t v3;

  result = UnsafeRawBufferPointer.indices.getter();
  *a1 = 0;
  a1[1] = v3;
  return result;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance UnsafeRawBufferPointer()
{
  _QWORD *v0;

  return !*v0 || v0[1] == *v0;
}

uint64_t protocol witness for Collection.index(after:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v2;
  uint64_t result;

  result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2, v2[1]);
  *a2 = result;
  return result;
}

uint64_t *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableRawBufferPointer(uint64_t *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (!*v1 || (v2 = *result, *result < 0) || v2 >= v1[1] - *v1)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  *result = v2 + 1;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v2;
  uint64_t result;

  result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2, v2[1]);
  *a2 = result;
  return result;
}

uint64_t *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableRawBufferPointer(uint64_t *result)
{
  _QWORD *v1;
  uint64_t v2;

  v2 = *result - 1;
  if (__OFSUB__(*result, 1))
  {
    __break(1u);
  }
  else
  {
    if (!*v1 || v2 < 0 || v2 >= v1[1] - *v1)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
    *result = v2;
  }
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *v3;
  uint64_t result;

  result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3, v3[1]);
  *a3 = result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance UnsafeRawBufferPointer(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v2;

  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2, v2[1]);
}

Swift::Void __swiftcall UnsafeRawBufferPointer.deallocate()()
{
  void *v0;

  if (v0)
    swift_slowDealloc(v0);
}

uint64_t UnsafeRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  if (a3)
    result = a3 + a1;
  else
    result = 0;
  v5 = a2 - a1;
  if (v5 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  if (v5)
  {
    if (!result)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
  }
  return result;
}

unint64_t UnsafeRawBufferPointer.debugDescription.getter(uint64_t a1, unint64_t object)
{
  unint64_t v2;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t countAndFlagsBits;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  Swift::Int v24;
  unint64_t v25;
  int64_t v26;
  char v27;
  int64_t v28;
  char v29;
  BOOL v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  unint64_t v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  size_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  unsigned __int8 *v55;
  Swift::String::Index v56;
  Swift::String::Index v57;
  Swift::String::Index v58;
  Swift::String::Index v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  char v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  char *v86;
  BOOL v87;
  Swift::Int v88;
  uint64_t v89;
  int64_t v90;
  char v91;
  int64_t v92;
  char v93;
  uint64_t v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  size_t v100;
  int v101;
  char v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  char v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  id v114;
  uint64_t v115;
  char *v116;
  size_t v117;
  Swift::String::Index v118;
  Swift::String::Index v119;
  Swift::String::Index v120;
  Swift::String::Index v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  char v134;
  uint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  uint64_t v141;
  char *v142;
  Swift::String v143;
  unint64_t v144;
  unint64_t v145;
  int64_t v146;
  unint64_t v147;
  int64_t v148;
  char v149;
  char *v150;
  size_t v151;
  unint64_t v152;
  uint64_t v153;
  uint64_t v154;
  char *v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  Swift::String::Index v159;
  Swift::String::Index v160;
  Swift::String::Index v161;
  Swift::String::Index v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  void *v170;
  uint64_t v171;
  char v172;
  uint64_t v173;
  void *v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  char *v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unint64_t v190;
  unint64_t v192;
  char v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  char v200;
  uint64_t v201;
  unint64_t v202;
  unint64_t v203;
  unint64_t v204;
  char v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  char v212;
  uint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  id v217;
  uint64_t v218;
  uint64_t v219;
  char *v220;
  size_t v221;
  unint64_t v222;
  unint64_t v223;
  Swift::String::Index v224;
  Swift::String::Index v225;
  Swift::String::Index v226;
  Swift::String::Index v227;
  Swift::Int v228;
  Swift::String::Index v229;
  Swift::String::Index v230;
  Swift::String::Index v231;
  Swift::String::Index v232;
  Swift::Int v233;
  Swift::Int v234;
  unsigned __int8 *v235;
  uint64_t v236;
  unsigned __int8 *v237;
  uint64_t v238;
  unsigned __int8 *v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  unint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  unint64_t v248;
  unint64_t v249;
  uint64_t v250;
  unint64_t v251;
  uint64_t v252;
  __int128 v253;
  Swift::String v254;

  v5 = specialized static String._createEmpty(withInitialCapacity:)(22);
  v9 = v5;
  countAndFlagsBits = v6;
  v254._countAndFlagsBits = v5;
  v254._object = (void *)v6;
  v11 = HIBYTE(v6) & 0xF;
  v12 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000) != 0)
    v13 = HIBYTE(v6) & 0xF;
  else
    v13 = v5 & 0xFFFFFFFFFFFFLL;
  if (!v13 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    v254._countAndFlagsBits = 0x203A747261747328;
    v254._object = (void *)0xE800000000000000;
    v251 = object;
    if (a1)
      goto LABEL_80;
    goto LABEL_58;
  }
  if ((v6 & 0x2000000000000000) == 0 || v11 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6, v7, v8);
    if ((countAndFlagsBits & 0x1000000000000000) == 0)
    {
      v24 = v13 + 8;
      if (!__OFADD__(v13, 8))
        goto LABEL_13;
      goto LABEL_281;
    }
    goto LABEL_279;
  }
  v14 = 8 * HIBYTE(v6);
  v15 = (40 << (v14 & 0x38)) | ((-255 << (v14 & 0x38)) - 1) & v5;
  v16 = (v14 + 8) & 0x38;
  v17 = (-255 << v16) - 1;
  v18 = 115 << v16;
  if (v11 >= 7)
  {
    v20 = v18 | v17 & v6;
    v19 = 8;
    goto LABEL_32;
  }
  v15 = v18 | v17 & v15;
  if (v11 == 6)
  {
    v19 = 0;
    v20 = v6;
LABEL_32:
    v32 = (116 << v19) | ((-255 << v19) - 1) & v20;
    v33 = v11 + 3;
LABEL_33:
    v34 = (97 << (8 * (v33 & 7u))) | ((-255 << (8 * (v33 & 7u))) - 1) & v32;
    v35 = v11 + 4;
LABEL_34:
    v36 = (114 << (8 * (v35 & 7u))) | ((-255 << (8 * (v35 & 7u))) - 1) & v34;
    v37 = v11 + 5;
LABEL_35:
    v38 = (116 << (8 * (v37 & 7u))) | ((-255 << (8 * (v37 & 7u))) - 1) & v36;
    v39 = v11 + 6;
LABEL_36:
    v40 = (58 << (8 * (v39 & 7u))) | ((-255 << (8 * (v39 & 7u))) - 1) & v38;
    v41 = v11 + 7;
    goto LABEL_37;
  }
  v15 = (116 << ((v14 + 16) & 0x38)) | ((-255 << ((v14 + 16) & 0x38)) - 1) & v15;
  if (v11 >= 5)
  {
    v33 = 8;
    v32 = v6;
    goto LABEL_33;
  }
  v15 = (97 << ((v14 + 24) & 0x38)) | ((-255 << ((v14 + 24) & 0x38)) - 1) & v15;
  if (v11 == 4)
  {
    v35 = 8;
    v34 = v6;
    goto LABEL_34;
  }
  v15 = (114 << ((v14 + 32) & 0x38)) | ((-255 << ((v14 + 32) & 0x38)) - 1) & v15;
  if (v11 >= 3)
  {
    v37 = 8;
    v36 = v6;
    goto LABEL_35;
  }
  v15 = (116 << ((v14 + 40) & 0x38)) | ((-255 << ((v14 + 40) & 0x38)) - 1) & v15;
  if (v11 == 2)
  {
    v39 = 8;
    v38 = v6;
    goto LABEL_36;
  }
  v15 = (58 << ((v14 + 48) & 0x38)) | ((-255 << ((v14 + 48) & 0x38)) - 1) & v15;
  if (!v11)
  {
    v15 = (32 << ((v14 + 56) & 0x38)) | ((-255 << ((v14 + 56) & 0x38)) - 1) & v15;
    v42 = v6;
    goto LABEL_38;
  }
  v41 = 8;
  v40 = v6;
LABEL_37:
  v42 = (32 << (8 * (v41 & 7u))) | ((-255 << (8 * (v41 & 7u))) - 1) & v40;
LABEL_38:
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE800000000000000);
  v45 = 0xA000000000000000;
  if (!(v15 & 0x8080808080808080 | v42 & 0x80808080808080))
    v45 = 0xE000000000000000;
  v254._countAndFlagsBits = v15;
  v254._object = (void *)((v45 & 0xFF00000000000000 | (v11 << 56) | v42 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  v251 = object;
  if (a1)
    goto LABEL_80;
LABEL_58:
  v9 = 0xE300000000000000;
  v12 = 7104878;
  while (1)
  {
    countAndFlagsBits = v254._countAndFlagsBits;
    object = (unint64_t)v254._object;
    v78 = ((unint64_t)v254._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0)
      v79 = ((unint64_t)v254._object >> 56) & 0xF;
    else
      v79 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    v252 = a1;
    if (!v79 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254._countAndFlagsBits = v12;
      v254._object = (void *)v9;
      goto LABEL_170;
    }
    v80 = v9 & 0x2000000000000000;
    v2 = HIBYTE(v9) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0 && v80)
    {
      v81 = v78 + v2;
      if (v78 + v2 <= 0xF)
      {
        if (v2)
        {
          v102 = 0;
          v103 = 0;
          v104 = (unint64_t)v254._object;
          do
          {
            v105 = v78 + v103;
            v106 = v103 + 1;
            if (v103 >= 8)
              v107 = v9;
            else
              v107 = v12;
            v108 = v107 >> (v102 & 0x38);
            v109 = (8 * v78 + v102) & 0x38;
            v110 = (-255 << v109) - 1;
            v111 = (unint64_t)v108 << v109;
            v112 = v111 | v110 & v104;
            v113 = v111 | v110 & countAndFlagsBits;
            if (v105 < 8)
              countAndFlagsBits = v113;
            else
              v104 = v112;
            v102 += 8;
            v103 = v106;
          }
          while (v2 != v106);
        }
        else
        {
          v104 = (unint64_t)v254._object;
        }
        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease(v9);
        v140 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v104 & 0x80808080808080))
          v140 = 0xE000000000000000;
        v254._countAndFlagsBits = countAndFlagsBits;
        v254._object = (void *)(v140 & 0xFF00000000000000 | (v81 << 56) | v104 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      v80 = 1;
    }
    a1 = v12 & 0xFFFFFFFFFFFFLL;
    v82 = v80 ? HIBYTE(v9) & 0xF : v12 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v9, 2, v43, v44);
    v250 = v82;
    if ((v9 & 0x1000000000000000) != 0)
      break;
    swift_bridgeObjectRetain_n(v9, 4, v83, v84);
    if ((object & 0x1000000000000000) != 0)
      goto LABEL_270;
LABEL_95:
    v87 = __OFADD__(v79, v82);
    v88 = v79 + v82;
    if (v87)
      goto LABEL_272;
LABEL_96:
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v88 >= 16)
      {
        v89 = v254._countAndFlagsBits;
        countAndFlagsBits = (uint64_t)v254._object;
        goto LABEL_105;
      }
      object = (unint64_t)v254._object;
      if (((uint64_t)v254._object & 0x2000000000000000) != 0)
      {
        v101 = 0;
        countAndFlagsBits = (uint64_t)v254._object;
      }
      else
      {
        countAndFlagsBits = (uint64_t)v254._object;
LABEL_128:
        v101 = 1;
      }
LABEL_147:
      v11 = v250;
      swift_bridgeObjectRelease_n(v9, 5);
      v2 = v254._countAndFlagsBits;
      if (v101)
      {
LABEL_282:
        if ((object & 0x1000000000000000) != 0)
        {
          v2 = _StringGuts._foreignConvertedToSmall()(v2, countAndFlagsBits);
          object = v245;
        }
        else
        {
          if ((v2 & 0x1000000000000000) != 0)
          {
            v235 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
            v236 = v2 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            v235 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, countAndFlagsBits);
            v236 = v21;
          }
          swift_bridgeObjectRetain(countAndFlagsBits, v21, v22, v23);
          closure #1 in _StringGuts._convertedToSmall()(v235, v236, &v253);
          swift_bridgeObjectRelease(countAndFlagsBits);
          object = *((_QWORD *)&v253 + 1);
          v2 = v253;
        }
      }
      v118._rawBits = (v11 << 16) | 1;
      v119._rawBits = 1;
      v120._rawBits = _StringGuts.validateScalarRange(_:)(v119, v118, v12, v9);
      if (v120._rawBits < 0x10000)
        v120._rawBits |= 3;
      v122 = specialized String.init(_:)(v120, v121, v12, v9);
      v124 = v123;
      swift_bridgeObjectRelease(v9);
      if ((v124 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v124);
      }
      else if ((v124 & 0x1000000000000000) != 0)
      {
        v122 = _StringGuts._foreignConvertedToSmall()(v122, v124);
        v247 = v246;
        swift_bridgeObjectRelease(v124);
        v124 = v247;
      }
      else
      {
        if ((v122 & 0x1000000000000000) != 0)
        {
          v237 = (unsigned __int8 *)((v124 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v238 = v122 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v237 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v122, v124);
        }
        closure #1 in _StringGuts._convertedToSmall()(v237, v238, &v253);
        swift_bridgeObjectRelease(v124);
        v124 = *((_QWORD *)&v253 + 1);
        v122 = v253;
      }
      v125 = HIBYTE(object) & 0xF;
      v126 = HIBYTE(v124) & 0xF;
      v127 = v126 + v125;
      if ((unint64_t)(v126 + v125) > 0xF)
        goto LABEL_302;
      if (v126)
      {
        v128 = 0;
        v129 = 0;
        do
        {
          v130 = v125 + v129;
          v131 = v129 + 1;
          if (v129 >= 8)
            v132 = v124;
          else
            v132 = v122;
          v133 = v132 >> (v128 & 0x38);
          v134 = (8 * v125 + v128) & 0x38;
          v135 = (-255 << v134) - 1;
          v136 = (unint64_t)v133 << v134;
          v137 = v136 | v135 & object;
          v138 = v136 | v135 & v2;
          if (v130 < 8)
            v2 = v138;
          else
            object = v137;
          v128 += 8;
          v129 = v131;
        }
        while (v126 != v131);
      }
      swift_bridgeObjectRelease(countAndFlagsBits);
      swift_bridgeObjectRelease(v9);
      v139 = 0xA000000000000000;
      if (!(v2 & 0x8080808080808080 | object & 0x80808080808080))
        v139 = 0xE000000000000000;
      v254._countAndFlagsBits = v2;
      v254._object = (void *)(v139 & 0xFF00000000000000 | (v127 << 56) | object & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    v89 = v254._countAndFlagsBits;
    countAndFlagsBits = (uint64_t)v254._object;
    v90 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v91 & 1) != 0)
      goto LABEL_303;
    if (v88 <= 15)
    {
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
        v101 = 0;
        object = countAndFlagsBits;
        goto LABEL_147;
      }
      object = countAndFlagsBits;
      if (v90 < v82)
        goto LABEL_128;
    }
LABEL_105:
    v92 = _StringGuts.nativeUnusedCapacity.getter(v89, countAndFlagsBits);
    v61 = (v93 & 1) == 0 && v92 >= v82;
    if ((v89 & ~countAndFlagsBits & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      if ((v61 & 1) != 0)
        goto LABEL_123;
LABEL_116:
      v95 = _StringGuts.nativeCapacity.getter(v89, countAndFlagsBits);
      if ((v96 & 1) != 0)
        v97 = 0;
      else
        v97 = v95;
      if (v97 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_291;
      }
      v98 = 2 * v97;
      if (v98 > v88)
        v88 = v98;
      goto LABEL_122;
    }
    if ((v61 & 1) == 0)
      goto LABEL_116;
LABEL_122:
    _StringGuts.grow(_:)(v88);
LABEL_123:
    swift_bridgeObjectRelease_n(v9, 4);
    if ((v9 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v9);
      _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0, v250);
    }
    else
    {
      if (v80)
      {
        swift_bridgeObjectRelease_n(v9, 2);
        *(_QWORD *)&v253 = v12;
        *((_QWORD *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
        v99 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v9) & 0xF, (uint64_t)&v253, HIBYTE(v9) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v99, v100, (v9 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(v9);
        goto LABEL_170;
      }
      if ((v12 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v9);
        v114 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v115 = v12 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v114 = _StringObject.sharedUTF8.getter(v12, v9);
        v115 = v243;
        swift_bridgeObjectRelease(v9);
        if (v115 < a1)
          goto LABEL_301;
      }
      v116 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v12 & 0xFFFFFFFFFFFFLL, (uint64_t)v114, v115);
      _StringGuts.appendInPlace(_:isASCII:)(v116, v117, v12 < 0);
    }
    swift_bridgeObjectRelease_n(v9, 2);
LABEL_170:
    v143 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    v12 = v143._countAndFlagsBits;
    v9 = (unint64_t)v143._object;
    countAndFlagsBits = v254._countAndFlagsBits;
    v2 = (unint64_t)v254._object;
    v144 = ((unint64_t)v254._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0)
      v88 = ((unint64_t)v254._object >> 56) & 0xF;
    else
      v88 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (!v88 && (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v254._object);
      v254 = v143;
LABEL_203:
      v171 = v252;
      goto LABEL_204;
    }
    a1 = (uint64_t)v143._object & 0x2000000000000000;
    v82 = ((unint64_t)v143._object >> 56) & 0xF;
    if (((uint64_t)v254._object & 0x2000000000000000) != 0 && a1)
    {
      v145 = v144 + v82;
      if (v144 + v82 <= 0xF)
      {
        v171 = v252;
        if (v82)
        {
          v205 = 0;
          v206 = 0;
          v207 = (unint64_t)v254._object;
          do
          {
            v208 = v144 + v206;
            v209 = v206 + 1;
            if (v206 >= 8)
              v210 = (unint64_t)v143._object;
            else
              v210 = v143._countAndFlagsBits;
            v211 = v210 >> (v205 & 0x38);
            v212 = (8 * v144 + v205) & 0x38;
            v213 = (-255 << v212) - 1;
            v214 = (unint64_t)v211 << v212;
            v215 = v214 | v213 & v207;
            v216 = v214 | v213 & countAndFlagsBits;
            if (v208 < 8)
              countAndFlagsBits = v216;
            else
              v207 = v215;
            v205 += 8;
            v206 = v209;
          }
          while (v82 != v209);
        }
        else
        {
          v207 = (unint64_t)v254._object;
        }
        swift_bridgeObjectRelease((uint64_t)v254._object);
        swift_bridgeObjectRelease((uint64_t)v143._object);
        v222 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v207 & 0x80808080808080))
          v222 = 0xE000000000000000;
        v254._countAndFlagsBits = countAndFlagsBits;
        v254._object = (void *)(v222 & 0xFF00000000000000 | (v145 << 56) | v207 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_204;
      }
      a1 = 1;
    }
    v250 = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a1)
      object = ((unint64_t)v143._object >> 56) & 0xF;
    else
      object = v143._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 2, v141, v142);
    if (((uint64_t)v143._object & 0x1000000000000000) != 0)
      goto LABEL_273;
    swift_bridgeObjectRetain_n((uint64_t)v143._object, 4, v85, v86);
    v11 = object;
    if ((v2 & 0x1000000000000000) != 0)
      goto LABEL_276;
LABEL_184:
    v146 = v88 + v11;
    if (!__OFADD__(v88, v11))
      goto LABEL_185;
LABEL_278:
    __break(1u);
LABEL_279:
    v234 = String.UTF8View._foreignCount()();
    v24 = v234 + 8;
    if (__OFADD__(v234, 8))
    {
LABEL_281:
      __break(1u);
      goto LABEL_282;
    }
LABEL_13:
    v25 = v9 & ~countAndFlagsBits;
    if ((v25 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      v26 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
      if ((v27 & 1) != 0)
        goto LABEL_303;
      if (v24 > 15)
        goto LABEL_21;
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
        goto LABEL_62;
      if (v26 > 7)
      {
LABEL_21:
        v28 = _StringGuts.nativeUnusedCapacity.getter(v9, countAndFlagsBits);
        v31 = (v29 & 1) == 0 && v28 > 7;
        if ((v25 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v31)
            goto LABEL_50;
        }
        else if (v31)
        {
          goto LABEL_49;
        }
        v46 = _StringGuts.nativeCapacity.getter(v9, countAndFlagsBits);
        if ((v47 & 1) != 0)
          v48 = 0;
        else
          v48 = v46;
        if (v48 + 0x4000000000000000 >= 0)
        {
          v49 = 2 * v48;
          if (v49 > v24)
            v24 = v49;
LABEL_49:
          _StringGuts.grow(_:)(v24);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          v253 = xmmword_1816ABF40;
          v50 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v253, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v50, v51, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          v251 = object;
          if (!a1)
            goto LABEL_58;
          goto LABEL_80;
        }
        __break(1u);
LABEL_296:
        v9 = _StringGuts._foreignConvertedToSmall()(v9, countAndFlagsBits);
        v12 = v241;
        goto LABEL_63;
      }
    }
    else
    {
      if (v24 > 15)
        goto LABEL_21;
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        v12 = countAndFlagsBits;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((countAndFlagsBits & 0x1000000000000000) != 0)
      goto LABEL_296;
    if ((v9 & 0x1000000000000000) != 0)
    {
      v55 = (unsigned __int8 *)((countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v55 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v9, countAndFlagsBits);
      v12 = v52;
    }
    swift_bridgeObjectRetain(countAndFlagsBits, v52, v53, v54);
    closure #1 in _StringGuts._convertedToSmall()(v55, v12, &v253);
    swift_bridgeObjectRelease(countAndFlagsBits);
    v12 = *((_QWORD *)&v253 + 1);
    v9 = v253;
LABEL_63:
    v56._rawBits = 1;
    v57._rawBits = 524289;
    v58._rawBits = _StringGuts.validateScalarRange(_:)(v56, v57, 0x203A747261747328uLL, 0xE800000000000000);
    if (v58._rawBits < 0x10000)
      v58._rawBits |= 3;
    v2 = specialized String.init(_:)(v58, v59, 0x203A747261747328uLL, 0xE800000000000000);
    v61 = v60;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v61 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v61);
      goto LABEL_67;
    }
LABEL_291:
    if ((v61 & 0x1000000000000000) != 0)
    {
      v2 = _StringGuts._foreignConvertedToSmall()(v2, v61);
      v249 = v248;
      swift_bridgeObjectRelease(v61);
      v61 = v249;
    }
    else
    {
      if ((v2 & 0x1000000000000000) != 0)
      {
        v239 = (unsigned __int8 *)((v61 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v240 = v2 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v239 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, v61);
      }
      closure #1 in _StringGuts._convertedToSmall()(v239, v240, &v253);
      swift_bridgeObjectRelease(v61);
      v61 = *((_QWORD *)&v253 + 1);
      v2 = v253;
    }
LABEL_67:
    v62 = HIBYTE(v12) & 0xF;
    v63 = HIBYTE(v61) & 0xF;
    v64 = v63 + v62;
    if ((unint64_t)(v63 + v62) > 0xF)
      goto LABEL_302;
    if (v63)
    {
      v65 = 0;
      v66 = 0;
      do
      {
        v67 = v62 + v66;
        v68 = v66 + 1;
        if (v66 >= 8)
          v69 = v61;
        else
          v69 = v2;
        v70 = v69 >> (v65 & 0x38);
        v71 = (8 * v62 + v65) & 0x38;
        v72 = (-255 << v71) - 1;
        v73 = (unint64_t)v70 << v71;
        v74 = v73 | v72 & v12;
        v75 = v73 | v72 & v9;
        if (v67 < 8)
          v9 = v75;
        else
          v12 = v74;
        v65 += 8;
        v66 = v68;
      }
      while (v63 != v68);
    }
    swift_bridgeObjectRelease(countAndFlagsBits);
    swift_bridgeObjectRelease(0xE800000000000000);
    v76 = 0xA000000000000000;
    if (!(v9 & 0x8080808080808080 | v12 & 0x80808080808080))
      v76 = 0xE000000000000000;
    v254._countAndFlagsBits = v9;
    v254._object = (void *)(v76 & 0xFF00000000000000 | (v64 << 56) | v12 & 0xFFFFFFFFFFFFFFLL);
    v251 = object;
    if (!a1)
      goto LABEL_58;
LABEL_80:
    v12 = specialized String.init<A>(describing:)((void *)a1);
    v9 = v77;
  }
  swift_bridgeObjectRetain_n(v9, 5, v83, v84);
  v224._rawBits = 1;
  v225._rawBits = (v82 << 16) | 1;
  v226._rawBits = _StringGuts.validateScalarRange(_:)(v224, v225, v12, v9);
  if (v226._rawBits < 0x10000)
    v226._rawBits |= 3;
  v82 = specialized Collection.count.getter(v226, v227, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((object & 0x1000000000000000) == 0)
    goto LABEL_95;
LABEL_270:
  v228 = String.UTF8View._foreignCount()();
  v88 = v228 + v82;
  if (!__OFADD__(v228, v82))
    goto LABEL_96;
LABEL_272:
  __break(1u);
LABEL_273:
  swift_bridgeObjectRetain_n(v9, 5, v85, v86);
  v229._rawBits = 1;
  v230._rawBits = (object << 16) | 1;
  v231._rawBits = _StringGuts.validateScalarRange(_:)(v229, v230, v12, v9);
  if (v231._rawBits < 0x10000)
    v231._rawBits |= 3;
  v11 = specialized Collection.count.getter(v231, v232, v12, v9);
  swift_bridgeObjectRelease(v9);
  if ((v2 & 0x1000000000000000) == 0)
    goto LABEL_184;
LABEL_276:
  v233 = String.UTF8View._foreignCount()();
  v146 = v233 + v11;
  if (__OFADD__(v233, v11))
    goto LABEL_278;
LABEL_185:
  if ((countAndFlagsBits & ~v2 & 0x2000000000000000) != 0
    && swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
  {
    v147 = (unint64_t)v254._object;
    v148 = _StringGuts.nativeUnusedCapacity.getter(v254._countAndFlagsBits, (uint64_t)v254._object);
    if ((v149 & 1) != 0)
    {
LABEL_303:
      v244 = 258;
      goto LABEL_304;
    }
    if (v146 <= 15 && ((v147 & 0x2000000000000000) != 0 || v148 < (uint64_t)v11))
    {
LABEL_197:
      swift_bridgeObjectRelease_n(v9, 5);
      v152 = v254._countAndFlagsBits;
      swift_bridgeObjectRetain(v147, v153, v154, v155);
      v156 = _StringGuts._convertedToSmall()(v152, v147);
      v158 = v157;
      swift_bridgeObjectRelease(v147);
      v159._rawBits = (object << 16) | 1;
      v160._rawBits = 1;
      v161._rawBits = _StringGuts.validateScalarRange(_:)(v160, v159, v12, v9);
      if (v161._rawBits < 0x10000)
        v161._rawBits |= 3;
      v163 = specialized String.init(_:)(v161, v162, v12, v9);
      v165 = v164;
      swift_bridgeObjectRelease(v9);
      v166 = _StringGuts._convertedToSmall()(v163, v165);
      v168 = v167;
      swift_bridgeObjectRelease(v165);
      v169 = specialized _SmallString.init(_:appending:)(v156, v158, v166, v168);
      v171 = v252;
      if ((v172 & 1) == 0)
      {
        v173 = v169;
        v174 = v170;
        swift_bridgeObjectRelease(v147);
        swift_bridgeObjectRelease(v9);
        v254._countAndFlagsBits = v173;
        v254._object = v174;
        goto LABEL_204;
      }
LABEL_302:
      v244 = 266;
LABEL_304:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v244, 0);
    }
  }
  else if (v146 <= 15)
  {
    v147 = (unint64_t)v254._object;
    goto LABEL_197;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v146, v11);
  swift_bridgeObjectRelease_n(v9, 4);
  if ((v9 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v9);
    _StringGuts._foreignAppendInPlace(_:)(v12, v9, 0, object);
    swift_bridgeObjectRelease_n(v9, 2);
    goto LABEL_203;
  }
  if (a1)
  {
    swift_bridgeObjectRelease_n(v9, 2);
    *(_QWORD *)&v253 = v12;
    *((_QWORD *)&v253 + 1) = v9 & 0xFFFFFFFFFFFFFFLL;
    v150 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v82, (uint64_t)&v253, v82);
    _StringGuts.appendInPlace(_:isASCII:)(v150, v151, (v9 & 0x4000000000000000) != 0);
    swift_bridgeObjectRelease(v9);
    goto LABEL_203;
  }
  if ((v12 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v9);
    v217 = (id)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    v218 = v250;
    v219 = v250;
    v171 = v252;
  }
  else
  {
    v217 = _StringObject.sharedUTF8.getter(v12, v9);
    v219 = v242;
    swift_bridgeObjectRelease(v9);
    if (v219 < v250)
LABEL_301:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    v171 = v252;
    v218 = v250;
  }
  v220 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v218, (uint64_t)v217, v219);
  _StringGuts.appendInPlace(_:isASCII:)(v220, v221, v12 < 0);
  swift_bridgeObjectRelease_n(v9, 2);
LABEL_204:
  if (v171)
    v175 = v251 - v171;
  else
    v175 = 0;
  v177 = _int64ToString(_:radix:uppercase:)(v175, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
  v178 = v176;
  v179 = v254._countAndFlagsBits;
  v180 = ((unint64_t)v254._object >> 56) & 0xF;
  v181 = v254._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v254._object & 0x2000000000000000) != 0)
    v181 = ((unint64_t)v254._object >> 56) & 0xF;
  if (v181 || (v254._countAndFlagsBits & ~(uint64_t)v254._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v254._object & 0x2000000000000000) == 0)
    {
      if ((v176 & 0x2000000000000000) != 0)
      {
        v182 = HIBYTE(v176) & 0xF;
        goto LABEL_216;
      }
LABEL_215:
      v182 = v177 & 0xFFFFFFFFFFFFLL;
      goto LABEL_216;
    }
    if ((v176 & 0x2000000000000000) == 0)
      goto LABEL_215;
    v182 = HIBYTE(v176) & 0xF;
    v192 = v180 + v182;
    if (v180 + v182 > 0xF)
    {
LABEL_216:
      _StringGuts.append(_:)(v177, v176, 0, v182);
      swift_bridgeObjectRelease(v178);
      v177 = v254._countAndFlagsBits;
      v178 = (unint64_t)v254._object;
    }
    else
    {
      if (v182)
      {
        v193 = 0;
        v194 = 0;
        v195 = (unint64_t)v254._object;
        do
        {
          v196 = v180 + v194;
          v197 = v194 + 1;
          if (v194 >= 8)
            v198 = v176;
          else
            v198 = v177;
          v199 = v198 >> (v193 & 0x38);
          v200 = (8 * v180 + v193) & 0x38;
          v201 = (-255 << v200) - 1;
          v202 = (unint64_t)v199 << v200;
          v203 = v202 | v201 & v195;
          v204 = v202 | v201 & v179;
          if (v196 < 8)
            v179 = v204;
          else
            v195 = v203;
          v193 += 8;
          v194 = v197;
        }
        while (v182 != v197);
      }
      else
      {
        v195 = (unint64_t)v254._object;
      }
      swift_bridgeObjectRelease((uint64_t)v254._object);
      swift_bridgeObjectRelease(v178);
      v223 = 0xA000000000000000;
      if (!(v179 & 0x8080808080808080 | v195 & 0x80808080808080))
        v223 = 0xE000000000000000;
      v178 = v223 & 0xFF00000000000000 | (v192 << 56) | v195 & 0xFFFFFFFFFFFFFFLL;
      v254._countAndFlagsBits = v179;
      v254._object = (void *)v178;
      v177 = v179;
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v254._object);
    v254._countAndFlagsBits = v177;
    v254._object = (void *)v178;
  }
  v186 = HIBYTE(v178) & 0xF;
  if ((v178 & 0x2000000000000000) == 0)
    v186 = v177 & 0xFFFFFFFFFFFFLL;
  if (v186 || (v177 & ~v178 & 0x2000000000000000) != 0)
  {
    if ((v178 & 0x2000000000000000) == 0
      || (v187 = specialized _SmallString.init(_:appending:)(v177, v178, 0x29uLL, 0xE100000000000000), (v184 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000, v183, v184, v185);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      v188 = v254._countAndFlagsBits;
      v189 = (uint64_t)v254._object;
    }
    else
    {
      v188 = v187;
      v189 = v183;
      swift_bridgeObjectRelease(v178);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v178);
    v189 = 0xE100000000000000;
    v188 = 41;
  }
  v190 = specialized static String.+ infix(_:_:)(0xD000000000000016, 0x80000001816AC5F0 | 0x8000000000000000, v188, v189);
  swift_bridgeObjectRelease(0x80000001816AC5F0 | 0x8000000000000000);
  swift_bridgeObjectRelease(v189);
  return v190;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeRawBufferPointer()
{
  uint64_t v0;

  return UnsafeRawBufferPointer.debugDescription.getter(*(_QWORD *)v0, *(_QWORD *)(v0 + 8));
}

uint64_t UnsafeRawBufferPointer.subscript.getter()
{
  return 0;
}

uint64_t withUnsafeMutableBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  return withUnsafeMutableBytes<A, B>(of:_:)(a1, a2, a3, a4, a5, "UnsafeMutableRawBufferPointer with negative count", 49, 0x68uLL);
}

uint64_t withUnsafeBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  return withUnsafeMutableBytes<A, B>(of:_:)(a1, a2, a3, a4, a5, "UnsafeRawBufferPointer with negative count", 42, 0x485uLL);
}

uint64_t withUnsafeMutableBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, unint64_t a8)
{
  uint64_t v8;

  v8 = *(_QWORD *)(*(_QWORD *)(a4 - 8) + 64);
  if (v8 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a6, a7, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a8, 0);
  return a2(a1, a1 + v8);
}

uint64_t withUnsafeBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(*(_QWORD *)(a4 - 8) + 64);
  if (v4 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  return a2(a1, a1 + v4);
}

uint64_t == infix(_:_:)()
{
  return 1;
}

uint64_t != infix(_:_:)()
{
  return 0;
}

uint64_t < infix(_:_:)()
{
  return 0;
}

uint64_t <= infix(_:_:)()
{
  return 1;
}

uint64_t > infix(_:_:)()
{
  return 0;
}

uint64_t >= infix(_:_:)()
{
  return 1;
}

uint64_t != infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *TupleTypeMetadata2;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  void (*v19)(char *, uint64_t, uint64_t);
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  char *v22;
  char v23;
  void (*v24)(char *, unint64_t *);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v26 = a8;
  v27 = a3;
  v28 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  v29 = *(TupleTypeMetadata2 - 1);
  v14 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v16 = (char *)&v26 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v26 - v17;
  v19 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 16);
  v19((char *)&v26 - v17, a1, a5);
  v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a6 - 8) + 16);
  v21(v20, a2, a6);
  v19(v16, v27, a5);
  v22 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v22, v28, a6);
  if (((*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(a7 + 8))(v18, v16, a5, a7) & 1) != 0)
    v23 = (*(uint64_t (**)(char *, char *, uint64_t))(v26 + 8))(v20, v22, a6) ^ 1;
  else
    v23 = 1;
  v24 = *(void (**)(char *, unint64_t *))(v29 + 8);
  v24(v16, TupleTypeMetadata2);
  v24(v18, TupleTypeMetadata2);
  return v23 & 1;
}

uint64_t <= infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *TupleTypeMetadata2;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  void (*v19)(char *, uint64_t, uint64_t);
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char v25;
  char v26;
  void (*v27)(char *, unint64_t *);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v29 = a8;
  v30 = a3;
  v31 = a4;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  v32 = *(TupleTypeMetadata2 - 1);
  v14 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v29 - v17;
  v19 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a5 - 8) + 16);
  v19((char *)&v29 - v17, a1, a5);
  v20 = &v18[*((int *)TupleTypeMetadata2 + 12)];
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a6 - 8) + 16);
  v22 = a2;
  v23 = a7;
  v21(v20, v22, a6);
  v19(v16, v30, a5);
  v24 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  v21(v24, v31, a6);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v23 + 8) + 8))(v18, v16, a5) & 1) != 0)
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v29 + 24))(v20, v24, a6);
  else
    v25 = (*(uint64_t (**)(char *, char *, uint64_t))(v23 + 24))(v18, v16, a5);
  v26 = v25;
  v27 = *(void (**)(char *, unint64_t *))(v32 + 8);
  v27(v16, TupleTypeMetadata2);
  v27(v18, TupleTypeMetadata2);
  return v26 & 1;
}

uint64_t == infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, char *a3, char *a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t *TupleTypeMetadata2;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *TupleTypeMetadata3;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  void (*v25)(char *, uint64_t, uint64_t);
  void (*v26)(void);
  void (*v27)(void);
  char *v28;
  char *v29;
  unint64_t *v30;
  char *v31;
  char *v32;
  char v33;
  uint64_t v34;
  char v35;
  void (*v36)(char *, unint64_t *);
  void (*v37)(char *, unint64_t *);
  uint64_t v39;
  char *v40;
  char *v41;
  uint64_t v42;
  unint64_t *v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;

  v49 = a5;
  v50 = a6;
  v47 = a3;
  v48 = a4;
  v46 = a10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a8, a9, 0, 0);
  v42 = *(TupleTypeMetadata2 - 1);
  v43 = TupleTypeMetadata2;
  v16 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v41 = (char *)&v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v45 = (char *)&v39 - v18;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  v44 = *(TupleTypeMetadata3 - 1);
  v20 = MEMORY[0x1E0C80A78](TupleTypeMetadata3);
  v22 = (char *)&v39 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v20);
  v24 = (char *)&v39 - v23;
  v25 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a7 - 8) + 16);
  v25((char *)&v39 - v23, a1, a7);
  v26 = *(void (**)(void))(*(_QWORD *)(a8 - 8) + 16);
  v40 = &v24[*((int *)TupleTypeMetadata3 + 12)];
  v26();
  v27 = *(void (**)(void))(*(_QWORD *)(a9 - 8) + 16);
  v27();
  v25(v22, (uint64_t)v48, a7);
  v28 = &v22[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(char *, char *, uint64_t))v26)(v28, v49, a8);
  v49 = &v22[*((int *)TupleTypeMetadata3 + 16)];
  v27();
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v46 + 8))(v24, v22, a7) & 1) != 0)
  {
    v50 = a11;
    v29 = v45;
    ((void (*)(char *, char *, uint64_t))v26)(v45, v40, a8);
    v48 = v28;
    v30 = v43;
    v47 = &v29[*((int *)v43 + 12)];
    v27();
    v31 = v41;
    ((void (*)(char *, char *, uint64_t))v26)(v41, v48, a8);
    v32 = &v31[*((int *)v30 + 12)];
    ((void (*)(char *, char *, uint64_t))v27)(v32, v49, a9);
    v33 = (*(uint64_t (**)(char *, char *, uint64_t))(v50 + 8))(v29, v31, a8);
    v34 = v42;
    if ((v33 & 1) != 0)
      v35 = (*(uint64_t (**)(char *, char *, uint64_t))(a12 + 8))(v47, v32, a9);
    else
      v35 = 0;
    v36 = *(void (**)(char *, unint64_t *))(v34 + 8);
    v36(v31, v30);
    v36(v45, v30);
  }
  else
  {
    v35 = 0;
  }
  v37 = *(void (**)(char *, unint64_t *))(v44 + 8);
  v37(v22, TupleTypeMetadata3);
  v37(v24, TupleTypeMetadata3);
  return v35 & 1;
}

uint64_t != infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, char *a3, char *a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t *TupleTypeMetadata2;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *TupleTypeMetadata3;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  void (*v25)(char *, uint64_t, uint64_t);
  void (*v26)(void);
  void (*v27)(void);
  char *v28;
  char *v29;
  unint64_t *v30;
  char *v31;
  char *v32;
  char v33;
  uint64_t v34;
  char v35;
  void (*v36)(char *, unint64_t *);
  void (*v37)(char *, unint64_t *);
  uint64_t v39;
  char *v40;
  char *v41;
  uint64_t v42;
  unint64_t *v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;

  v49 = a5;
  v50 = a6;
  v47 = a3;
  v48 = a4;
  v46 = a10;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a8, a9, 0, 0);
  v42 = *(TupleTypeMetadata2 - 1);
  v43 = TupleTypeMetadata2;
  v16 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v41 = (char *)&v39 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v45 = (char *)&v39 - v18;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  v44 = *(TupleTypeMetadata3 - 1);
  v20 = MEMORY[0x1E0C80A78](TupleTypeMetadata3);
  v22 = (char *)&v39 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v20);
  v24 = (char *)&v39 - v23;
  v25 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a7 - 8) + 16);
  v25((char *)&v39 - v23, a1, a7);
  v26 = *(void (**)(void))(*(_QWORD *)(a8 - 8) + 16);
  v40 = &v24[*((int *)TupleTypeMetadata3 + 12)];
  v26();
  v27 = *(void (**)(void))(*(_QWORD *)(a9 - 8) + 16);
  v27();
  v25(v22, (uint64_t)v48, a7);
  v28 = &v22[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(char *, char *, uint64_t))v26)(v28, v49, a8);
  v49 = &v22[*((int *)TupleTypeMetadata3 + 16)];
  v27();
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v46 + 8))(v24, v22, a7) & 1) != 0)
  {
    v50 = a11;
    v29 = v45;
    ((void (*)(char *, char *, uint64_t))v26)(v45, v40, a8);
    v48 = v28;
    v30 = v43;
    v47 = &v29[*((int *)v43 + 12)];
    v27();
    v31 = v41;
    ((void (*)(char *, char *, uint64_t))v26)(v41, v48, a8);
    v32 = &v31[*((int *)v30 + 12)];
    ((void (*)(char *, char *, uint64_t))v27)(v32, v49, a9);
    v33 = (*(uint64_t (**)(char *, char *, uint64_t))(v50 + 8))(v29, v31, a8);
    v34 = v42;
    if ((v33 & 1) != 0)
      v35 = (*(uint64_t (**)(char *, char *, uint64_t))(a12 + 8))(v47, v32, a9) ^ 1;
    else
      v35 = 1;
    v36 = *(void (**)(char *, unint64_t *))(v34 + 8);
    v36(v31, v30);
    v36(v45, v30);
  }
  else
  {
    v35 = 1;
  }
  v37 = *(void (**)(char *, unint64_t *))(v44 + 8);
  v37(v22, TupleTypeMetadata3);
  v37(v24, TupleTypeMetadata3);
  return v35 & 1;
}

uint64_t <= infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t *TupleTypeMetadata3;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  void (*v22)(void);
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  void (*v30)(char *, unint64_t *);
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v35 = a4;
  v36 = a5;
  v34 = a3;
  v37 = a10;
  v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  v39 = *(TupleTypeMetadata3 - 1);
  v16 = MEMORY[0x1E0C80A78](TupleTypeMetadata3);
  v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v32 - v19;
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a7 - 8) + 16);
  v21((char *)&v32 - v19, a1, a7);
  v22 = *(void (**)(void))(*(_QWORD *)(a8 - 8) + 16);
  v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  v27 = v37;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v37 + 8) + 8))(v20, v18, a7) & 1) != 0)
    v28 = <= infix<A, B>(_:_:)((uint64_t)v33, v23, v25, v26, a8, a9, a11, a12);
  else
    v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 24))(v20, v18, a7, v27);
  v29 = v28;
  v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t > infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t *TupleTypeMetadata3;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  void (*v22)(void);
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  void (*v30)(char *, unint64_t *);
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v35 = a4;
  v36 = a5;
  v34 = a3;
  v37 = a10;
  v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  v39 = *(TupleTypeMetadata3 - 1);
  v16 = MEMORY[0x1E0C80A78](TupleTypeMetadata3);
  v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v32 - v19;
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a7 - 8) + 16);
  v21((char *)&v32 - v19, a1, a7);
  v22 = *(void (**)(void))(*(_QWORD *)(a8 - 8) + 16);
  v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  v27 = v37;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v37 + 8) + 8))(v20, v18, a7) & 1) != 0)
    v28 = > infix<A, B>(_:_:)((uint64_t)v33, v23, v25, v26, a8, a9, a11, a12);
  else
    v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 40))(v20, v18, a7, v27);
  v29 = v28;
  v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t >= infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t *TupleTypeMetadata3;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  void (*v21)(char *, uint64_t, uint64_t);
  void (*v22)(void);
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t, uint64_t);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  void (*v30)(char *, unint64_t *);
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v35 = a4;
  v36 = a5;
  v34 = a3;
  v37 = a10;
  v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  v39 = *(TupleTypeMetadata3 - 1);
  v16 = MEMORY[0x1E0C80A78](TupleTypeMetadata3);
  v18 = (char *)&v32 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v16);
  v20 = (char *)&v32 - v19;
  v21 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a7 - 8) + 16);
  v21((char *)&v32 - v19, a1, a7);
  v22 = *(void (**)(void))(*(_QWORD *)(a8 - 8) + 16);
  v33 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  v23 = (uint64_t)&v20[*((int *)TupleTypeMetadata3 + 16)];
  v24 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v24(v23, v34, a9);
  v21(v18, v35, a7);
  v25 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 12)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v22)(v25, v36, a8);
  v26 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  v24(v26, v38, a9);
  v27 = v37;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v37 + 8) + 8))(v20, v18, a7) & 1) != 0)
    v28 = >= infix<A, B>(_:_:)((uint64_t)v33, v23, v25, v26, a8, a9, a11, a12);
  else
    v28 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v27 + 32))(v20, v18, a7, v27);
  v29 = v28;
  v30 = *(void (**)(char *, unint64_t *))(v39 + 8);
  v30(v18, TupleTypeMetadata3);
  v30(v20, TupleTypeMetadata3);
  return v29 & 1;
}

uint64_t == infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int *TupleTypeMetadata;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(void);
  void (*v25)(void);
  char *v26;
  void (*v27)(void);
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  void (*v33)(char *, int *);
  char *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD v46[5];

  v41 = a6;
  v42 = a7;
  v39 = a4;
  v40 = a5;
  v38 = a3;
  v43 = a13;
  v44 = a8;
  v46[0] = a9;
  v46[1] = a10;
  v46[2] = a11;
  v46[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v46, 0, 0);
  v45 = *((_QWORD *)TupleTypeMetadata - 1);
  v18 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v20 = (char *)&v35 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v35 - v21;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v23((char *)&v35 - v21, a1, a9);
  v24 = *(void (**)(void))(*(_QWORD *)(a10 - 8) + 16);
  v36 = &v22[TupleTypeMetadata[12]];
  v24();
  v25 = *(void (**)(void))(*(_QWORD *)(a11 - 8) + 16);
  v35 = &v22[TupleTypeMetadata[16]];
  v25();
  v26 = &v22[TupleTypeMetadata[20]];
  v37 = a12;
  v38 = v26;
  v27 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v27();
  v23(v20, (uint64_t)v40, a9);
  v40 = &v20[TupleTypeMetadata[12]];
  v41 = a10;
  v24();
  v28 = &v20[TupleTypeMetadata[16]];
  v29 = v42;
  v42 = a11;
  v30 = v37;
  ((void (*)(char *, uint64_t, uint64_t))v25)(v28, v29, a11);
  v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v44, v30);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v43 + 8))(v22, v20, a9) & 1) != 0)
    v32 = == infix<A, B, C>(_:_:)((uint64_t)v36, (uint64_t)v35, v38, v40, v28, v31, v41, v42, v30, a14, a15, a16);
  else
    v32 = 0;
  v33 = *(void (**)(char *, int *))(v45 + 8);
  v33(v20, TupleTypeMetadata);
  v33(v22, TupleTypeMetadata);
  return v32 & 1;
}

uint64_t != infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int *TupleTypeMetadata;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(void);
  void (*v25)(void);
  char *v26;
  void (*v27)(void);
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  void (*v33)(char *, int *);
  char *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD v46[5];

  v41 = a6;
  v42 = a7;
  v39 = a4;
  v40 = a5;
  v38 = a3;
  v43 = a13;
  v44 = a8;
  v46[0] = a9;
  v46[1] = a10;
  v46[2] = a11;
  v46[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v46, 0, 0);
  v45 = *((_QWORD *)TupleTypeMetadata - 1);
  v18 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v20 = (char *)&v35 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v35 - v21;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v23((char *)&v35 - v21, a1, a9);
  v24 = *(void (**)(void))(*(_QWORD *)(a10 - 8) + 16);
  v36 = &v22[TupleTypeMetadata[12]];
  v24();
  v25 = *(void (**)(void))(*(_QWORD *)(a11 - 8) + 16);
  v35 = &v22[TupleTypeMetadata[16]];
  v25();
  v26 = &v22[TupleTypeMetadata[20]];
  v37 = a12;
  v38 = v26;
  v27 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v27();
  v23(v20, (uint64_t)v40, a9);
  v40 = &v20[TupleTypeMetadata[12]];
  v41 = a10;
  v24();
  v28 = &v20[TupleTypeMetadata[16]];
  v29 = v42;
  v42 = a11;
  v30 = v37;
  ((void (*)(char *, uint64_t, uint64_t))v25)(v28, v29, a11);
  v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v44, v30);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v43 + 8))(v22, v20, a9) & 1) != 0)
    v32 = != infix<A, B, C>(_:_:)((uint64_t)v36, (uint64_t)v35, v38, v40, v28, v31, v41, v42, v30, a14, a15, a16);
  else
    v32 = 1;
  v33 = *(void (**)(char *, int *))(v45 + 8);
  v33(v20, TupleTypeMetadata);
  v33(v22, TupleTypeMetadata);
  return v32 & 1;
}

uint64_t < infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int *TupleTypeMetadata;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(void);
  void (*v25)(void);
  uint64_t v26;
  void (*v27)(void);
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  void (*v35)(char *, int *);
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[5];

  v43 = a6;
  v44 = a7;
  v41 = a4;
  v42 = (char *)a5;
  v39 = (char *)a2;
  v40 = a3;
  v45 = a13;
  v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v48, 0, 0);
  v47 = *((_QWORD *)TupleTypeMetadata - 1);
  v18 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v37 - v21;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v23((char *)&v37 - v21, a1, a9);
  v24 = *(void (**)(void))(*(_QWORD *)(a10 - 8) + 16);
  v37 = &v22[TupleTypeMetadata[12]];
  v24();
  v25 = *(void (**)(void))(*(_QWORD *)(a11 - 8) + 16);
  v39 = &v22[TupleTypeMetadata[16]];
  v25();
  v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  v38 = a12;
  v27 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  v42 = &v20[TupleTypeMetadata[12]];
  v43 = a10;
  v24();
  v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  v29 = v44;
  v44 = a11;
  v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  v32 = v45;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v45 + 8) + 8))(v22, v20, a9) & 1) != 0)
    v33 = < infix<A, B, C>(_:_:)((uint64_t)v37, (uint64_t)v39, v40, (uint64_t)v42, v28, v31, v43, v44, v30, a14, a15, a16);
  else
    v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 16))(v22, v20, a9, v32);
  v34 = v33;
  v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t <= infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int *TupleTypeMetadata;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(void);
  void (*v25)(void);
  uint64_t v26;
  void (*v27)(void);
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  void (*v35)(char *, int *);
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[5];

  v43 = a6;
  v44 = a7;
  v41 = a4;
  v42 = (char *)a5;
  v39 = (char *)a2;
  v40 = a3;
  v45 = a13;
  v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v48, 0, 0);
  v47 = *((_QWORD *)TupleTypeMetadata - 1);
  v18 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v37 - v21;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v23((char *)&v37 - v21, a1, a9);
  v24 = *(void (**)(void))(*(_QWORD *)(a10 - 8) + 16);
  v37 = &v22[TupleTypeMetadata[12]];
  v24();
  v25 = *(void (**)(void))(*(_QWORD *)(a11 - 8) + 16);
  v39 = &v22[TupleTypeMetadata[16]];
  v25();
  v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  v38 = a12;
  v27 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  v42 = &v20[TupleTypeMetadata[12]];
  v43 = a10;
  v24();
  v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  v29 = v44;
  v44 = a11;
  v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  v32 = v45;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v45 + 8) + 8))(v22, v20, a9) & 1) != 0)
    v33 = <= infix<A, B, C>(_:_:)((uint64_t)v37, (uint64_t)v39, v40, (uint64_t)v42, v28, v31, v43, v44, v30, a14, a15, a16);
  else
    v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 24))(v22, v20, a9, v32);
  v34 = v33;
  v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t > infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int *TupleTypeMetadata;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(void);
  void (*v25)(void);
  uint64_t v26;
  void (*v27)(void);
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  void (*v35)(char *, int *);
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[5];

  v43 = a6;
  v44 = a7;
  v41 = a4;
  v42 = (char *)a5;
  v39 = (char *)a2;
  v40 = a3;
  v45 = a13;
  v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v48, 0, 0);
  v47 = *((_QWORD *)TupleTypeMetadata - 1);
  v18 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v37 - v21;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v23((char *)&v37 - v21, a1, a9);
  v24 = *(void (**)(void))(*(_QWORD *)(a10 - 8) + 16);
  v37 = &v22[TupleTypeMetadata[12]];
  v24();
  v25 = *(void (**)(void))(*(_QWORD *)(a11 - 8) + 16);
  v39 = &v22[TupleTypeMetadata[16]];
  v25();
  v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  v38 = a12;
  v27 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  v42 = &v20[TupleTypeMetadata[12]];
  v43 = a10;
  v24();
  v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  v29 = v44;
  v44 = a11;
  v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  v32 = v45;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v45 + 8) + 8))(v22, v20, a9) & 1) != 0)
    v33 = > infix<A, B, C>(_:_:)((uint64_t)v37, (uint64_t)v39, v40, (uint64_t)v42, v28, v31, v43, v44, v30, a14, a15, a16);
  else
    v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 40))(v22, v20, a9, v32);
  v34 = v33;
  v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t >= infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int *TupleTypeMetadata;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(void);
  void (*v25)(void);
  uint64_t v26;
  void (*v27)(void);
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;
  void (*v35)(char *, int *);
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[5];

  v43 = a6;
  v44 = a7;
  v41 = a4;
  v42 = (char *)a5;
  v39 = (char *)a2;
  v40 = a3;
  v45 = a13;
  v46 = a8;
  v48[0] = a9;
  v48[1] = a10;
  v48[2] = a11;
  v48[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v48, 0, 0);
  v47 = *((_QWORD *)TupleTypeMetadata - 1);
  v18 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v37 - v21;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a9 - 8) + 16);
  v23((char *)&v37 - v21, a1, a9);
  v24 = *(void (**)(void))(*(_QWORD *)(a10 - 8) + 16);
  v37 = &v22[TupleTypeMetadata[12]];
  v24();
  v25 = *(void (**)(void))(*(_QWORD *)(a11 - 8) + 16);
  v39 = &v22[TupleTypeMetadata[16]];
  v25();
  v26 = (uint64_t)&v22[TupleTypeMetadata[20]];
  v38 = a12;
  v27 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v40 = v26;
  v27();
  v23(v20, (uint64_t)v42, a9);
  v42 = &v20[TupleTypeMetadata[12]];
  v43 = a10;
  v24();
  v28 = (uint64_t)&v20[TupleTypeMetadata[16]];
  v29 = v44;
  v44 = a11;
  v30 = v38;
  ((void (*)(uint64_t, uint64_t, uint64_t))v25)(v28, v29, a11);
  v31 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v27)(v31, v46, v30);
  v32 = v45;
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v45 + 8) + 8))(v22, v20, a9) & 1) != 0)
    v33 = >= infix<A, B, C>(_:_:)((uint64_t)v37, (uint64_t)v39, v40, (uint64_t)v42, v28, v31, v43, v44, v30, a14, a15, a16);
  else
    v33 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v32 + 32))(v22, v20, a9, v32);
  v34 = v33;
  v35 = *(void (**)(char *, int *))(v47 + 8);
  v35(v20, TupleTypeMetadata);
  v35(v22, TupleTypeMetadata);
  return v34 & 1;
}

uint64_t == infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int *TupleTypeMetadata;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  void (*v28)(void);
  char *v29;
  void (*v30)(void);
  void (*v31)(void);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  void (*v36)(char *, int *);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(void);
  void (*v42)(char *, uint64_t, uint64_t);
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD v54[6];

  v47 = a6;
  v48 = a7;
  v45 = a3;
  v46 = (char *)a5;
  v43 = (char *)a4;
  v44 = (char *)a2;
  v52 = a16;
  v50 = a8;
  v51 = a10;
  v49 = a9;
  v54[0] = a11;
  v54[1] = a12;
  v54[2] = a13;
  v54[3] = a14;
  v54[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v54, 0, 0);
  v53 = *((_QWORD *)TupleTypeMetadata - 1);
  v22 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v24 = (char *)&v38 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v38 - v25;
  v42 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a11 - 8) + 16);
  v42((char *)&v38 - v25, a1, a11);
  v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  v41 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v39 = v27;
  v41();
  v28 = *(void (**)(void))(*(_QWORD *)(a13 - 8) + 16);
  v44 = &v26[TupleTypeMetadata[16]];
  v28();
  v29 = &v26[TupleTypeMetadata[20]];
  v40 = a14;
  v30 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v45 = v29;
  v30();
  v31 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v43 = &v26[TupleTypeMetadata[24]];
  v31();
  v42(v24, (uint64_t)v47, a11);
  v47 = &v24[TupleTypeMetadata[12]];
  v48 = a12;
  v41();
  v46 = &v24[TupleTypeMetadata[16]];
  v50 = a13;
  v28();
  v32 = v40;
  v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v49, v40);
  v34 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v34, v51, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v52 + 8))(v26, v24, a11) & 1) != 0)
    v35 = == infix<A, B, C, D>(_:_:)(v39, (uint64_t)v44, v45, (uint64_t)v43, v47, (uint64_t)v46, v33, v34, v48, v50, v32, a15, a17, a18, a19, a20);
  else
    v35 = 0;
  v36 = *(void (**)(char *, int *))(v53 + 8);
  v36(v24, TupleTypeMetadata);
  v36(v26, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t != infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int *TupleTypeMetadata;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  void (*v28)(void);
  char *v29;
  void (*v30)(void);
  void (*v31)(void);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  void (*v36)(char *, int *);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(void);
  void (*v42)(char *, uint64_t, uint64_t);
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD v54[6];

  v47 = a6;
  v48 = a7;
  v45 = a3;
  v46 = (char *)a5;
  v43 = (char *)a4;
  v44 = (char *)a2;
  v52 = a16;
  v50 = a8;
  v51 = a10;
  v49 = a9;
  v54[0] = a11;
  v54[1] = a12;
  v54[2] = a13;
  v54[3] = a14;
  v54[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v54, 0, 0);
  v53 = *((_QWORD *)TupleTypeMetadata - 1);
  v22 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v24 = (char *)&v38 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v38 - v25;
  v42 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a11 - 8) + 16);
  v42((char *)&v38 - v25, a1, a11);
  v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  v41 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v39 = v27;
  v41();
  v28 = *(void (**)(void))(*(_QWORD *)(a13 - 8) + 16);
  v44 = &v26[TupleTypeMetadata[16]];
  v28();
  v29 = &v26[TupleTypeMetadata[20]];
  v40 = a14;
  v30 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v45 = v29;
  v30();
  v31 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v43 = &v26[TupleTypeMetadata[24]];
  v31();
  v42(v24, (uint64_t)v47, a11);
  v47 = &v24[TupleTypeMetadata[12]];
  v48 = a12;
  v41();
  v46 = &v24[TupleTypeMetadata[16]];
  v50 = a13;
  v28();
  v32 = v40;
  v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v49, v40);
  v34 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v34, v51, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v52 + 8))(v26, v24, a11) & 1) != 0)
    v35 = != infix<A, B, C, D>(_:_:)(v39, (uint64_t)v44, v45, (uint64_t)v43, v47, (uint64_t)v46, v33, v34, v48, v50, v32, a15, a17, a18, a19, a20);
  else
    v35 = 1;
  v36 = *(void (**)(char *, int *))(v53 + 8);
  v36(v24, TupleTypeMetadata);
  v36(v26, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t < infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int *TupleTypeMetadata;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  void (*v28)(void);
  uint64_t v29;
  void (*v30)(void);
  void (*v31)(void);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  char v37;
  void (*v38)(char *, int *);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(void);
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[6];

  v49 = (char *)a6;
  v50 = a7;
  v47 = (char *)a4;
  v48 = (char *)a5;
  v45 = (char *)a2;
  v46 = a3;
  v54 = a16;
  v52 = a8;
  v53 = a10;
  v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v56, 0, 0);
  v55 = *((_QWORD *)TupleTypeMetadata - 1);
  v22 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v40 - v25;
  v44 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a11 - 8) + 16);
  v44((char *)&v40 - v25, a1, a11);
  v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  v43 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v41 = v27;
  v43();
  v28 = *(void (**)(void))(*(_QWORD *)(a13 - 8) + 16);
  v45 = &v26[TupleTypeMetadata[16]];
  v28();
  v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  v42 = a14;
  v30 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v46 = v29;
  v30();
  v31 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  v49 = &v24[TupleTypeMetadata[12]];
  v50 = a12;
  v43();
  v48 = &v24[TupleTypeMetadata[16]];
  v52 = a13;
  v28();
  v32 = v42;
  v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  v34 = v54;
  v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v34 + 8) + 8))(v26, v24, a11) & 1) != 0)
    v36 = < infix<A, B, C, D>(_:_:)(v41, (uint64_t)v45, v46, (uint64_t)v47, (uint64_t)v49, (uint64_t)v48, v33, v35, v50, v52, v32, a15, a17, a18, a19, a20);
  else
    v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 16))(v26, v24, a11, v34);
  v37 = v36;
  v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t <= infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int *TupleTypeMetadata;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  void (*v28)(void);
  uint64_t v29;
  void (*v30)(void);
  void (*v31)(void);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  char v37;
  void (*v38)(char *, int *);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(void);
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[6];

  v49 = (char *)a6;
  v50 = a7;
  v47 = (char *)a4;
  v48 = (char *)a5;
  v45 = (char *)a2;
  v46 = a3;
  v54 = a16;
  v52 = a8;
  v53 = a10;
  v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v56, 0, 0);
  v55 = *((_QWORD *)TupleTypeMetadata - 1);
  v22 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v40 - v25;
  v44 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a11 - 8) + 16);
  v44((char *)&v40 - v25, a1, a11);
  v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  v43 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v41 = v27;
  v43();
  v28 = *(void (**)(void))(*(_QWORD *)(a13 - 8) + 16);
  v45 = &v26[TupleTypeMetadata[16]];
  v28();
  v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  v42 = a14;
  v30 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v46 = v29;
  v30();
  v31 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  v49 = &v24[TupleTypeMetadata[12]];
  v50 = a12;
  v43();
  v48 = &v24[TupleTypeMetadata[16]];
  v52 = a13;
  v28();
  v32 = v42;
  v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  v34 = v54;
  v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v34 + 8) + 8))(v26, v24, a11) & 1) != 0)
    v36 = <= infix<A, B, C, D>(_:_:)(v41, (uint64_t)v45, v46, (uint64_t)v47, (uint64_t)v49, (uint64_t)v48, v33, v35, v50, v52, v32, a15, a17, a18, a19, a20);
  else
    v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 24))(v26, v24, a11, v34);
  v37 = v36;
  v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t > infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int *TupleTypeMetadata;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  void (*v28)(void);
  uint64_t v29;
  void (*v30)(void);
  void (*v31)(void);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  char v37;
  void (*v38)(char *, int *);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(void);
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[6];

  v49 = (char *)a6;
  v50 = a7;
  v47 = (char *)a4;
  v48 = (char *)a5;
  v45 = (char *)a2;
  v46 = a3;
  v54 = a16;
  v52 = a8;
  v53 = a10;
  v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v56, 0, 0);
  v55 = *((_QWORD *)TupleTypeMetadata - 1);
  v22 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v40 - v25;
  v44 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a11 - 8) + 16);
  v44((char *)&v40 - v25, a1, a11);
  v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  v43 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v41 = v27;
  v43();
  v28 = *(void (**)(void))(*(_QWORD *)(a13 - 8) + 16);
  v45 = &v26[TupleTypeMetadata[16]];
  v28();
  v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  v42 = a14;
  v30 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v46 = v29;
  v30();
  v31 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  v49 = &v24[TupleTypeMetadata[12]];
  v50 = a12;
  v43();
  v48 = &v24[TupleTypeMetadata[16]];
  v52 = a13;
  v28();
  v32 = v42;
  v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  v34 = v54;
  v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v34 + 8) + 8))(v26, v24, a11) & 1) != 0)
    v36 = > infix<A, B, C, D>(_:_:)(v41, (uint64_t)v45, v46, (uint64_t)v47, (uint64_t)v49, (uint64_t)v48, v33, v35, v50, v52, v32, a15, a17, a18, a19, a20);
  else
    v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 40))(v26, v24, a11, v34);
  v37 = v36;
  v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t >= infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int *TupleTypeMetadata;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  void (*v28)(void);
  uint64_t v29;
  void (*v30)(void);
  void (*v31)(void);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  char v37;
  void (*v38)(char *, int *);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(void);
  void (*v44)(char *, uint64_t, uint64_t);
  char *v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[6];

  v49 = (char *)a6;
  v50 = a7;
  v47 = (char *)a4;
  v48 = (char *)a5;
  v45 = (char *)a2;
  v46 = a3;
  v54 = a16;
  v52 = a8;
  v53 = a10;
  v51 = a9;
  v56[0] = a11;
  v56[1] = a12;
  v56[2] = a13;
  v56[3] = a14;
  v56[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v56, 0, 0);
  v55 = *((_QWORD *)TupleTypeMetadata - 1);
  v22 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v24 = (char *)&v40 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v22);
  v26 = (char *)&v40 - v25;
  v44 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a11 - 8) + 16);
  v44((char *)&v40 - v25, a1, a11);
  v27 = (uint64_t)&v26[TupleTypeMetadata[12]];
  v43 = *(void (**)(void))(*(_QWORD *)(a12 - 8) + 16);
  v41 = v27;
  v43();
  v28 = *(void (**)(void))(*(_QWORD *)(a13 - 8) + 16);
  v45 = &v26[TupleTypeMetadata[16]];
  v28();
  v29 = (uint64_t)&v26[TupleTypeMetadata[20]];
  v42 = a14;
  v30 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v46 = v29;
  v30();
  v31 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v47 = &v26[TupleTypeMetadata[24]];
  v31();
  v44(v24, (uint64_t)v49, a11);
  v49 = &v24[TupleTypeMetadata[12]];
  v50 = a12;
  v43();
  v48 = &v24[TupleTypeMetadata[16]];
  v52 = a13;
  v28();
  v32 = v42;
  v33 = (uint64_t)&v24[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v30)(v33, v51, v42);
  v34 = v54;
  v35 = (uint64_t)&v24[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v31)(v35, v53, a15);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v34 + 8) + 8))(v26, v24, a11) & 1) != 0)
    v36 = >= infix<A, B, C, D>(_:_:)(v41, (uint64_t)v45, v46, (uint64_t)v47, (uint64_t)v49, (uint64_t)v48, v33, v35, v50, v52, v32, a15, a17, a18, a19, a20);
  else
    v36 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v34 + 32))(v26, v24, a11, v34);
  v37 = v36;
  v38 = *(void (**)(char *, int *))(v55 + 8);
  v38(v24, TupleTypeMetadata);
  v38(v26, TupleTypeMetadata);
  return v37 & 1;
}

uint64_t == infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  int *TupleTypeMetadata;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  void (*v35)(void);
  uint64_t v36;
  void (*v37)(void);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  void (*v43)(char *, int *);
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(void);
  void (*v51)(char *, uint64_t, uint64_t);
  uint64_t v52;
  void (*v53)(void);
  void (*v54)(void);
  uint64_t v55;
  char *v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD v66[7];

  v56 = (char *)a5;
  v57 = a6;
  v54 = a3;
  v55 = a4;
  v52 = a18;
  v53 = a2;
  v63 = a12;
  v64 = a19;
  v61 = a8;
  v62 = a11;
  v59 = a7;
  v60 = a10;
  v58 = (char *)a9;
  v66[0] = a13;
  v66[1] = a14;
  v66[2] = a15;
  v66[3] = a16;
  v66[4] = a17;
  v66[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v66, 0, 0);
  v65 = *((_QWORD *)TupleTypeMetadata - 1);
  v26 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v28 = (char *)&v45 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v45 - v29;
  v51 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a13 - 8) + 16);
  v51((char *)&v45 - v29, a1, a13);
  v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  v50 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v48 = v31;
  v50();
  v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  v53 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v47 = v32;
  v53();
  v33 = &v30[TupleTypeMetadata[20]];
  v54 = *(void (**)(void))(*(_QWORD *)(a16 - 8) + 16);
  v46 = v33;
  v54();
  v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  v49 = a17;
  v35 = *(void (**)(void))(*(_QWORD *)(a17 - 8) + 16);
  v55 = v34;
  v35();
  v36 = v52;
  v37 = *(void (**)(void))(*(_QWORD *)(v52 - 8) + 16);
  v56 = &v30[TupleTypeMetadata[28]];
  v37();
  v51(v28, v59, a13);
  v51 = (void (*)(char *, uint64_t, uint64_t))&v28[TupleTypeMetadata[12]];
  v57 = a14;
  v50();
  v50 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  v59 = a15;
  v53();
  v38 = v36;
  v58 = &v28[TupleTypeMetadata[20]];
  v61 = a16;
  v54();
  v39 = v49;
  v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v62, v49);
  v41 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v41, v63, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v64 + 8))(v30, v28, a13) & 1) != 0)
    v42 = == infix<A, B, C, D, E>(_:_:)(v48, v47, v46, v55, (uint64_t)v56, (char *)v51, (uint64_t)v50, (uint64_t)v58, v40, v41, v57, v59, v61, v39, v38, a20, a21, a22, a23,
            a24);
  else
    v42 = 0;
  v43 = *(void (**)(char *, int *))(v65 + 8);
  v43(v28, TupleTypeMetadata);
  v43(v30, TupleTypeMetadata);
  return v42 & 1;
}

uint64_t != infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  int *TupleTypeMetadata;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  void (*v35)(void);
  uint64_t v36;
  void (*v37)(void);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  void (*v43)(char *, int *);
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void (*v50)(void);
  void (*v51)(char *, uint64_t, uint64_t);
  uint64_t v52;
  void (*v53)(void);
  void (*v54)(void);
  uint64_t v55;
  char *v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD v66[7];

  v56 = (char *)a5;
  v57 = a6;
  v54 = a3;
  v55 = a4;
  v52 = a18;
  v53 = a2;
  v63 = a12;
  v64 = a19;
  v61 = a8;
  v62 = a11;
  v59 = a7;
  v60 = a10;
  v58 = (char *)a9;
  v66[0] = a13;
  v66[1] = a14;
  v66[2] = a15;
  v66[3] = a16;
  v66[4] = a17;
  v66[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v66, 0, 0);
  v65 = *((_QWORD *)TupleTypeMetadata - 1);
  v26 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v28 = (char *)&v45 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v45 - v29;
  v51 = *(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(a13 - 8) + 16);
  v51((char *)&v45 - v29, a1, a13);
  v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  v50 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v48 = v31;
  v50();
  v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  v53 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v47 = v32;
  v53();
  v33 = &v30[TupleTypeMetadata[20]];
  v54 = *(void (**)(void))(*(_QWORD *)(a16 - 8) + 16);
  v46 = v33;
  v54();
  v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  v49 = a17;
  v35 = *(void (**)(void))(*(_QWORD *)(a17 - 8) + 16);
  v55 = v34;
  v35();
  v36 = v52;
  v37 = *(void (**)(void))(*(_QWORD *)(v52 - 8) + 16);
  v56 = &v30[TupleTypeMetadata[28]];
  v37();
  v51(v28, v59, a13);
  v51 = (void (*)(char *, uint64_t, uint64_t))&v28[TupleTypeMetadata[12]];
  v57 = a14;
  v50();
  v50 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  v59 = a15;
  v53();
  v38 = v36;
  v58 = &v28[TupleTypeMetadata[20]];
  v61 = a16;
  v54();
  v39 = v49;
  v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v62, v49);
  v41 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v41, v63, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(v64 + 8))(v30, v28, a13) & 1) != 0)
    v42 = != infix<A, B, C, D, E>(_:_:)(v48, v47, v46, v55, (uint64_t)v56, (char *)v51, (uint64_t)v50, (uint64_t)v58, v40, v41, v57, v59, v61, v39, v38, a20, a21, a22, a23,
            a24);
  else
    v42 = 1;
  v43 = *(void (**)(char *, int *))(v65 + 8);
  v43(v28, TupleTypeMetadata);
  v43(v30, TupleTypeMetadata);
  return v42 & 1;
}

uint64_t < infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  int *TupleTypeMetadata;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(void);
  uint64_t v36;
  void (*v37)(void);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  char v44;
  void (*v45)(char *, int *);
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void (*v52)(void);
  char *v53;
  uint64_t v54;
  void (*v55)(void);
  void (*v56)(void);
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[7];

  v61 = a7;
  v58 = (char *)a5;
  v59 = a6;
  v56 = a3;
  v57 = a4;
  v54 = a18;
  v55 = a2;
  v65 = a12;
  v66 = a19;
  v63 = a8;
  v64 = a11;
  v62 = a10;
  v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v68, 0, 0);
  v67 = *((_QWORD *)TupleTypeMetadata - 1);
  v26 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v47 - v29;
  v53 = *(char **)(*(_QWORD *)(a13 - 8) + 16);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  v52 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v50 = v31;
  v52();
  v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  v55 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v49 = v32;
  v55();
  v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  v56 = *(void (**)(void))(*(_QWORD *)(a16 - 8) + 16);
  v48 = v33;
  v56();
  v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  v51 = a17;
  v35 = *(void (**)(void))(*(_QWORD *)(a17 - 8) + 16);
  v57 = v34;
  v35();
  v36 = v54;
  v37 = *(void (**)(void))(*(_QWORD *)(v54 - 8) + 16);
  v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  v53 = &v28[TupleTypeMetadata[12]];
  v59 = a14;
  v52();
  v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  v61 = a15;
  v55();
  v38 = v36;
  v60 = &v28[TupleTypeMetadata[20]];
  v63 = a16;
  v56();
  v39 = v51;
  v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  v41 = v66;
  v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v41 + 8) + 8))(v30, v28, a13) & 1) != 0)
    v43 = < infix<A, B, C, D, E>(_:_:)(v50, v49, v48, v57, (uint64_t)v58, (uint64_t)v53, (uint64_t)v52, (uint64_t)v60, v40, v42, v59, v61, v63, v39, v38, a20, a21, a22, a23,
            a24);
  else
    v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 16))(v30, v28, a13, v41);
  v44 = v43;
  v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t <= infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  int *TupleTypeMetadata;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(void);
  uint64_t v36;
  void (*v37)(void);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  char v44;
  void (*v45)(char *, int *);
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void (*v52)(void);
  char *v53;
  uint64_t v54;
  void (*v55)(void);
  void (*v56)(void);
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[7];

  v61 = a7;
  v58 = (char *)a5;
  v59 = a6;
  v56 = a3;
  v57 = a4;
  v54 = a18;
  v55 = a2;
  v65 = a12;
  v66 = a19;
  v63 = a8;
  v64 = a11;
  v62 = a10;
  v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v68, 0, 0);
  v67 = *((_QWORD *)TupleTypeMetadata - 1);
  v26 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v47 - v29;
  v53 = *(char **)(*(_QWORD *)(a13 - 8) + 16);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  v52 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v50 = v31;
  v52();
  v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  v55 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v49 = v32;
  v55();
  v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  v56 = *(void (**)(void))(*(_QWORD *)(a16 - 8) + 16);
  v48 = v33;
  v56();
  v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  v51 = a17;
  v35 = *(void (**)(void))(*(_QWORD *)(a17 - 8) + 16);
  v57 = v34;
  v35();
  v36 = v54;
  v37 = *(void (**)(void))(*(_QWORD *)(v54 - 8) + 16);
  v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  v53 = &v28[TupleTypeMetadata[12]];
  v59 = a14;
  v52();
  v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  v61 = a15;
  v55();
  v38 = v36;
  v60 = &v28[TupleTypeMetadata[20]];
  v63 = a16;
  v56();
  v39 = v51;
  v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  v41 = v66;
  v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v41 + 8) + 8))(v30, v28, a13) & 1) != 0)
    v43 = <= infix<A, B, C, D, E>(_:_:)(v50, v49, v48, v57, (uint64_t)v58, (uint64_t)v53, (uint64_t)v52, (uint64_t)v60, v40, v42, v59, v61, v63, v39, v38, a20, a21, a22, a23,
            a24);
  else
    v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 24))(v30, v28, a13, v41);
  v44 = v43;
  v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t > infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  int *TupleTypeMetadata;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(void);
  uint64_t v36;
  void (*v37)(void);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  char v44;
  void (*v45)(char *, int *);
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void (*v52)(void);
  char *v53;
  uint64_t v54;
  void (*v55)(void);
  void (*v56)(void);
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[7];

  v61 = a7;
  v58 = (char *)a5;
  v59 = a6;
  v56 = a3;
  v57 = a4;
  v54 = a18;
  v55 = a2;
  v65 = a12;
  v66 = a19;
  v63 = a8;
  v64 = a11;
  v62 = a10;
  v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v68, 0, 0);
  v67 = *((_QWORD *)TupleTypeMetadata - 1);
  v26 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v47 - v29;
  v53 = *(char **)(*(_QWORD *)(a13 - 8) + 16);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  v52 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v50 = v31;
  v52();
  v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  v55 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v49 = v32;
  v55();
  v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  v56 = *(void (**)(void))(*(_QWORD *)(a16 - 8) + 16);
  v48 = v33;
  v56();
  v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  v51 = a17;
  v35 = *(void (**)(void))(*(_QWORD *)(a17 - 8) + 16);
  v57 = v34;
  v35();
  v36 = v54;
  v37 = *(void (**)(void))(*(_QWORD *)(v54 - 8) + 16);
  v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  v53 = &v28[TupleTypeMetadata[12]];
  v59 = a14;
  v52();
  v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  v61 = a15;
  v55();
  v38 = v36;
  v60 = &v28[TupleTypeMetadata[20]];
  v63 = a16;
  v56();
  v39 = v51;
  v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  v41 = v66;
  v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v41 + 8) + 8))(v30, v28, a13) & 1) != 0)
    v43 = > infix<A, B, C, D, E>(_:_:)(v50, v49, v48, v57, (uint64_t)v58, (uint64_t)v53, (uint64_t)v52, (uint64_t)v60, v40, v42, v59, v61, v63, v39, v38, a20, a21, a22, a23,
            a24);
  else
    v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 40))(v30, v28, a13, v41);
  v44 = v43;
  v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t >= infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, void (*a2)(void), void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  int *TupleTypeMetadata;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(void);
  uint64_t v36;
  void (*v37)(void);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  char v44;
  void (*v45)(char *, int *);
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void (*v52)(void);
  char *v53;
  uint64_t v54;
  void (*v55)(void);
  void (*v56)(void);
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[7];

  v61 = a7;
  v58 = (char *)a5;
  v59 = a6;
  v56 = a3;
  v57 = a4;
  v54 = a18;
  v55 = a2;
  v65 = a12;
  v66 = a19;
  v63 = a8;
  v64 = a11;
  v62 = a10;
  v60 = (char *)a9;
  v68[0] = a13;
  v68[1] = a14;
  v68[2] = a15;
  v68[3] = a16;
  v68[4] = a17;
  v68[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v68, 0, 0);
  v67 = *((_QWORD *)TupleTypeMetadata - 1);
  v26 = MEMORY[0x1E0C80A78](TupleTypeMetadata);
  v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v26);
  v30 = (char *)&v47 - v29;
  v53 = *(char **)(*(_QWORD *)(a13 - 8) + 16);
  ((void (*)(char *, uint64_t, uint64_t))v53)((char *)&v47 - v29, a1, a13);
  v31 = (uint64_t)&v30[TupleTypeMetadata[12]];
  v52 = *(void (**)(void))(*(_QWORD *)(a14 - 8) + 16);
  v50 = v31;
  v52();
  v32 = (uint64_t)&v30[TupleTypeMetadata[16]];
  v55 = *(void (**)(void))(*(_QWORD *)(a15 - 8) + 16);
  v49 = v32;
  v55();
  v33 = (uint64_t)&v30[TupleTypeMetadata[20]];
  v56 = *(void (**)(void))(*(_QWORD *)(a16 - 8) + 16);
  v48 = v33;
  v56();
  v34 = (uint64_t)&v30[TupleTypeMetadata[24]];
  v51 = a17;
  v35 = *(void (**)(void))(*(_QWORD *)(a17 - 8) + 16);
  v57 = v34;
  v35();
  v36 = v54;
  v37 = *(void (**)(void))(*(_QWORD *)(v54 - 8) + 16);
  v58 = &v30[TupleTypeMetadata[28]];
  v37();
  ((void (*)(char *, uint64_t, uint64_t))v53)(v28, v61, a13);
  v53 = &v28[TupleTypeMetadata[12]];
  v59 = a14;
  v52();
  v52 = (void (*)(void))&v28[TupleTypeMetadata[16]];
  v61 = a15;
  v55();
  v38 = v36;
  v60 = &v28[TupleTypeMetadata[20]];
  v63 = a16;
  v56();
  v39 = v51;
  v40 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v35)(v40, v64, v51);
  v41 = v66;
  v42 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v37)(v42, v65, v38);
  if (((*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v41 + 8) + 8))(v30, v28, a13) & 1) != 0)
    v43 = >= infix<A, B, C, D, E>(_:_:)(v50, v49, v48, v57, (uint64_t)v58, (uint64_t)v53, (uint64_t)v52, (uint64_t)v60, v40, v42, v59, v61, v63, v39, v38, a20, a21, a22, a23,
            a24);
  else
    v43 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v41 + 32))(v30, v28, a13, v41);
  v44 = v43;
  v45 = *(void (**)(char *, int *))(v67 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t SIMD2._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage, a2);
}

uint64_t SIMD2._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t (*SIMD2._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD2.scalarCount.getter()
{
  return 2;
}

uint64_t key path getter for SIMD2.subscript(_:) : <A>SIMD2<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v8)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v9;

  v3 = *a2;
  if ((unint64_t)*a2 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  v4 = *(const char **)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD2.subscript(_:) : <A>SIMD2<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  size_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(char *, unint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t v17;

  v4 = *(_QWORD *)(a4 + a3 - 16);
  v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v17 - v6;
  v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x2CuLL, 0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD2.subscript.modify(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD2.init(_:_:)(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  size_t v8;
  uint64_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v13)(char *, uint64_t, unint64_t, unint64_t);
  uint64_t v15;

  v8 = *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64);
  MEMORY[0x1E0C80A78](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v9, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v8);
  v13 = *(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v13((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v8);
  return v13((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD2.x.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

uint64_t key path getter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

uint64_t key path setter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

uint64_t SIMD2.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

void (*SIMD2.x.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(_QWORD, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(0, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

void SIMD2.x.modify(uint64_t a1, uint64_t a2)
{
  SIMD2.x.modify(a1, a2, 0);
}

uint64_t SIMD2.y.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

uint64_t key path getter for SIMD2.y : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

uint64_t key path setter for SIMD2.y : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

uint64_t SIMD2.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

void (*SIMD2.y.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(1, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

void SIMD2.y.modify(uint64_t a1, uint64_t a2)
{
  SIMD2.x.modify(a1, a2, 1);
}

Swift::Int SIMD2.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD2<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD2<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD2<A>(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD2<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x2CuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD2<A>(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD2<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD2<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD2<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD2<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD, _QWORD, _QWORD);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t);
  const char *v23;
  unint64_t AssociatedTypeWitness;
  char *v25;
  unint64_t AssociatedConformanceWitness;
  void (*v27)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v28;
  void (*v29)(char *, uint64_t);
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;

  v3 = a3;
  v44 = a2;
  v4 = a1;
  v39 = *(_QWORD *)(a3 + 16);
  v5 = MEMORY[0x1E0C80A78](a1);
  v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = MEMORY[0x1E0C80A78](v5);
  v42 = (char *)&v37 - v8;
  v9 = MEMORY[0x1E0C80A78](v7);
  v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v37 - v13;
  v15 = 0;
  v16 = 1;
  v18 = v17;
  v19 = *(void (**)(_QWORD, _QWORD, _QWORD))(v17 + 16);
  v40 = v12;
  v41 = v20;
  v37 = v19;
  v38 = v17;
  v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      v23 = *(const char **)(v3 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
      v25 = v11;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
      v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      v28 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      v30 = v28;
      v19 = v37;
      v31 = AssociatedConformanceWitness;
      v11 = v25;
      v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      v32 = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      v33 = (uint64_t)v23;
      v4 = v40;
      v34 = swift_getAssociatedConformanceWitness(v33, v21, v32, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      v35 = swift_getAssociatedConformanceWitness(v34, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v18 = v38;
      v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35 + 8) + 8))(v42, v43, v21);
    }
    else
    {
      v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      v16 = 0;
    }
    if (++v15 == 2)
      break;
    v19(v14, v4, v3);
  }
  return v16 & 1;
}

uint64_t SIMD2<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v18)(unint64_t);
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void (*v22)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  void (*v29)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  void (*v40)(_QWORD, unint64_t *, unint64_t);
  unint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v46 = a4;
  v47 = a6;
  v48 = a1;
  v42 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v44 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v43 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v15, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v18 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 48);
  v41 = AssociatedTypeWitness;
  v19 = AssociatedConformanceWitness;
  v18(AssociatedTypeWitness);
  v45 = a7;
  v20 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  v39 = a3;
  v21 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, v20, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v40 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v21 + 56);
  v22 = v40;
  v23 = swift_checkMetadataState(0, v20);
  v24 = v44;
  v22(0, v23, v21);
  v25 = *(_QWORD *)(v46 + 8);
  v26 = *(_QWORD *)(v47 + 8);
  v46 = *(_QWORD *)(v25 + 96);
  v47 = v26;
  v27 = v43;
  ((void (*)(char *, uint64_t))v46)(v24, a3);
  v28 = v19;
  v38 = v19;
  v29 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(v19 + 64);
  v30 = v41;
  v29(v27, 0, v41, v28);
  v31 = swift_checkMetadataState(0, v20);
  v32 = v48;
  v40(1, v31, v21);
  v33 = v39;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v46)(v24, v39, v47, a2, v25);
  v29(v27, 1, v30, v38);
  v35 = type metadata accessor for SIMD2(0, v33, (uint64_t)v45, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v35 - 8) + 8))(v32, v35);
}

uint64_t SIMD2<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v18)(unint64_t);
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void (*v22)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  void (*v29)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  void (*v40)(_QWORD, unint64_t *, unint64_t);
  unint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v46 = a4;
  v47 = a6;
  v48 = a1;
  v42 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v44 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v43 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v15, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v18 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 48);
  v41 = AssociatedTypeWitness;
  v19 = AssociatedConformanceWitness;
  v18(AssociatedTypeWitness);
  v45 = a7;
  v20 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  v39 = a3;
  v21 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, v20, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v40 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v21 + 56);
  v22 = v40;
  v23 = swift_checkMetadataState(0, v20);
  v24 = v44;
  v22(0, v23, v21);
  v25 = *(_QWORD *)(v46 + 8);
  v26 = *(_QWORD *)(v47 + 8);
  v46 = *(_QWORD *)(v25 + 104);
  v47 = v26;
  v27 = v43;
  ((void (*)(char *, uint64_t))v46)(v24, a3);
  v28 = v19;
  v38 = v19;
  v29 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(v19 + 64);
  v30 = v41;
  v29(v27, 0, v41, v28);
  v31 = swift_checkMetadataState(0, v20);
  v32 = v48;
  v40(1, v31, v21);
  v33 = v39;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v46)(v24, v39, v47, a2, v25);
  v29(v27, 1, v30, v38);
  v35 = type metadata accessor for SIMD2(0, v33, (uint64_t)v45, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v35 - 8) + 8))(v32, v35);
}

uint64_t SIMD2<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  unint64_t AssociatedTypeWitness;
  void (*v21)(unint64_t, unint64_t);
  unint64_t v22;
  unint64_t v23;
  void (*v24)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  void (*v30)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  void (*v37)(uint64_t, uint64_t, uint64_t);
  uint64_t v38;
  void (*v39)(_QWORD, unint64_t *, unint64_t);
  uint64_t v40;
  char *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t AssociatedConformanceWitness;
  char *v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;

  v48 = a7;
  v43 = a5;
  v44 = a3;
  v50 = a2;
  v38 = a1;
  v40 = a9;
  v13 = MEMORY[0x1E0C80A78](a1);
  v46 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v13);
  v47 = (char *)&v37 - v16;
  MEMORY[0x1E0C80A78](v15);
  v41 = (char *)&v37 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v21 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v49 = AssociatedTypeWitness;
  v21(AssociatedTypeWitness, AssociatedConformanceWitness);
  v42 = a8;
  v22 = swift_getAssociatedTypeWitness(255, a8, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  v23 = swift_getAssociatedConformanceWitness((uint64_t)a8, a4, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v39 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v23 + 56);
  v24 = v39;
  v25 = swift_checkMetadataState(0, v22);
  v24(0, v25, v23);
  v26 = v47;
  v27 = v48;
  v28 = *(_QWORD *)(v48 + 16);
  v37 = *(void (**)(uint64_t, uint64_t, uint64_t))(v28 + 304);
  v37(v50, a4, v28);
  v43 = *(_QWORD *)(*(_QWORD *)(v43 + 8) + 80);
  v29 = v41;
  ((void (*)(char *, uint64_t, uint64_t))v43)(v26, a4, v27);
  v30 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v30)(v29, 0, v49);
  v31 = swift_checkMetadataState(0, v22);
  v32 = v38;
  v39(1, v31, v23);
  v33 = v47;
  v37(v50, a4, v28);
  ((void (*)(char *, uint64_t, uint64_t))v43)(v33, a4, v48);
  v30(v29, 1, v49, AssociatedConformanceWitness);
  v35 = type metadata accessor for SIMD2(0, a4, (uint64_t)v42, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v35 - 8) + 8))(v32, v35);
}

uint64_t SIMD2.debugDescription.getter(uint64_t a1)
{
  uint64_t v1;
  Class *v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  const void *v37;
  unint64_t v38;
  BOOL v39;
  int64_t v40;
  int64_t v41;
  char v42;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  Swift::String::Index v52;
  Swift::String::Index v53;
  Swift::String::Index v54;
  Swift::String::Index v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char v64;
  unint64_t v65;
  unint64_t v66;
  char *v67;
  size_t v68;
  uint64_t v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  char v74;
  size_t v75;
  uint64_t v76;
  char v77;
  uint64_t v78;
  unint64_t v79;
  uint8x16_t *TypeName;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  size_t v84;
  uint64_t *v85;
  uint8x16_t *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t countAndFlagsBits;
  unint64_t object;
  char v91;
  uint64_t v92;
  uint8x16_t *v93;
  uint8x16_t *v94;
  uint8x16_t *v95;
  uint64_t v96;
  unsigned __int8 v97;
  int v98;
  unsigned int v99;
  unsigned int v100;
  _QWORD *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  char *v119;
  size_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  int64x2_t v132;
  int8x16_t v133;
  int8x16_t v134;
  int64x2_t v135;
  int64x2_t v136;
  int64x2_t v137;
  int64x2_t v138;
  uint8x8_t *v139;
  int8x16_t v140;
  unint64_t v141;
  int64x2_t v142;
  int8x16_t v143;
  int8x16_t v144;
  uint8x8_t v145;
  uint16x8_t v146;
  uint32x4_t v147;
  uint64x2_t v148;
  uint64x2_t v149;
  uint64x2_t v150;
  uint32x4_t v151;
  uint64x2_t v152;
  int8x16_t v153;
  uint16x8_t v154;
  int8x16_t v155;
  uint16x8_t v156;
  int8x16_t v157;
  int8x16_t v158;
  int8x8_t v159;
  int8x16_t v160;
  int8x8_t v161;
  uint64x2_t v162;
  int8x16_t v163;
  int8x16_t v164;
  int8x16_t v165;
  int8x16_t v166;
  unsigned __int8 *v167;
  unint64_t v168;
  unsigned int v169;
  unint64_t v170;
  int8x8_t v171;
  unint64_t v172;
  unint64_t v173;
  int64x2_t v174;
  int8x16_t v175;
  int8x16_t v176;
  int64x2_t v177;
  int64x2_t v178;
  int64x2_t v179;
  int64x2_t v180;
  uint8x8_t *v181;
  int8x16_t v182;
  unint64_t v183;
  int64x2_t v184;
  int8x16_t v185;
  int8x16_t v186;
  uint8x8_t v187;
  uint16x8_t v188;
  uint32x4_t v189;
  uint64x2_t v190;
  uint64x2_t v191;
  uint64x2_t v192;
  uint32x4_t v193;
  uint64x2_t v194;
  int8x16_t v195;
  uint8x16_t *v196;
  int64x2_t v197;
  int64x2_t v198;
  int64x2_t v199;
  int64x2_t v200;
  int64x2_t v201;
  int64x2_t v202;
  int8x16_t v203;
  int64x2_t v204;
  int64x2_t v205;
  int8x16_t v206;
  int8x16_t v207;
  int64x2_t v208;
  unint64_t v209;
  int8x16_t v210;
  int8x16_t v211;
  int8x16_t v212;
  int8x16_t v213;
  int8x16_t v214;
  int8x16_t v215;
  uint8x16_t v216;
  uint16x8_t v217;
  uint32x4_t v218;
  uint64x2_t v219;
  uint64x2_t v220;
  uint16x8_t v221;
  uint32x4_t v222;
  uint64x2_t v223;
  uint64x2_t v224;
  uint64x2_t v225;
  uint32x4_t v226;
  uint64x2_t v227;
  uint32x4_t v228;
  uint64x2_t v229;
  uint64x2_t v230;
  int8x16_t v231;
  uint64_t v232;
  unsigned __int8 *v233;
  unsigned int v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  uint64_t v239;
  unint64_t v240;
  uint64_t v241;
  uint64_t v242;
  char *v243;
  uint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  const char *v248;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v251)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v252;
  _QWORD *v253;
  uint64_t *v254;
  swift::SwiftError **v255;
  _QWORD *DynamicType;
  uint64_t *v257;
  Class *v258;
  uint64_t v259;
  uint64_t v260;
  unint64_t v261;
  unint64_t v262;
  uint64_t v263;
  unint64_t v264;
  uint64_t v265;
  uint64_t v266;
  char *v267;
  uint64_t *v268;
  void *v269;
  uint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t v274;
  const void *v275;
  _QWORD *v276;
  uint64_t *v277;
  swift::SwiftError **v278;
  _QWORD *v279;
  uint64_t *v280;
  Class *v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  unint64_t v285;
  uint64_t v286;
  unint64_t v287;
  uint64_t v288;
  uint64_t v289;
  char *v290;
  uint64_t *v291;
  void *v292;
  uint64_t v293;
  unint64_t v294;
  unint64_t v295;
  unint64_t v296;
  uint64_t *v298;
  Class *v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t *v302;
  Class *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t *v306;
  Class *v307;
  uint64_t *v308;
  Class *v309;
  uint64_t *v310;
  Class *v311;
  uint64_t *v312;
  Class *v313;
  size_t v314;
  char v315;
  unint64_t v316;
  unint64_t v317;
  unint64_t v318;
  unint64_t v319;
  unint64_t v320;
  unint64_t v321;
  char v322;
  uint64_t v323;
  unint64_t v324;
  unint64_t v325;
  unint64_t v326;
  unint64_t v327;
  _QWORD *v328;
  void *v329;
  uint64_t v330;
  _QWORD *v331;
  void *v332;
  uint64_t v333;
  Swift::Int v334;
  unint64_t v335;
  uint64_t v336;
  size_t v337;
  Class *v338;
  uint64_t *v339;
  uint64_t *v340;
  uint64_t *v341;
  uint64_t *v342;
  uint64_t *v343;
  uint64_t *v344;
  uint64_t *v345;
  uint64_t *v346;
  uint64_t *v347;
  char *v348;
  char *v349;
  Swift::String v350;
  uint64_t *v351;
  uint64_t v352;
  __int128 v353;
  __int128 v354;
  uint64_t v355;
  unint64_t v356;
  unint64_t v357;
  size_t v358[2];

  v1 = a1;
  v2 = *(Class **)(a1 + 16);
  v3 = *((_QWORD *)*(v2 - 1) + 8);
  v4 = MEMORY[0x1E0C80A78](a1);
  v340 = (uint64_t *)((char *)&v336 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  v5 = MEMORY[0x1E0C80A78](v4);
  v342 = (uint64_t *)((char *)&v336 - v6);
  v7 = MEMORY[0x1E0C80A78](v5);
  v344 = (uint64_t *)((char *)&v336 - v8);
  v9 = MEMORY[0x1E0C80A78](v7);
  v346 = (uint64_t *)((char *)&v336 - v10);
  v11 = MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v336 - v12;
  v14 = MEMORY[0x1E0C80A78](v11);
  v339 = (uint64_t *)((char *)&v336 - v15);
  v16 = MEMORY[0x1E0C80A78](v14);
  v341 = (uint64_t *)((char *)&v336 - v17);
  v18 = MEMORY[0x1E0C80A78](v16);
  v343 = (uint64_t *)((char *)&v336 - v19);
  v20 = MEMORY[0x1E0C80A78](v18);
  v345 = (uint64_t *)((char *)&v336 - v21);
  v22 = MEMORY[0x1E0C80A78](v20);
  v347 = (uint64_t *)((char *)&v336 - v23);
  MEMORY[0x1E0C80A78](v22);
  v349 = (char *)&v336 - v24;
  v25 = specialized static String._createEmpty(withInitialCapacity:)(17);
  v29 = v25;
  v30 = v26;
  v356 = v25;
  v357 = v26;
  v31 = HIBYTE(v26) & 0xF;
  if ((v26 & 0x2000000000000000) != 0)
    v32 = HIBYTE(v26) & 0xF;
  else
    v32 = v25 & 0xFFFFFFFFFFFFLL;
  v348 = v13;
  if (!v32 && (v25 & ~v26 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v26);
    v356 = 0x3C32444D4953;
    v357 = 0xE600000000000000;
    goto LABEL_40;
  }
  if ((v26 & 0x2000000000000000) == 0 || v31 > 9)
  {
    swift_bridgeObjectRetain_n(0xE600000000000000, 6, v27, v28);
    if ((v30 & 0x1000000000000000) != 0)
    {
      v334 = String.UTF8View._foreignCount()();
      v40 = v334 + 6;
      if (!__OFADD__(v334, 6))
      {
LABEL_13:
        if ((v29 & ~v30 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v30 & 0xFFFFFFFFFFFFFFFLL))
        {
          v41 = _StringGuts.nativeUnusedCapacity.getter(v29, v30);
          if ((v42 & 1) != 0)
          {
            v335 = 258;
            goto LABEL_257;
          }
          v44 = (v30 & 0x2000000000000000) == 0 && v41 > 5;
          if (v40 <= 15 && !v44)
          {
LABEL_24:
            v45 = v1;
            swift_bridgeObjectRelease_n(0xE600000000000000, 5);
            swift_bridgeObjectRetain(v30, v46, v47, v48);
            v49 = _StringGuts._convertedToSmall()(v29, v30);
            v51 = v50;
            swift_bridgeObjectRelease(v30);
            v52._rawBits = 1;
            v53._rawBits = 393217;
            v54._rawBits = _StringGuts.validateScalarRange(_:)(v52, v53, 0x3C32444D4953uLL, 0xE600000000000000);
            if (v54._rawBits < 0x10000)
              v54._rawBits |= 3;
            v56 = specialized String.init(_:)(v54, v55, 0x3C32444D4953uLL, 0xE600000000000000);
            v58 = v57;
            swift_bridgeObjectRelease(0xE600000000000000);
            v59 = _StringGuts._convertedToSmall()(v56, v58);
            v61 = v60;
            swift_bridgeObjectRelease(v58);
            v62 = specialized _SmallString.init(_:appending:)(v49, v51, v59, v61);
            if ((v64 & 1) == 0)
            {
              v65 = v62;
              v66 = v63;
              swift_bridgeObjectRelease(v30);
              swift_bridgeObjectRelease(0xE600000000000000);
              v356 = v65;
              v357 = v66;
              v37 = v349;
              v1 = v45;
              goto LABEL_41;
            }
            v335 = 266;
LABEL_257:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v335, 0);
          }
        }
        else if (v40 <= 15)
        {
          goto LABEL_24;
        }
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v40, 6);
        swift_bridgeObjectRelease_n(0xE600000000000000, 6);
        v350 = (Swift::String)xmmword_1816ABF50;
        v67 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 6, (uint64_t)&v350, 6);
        _StringGuts.appendInPlace(_:isASCII:)(v67, v68, 1);
        swift_bridgeObjectRelease(0xE600000000000000);
LABEL_40:
        v37 = v349;
        goto LABEL_41;
      }
    }
    else
    {
      v39 = __OFADD__(v32, 6);
      v40 = v32 + 6;
      if (!v39)
        goto LABEL_13;
    }
    __break(1u);
    goto LABEL_253;
  }
  v33 = 8 * HIBYTE(v26);
  v34 = (-255 << (v33 & 0x38)) - 1;
  v35 = 83 << (v33 & 0x38);
  v36 = v31 + 1;
  if (v31 >= 8)
  {
    v38 = v35 | v34 & v26;
    v37 = v349;
    goto LABEL_31;
  }
  v29 = v35 | v34 & v25;
  v37 = v349;
  if (v31 == 7)
  {
    v36 = 8;
    v38 = v26;
LABEL_31:
    v69 = (73 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v38;
    v70 = v31 + 2;
LABEL_32:
    v71 = (77 << (8 * (v70 & 7u))) | ((-255 << (8 * (v70 & 7u))) - 1) & v69;
    v72 = v31 + 3;
LABEL_33:
    v73 = (68 << (8 * (v72 & 7u))) | ((-255 << (8 * (v72 & 7u))) - 1) & v71;
    v74 = v31 + 4;
LABEL_34:
    v75 = v3;
    v76 = (50 << (8 * (v74 & 7u))) | ((-255 << (8 * (v74 & 7u))) - 1) & v73;
    v77 = v31 + 5;
    goto LABEL_35;
  }
  v29 = (73 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v29;
  if (v31 >= 6)
  {
    v70 = 8;
    v69 = v26;
    goto LABEL_32;
  }
  v29 = (77 << ((v33 + 16) & 0x38)) | ((-255 << ((v33 + 16) & 0x38)) - 1) & v29;
  if (v31 == 5)
  {
    v72 = 8;
    v71 = v26;
    goto LABEL_33;
  }
  v29 = (68 << ((v33 + 24) & 0x38)) | ((-255 << ((v33 + 24) & 0x38)) - 1) & v29;
  if (v31 >= 4)
  {
    v74 = 8;
    v73 = v26;
    goto LABEL_34;
  }
  v29 = (50 << ((v33 + 32) & 0x38)) | ((-255 << ((v33 + 32) & 0x38)) - 1) & v29;
  v75 = v3;
  if (v31 != 3)
  {
    v29 = (60 << ((v33 + 40) & 0x38)) | ((-255 << ((v33 + 40) & 0x38)) - 1) & v29;
    v78 = v26;
    goto LABEL_36;
  }
  v77 = 8;
  v76 = v26;
LABEL_35:
  v78 = (60 << (8 * (v77 & 7u))) | ((-255 << (8 * (v77 & 7u))) - 1) & v76;
LABEL_36:
  swift_bridgeObjectRelease(v26);
  swift_bridgeObjectRelease(0xE600000000000000);
  v79 = 0xA000000000000000;
  if (!(v29 & 0x8080808080808080 | v78 & 0x80808080808080))
    v79 = 0xE000000000000000;
  v356 = v29;
  v357 = (v79 & 0xFF00000000000000 | (v31 << 56) | v78 & 0xFFFFFFFFFFFFFFLL) + 0x600000000000000;
  v3 = v75;
LABEL_41:
  TypeName = (uint8x16_t *)swift_getTypeName(v2, 0);
  if (v81 < 0)
    goto LABEL_249;
  v84 = v81;
  if (!v81)
  {
    countAndFlagsBits = 0;
    object = 0xE000000000000000;
    goto LABEL_157;
  }
  v85 = (uint64_t *)TypeName;
  v86 = TypeName;
  if ((v81 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0)
      goto LABEL_63;
    v86 = TypeName + 1;
    while (v86 < (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFF0])
    {
      v87 = v86->i64[0];
      v88 = v86->i64[1];
      ++v86;
      if (((v88 | v87) & 0x8080808080808080) != 0)
        goto LABEL_63;
    }
  }
  if (v86 < (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v86->i64[0] & 0x8080808080808080) != 0)
      goto LABEL_63;
    v86 = (uint8x16_t *)((char *)v86 + 8);
  }
  if (v86 < (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v86->i32[0] & 0x80808080) != 0)
      goto LABEL_63;
    v86 = (uint8x16_t *)((char *)v86 + 4);
  }
  if (v86 >= (uint8x16_t *)&TypeName->i8[v81 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_59:
    if (v86 >= (uint8x16_t *)&TypeName->i8[v81] || (v86->i8[0] & 0x80000000) == 0)
    {
      if (v81 > 15)
      {
        v91 = 1;
LABEL_104:
        object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v81, v81, v91 & 1);
        countAndFlagsBits = *(_QWORD *)(object + 24);
        goto LABEL_157;
      }
LABEL_114:
      v127 = v81 - 8;
      v128 = 8;
      if (v81 < 8)
        v128 = v81;
      if ((v128 & 0x8000000000000000) == 0)
      {
        if (v128 >= 8)
        {
          if (v128 >= 0x10)
          {
            v129 = v128 & 0xFFFFFFFFFFFFFFF0;
            v154 = vmovl_high_u8(*TypeName);
            v155 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v154.i8);
            v156 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            v157 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v156.i8);
            v158 = (int8x16_t)vmovl_high_u16(v154);
            v159 = (int8x8_t)vextq_s8(v158, v158, 8uLL).u64[0];
            v160 = (int8x16_t)vmovl_high_u16(v156);
            v161 = (int8x8_t)vextq_s8(v160, v160, 8uLL).u64[0];
            *(int8x8_t *)v160.i8 = vorr_s8(*(int8x8_t *)v160.i8, *(int8x8_t *)v158.i8);
            v162.i64[0] = v160.u32[0];
            v162.i64[1] = v160.u32[1];
            v163 = (int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1816ABC20);
            *(int8x8_t *)v158.i8 = vorr_s8(*(int8x8_t *)v157.i8, *(int8x8_t *)v155.i8);
            v162.i64[0] = v158.u32[0];
            v162.i64[1] = v158.u32[1];
            v164 = vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1816ABC10), v163);
            *(int8x8_t *)v158.i8 = vorr_s8(v161, v159);
            v162.i64[0] = v158.u32[0];
            v162.i64[1] = v158.u32[1];
            v165 = (int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1816ABC00);
            *(int8x8_t *)v155.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v157, v157, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v155, v155, 8uLL));
            v162.i64[0] = v155.u32[0];
            v162.i64[1] = v155.u32[1];
            v166 = vorrq_s8(v164, vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)xmmword_1816ABBF0), v165));
            countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v166.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v166, v166, 8uLL));
            if (v128 == (v128 & 0xFFFFFFFFFFFFFFF0))
              goto LABEL_135;
            v130 = 8 * v129;
            if ((v128 & 8) == 0)
              goto LABEL_133;
          }
          else
          {
            countAndFlagsBits = 0;
            v130 = 0;
            v129 = 0;
          }
          v131 = v129;
          v132 = vdupq_n_s64(v130);
          v129 = v128 & 0xFFFFFFFFFFFFFFF8;
          v130 = 8 * (v128 & 0xFFFFFFFFFFFFFFF8);
          v133 = 0uLL;
          v134 = (int8x16_t)(unint64_t)countAndFlagsBits;
          v135 = vaddq_s64(v132, (int64x2_t)xmmword_1816ABC00);
          v136 = vaddq_s64(v132, (int64x2_t)xmmword_1816ABC20);
          v137 = vaddq_s64(v132, (int64x2_t)xmmword_1816ABBF0);
          v138 = vaddq_s64(v132, (int64x2_t)xmmword_1816ABC10);
          v139 = (uint8x8_t *)&TypeName->i8[v131];
          v140 = (int8x16_t)vdupq_n_s64(0x38uLL);
          v141 = v131 - (v128 & 0xFFFFFFFFFFFFFFF8);
          v142 = vdupq_n_s64(0x40uLL);
          v143 = 0uLL;
          v144 = 0uLL;
          do
          {
            v145 = *v139++;
            v146 = vmovl_u8(v145);
            v147 = vmovl_high_u16(v146);
            v148.i64[0] = v147.u32[2];
            v148.i64[1] = v147.u32[3];
            v149 = v148;
            v148.i64[0] = v147.u32[0];
            v148.i64[1] = v147.u32[1];
            v150 = v148;
            v151 = vmovl_u16(*(uint16x4_t *)v146.i8);
            v148.i64[0] = v151.u32[2];
            v148.i64[1] = v151.u32[3];
            v152 = v148;
            v148.i64[0] = v151.u32[0];
            v148.i64[1] = v151.u32[1];
            v144 = vorrq_s8((int8x16_t)vshlq_u64(v149, (uint64x2_t)vandq_s8((int8x16_t)v135, v140)), v144);
            v143 = vorrq_s8((int8x16_t)vshlq_u64(v150, (uint64x2_t)vandq_s8((int8x16_t)v136, v140)), v143);
            v133 = vorrq_s8((int8x16_t)vshlq_u64(v152, (uint64x2_t)vandq_s8((int8x16_t)v137, v140)), v133);
            v134 = vorrq_s8((int8x16_t)vshlq_u64(v148, (uint64x2_t)vandq_s8((int8x16_t)v138, v140)), v134);
            v136 = vaddq_s64(v136, v142);
            v137 = vaddq_s64(v137, v142);
            v138 = vaddq_s64(v138, v142);
            v135 = vaddq_s64(v135, v142);
            v141 += 8;
          }
          while (v141);
          v153 = vorrq_s8(vorrq_s8(v134, v143), vorrq_s8(v133, v144));
          countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v153.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v153, v153, 8uLL));
          if (v128 == v129)
          {
LABEL_135:
            if (v81 < 9)
            {
              v171 = 0;
LABEL_154:
              v235 = 0xA000000000000000;
              if (((*(_QWORD *)&v171 | countAndFlagsBits) & 0x8080808080808080) == 0)
                v235 = 0xE000000000000000;
              object = v235 | (v81 << 56) | *(_QWORD *)&v171;
              goto LABEL_157;
            }
            if (v127 < 8)
            {
              v170 = 0;
              v171 = 0;
              v172 = 0;
LABEL_152:
              v232 = v81 - v170 - 8;
              v233 = &TypeName->u8[v170 + 8];
              do
              {
                v234 = *v233++;
                *(_QWORD *)&v171 |= (unint64_t)v234 << (v172 & 0x38);
                v172 += 8;
                --v232;
              }
              while (v232);
              goto LABEL_154;
            }
            if (v127 >= 0x10)
            {
              v196 = (uint8x16_t *)&TypeName->u64[1];
              v170 = v127 & 0xFFFFFFFFFFFFFFF0;
              v197 = (int64x2_t)xmmword_1816ABCA0;
              v198 = (int64x2_t)xmmword_1816ABCB0;
              v199 = (int64x2_t)xmmword_1816ABCC0;
              v200 = (int64x2_t)xmmword_1816ABCD0;
              v201 = (int64x2_t)xmmword_1816ABC00;
              v202 = (int64x2_t)xmmword_1816ABC20;
              v203 = (int8x16_t)vdupq_n_s64(0x38uLL);
              v204 = vdupq_n_s64(0x80uLL);
              v205 = (int64x2_t)xmmword_1816ABBF0;
              v172 = 8 * (v127 & 0xFFFFFFFFFFFFFFF0);
              v206 = 0uLL;
              v207 = 0uLL;
              v208 = (int64x2_t)xmmword_1816ABC10;
              v209 = v127 & 0xFFFFFFFFFFFFFFF0;
              v210 = 0uLL;
              v211 = 0uLL;
              v212 = 0uLL;
              v213 = 0uLL;
              v214 = 0uLL;
              v215 = 0uLL;
              do
              {
                v216 = *v196++;
                v217 = vmovl_u8(*(uint8x8_t *)v216.i8);
                v218 = vmovl_high_u16(v217);
                v219.i64[0] = v218.u32[2];
                v219.i64[1] = v218.u32[3];
                v220 = v219;
                v221 = vmovl_high_u8(v216);
                v222 = vmovl_u16(*(uint16x4_t *)v221.i8);
                v219.i64[0] = v222.u32[2];
                v219.i64[1] = v222.u32[3];
                v223 = v219;
                v219.i64[0] = v222.u32[0];
                v219.i64[1] = v222.u32[1];
                v224 = v219;
                v219.i64[0] = v218.u32[0];
                v219.i64[1] = v218.u32[1];
                v225 = v219;
                v226 = vmovl_u16(*(uint16x4_t *)v217.i8);
                v219.i64[0] = v226.u32[2];
                v219.i64[1] = v226.u32[3];
                v227 = v219;
                v228 = vmovl_high_u16(v221);
                v219.i64[0] = v228.u32[0];
                v219.i64[1] = v228.u32[1];
                v229 = v219;
                v219.i64[0] = v226.u32[0];
                v219.i64[1] = v226.u32[1];
                v230 = v219;
                v219.i64[0] = v228.u32[2];
                v219.i64[1] = v228.u32[3];
                v211 = vorrq_s8((int8x16_t)vshlq_u64(v220, (uint64x2_t)vandq_s8((int8x16_t)v201, v203)), v211);
                v213 = vorrq_s8((int8x16_t)vshlq_u64(v223, (uint64x2_t)vandq_s8((int8x16_t)v199, v203)), v213);
                v212 = vorrq_s8((int8x16_t)vshlq_u64(v224, (uint64x2_t)vandq_s8((int8x16_t)v200, v203)), v212);
                v210 = vorrq_s8((int8x16_t)vshlq_u64(v225, (uint64x2_t)vandq_s8((int8x16_t)v202, v203)), v210);
                v207 = vorrq_s8((int8x16_t)vshlq_u64(v227, (uint64x2_t)vandq_s8((int8x16_t)v205, v203)), v207);
                v214 = vorrq_s8((int8x16_t)vshlq_u64(v229, (uint64x2_t)vandq_s8((int8x16_t)v198, v203)), v214);
                v206 = vorrq_s8((int8x16_t)vshlq_u64(v230, (uint64x2_t)vandq_s8((int8x16_t)v208, v203)), v206);
                v215 = vorrq_s8((int8x16_t)vshlq_u64(v219, (uint64x2_t)vandq_s8((int8x16_t)v197, v203)), v215);
                v202 = vaddq_s64(v202, v204);
                v205 = vaddq_s64(v205, v204);
                v208 = vaddq_s64(v208, v204);
                v201 = vaddq_s64(v201, v204);
                v200 = vaddq_s64(v200, v204);
                v199 = vaddq_s64(v199, v204);
                v198 = vaddq_s64(v198, v204);
                v197 = vaddq_s64(v197, v204);
                v209 -= 16;
              }
              while (v209);
              v231 = vorrq_s8(vorrq_s8(vorrq_s8(v206, v212), vorrq_s8(v210, v214)), vorrq_s8(vorrq_s8(v207, v213), vorrq_s8(v211, v215)));
              v171 = vorr_s8(*(int8x8_t *)v231.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v231, v231, 8uLL));
              if (v127 == v170)
                goto LABEL_154;
              if ((v127 & 8) == 0)
                goto LABEL_152;
            }
            else
            {
              v171 = 0;
              v172 = 0;
              v170 = 0;
            }
            v173 = v170;
            v170 = v127 & 0xFFFFFFFFFFFFFFF8;
            v174 = vdupq_n_s64(v172);
            v172 = 8 * (v127 & 0xFFFFFFFFFFFFFFF8);
            v175 = (int8x16_t)(unint64_t)v171;
            v176 = 0uLL;
            v177 = vaddq_s64(v174, (int64x2_t)xmmword_1816ABC00);
            v178 = vaddq_s64(v174, (int64x2_t)xmmword_1816ABC20);
            v179 = vaddq_s64(v174, (int64x2_t)xmmword_1816ABBF0);
            v180 = vaddq_s64(v174, (int64x2_t)xmmword_1816ABC10);
            v181 = (uint8x8_t *)((char *)&TypeName->u64[1] + v173);
            v182 = (int8x16_t)vdupq_n_s64(0x38uLL);
            v183 = v173 - (v127 & 0xFFFFFFFFFFFFFFF8);
            v184 = vdupq_n_s64(0x40uLL);
            v185 = 0uLL;
            v186 = 0uLL;
            do
            {
              v187 = *v181++;
              v188 = vmovl_u8(v187);
              v189 = vmovl_high_u16(v188);
              v190.i64[0] = v189.u32[2];
              v190.i64[1] = v189.u32[3];
              v191 = v190;
              v190.i64[0] = v189.u32[0];
              v190.i64[1] = v189.u32[1];
              v192 = v190;
              v193 = vmovl_u16(*(uint16x4_t *)v188.i8);
              v190.i64[0] = v193.u32[2];
              v190.i64[1] = v193.u32[3];
              v194 = v190;
              v190.i64[0] = v193.u32[0];
              v190.i64[1] = v193.u32[1];
              v186 = vorrq_s8((int8x16_t)vshlq_u64(v191, (uint64x2_t)vandq_s8((int8x16_t)v177, v182)), v186);
              v185 = vorrq_s8((int8x16_t)vshlq_u64(v192, (uint64x2_t)vandq_s8((int8x16_t)v178, v182)), v185);
              v176 = vorrq_s8((int8x16_t)vshlq_u64(v194, (uint64x2_t)vandq_s8((int8x16_t)v179, v182)), v176);
              v175 = vorrq_s8((int8x16_t)vshlq_u64(v190, (uint64x2_t)vandq_s8((int8x16_t)v180, v182)), v175);
              v178 = vaddq_s64(v178, v184);
              v179 = vaddq_s64(v179, v184);
              v180 = vaddq_s64(v180, v184);
              v177 = vaddq_s64(v177, v184);
              v183 += 8;
            }
            while (v183);
            v195 = vorrq_s8(vorrq_s8(v175, v185), vorrq_s8(v176, v186));
            v171 = vorr_s8(*(int8x8_t *)v195.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v195, v195, 8uLL));
            if (v127 == v170)
              goto LABEL_154;
            goto LABEL_152;
          }
        }
        else
        {
          v129 = 0;
          countAndFlagsBits = 0;
          v130 = 0;
        }
LABEL_133:
        v167 = &TypeName->u8[v129];
        v168 = v128 - v129;
        do
        {
          v169 = *v167++;
          countAndFlagsBits |= (unint64_t)v169 << (v130 & 0x38);
          v130 += 8;
          --v168;
        }
        while (v168);
        goto LABEL_135;
      }
LABEL_254:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    goto LABEL_63;
  }
  if ((v86->i16[0] & 0x8080) == 0)
  {
    v86 = (uint8x16_t *)((char *)v86 + 2);
    goto LABEL_59;
  }
LABEL_63:
  v92 = 0;
  v93 = (uint8x16_t *)((char *)TypeName + v81);
  v91 = 1;
  v94 = TypeName;
  v95 = TypeName;
  while (1)
  {
    v98 = v95->i8[0];
    v95 = (uint8x16_t *)((char *)v95 + 1);
    v97 = v98;
    if (v98 < 0)
      break;
    v96 = 1;
LABEL_65:
    v92 += v96;
    v94 = v95;
    if (v95 == v93)
    {
      if (v81 > 15)
        goto LABEL_104;
      goto LABEL_114;
    }
  }
  if ((v97 + 62) > 0x32u)
    goto LABEL_105;
  if (v97 <= 0xDFu)
  {
    if (v95 == v93 || (v95->i8[0] & 0xC0) != 0x80)
      goto LABEL_105;
    v91 = 0;
    v95 = (uint8x16_t *)&v94->i16[1];
    v96 = 2;
    goto LABEL_65;
  }
  if (v97 == 224)
  {
    if (v95 == v93 || (v94->i8[1] & 0xE0) != 0xA0)
      goto LABEL_105;
    goto LABEL_85;
  }
  if (v97 <= 0xECu)
    goto LABEL_82;
  if (v97 == 237)
  {
    if (v95 == v93)
      goto LABEL_105;
    v99 = v94->u8[1];
    if (v99 > 0x9F)
      goto LABEL_105;
    goto LABEL_84;
  }
  if (v97 <= 0xEFu)
  {
LABEL_82:
    if (v95 == v93)
      goto LABEL_105;
    LOBYTE(v99) = v94->i8[1];
LABEL_84:
    if ((v99 & 0xC0) != 0x80)
      goto LABEL_105;
LABEL_85:
    if (&v94->i16[1] == (__int16 *)v93 || (v94->i8[2] & 0xC0) != 0x80)
      goto LABEL_105;
    v91 = 0;
    v95 = (uint8x16_t *)((char *)v94->i32 + 3);
    v96 = 3;
    goto LABEL_65;
  }
  if (v97 == 240)
  {
    if (v95 == v93 || (v94->i8[1] + 64) < 0xD0u)
      goto LABEL_105;
    goto LABEL_98;
  }
  if ((v97 + 15) <= 2u)
  {
    if (v95 == v93)
      goto LABEL_105;
    LOBYTE(v100) = v94->i8[1];
LABEL_97:
    if ((v100 & 0xC0) != 0x80)
      goto LABEL_105;
LABEL_98:
    if (&v94->i16[1] == (__int16 *)v93
      || (v94->i8[2] & 0xC0) != 0x80
      || (uint8x16_t *)((char *)v94->i32 + 3) == v93
      || (v94->i8[3] & 0xC0) != 0x80)
    {
      goto LABEL_105;
    }
    v91 = 0;
    v95 = (uint8x16_t *)((char *)v94->i64 + 4);
    v96 = 4;
    goto LABEL_65;
  }
  if (v95 != v93)
  {
    v100 = v94->u8[1];
    if (v100 <= 0x8F)
      goto LABEL_97;
  }
LABEL_105:
  v338 = v2;
  v101 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v101);
  v102 = specialized Collection.subscript.getter(v92, (uint64_t)v85, v84);
  v107 = findInvalidRange #1 (_:) in validateUTF8(_:)(v102, v103, v104, v105);
  v350._countAndFlagsBits = 0;
  v350._object = (void *)0xE000000000000000;
  if (__OFADD__(v84, 15))
  {
LABEL_253:
    __break(1u);
    goto LABEL_254;
  }
  v108 = v106;
  v336 = v1;
  v337 = v3;
  _StringGuts.reserveCapacity(_:)(v84 + 15);
  while (1)
  {
    v109 = specialized Collection.subscript.getter(v107, (uint64_t)v85, v84);
    v113 = v350._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v350._object & 0x2000000000000000) != 0)
      v113 = ((unint64_t)v350._object >> 56) & 0xF;
    v39 = __OFADD__(v113, v84);
    v114 = v113 + v84;
    if (v39)
    {
      __break(1u);
LABEL_248:
      __break(1u);
LABEL_249:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    v115 = v109;
    if (__OFADD__(v114, 3))
      goto LABEL_248;
    v116 = v110;
    v117 = v111;
    v118 = v112;
    _StringGuts.reserveCapacity(_:)(v114 + 3);
    v119 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v115, v116, v117, v118);
    _StringGuts.appendInPlace(_:isASCII:)(v119, v120, 0);
    v358[0] = 3;
    *(_QWORD *)&v353 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v353, v358, &v350);
    v121 = specialized Collection.subscript.getter(v108, (uint64_t)v85, v84);
    v85 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v121, v122, v123, v124);
    v84 = v125;
    v126 = validateUTF8(_:)(v85, v125);
    if ((v82 & 1) == 0)
      break;
    v107 = v126;
    v108 = v81;
    if (!v84)
      goto LABEL_120;
  }
  _StringGuts.appendInPlace(_:isASCII:)((char *)v85, v84, 0);
LABEL_120:
  object = (unint64_t)v350._object;
  countAndFlagsBits = v350._countAndFlagsBits;
  v2 = v338;
  v3 = v337;
  v37 = v349;
  v1 = v336;
LABEL_157:
  v236 = v356;
  v237 = HIBYTE(v357) & 0xF;
  v238 = v356 & 0xFFFFFFFFFFFFLL;
  if ((v357 & 0x2000000000000000) != 0)
    v238 = HIBYTE(v357) & 0xF;
  if (v238 || (v356 & ~v357 & 0x2000000000000000) != 0)
  {
    if ((v357 & 0x2000000000000000) == 0)
    {
      if ((object & 0x2000000000000000) != 0)
      {
        v239 = HIBYTE(object) & 0xF;
        goto LABEL_167;
      }
LABEL_165:
      v239 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      goto LABEL_167;
    }
    if ((object & 0x2000000000000000) == 0)
      goto LABEL_165;
    v239 = HIBYTE(object) & 0xF;
    v240 = v237 + v239;
    if (v237 + v239 <= 0xF)
    {
      v314 = v3;
      if (v239)
      {
        v315 = 0;
        v316 = 0;
        v317 = v357;
        do
        {
          v318 = v237 + v316;
          v319 = v316 + 1;
          if (v316 >= 8)
            v320 = object;
          else
            v320 = countAndFlagsBits;
          v321 = v320 >> (v315 & 0x38);
          v322 = (8 * v237 + v315) & 0x38;
          v323 = (-255 << v322) - 1;
          v324 = (unint64_t)v321 << v322;
          v325 = v324 | v323 & v317;
          v326 = v324 | v323 & v236;
          if (v318 < 8)
            v236 = v326;
          else
            v317 = v325;
          v315 += 8;
          v316 = v319;
        }
        while (v239 != v319);
      }
      else
      {
        v317 = v357;
      }
      swift_bridgeObjectRelease(v357);
      swift_bridgeObjectRelease(object);
      v327 = 0xA000000000000000;
      if (!(v236 & 0x8080808080808080 | v317 & 0x80808080808080))
        v327 = 0xE000000000000000;
      object = v327 & 0xFF00000000000000 | (v240 << 56) | v317 & 0xFFFFFFFFFFFFFFLL;
      v356 = v236;
      v357 = object;
      countAndFlagsBits = v236;
      v3 = v314;
    }
    else
    {
LABEL_167:
      swift_bridgeObjectRetain(object, v81, v82, v83);
      _StringGuts.append(_:)(countAndFlagsBits, object, 0, v239);
      swift_bridgeObjectRelease_n(object, 2);
      countAndFlagsBits = v356;
      object = v357;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v357);
    v356 = countAndFlagsBits;
    v357 = object;
  }
  v244 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0)
    v244 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v244 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (v245 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x283EuLL, 0xE200000000000000),
          (v242 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v241, v242, v243);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v246 = v245;
      v247 = v241;
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE200000000000000);
      v356 = v246;
      v357 = v247;
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    v356 = 10302;
    v357 = 0xE200000000000000;
  }
  v248 = *(const char **)(v1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v248, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v248, (uint64_t)v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v251 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v252 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v251(0, v252, AssociatedConformanceWitness);
  v351 = (uint64_t *)v2;
  v253 = __swift_allocate_boxed_opaque_existential_0Tm(&v350);
  memcpy(v253, v37, v3);
  v254 = v351;
  v255 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
  DynamicType = (_QWORD *)swift_getDynamicType(v255, v254, 1);
  LODWORD(v254) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
  if ((_DWORD)v254)
  {
    v257 = v347;
    memcpy(v347, v37, v3);
    v258 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v350, v257, v2, v258, 7uLL);
    goto LABEL_178;
  }
  v268 = v345;
  memcpy(v345, v37, v3);
  if ((swift_dynamicCast((char *)&v350, v268, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v269 = v350._object;
    String.append(_:)(v350);
    swift_bridgeObjectRelease((uint64_t)v269);
    goto LABEL_186;
  }
  v298 = v343;
  memcpy(v343, v37, v3);
  v299 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v353, v298, v2, v299, 6uLL))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
    v300 = (uint64_t)v351;
    v301 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v301 + 8))(&v356, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v300, v301);
LABEL_183:
    __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
    goto LABEL_186;
  }
  v355 = 0;
  v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v353, &demangling cache variable for type metadata for TextOutputStreamable?);
  v306 = v341;
  memcpy(v341, v37, v3);
  v307 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v353, v306, v2, v307, 6uLL)
    || (v355 = 0,
        v353 = 0u,
        v354 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v353, &demangling cache variable for type metadata for CustomStringConvertible?), v308 = v339, memcpy(v339, v37, v3), v309 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v353, v308, v2, v309, 6uLL)))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
LABEL_178:
    v259 = (uint64_t)v351;
    v260 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    v262 = (*(uint64_t (**)(uint64_t, uint64_t))(v260 + 8))(v259, v260);
    v263 = v261;
    v264 = HIBYTE(v357) & 0xF;
    if ((v357 & 0x2000000000000000) == 0)
      v264 = v356 & 0xFFFFFFFFFFFFLL;
    if (v264 || (v356 & ~v357 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v262, v261);
      swift_bridgeObjectRelease(v263);
    }
    else
    {
      swift_bridgeObjectRelease(v357);
      v356 = v262;
      v357 = v263;
    }
    goto LABEL_183;
  }
  v355 = 0;
  v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v353, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((_QWORD *)&v354 + 1) = v2;
  v328 = __swift_allocate_boxed_opaque_existential_0Tm(&v353);
  memcpy(v328, v37, v3);
  Mirror.init(reflecting:)((uint64_t *)&v353, (uint64_t)&v350);
  v329 = v350._object;
  v330 = v352;
  ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v37, &v350, &v356, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v330);
  swift_release((uint64_t)v329);
LABEL_186:
  v270 = v357;
  v271 = HIBYTE(v357) & 0xF;
  if ((v357 & 0x2000000000000000) == 0)
    v271 = v356 & 0xFFFFFFFFFFFFLL;
  if (v271 || (v356 & ~v357 & 0x2000000000000000) != 0)
  {
    if ((v357 & 0x2000000000000000) == 0
      || (v272 = specialized _SmallString.init(_:appending:)(v356, v357, 0x202CuLL, 0xE200000000000000),
          (v266 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v265, v266, v267);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v273 = v272;
      v274 = v265;
      swift_bridgeObjectRelease(v270);
      swift_bridgeObjectRelease(0xE200000000000000);
      v356 = v273;
      v357 = v274;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v357);
    v356 = 8236;
    v357 = 0xE200000000000000;
  }
  v275 = v348;
  v251(1, v252, AssociatedConformanceWitness);
  v351 = (uint64_t *)v2;
  v276 = __swift_allocate_boxed_opaque_existential_0Tm(&v350);
  memcpy(v276, v275, v3);
  v277 = v351;
  v278 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
  v279 = (_QWORD *)swift_getDynamicType(v278, v277, 1);
  LODWORD(v277) = swift_isOptionalType(v279);
  __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
  if ((_DWORD)v277)
  {
    v280 = v347;
    memcpy(v347, v275, v3);
    v281 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v350, v280, v2, v281, 7uLL);
    goto LABEL_196;
  }
  v291 = v346;
  memcpy(v346, v275, v3);
  if ((swift_dynamicCast((char *)&v350, v291, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v292 = v350._object;
    String.append(_:)(v350);
    swift_bridgeObjectRelease((uint64_t)v292);
    goto LABEL_204;
  }
  v302 = v344;
  memcpy(v344, v275, v3);
  v303 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v353, v302, v2, v303, 6uLL))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
    v304 = (uint64_t)v351;
    v305 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v305 + 8))(&v356, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v304, v305);
LABEL_201:
    __swift_destroy_boxed_opaque_existential_1Tm(&v350._countAndFlagsBits);
    goto LABEL_204;
  }
  v355 = 0;
  v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v353, &demangling cache variable for type metadata for TextOutputStreamable?);
  v310 = v342;
  memcpy(v342, v275, v3);
  v311 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v353, v310, v2, v311, 6uLL)
    || (v355 = 0,
        v353 = 0u,
        v354 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v353, &demangling cache variable for type metadata for CustomStringConvertible?), v312 = v340, memcpy(v340, v275, v3), v313 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v353, v312, v2, v313, 6uLL)))
  {
    outlined init with take of MirrorPath(&v353, (uint64_t)&v350);
LABEL_196:
    v282 = (uint64_t)v351;
    v283 = v352;
    __swift_project_boxed_opaque_existential_0Tm(&v350, (uint64_t)v351);
    v285 = (*(uint64_t (**)(uint64_t, uint64_t))(v283 + 8))(v282, v283);
    v286 = v284;
    v287 = HIBYTE(v357) & 0xF;
    if ((v357 & 0x2000000000000000) == 0)
      v287 = v356 & 0xFFFFFFFFFFFFLL;
    if (v287 || (v356 & ~v357 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v285, v284);
      swift_bridgeObjectRelease(v286);
    }
    else
    {
      swift_bridgeObjectRelease(v357);
      v356 = v285;
      v357 = v286;
    }
    goto LABEL_201;
  }
  v355 = 0;
  v353 = 0u;
  v354 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v353, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((_QWORD *)&v354 + 1) = v2;
  v331 = __swift_allocate_boxed_opaque_existential_0Tm(&v353);
  memcpy(v331, v275, v3);
  Mirror.init(reflecting:)((uint64_t *)&v353, (uint64_t)&v350);
  v332 = v350._object;
  v333 = v352;
  ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v275, &v350, &v356, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v333);
  swift_release((uint64_t)v332);
LABEL_204:
  v293 = v357;
  v294 = HIBYTE(v357) & 0xF;
  if ((v357 & 0x2000000000000000) == 0)
    v294 = v356 & 0xFFFFFFFFFFFFLL;
  if (v294 || (v356 & ~v357 & 0x2000000000000000) != 0)
  {
    if ((v357 & 0x2000000000000000) == 0
      || (v295 = specialized _SmallString.init(_:appending:)(v356, v357, 0x29uLL, 0xE100000000000000), (v289 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000, v288, v289, v290);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      return v356;
    }
    else
    {
      v296 = v295;
      swift_bridgeObjectRelease(v293);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v357);
    return 41;
  }
  return v296;
}

uint64_t SIMD2<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v18)(unint64_t);
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void (*v22)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  void (*v29)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  void (*v40)(_QWORD, unint64_t *, unint64_t);
  unint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v46 = a4;
  v47 = a6;
  v48 = a1;
  v42 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v44 = (char *)&v37 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v43 = (char *)&v37 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v15, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v18 = *(void (**)(unint64_t))(AssociatedConformanceWitness + 48);
  v41 = AssociatedTypeWitness;
  v19 = AssociatedConformanceWitness;
  v18(AssociatedTypeWitness);
  v45 = a7;
  v20 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  v39 = a3;
  v21 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, v20, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v40 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v21 + 56);
  v22 = v40;
  v23 = swift_checkMetadataState(0, v20);
  v24 = v44;
  v22(0, v23, v21);
  v25 = *(_QWORD *)(v46 + 16);
  v26 = *(_QWORD *)(v47 + 8);
  v46 = *(_QWORD *)(v25 + 72);
  v47 = v26;
  v27 = v43;
  ((void (*)(char *, uint64_t))v46)(v24, a3);
  v28 = v19;
  v38 = v19;
  v29 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(v19 + 64);
  v30 = v41;
  v29(v27, 0, v41, v28);
  v31 = swift_checkMetadataState(0, v20);
  v32 = v48;
  v40(1, v31, v21);
  v33 = v39;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v46)(v24, v39, v47, a2, v25);
  v29(v27, 1, v30, v38);
  v35 = type metadata accessor for SIMD2(0, v33, (uint64_t)v45, v34);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v35 - 8) + 8))(v32, v35);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v18)(unint64_t, unint64_t);
  unint64_t v19;
  unint64_t v20;
  void (*v21)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(char *, uint64_t, uint64_t, uint64_t);
  uint64_t v37;
  void (*v38)(_QWORD, unint64_t *, unint64_t);
  uint64_t v39;
  char *v40;
  char *v41;
  const char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;

  v43 = a6;
  v45 = a4;
  v37 = a1;
  v39 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v41 = (char *)&v34 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v40 = (char *)&v34 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v15, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v44 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  v42 = a7;
  v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  v35 = a3;
  v20 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v38 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v20 + 56);
  v21 = v38;
  v22 = swift_checkMetadataState(0, v19);
  v23 = v41;
  v21(0, v22, v20);
  v36 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v45 + 80);
  v24 = v40;
  v25 = a3;
  v26 = v43;
  v36(v23, v25, v43, a2);
  v27 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v27(v24, 0, v44, AssociatedConformanceWitness);
  v28 = swift_checkMetadataState(0, v19);
  v29 = v37;
  v38(1, v28, v20);
  v30 = v35;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v36)(v23, v35, v26, a2, v45);
  v27(v24, 1, v44, AssociatedConformanceWitness);
  v32 = type metadata accessor for SIMD2(0, v30, (uint64_t)v42, v31);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v32 - 8) + 8))(v29, v32);
}

uint64_t SIMD4._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage, a2);
}

uint64_t SIMD4._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t (*SIMD4._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD4.scalarCount.getter()
{
  return 4;
}

uint64_t key path getter for SIMD4.subscript(_:) : <A>SIMD4<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v8)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v9;

  v3 = *a2;
  if ((unint64_t)*a2 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  v4 = *(const char **)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD4.subscript(_:) : <A>SIMD4<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  size_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(char *, unint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t v17;

  v4 = *(_QWORD *)(a4 + a3 - 16);
  v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v17 - v6;
  v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC9uLL, 0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD4.subscript.modify(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD4.init(_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  size_t v11;
  const char *v12;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v15)(char *, uint64_t, unint64_t, unint64_t);
  uint64_t v17;
  const void *v18;

  v18 = a4;
  v11 = *(_QWORD *)(*(_QWORD *)(a5 - 8) + 64);
  MEMORY[0x1E0C80A78](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v12, a5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v11);
  v15 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v11);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v11);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), v18, v11);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v15)((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 3, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD4.x.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t key path getter for SIMD4.x : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t key path setter for SIMD4.x : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t SIMD4.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

void (*SIMD4.x.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(_QWORD, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(0, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

uint64_t SIMD4.y.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t key path getter for SIMD4.y : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t key path setter for SIMD4.y : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t SIMD4.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

void (*SIMD4.y.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(1, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

uint64_t SIMD4.z.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t key path getter for SIMD4.z : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t key path setter for SIMD4.z : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t SIMD4.z.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

void (*SIMD4.z.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(2, v12, AssociatedConformanceWitness);
  return SIMD4.z.modify;
}

void SIMD4.z.modify(uint64_t a1, uint64_t a2)
{
  SIMD2.x.modify(a1, a2, 2);
}

uint64_t SIMD4.w.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

uint64_t key path getter for SIMD4.w : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

uint64_t key path setter for SIMD4.w : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

uint64_t SIMD4.w.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

void (*SIMD4.w.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(3, v12, AssociatedConformanceWitness);
  return SIMD4.w.modify;
}

void SIMD4.w.modify(uint64_t a1, uint64_t a2)
{
  SIMD2.x.modify(a1, a2, 3);
}

uint64_t SIMD4.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v15)(uint64_t, uint64_t);

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = type metadata accessor for SIMD4(0, a3, (uint64_t)a4, v10);
  specialized SIMD4.lowHalf.setter(a1, v11, 0, 1);
  v13 = type metadata accessor for SIMD2(0, a3, (uint64_t)a4, v12);
  v15 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 8);
  v15(a1, v13);
  specialized SIMD4.lowHalf.setter(a2, v11, 2, 3);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 0, 1);
}

uint64_t SIMD4.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 2, 3);
}

uint64_t SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;

  specialized SIMD4.lowHalf.setter(a1, a2, a3, a4);
  v7 = type metadata accessor for SIMD2(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 8))(a1, v7);
}

uint64_t SIMD4.lowHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 0, 1);
}

uint64_t key path getter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD4, SIMD4.lowHalf.getter);
}

uint64_t key path setter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 0, 1);
}

void (*SIMD4.lowHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD2(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.lowHalf.getter(a2);
  return SIMD4.lowHalf.modify;
}

void SIMD4.lowHalf.modify(uint64_t **a1, char a2)
{
  SIMD4.lowHalf.modify(a1, a2, 0, 1);
}

uint64_t SIMD4.highHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 2, 3);
}

uint64_t key path getter for SIMD4.highHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD4, SIMD4.highHalf.getter);
}

uint64_t key path getter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD, _QWORD, _QWORD), uint64_t (*a5)(uint64_t))
{
  uint64_t v6;

  v6 = a4(0, *(_QWORD *)(a3 + a2 - 16), *(_QWORD *)(a3 + a2 - 8));
  return a5(v6);
}

uint64_t key path setter for SIMD4.highHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 2, 3);
}

uint64_t key path setter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;

  v9 = type metadata accessor for SIMD4(0, *(_QWORD *)(a4 + a3 - 16), *(_QWORD *)(a4 + a3 - 8), a4);
  return specialized SIMD4.lowHalf.setter(a1, v9, a5, a6);
}

void (*SIMD4.highHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD2(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.highHalf.getter(a2);
  return SIMD4.highHalf.modify;
}

void SIMD4.highHalf.modify(uint64_t **a1, char a2)
{
  SIMD4.lowHalf.modify(a1, a2, 2, 3);
}

void SIMD4.lowHalf.modify(uint64_t **a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(void *, uint64_t);

  v6 = *a1;
  v7 = (void *)(*a1)[4];
  v8 = (void *)(*a1)[5];
  v9 = (*a1)[2];
  v10 = (*a1)[3];
  v11 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v10 + 16))((*a1)[4], v8, v9);
    specialized SIMD4.lowHalf.setter((uint64_t)v7, v11, a3, a4);
    v12 = *(void (**)(void *, uint64_t))(v10 + 8);
    v12(v7, v9);
  }
  else
  {
    specialized SIMD4.lowHalf.setter((*a1)[5], v11, a3, a4);
    v12 = *(void (**)(void *, uint64_t))(v10 + 8);
  }
  v12(v8, v9);
  free(v8);
  free(v7);
  free(v6);
}

uint64_t SIMD4.evenHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 0, 2);
}

uint64_t key path getter for SIMD4.evenHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD4, SIMD4.evenHalf.getter);
}

uint64_t key path setter for SIMD4.evenHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 0, 2);
}

uint64_t SIMD4.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 0, 2);
}

void (*SIMD4.evenHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD2(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.evenHalf.getter(a2);
  return SIMD4.evenHalf.modify;
}

void SIMD4.evenHalf.modify(uint64_t **a1, char a2)
{
  SIMD4.lowHalf.modify(a1, a2, 0, 2);
}

uint64_t SIMD4.oddHalf.getter(uint64_t a1)
{
  return SIMD4.lowHalf.getter(a1, 1, 3);
}

uint64_t SIMD4.lowHalf.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  const char *v7;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v10;
  unint64_t v11;
  void (*v12)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v13;
  uint64_t (*v14)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v15;
  uint64_t v17;
  uint64_t v18;

  v17 = a2;
  v18 = a3;
  v3 = *(_QWORD *)(a1 + 16);
  v4 = MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *(const char **)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v10 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v11 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v12 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v11 + 56);
  v13 = swift_checkMetadataState(0, v10);
  v12(v17, v13, v11);
  v14 = *(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v14(v6, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  v15 = swift_checkMetadataState(0, v10);
  v12(v18, v15, v11);
  return v14(v6, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD4.oddHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD4, SIMD4.oddHalf.getter);
}

uint64_t key path setter for SIMD4.oddHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 1, 3);
}

uint64_t SIMD4.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 1, 3);
}

void (*SIMD4.oddHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD2(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD4.oddHalf.getter(a2);
  return SIMD4.oddHalf.modify;
}

void SIMD4.oddHalf.modify(uint64_t **a1, char a2)
{
  SIMD4.lowHalf.modify(a1, a2, 1, 3);
}

Swift::Int SIMD4.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD4<A>, a3);
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMD4<A>()
{
  return 4;
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD4<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD4<A>(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD4<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC9uLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD4<A>(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 4)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD4<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD4<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD4<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD4<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD, _QWORD, _QWORD);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t);
  const char *v23;
  unint64_t AssociatedTypeWitness;
  char *v25;
  unint64_t AssociatedConformanceWitness;
  void (*v27)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v28;
  void (*v29)(char *, uint64_t);
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;

  v3 = a3;
  v44 = a2;
  v4 = a1;
  v39 = *(_QWORD *)(a3 + 16);
  v5 = MEMORY[0x1E0C80A78](a1);
  v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = MEMORY[0x1E0C80A78](v5);
  v42 = (char *)&v37 - v8;
  v9 = MEMORY[0x1E0C80A78](v7);
  v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v37 - v13;
  v15 = 0;
  v16 = 1;
  v18 = v17;
  v19 = *(void (**)(_QWORD, _QWORD, _QWORD))(v17 + 16);
  v40 = v12;
  v41 = v20;
  v37 = v19;
  v38 = v17;
  v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      v23 = *(const char **)(v3 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
      v25 = v11;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
      v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      v28 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      v30 = v28;
      v19 = v37;
      v31 = AssociatedConformanceWitness;
      v11 = v25;
      v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      v32 = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      v33 = (uint64_t)v23;
      v4 = v40;
      v34 = swift_getAssociatedConformanceWitness(v33, v21, v32, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      v35 = swift_getAssociatedConformanceWitness(v34, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v18 = v38;
      v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35 + 8) + 8))(v42, v43, v21);
    }
    else
    {
      v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      v16 = 0;
    }
    if (++v15 == 4)
      break;
    v19(v14, v4, v3);
  }
  return v16 & 1;
}

uint64_t SIMD4<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  void (*v18)(unint64_t, unint64_t);
  const char *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  void (*v23)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  void (*v32)(uint64_t, unint64_t *, unint64_t);
  void (*v33)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  void (*v38)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v50;
  void (*v51)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(_QWORD, unint64_t *, unint64_t);
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t AssociatedConformanceWitness;
  uint64_t v62;
  unint64_t v63;

  v60 = a7;
  v55 = a4;
  v57 = a3;
  v58 = a8;
  v62 = a1;
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (char *)&v50 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v11);
  v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v63 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  v19 = v60;
  v20 = v57;
  v21 = swift_getAssociatedTypeWitness(255, v60, v57, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v22 = swift_getAssociatedConformanceWitness((uint64_t)v19, v20, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v56 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v22 + 56);
  v23 = v56;
  v52 = v22;
  v59 = v21;
  v24 = swift_checkMetadataState(0, v21);
  v23(0, v24, v22);
  v25 = *(_QWORD *)(v55 + 8);
  v55 = *(_QWORD *)(v25 + 96);
  v26 = *(_QWORD *)(a6 + 8);
  v53 = v25;
  v54 = v26;
  v27 = v13;
  v28 = v13;
  v29 = a2;
  ((void (*)(char *, uint64_t))v55)(v27, v20);
  v51 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v51)(v15, 0, v63);
  v30 = swift_checkMetadataState(0, v21);
  v31 = v52;
  v32 = v56;
  v56(1, v30, v52);
  v34 = v54;
  v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55;
  v50 = v29;
  v35 = v29;
  v36 = v53;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v20, v54, v35, v53);
  v37 = v63;
  v38 = v51;
  v51(v15, 1, v63, AssociatedConformanceWitness);
  v39 = swift_checkMetadataState(0, v59);
  v32(2, v39, v31);
  v40 = v57;
  v41 = v34;
  v42 = v50;
  v33(v28, v57, v41, v50, v36);
  v43 = v37;
  v44 = AssociatedConformanceWitness;
  v38(v15, 2, v43, AssociatedConformanceWitness);
  v45 = swift_checkMetadataState(0, v59);
  v46 = v62;
  v56(3, v45, v31);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v40, v54, v42, v53);
  v38(v15, 3, v63, v44);
  v48 = type metadata accessor for SIMD4(0, v40, (uint64_t)v60, v47);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v48 - 8) + 8))(v46, v48);
}

uint64_t SIMD4<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  void (*v18)(unint64_t, unint64_t);
  const char *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  void (*v23)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  void (*v32)(uint64_t, unint64_t *, unint64_t);
  void (*v33)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  void (*v38)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v50;
  void (*v51)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(_QWORD, unint64_t *, unint64_t);
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t AssociatedConformanceWitness;
  uint64_t v62;
  unint64_t v63;

  v60 = a7;
  v55 = a4;
  v57 = a3;
  v58 = a8;
  v62 = a1;
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (char *)&v50 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v11);
  v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v63 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  v19 = v60;
  v20 = v57;
  v21 = swift_getAssociatedTypeWitness(255, v60, v57, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v22 = swift_getAssociatedConformanceWitness((uint64_t)v19, v20, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v56 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v22 + 56);
  v23 = v56;
  v52 = v22;
  v59 = v21;
  v24 = swift_checkMetadataState(0, v21);
  v23(0, v24, v22);
  v25 = *(_QWORD *)(v55 + 8);
  v55 = *(_QWORD *)(v25 + 104);
  v26 = *(_QWORD *)(a6 + 8);
  v53 = v25;
  v54 = v26;
  v27 = v13;
  v28 = v13;
  v29 = a2;
  ((void (*)(char *, uint64_t))v55)(v27, v20);
  v51 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v51)(v15, 0, v63);
  v30 = swift_checkMetadataState(0, v21);
  v31 = v52;
  v32 = v56;
  v56(1, v30, v52);
  v34 = v54;
  v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55;
  v50 = v29;
  v35 = v29;
  v36 = v53;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v20, v54, v35, v53);
  v37 = v63;
  v38 = v51;
  v51(v15, 1, v63, AssociatedConformanceWitness);
  v39 = swift_checkMetadataState(0, v59);
  v32(2, v39, v31);
  v40 = v57;
  v41 = v34;
  v42 = v50;
  v33(v28, v57, v41, v50, v36);
  v43 = v37;
  v44 = AssociatedConformanceWitness;
  v38(v15, 2, v43, AssociatedConformanceWitness);
  v45 = swift_checkMetadataState(0, v59);
  v46 = v62;
  v56(3, v45, v31);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v40, v54, v42, v53);
  v38(v15, 3, v63, v44);
  v48 = type metadata accessor for SIMD4(0, v40, (uint64_t)v60, v47);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v48 - 8) + 8))(v46, v48);
}

uint64_t SIMD4<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  unint64_t AssociatedTypeWitness;
  unint64_t v22;
  unint64_t v23;
  void (*v24)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t, uint64_t);
  char *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void (*v46)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  unint64_t v47;
  void (*v48)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v54;
  char *v55;
  const char *v56;
  uint64_t v57;
  void (*v58)(uint64_t, unint64_t *, unint64_t);
  uint64_t v59;
  void (*v60)(uint64_t, uint64_t);
  unint64_t v61;
  char *v62;
  void (*v63)(char *, uint64_t, unint64_t, unint64_t);
  uint64_t v64;
  unint64_t AssociatedConformanceWitness;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;

  v69 = a7;
  v70 = a1;
  v64 = a5;
  v71 = a9;
  v72 = a2;
  v13 = MEMORY[0x1E0C80A78](a1);
  v15 = (char *)&v54 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v13);
  v62 = (char *)&v54 - v17;
  MEMORY[0x1E0C80A78](v16);
  v55 = (char *)&v54 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v20, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v66 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v56 = a8;
  v22 = swift_getAssociatedTypeWitness(255, a8, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v61 = v22;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)a8, a4, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v24 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  v68 = v23;
  v25 = swift_checkMetadataState(0, v22);
  v54 = v15;
  v24(0, v25, v23);
  v58 = v24;
  v26 = v69;
  v67 = *(_QWORD *)(v69 + 16);
  v60 = *(void (**)(uint64_t, uint64_t))(v67 + 304);
  v27 = v62;
  v60(v72, a4);
  v59 = *(_QWORD *)(v64 + 8);
  v64 = *(_QWORD *)(v59 + 80);
  v28 = v55;
  v29 = v27;
  v30 = v27;
  v31 = a4;
  v57 = a3;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t))v64)(v29, a4, v26, a3);
  v32 = v66;
  v63 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v63)(v28, 0, v66);
  v33 = v61;
  v34 = swift_checkMetadataState(0, v61);
  v24(1, v34, v68);
  v35 = v72;
  v36 = (void (*)(uint64_t, uint64_t, uint64_t))v60;
  ((void (*)(uint64_t, uint64_t, uint64_t))v60)(v72, v31, v67);
  v37 = v30;
  v38 = v59;
  ((void (*)(char *, uint64_t, uint64_t))v64)(v37, v31, v69);
  v39 = v32;
  v40 = AssociatedConformanceWitness;
  v63(v28, 1, v39, AssociatedConformanceWitness);
  v41 = swift_checkMetadataState(0, v33);
  v58(2, v41, v68);
  v42 = v62;
  v36(v35, v31, v67);
  v43 = v69;
  v44 = v57;
  v45 = v38;
  v46 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v64;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v64)(v42, v31, v69, v57, v45);
  v47 = v40;
  v48 = v63;
  v63(v28, 2, v66, v47);
  v49 = swift_checkMetadataState(0, v61);
  v50 = v70;
  v58(3, v49, v68);
  ((void (*)(uint64_t, uint64_t, uint64_t))v60)(v72, v31, v67);
  v46(v42, v31, v43, v44, v59);
  v48(v28, 3, v66, AssociatedConformanceWitness);
  v52 = type metadata accessor for SIMD4(0, v31, (uint64_t)v56, v51);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v52 - 8) + 8))(v50, v52);
}

uint64_t SIMD4.debugDescription.getter(uint64_t a1)
{
  uint64_t v1;
  Class *v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t *TypeName;
  uint64_t v57;
  uint8x16_t *v58;
  uint64_t v59;
  char v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t v65;
  unsigned __int8 *v66;
  uint8x16_t *i;
  unsigned int v68;
  unsigned int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unsigned __int8 *v72;
  unsigned int v73;
  char *v74;
  Class *v75;
  char *v76;
  char *v77;
  uint64_t v78;
  _QWORD *v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int64_t v85;
  int64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  const char *v99;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v102)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v103;
  _QWORD *v104;
  uint64_t *v105;
  swift::SwiftError **v106;
  _QWORD *DynamicType;
  uint64_t *v108;
  Class *v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  uint64_t *v119;
  void *object;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  _QWORD *v126;
  uint64_t *v127;
  swift::SwiftError **v128;
  _QWORD *v129;
  uint64_t *v130;
  Class *v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t v135;
  uint64_t v136;
  unint64_t v137;
  const void *v138;
  uint64_t v139;
  uint64_t v140;
  char *v141;
  uint64_t *v142;
  void *v143;
  Class *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t *v147;
  Class *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  const void *v156;
  _QWORD *v157;
  uint64_t *v158;
  swift::SwiftError **v159;
  _QWORD *v160;
  uint64_t *v161;
  Class *v162;
  uint64_t v163;
  uint64_t v164;
  unint64_t v165;
  unint64_t v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  char *v171;
  uint64_t *v172;
  void *v173;
  uint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  _QWORD *v179;
  uint64_t *v180;
  swift::SwiftError **v181;
  _QWORD *v182;
  uint64_t *v183;
  Class *v184;
  uint64_t v185;
  uint64_t v186;
  unint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  char *v193;
  uint64_t *v194;
  void *v195;
  uint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  uint64_t *v201;
  Class *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t *v205;
  Class *v206;
  uint64_t v207;
  uint64_t v208;
  char *v209;
  char *v210;
  uint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t v214;
  uint64_t *v215;
  Class *v216;
  uint64_t *v217;
  Class *v218;
  uint64_t v219;
  uint64_t v220;
  unint64_t v221;
  uint64_t *v222;
  Class *v223;
  uint64_t *v224;
  Class *v225;
  uint64_t *v226;
  Class *v227;
  uint64_t *v228;
  Class *v229;
  uint64_t *v230;
  Class *v231;
  uint64_t *v232;
  Class *v233;
  _QWORD *v234;
  void *v235;
  uint64_t v236;
  _QWORD *v237;
  void *v238;
  uint64_t v239;
  _QWORD *v240;
  void *v241;
  const void *v242;
  uint64_t v243;
  _QWORD *v244;
  void *v245;
  uint64_t v246;
  uint64_t v247;
  Class *v248;
  uint64_t *v249;
  uint64_t *v250;
  uint64_t *v251;
  uint64_t *v252;
  uint64_t *v253;
  uint64_t *v254;
  uint64_t *v255;
  uint64_t *v256;
  uint64_t *v257;
  uint64_t *v258;
  uint64_t *v259;
  uint64_t *v260;
  uint64_t *v261;
  uint64_t *v262;
  uint64_t *v263;
  char *v264;
  char *v265;
  uint64_t *v266;
  Swift::String v267;
  uint64_t *v268;
  uint64_t v269;
  __int128 v270;
  __int128 v271;
  uint64_t v272;
  unint64_t v273;
  unint64_t v274;

  v1 = a1;
  v2 = *(Class **)(a1 + 16);
  v3 = *((_QWORD *)*(v2 - 1) + 8);
  v4 = MEMORY[0x1E0C80A78](a1);
  v5 = MEMORY[0x1E0C80A78](v4);
  v256 = (uint64_t *)((char *)&v247 - v6);
  v7 = MEMORY[0x1E0C80A78](v5);
  v259 = (uint64_t *)((char *)&v247 - v8);
  v9 = MEMORY[0x1E0C80A78](v7);
  v263 = (uint64_t *)((char *)&v247 - v10);
  v11 = MEMORY[0x1E0C80A78](v9);
  v264 = (char *)&v247 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v251 = (uint64_t *)((char *)&v247 - v14);
  v15 = MEMORY[0x1E0C80A78](v13);
  v255 = (uint64_t *)((char *)&v247 - v16);
  v17 = MEMORY[0x1E0C80A78](v15);
  v258 = (uint64_t *)((char *)&v247 - v18);
  v19 = MEMORY[0x1E0C80A78](v17);
  v262 = (uint64_t *)((char *)&v247 - v20);
  v21 = MEMORY[0x1E0C80A78](v19);
  v265 = (char *)&v247 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v250 = (uint64_t *)((char *)&v247 - v24);
  v25 = MEMORY[0x1E0C80A78](v23);
  v254 = (uint64_t *)((char *)&v247 - v26);
  v27 = MEMORY[0x1E0C80A78](v25);
  v257 = (uint64_t *)((char *)&v247 - v28);
  v29 = MEMORY[0x1E0C80A78](v27);
  v261 = (uint64_t *)((char *)&v247 - v30);
  v31 = MEMORY[0x1E0C80A78](v29);
  v33 = (char *)&v247 - v32;
  v34 = MEMORY[0x1E0C80A78](v31);
  v249 = (uint64_t *)((char *)&v247 - v35);
  v36 = MEMORY[0x1E0C80A78](v34);
  v253 = (uint64_t *)((char *)&v247 - v37);
  v38 = MEMORY[0x1E0C80A78](v36);
  v40 = (char *)&v247 - v39;
  v41 = MEMORY[0x1E0C80A78](v38);
  v260 = (uint64_t *)((char *)&v247 - v42);
  v43 = MEMORY[0x1E0C80A78](v41);
  v266 = (uint64_t *)((char *)&v247 - v44);
  MEMORY[0x1E0C80A78](v43);
  v46 = (char *)&v247 - v45;
  v47 = specialized static String._createEmpty(withInitialCapacity:)(25);
  v51 = v48;
  v273 = v47;
  v274 = v48;
  v52 = HIBYTE(v48) & 0xF;
  if ((v48 & 0x2000000000000000) == 0)
    v52 = v47 & 0xFFFFFFFFFFFFLL;
  v252 = (uint64_t *)((char *)&v247 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v52 || (v47 & ~v48 & 0x2000000000000000) != 0)
  {
    if ((v48 & 0x2000000000000000) == 0
      || (v53 = specialized _SmallString.init(_:appending:)(v47, v48, 0x3C34444D4953uLL, 0xE600000000000000),
          (v49 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE600000000000000, v48, v49, v50);
      _StringGuts.append(_:)(0x3C34444D4953, 0xE600000000000000, 0, 6);
      swift_bridgeObjectRelease_n(0xE600000000000000, 2);
    }
    else
    {
      v54 = v53;
      v55 = v48;
      swift_bridgeObjectRelease(v51);
      swift_bridgeObjectRelease(0xE600000000000000);
      v273 = v54;
      v274 = v55;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v48);
    v273 = 0x3C34444D4953;
    v274 = 0xE600000000000000;
  }
  TypeName = (uint64_t *)swift_getTypeName(v2, 0);
  if (v57 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v58 = (uint8x16_t *)TypeName;
  v59 = v57;
  if (!_allASCII(_:)(TypeName, v57))
  {
    v65 = 0;
    v66 = &v58->u8[v59];
    if (!v58)
      v66 = 0;
    v60 = 1;
    for (i = v58; ; i = (uint8x16_t *)((char *)i + 3))
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if (!i || i == (uint8x16_t *)v66)
              goto LABEL_12;
            v69 = i->u8[0];
            i = (uint8x16_t *)((char *)i + 1);
            v68 = v69;
            if ((v68 & 0x80) != 0)
              break;
            ++v65;
          }
          if ((v68 + 62) >= 0x33u)
            goto LABEL_64;
          if (v68 > 0xDF)
            break;
          if (!i || i == (uint8x16_t *)v66 || (i->i8[0] & 0xC0) != 0x80)
            goto LABEL_64;
          v60 = 0;
          i = (uint8x16_t *)((char *)i + 1);
          v65 += 2;
        }
        if (v68 != 224)
          break;
        if (!i)
          goto LABEL_64;
        if (i == (uint8x16_t *)v66)
          goto LABEL_64;
        v70 = &i->u8[1];
        if ((i->i8[0] & 0xE0) != 0xA0)
          goto LABEL_64;
LABEL_42:
        if (v70 == v66 || (*v70 & 0xC0) != 0x80)
          goto LABEL_64;
        v60 = 0;
        i = (uint8x16_t *)((char *)i + 2);
        v65 += 3;
      }
      if (v68 <= 0xEC)
        break;
      if (v68 == 237)
      {
        if (!i)
          goto LABEL_64;
        if (i == (uint8x16_t *)v66)
          goto LABEL_64;
        v70 = &i->u8[1];
        v71 = i->u8[0];
        if (v71 > 0x9F)
          goto LABEL_64;
        goto LABEL_41;
      }
      if (v68 <= 0xEF)
        break;
      if (v68 == 240)
      {
        if (!i)
          goto LABEL_64;
        if (i == (uint8x16_t *)v66)
          goto LABEL_64;
        v72 = &i->u8[1];
        if ((i->i8[0] + 64) < 0xD0u)
          goto LABEL_64;
      }
      else
      {
        if ((v68 + 15) > 2u)
        {
          if (!i || i == (uint8x16_t *)v66 || (v72 = &i->u8[1], v73 = i->u8[0], v73 > 0x8F))
          {
LABEL_64:
            v74 = v46;
            v75 = v2;
            v76 = v40;
            v77 = v33;
            v78 = v1;
            v79 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
            v248 = (Class *)v3;
            swift_willThrow();
            v80 = v79;
            v1 = v78;
            v33 = v77;
            v40 = v76;
            v2 = v75;
            v46 = v74;
            swift_errorRelease(v80);
            v81 = specialized Collection.subscript.getter(v65, (uint64_t)v58, v59);
            v85 = findInvalidRange #1 (_:) in validateUTF8(_:)(v81, v82, v83, v84);
            v3 = (size_t)v248;
            v61 = repairUTF8(_:firstKnownBrokenRange:)(v58->i8, v59, v85, v86);
            goto LABEL_65;
          }
        }
        else
        {
          if (!i || i == (uint8x16_t *)v66)
            goto LABEL_64;
          v72 = &i->u8[1];
          LOBYTE(v73) = i->i8[0];
        }
        if ((v73 & 0xC0) != 0x80)
          goto LABEL_64;
      }
      if (v72 == v66 || (i->i8[1] & 0xC0) != 0x80 || &i->i16[1] == (__int16 *)v66 || (i->i8[2] & 0xC0) != 0x80)
        goto LABEL_64;
      v60 = 0;
      v65 += 4;
    }
    if (!i || i == (uint8x16_t *)v66)
      goto LABEL_64;
    v70 = &i->u8[1];
    LOBYTE(v71) = i->i8[0];
LABEL_41:
    if ((v71 & 0xC0) != 0x80)
      goto LABEL_64;
    goto LABEL_42;
  }
  v60 = 1;
LABEL_12:
  v61 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v58, v59, v60 & 1);
LABEL_65:
  v87 = v61;
  v88 = v62;
  v89 = v274;
  v90 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000) == 0)
    v90 = v273 & 0xFFFFFFFFFFFFLL;
  if (v90 || (v273 & ~v274 & 0x2000000000000000) != 0)
  {
    if ((v274 & 0x2000000000000000) == 0)
    {
      if ((v62 & 0x2000000000000000) != 0)
      {
        v91 = HIBYTE(v62) & 0xF;
LABEL_74:
        swift_bridgeObjectRetain(v88, v62, v63, v64);
        _StringGuts.append(_:)(v87, v88, 0, v91);
        swift_bridgeObjectRelease_n(v88, 2);
        v87 = v273;
        v88 = v274;
        goto LABEL_75;
      }
LABEL_73:
      v91 = v61 & 0xFFFFFFFFFFFFLL;
      goto LABEL_74;
    }
    if ((v62 & 0x2000000000000000) == 0)
      goto LABEL_73;
    v248 = v2;
    v209 = v40;
    v210 = v33;
    v211 = v1;
    v212 = specialized _SmallString.init(_:appending:)(v273, v274, v61, v62);
    if ((v63 & 1) != 0)
    {
      v91 = HIBYTE(v88) & 0xF;
      v33 = v210;
      v40 = v209;
      v2 = v248;
      goto LABEL_74;
    }
    v213 = v212;
    v214 = v62;
    swift_bridgeObjectRelease(v89);
    swift_bridgeObjectRelease(v88);
    v273 = v213;
    v274 = v214;
    v88 = v214;
    v87 = v213;
    v1 = v211;
    v33 = v210;
    v40 = v209;
    v2 = v248;
  }
  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = v87;
    v274 = v88;
  }
LABEL_75:
  v95 = HIBYTE(v88) & 0xF;
  if ((v88 & 0x2000000000000000) == 0)
    v95 = v87 & 0xFFFFFFFFFFFFLL;
  if (v95 || (v87 & ~v88 & 0x2000000000000000) != 0)
  {
    if ((v88 & 0x2000000000000000) == 0
      || (v96 = specialized _SmallString.init(_:appending:)(v87, v88, 0x283EuLL, 0xE200000000000000), (v93 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v92, v93, v94);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v97 = v96;
      v98 = v92;
      swift_bridgeObjectRelease(v88);
      swift_bridgeObjectRelease(0xE200000000000000);
      v273 = v97;
      v274 = v98;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v88);
    v273 = 10302;
    v274 = 0xE200000000000000;
  }
  v99 = *(const char **)(v1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v99, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, (uint64_t)v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v102 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v103 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v102(0, v103, AssociatedConformanceWitness);
  v268 = (uint64_t *)v2;
  v104 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v104, v46, v3);
  v105 = v268;
  v106 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  DynamicType = (_QWORD *)swift_getDynamicType(v106, v105, 1);
  LODWORD(v105) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if ((_DWORD)v105)
  {
    v108 = v266;
    memcpy(v266, v46, v3);
    v109 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v267, v108, v2, v109, 7uLL);
    v110 = (uint64_t)v268;
    v111 = v269;
    __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
    v113 = (*(uint64_t (**)(uint64_t, uint64_t))(v111 + 8))(v110, v111);
    v114 = v112;
    v115 = HIBYTE(v274) & 0xF;
    if ((v274 & 0x2000000000000000) == 0)
      v115 = v273 & 0xFFFFFFFFFFFFLL;
    if (v115 || (v273 & ~v274 & 0x2000000000000000) != 0)
    {
LABEL_88:
      _StringGuts.append(_:)(v113, v112);
      swift_bridgeObjectRelease(v114);
LABEL_89:
      __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      goto LABEL_92;
    }
LABEL_198:
    swift_bridgeObjectRelease(v274);
    v273 = v113;
    v274 = v114;
    goto LABEL_89;
  }
  v119 = v260;
  memcpy(v260, v46, v3);
  if ((swift_dynamicCast((char *)&v267, v119, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    object = v267._object;
    String.append(_:)(v267);
    swift_bridgeObjectRelease((uint64_t)object);
  }
  else
  {
    memcpy(v40, v46, v3);
    v144 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v270, (uint64_t *)v40, v2, v144, 6uLL))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      v145 = (uint64_t)v268;
      v146 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v146 + 8))(&v273, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v145, v146);
      goto LABEL_89;
    }
    v272 = 0;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for TextOutputStreamable?);
    v215 = v253;
    memcpy(v253, v46, v3);
    v216 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v270, v215, v2, v216, 6uLL)
      || (v272 = 0,
          v270 = 0u,
          v271 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomStringConvertible?), v217 = v249, memcpy(v249, v46, v3), v218 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v270, v217, v2, v218, 6uLL)))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      v219 = (uint64_t)v268;
      v220 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      v113 = (*(uint64_t (**)(uint64_t, uint64_t))(v220 + 8))(v219, v220);
      v114 = v112;
      v221 = HIBYTE(v274) & 0xF;
      if ((v274 & 0x2000000000000000) == 0)
        v221 = v273 & 0xFFFFFFFFFFFFLL;
      if (v221 || (v273 & ~v274 & 0x2000000000000000) != 0)
        goto LABEL_88;
      goto LABEL_198;
    }
    v272 = 0;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v271 + 1) = v2;
    v234 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
    memcpy(v234, v46, v3);
    Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
    v235 = v267._object;
    v236 = v269;
    ((void (*)(char *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v46, &v267, &v273, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v236);
    swift_release((uint64_t)v235);
  }
LABEL_92:
  v121 = v274;
  v122 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000) == 0)
    v122 = v273 & 0xFFFFFFFFFFFFLL;
  if (v122 || (v273 & ~v274 & 0x2000000000000000) != 0)
  {
    if ((v274 & 0x2000000000000000) == 0
      || (v123 = specialized _SmallString.init(_:appending:)(v273, v274, 0x202CuLL, 0xE200000000000000),
          (v117 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v116, v117, v118);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v124 = v123;
      v125 = v116;
      swift_bridgeObjectRelease(v121);
      swift_bridgeObjectRelease(0xE200000000000000);
      v273 = v124;
      v274 = v125;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = 8236;
    v274 = 0xE200000000000000;
  }
  v102(1, v103, AssociatedConformanceWitness);
  v268 = (uint64_t *)v2;
  v126 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v126, v33, v3);
  v127 = v268;
  v128 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  v129 = (_QWORD *)swift_getDynamicType(v128, v127, 1);
  LODWORD(v127) = swift_isOptionalType(v129);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if (!(_DWORD)v127)
  {
    v142 = v261;
    memcpy(v261, v33, v3);
    if ((swift_dynamicCast((char *)&v267, v142, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
    {
      v143 = v267._object;
      String.append(_:)(v267);
      swift_bridgeObjectRelease((uint64_t)v143);
    }
    else
    {
      v147 = v257;
      memcpy(v257, v33, v3);
      v148 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
      if (swift_dynamicCast((char *)&v270, v147, v2, v148, 6uLL))
      {
        outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
        v149 = (uint64_t)v268;
        v150 = v269;
        __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
        (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v150 + 8))(&v273, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v149, v150);
        __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      }
      else
      {
        v272 = 0;
        v270 = 0u;
        v271 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for TextOutputStreamable?);
        v222 = v254;
        memcpy(v254, v33, v3);
        v223 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
        if (swift_dynamicCast((char *)&v270, v222, v2, v223, 6uLL)
          || (v272 = 0,
              v270 = 0u,
              v271 = 0u,
              outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomStringConvertible?), v224 = v250, memcpy(v250, v33, v3), v225 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v270, v224, v2, v225, 6uLL)))
        {
          outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
          goto LABEL_102;
        }
        v272 = 0;
        v270 = 0u;
        v271 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((_QWORD *)&v271 + 1) = v2;
        v237 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
        memcpy(v237, v33, v3);
        Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
        v238 = v267._object;
        v239 = v269;
        ((void (*)(char *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v33, &v267, &v273, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
        swift_release(v239);
        swift_release((uint64_t)v238);
      }
    }
    v138 = v264;
    goto LABEL_115;
  }
  v130 = v266;
  memcpy(v266, v33, v3);
  v131 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  swift_dynamicCast((char *)&v267, v130, v2, v131, 7uLL);
LABEL_102:
  v132 = (uint64_t)v268;
  v133 = v269;
  __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  v135 = (*(uint64_t (**)(uint64_t, uint64_t))(v133 + 8))(v132, v133);
  v136 = v134;
  v137 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000) == 0)
    v137 = v273 & 0xFFFFFFFFFFFFLL;
  if (v137 || (v273 & ~v274 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(v135, v134);
    swift_bridgeObjectRelease(v136);
  }
  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = v135;
    v274 = v136;
  }
  v138 = v264;
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
LABEL_115:
  v151 = v274;
  v152 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000) == 0)
    v152 = v273 & 0xFFFFFFFFFFFFLL;
  if (v152 || (v273 & ~v274 & 0x2000000000000000) != 0)
  {
    if ((v274 & 0x2000000000000000) == 0
      || (v153 = specialized _SmallString.init(_:appending:)(v273, v274, 0x202CuLL, 0xE200000000000000),
          (v140 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v139, v140, v141);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v154 = v153;
      v155 = v139;
      swift_bridgeObjectRelease(v151);
      swift_bridgeObjectRelease(0xE200000000000000);
      v273 = v154;
      v274 = v155;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = 8236;
    v274 = 0xE200000000000000;
  }
  v156 = v265;
  v102(2, v103, AssociatedConformanceWitness);
  v268 = (uint64_t *)v2;
  v157 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v157, v156, v3);
  v158 = v268;
  v159 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  v160 = (_QWORD *)swift_getDynamicType(v159, v158, 1);
  LODWORD(v158) = swift_isOptionalType(v160);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if ((_DWORD)v158)
  {
    v161 = v266;
    memcpy(v266, v156, v3);
    v162 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v267, v161, v2, v162, 7uLL);
LABEL_125:
    v163 = (uint64_t)v268;
    v164 = v269;
    __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
    v166 = (*(uint64_t (**)(uint64_t, uint64_t))(v164 + 8))(v163, v164);
    v167 = v165;
    v168 = HIBYTE(v274) & 0xF;
    if ((v274 & 0x2000000000000000) == 0)
      v168 = v273 & 0xFFFFFFFFFFFFLL;
    if (v168 || (v273 & ~v274 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v166, v165);
      swift_bridgeObjectRelease(v167);
    }
    else
    {
      swift_bridgeObjectRelease(v274);
      v273 = v166;
      v274 = v167;
    }
    goto LABEL_130;
  }
  v172 = v262;
  memcpy(v262, v156, v3);
  if ((swift_dynamicCast((char *)&v267, v172, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v173 = v267._object;
    String.append(_:)(v267);
    swift_bridgeObjectRelease((uint64_t)v173);
  }
  else
  {
    v201 = v258;
    memcpy(v258, v156, v3);
    v202 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v270, v201, v2, v202, 6uLL))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      v203 = (uint64_t)v268;
      v204 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v204 + 8))(&v273, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v203, v204);
LABEL_130:
      __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      goto LABEL_133;
    }
    v272 = 0;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for TextOutputStreamable?);
    v226 = v255;
    memcpy(v255, v156, v3);
    v227 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v270, v226, v2, v227, 6uLL)
      || (v272 = 0,
          v270 = 0u,
          v271 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomStringConvertible?), v228 = v251, memcpy(v251, v156, v3), v229 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v270, v228, v2, v229, 6uLL)))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      goto LABEL_125;
    }
    v272 = 0;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v271 + 1) = v2;
    v240 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
    memcpy(v240, v156, v3);
    Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
    v241 = v267._object;
    v242 = v156;
    v243 = v269;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v242, &v267, &v273, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v243);
    swift_release((uint64_t)v241);
  }
LABEL_133:
  v174 = v274;
  v175 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000) == 0)
    v175 = v273 & 0xFFFFFFFFFFFFLL;
  if (v175 || (v273 & ~v274 & 0x2000000000000000) != 0)
  {
    if ((v274 & 0x2000000000000000) == 0
      || (v176 = specialized _SmallString.init(_:appending:)(v273, v274, 0x202CuLL, 0xE200000000000000),
          (v170 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v169, v170, v171);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v177 = v176;
      v178 = v169;
      swift_bridgeObjectRelease(v174);
      swift_bridgeObjectRelease(0xE200000000000000);
      v273 = v177;
      v274 = v178;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v274);
    v273 = 8236;
    v274 = 0xE200000000000000;
  }
  v102(3, v103, AssociatedConformanceWitness);
  v268 = (uint64_t *)v2;
  v179 = __swift_allocate_boxed_opaque_existential_0Tm(&v267);
  memcpy(v179, v138, v3);
  v180 = v268;
  v181 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
  v182 = (_QWORD *)swift_getDynamicType(v181, v180, 1);
  LODWORD(v180) = swift_isOptionalType(v182);
  __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
  if ((_DWORD)v180)
  {
    v183 = v266;
    memcpy(v266, v138, v3);
    v184 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v267, v183, v2, v184, 7uLL);
LABEL_143:
    v185 = (uint64_t)v268;
    v186 = v269;
    __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
    v188 = (*(uint64_t (**)(uint64_t, uint64_t))(v186 + 8))(v185, v186);
    v189 = v187;
    v190 = HIBYTE(v274) & 0xF;
    if ((v274 & 0x2000000000000000) == 0)
      v190 = v273 & 0xFFFFFFFFFFFFLL;
    if (v190 || (v273 & ~v274 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v188, v187);
      swift_bridgeObjectRelease(v189);
    }
    else
    {
      swift_bridgeObjectRelease(v274);
      v273 = v188;
      v274 = v189;
    }
    goto LABEL_148;
  }
  v194 = v263;
  memcpy(v263, v138, v3);
  if ((swift_dynamicCast((char *)&v267, v194, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v195 = v267._object;
    String.append(_:)(v267);
    swift_bridgeObjectRelease((uint64_t)v195);
  }
  else
  {
    v205 = v259;
    memcpy(v259, v138, v3);
    v206 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v270, v205, v2, v206, 6uLL))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      v207 = (uint64_t)v268;
      v208 = v269;
      __swift_project_boxed_opaque_existential_0Tm(&v267, (uint64_t)v268);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v208 + 8))(&v273, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v207, v208);
LABEL_148:
      __swift_destroy_boxed_opaque_existential_1Tm(&v267._countAndFlagsBits);
      goto LABEL_151;
    }
    v272 = 0;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for TextOutputStreamable?);
    v230 = v256;
    memcpy(v256, v138, v3);
    v231 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v270, v230, v2, v231, 6uLL)
      || (v272 = 0,
          v270 = 0u,
          v271 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomStringConvertible?), v232 = v252, memcpy(v252, v138, v3), v233 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v270, v232, v2, v233, 6uLL)))
    {
      outlined init with take of MirrorPath(&v270, (uint64_t)&v267);
      goto LABEL_143;
    }
    v272 = 0;
    v270 = 0u;
    v271 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v270, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v271 + 1) = v2;
    v244 = __swift_allocate_boxed_opaque_existential_0Tm(&v270);
    memcpy(v244, v138, v3);
    Mirror.init(reflecting:)((uint64_t *)&v270, (uint64_t)&v267);
    v245 = v267._object;
    v246 = v269;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v138, &v267, &v273, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v246);
    swift_release((uint64_t)v245);
  }
LABEL_151:
  v196 = v274;
  v197 = HIBYTE(v274) & 0xF;
  if ((v274 & 0x2000000000000000) == 0)
    v197 = v273 & 0xFFFFFFFFFFFFLL;
  if (v197 || (v273 & ~v274 & 0x2000000000000000) != 0)
  {
    if ((v274 & 0x2000000000000000) == 0
      || (v198 = specialized _SmallString.init(_:appending:)(v273, v274, 0x29uLL, 0xE100000000000000), (v192 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000, v191, v192, v193);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      return v273;
    }
    else
    {
      v199 = v198;
      swift_bridgeObjectRelease(v196);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v274);
    return 41;
  }
  return v199;
}

uint64_t SIMD4<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  void (*v18)(unint64_t, unint64_t);
  const char *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  void (*v23)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  void (*v32)(uint64_t, unint64_t *, unint64_t);
  void (*v33)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  void (*v38)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v50;
  void (*v51)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void (*v56)(_QWORD, unint64_t *, unint64_t);
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t AssociatedConformanceWitness;
  uint64_t v62;
  unint64_t v63;

  v60 = a7;
  v55 = a4;
  v57 = a3;
  v58 = a8;
  v62 = a1;
  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = (char *)&v50 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v11);
  v15 = (char *)&v50 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v18 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v63 = AssociatedTypeWitness;
  v18(AssociatedTypeWitness, AssociatedConformanceWitness);
  v19 = v60;
  v20 = v57;
  v21 = swift_getAssociatedTypeWitness(255, v60, v57, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v22 = swift_getAssociatedConformanceWitness((uint64_t)v19, v20, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v56 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v22 + 56);
  v23 = v56;
  v52 = v22;
  v59 = v21;
  v24 = swift_checkMetadataState(0, v21);
  v23(0, v24, v22);
  v25 = *(_QWORD *)(v55 + 16);
  v55 = *(_QWORD *)(v25 + 72);
  v26 = *(_QWORD *)(a6 + 8);
  v53 = v25;
  v54 = v26;
  v27 = v13;
  v28 = v13;
  v29 = a2;
  ((void (*)(char *, uint64_t))v55)(v27, v20);
  v51 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v51)(v15, 0, v63);
  v30 = swift_checkMetadataState(0, v21);
  v31 = v52;
  v32 = v56;
  v56(1, v30, v52);
  v34 = v54;
  v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55;
  v50 = v29;
  v35 = v29;
  v36 = v53;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v20, v54, v35, v53);
  v37 = v63;
  v38 = v51;
  v51(v15, 1, v63, AssociatedConformanceWitness);
  v39 = swift_checkMetadataState(0, v59);
  v32(2, v39, v31);
  v40 = v57;
  v41 = v34;
  v42 = v50;
  v33(v28, v57, v41, v50, v36);
  v43 = v37;
  v44 = AssociatedConformanceWitness;
  v38(v15, 2, v43, AssociatedConformanceWitness);
  v45 = swift_checkMetadataState(0, v59);
  v46 = v62;
  v56(3, v45, v31);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v55)(v28, v40, v54, v42, v53);
  v38(v15, 3, v63, v44);
  v48 = type metadata accessor for SIMD4(0, v40, (uint64_t)v60, v47);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v48 - 8) + 8))(v46, v48);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  void (*v22)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v23;
  char *v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  unint64_t v34;
  unint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  void (*v41)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(uint64_t, unint64_t *, unint64_t);
  uint64_t v49;
  char *v50;
  const char *v51;
  void (*v52)(char *, uint64_t, uint64_t, uint64_t);
  unint64_t v53;
  uint64_t v54;
  void (*v55)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t AssociatedConformanceWitness;
  unint64_t v60;
  uint64_t v61;

  v61 = a6;
  v57 = a1;
  v58 = a4;
  v54 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v50 = (char *)&v46 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v15 = (char *)&v46 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v60 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = (uint64_t)a7;
  v51 = a7;
  v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v20 = a3;
  v49 = a3;
  v21 = swift_getAssociatedConformanceWitness(v18, a3, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v22 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v21 + 56);
  v53 = v21;
  v56 = v19;
  v23 = swift_checkMetadataState(0, v19);
  v24 = v50;
  v22(0, v23, v21);
  v25 = v22;
  v52 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v58 + 80);
  v26 = v20;
  v27 = v61;
  v28 = v58;
  v52(v24, v26, v61, a2);
  v55 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v55)(v15, 0, v60);
  v29 = swift_checkMetadataState(0, v19);
  v30 = v53;
  v48 = v22;
  v22(1, v29, v53);
  v31 = v49;
  v47 = a2;
  v32 = a2;
  v33 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v52;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v52)(v24, v49, v27, v32, v28);
  v34 = v60;
  v55(v15, 1, v60, AssociatedConformanceWitness);
  v35 = swift_checkMetadataState(0, v56);
  v36 = v57;
  v25(2, v35, v30);
  v37 = v31;
  v38 = v47;
  v33(v24, v31, v61, v47, v28);
  v39 = v34;
  v40 = AssociatedConformanceWitness;
  v41 = v55;
  v55(v15, 2, v39, AssociatedConformanceWitness);
  v42 = swift_checkMetadataState(0, v56);
  v48(3, v42, v53);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v52)(v24, v37, v61, v38, v58);
  v41(v15, 3, v60, v40);
  v44 = type metadata accessor for SIMD4(0, v37, (uint64_t)v51, v43);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v44 - 8) + 8))(v36, v44);
}

uint64_t SIMD8._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage, a2);
}

uint64_t SIMD8._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t (*SIMD8._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD8.scalarCount.getter()
{
  return 8;
}

uint64_t key path getter for SIMD8.subscript(_:) : <A>SIMD8<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v8)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v9;

  v3 = *a2;
  if ((unint64_t)*a2 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  v4 = *(const char **)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD8.subscript(_:) : <A>SIMD8<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  size_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(char *, unint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t v17;

  v4 = *(_QWORD *)(a4 + a3 - 16);
  v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v17 - v6;
  v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1BBuLL, 0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD8.subscript.modify(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD8.init(_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, uint64_t a9, const char *a10)
{
  size_t v13;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v16)(char *, uint64_t, unint64_t, unint64_t);
  uint64_t v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;

  v22 = a7;
  v23 = a8;
  v20 = a5;
  v21 = a6;
  v19 = a4;
  v13 = *(_QWORD *)(*(_QWORD *)(a9 - 8) + 64);
  MEMORY[0x1E0C80A78](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a10, a9, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a10, a9, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v13);
  v16 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v19, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v20, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v21, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v22, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v23, v13);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v16)((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 7, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD8.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v15)(uint64_t, uint64_t);

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = type metadata accessor for SIMD8(0, a3, (uint64_t)a4, v10);
  specialized SIMD8.lowHalf.setter(a1, v11, 0, 1, 2, 3);
  v13 = type metadata accessor for SIMD4(0, a3, (uint64_t)a4, v12);
  v15 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 8);
  v15(a1, v13);
  specialized SIMD8.lowHalf.setter(a2, v11, 4, 5, 6, 7);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD8.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 0, 1, 2, 3);
}

uint64_t SIMD8.oddHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;

  specialized SIMD8.lowHalf.setter(a1, a2, a3, a4, a5, a6);
  v9 = type metadata accessor for SIMD4(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 8))(a1, v9);
}

uint64_t SIMD8.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 4, 5, 6, 7);
}

uint64_t SIMD8.lowHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 0, 1, 2, 3);
}

uint64_t key path getter for SIMD8.lowHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8, SIMD8.lowHalf.getter);
}

uint64_t key path setter for SIMD8.lowHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 0, 1, 2, 3);
}

uint64_t key path setter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;

  v13 = type metadata accessor for SIMD8(0, *(_QWORD *)(a4 + a3 - 16), *(_QWORD *)(a4 + a3 - 8), a4);
  return specialized SIMD8.lowHalf.setter(a1, v13, a5, a6, a7, a8);
}

void (*SIMD8.lowHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD4(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.lowHalf.getter(a2);
  return SIMD8.lowHalf.modify;
}

void SIMD8.lowHalf.modify(uint64_t **a1, char a2)
{
  SIMD8.oddHalf.modify(a1, a2, 0, 1, 2, 3);
}

void SIMD8.oddHalf.modify(uint64_t **a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(void *, uint64_t);

  v9 = *a1;
  v10 = (void *)(*a1)[4];
  v11 = (void *)(*a1)[5];
  v12 = (*a1)[2];
  v13 = (*a1)[3];
  v14 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v13 + 16))((*a1)[4], v11, v12);
    specialized SIMD8.lowHalf.setter((uint64_t)v10, v14, a3, a4, a5, a6);
    v15 = *(void (**)(void *, uint64_t))(v13 + 8);
    v15(v10, v12);
  }
  else
  {
    specialized SIMD8.lowHalf.setter((*a1)[5], v14, a3, a4, a5, a6);
    v15 = *(void (**)(void *, uint64_t))(v13 + 8);
  }
  v15(v11, v12);
  free(v11);
  free(v10);
  free(v9);
}

uint64_t SIMD8.highHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 4, 5, 6, 7);
}

uint64_t key path getter for SIMD8.highHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8, SIMD8.highHalf.getter);
}

uint64_t key path setter for SIMD8.highHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 4, 5, 6, 7);
}

void (*SIMD8.highHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD4(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.highHalf.getter(a2);
  return SIMD8.highHalf.modify;
}

void SIMD8.highHalf.modify(uint64_t **a1, char a2)
{
  SIMD8.oddHalf.modify(a1, a2, 4, 5, 6, 7);
}

uint64_t SIMD8.evenHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 0, 2, 4, 6);
}

uint64_t key path getter for SIMD8.evenHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8, SIMD8.evenHalf.getter);
}

uint64_t key path setter for SIMD8.evenHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 0, 2, 4, 6);
}

uint64_t SIMD8.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 0, 2, 4, 6);
}

void (*SIMD8.evenHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD4(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.evenHalf.getter(a2);
  return SIMD8.evenHalf.modify;
}

void SIMD8.evenHalf.modify(uint64_t **a1, char a2)
{
  SIMD8.oddHalf.modify(a1, a2, 0, 2, 4, 6);
}

uint64_t SIMD8.oddHalf.getter(uint64_t a1)
{
  return SIMD8.lowHalf.getter(a1, 1, 3, 5, 7);
}

uint64_t SIMD8.lowHalf.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  const char *v9;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v12;
  unint64_t v13;
  void (*v14)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  void (*v16)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v23 = a4;
  v24 = a5;
  v21 = a2;
  v22 = a3;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v21 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v9 = *(const char **)(v6 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v9, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v9, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v12 = swift_getAssociatedTypeWitness(255, v9, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  v13 = swift_getAssociatedConformanceWitness((uint64_t)v9, v5, v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v13 + 56);
  v15 = swift_checkMetadataState(0, v12);
  v14(v21, v15, v13);
  v16 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v16(v8, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  v17 = swift_checkMetadataState(0, v12);
  v14(v22, v17, v13);
  v16(v8, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = swift_checkMetadataState(0, v12);
  v14(v23, v18, v13);
  v16(v8, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  v19 = swift_checkMetadataState(0, v12);
  v14(v24, v19, v13);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v16)(v8, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8, SIMD8.oddHalf.getter);
}

uint64_t key path setter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 1, 3, 5, 7);
}

uint64_t SIMD8.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 1, 3, 5, 7);
}

void (*SIMD8.oddHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD4(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD8.oddHalf.getter(a2);
  return SIMD8.oddHalf.modify;
}

void SIMD8.oddHalf.modify(uint64_t **a1, char a2)
{
  SIMD8.oddHalf.modify(a1, a2, 1, 3, 5, 7);
}

Swift::Int SIMD8.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD8<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD8<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD8Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD8<A>(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD8<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1BBuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD8<A>(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 8)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD8<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD8<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD8<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD8<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD, _QWORD, _QWORD);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t);
  const char *v23;
  unint64_t AssociatedTypeWitness;
  char *v25;
  unint64_t AssociatedConformanceWitness;
  void (*v27)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v28;
  void (*v29)(char *, uint64_t);
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;

  v3 = a3;
  v44 = a2;
  v4 = a1;
  v39 = *(_QWORD *)(a3 + 16);
  v5 = MEMORY[0x1E0C80A78](a1);
  v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = MEMORY[0x1E0C80A78](v5);
  v42 = (char *)&v37 - v8;
  v9 = MEMORY[0x1E0C80A78](v7);
  v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v37 - v13;
  v15 = 0;
  v16 = 1;
  v18 = v17;
  v19 = *(void (**)(_QWORD, _QWORD, _QWORD))(v17 + 16);
  v40 = v12;
  v41 = v20;
  v37 = v19;
  v38 = v17;
  v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      v23 = *(const char **)(v3 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
      v25 = v11;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
      v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      v28 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      v30 = v28;
      v19 = v37;
      v31 = AssociatedConformanceWitness;
      v11 = v25;
      v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      v32 = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      v33 = (uint64_t)v23;
      v4 = v40;
      v34 = swift_getAssociatedConformanceWitness(v33, v21, v32, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      v35 = swift_getAssociatedConformanceWitness(v34, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v18 = v38;
      v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35 + 8) + 8))(v42, v43, v21);
    }
    else
    {
      v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      v16 = 0;
    }
    if (++v15 == 8)
      break;
    v19(v14, v4, v3);
  }
  return v16 & 1;
}

uint64_t SIMD8<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 96))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 8);
  v28 = type metadata accessor for SIMD8(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD8<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 104))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 8);
  v28 = type metadata accessor for SIMD8(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD8<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  const char *v20;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v23)(unint64_t, unint64_t);
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  unint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  const char *v34;
  void (*v35)(uint64_t, unint64_t *, unint64_t);
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  uint64_t v44;

  v40 = a5;
  v41 = a7;
  v38 = a2;
  v44 = a1;
  v42 = a9;
  v13 = MEMORY[0x1E0C80A78](a1);
  v14 = MEMORY[0x1E0C80A78](v13);
  v16 = (char *)&v33 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v43 = associated type descriptor for SIMDScalar.SIMD8Storage;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v20, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  v39 = a3;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  v24 = swift_getAssociatedTypeWitness(255, a8, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, v43);
  v34 = a8;
  v43 = a4;
  v36 = v24;
  v25 = swift_getAssociatedConformanceWitness((uint64_t)a8, (uint64_t)a4, v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v26 = 0;
  v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  v27 = v41;
  v28 = v43;
  do
  {
    v29 = swift_checkMetadataState(0, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(_QWORD *)(v27 + 16) + 304))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(_QWORD *)(v40 + 8) + 80))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v18, v26++, v37, AssociatedConformanceWitness);
  }
  while (v26 != 8);
  v31 = type metadata accessor for SIMD8(0, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v31 - 8) + 8))(v44, v31);
}

uint64_t SIMD8.debugDescription.getter(uint64_t a1)
{
  Class *v1;
  size_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t *TypeName;
  uint64_t v98;
  uint8x16_t *v99;
  uint64_t v100;
  uint64_t v101;
  uint8x16_t *v102;
  char v103;
  uint8x16_t *v104;
  uint8x16_t *v105;
  unsigned __int8 v106;
  int v107;
  uint64_t v108;
  uint8x16_t *v109;
  BOOL v110;
  unsigned int v111;
  unsigned int v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  char *v116;
  _QWORD *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int64_t v122;
  int64_t v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  const char *v139;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v142)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v143;
  unint64_t v144;
  void (*v145)(uint64_t, unint64_t *, unint64_t);
  _QWORD *v146;
  uint64_t *v147;
  swift::SwiftError **v148;
  _QWORD *DynamicType;
  uint64_t *v150;
  Class *v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  void (*v159)(uint64_t, unint64_t *, unint64_t);
  uint64_t v160;
  unint64_t object;
  unint64_t countAndFlagsBits;
  uint64_t v163;
  unint64_t v164;
  uint64_t v165;
  uint64_t *v166;
  Class *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  char *v172;
  uint64_t *v173;
  Class *v174;
  uint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  char v183;
  unint64_t v184;
  unint64_t v185;
  uint64_t *v186;
  Class *v187;
  uint64_t v188;
  uint64_t v189;
  unint64_t v190;
  unint64_t v191;
  uint64_t v192;
  char *v193;
  unint64_t v194;
  unint64_t v195;
  char v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t *v199;
  _QWORD *v200;
  void *v201;
  uint64_t v202;
  unint64_t v203;
  const void *v204;
  uint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  _QWORD *v210;
  uint64_t *v211;
  swift::SwiftError **v212;
  _QWORD *v213;
  Class *v214;
  uint64_t v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t *v221;
  void *v222;
  uint64_t *v223;
  Class *v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t *v227;
  Class *v228;
  uint64_t *v229;
  Class *v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  unint64_t v234;
  uint64_t v235;
  char *v236;
  const void *v237;
  unint64_t v238;
  _QWORD *v239;
  uint64_t *v240;
  swift::SwiftError **v241;
  _QWORD *v242;
  Class *v243;
  uint64_t v244;
  uint64_t v245;
  unint64_t v246;
  unint64_t v247;
  uint64_t v248;
  char *v249;
  uint64_t *v250;
  void *v251;
  unint64_t v252;
  const void *v253;
  _QWORD *v254;
  uint64_t *v255;
  swift::SwiftError **v256;
  _QWORD *v257;
  Class *v258;
  uint64_t v259;
  uint64_t v260;
  unint64_t v261;
  unint64_t v262;
  uint64_t v263;
  char *v264;
  uint64_t *v265;
  void *v266;
  unint64_t v267;
  const void *v268;
  _QWORD *v269;
  uint64_t *v270;
  swift::SwiftError **v271;
  _QWORD *v272;
  Class *v273;
  uint64_t v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  uint64_t v278;
  char *v279;
  uint64_t *v280;
  void *v281;
  unint64_t v282;
  const void *v283;
  _QWORD *v284;
  uint64_t *v285;
  swift::SwiftError **v286;
  _QWORD *v287;
  Class *v288;
  uint64_t v289;
  uint64_t v290;
  unint64_t v291;
  unint64_t v292;
  uint64_t v293;
  char *v294;
  uint64_t *v295;
  void *v296;
  unint64_t v297;
  const void *v298;
  _QWORD *v299;
  uint64_t *v300;
  swift::SwiftError **v301;
  _QWORD *v302;
  Class *v303;
  uint64_t v304;
  uint64_t v305;
  unint64_t v306;
  unint64_t v307;
  uint64_t v308;
  char *v309;
  uint64_t *v310;
  void *v311;
  unint64_t v312;
  const void *v313;
  _QWORD *v314;
  uint64_t *v315;
  swift::SwiftError **v316;
  _QWORD *v317;
  Class *v318;
  uint64_t v319;
  uint64_t v320;
  unint64_t v321;
  unint64_t v322;
  uint64_t v323;
  char *v324;
  uint64_t *v325;
  void *v326;
  unint64_t v327;
  uint64_t *v329;
  Class *v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t *v333;
  Class *v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t *v337;
  Class *v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t *v341;
  Class *v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t *v345;
  Class *v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t *v349;
  Class *v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t *v353;
  Class *v354;
  uint64_t *v355;
  Class *v356;
  uint64_t *v357;
  Class *v358;
  uint64_t *v359;
  Class *v360;
  uint64_t *v361;
  Class *v362;
  uint64_t *v363;
  Class *v364;
  uint64_t *v365;
  Class *v366;
  uint64_t *v367;
  Class *v368;
  uint64_t *v369;
  Class *v370;
  uint64_t *v371;
  Class *v372;
  uint64_t *v373;
  Class *v374;
  uint64_t *v375;
  Class *v376;
  _QWORD *v377;
  void *v378;
  uint64_t v379;
  _QWORD *v380;
  void *v381;
  const void *v382;
  uint64_t v383;
  _QWORD *v384;
  void *v385;
  const void *v386;
  uint64_t v387;
  _QWORD *v388;
  void *v389;
  const void *v390;
  uint64_t v391;
  _QWORD *v392;
  void *v393;
  const void *v394;
  uint64_t v395;
  _QWORD *v396;
  void *v397;
  const void *v398;
  uint64_t v399;
  _QWORD *v400;
  void *v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t *v404;
  uint64_t *v405;
  uint64_t *v406;
  uint64_t *v407;
  uint64_t *v408;
  uint64_t *v409;
  uint64_t *v410;
  uint64_t *v411;
  uint64_t *v412;
  uint64_t *v413;
  uint64_t *v414;
  uint64_t *v415;
  uint64_t *v416;
  uint64_t *v417;
  uint64_t *v418;
  uint64_t *v419;
  uint64_t *v420;
  uint64_t *v421;
  uint64_t *v422;
  uint64_t *v423;
  uint64_t *v424;
  uint64_t *v425;
  uint64_t *v426;
  uint64_t *v427;
  uint64_t *v428;
  uint64_t *v429;
  uint64_t *v430;
  uint64_t *v431;
  uint64_t *v432;
  uint64_t *v433;
  uint64_t *v434;
  char *v435;
  char *v436;
  uint64_t v437;
  char *v438;
  char *v439;
  char *v440;
  char *v441;
  char *v442;
  uint64_t *v443;
  Swift::String v444;
  uint64_t *v445;
  uint64_t v446;
  __int128 v447;
  __int128 v448;
  uint64_t v449;
  unint64_t v450;
  unint64_t v451;

  v437 = a1;
  v1 = *(Class **)(a1 + 16);
  v2 = *((_QWORD *)*(v1 - 1) + 8);
  v3 = MEMORY[0x1E0C80A78](a1);
  v411 = (uint64_t *)((char *)&v403 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  v4 = MEMORY[0x1E0C80A78](v3);
  v419 = (uint64_t *)((char *)&v403 - v5);
  v6 = MEMORY[0x1E0C80A78](v4);
  v427 = (uint64_t *)((char *)&v403 - v7);
  v8 = MEMORY[0x1E0C80A78](v6);
  v434 = (uint64_t *)((char *)&v403 - v9);
  v10 = MEMORY[0x1E0C80A78](v8);
  v442 = (char *)&v403 - v11;
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (uint64_t *)((char *)&v403 - v13);
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (uint64_t *)((char *)&v403 - v16);
  v18 = MEMORY[0x1E0C80A78](v15);
  v426 = (uint64_t *)((char *)&v403 - v19);
  v20 = MEMORY[0x1E0C80A78](v18);
  v433 = (uint64_t *)((char *)&v403 - v21);
  v22 = MEMORY[0x1E0C80A78](v20);
  v441 = (char *)&v403 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v409 = (uint64_t *)((char *)&v403 - v25);
  v26 = MEMORY[0x1E0C80A78](v24);
  v417 = (uint64_t *)((char *)&v403 - v27);
  v28 = MEMORY[0x1E0C80A78](v26);
  v425 = (uint64_t *)((char *)&v403 - v29);
  v30 = MEMORY[0x1E0C80A78](v28);
  v432 = (uint64_t *)((char *)&v403 - v31);
  v32 = MEMORY[0x1E0C80A78](v30);
  v440 = (char *)&v403 - v33;
  v34 = MEMORY[0x1E0C80A78](v32);
  v408 = (uint64_t *)((char *)&v403 - v35);
  v36 = MEMORY[0x1E0C80A78](v34);
  v416 = (uint64_t *)((char *)&v403 - v37);
  v38 = MEMORY[0x1E0C80A78](v36);
  v424 = (uint64_t *)((char *)&v403 - v39);
  v40 = MEMORY[0x1E0C80A78](v38);
  v431 = (uint64_t *)((char *)&v403 - v41);
  v42 = MEMORY[0x1E0C80A78](v40);
  v44 = (char *)&v403 - v43;
  v45 = MEMORY[0x1E0C80A78](v42);
  v407 = (uint64_t *)((char *)&v403 - v46);
  v47 = MEMORY[0x1E0C80A78](v45);
  v415 = (uint64_t *)((char *)&v403 - v48);
  v49 = MEMORY[0x1E0C80A78](v47);
  v423 = (uint64_t *)((char *)&v403 - v50);
  v51 = MEMORY[0x1E0C80A78](v49);
  v430 = (uint64_t *)((char *)&v403 - v52);
  v53 = MEMORY[0x1E0C80A78](v51);
  v439 = (char *)&v403 - v54;
  v55 = MEMORY[0x1E0C80A78](v53);
  v406 = (uint64_t *)((char *)&v403 - v56);
  v57 = MEMORY[0x1E0C80A78](v55);
  v414 = (uint64_t *)((char *)&v403 - v58);
  v59 = MEMORY[0x1E0C80A78](v57);
  v422 = (uint64_t *)((char *)&v403 - v60);
  v61 = MEMORY[0x1E0C80A78](v59);
  v429 = (uint64_t *)((char *)&v403 - v62);
  v63 = MEMORY[0x1E0C80A78](v61);
  v438 = (char *)&v403 - v64;
  v65 = MEMORY[0x1E0C80A78](v63);
  v405 = (uint64_t *)((char *)&v403 - v66);
  v67 = MEMORY[0x1E0C80A78](v65);
  v413 = (uint64_t *)((char *)&v403 - v68);
  v69 = MEMORY[0x1E0C80A78](v67);
  v421 = (uint64_t *)((char *)&v403 - v70);
  v71 = MEMORY[0x1E0C80A78](v69);
  v428 = (uint64_t *)((char *)&v403 - v72);
  v73 = MEMORY[0x1E0C80A78](v71);
  v436 = (char *)&v403 - v74;
  v75 = MEMORY[0x1E0C80A78](v73);
  v404 = (uint64_t *)((char *)&v403 - v76);
  v77 = MEMORY[0x1E0C80A78](v75);
  v412 = (uint64_t *)((char *)&v403 - v78);
  v79 = MEMORY[0x1E0C80A78](v77);
  v420 = (uint64_t *)((char *)&v403 - v80);
  v81 = MEMORY[0x1E0C80A78](v79);
  v83 = (char *)&v403 - v82;
  v84 = MEMORY[0x1E0C80A78](v81);
  v443 = (uint64_t *)((char *)&v403 - v85);
  MEMORY[0x1E0C80A78](v84);
  v87 = (char *)&v403 - v86;
  v88 = specialized static String._createEmpty(withInitialCapacity:)(41);
  v92 = v89;
  v450 = v88;
  v451 = v89;
  v93 = HIBYTE(v89) & 0xF;
  if ((v89 & 0x2000000000000000) == 0)
    v93 = v88 & 0xFFFFFFFFFFFFLL;
  v410 = v14;
  v418 = v17;
  if (v93 || (v88 & ~v89 & 0x2000000000000000) != 0)
  {
    if ((v89 & 0x2000000000000000) == 0
      || (v94 = specialized _SmallString.init(_:appending:)(v88, v89, 0x3C38444D4953uLL, 0xE600000000000000),
          (v90 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE600000000000000, v89, v90, v91);
      _StringGuts.append(_:)(0x3C38444D4953, 0xE600000000000000, 0, 6);
      swift_bridgeObjectRelease_n(0xE600000000000000, 2);
    }
    else
    {
      v95 = v94;
      v96 = v89;
      swift_bridgeObjectRelease(v92);
      swift_bridgeObjectRelease(0xE600000000000000);
      v450 = v95;
      v451 = v96;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v89);
    v450 = 0x3C38444D4953;
    v451 = 0xE600000000000000;
  }
  TypeName = (uint64_t *)swift_getTypeName(v1, 0);
  if (v98 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v99 = (uint8x16_t *)TypeName;
  v100 = v98;
  if (!_allASCII(_:)(TypeName, v98) && v100)
  {
    v101 = 0;
    v102 = (uint8x16_t *)((char *)v99 + v100);
    v103 = 1;
    v104 = v99;
    v105 = v99;
    while (1)
    {
      v107 = v105->i8[0];
      v105 = (uint8x16_t *)((char *)v105 + 1);
      v106 = v107;
      if ((v107 & 0x80000000) == 0)
      {
        v108 = 1;
        goto LABEL_15;
      }
      if ((v106 + 11) <= 0xCCu)
        goto LABEL_59;
      if (v106 <= 0xDFu)
      {
        if (v105 == v102 || (v105->i8[0] & 0xC0) != 0x80)
          goto LABEL_59;
        v103 = 0;
        v105 = (uint8x16_t *)&v104->i16[1];
        v108 = 2;
      }
      else
      {
        if (v106 == 224)
        {
          if (v105 == v102
            || ((v109 = (uint8x16_t *)&v104->i16[1], (v104->i8[1] + 64) >= 0xE0u)
              ? (v110 = v109 == v102)
              : (v110 = 1),
                v110))
          {
LABEL_59:
            v117 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
            swift_willThrow();
            swift_errorRelease(v117);
            v118 = specialized Collection.subscript.getter(v101, (uint64_t)v99, v100);
            v122 = findInvalidRange #1 (_:) in validateUTF8(_:)(v118, v119, v120, v121);
            v113 = repairUTF8(_:firstKnownBrokenRange:)(v99->i8, v100, v122, v123);
            goto LABEL_60;
          }
          goto LABEL_40;
        }
        if (v106 <= 0xECu)
          goto LABEL_36;
        if (v106 == 237)
        {
          if (v105 == v102)
            goto LABEL_59;
          v111 = v104->u8[1];
          if (v111 > 0x9F)
            goto LABEL_59;
LABEL_38:
          if ((v111 & 0xC0) != 0x80)
            goto LABEL_59;
          v109 = (uint8x16_t *)&v104->i16[1];
          if (&v104->i16[1] == (__int16 *)v102)
            goto LABEL_59;
LABEL_40:
          if ((v109->i8[0] & 0xC0) != 0x80)
            goto LABEL_59;
          v103 = 0;
          v105 = (uint8x16_t *)((char *)v104->i32 + 3);
          v108 = 3;
          goto LABEL_15;
        }
        if (v106 <= 0xEFu)
        {
LABEL_36:
          if (v105 == v102)
            goto LABEL_59;
          LOBYTE(v111) = v104->i8[1];
          goto LABEL_38;
        }
        if (v106 == 240)
        {
          if (v105 == v102 || (v104->i8[1] + 64) < 0xD0u)
            goto LABEL_59;
        }
        else
        {
          if ((v106 + 15) > 2u)
          {
            if (v105 == v102)
              goto LABEL_59;
            v112 = v104->u8[1];
            if (v112 > 0x8F)
              goto LABEL_59;
          }
          else
          {
            if (v105 == v102)
              goto LABEL_59;
            LOBYTE(v112) = v104->i8[1];
          }
          if ((v112 & 0xC0) != 0x80)
            goto LABEL_59;
        }
        if (&v104->i16[1] == (__int16 *)v102
          || (v104->i8[2] & 0xC0) != 0x80
          || (uint8x16_t *)((char *)v104->i32 + 3) == v102
          || (v104->i8[3] & 0xC0) != 0x80)
        {
          goto LABEL_59;
        }
        v103 = 0;
        v105 = (uint8x16_t *)((char *)v104->i64 + 4);
        v108 = 4;
      }
LABEL_15:
      v101 += v108;
      v104 = v105;
      if (v105 == v102)
        goto LABEL_58;
    }
  }
  v103 = 1;
LABEL_58:
  v113 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v99, v100, v103 & 1);
LABEL_60:
  v124 = v113;
  v125 = v114;
  v126 = v451;
  v127 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v127 = v450 & 0xFFFFFFFFFFFFLL;
  if (v127 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    if ((v451 & 0x2000000000000000) != 0)
    {
      if ((v114 & 0x2000000000000000) != 0)
      {
        v129 = specialized _SmallString.init(_:appending:)(v450, v451, v113, v114);
        if ((v115 & 1) == 0)
        {
          v130 = v129;
          v131 = v114;
          swift_bridgeObjectRelease(v126);
          swift_bridgeObjectRelease(v125);
          v450 = v130;
          v451 = v131;
          v125 = v131;
          v124 = v130;
          goto LABEL_73;
        }
        goto LABEL_71;
      }
    }
    else if ((v114 & 0x2000000000000000) != 0)
    {
LABEL_71:
      v128 = HIBYTE(v125) & 0xF;
      goto LABEL_72;
    }
    v128 = v113 & 0xFFFFFFFFFFFFLL;
LABEL_72:
    swift_bridgeObjectRetain(v125, v114, v115, v116);
    _StringGuts.append(_:)(v124, v125, 0, v128);
    swift_bridgeObjectRelease_n(v125, 2);
    v124 = v450;
    v125 = v451;
    goto LABEL_73;
  }
  swift_bridgeObjectRelease(v451);
  v450 = v124;
  v451 = v125;
LABEL_73:
  v135 = HIBYTE(v125) & 0xF;
  if ((v125 & 0x2000000000000000) == 0)
    v135 = v124 & 0xFFFFFFFFFFFFLL;
  v435 = v44;
  if (v135 || (v124 & ~v125 & 0x2000000000000000) != 0)
  {
    if ((v125 & 0x2000000000000000) == 0
      || (v136 = specialized _SmallString.init(_:appending:)(v124, v125, 0x283EuLL, 0xE200000000000000),
          (v133 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v132, v133, v134);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v137 = v136;
      v138 = v132;
      swift_bridgeObjectRelease(v125);
      swift_bridgeObjectRelease(0xE200000000000000);
      v450 = v137;
      v451 = v138;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v125);
    v450 = 10302;
    v451 = 0xE200000000000000;
  }
  v139 = *(const char **)(v437 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v139, (uint64_t)v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v139, (uint64_t)v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v142 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v143 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v144 = AssociatedConformanceWitness;
  v145 = v142;
  ((void (*)(_QWORD))v142)(0);
  v445 = (uint64_t *)v1;
  v146 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v146, v87, v2);
  v147 = v445;
  v148 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  DynamicType = (_QWORD *)swift_getDynamicType(v148, v147, 1);
  LODWORD(v147) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v147)
  {
    v150 = v443;
    memcpy(v443, v87, v2);
    v151 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v151, 7uLL);
    v152 = (uint64_t)v445;
    v153 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v155 = (*(uint64_t (**)(uint64_t, uint64_t))(v153 + 8))(v152, v153);
    v156 = v154;
    v157 = v451;
    v158 = HIBYTE(v451) & 0xF;
    if ((v451 & 0x2000000000000000) == 0)
      v158 = v450 & 0xFFFFFFFFFFFFLL;
    if (v158 || (v450 & ~v451 & 0x2000000000000000) != 0)
    {
      v159 = v145;
      if ((v451 & 0x2000000000000000) == 0)
      {
        if ((v154 & 0x2000000000000000) != 0)
        {
          v160 = HIBYTE(v154) & 0xF;
LABEL_124:
          _StringGuts.append(_:)(v155, v156, 0, v160);
          swift_bridgeObjectRelease(v156);
          goto LABEL_125;
        }
LABEL_102:
        v160 = v155 & 0xFFFFFFFFFFFFLL;
        goto LABEL_124;
      }
      if ((v154 & 0x2000000000000000) == 0)
        goto LABEL_102;
      v181 = specialized _SmallString.init(_:appending:)(v450, v451, v155, v154);
      if ((v183 & 1) != 0)
      {
        v160 = HIBYTE(v156) & 0xF;
        v150 = v443;
        v159 = v145;
        goto LABEL_124;
      }
      v184 = v181;
      v185 = v182;
      swift_bridgeObjectRelease(v156);
      swift_bridgeObjectRelease(v157);
      v450 = v184;
      v451 = v185;
      v150 = v443;
    }
    else
    {
      swift_bridgeObjectRelease(v451);
      v450 = v155;
      v451 = v156;
    }
    v159 = v145;
LABEL_125:
    v199 = v143;
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_131;
  }
  memcpy(v83, v87, v2);
  if ((swift_dynamicCast((char *)&v444, (uint64_t *)v83, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    countAndFlagsBits = v444._countAndFlagsBits;
    object = (unint64_t)v444._object;
    v163 = v451;
    v164 = HIBYTE(v451) & 0xF;
    if ((v451 & 0x2000000000000000) == 0)
      v164 = v450 & 0xFFFFFFFFFFFFLL;
    v150 = v443;
    v159 = v145;
    if (!v164 && (v450 & ~v451 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v451);
      v450 = countAndFlagsBits;
      v451 = object;
      goto LABEL_130;
    }
    if ((v451 & 0x2000000000000000) == 0)
    {
      if (((uint64_t)v444._object & 0x2000000000000000) != 0)
      {
        v165 = ((unint64_t)v444._object >> 56) & 0xF;
LABEL_129:
        _StringGuts.append(_:)(countAndFlagsBits, object, 0, v165);
        swift_bridgeObjectRelease(object);
        goto LABEL_130;
      }
LABEL_114:
      v165 = v444._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      goto LABEL_129;
    }
    if (((uint64_t)v444._object & 0x2000000000000000) == 0)
      goto LABEL_114;
    v194 = specialized _SmallString.init(_:appending:)(v450, v451, v444._countAndFlagsBits, (unint64_t)v444._object);
    if ((v196 & 1) != 0)
    {
      v165 = HIBYTE(object) & 0xF;
      v150 = v443;
      v159 = v145;
      goto LABEL_129;
    }
    v197 = v194;
    v198 = v195;
    swift_bridgeObjectRelease(object);
    swift_bridgeObjectRelease(v163);
    v450 = v197;
    v451 = v198;
  }
  else
  {
    v166 = v420;
    memcpy(v420, v87, v2);
    v167 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v166, v1, v167, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v168 = (uint64_t)v445;
      v169 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v169 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v168, v169);
    }
    else
    {
      v449 = 0;
      v447 = 0u;
      v448 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
      v173 = v412;
      memcpy(v412, v87, v2);
      v174 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
      if (swift_dynamicCast((char *)&v447, v173, v1, v174, 6uLL))
      {
        outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
        v175 = (uint64_t)v445;
        v176 = v446;
        __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
        v178 = (*(uint64_t (**)(uint64_t, uint64_t))(v176 + 8))(v175, v176);
        v179 = v177;
        v180 = HIBYTE(v451) & 0xF;
        if ((v451 & 0x2000000000000000) == 0)
          v180 = v450 & 0xFFFFFFFFFFFFLL;
        if (v180 || (v450 & ~v451 & 0x2000000000000000) != 0)
        {
          _StringGuts.append(_:)(v178, v177);
          swift_bridgeObjectRelease(v179);
        }
        else
        {
          swift_bridgeObjectRelease(v451);
          v450 = v178;
          v451 = v179;
        }
        v150 = v443;
        v159 = v145;
        __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
        goto LABEL_130;
      }
      v449 = 0;
      v447 = 0u;
      v448 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?);
      v186 = v404;
      memcpy(v404, v87, v2);
      v187 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
      if (!swift_dynamicCast((char *)&v447, v186, v1, v187, 6uLL))
      {
        v449 = 0;
        v447 = 0u;
        v448 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((_QWORD *)&v448 + 1) = v1;
        v200 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
        memcpy(v200, v87, v2);
        Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
        v201 = v444._object;
        v202 = v446;
        ((void (*)(char *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v87, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
        swift_release(v202);
        swift_release((uint64_t)v201);
        goto LABEL_100;
      }
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v188 = (uint64_t)v445;
      v189 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      v190 = (*(uint64_t (**)(uint64_t, uint64_t))(v189 + 8))(v188, v189);
      v192 = v191;
      specialized String.write<A>(to:)(&v450, v190, v191, v193);
      swift_bridgeObjectRelease(v192);
    }
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  }
LABEL_100:
  v150 = v443;
  v159 = v145;
LABEL_130:
  v199 = v143;
LABEL_131:
  v203 = v144;
  v204 = v436;
  v205 = v451;
  v206 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v206 = v450 & 0xFFFFFFFFFFFFLL;
  if (v206 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    if ((v451 & 0x2000000000000000) == 0
      || (v207 = specialized _SmallString.init(_:appending:)(v450, v451, 0x202CuLL, 0xE200000000000000),
          (v171 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v170, v171, v172);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v208 = v207;
      v209 = v170;
      swift_bridgeObjectRelease(v205);
      swift_bridgeObjectRelease(0xE200000000000000);
      v450 = v208;
      v451 = v209;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236;
    v451 = 0xE200000000000000;
  }
  v159(1, v199, v203);
  v445 = (uint64_t *)v1;
  v210 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v210, v204, v2);
  v211 = v445;
  v212 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v213 = (_QWORD *)swift_getDynamicType(v212, v211, 1);
  LODWORD(v211) = swift_isOptionalType(v213);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v211)
  {
    memcpy(v150, v204, v2);
    v214 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v214, 7uLL);
    v215 = (uint64_t)v445;
    v216 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v218 = (*(uint64_t (**)(uint64_t, uint64_t))(v216 + 8))(v215, v216);
    v219 = v217;
    v220 = HIBYTE(v451) & 0xF;
    if ((v451 & 0x2000000000000000) == 0)
      v220 = v450 & 0xFFFFFFFFFFFFLL;
    if (v220 || (v450 & ~v451 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v218, v217);
      swift_bridgeObjectRelease(v219);
    }
    else
    {
      swift_bridgeObjectRelease(v451);
      v450 = v218;
      v451 = v219;
    }
    goto LABEL_154;
  }
  v221 = v428;
  memcpy(v428, v204, v2);
  if ((swift_dynamicCast((char *)&v444, v221, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v222 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v222);
    goto LABEL_155;
  }
  v223 = v421;
  memcpy(v421, v204, v2);
  v224 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v447, v223, v1, v224, 6uLL))
  {
    outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
    v225 = (uint64_t)v445;
    v226 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v226 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v225, v226);
LABEL_154:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_155;
  }
  v449 = 0;
  v447 = 0u;
  v448 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
  v227 = v413;
  memcpy(v413, v204, v2);
  v228 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v447, v227, v1, v228, 6uLL)
    || (v449 = 0,
        v447 = 0u,
        v448 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?), v229 = v405, memcpy(v405, v204, v2), v230 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v447, v229, v1, v230, 6uLL)))
  {
    outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
    v231 = (uint64_t)v445;
    v232 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v233 = (*(uint64_t (**)(uint64_t, uint64_t))(v232 + 8))(v231, v232);
    v235 = v234;
    specialized String.write<A>(to:)(&v450, v233, v234, v236);
    swift_bridgeObjectRelease(v235);
    goto LABEL_154;
  }
  v449 = 0;
  v447 = 0u;
  v448 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((_QWORD *)&v448 + 1) = v1;
  v377 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
  memcpy(v377, v204, v2);
  Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
  v378 = v444._object;
  v379 = v446;
  ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v204, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v379);
  swift_release((uint64_t)v378);
LABEL_155:
  v237 = v438;
  v238 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v238 = v450 & 0xFFFFFFFFFFFFLL;
  if (v238 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236;
    v451 = 0xE200000000000000;
  }
  v159(2, v199, v203);
  v445 = (uint64_t *)v1;
  v239 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v239, v237, v2);
  v240 = v445;
  v241 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v242 = (_QWORD *)swift_getDynamicType(v241, v240, 1);
  LODWORD(v240) = swift_isOptionalType(v242);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v240)
  {
    memcpy(v150, v237, v2);
    v243 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v243, 7uLL);
LABEL_162:
    v244 = (uint64_t)v445;
    v245 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v246 = (*(uint64_t (**)(uint64_t, uint64_t))(v245 + 8))(v244, v245);
    v248 = v247;
    specialized String.write<A>(to:)(&v450, v246, v247, v249);
    swift_bridgeObjectRelease(v248);
LABEL_163:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_166;
  }
  v250 = v429;
  memcpy(v429, v237, v2);
  if ((swift_dynamicCast((char *)&v444, v250, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v251 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v251);
  }
  else
  {
    v329 = v422;
    memcpy(v422, v237, v2);
    v330 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v329, v1, v330, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v331 = (uint64_t)v445;
      v332 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v332 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v331, v332);
      goto LABEL_163;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
    v353 = v414;
    memcpy(v414, v237, v2);
    v354 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v353, v1, v354, 6uLL)
      || (v449 = 0,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?), v355 = v406, memcpy(v406, v237, v2), v356 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v447, v355, v1, v356, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_162;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v448 + 1) = v1;
    v380 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v380, v237, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v381 = v444._object;
    v382 = v237;
    v383 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v382, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v383);
    swift_release((uint64_t)v381);
  }
LABEL_166:
  v252 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v252 = v450 & 0xFFFFFFFFFFFFLL;
  v253 = v439;
  if (v252 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236;
    v451 = 0xE200000000000000;
  }
  v159(3, v199, v203);
  v445 = (uint64_t *)v1;
  v254 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v254, v253, v2);
  v255 = v445;
  v256 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v257 = (_QWORD *)swift_getDynamicType(v256, v255, 1);
  LODWORD(v255) = swift_isOptionalType(v257);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v255)
  {
    memcpy(v150, v253, v2);
    v258 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v258, 7uLL);
LABEL_173:
    v259 = (uint64_t)v445;
    v260 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v261 = (*(uint64_t (**)(uint64_t, uint64_t))(v260 + 8))(v259, v260);
    v263 = v262;
    specialized String.write<A>(to:)(&v450, v261, v262, v264);
    swift_bridgeObjectRelease(v263);
LABEL_174:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_177;
  }
  v265 = v430;
  memcpy(v430, v253, v2);
  if ((swift_dynamicCast((char *)&v444, v265, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v266 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v266);
  }
  else
  {
    v333 = v423;
    memcpy(v423, v253, v2);
    v334 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v333, v1, v334, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v335 = (uint64_t)v445;
      v336 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v336 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v335, v336);
      goto LABEL_174;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
    v357 = v415;
    memcpy(v415, v253, v2);
    v358 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v357, v1, v358, 6uLL)
      || (v449 = 0,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?), v359 = v407, memcpy(v407, v253, v2), v360 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v447, v359, v1, v360, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_173;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v448 + 1) = v1;
    v384 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v384, v253, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v385 = v444._object;
    v386 = v253;
    v387 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v386, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v387);
    swift_release((uint64_t)v385);
  }
LABEL_177:
  v267 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v267 = v450 & 0xFFFFFFFFFFFFLL;
  v268 = v435;
  if (v267 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236;
    v451 = 0xE200000000000000;
  }
  v159(4, v199, v203);
  v445 = (uint64_t *)v1;
  v269 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v269, v268, v2);
  v270 = v445;
  v271 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v272 = (_QWORD *)swift_getDynamicType(v271, v270, 1);
  LODWORD(v270) = swift_isOptionalType(v272);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v270)
  {
    memcpy(v150, v268, v2);
    v273 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v273, 7uLL);
LABEL_184:
    v274 = (uint64_t)v445;
    v275 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v276 = (*(uint64_t (**)(uint64_t, uint64_t))(v275 + 8))(v274, v275);
    v278 = v277;
    specialized String.write<A>(to:)(&v450, v276, v277, v279);
    swift_bridgeObjectRelease(v278);
LABEL_185:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_188;
  }
  v280 = v431;
  memcpy(v431, v268, v2);
  if ((swift_dynamicCast((char *)&v444, v280, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v281 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v281);
  }
  else
  {
    v337 = v424;
    memcpy(v424, v268, v2);
    v338 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v337, v1, v338, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v339 = (uint64_t)v445;
      v340 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v340 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v339, v340);
      goto LABEL_185;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
    v361 = v416;
    memcpy(v416, v268, v2);
    v362 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v361, v1, v362, 6uLL)
      || (v449 = 0,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?), v363 = v408, memcpy(v408, v268, v2), v364 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v447, v363, v1, v364, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_184;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v448 + 1) = v1;
    v388 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v388, v268, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v389 = v444._object;
    v390 = v268;
    v391 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v390, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v391);
    swift_release((uint64_t)v389);
  }
LABEL_188:
  v282 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v282 = v450 & 0xFFFFFFFFFFFFLL;
  v283 = v440;
  if (v282 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236;
    v451 = 0xE200000000000000;
  }
  v159(5, v199, v203);
  v445 = (uint64_t *)v1;
  v284 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v284, v283, v2);
  v285 = v445;
  v286 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v287 = (_QWORD *)swift_getDynamicType(v286, v285, 1);
  LODWORD(v285) = swift_isOptionalType(v287);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v285)
  {
    memcpy(v150, v283, v2);
    v288 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v288, 7uLL);
LABEL_195:
    v289 = (uint64_t)v445;
    v290 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v291 = (*(uint64_t (**)(uint64_t, uint64_t))(v290 + 8))(v289, v290);
    v293 = v292;
    specialized String.write<A>(to:)(&v450, v291, v292, v294);
    swift_bridgeObjectRelease(v293);
LABEL_196:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_199;
  }
  v295 = v432;
  memcpy(v432, v283, v2);
  if ((swift_dynamicCast((char *)&v444, v295, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v296 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v296);
  }
  else
  {
    v341 = v425;
    memcpy(v425, v283, v2);
    v342 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v341, v1, v342, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v343 = (uint64_t)v445;
      v344 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v344 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v343, v344);
      goto LABEL_196;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
    v365 = v417;
    memcpy(v417, v283, v2);
    v366 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v365, v1, v366, 6uLL)
      || (v449 = 0,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?), v367 = v409, memcpy(v409, v283, v2), v368 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v447, v367, v1, v368, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_195;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v448 + 1) = v1;
    v392 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v392, v283, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v393 = v444._object;
    v394 = v283;
    v395 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v394, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v395);
    swift_release((uint64_t)v393);
  }
LABEL_199:
  v297 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v297 = v450 & 0xFFFFFFFFFFFFLL;
  v298 = v441;
  if (v297 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236;
    v451 = 0xE200000000000000;
  }
  v159(6, v199, v203);
  v445 = (uint64_t *)v1;
  v299 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v299, v298, v2);
  v300 = v445;
  v301 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v302 = (_QWORD *)swift_getDynamicType(v301, v300, 1);
  LODWORD(v300) = swift_isOptionalType(v302);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v300)
  {
    memcpy(v150, v298, v2);
    v303 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v303, 7uLL);
LABEL_206:
    v304 = (uint64_t)v445;
    v305 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v306 = (*(uint64_t (**)(uint64_t, uint64_t))(v305 + 8))(v304, v305);
    v308 = v307;
    specialized String.write<A>(to:)(&v450, v306, v307, v309);
    swift_bridgeObjectRelease(v308);
LABEL_207:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_210;
  }
  v310 = v433;
  memcpy(v433, v298, v2);
  if ((swift_dynamicCast((char *)&v444, v310, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v311 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v311);
  }
  else
  {
    v345 = v426;
    memcpy(v426, v298, v2);
    v346 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v345, v1, v346, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v347 = (uint64_t)v445;
      v348 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v348 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v347, v348);
      goto LABEL_207;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
    v369 = v418;
    memcpy(v418, v298, v2);
    v370 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v369, v1, v370, 6uLL)
      || (v449 = 0,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?), v371 = v410, memcpy(v410, v298, v2), v372 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v447, v371, v1, v372, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_206;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v448 + 1) = v1;
    v396 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v396, v298, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v397 = v444._object;
    v398 = v298;
    v399 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v398, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v399);
    swift_release((uint64_t)v397);
  }
LABEL_210:
  v312 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v312 = v450 & 0xFFFFFFFFFFFFLL;
  v313 = v442;
  if (v312 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    v450 = 8236;
    v451 = 0xE200000000000000;
  }
  v159(7, v199, v203);
  v445 = (uint64_t *)v1;
  v314 = __swift_allocate_boxed_opaque_existential_0Tm(&v444);
  memcpy(v314, v313, v2);
  v315 = v445;
  v316 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
  v317 = (_QWORD *)swift_getDynamicType(v316, v315, 1);
  LODWORD(v315) = swift_isOptionalType(v317);
  __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
  if ((_DWORD)v315)
  {
    memcpy(v150, v313, v2);
    v318 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v444, v150, v1, v318, 7uLL);
LABEL_217:
    v319 = (uint64_t)v445;
    v320 = v446;
    __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
    v321 = (*(uint64_t (**)(uint64_t, uint64_t))(v320 + 8))(v319, v320);
    v323 = v322;
    specialized String.write<A>(to:)(&v450, v321, v322, v324);
    swift_bridgeObjectRelease(v323);
LABEL_218:
    __swift_destroy_boxed_opaque_existential_1Tm(&v444._countAndFlagsBits);
    goto LABEL_221;
  }
  v325 = v434;
  memcpy(v434, v313, v2);
  if ((swift_dynamicCast((char *)&v444, v325, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v326 = v444._object;
    String.append(_:)(v444);
    swift_bridgeObjectRelease((uint64_t)v326);
  }
  else
  {
    v349 = v427;
    memcpy(v427, v313, v2);
    v350 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v447, v349, v1, v350, 6uLL))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      v351 = (uint64_t)v445;
      v352 = v446;
      __swift_project_boxed_opaque_existential_0Tm(&v444, (uint64_t)v445);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v352 + 8))(&v450, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v351, v352);
      goto LABEL_218;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for TextOutputStreamable?);
    v373 = v419;
    memcpy(v419, v313, v2);
    v374 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v447, v373, v1, v374, 6uLL)
      || (v449 = 0,
          v447 = 0u,
          v448 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomStringConvertible?), v375 = v411, memcpy(v411, v313, v2), v376 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v447, v375, v1, v376, 6uLL)))
    {
      outlined init with take of MirrorPath(&v447, (uint64_t)&v444);
      goto LABEL_217;
    }
    v449 = 0;
    v447 = 0u;
    v448 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v447, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v448 + 1) = v1;
    v400 = __swift_allocate_boxed_opaque_existential_0Tm(&v447);
    memcpy(v400, v313, v2);
    Mirror.init(reflecting:)((uint64_t *)&v447, (uint64_t)&v444);
    v401 = v444._object;
    v402 = v446;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v313, &v444, &v450, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v402);
    swift_release((uint64_t)v401);
  }
LABEL_221:
  v327 = HIBYTE(v451) & 0xF;
  if ((v451 & 0x2000000000000000) == 0)
    v327 = v450 & 0xFFFFFFFFFFFFLL;
  if (v327 || (v450 & ~v451 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x29uLL, 0xE100000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    return v450;
  }
  else
  {
    swift_bridgeObjectRelease(v451);
    return 41;
  }
}

uint64_t SIMD8<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 16) + 72))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 8);
  v28 = type metadata accessor for SIMD8(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a6;
  v35 = a8;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  v36 = a3;
  v32 = v22;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v33, AssociatedConformanceWitness);
  }
  while (v24 != 8);
  v28 = type metadata accessor for SIMD8(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD16._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage, a2);
}

uint64_t SIMD16._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t (*SIMD16._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD16.scalarCount.getter()
{
  return 16;
}

uint64_t key path getter for SIMD16.subscript(_:) : <A>SIMD16<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v8)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v9;

  v3 = *a2;
  if ((unint64_t)*a2 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  v4 = *(const char **)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD16.subscript(_:) : <A>SIMD16<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  size_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(char *, unint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t v17;

  v4 = *(_QWORD *)(a4 + a3 - 16);
  v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v17 - v6;
  v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x283uLL, 0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD16.subscript.modify(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD16.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, uint64_t a17, const char *a18)
{
  size_t v21;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v24)(char *, uint64_t, unint64_t, unint64_t);
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;

  v31 = a8;
  v28 = a6;
  v29 = a7;
  v26 = a4;
  v27 = a5;
  v37 = a15;
  v38 = a16;
  v35 = a13;
  v36 = a14;
  v33 = a11;
  v34 = a12;
  v32 = a10;
  v30 = a9;
  v21 = *(_QWORD *)(*(_QWORD *)(a17 - 8) + 64);
  MEMORY[0x1E0C80A78](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a18, a17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a18, a17, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v21);
  v24 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v26, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v27, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v28, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v29, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v31, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 7, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v30, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 8, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v32, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 9, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v33, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 10, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v34, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 11, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v35, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 12, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v36, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 13, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v37, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 14, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v38, v21);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v24)((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 15, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD16.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v15)(uint64_t, uint64_t);

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = type metadata accessor for SIMD16(0, a3, (uint64_t)a4, v10);
  specialized SIMD16.lowHalf.setter(a1, v11);
  v13 = type metadata accessor for SIMD8(0, a3, (uint64_t)a4, v12);
  v15 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 8);
  v15(a1, v13);
  specialized SIMD16.highHalf.setter(a2, v11);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD16.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.lowHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8);
}

uint64_t SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t (*a4)(_QWORD, _QWORD, _QWORD))
{
  uint64_t v7;

  a3();
  v7 = a4(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v7 - 8) + 8))(a1, v7);
}

uint64_t SIMD16.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.highHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8);
}

uint64_t SIMD16.lowHalf.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  const char *v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v8;
  unint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v11;
  void (*v12)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v21 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = *(const char **)(v2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v8 = swift_getAssociatedTypeWitness(255, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v9 = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  v11 = swift_checkMetadataState(0, v8);
  v10(0, v11, v9);
  v12 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v12(v4, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  v13 = swift_checkMetadataState(0, v8);
  v10(1, v13, v9);
  v12(v4, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  v14 = swift_checkMetadataState(0, v8);
  v10(2, v14, v9);
  v12(v4, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  v15 = swift_checkMetadataState(0, v8);
  v10(3, v15, v9);
  v12(v4, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  v16 = swift_checkMetadataState(0, v8);
  v10(4, v16, v9);
  v12(v4, 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  v17 = swift_checkMetadataState(0, v8);
  v10(5, v17, v9);
  v12(v4, 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = swift_checkMetadataState(0, v8);
  v10(6, v18, v9);
  v12(v4, 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  v19 = swift_checkMetadataState(0, v8);
  v10(7, v19, v9);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v12)(v4, 7, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD16.lowHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, SIMD16.lowHalf.getter);
}

uint64_t key path setter for SIMD16.lowHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, specialized SIMD16.lowHalf.setter);
}

uint64_t key path setter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(_QWORD, _QWORD, _QWORD), uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v8;

  v8 = a5(0, *(_QWORD *)(a4 + a3 - 16), *(_QWORD *)(a4 + a3 - 8));
  return a6(a1, v8);
}

void (*SIMD16.lowHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD8(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD16.lowHalf.getter(a2);
  return SIMD16.lowHalf.modify;
}

void SIMD16.lowHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD16.lowHalf.setter);
}

void SIMD64.oddHalf.modify(uint64_t **a1, char a2, void (*a3)(void *, uint64_t))
{
  uint64_t *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(void *, uint64_t);

  v4 = *a1;
  v5 = (void *)(*a1)[4];
  v6 = (void *)(*a1)[5];
  v7 = (*a1)[2];
  v8 = (*a1)[3];
  v9 = **a1;
  if ((a2 & 1) != 0)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[4], v6, v7);
    a3(v5, v9);
    v10 = *(void (**)(void *, uint64_t))(v8 + 8);
    v10(v5, v7);
  }
  else
  {
    a3((void *)(*a1)[5], v9);
    v10 = *(void (**)(void *, uint64_t))(v8 + 8);
  }
  v10(v6, v7);
  free(v6);
  free(v5);
  free(v4);
}

uint64_t SIMD16.highHalf.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  const char *v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v8;
  unint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v11;
  void (*v12)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v21 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = *(const char **)(v2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v8 = swift_getAssociatedTypeWitness(255, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v9 = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  v11 = swift_checkMetadataState(0, v8);
  v10(8, v11, v9);
  v12 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v12(v4, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  v13 = swift_checkMetadataState(0, v8);
  v10(9, v13, v9);
  v12(v4, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  v14 = swift_checkMetadataState(0, v8);
  v10(10, v14, v9);
  v12(v4, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  v15 = swift_checkMetadataState(0, v8);
  v10(11, v15, v9);
  v12(v4, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  v16 = swift_checkMetadataState(0, v8);
  v10(12, v16, v9);
  v12(v4, 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  v17 = swift_checkMetadataState(0, v8);
  v10(13, v17, v9);
  v12(v4, 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = swift_checkMetadataState(0, v8);
  v10(14, v18, v9);
  v12(v4, 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  v19 = swift_checkMetadataState(0, v8);
  v10(15, v19, v9);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v12)(v4, 7, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD16.highHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, SIMD16.highHalf.getter);
}

uint64_t key path setter for SIMD16.highHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, specialized SIMD16.highHalf.setter);
}

void (*SIMD16.highHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD8(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD16.highHalf.getter(a2);
  return SIMD16.highHalf.modify;
}

void SIMD16.highHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD16.highHalf.setter);
}

uint64_t SIMD16.evenHalf.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  const char *v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v8;
  unint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v11;
  void (*v12)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v21 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = *(const char **)(v2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v8 = swift_getAssociatedTypeWitness(255, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v9 = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  v11 = swift_checkMetadataState(0, v8);
  v10(0, v11, v9);
  v12 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v12(v4, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  v13 = swift_checkMetadataState(0, v8);
  v10(2, v13, v9);
  v12(v4, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  v14 = swift_checkMetadataState(0, v8);
  v10(4, v14, v9);
  v12(v4, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  v15 = swift_checkMetadataState(0, v8);
  v10(6, v15, v9);
  v12(v4, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  v16 = swift_checkMetadataState(0, v8);
  v10(8, v16, v9);
  v12(v4, 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  v17 = swift_checkMetadataState(0, v8);
  v10(10, v17, v9);
  v12(v4, 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = swift_checkMetadataState(0, v8);
  v10(12, v18, v9);
  v12(v4, 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  v19 = swift_checkMetadataState(0, v8);
  v10(14, v19, v9);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v12)(v4, 7, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD16.evenHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, SIMD16.evenHalf.getter);
}

uint64_t key path setter for SIMD16.evenHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, specialized SIMD16.evenHalf.setter);
}

uint64_t SIMD16.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.evenHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8);
}

void (*SIMD16.evenHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD8(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD16.evenHalf.getter(a2);
  return SIMD16.evenHalf.modify;
}

void SIMD16.evenHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD16.evenHalf.setter);
}

uint64_t SIMD16.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  const char *v7;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v10)(unint64_t, unint64_t);
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void (*v14)(uint64_t, unint64_t *, unint64_t);
  uint64_t v15;
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *(const char **)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v13 = 0;
  v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  v15 = 1;
  do
  {
    v16 = swift_checkMetadataState(0, v11);
    v14(v15, v16, v12);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v6, v13, AssociatedTypeWitness, AssociatedConformanceWitness);
    v15 += 2;
    ++v13;
  }
  while (v13 != 8);
  return result;
}

uint64_t key path getter for SIMD16.oddHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, (uint64_t (*)(uint64_t))SIMD16.oddHalf.getter);
}

uint64_t key path setter for SIMD16.oddHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16, specialized SIMD16.oddHalf.setter);
}

uint64_t SIMD16.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.oddHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD8);
}

void (*SIMD16.oddHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  void *v10;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD8(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v10 = malloc(v9);
  v5[5] = v10;
  SIMD16.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD16.oddHalf.modify;
}

void SIMD16.oddHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD16.oddHalf.setter);
}

Swift::Int SIMD16.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD16<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD16<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD16Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD16<A>(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD16<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x283uLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD16<A>(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x10)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD16<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD16<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD16<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD16<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD, _QWORD, _QWORD);
  uint64_t v21;
  void (*v22)(char *, uint64_t);
  const char *v23;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v26;
  void (*v27)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v28;
  void (*v29)(char *, uint64_t);
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v36;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  char *v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;

  v3 = a3;
  v5 = a1;
  v41 = *(_QWORD *)(a3 + 16);
  v6 = MEMORY[0x1E0C80A78](a1);
  v40 = (char *)&v36 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = MEMORY[0x1E0C80A78](v6);
  v45 = (char *)&v36 - v9;
  v10 = MEMORY[0x1E0C80A78](v8);
  v12 = (char *)&v36 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v13 = MEMORY[0x1E0C80A78](v10);
  v15 = (char *)&v36 - v14;
  v16 = 0;
  v17 = 1;
  v42 = v18;
  v43 = v19;
  v20 = *(void (**)(_QWORD, _QWORD, _QWORD))(v19 + 16);
  v38 = (char *)&v36 - v14;
  v39 = v13;
  v44 = v12;
  v37 = v20;
  v21 = v41;
  v20((char *)&v36 - v14, v5, v3);
  while (1)
  {
    v20(v12, a2, v3);
    if ((v17 & 1) != 0)
    {
      v23 = *(const char **)(v3 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      v26 = v3;
      v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      v28 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v27(v16, v28, AssociatedConformanceWitness);
      v29 = *(void (**)(char *, uint64_t))(v43 + 8);
      v29(v15, v26);
      v30 = v40;
      v27(v16, v28, AssociatedConformanceWitness);
      v3 = v26;
      v12 = v44;
      v29(v44, v3);
      v20 = v37;
      v31 = AssociatedConformanceWitness;
      v5 = v39;
      v32 = (uint64_t)v28;
      a2 = v42;
      v33 = swift_getAssociatedConformanceWitness(v31, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v34 = v30;
      v15 = v38;
      v17 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v33 + 8) + 8))(v45, v34, v21);
    }
    else
    {
      v22 = *(void (**)(char *, uint64_t))(v43 + 8);
      v22(v12, v3);
      v22(v15, v3);
      v17 = 0;
    }
    if (++v16 == 16)
      break;
    v20(v15, v5, v3);
  }
  return v17 & 1;
}

uint64_t SIMD16<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 96))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 16);
  v28 = type metadata accessor for SIMD16(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD16<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 104))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 16);
  v28 = type metadata accessor for SIMD16(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD16<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  const char *v20;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v23)(unint64_t, unint64_t);
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  unint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  const char *v34;
  void (*v35)(uint64_t, unint64_t *, unint64_t);
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  uint64_t v44;

  v40 = a5;
  v41 = a7;
  v38 = a2;
  v44 = a1;
  v42 = a9;
  v13 = MEMORY[0x1E0C80A78](a1);
  v14 = MEMORY[0x1E0C80A78](v13);
  v16 = (char *)&v33 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v43 = associated type descriptor for SIMDScalar.SIMD16Storage;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v20, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v39 = a3;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  v24 = swift_getAssociatedTypeWitness(255, a8, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, v43);
  v34 = a8;
  v43 = a4;
  v36 = v24;
  v25 = swift_getAssociatedConformanceWitness((uint64_t)a8, (uint64_t)a4, v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v26 = 0;
  v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  v27 = v41;
  v28 = v43;
  do
  {
    v29 = swift_checkMetadataState(0, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(_QWORD *)(v27 + 16) + 304))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(_QWORD *)(v40 + 8) + 80))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v18, v26++, v37, AssociatedConformanceWitness);
  }
  while (v26 != 16);
  v31 = type metadata accessor for SIMD16(0, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v31 - 8) + 8))(v44, v31);
}

unint64_t SIMD16.debugDescription.getter(uint64_t a1)
{
  Class *v1;
  size_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  char *v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  char v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t *TypeName;
  uint64_t v118;
  uint8x16_t *v119;
  int64_t v120;
  int64_t v121;
  int64_t v122;
  char v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  char v133;
  unint64_t v134;
  unint64_t v135;
  uint64_t v136;
  unint64_t v137;
  unint64_t v138;
  char v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  const char *v143;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v146)(uint64_t, unint64_t *, unint64_t);
  _QWORD *v147;
  uint64_t *v148;
  swift::SwiftError **v149;
  _QWORD *DynamicType;
  uint64_t *v151;
  Class *v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  uint64_t v156;
  char *v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  char *v166;
  unint64_t object;
  unint64_t countAndFlagsBits;
  uint64_t v169;
  unint64_t v170;
  uint64_t v171;
  Class *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t *v175;
  Class *v176;
  uint64_t v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v181;
  char *v182;
  unint64_t v183;
  uint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  char v188;
  unint64_t v189;
  unint64_t v190;
  uint64_t *v191;
  Class *v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  unint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  char v200;
  unint64_t v201;
  unint64_t v202;
  _QWORD *v203;
  void *v204;
  uint64_t v205;
  uint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  char v210;
  unint64_t v211;
  unint64_t v212;
  uint64_t v213;
  const void *v214;
  _QWORD *v215;
  uint64_t *v216;
  swift::SwiftError **v217;
  _QWORD *v218;
  Class *v219;
  uint64_t v220;
  uint64_t v221;
  unint64_t v222;
  uint64_t v223;
  char *v224;
  uint64_t v225;
  unint64_t v226;
  uint64_t v227;
  unint64_t v228;
  uint64_t v229;
  uint64_t *v230;
  uint64_t v231;
  uint64_t v232;
  char *v233;
  void *v234;
  uint64_t v235;
  uint64_t v236;
  unint64_t v237;
  uint64_t *v238;
  Class *v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t *v242;
  Class *v243;
  uint64_t *v244;
  Class *v245;
  uint64_t v246;
  uint64_t v247;
  unint64_t v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  char v252;
  unint64_t v253;
  unint64_t v254;
  uint64_t v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  char v259;
  unint64_t v260;
  unint64_t v261;
  uint64_t v262;
  const void *v263;
  _QWORD *v264;
  uint64_t *v265;
  swift::SwiftError **v266;
  _QWORD *v267;
  Class *v268;
  uint64_t v269;
  uint64_t v270;
  unint64_t v271;
  unint64_t v272;
  uint64_t v273;
  char *v274;
  unint64_t v275;
  unint64_t v276;
  uint64_t v277;
  unint64_t v278;
  uint64_t v279;
  uint64_t *v280;
  uint64_t v281;
  uint64_t v282;
  char *v283;
  void *v284;
  uint64_t v285;
  uint64_t v286;
  unint64_t v287;
  uint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  char v292;
  unint64_t v293;
  unint64_t v294;
  uint64_t v295;
  const void *v296;
  _QWORD *v297;
  uint64_t *v298;
  swift::SwiftError **v299;
  _QWORD *v300;
  Class *v301;
  uint64_t v302;
  uint64_t v303;
  unint64_t v304;
  unint64_t v305;
  uint64_t v306;
  char *v307;
  uint64_t *v308;
  void *v309;
  const void *v310;
  uint64_t v311;
  unint64_t v312;
  _QWORD *v313;
  uint64_t *v314;
  swift::SwiftError **v315;
  _QWORD *v316;
  Class *v317;
  uint64_t v318;
  uint64_t v319;
  unint64_t v320;
  unint64_t v321;
  uint64_t v322;
  char *v323;
  uint64_t *v324;
  void *v325;
  const void *v326;
  uint64_t v327;
  unint64_t v328;
  _QWORD *v329;
  uint64_t *v330;
  swift::SwiftError **v331;
  _QWORD *v332;
  Class *v333;
  uint64_t v334;
  uint64_t v335;
  unint64_t v336;
  unint64_t v337;
  uint64_t v338;
  char *v339;
  uint64_t *v340;
  void *v341;
  const void *v342;
  uint64_t v343;
  unint64_t v344;
  _QWORD *v345;
  uint64_t *v346;
  swift::SwiftError **v347;
  _QWORD *v348;
  Class *v349;
  uint64_t v350;
  uint64_t v351;
  unint64_t v352;
  unint64_t v353;
  uint64_t v354;
  char *v355;
  uint64_t *v356;
  void *v357;
  const void *v358;
  uint64_t v359;
  unint64_t v360;
  _QWORD *v361;
  uint64_t *v362;
  swift::SwiftError **v363;
  _QWORD *v364;
  Class *v365;
  uint64_t v366;
  uint64_t v367;
  unint64_t v368;
  unint64_t v369;
  uint64_t v370;
  char *v371;
  uint64_t *v372;
  void *v373;
  const void *v374;
  uint64_t v375;
  unint64_t v376;
  _QWORD *v377;
  uint64_t *v378;
  swift::SwiftError **v379;
  _QWORD *v380;
  Class *v381;
  uint64_t v382;
  uint64_t v383;
  unint64_t v384;
  unint64_t v385;
  uint64_t v386;
  char *v387;
  uint64_t *v388;
  void *v389;
  const void *v390;
  uint64_t v391;
  unint64_t v392;
  _QWORD *v393;
  uint64_t *v394;
  swift::SwiftError **v395;
  _QWORD *v396;
  Class *v397;
  uint64_t v398;
  uint64_t v399;
  unint64_t v400;
  unint64_t v401;
  uint64_t v402;
  char *v403;
  char *v404;
  uint64_t *v405;
  void *v406;
  char *v407;
  char *v408;
  char *v409;
  char *v410;
  char *v411;
  char *v412;
  uint64_t *v414;
  Class *v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t *v418;
  Class *v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t *v422;
  Class *v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t *v426;
  Class *v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t *v430;
  Class *v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t *v434;
  Class *v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t *v438;
  Class *v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t *v442;
  Class *v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t *v446;
  Class *v447;
  uint64_t *v448;
  Class *v449;
  uint64_t v450;
  uint64_t v451;
  unint64_t v452;
  unint64_t v453;
  unint64_t v454;
  char *v455;
  uint64_t *v456;
  Class *v457;
  uint64_t *v458;
  Class *v459;
  uint64_t *v460;
  Class *v461;
  uint64_t *v462;
  Class *v463;
  uint64_t *v464;
  Class *v465;
  uint64_t *v466;
  Class *v467;
  uint64_t *v468;
  Class *v469;
  uint64_t *v470;
  Class *v471;
  uint64_t *v472;
  Class *v473;
  uint64_t *v474;
  Class *v475;
  uint64_t *v476;
  Class *v477;
  uint64_t *v478;
  Class *v479;
  uint64_t *v480;
  Class *v481;
  uint64_t *v482;
  Class *v483;
  _QWORD *v484;
  void *v485;
  uint64_t v486;
  _QWORD *v487;
  void *v488;
  uint64_t v489;
  _QWORD *v490;
  void *v491;
  uint64_t v492;
  _QWORD *v493;
  void *v494;
  uint64_t v495;
  _QWORD *v496;
  void *v497;
  uint64_t v498;
  _QWORD *v499;
  void *v500;
  uint64_t v501;
  _QWORD *v502;
  void *v503;
  uint64_t v504;
  _QWORD *v505;
  void *v506;
  uint64_t v507;
  _QWORD *v508;
  void *v509;
  uint64_t v510;
  uint64_t *v511;
  uint64_t *v512;
  uint64_t *v513;
  uint64_t *v514;
  uint64_t *v515;
  uint64_t *v516;
  uint64_t *v517;
  uint64_t *v518;
  uint64_t *v519;
  uint64_t *v520;
  uint64_t *v521;
  uint64_t *v522;
  uint64_t *v523;
  uint64_t *v524;
  uint64_t *v525;
  uint64_t *v526;
  uint64_t *v527;
  uint64_t *v528;
  uint64_t *v529;
  uint64_t *v530;
  uint64_t *v531;
  uint64_t *v532;
  uint64_t *v533;
  uint64_t *v534;
  uint64_t *v535;
  uint64_t *v536;
  uint64_t *v537;
  uint64_t *v538;
  uint64_t *v539;
  uint64_t *v540;
  uint64_t *v541;
  uint64_t *v542;
  uint64_t *v543;
  uint64_t *v544;
  uint64_t *v545;
  uint64_t *v546;
  uint64_t *v547;
  uint64_t *v548;
  char *v549;
  char *v550;
  char *v551;
  char *v552;
  char *v553;
  char *v554;
  char *v555;
  char *v556;
  char *v557;
  unint64_t *v558;
  uint64_t *v559;
  Swift::String v560;
  uint64_t *v561;
  uint64_t v562;
  __int128 v563;
  __int128 v564;
  uint64_t v565;
  unint64_t v566;
  unint64_t v567;

  v558 = (unint64_t *)a1;
  v1 = *(Class **)(a1 + 16);
  v2 = *((_QWORD *)*(v1 - 1) + 8);
  v3 = MEMORY[0x1E0C80A78](a1);
  v4 = MEMORY[0x1E0C80A78](v3);
  v6 = (uint64_t *)((char *)&v511 - v5);
  v7 = MEMORY[0x1E0C80A78](v4);
  v539 = (uint64_t *)((char *)&v511 - v8);
  v9 = MEMORY[0x1E0C80A78](v7);
  v548 = (uint64_t *)((char *)&v511 - v10);
  v11 = MEMORY[0x1E0C80A78](v9);
  v557 = (char *)&v511 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v520 = (uint64_t *)((char *)&v511 - v14);
  v15 = MEMORY[0x1E0C80A78](v13);
  v530 = (uint64_t *)((char *)&v511 - v16);
  v17 = MEMORY[0x1E0C80A78](v15);
  v538 = (uint64_t *)((char *)&v511 - v18);
  v19 = MEMORY[0x1E0C80A78](v17);
  v547 = (uint64_t *)((char *)&v511 - v20);
  v21 = MEMORY[0x1E0C80A78](v19);
  v556 = (char *)&v511 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v519 = (uint64_t *)((char *)&v511 - v24);
  v25 = MEMORY[0x1E0C80A78](v23);
  v529 = (uint64_t *)((char *)&v511 - v26);
  v27 = MEMORY[0x1E0C80A78](v25);
  v537 = (uint64_t *)((char *)&v511 - v28);
  v29 = MEMORY[0x1E0C80A78](v27);
  v546 = (uint64_t *)((char *)&v511 - v30);
  v31 = MEMORY[0x1E0C80A78](v29);
  v555 = (char *)&v511 - v32;
  v33 = MEMORY[0x1E0C80A78](v31);
  v518 = (uint64_t *)((char *)&v511 - v34);
  v35 = MEMORY[0x1E0C80A78](v33);
  v528 = (uint64_t *)((char *)&v511 - v36);
  v37 = MEMORY[0x1E0C80A78](v35);
  v536 = (uint64_t *)((char *)&v511 - v38);
  v39 = MEMORY[0x1E0C80A78](v37);
  v545 = (uint64_t *)((char *)&v511 - v40);
  v41 = MEMORY[0x1E0C80A78](v39);
  v554 = (char *)&v511 - v42;
  v43 = MEMORY[0x1E0C80A78](v41);
  v517 = (uint64_t *)((char *)&v511 - v44);
  v45 = MEMORY[0x1E0C80A78](v43);
  v527 = (uint64_t *)((char *)&v511 - v46);
  v47 = MEMORY[0x1E0C80A78](v45);
  v535 = (uint64_t *)((char *)&v511 - v48);
  v49 = MEMORY[0x1E0C80A78](v47);
  v544 = (uint64_t *)((char *)&v511 - v50);
  v51 = MEMORY[0x1E0C80A78](v49);
  v553 = (char *)&v511 - v52;
  v53 = MEMORY[0x1E0C80A78](v51);
  v516 = (uint64_t *)((char *)&v511 - v54);
  v55 = MEMORY[0x1E0C80A78](v53);
  v526 = (uint64_t *)((char *)&v511 - v56);
  v57 = MEMORY[0x1E0C80A78](v55);
  v534 = (uint64_t *)((char *)&v511 - v58);
  v59 = MEMORY[0x1E0C80A78](v57);
  v543 = (uint64_t *)((char *)&v511 - v60);
  v61 = MEMORY[0x1E0C80A78](v59);
  v552 = (char *)&v511 - v62;
  v63 = MEMORY[0x1E0C80A78](v61);
  v515 = (uint64_t *)((char *)&v511 - v64);
  v65 = MEMORY[0x1E0C80A78](v63);
  v525 = (uint64_t *)((char *)&v511 - v66);
  v67 = MEMORY[0x1E0C80A78](v65);
  v533 = (uint64_t *)((char *)&v511 - v68);
  v69 = MEMORY[0x1E0C80A78](v67);
  v542 = (uint64_t *)((char *)&v511 - v70);
  v71 = MEMORY[0x1E0C80A78](v69);
  v551 = (char *)&v511 - v72;
  v73 = MEMORY[0x1E0C80A78](v71);
  v514 = (uint64_t *)((char *)&v511 - v74);
  v75 = MEMORY[0x1E0C80A78](v73);
  v524 = (uint64_t *)((char *)&v511 - v76);
  v77 = MEMORY[0x1E0C80A78](v75);
  v532 = (uint64_t *)((char *)&v511 - v78);
  v79 = MEMORY[0x1E0C80A78](v77);
  v541 = (uint64_t *)((char *)&v511 - v80);
  v81 = MEMORY[0x1E0C80A78](v79);
  v550 = (char *)&v511 - v82;
  v83 = MEMORY[0x1E0C80A78](v81);
  v513 = (uint64_t *)((char *)&v511 - v84);
  v85 = MEMORY[0x1E0C80A78](v83);
  v523 = (uint64_t *)((char *)&v511 - v86);
  v87 = MEMORY[0x1E0C80A78](v85);
  v531 = (uint64_t *)((char *)&v511 - v88);
  v89 = MEMORY[0x1E0C80A78](v87);
  v540 = (uint64_t *)((char *)&v511 - v90);
  v91 = MEMORY[0x1E0C80A78](v89);
  v549 = (char *)&v511 - v92;
  v93 = MEMORY[0x1E0C80A78](v91);
  v512 = (uint64_t *)((char *)&v511 - v94);
  v95 = MEMORY[0x1E0C80A78](v93);
  v522 = (uint64_t *)((char *)&v511 - v96);
  v97 = MEMORY[0x1E0C80A78](v95);
  v99 = (char *)&v511 - v98;
  v100 = MEMORY[0x1E0C80A78](v97);
  v102 = (char *)&v511 - v101;
  v103 = MEMORY[0x1E0C80A78](v100);
  v559 = (uint64_t *)((char *)&v511 - v104);
  MEMORY[0x1E0C80A78](v103);
  v106 = (char *)&v511 - v105;
  v107 = specialized static String._createEmpty(withInitialCapacity:)(74);
  v109 = v108;
  v566 = v107;
  v567 = v108;
  v110 = HIBYTE(v108) & 0xF;
  if ((v108 & 0x2000000000000000) == 0)
    v110 = v107 & 0xFFFFFFFFFFFFLL;
  if (v110 || (v107 & ~v108 & 0x2000000000000000) != 0)
  {
    if ((v108 & 0x2000000000000000) == 0
      || (v111 = specialized _SmallString.init(_:appending:)(v107, v108, 0x3C3631444D4953uLL, 0xE700000000000000),
          (v113 & 1) != 0))
    {
      _StringGuts.append(_:)(0x3C3631444D4953, 0xE700000000000000, 0, 7);
    }
    else
    {
      v114 = v111;
      v115 = v112;
      swift_bridgeObjectRelease(v109);
      v566 = v114;
      v567 = v115;
    }
    v116 = 0xE700000000000000;
  }
  else
  {
    v566 = 0x3C3631444D4953;
    v567 = 0xE700000000000000;
    v116 = v108;
  }
  swift_bridgeObjectRelease(v116);
  TypeName = (uint64_t *)swift_getTypeName(v1, 0);
  if (v118 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v119 = (uint8x16_t *)TypeName;
  v120 = v118;
  v521 = v6;
  v511 = (uint64_t *)((char *)&v511 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  v121 = validateUTF8(_:)(TypeName, v118);
  if ((v123 & 1) != 0)
    v124 = repairUTF8(_:firstKnownBrokenRange:)(v119->i8, v120, v121, v122);
  else
    v124 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v119, v120, v121 & 1);
  v126 = v124;
  v127 = v125;
  v128 = v567;
  v129 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v129 = v566 & 0xFFFFFFFFFFFFLL;
  if (v129 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    if ((v567 & 0x2000000000000000) != 0)
    {
      if ((v125 & 0x2000000000000000) != 0)
      {
        v131 = specialized _SmallString.init(_:appending:)(v566, v567, v124, v125);
        if ((v133 & 1) == 0)
        {
          v134 = v131;
          v135 = v132;
          swift_bridgeObjectRelease(v128);
          v566 = v134;
          v567 = v135;
          swift_bridgeObjectRelease(v127);
          v127 = v135;
          v126 = v134;
          goto LABEL_27;
        }
        goto LABEL_25;
      }
    }
    else if ((v125 & 0x2000000000000000) != 0)
    {
LABEL_25:
      v130 = HIBYTE(v127) & 0xF;
      goto LABEL_26;
    }
    v130 = v124 & 0xFFFFFFFFFFFFLL;
LABEL_26:
    _StringGuts.append(_:)(v126, v127, 0, v130);
    swift_bridgeObjectRelease(v127);
    v126 = v566;
    v127 = v567;
    goto LABEL_27;
  }
  v566 = v124;
  v567 = v125;
  swift_bridgeObjectRelease(v128);
LABEL_27:
  v136 = HIBYTE(v127) & 0xF;
  if ((v127 & 0x2000000000000000) == 0)
    v136 = v126 & 0xFFFFFFFFFFFFLL;
  if (v136 || (v126 & ~v127 & 0x2000000000000000) != 0)
  {
    if ((v127 & 0x2000000000000000) == 0
      || (v137 = specialized _SmallString.init(_:appending:)(v126, v127, 0x283EuLL, 0xE200000000000000),
          (v139 & 1) != 0))
    {
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
    }
    else
    {
      v140 = v137;
      v141 = v138;
      swift_bridgeObjectRelease(v127);
      v566 = v140;
      v567 = v141;
    }
    v142 = 0xE200000000000000;
  }
  else
  {
    v566 = 10302;
    v567 = 0xE200000000000000;
    v142 = v127;
  }
  swift_bridgeObjectRelease(v142);
  v143 = (const char *)v558[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v143, (uint64_t)v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v143, (uint64_t)v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v146 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v558 = swift_checkMetadataState(0, AssociatedTypeWitness);
  ((void (*)(_QWORD))v146)(0);
  v561 = (uint64_t *)v1;
  v147 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v147, v106, v2);
  v148 = v561;
  v149 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  DynamicType = (_QWORD *)swift_getDynamicType(v149, v148, 1);
  LODWORD(v148) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if (!(_DWORD)v148)
  {
    memcpy(v102, v106, v2);
    if ((swift_dynamicCast((char *)&v560, (uint64_t *)v102, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
    {
      countAndFlagsBits = v560._countAndFlagsBits;
      object = (unint64_t)v560._object;
      v169 = v567;
      v170 = HIBYTE(v567) & 0xF;
      if ((v567 & 0x2000000000000000) == 0)
        v170 = v566 & 0xFFFFFFFFFFFFLL;
      v162 = v558;
      if (!v170 && (v566 & ~v567 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRetain((unint64_t)v560._object, v164, v165, v166);
        swift_bridgeObjectRelease(v169);
        v566 = countAndFlagsBits;
        v567 = object;
        swift_bridgeObjectRelease(object);
        v151 = v559;
        goto LABEL_90;
      }
      v151 = v559;
      if ((v567 & 0x2000000000000000) == 0)
      {
        if (((uint64_t)v560._object & 0x2000000000000000) != 0)
        {
          v171 = ((unint64_t)v560._object >> 56) & 0xF;
LABEL_85:
          _StringGuts.append(_:)(countAndFlagsBits, object, 0, v171);
          swift_bridgeObjectRelease(object);
          goto LABEL_90;
        }
LABEL_68:
        v171 = v560._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        goto LABEL_85;
      }
      if (((uint64_t)v560._object & 0x2000000000000000) == 0)
        goto LABEL_68;
      v198 = specialized _SmallString.init(_:appending:)(v566, v567, v560._countAndFlagsBits, (unint64_t)v560._object);
      if ((v200 & 1) != 0)
      {
        v171 = HIBYTE(object) & 0xF;
        v162 = v558;
        v151 = v559;
        goto LABEL_85;
      }
      v201 = v198;
      v202 = v199;
      swift_bridgeObjectRelease(v169);
      v566 = v201;
      v567 = v202;
      swift_bridgeObjectRelease(object);
    }
    else
    {
      memcpy(v99, v106, v2);
      v172 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
      if (!swift_dynamicCast((char *)&v563, (uint64_t *)v99, v1, v172, 6uLL))
      {
        v565 = 0;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
        v175 = v522;
        memcpy(v522, v106, v2);
        v176 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
        if (swift_dynamicCast((char *)&v563, v175, v1, v176, 6uLL))
        {
          outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
          v177 = (uint64_t)v561;
          v178 = v562;
          __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
          v179 = (*(uint64_t (**)(uint64_t, uint64_t))(v178 + 8))(v177, v178);
          v183 = v179;
          v159 = v180;
          v184 = v567;
          v185 = HIBYTE(v567) & 0xF;
          if ((v567 & 0x2000000000000000) == 0)
            v185 = v566 & 0xFFFFFFFFFFFFLL;
          if (v185 || (v566 & ~v567 & 0x2000000000000000) != 0)
          {
            _StringGuts.append(_:)(v179, v180);
            v151 = v559;
          }
          else
          {
            swift_bridgeObjectRetain(v180, v180, v181, v182);
            swift_bridgeObjectRelease(v184);
            v566 = v183;
            v567 = v159;
            v151 = v559;
          }
          goto LABEL_88;
        }
        v565 = 0;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?);
        v191 = v512;
        memcpy(v512, v106, v2);
        v192 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
        v193 = swift_dynamicCast((char *)&v563, v191, v1, v192, 6uLL);
        v151 = v559;
        if (v193)
        {
          outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
          v194 = (uint64_t)v561;
          v195 = v562;
          __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
          v196 = (*(uint64_t (**)(uint64_t, uint64_t))(v195 + 8))(v194, v195);
          v158 = v196;
          v159 = v155;
          v160 = v567;
          v197 = HIBYTE(v567) & 0xF;
          if ((v567 & 0x2000000000000000) == 0)
            v197 = v566 & 0xFFFFFFFFFFFFLL;
          if (v197 || (v566 & ~v567 & 0x2000000000000000) != 0)
          {
            _StringGuts.append(_:)(v196, v155);
            goto LABEL_88;
          }
LABEL_87:
          swift_bridgeObjectRetain(v155, v155, v156, v157);
          swift_bridgeObjectRelease(v160);
          v566 = v158;
          v567 = v159;
          goto LABEL_88;
        }
        v565 = 0;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((_QWORD *)&v564 + 1) = v1;
        v203 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
        memcpy(v203, v106, v2);
        Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
        v204 = v560._object;
        v205 = v562;
        ((void (*)(char *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v106, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
        swift_release(v205);
        swift_release((uint64_t)v204);
LABEL_55:
        v162 = v558;
        goto LABEL_90;
      }
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v173 = (uint64_t)v561;
      v174 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v174 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v173, v174);
      __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    }
    v151 = v559;
    goto LABEL_55;
  }
  v151 = v559;
  memcpy(v559, v106, v2);
  v152 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  swift_dynamicCast((char *)&v560, v151, v1, v152, 7uLL);
  v153 = (uint64_t)v561;
  v154 = v562;
  __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v158 = (*(uint64_t (**)(uint64_t, uint64_t))(v154 + 8))(v153, v154);
  v159 = v155;
  v160 = v567;
  v161 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v161 = v566 & 0xFFFFFFFFFFFFLL;
  if (!v161 && (v566 & ~v567 & 0x2000000000000000) == 0)
    goto LABEL_87;
  v162 = v558;
  if ((v567 & 0x2000000000000000) != 0)
  {
    if ((v155 & 0x2000000000000000) == 0)
      goto LABEL_57;
    v186 = specialized _SmallString.init(_:appending:)(v566, v567, v158, v155);
    if ((v188 & 1) != 0)
    {
      v163 = HIBYTE(v159) & 0xF;
      v162 = v558;
      v151 = v559;
      goto LABEL_81;
    }
    v189 = v186;
    v190 = v187;
    swift_bridgeObjectRelease(v160);
    v566 = v189;
    v567 = v190;
    v151 = v559;
LABEL_88:
    v162 = v558;
    goto LABEL_89;
  }
  if ((v155 & 0x2000000000000000) == 0)
  {
LABEL_57:
    v163 = v158 & 0xFFFFFFFFFFFFLL;
    goto LABEL_81;
  }
  v163 = HIBYTE(v155) & 0xF;
LABEL_81:
  _StringGuts.append(_:)(v158, v159, 0, v163);
LABEL_89:
  swift_bridgeObjectRelease(v159);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
LABEL_90:
  v206 = v567;
  v207 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v207 = v566 & 0xFFFFFFFFFFFFLL;
  if (v207 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    if ((v567 & 0x2000000000000000) == 0
      || (v208 = specialized _SmallString.init(_:appending:)(v566, v567, 0x202CuLL, 0xE200000000000000),
          (v210 & 1) != 0))
    {
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
    }
    else
    {
      v211 = v208;
      v212 = v209;
      swift_bridgeObjectRelease(v206);
      v566 = v211;
      v567 = v212;
    }
    v213 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
    v213 = v206;
  }
  swift_bridgeObjectRelease(v213);
  v214 = v549;
  v146(1, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v215 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v215, v214, v2);
  v216 = v561;
  v217 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v218 = (_QWORD *)swift_getDynamicType(v217, v216, 1);
  LODWORD(v216) = swift_isOptionalType(v218);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v216)
  {
    memcpy(v151, v214, v2);
    v219 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v219, 7uLL);
    v220 = (uint64_t)v561;
    v221 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v225 = (*(uint64_t (**)(uint64_t, uint64_t))(v221 + 8))(v220, v221);
    v226 = v222;
    v227 = v567;
    v228 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000) == 0)
      v228 = v566 & 0xFFFFFFFFFFFFLL;
    if (v228 || (v566 & ~v567 & 0x2000000000000000) != 0)
    {
      if ((v567 & 0x2000000000000000) == 0)
      {
        if ((v222 & 0x2000000000000000) != 0)
        {
          v229 = HIBYTE(v222) & 0xF;
LABEL_130:
          _StringGuts.append(_:)(v225, v226, 0, v229);
          goto LABEL_131;
        }
LABEL_117:
        v229 = v225 & 0xFFFFFFFFFFFFLL;
        goto LABEL_130;
      }
      if ((v222 & 0x2000000000000000) == 0)
        goto LABEL_117;
      v250 = specialized _SmallString.init(_:appending:)(v566, v567, v225, v222);
      if ((v252 & 1) != 0)
      {
        v229 = HIBYTE(v226) & 0xF;
        v162 = v558;
        v151 = v559;
        goto LABEL_130;
      }
      v253 = v250;
      v254 = v251;
      swift_bridgeObjectRelease(v227);
      v566 = v253;
      v567 = v254;
      v162 = v558;
      v151 = v559;
LABEL_131:
      swift_bridgeObjectRelease(v226);
      goto LABEL_132;
    }
    goto LABEL_128;
  }
  v230 = v540;
  memcpy(v540, v214, v2);
  if ((swift_dynamicCast((char *)&v560, v230, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v235 = v560._countAndFlagsBits;
    v234 = v560._object;
    v236 = v567;
    v237 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000) == 0)
      v237 = v566 & 0xFFFFFFFFFFFFLL;
    if (v237 || (v566 & ~v567 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v560._countAndFlagsBits, (unint64_t)v560._object);
    }
    else
    {
      swift_bridgeObjectRetain((unint64_t)v560._object, v231, v232, v233);
      swift_bridgeObjectRelease(v236);
      v566 = v235;
      v567 = (unint64_t)v234;
    }
    swift_bridgeObjectRelease((uint64_t)v234);
  }
  else
  {
    v238 = v531;
    memcpy(v531, v214, v2);
    v239 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v238, v1, v239, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v240 = (uint64_t)v561;
      v241 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v241 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v240, v241);
LABEL_132:
      __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
      goto LABEL_133;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v242 = v523;
    memcpy(v523, v214, v2);
    v243 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v242, v1, v243, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v244 = v513, memcpy(v513, v214, v2), v245 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v244, v1, v245, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v246 = (uint64_t)v561;
      v247 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      v248 = (*(uint64_t (**)(uint64_t, uint64_t))(v247 + 8))(v246, v247);
      v225 = v248;
      v226 = v222;
      v227 = v567;
      v249 = HIBYTE(v567) & 0xF;
      if ((v567 & 0x2000000000000000) == 0)
        v249 = v566 & 0xFFFFFFFFFFFFLL;
      if (v249 || (v566 & ~v567 & 0x2000000000000000) != 0)
      {
        _StringGuts.append(_:)(v248, v222);
        goto LABEL_131;
      }
LABEL_128:
      swift_bridgeObjectRetain(v226, v222, v223, v224);
      swift_bridgeObjectRelease(v227);
      v566 = v225;
      v567 = v226;
      goto LABEL_131;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v484 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v484, v214, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v485 = v560._object;
    v486 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v214, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v486);
    swift_release((uint64_t)v485);
  }
LABEL_133:
  v255 = v567;
  v256 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v256 = v566 & 0xFFFFFFFFFFFFLL;
  if (v256 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    if ((v567 & 0x2000000000000000) == 0
      || (v257 = specialized _SmallString.init(_:appending:)(v566, v567, 0x202CuLL, 0xE200000000000000),
          (v259 & 1) != 0))
    {
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
    }
    else
    {
      v260 = v257;
      v261 = v258;
      swift_bridgeObjectRelease(v255);
      v566 = v260;
      v567 = v261;
    }
    v262 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
    v262 = v255;
  }
  swift_bridgeObjectRelease(v262);
  v263 = v550;
  v146(2, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v264 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v264, v263, v2);
  v265 = v561;
  v266 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v267 = (_QWORD *)swift_getDynamicType(v266, v265, 1);
  LODWORD(v265) = swift_isOptionalType(v267);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v265)
  {
    memcpy(v151, v263, v2);
    v268 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v268, 7uLL);
    v269 = (uint64_t)v561;
    v270 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v271 = (*(uint64_t (**)(uint64_t, uint64_t))(v270 + 8))(v269, v270);
    v275 = v271;
    v276 = v272;
    v277 = v567;
    v278 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000) == 0)
      v278 = v566 & 0xFFFFFFFFFFFFLL;
    if (v278 || (v566 & ~v567 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v271, v272);
    }
    else
    {
      swift_bridgeObjectRetain(v272, v272, v273, v274);
      swift_bridgeObjectRelease(v277);
      v566 = v275;
      v567 = v276;
    }
    v279 = v276;
    goto LABEL_149;
  }
  v280 = v541;
  memcpy(v541, v263, v2);
  if ((swift_dynamicCast((char *)&v560, v280, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v285 = v560._countAndFlagsBits;
    v284 = v560._object;
    v286 = v567;
    v287 = HIBYTE(v567) & 0xF;
    if ((v567 & 0x2000000000000000) == 0)
      v287 = v566 & 0xFFFFFFFFFFFFLL;
    if (v287 || (v566 & ~v567 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v560._countAndFlagsBits, (unint64_t)v560._object);
    }
    else
    {
      swift_bridgeObjectRetain((unint64_t)v560._object, v281, v282, v283);
      swift_bridgeObjectRelease(v286);
      v566 = v285;
      v567 = (unint64_t)v284;
    }
    swift_bridgeObjectRelease((uint64_t)v284);
  }
  else
  {
    v414 = v532;
    memcpy(v532, v263, v2);
    v415 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v414, v1, v415, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v416 = (uint64_t)v561;
      v417 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v417 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v416, v417);
      goto LABEL_150;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v446 = v524;
    memcpy(v524, v263, v2);
    v447 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v446, v1, v447, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v448 = v514, memcpy(v514, v263, v2), v449 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v448, v1, v449, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v450 = (uint64_t)v561;
      v451 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      v452 = (*(uint64_t (**)(uint64_t, uint64_t))(v451 + 8))(v450, v451);
      v454 = v453;
      specialized String.write<A>(to:)(&v566, v452, v453, v455);
      v279 = v454;
LABEL_149:
      swift_bridgeObjectRelease(v279);
LABEL_150:
      __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
      goto LABEL_158;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v487 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v487, v263, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v488 = v560._object;
    v489 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v263, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v489);
    swift_release((uint64_t)v488);
  }
LABEL_158:
  v288 = v567;
  v289 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v289 = v566 & 0xFFFFFFFFFFFFLL;
  if (v289 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    if ((v567 & 0x2000000000000000) == 0
      || (v290 = specialized _SmallString.init(_:appending:)(v566, v567, 0x202CuLL, 0xE200000000000000),
          (v292 & 1) != 0))
    {
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
    }
    else
    {
      v293 = v290;
      v294 = v291;
      swift_bridgeObjectRelease(v288);
      v566 = v293;
      v567 = v294;
    }
    v295 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
    v295 = v288;
  }
  swift_bridgeObjectRelease(v295);
  v296 = v551;
  v146(3, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v297 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v297, v296, v2);
  v298 = v561;
  v299 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v300 = (_QWORD *)swift_getDynamicType(v299, v298, 1);
  LODWORD(v298) = swift_isOptionalType(v300);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v298)
  {
    memcpy(v151, v296, v2);
    v301 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v301, 7uLL);
LABEL_169:
    v302 = (uint64_t)v561;
    v303 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v304 = (*(uint64_t (**)(uint64_t, uint64_t))(v303 + 8))(v302, v303);
    v306 = v305;
    specialized String.write<A>(to:)(&v566, v304, v305, v307);
    swift_bridgeObjectRelease(v306);
LABEL_170:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_173;
  }
  v308 = v542;
  memcpy(v542, v296, v2);
  if ((swift_dynamicCast((char *)&v560, v308, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v309 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v309);
  }
  else
  {
    v418 = v533;
    memcpy(v533, v296, v2);
    v419 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v418, v1, v419, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v420 = (uint64_t)v561;
      v421 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v421 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v420, v421);
      goto LABEL_170;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v456 = v525;
    memcpy(v525, v296, v2);
    v457 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v456, v1, v457, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v458 = v515, memcpy(v515, v296, v2), v459 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v458, v1, v459, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_169;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v490 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v490, v296, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v491 = v560._object;
    v492 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v296, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v492);
    swift_release((uint64_t)v491);
  }
LABEL_173:
  v310 = v552;
  v311 = v567;
  v312 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v312 = v566 & 0xFFFFFFFFFFFFLL;
  if (v312 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    v311 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v311);
  v146(4, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v313 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v313, v310, v2);
  v314 = v561;
  v315 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v316 = (_QWORD *)swift_getDynamicType(v315, v314, 1);
  LODWORD(v314) = swift_isOptionalType(v316);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v314)
  {
    memcpy(v151, v310, v2);
    v317 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v317, 7uLL);
LABEL_180:
    v318 = (uint64_t)v561;
    v319 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v320 = (*(uint64_t (**)(uint64_t, uint64_t))(v319 + 8))(v318, v319);
    v322 = v321;
    specialized String.write<A>(to:)(&v566, v320, v321, v323);
    swift_bridgeObjectRelease(v322);
LABEL_181:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_184;
  }
  v324 = v543;
  memcpy(v543, v310, v2);
  if ((swift_dynamicCast((char *)&v560, v324, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v325 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v325);
  }
  else
  {
    v422 = v534;
    memcpy(v534, v310, v2);
    v423 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v422, v1, v423, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v424 = (uint64_t)v561;
      v425 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v425 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v424, v425);
      goto LABEL_181;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v460 = v526;
    memcpy(v526, v310, v2);
    v461 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v460, v1, v461, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v462 = v516, memcpy(v516, v310, v2), v463 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v462, v1, v463, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_180;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v493 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v493, v310, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v494 = v560._object;
    v495 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v310, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v495);
    swift_release((uint64_t)v494);
  }
LABEL_184:
  v326 = v553;
  v327 = v567;
  v328 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v328 = v566 & 0xFFFFFFFFFFFFLL;
  if (v328 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    v327 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v327);
  v146(5, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v329 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v329, v326, v2);
  v330 = v561;
  v331 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v332 = (_QWORD *)swift_getDynamicType(v331, v330, 1);
  LODWORD(v330) = swift_isOptionalType(v332);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v330)
  {
    memcpy(v151, v326, v2);
    v333 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v333, 7uLL);
LABEL_191:
    v334 = (uint64_t)v561;
    v335 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v336 = (*(uint64_t (**)(uint64_t, uint64_t))(v335 + 8))(v334, v335);
    v338 = v337;
    specialized String.write<A>(to:)(&v566, v336, v337, v339);
    swift_bridgeObjectRelease(v338);
LABEL_192:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_195;
  }
  v340 = v544;
  memcpy(v544, v326, v2);
  if ((swift_dynamicCast((char *)&v560, v340, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v341 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v341);
  }
  else
  {
    v426 = v535;
    memcpy(v535, v326, v2);
    v427 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v426, v1, v427, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v428 = (uint64_t)v561;
      v429 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v429 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v428, v429);
      goto LABEL_192;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v464 = v527;
    memcpy(v527, v326, v2);
    v465 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v464, v1, v465, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v466 = v517, memcpy(v517, v326, v2), v467 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v466, v1, v467, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_191;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v496 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v496, v326, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v497 = v560._object;
    v498 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v326, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v498);
    swift_release((uint64_t)v497);
  }
LABEL_195:
  v342 = v554;
  v343 = v567;
  v344 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v344 = v566 & 0xFFFFFFFFFFFFLL;
  if (v344 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    v343 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v343);
  v146(6, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v345 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v345, v342, v2);
  v346 = v561;
  v347 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v348 = (_QWORD *)swift_getDynamicType(v347, v346, 1);
  LODWORD(v346) = swift_isOptionalType(v348);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v346)
  {
    memcpy(v151, v342, v2);
    v349 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v349, 7uLL);
LABEL_202:
    v350 = (uint64_t)v561;
    v351 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v352 = (*(uint64_t (**)(uint64_t, uint64_t))(v351 + 8))(v350, v351);
    v354 = v353;
    specialized String.write<A>(to:)(&v566, v352, v353, v355);
    swift_bridgeObjectRelease(v354);
LABEL_203:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_206;
  }
  v356 = v545;
  memcpy(v545, v342, v2);
  if ((swift_dynamicCast((char *)&v560, v356, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v357 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v357);
  }
  else
  {
    v430 = v536;
    memcpy(v536, v342, v2);
    v431 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v430, v1, v431, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v432 = (uint64_t)v561;
      v433 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v433 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v432, v433);
      goto LABEL_203;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v468 = v528;
    memcpy(v528, v342, v2);
    v469 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v468, v1, v469, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v470 = v518, memcpy(v518, v342, v2), v471 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v470, v1, v471, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_202;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v499 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v499, v342, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v500 = v560._object;
    v501 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v342, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v501);
    swift_release((uint64_t)v500);
  }
LABEL_206:
  v358 = v555;
  v359 = v567;
  v360 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v360 = v566 & 0xFFFFFFFFFFFFLL;
  if (v360 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    v359 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v359);
  v146(7, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v361 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v361, v358, v2);
  v362 = v561;
  v363 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v364 = (_QWORD *)swift_getDynamicType(v363, v362, 1);
  LODWORD(v362) = swift_isOptionalType(v364);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v362)
  {
    memcpy(v151, v358, v2);
    v365 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v365, 7uLL);
LABEL_213:
    v366 = (uint64_t)v561;
    v367 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v368 = (*(uint64_t (**)(uint64_t, uint64_t))(v367 + 8))(v366, v367);
    v370 = v369;
    specialized String.write<A>(to:)(&v566, v368, v369, v371);
    swift_bridgeObjectRelease(v370);
LABEL_214:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_217;
  }
  v372 = v546;
  memcpy(v546, v358, v2);
  if ((swift_dynamicCast((char *)&v560, v372, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v373 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v373);
  }
  else
  {
    v434 = v537;
    memcpy(v537, v358, v2);
    v435 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v434, v1, v435, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v436 = (uint64_t)v561;
      v437 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v437 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v436, v437);
      goto LABEL_214;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v472 = v529;
    memcpy(v529, v358, v2);
    v473 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v472, v1, v473, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v474 = v519, memcpy(v519, v358, v2), v475 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v474, v1, v475, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_213;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v502 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v502, v358, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v503 = v560._object;
    v504 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v358, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v504);
    swift_release((uint64_t)v503);
  }
LABEL_217:
  v374 = v556;
  v375 = v567;
  v376 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v376 = v566 & 0xFFFFFFFFFFFFLL;
  if (v376 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    v375 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v375);
  v146(8, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v377 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v377, v374, v2);
  v378 = v561;
  v379 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v380 = (_QWORD *)swift_getDynamicType(v379, v378, 1);
  LODWORD(v378) = swift_isOptionalType(v380);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v378)
  {
    memcpy(v151, v374, v2);
    v381 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v381, 7uLL);
LABEL_224:
    v382 = (uint64_t)v561;
    v383 = v562;
    __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
    v384 = (*(uint64_t (**)(uint64_t, uint64_t))(v383 + 8))(v382, v383);
    v386 = v385;
    specialized String.write<A>(to:)(&v566, v384, v385, v387);
    swift_bridgeObjectRelease(v386);
LABEL_225:
    __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
    goto LABEL_228;
  }
  v388 = v547;
  memcpy(v547, v374, v2);
  if ((swift_dynamicCast((char *)&v560, v388, v1, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v389 = v560._object;
    String.append(_:)(v560);
    swift_bridgeObjectRelease((uint64_t)v389);
  }
  else
  {
    v438 = v538;
    memcpy(v538, v374, v2);
    v439 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v438, v1, v439, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v440 = (uint64_t)v561;
      v441 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v441 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v440, v441);
      goto LABEL_225;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v476 = v530;
    memcpy(v530, v374, v2);
    v477 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v563, v476, v1, v477, 6uLL)
      || (v565 = 0,
          v563 = 0u,
          v564 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?), v478 = v520, memcpy(v520, v374, v2), v479 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v563, v478, v1, v479, 6uLL)))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      goto LABEL_224;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v564 + 1) = v1;
    v505 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
    memcpy(v505, v374, v2);
    Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
    v506 = v560._object;
    v507 = v562;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v374, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v507);
    swift_release((uint64_t)v506);
  }
LABEL_228:
  v390 = v557;
  v391 = v567;
  v392 = HIBYTE(v567) & 0xF;
  if ((v567 & 0x2000000000000000) == 0)
    v392 = v566 & 0xFFFFFFFFFFFFLL;
  if (v392 || (v566 & ~v567 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    v391 = 0xE200000000000000;
  }
  else
  {
    v566 = 8236;
    v567 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v391);
  v146(9, v162, AssociatedConformanceWitness);
  v561 = (uint64_t *)v1;
  v393 = __swift_allocate_boxed_opaque_existential_0Tm(&v560);
  memcpy(v393, v390, v2);
  v394 = v561;
  v395 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v396 = (_QWORD *)swift_getDynamicType(v395, v394, 1);
  LODWORD(v394) = swift_isOptionalType(v396);
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
  if ((_DWORD)v394)
  {
    memcpy(v151, v390, v2);
    v397 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v560, v151, v1, v397, 7uLL);
  }
  else
  {
    v405 = v548;
    memcpy(v548, v390, v2);
    if (swift_dynamicCast((char *)&v560, v405, v1, (Class *)&type metadata for String, 6uLL))
    {
      v406 = v560._object;
      String.append(_:)(v560);
      swift_bridgeObjectRelease((uint64_t)v406);
      goto LABEL_239;
    }
    v442 = v539;
    memcpy(v539, v390, v2);
    v443 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v563, v442, v1, v443, 6uLL))
    {
      outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
      v444 = (uint64_t)v561;
      v445 = v562;
      __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v445 + 8))(&v566, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v444, v445);
      goto LABEL_236;
    }
    v565 = 0;
    v563 = 0u;
    v564 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for TextOutputStreamable?);
    v480 = v521;
    memcpy(v521, v390, v2);
    v481 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (!swift_dynamicCast((char *)&v563, v480, v1, v481, 6uLL))
    {
      v565 = 0;
      v563 = 0u;
      v564 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomStringConvertible?);
      v482 = v511;
      memcpy(v511, v390, v2);
      v483 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
      if (!swift_dynamicCast((char *)&v563, v482, v1, v483, 6uLL))
      {
        v565 = 0;
        v563 = 0u;
        v564 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v563, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((_QWORD *)&v564 + 1) = v1;
        v508 = __swift_allocate_boxed_opaque_existential_0Tm(&v563);
        memcpy(v508, v390, v2);
        Mirror.init(reflecting:)((uint64_t *)&v563, (uint64_t)&v560);
        v509 = v560._object;
        v510 = v562;
        ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v390, &v560, &v566, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
        swift_release(v510);
        swift_release((uint64_t)v509);
        goto LABEL_239;
      }
    }
    outlined init with take of MirrorPath(&v563, (uint64_t)&v560);
  }
  v398 = (uint64_t)v561;
  v399 = v562;
  __swift_project_boxed_opaque_existential_0Tm(&v560, (uint64_t)v561);
  v400 = (*(uint64_t (**)(uint64_t, uint64_t))(v399 + 8))(v398, v399);
  v402 = v401;
  specialized String.write<A>(to:)(&v566, v400, v401, v403);
  swift_bridgeObjectRelease(v402);
LABEL_236:
  __swift_destroy_boxed_opaque_existential_1Tm(&v560._countAndFlagsBits);
LABEL_239:
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000, v404);
  swift_bridgeObjectRelease(0xE200000000000000);
  v146(10, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v566, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000, v407);
  swift_bridgeObjectRelease(0xE200000000000000);
  v146(11, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v566, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000, v408);
  swift_bridgeObjectRelease(0xE200000000000000);
  v146(12, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v566, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000, v409);
  swift_bridgeObjectRelease(0xE200000000000000);
  v146(13, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v566, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000, v410);
  swift_bridgeObjectRelease(0xE200000000000000);
  v146(14, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v566, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x202CuLL, 0xE200000000000000, v411);
  swift_bridgeObjectRelease(0xE200000000000000);
  v146(15, v162, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v566, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v566, 0x29uLL, 0xE100000000000000, v412);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v566;
}

uint64_t SIMD16<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 16) + 72))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 16);
  v28 = type metadata accessor for SIMD16(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a6;
  v35 = a8;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  v36 = a3;
  v32 = v22;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v33, AssociatedConformanceWitness);
  }
  while (v24 != 16);
  v28 = type metadata accessor for SIMD16(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD32._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage, a2);
}

uint64_t SIMD32._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t (*SIMD32._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD32.scalarCount.getter()
{
  return 32;
}

uint64_t key path getter for SIMD32.subscript(_:) : <A>SIMD32<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v8)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v9;

  v3 = *a2;
  if ((unint64_t)*a2 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  v4 = *(const char **)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD32.subscript(_:) : <A>SIMD32<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  size_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(char *, unint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t v17;

  v4 = *(_QWORD *)(a4 + a3 - 16);
  v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v17 - v6;
  v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x35BuLL, 0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD32.subscript.modify(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD32.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, const void *a17, const void *a18, const void *a19, const void *a20,const void *a21,const void *a22,const void *a23,const void *a24,const void *a25,const void *a26,const void *a27,const void *a28,const void *a29,const void *a30,const void *a31,const void *a32,uint64_t a33,const char *a34)
{
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v43)(char *, uint64_t, unint64_t, unint64_t);
  char *v44;
  uint64_t v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  const void *v56;
  const void *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  const void *v64;
  const void *v65;
  const void *v66;
  const void *v67;
  const void *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  char *v73;
  const void *v74;
  const void *v75;
  const void *v76;

  v53 = a8;
  v51 = a7;
  v49 = a6;
  v48 = a5;
  v47 = a4;
  v75 = a31;
  v76 = a32;
  v74 = a30;
  v71 = a28;
  v72 = a29;
  v69 = a26;
  v70 = a27;
  v67 = a24;
  v68 = a25;
  v65 = a22;
  v66 = a23;
  v63 = a20;
  v64 = a21;
  v61 = a18;
  v62 = a19;
  v59 = a16;
  v60 = a17;
  v37 = *(_QWORD *)(*(_QWORD *)(a33 - 8) + 64);
  v57 = a14;
  v58 = a15;
  v56 = a13;
  v55 = a12;
  v54 = a11;
  v52 = a10;
  v50 = a9;
  v38 = MEMORY[0x1E0C80A78](a1);
  v73 = (char *)&v46 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v38);
  v40 = (char *)&v46 - v39;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a34, a33, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a34, a33, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a1, v37);
  v43 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v43(v40, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a2, v37);
  v43(v40, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a3, v37);
  v43(v40, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v47, v37);
  v43(v40, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v48, v37);
  v43(v40, 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v49, v37);
  v43(v40, 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v51, v37);
  v43(v40, 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v53, v37);
  v43(v40, 7, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v50, v37);
  v43(v40, 8, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v52, v37);
  v43(v40, 9, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v54, v37);
  v43(v40, 10, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v55, v37);
  v43(v40, 11, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v56, v37);
  v43(v40, 12, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v57, v37);
  v43(v40, 13, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v58, v37);
  v43(v40, 14, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v59, v37);
  v43(v40, 15, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v60, v37);
  v43(v40, 16, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v61, v37);
  v43(v40, 17, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v62, v37);
  v43(v40, 18, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v63, v37);
  v43(v40, 19, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v64, v37);
  v43(v40, 20, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v65, v37);
  v43(v40, 21, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v66, v37);
  v43(v40, 22, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v67, v37);
  v43(v40, 23, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v68, v37);
  v43(v40, 24, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v69, v37);
  v43(v40, 25, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v70, v37);
  v43(v40, 26, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v71, v37);
  v43(v40, 27, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v72, v37);
  v43(v40, 28, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v74, v37);
  v43(v40, 29, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v75, v37);
  v43(v40, 30, AssociatedTypeWitness, AssociatedConformanceWitness);
  v44 = v73;
  memcpy(v73, v76, v37);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v43)(v44, 31, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD32.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v15)(uint64_t, uint64_t);

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = type metadata accessor for SIMD32(0, a3, (uint64_t)a4, v10);
  specialized SIMD32.lowHalf.setter(a1, v11);
  v13 = type metadata accessor for SIMD16(0, a3, (uint64_t)a4, v12);
  v15 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 8);
  v15(a1, v13);
  specialized SIMD32.highHalf.setter(a2, v11);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD32.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.lowHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16);
}

uint64_t SIMD32.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.highHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16);
}

uint64_t SIMD32.lowHalf.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  const char *v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;
  uint64_t result;
  uint64_t v14;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = *(const char **)(v2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v8 = swift_getAssociatedTypeWitness(255, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v9 = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v10 = 0;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    v12 = swift_checkMetadataState(0, v8);
    v11(v10, v12, v9);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v4, v10++, AssociatedTypeWitness, AssociatedConformanceWitness);
  }
  while (v10 != 16);
  return result;
}

uint64_t key path getter for SIMD32.lowHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, SIMD32.lowHalf.getter);
}

uint64_t key path setter for SIMD32.lowHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, specialized SIMD32.lowHalf.setter);
}

void (*SIMD32.lowHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD16(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD32.lowHalf.getter(a2);
  return SIMD32.lowHalf.modify;
}

void SIMD32.lowHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD32.lowHalf.setter);
}

uint64_t SIMD32.highHalf.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  const char *v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;
  uint64_t result;
  uint64_t v14;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = *(const char **)(v2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v8 = swift_getAssociatedTypeWitness(255, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v9 = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v10 = 0;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    v12 = swift_checkMetadataState(0, v8);
    v11(v10 + 16, v12, v9);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v4, v10++, AssociatedTypeWitness, AssociatedConformanceWitness);
  }
  while (v10 != 16);
  return result;
}

uint64_t key path getter for SIMD32.highHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, SIMD32.highHalf.getter);
}

uint64_t key path setter for SIMD32.highHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, specialized SIMD32.highHalf.setter);
}

void (*SIMD32.highHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD16(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD32.highHalf.getter(a2);
  return SIMD32.highHalf.modify;
}

void SIMD32.highHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD32.highHalf.setter);
}

uint64_t SIMD32.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  const char *v7;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v10)(unint64_t, unint64_t);
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *(const char **)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v13 = 0;
  v14 = 0;
  v15 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  do
  {
    v16 = swift_checkMetadataState(0, v11);
    v15(v13, v16, v12);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v6, v14, AssociatedTypeWitness, AssociatedConformanceWitness);
    v13 += 2;
    ++v14;
  }
  while (v14 != 16);
  return result;
}

uint64_t key path getter for SIMD32.evenHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, (uint64_t (*)(uint64_t))SIMD32.evenHalf.getter);
}

uint64_t key path setter for SIMD32.evenHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, specialized SIMD32.evenHalf.setter);
}

uint64_t SIMD32.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.evenHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16);
}

void (*SIMD32.evenHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  void *v10;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD16(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD32.evenHalf.modify;
}

void SIMD32.evenHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD32.evenHalf.setter);
}

uint64_t SIMD32.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  const char *v7;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v10)(unint64_t, unint64_t);
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void (*v14)(uint64_t, unint64_t *, unint64_t);
  uint64_t v15;
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *(const char **)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v13 = 0;
  v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  v15 = 1;
  do
  {
    v16 = swift_checkMetadataState(0, v11);
    v14(v15, v16, v12);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v6, v13, AssociatedTypeWitness, AssociatedConformanceWitness);
    v15 += 2;
    ++v13;
  }
  while (v13 != 16);
  return result;
}

uint64_t key path getter for SIMD32.oddHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, (uint64_t (*)(uint64_t))SIMD32.oddHalf.getter);
}

uint64_t key path setter for SIMD32.oddHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32, specialized SIMD32.oddHalf.setter);
}

uint64_t SIMD32.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.oddHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD16);
}

void (*SIMD32.oddHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  void *v10;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD16(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD32.oddHalf.modify;
}

void SIMD32.oddHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD32.oddHalf.setter);
}

Swift::Int SIMD32.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD32<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD32<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD32Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD32<A>(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD32<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x35BuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD32<A>(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x20)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD32<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD32<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD32<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD32<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD, _QWORD, _QWORD);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t);
  const char *v23;
  unint64_t AssociatedTypeWitness;
  char *v25;
  unint64_t AssociatedConformanceWitness;
  void (*v27)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v28;
  void (*v29)(char *, uint64_t);
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;

  v3 = a3;
  v44 = a2;
  v4 = a1;
  v39 = *(_QWORD *)(a3 + 16);
  v5 = MEMORY[0x1E0C80A78](a1);
  v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = MEMORY[0x1E0C80A78](v5);
  v42 = (char *)&v37 - v8;
  v9 = MEMORY[0x1E0C80A78](v7);
  v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v37 - v13;
  v15 = 0;
  v16 = 1;
  v18 = v17;
  v19 = *(void (**)(_QWORD, _QWORD, _QWORD))(v17 + 16);
  v40 = v12;
  v41 = v20;
  v37 = v19;
  v38 = v17;
  v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      v23 = *(const char **)(v3 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
      v25 = v11;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
      v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      v28 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      v30 = v28;
      v19 = v37;
      v31 = AssociatedConformanceWitness;
      v11 = v25;
      v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      v32 = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      v33 = (uint64_t)v23;
      v4 = v40;
      v34 = swift_getAssociatedConformanceWitness(v33, v21, v32, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      v35 = swift_getAssociatedConformanceWitness(v34, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v18 = v38;
      v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35 + 8) + 8))(v42, v43, v21);
    }
    else
    {
      v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      v16 = 0;
    }
    if (++v15 == 32)
      break;
    v19(v14, v4, v3);
  }
  return v16 & 1;
}

uint64_t SIMD32<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 96))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 32);
  v28 = type metadata accessor for SIMD32(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD32<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 104))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 32);
  v28 = type metadata accessor for SIMD32(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD32<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  const char *v20;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v23)(unint64_t, unint64_t);
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  unint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  const char *v34;
  void (*v35)(uint64_t, unint64_t *, unint64_t);
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  uint64_t v44;

  v40 = a5;
  v41 = a7;
  v38 = a2;
  v44 = a1;
  v42 = a9;
  v13 = MEMORY[0x1E0C80A78](a1);
  v14 = MEMORY[0x1E0C80A78](v13);
  v16 = (char *)&v33 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v43 = associated type descriptor for SIMDScalar.SIMD32Storage;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v20, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v39 = a3;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  v24 = swift_getAssociatedTypeWitness(255, a8, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, v43);
  v34 = a8;
  v43 = a4;
  v36 = v24;
  v25 = swift_getAssociatedConformanceWitness((uint64_t)a8, (uint64_t)a4, v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v26 = 0;
  v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  v27 = v41;
  v28 = v43;
  do
  {
    v29 = swift_checkMetadataState(0, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(_QWORD *)(v27 + 16) + 304))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(_QWORD *)(v40 + 8) + 80))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v18, v26++, v37, AssociatedConformanceWitness);
  }
  while (v26 != 32);
  v31 = type metadata accessor for SIMD32(0, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v31 - 8) + 8))(v44, v31);
}

unint64_t SIMD32.debugDescription.getter(uint64_t a1)
{
  uint64_t v1;
  Class *v2;
  size_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  char *v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t *TypeName;
  uint64_t v113;
  uint8x16_t *v114;
  uint64_t v115;
  BOOL v116;
  char v117;
  unint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unsigned __int8 *v121;
  uint8x16_t *i;
  unsigned int v123;
  unsigned int v124;
  unsigned __int8 *v125;
  unsigned int v126;
  unsigned __int8 *v127;
  unsigned int v128;
  uint64_t v129;
  _QWORD *v130;
  void *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  int64_t v136;
  int64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  uint64_t v141;
  const char *v142;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v145)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v146;
  const void *v147;
  _QWORD *v148;
  uint64_t *v149;
  swift::SwiftError **v150;
  _QWORD *DynamicType;
  Class *v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  uint64_t v157;
  char *v158;
  uint64_t *v159;
  void *object;
  unint64_t v161;
  const void *v162;
  _QWORD *v163;
  uint64_t *v164;
  swift::SwiftError **v165;
  _QWORD *v166;
  Class *v167;
  uint64_t v168;
  uint64_t v169;
  unint64_t v170;
  unint64_t v171;
  uint64_t v172;
  char *v173;
  uint64_t *v174;
  void *v175;
  unint64_t v176;
  const void *v177;
  _QWORD *v178;
  uint64_t *v179;
  swift::SwiftError **v180;
  _QWORD *v181;
  Class *v182;
  uint64_t v183;
  uint64_t v184;
  unint64_t v185;
  unint64_t v186;
  uint64_t v187;
  char *v188;
  uint64_t *v189;
  void *v190;
  unint64_t v191;
  const void *v192;
  _QWORD *v193;
  uint64_t *v194;
  swift::SwiftError **v195;
  _QWORD *v196;
  Class *v197;
  uint64_t v198;
  uint64_t v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  char *v203;
  uint64_t *v204;
  void *v205;
  unint64_t v206;
  const void *v207;
  _QWORD *v208;
  uint64_t *v209;
  swift::SwiftError **v210;
  _QWORD *v211;
  Class *v212;
  uint64_t v213;
  uint64_t v214;
  unint64_t v215;
  unint64_t v216;
  uint64_t v217;
  char *v218;
  uint64_t *v219;
  void *v220;
  const void *v221;
  unint64_t v222;
  _QWORD *v223;
  uint64_t *v224;
  swift::SwiftError **v225;
  _QWORD *v226;
  Class *v227;
  uint64_t v228;
  uint64_t v229;
  unint64_t v230;
  unint64_t v231;
  uint64_t v232;
  char *v233;
  uint64_t *v234;
  void *v235;
  unint64_t v236;
  char *v237;
  char *v238;
  char *v239;
  char *v240;
  char *v241;
  char *v242;
  char *v243;
  char *v244;
  uint64_t v245;
  char *v246;
  uint64_t v247;
  Swift::String v248;
  uint64_t v249;
  Swift::String v250;
  uint64_t v251;
  Swift::String v252;
  uint64_t v253;
  Swift::String v254;
  uint64_t v255;
  Swift::String v256;
  uint64_t v257;
  Swift::String v258;
  uint64_t v259;
  Swift::String v260;
  uint64_t v261;
  Swift::String v262;
  uint64_t v263;
  Swift::String v264;
  uint64_t v265;
  Swift::String v266;
  uint64_t v267;
  Swift::String v268;
  uint64_t v269;
  Swift::String v270;
  uint64_t v271;
  Swift::String v272;
  uint64_t v273;
  Swift::String v274;
  uint64_t v275;
  Swift::String v276;
  uint64_t v277;
  Swift::String v278;
  uint64_t v279;
  Swift::String v280;
  uint64_t *v282;
  Class *v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t *v286;
  Class *v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t *v290;
  Class *v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t *v294;
  Class *v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t *v298;
  Class *v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t *v302;
  Class *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t *v306;
  Class *v307;
  uint64_t *v308;
  Class *v309;
  uint64_t *v310;
  Class *v311;
  uint64_t *v312;
  Class *v313;
  uint64_t *v314;
  Class *v315;
  uint64_t *v316;
  Class *v317;
  uint64_t *v318;
  Class *v319;
  uint64_t *v320;
  Class *v321;
  uint64_t *v322;
  Class *v323;
  uint64_t *v324;
  Class *v325;
  uint64_t *v326;
  Class *v327;
  uint64_t *v328;
  Class *v329;
  _QWORD *v330;
  void *v331;
  uint64_t v332;
  _QWORD *v333;
  void *v334;
  const void *v335;
  uint64_t v336;
  _QWORD *v337;
  void *v338;
  const void *v339;
  uint64_t v340;
  _QWORD *v341;
  void *v342;
  const void *v343;
  uint64_t v344;
  _QWORD *v345;
  void *v346;
  const void *v347;
  uint64_t v348;
  _QWORD *v349;
  void *v350;
  uint64_t v351;
  Class *v352;
  uint64_t *v353;
  uint64_t *v354;
  uint64_t *v355;
  uint64_t *v356;
  uint64_t *v357;
  uint64_t *v358;
  uint64_t *v359;
  uint64_t *v360;
  uint64_t *v361;
  uint64_t *v362;
  uint64_t *v363;
  uint64_t *v364;
  uint64_t *v365;
  uint64_t *v366;
  uint64_t *v367;
  uint64_t *v368;
  uint64_t *v369;
  uint64_t *v370;
  uint64_t *v371;
  uint64_t *v372;
  uint64_t *v373;
  uint64_t *v374;
  uint64_t *v375;
  uint64_t *v376;
  char *v377;
  char *v378;
  char *v379;
  char *v380;
  char *v381;
  char *v382;
  char *v383;
  char *v384;
  char *v385;
  char *v386;
  char *v387;
  char *v388;
  char *v389;
  char *v390;
  char *v391;
  char *v392;
  char *v393;
  char *v394;
  char *v395;
  char *v396;
  char *v397;
  char *v398;
  char *v399;
  char *v400;
  Swift::String v401;
  uint64_t *v402;
  uint64_t v403;
  __int128 v404;
  __int128 v405;
  uint64_t v406;
  unint64_t v407;
  unint64_t v408;

  v1 = a1;
  v2 = *(Class **)(a1 + 16);
  v3 = *((_QWORD *)*(v2 - 1) + 8);
  v4 = MEMORY[0x1E0C80A78](a1);
  v5 = (char *)&v352 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = MEMORY[0x1E0C80A78](v4);
  v400 = (char *)&v352 - v7;
  v8 = MEMORY[0x1E0C80A78](v6);
  v399 = (char *)&v352 - v9;
  v10 = MEMORY[0x1E0C80A78](v8);
  v398 = (char *)&v352 - v11;
  v12 = MEMORY[0x1E0C80A78](v10);
  v397 = (char *)&v352 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v396 = (char *)&v352 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v395 = (char *)&v352 - v17;
  v18 = MEMORY[0x1E0C80A78](v16);
  v394 = (char *)&v352 - v19;
  v20 = MEMORY[0x1E0C80A78](v18);
  v393 = (char *)&v352 - v21;
  v22 = MEMORY[0x1E0C80A78](v20);
  v392 = (char *)&v352 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v391 = (char *)&v352 - v25;
  v26 = MEMORY[0x1E0C80A78](v24);
  v390 = (char *)&v352 - v27;
  v28 = MEMORY[0x1E0C80A78](v26);
  v389 = (char *)&v352 - v29;
  v30 = MEMORY[0x1E0C80A78](v28);
  v388 = (char *)&v352 - v31;
  v32 = MEMORY[0x1E0C80A78](v30);
  v387 = (char *)&v352 - v33;
  v34 = MEMORY[0x1E0C80A78](v32);
  v386 = (char *)&v352 - v35;
  v36 = MEMORY[0x1E0C80A78](v34);
  v385 = (char *)&v352 - v37;
  v38 = MEMORY[0x1E0C80A78](v36);
  v384 = (char *)&v352 - v39;
  v40 = MEMORY[0x1E0C80A78](v38);
  v358 = (uint64_t *)((char *)&v352 - v41);
  v42 = MEMORY[0x1E0C80A78](v40);
  v364 = (uint64_t *)((char *)&v352 - v43);
  v44 = MEMORY[0x1E0C80A78](v42);
  v370 = (uint64_t *)((char *)&v352 - v45);
  v46 = MEMORY[0x1E0C80A78](v44);
  v376 = (uint64_t *)((char *)&v352 - v47);
  v48 = MEMORY[0x1E0C80A78](v46);
  v50 = (char *)&v352 - v49;
  v51 = MEMORY[0x1E0C80A78](v48);
  v357 = (uint64_t *)((char *)&v352 - v52);
  v53 = MEMORY[0x1E0C80A78](v51);
  v363 = (uint64_t *)((char *)&v352 - v54);
  v55 = MEMORY[0x1E0C80A78](v53);
  v369 = (uint64_t *)((char *)&v352 - v56);
  v57 = MEMORY[0x1E0C80A78](v55);
  v375 = (uint64_t *)((char *)&v352 - v58);
  v59 = MEMORY[0x1E0C80A78](v57);
  v383 = (char *)&v352 - v60;
  v61 = MEMORY[0x1E0C80A78](v59);
  v356 = (uint64_t *)((char *)&v352 - v62);
  v63 = MEMORY[0x1E0C80A78](v61);
  v362 = (uint64_t *)((char *)&v352 - v64);
  v65 = MEMORY[0x1E0C80A78](v63);
  v368 = (uint64_t *)((char *)&v352 - v66);
  v67 = MEMORY[0x1E0C80A78](v65);
  v374 = (uint64_t *)((char *)&v352 - v68);
  v69 = MEMORY[0x1E0C80A78](v67);
  v382 = (char *)&v352 - v70;
  v71 = MEMORY[0x1E0C80A78](v69);
  v355 = (uint64_t *)((char *)&v352 - v72);
  v73 = MEMORY[0x1E0C80A78](v71);
  v361 = (uint64_t *)((char *)&v352 - v74);
  v75 = MEMORY[0x1E0C80A78](v73);
  v367 = (uint64_t *)((char *)&v352 - v76);
  v77 = MEMORY[0x1E0C80A78](v75);
  v373 = (uint64_t *)((char *)&v352 - v78);
  v79 = MEMORY[0x1E0C80A78](v77);
  v381 = (char *)&v352 - v80;
  v81 = MEMORY[0x1E0C80A78](v79);
  v354 = (uint64_t *)((char *)&v352 - v82);
  v83 = MEMORY[0x1E0C80A78](v81);
  v360 = (uint64_t *)((char *)&v352 - v84);
  v85 = MEMORY[0x1E0C80A78](v83);
  v366 = (uint64_t *)((char *)&v352 - v86);
  v87 = MEMORY[0x1E0C80A78](v85);
  v372 = (uint64_t *)((char *)&v352 - v88);
  v89 = MEMORY[0x1E0C80A78](v87);
  v380 = (char *)&v352 - v90;
  v91 = MEMORY[0x1E0C80A78](v89);
  v353 = (uint64_t *)((char *)&v352 - v92);
  v93 = MEMORY[0x1E0C80A78](v91);
  v359 = (uint64_t *)((char *)&v352 - v94);
  v95 = MEMORY[0x1E0C80A78](v93);
  v365 = (uint64_t *)((char *)&v352 - v96);
  v97 = MEMORY[0x1E0C80A78](v95);
  v371 = (uint64_t *)((char *)&v352 - v98);
  v99 = MEMORY[0x1E0C80A78](v97);
  v101 = (char *)&v352 - v100;
  MEMORY[0x1E0C80A78](v99);
  v379 = (char *)&v352 - v102;
  v103 = specialized static String._createEmpty(withInitialCapacity:)(138);
  v107 = v104;
  v407 = v103;
  v408 = v104;
  v108 = HIBYTE(v104) & 0xF;
  if ((v104 & 0x2000000000000000) == 0)
    v108 = v103 & 0xFFFFFFFFFFFFLL;
  if (v108 || (v103 & ~v104 & 0x2000000000000000) != 0)
  {
    if ((v104 & 0x2000000000000000) == 0
      || (v109 = specialized _SmallString.init(_:appending:)(v103, v104, 0x3C3233444D4953uLL, 0xE700000000000000),
          (v105 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE700000000000000, v104, v105, v106);
      _StringGuts.append(_:)(0x3C3233444D4953, 0xE700000000000000, 0, 7);
      swift_bridgeObjectRelease_n(0xE700000000000000, 2);
    }
    else
    {
      v110 = v109;
      v111 = v104;
      swift_bridgeObjectRelease(v107);
      swift_bridgeObjectRelease(0xE700000000000000);
      v407 = v110;
      v408 = v111;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v104);
    v407 = 0x3C3233444D4953;
    v408 = 0xE700000000000000;
  }
  TypeName = (uint64_t *)swift_getTypeName(v2, 0);
  if (v113 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v114 = (uint8x16_t *)TypeName;
  v115 = v113;
  v116 = _allASCII(_:)(TypeName, v113);
  v377 = v50;
  if (!v116)
  {
    v120 = 0;
    v121 = &v114->u8[v115];
    if (!v114)
      v121 = 0;
    v117 = 1;
    for (i = v114; ; i = (uint8x16_t *)((char *)i + 3))
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if (!i || i == (uint8x16_t *)v121)
              goto LABEL_12;
            v124 = i->u8[0];
            i = (uint8x16_t *)((char *)i + 1);
            v123 = v124;
            if ((v123 & 0x80) != 0)
              break;
            ++v120;
          }
          if ((v123 + 62) >= 0x33u)
            goto LABEL_64;
          if (v123 > 0xDF)
            break;
          if (!i || i == (uint8x16_t *)v121 || (i->i8[0] & 0xC0) != 0x80)
            goto LABEL_64;
          v117 = 0;
          i = (uint8x16_t *)((char *)i + 1);
          v120 += 2;
        }
        if (v123 != 224)
          break;
        if (!i)
          goto LABEL_64;
        if (i == (uint8x16_t *)v121)
          goto LABEL_64;
        v125 = &i->u8[1];
        if ((i->i8[0] & 0xE0) != 0xA0)
          goto LABEL_64;
LABEL_42:
        if (v125 == v121 || (*v125 & 0xC0) != 0x80)
          goto LABEL_64;
        v117 = 0;
        i = (uint8x16_t *)((char *)i + 2);
        v120 += 3;
      }
      if (v123 <= 0xEC)
        break;
      if (v123 == 237)
      {
        if (!i)
          goto LABEL_64;
        if (i == (uint8x16_t *)v121)
          goto LABEL_64;
        v125 = &i->u8[1];
        v126 = i->u8[0];
        if (v126 > 0x9F)
          goto LABEL_64;
        goto LABEL_41;
      }
      if (v123 <= 0xEF)
        break;
      if (v123 == 240)
      {
        if (!i)
          goto LABEL_64;
        if (i == (uint8x16_t *)v121)
          goto LABEL_64;
        v127 = &i->u8[1];
        if ((i->i8[0] + 64) < 0xD0u)
          goto LABEL_64;
      }
      else
      {
        if ((v123 + 15) > 2u)
        {
          if (!i || i == (uint8x16_t *)v121 || (v127 = &i->u8[1], v128 = i->u8[0], v128 > 0x8F))
          {
LABEL_64:
            v129 = v1;
            v130 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
            v352 = v2;
            swift_willThrow();
            v131 = v130;
            v1 = v129;
            v5 = (char *)&v352 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
            swift_errorRelease(v131);
            v132 = specialized Collection.subscript.getter(v120, (uint64_t)v114, v115);
            v136 = findInvalidRange #1 (_:) in validateUTF8(_:)(v132, v133, v134, v135);
            v2 = v352;
            v118 = repairUTF8(_:firstKnownBrokenRange:)(v114->i8, v115, v136, v137);
            goto LABEL_65;
          }
        }
        else
        {
          if (!i || i == (uint8x16_t *)v121)
            goto LABEL_64;
          v127 = &i->u8[1];
          LOBYTE(v128) = i->i8[0];
        }
        if ((v128 & 0xC0) != 0x80)
          goto LABEL_64;
      }
      if (v127 == v121 || (i->i8[1] & 0xC0) != 0x80 || &i->i16[1] == (__int16 *)v121 || (i->i8[2] & 0xC0) != 0x80)
        goto LABEL_64;
      v117 = 0;
      v120 += 4;
    }
    if (!i || i == (uint8x16_t *)v121)
      goto LABEL_64;
    v125 = &i->u8[1];
    LOBYTE(v126) = i->i8[0];
LABEL_41:
    if ((v126 & 0xC0) != 0x80)
      goto LABEL_64;
    goto LABEL_42;
  }
  v117 = 1;
LABEL_12:
  v118 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v114, v115, v117 & 1);
LABEL_65:
  v138 = v118;
  v139 = v119;
  v140 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000) == 0)
    v140 = v407 & 0xFFFFFFFFFFFFLL;
  if (v140 || (v407 & ~v408 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(v118, v119);
    swift_bridgeObjectRelease(v139);
    v138 = v407;
    v139 = v408;
  }
  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = v138;
    v408 = v139;
  }
  v141 = HIBYTE(v139) & 0xF;
  if ((v139 & 0x2000000000000000) == 0)
    v141 = v138 & 0xFFFFFFFFFFFFLL;
  v378 = v5;
  if (v141 || (v138 & ~v139 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x283EuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v139);
    v407 = 10302;
    v408 = 0xE200000000000000;
  }
  v142 = *(const char **)(v1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v142, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v142, (uint64_t)v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v145 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v146 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v147 = v379;
  v145(0, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v148 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v148, v147, v3);
  v149 = v402;
  v150 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  DynamicType = (_QWORD *)swift_getDynamicType(v150, v149, 1);
  LODWORD(v149) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v149)
  {
    memcpy(v101, v147, v3);
    v152 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v152, 7uLL);
LABEL_77:
    v153 = (uint64_t)v402;
    v154 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    v155 = (*(uint64_t (**)(uint64_t, uint64_t))(v154 + 8))(v153, v154);
    v157 = v156;
    specialized String.write<A>(to:)(&v407, v155, v156, v158);
    swift_bridgeObjectRelease(v157);
LABEL_78:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_81;
  }
  v159 = v371;
  memcpy(v371, v147, v3);
  if ((swift_dynamicCast((char *)&v401, v159, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    object = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)object);
  }
  else
  {
    v282 = v365;
    memcpy(v365, v147, v3);
    v283 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v282, v2, v283, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v284 = (uint64_t)v402;
      v285 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v285 + 8))(&v407, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v284, v285);
      goto LABEL_78;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for TextOutputStreamable?);
    v306 = v359;
    memcpy(v359, v147, v3);
    v307 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v306, v2, v307, 6uLL)
      || (v406 = 0,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomStringConvertible?), v308 = v353, memcpy(v353, v147, v3), v309 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v404, v308, v2, v309, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_77;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v405 + 1) = v2;
    v330 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v330, v147, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v331 = v401._object;
    v332 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v147, &v401, &v407, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v332);
    swift_release((uint64_t)v331);
  }
LABEL_81:
  v161 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000) == 0)
    v161 = v407 & 0xFFFFFFFFFFFFLL;
  v162 = v380;
  if (v161 || (v407 & ~v408 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236;
    v408 = 0xE200000000000000;
  }
  v145(1, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v163 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v163, v162, v3);
  v164 = v402;
  v165 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  v166 = (_QWORD *)swift_getDynamicType(v165, v164, 1);
  LODWORD(v164) = swift_isOptionalType(v166);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v164)
  {
    memcpy(v101, v162, v3);
    v167 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v167, 7uLL);
LABEL_88:
    v168 = (uint64_t)v402;
    v169 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    v170 = (*(uint64_t (**)(uint64_t, uint64_t))(v169 + 8))(v168, v169);
    v172 = v171;
    specialized String.write<A>(to:)(&v407, v170, v171, v173);
    swift_bridgeObjectRelease(v172);
LABEL_89:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_92;
  }
  v174 = v372;
  memcpy(v372, v162, v3);
  if ((swift_dynamicCast((char *)&v401, v174, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v175 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v175);
  }
  else
  {
    v286 = v366;
    memcpy(v366, v162, v3);
    v287 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v286, v2, v287, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v288 = (uint64_t)v402;
      v289 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v289 + 8))(&v407, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v288, v289);
      goto LABEL_89;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for TextOutputStreamable?);
    v310 = v360;
    memcpy(v360, v162, v3);
    v311 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v310, v2, v311, 6uLL)
      || (v406 = 0,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomStringConvertible?), v312 = v354, memcpy(v354, v162, v3), v313 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v404, v312, v2, v313, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_88;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v405 + 1) = v2;
    v333 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v333, v162, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v334 = v401._object;
    v335 = v162;
    v336 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v335, &v401, &v407, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v336);
    swift_release((uint64_t)v334);
  }
LABEL_92:
  v176 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000) == 0)
    v176 = v407 & 0xFFFFFFFFFFFFLL;
  v177 = v381;
  if (v176 || (v407 & ~v408 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236;
    v408 = 0xE200000000000000;
  }
  v145(2, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v178 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v178, v177, v3);
  v179 = v402;
  v180 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  v181 = (_QWORD *)swift_getDynamicType(v180, v179, 1);
  LODWORD(v179) = swift_isOptionalType(v181);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v179)
  {
    memcpy(v101, v177, v3);
    v182 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v182, 7uLL);
LABEL_99:
    v183 = (uint64_t)v402;
    v184 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    v185 = (*(uint64_t (**)(uint64_t, uint64_t))(v184 + 8))(v183, v184);
    v187 = v186;
    specialized String.write<A>(to:)(&v407, v185, v186, v188);
    swift_bridgeObjectRelease(v187);
LABEL_100:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_103;
  }
  v189 = v373;
  memcpy(v373, v177, v3);
  if ((swift_dynamicCast((char *)&v401, v189, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v190 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v190);
  }
  else
  {
    v290 = v367;
    memcpy(v367, v177, v3);
    v291 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v290, v2, v291, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v292 = (uint64_t)v402;
      v293 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v293 + 8))(&v407, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v292, v293);
      goto LABEL_100;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for TextOutputStreamable?);
    v314 = v361;
    memcpy(v361, v177, v3);
    v315 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v314, v2, v315, 6uLL)
      || (v406 = 0,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomStringConvertible?), v316 = v355, memcpy(v355, v177, v3), v317 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v404, v316, v2, v317, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_99;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v405 + 1) = v2;
    v337 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v337, v177, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v338 = v401._object;
    v339 = v177;
    v340 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v339, &v401, &v407, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v340);
    swift_release((uint64_t)v338);
  }
LABEL_103:
  v191 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000) == 0)
    v191 = v407 & 0xFFFFFFFFFFFFLL;
  v192 = v382;
  if (v191 || (v407 & ~v408 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236;
    v408 = 0xE200000000000000;
  }
  v145(3, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v193 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v193, v192, v3);
  v194 = v402;
  v195 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  v196 = (_QWORD *)swift_getDynamicType(v195, v194, 1);
  LODWORD(v194) = swift_isOptionalType(v196);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v194)
  {
    memcpy(v101, v192, v3);
    v197 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v197, 7uLL);
LABEL_110:
    v198 = (uint64_t)v402;
    v199 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    v200 = (*(uint64_t (**)(uint64_t, uint64_t))(v199 + 8))(v198, v199);
    v202 = v201;
    specialized String.write<A>(to:)(&v407, v200, v201, v203);
    swift_bridgeObjectRelease(v202);
LABEL_111:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_114;
  }
  v204 = v374;
  memcpy(v374, v192, v3);
  if ((swift_dynamicCast((char *)&v401, v204, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v205 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v205);
  }
  else
  {
    v294 = v368;
    memcpy(v368, v192, v3);
    v295 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v294, v2, v295, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v296 = (uint64_t)v402;
      v297 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v297 + 8))(&v407, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v296, v297);
      goto LABEL_111;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for TextOutputStreamable?);
    v318 = v362;
    memcpy(v362, v192, v3);
    v319 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v318, v2, v319, 6uLL)
      || (v406 = 0,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomStringConvertible?), v320 = v356, memcpy(v356, v192, v3), v321 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v404, v320, v2, v321, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_110;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v405 + 1) = v2;
    v341 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v341, v192, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v342 = v401._object;
    v343 = v192;
    v344 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v343, &v401, &v407, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v344);
    swift_release((uint64_t)v342);
  }
LABEL_114:
  v206 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000) == 0)
    v206 = v407 & 0xFFFFFFFFFFFFLL;
  v207 = v383;
  if (v206 || (v407 & ~v408 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236;
    v408 = 0xE200000000000000;
  }
  v145(4, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v208 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v208, v207, v3);
  v209 = v402;
  v210 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  v211 = (_QWORD *)swift_getDynamicType(v210, v209, 1);
  LODWORD(v209) = swift_isOptionalType(v211);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v209)
  {
    memcpy(v101, v207, v3);
    v212 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v212, 7uLL);
LABEL_121:
    v213 = (uint64_t)v402;
    v214 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    v215 = (*(uint64_t (**)(uint64_t, uint64_t))(v214 + 8))(v213, v214);
    v217 = v216;
    specialized String.write<A>(to:)(&v407, v215, v216, v218);
    swift_bridgeObjectRelease(v217);
LABEL_122:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_125;
  }
  v219 = v375;
  memcpy(v375, v207, v3);
  if ((swift_dynamicCast((char *)&v401, v219, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v220 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v220);
  }
  else
  {
    v298 = v369;
    memcpy(v369, v207, v3);
    v299 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v298, v2, v299, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v300 = (uint64_t)v402;
      v301 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v301 + 8))(&v407, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v300, v301);
      goto LABEL_122;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for TextOutputStreamable?);
    v322 = v363;
    memcpy(v363, v207, v3);
    v323 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v322, v2, v323, 6uLL)
      || (v406 = 0,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomStringConvertible?), v324 = v357, memcpy(v357, v207, v3), v325 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v404, v324, v2, v325, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_121;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v405 + 1) = v2;
    v345 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v345, v207, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v346 = v401._object;
    v347 = v207;
    v348 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v347, &v401, &v407, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v348);
    swift_release((uint64_t)v346);
  }
LABEL_125:
  v221 = v377;
  v222 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000) == 0)
    v222 = v407 & 0xFFFFFFFFFFFFLL;
  if (v222 || (v407 & ~v408 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236;
    v408 = 0xE200000000000000;
  }
  v145(5, v146, AssociatedConformanceWitness);
  v402 = (uint64_t *)v2;
  v223 = __swift_allocate_boxed_opaque_existential_0Tm(&v401);
  memcpy(v223, v221, v3);
  v224 = v402;
  v225 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
  v226 = (_QWORD *)swift_getDynamicType(v225, v224, 1);
  LODWORD(v224) = swift_isOptionalType(v226);
  __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
  if ((_DWORD)v224)
  {
    memcpy(v101, v221, v3);
    v227 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v401, (uint64_t *)v101, v2, v227, 7uLL);
LABEL_132:
    v228 = (uint64_t)v402;
    v229 = v403;
    __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
    v230 = (*(uint64_t (**)(uint64_t, uint64_t))(v229 + 8))(v228, v229);
    v232 = v231;
    specialized String.write<A>(to:)(&v407, v230, v231, v233);
    swift_bridgeObjectRelease(v232);
LABEL_133:
    __swift_destroy_boxed_opaque_existential_1Tm(&v401._countAndFlagsBits);
    goto LABEL_136;
  }
  v234 = v376;
  memcpy(v376, v221, v3);
  if ((swift_dynamicCast((char *)&v401, v234, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v235 = v401._object;
    String.append(_:)(v401);
    swift_bridgeObjectRelease((uint64_t)v235);
  }
  else
  {
    v302 = v370;
    memcpy(v370, v221, v3);
    v303 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v404, v302, v2, v303, 6uLL))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      v304 = (uint64_t)v402;
      v305 = v403;
      __swift_project_boxed_opaque_existential_0Tm(&v401, (uint64_t)v402);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v305 + 8))(&v407, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v304, v305);
      goto LABEL_133;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for TextOutputStreamable?);
    v326 = v364;
    memcpy(v364, v221, v3);
    v327 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v404, v326, v2, v327, 6uLL)
      || (v406 = 0,
          v404 = 0u,
          v405 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomStringConvertible?), v328 = v358, memcpy(v358, v221, v3), v329 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v404, v328, v2, v329, 6uLL)))
    {
      outlined init with take of MirrorPath(&v404, (uint64_t)&v401);
      goto LABEL_132;
    }
    v406 = 0;
    v404 = 0u;
    v405 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v404, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((_QWORD *)&v405 + 1) = v2;
    v349 = __swift_allocate_boxed_opaque_existential_0Tm(&v404);
    memcpy(v349, v221, v3);
    Mirror.init(reflecting:)((uint64_t *)&v404, (uint64_t)&v401);
    v350 = v401._object;
    v351 = v403;
    ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v221, &v401, &v407, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v351);
    swift_release((uint64_t)v350);
  }
LABEL_136:
  v236 = HIBYTE(v408) & 0xF;
  if ((v408 & 0x2000000000000000) == 0)
    v236 = v407 & 0xFFFFFFFFFFFFLL;
  if (v236 || (v407 & ~v408 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v408);
    v407 = 8236;
    v408 = 0xE200000000000000;
  }
  v145(6, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v237);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(7, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v238);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(8, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v239);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(9, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v240);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(10, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v241);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(11, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v242);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(12, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v243);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(13, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v101, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v244);
  swift_bridgeObjectRelease(0xE200000000000000);
  v245 = (uint64_t)v384;
  v145(14, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v245, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v407, 0x202CuLL, 0xE200000000000000, v246);
  swift_bridgeObjectRelease(0xE200000000000000);
  v247 = (uint64_t)v385;
  v145(15, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v247, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v248._countAndFlagsBits = 8236;
  v248._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v248);
  swift_bridgeObjectRelease(0xE200000000000000);
  v249 = (uint64_t)v386;
  v145(16, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v249, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v250._countAndFlagsBits = 8236;
  v250._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v250);
  swift_bridgeObjectRelease(0xE200000000000000);
  v251 = (uint64_t)v387;
  v145(17, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v251, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v252._countAndFlagsBits = 8236;
  v252._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v252);
  swift_bridgeObjectRelease(0xE200000000000000);
  v253 = (uint64_t)v388;
  v145(18, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v253, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v254._countAndFlagsBits = 8236;
  v254._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v254);
  swift_bridgeObjectRelease(0xE200000000000000);
  v255 = (uint64_t)v389;
  v145(19, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v255, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v256._countAndFlagsBits = 8236;
  v256._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v256);
  swift_bridgeObjectRelease(0xE200000000000000);
  v257 = (uint64_t)v390;
  v145(20, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v257, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v258._countAndFlagsBits = 8236;
  v258._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v258);
  swift_bridgeObjectRelease(0xE200000000000000);
  v259 = (uint64_t)v391;
  v145(21, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v259, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v260._countAndFlagsBits = 8236;
  v260._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v260);
  swift_bridgeObjectRelease(0xE200000000000000);
  v261 = (uint64_t)v392;
  v145(22, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v261, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v262._countAndFlagsBits = 8236;
  v262._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v262);
  swift_bridgeObjectRelease(0xE200000000000000);
  v263 = (uint64_t)v393;
  v145(23, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v263, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v264._countAndFlagsBits = 8236;
  v264._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v264);
  swift_bridgeObjectRelease(0xE200000000000000);
  v265 = (uint64_t)v394;
  v145(24, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v265, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v266._countAndFlagsBits = 8236;
  v266._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v266);
  swift_bridgeObjectRelease(0xE200000000000000);
  v267 = (uint64_t)v395;
  v145(25, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v267, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v268._countAndFlagsBits = 8236;
  v268._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v268);
  swift_bridgeObjectRelease(0xE200000000000000);
  v269 = (uint64_t)v396;
  v145(26, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v269, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v270._countAndFlagsBits = 8236;
  v270._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v270);
  swift_bridgeObjectRelease(0xE200000000000000);
  v271 = (uint64_t)v397;
  v145(27, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v271, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v272._countAndFlagsBits = 8236;
  v272._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v272);
  swift_bridgeObjectRelease(0xE200000000000000);
  v273 = (uint64_t)v398;
  v145(28, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v273, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v274._countAndFlagsBits = 8236;
  v274._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v274);
  swift_bridgeObjectRelease(0xE200000000000000);
  v275 = (uint64_t)v399;
  v145(29, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v275, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v276._countAndFlagsBits = 8236;
  v276._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v276);
  swift_bridgeObjectRelease(0xE200000000000000);
  v277 = (uint64_t)v400;
  v145(30, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v277, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v278._countAndFlagsBits = 8236;
  v278._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v278);
  swift_bridgeObjectRelease(0xE200000000000000);
  v279 = (uint64_t)v378;
  v145(31, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v279, (uint64_t)&v407, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v280._countAndFlagsBits = 41;
  v280._object = (void *)0xE100000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v280);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v407;
}

uint64_t SIMD32<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 16) + 72))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 32);
  v28 = type metadata accessor for SIMD32(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a6;
  v35 = a8;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  v36 = a3;
  v32 = v22;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v33, AssociatedConformanceWitness);
  }
  while (v24 != 32);
  v28 = type metadata accessor for SIMD32(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD64._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage, a2);
}

uint64_t SIMD64._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t (*SIMD64._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD64.scalarCount.getter()
{
  return 64;
}

uint64_t key path getter for SIMD64.subscript(_:) : <A>SIMD64<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v8)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v9;

  v3 = *a2;
  if ((unint64_t)*a2 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  v4 = *(const char **)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD64.subscript(_:) : <A>SIMD64<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  size_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(char *, unint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t v17;

  v4 = *(_QWORD *)(a4 + a3 - 16);
  v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v17 - v6;
  v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x453uLL, 0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD64.subscript.modify(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD64.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, const void *a17, const void *a18, const void *a19, const void *a20,const void *a21,const void *a22,const void *a23,const void *a24,const void *a25,const void *a26,const void *a27,const void *a28,const void *a29,const void *a30,const void *a31,const void *a32,const void *a33,const void *a34,const void *a35,const void *a36,const void *a37,const void *a38,const void *a39,const void *a40,const void *a41,const void *a42,const void *a43,const void *a44,const void *a45,const void *a46,const void *a47,const void *a48,const void *a49,const void *a50,const void *a51,const void *a52,const void *a53,const void *a54,const void *a55,const void *a56,const void *a57,const void *a58,const void *a59,const void *a60,const void *a61,const void *a62,const void *a63)
{
  const void *a64;
  uint64_t a65;
  const char *a66;
  size_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  char *v188;
  uint64_t v189;
  uint64_t v190;
  char *v191;
  uint64_t v192;
  uint64_t v193;
  char *v194;
  uint64_t v195;
  char *v196;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v199)(char *, uint64_t, unint64_t, unint64_t);
  char *v200;
  char *v201;
  char *v202;
  char *v203;
  char *v204;
  char *v205;
  char *v206;
  char *v207;
  char *v208;
  char *v209;
  char *v210;
  char *v211;
  char *v212;
  char *v213;
  char *v214;
  char *v215;
  char *v216;
  char *v217;
  char *v218;
  char *v219;
  char *v220;
  char *v221;
  char *v222;
  char *v223;
  char *v224;
  char *v225;
  char *v226;
  char *v227;
  char *v228;
  char *v229;
  char *v230;
  char *v231;
  char *v232;
  char *v233;
  char *v234;
  char *v235;
  char *v236;
  char *v237;
  char *v238;
  char *v239;
  char *v240;
  char *v241;
  char *v242;
  char *v243;
  char *v244;
  char *v245;
  char *v246;
  char *v247;
  char *v248;
  char *v249;
  char *v250;
  char *v251;
  char *v252;
  char *v253;
  char *v254;
  char *v255;
  char *v256;
  char *v257;
  char *v258;
  char *v259;
  uint64_t v261;
  char *v262;
  char *v263;
  char *v264;
  char *v265;
  char *v266;
  char *v267;
  char *v268;
  char *v269;
  char *v270;
  char *v271;
  char *v272;
  char *v273;
  char *v274;
  char *v275;
  char *v276;
  char *v277;
  const void *v278;
  char *v279;
  char *v280;
  char *v281;
  char *v282;
  const void *v283;
  const void *v284;
  char *v285;
  const void *v286;
  const void *v287;
  char *v288;
  const void *v289;
  const void *v290;
  const void *v291;
  const void *v292;
  char *v293;
  const void *v294;
  const void *v295;
  char *v296;
  const void *v297;
  const void *v298;
  const void *v299;
  char *v300;
  const void *v301;
  char *v302;
  const void *v303;
  char *v304;
  const void *v305;
  const void *v306;
  char *v307;
  const void *v308;
  char *v309;
  const void *v310;
  const void *v311;
  char *v312;
  const void *v313;
  char *v314;
  const void *v315;
  char *v316;
  const void *v317;
  const void *v318;
  char *v319;
  const void *v320;
  char *v321;
  const void *v322;
  char *v323;
  const void *v324;
  const void *v325;
  char *v326;
  const void *v327;
  char *v328;
  const void *v329;
  const void *v330;
  char *v331;
  const void *v332;
  char *v333;
  const void *v334;
  char *v335;
  const void *v336;
  const void *v337;
  char *v338;
  const void *v339;
  char *v340;
  const void *v341;
  const void *v342;
  char *v343;
  const void *v344;
  char *v345;
  const void *v346;
  char *v347;
  const void *v348;
  const void *v349;
  char *v350;
  const void *v351;
  char *v352;
  const void *v353;
  const void *v354;
  char *v355;
  char *v356;
  char *v357;
  const void *v358;
  char *v359;
  const void *v360;
  const void *v361;
  char *v362;
  const void *v363;
  char *v364;
  const void *v365;
  char *v366;
  const void *v367;
  const void *v368;
  char *v369;
  const void *v370;
  char *v371;
  const void *v372;
  char *v373;
  const void *v374;
  char *v375;
  const void *v376;
  char *v377;
  const void *v378;
  const void *v379;
  char *v380;
  const void *v381;
  const void *v382;
  const void *v383;
  const void *v384;
  const void *v385;

  v298 = a8;
  v295 = a7;
  v292 = a6;
  v290 = a5;
  v287 = a4;
  v284 = a3;
  v283 = a2;
  v278 = a1;
  v384 = a63;
  v385 = a64;
  v382 = a61;
  v383 = a62;
  v381 = a60;
  v378 = a58;
  v379 = a59;
  v376 = a57;
  v374 = a56;
  v372 = a55;
  v370 = a54;
  v367 = a52;
  v368 = a53;
  v365 = a51;
  v363 = a50;
  v361 = a49;
  v360 = a48;
  v358 = a47;
  v66 = *(_QWORD *)(*(_QWORD *)(a65 - 8) + 64);
  v354 = a46;
  v353 = a45;
  v351 = a44;
  v349 = a43;
  v348 = a42;
  v346 = a41;
  v344 = a40;
  v342 = a39;
  v341 = a38;
  v339 = a37;
  v337 = a36;
  v336 = a35;
  v334 = a34;
  v332 = a33;
  v330 = a32;
  v329 = a31;
  v327 = a30;
  v325 = a29;
  v324 = a28;
  v322 = a27;
  v320 = a26;
  v318 = a25;
  v317 = a24;
  v315 = a23;
  v313 = a22;
  v311 = a21;
  v310 = a20;
  v308 = a19;
  v306 = a18;
  v305 = a17;
  v303 = a16;
  v301 = a15;
  v299 = a14;
  v297 = a13;
  v294 = a12;
  v291 = a11;
  v289 = a10;
  v286 = a9;
  v67 = MEMORY[0x1E0C80A78](a1);
  v380 = (char *)&v261 - ((v66 + 15) & 0xFFFFFFFFFFFFFFF0);
  v68 = MEMORY[0x1E0C80A78](v67);
  v377 = (char *)&v261 - v69;
  v70 = MEMORY[0x1E0C80A78](v68);
  v375 = (char *)&v261 - v71;
  v72 = MEMORY[0x1E0C80A78](v70);
  v373 = (char *)&v261 - v73;
  v74 = MEMORY[0x1E0C80A78](v72);
  v371 = (char *)&v261 - v75;
  v76 = MEMORY[0x1E0C80A78](v74);
  v369 = (char *)&v261 - v77;
  v78 = MEMORY[0x1E0C80A78](v76);
  v366 = (char *)&v261 - v79;
  v80 = MEMORY[0x1E0C80A78](v78);
  v364 = (char *)&v261 - v81;
  v82 = MEMORY[0x1E0C80A78](v80);
  v362 = (char *)&v261 - v83;
  v84 = MEMORY[0x1E0C80A78](v82);
  v359 = (char *)&v261 - v85;
  v86 = MEMORY[0x1E0C80A78](v84);
  v357 = (char *)&v261 - v87;
  v88 = MEMORY[0x1E0C80A78](v86);
  v356 = (char *)&v261 - v89;
  v90 = MEMORY[0x1E0C80A78](v88);
  v355 = (char *)&v261 - v91;
  v92 = MEMORY[0x1E0C80A78](v90);
  v352 = (char *)&v261 - v93;
  v94 = MEMORY[0x1E0C80A78](v92);
  v350 = (char *)&v261 - v95;
  v96 = MEMORY[0x1E0C80A78](v94);
  v347 = (char *)&v261 - v97;
  v98 = MEMORY[0x1E0C80A78](v96);
  v345 = (char *)&v261 - v99;
  v100 = MEMORY[0x1E0C80A78](v98);
  v343 = (char *)&v261 - v101;
  v102 = MEMORY[0x1E0C80A78](v100);
  v340 = (char *)&v261 - v103;
  v104 = MEMORY[0x1E0C80A78](v102);
  v338 = (char *)&v261 - v105;
  v106 = MEMORY[0x1E0C80A78](v104);
  v335 = (char *)&v261 - v107;
  v108 = MEMORY[0x1E0C80A78](v106);
  v333 = (char *)&v261 - v109;
  v110 = MEMORY[0x1E0C80A78](v108);
  v331 = (char *)&v261 - v111;
  v112 = MEMORY[0x1E0C80A78](v110);
  v328 = (char *)&v261 - v113;
  v114 = MEMORY[0x1E0C80A78](v112);
  v326 = (char *)&v261 - v115;
  v116 = MEMORY[0x1E0C80A78](v114);
  v323 = (char *)&v261 - v117;
  v118 = MEMORY[0x1E0C80A78](v116);
  v321 = (char *)&v261 - v119;
  v120 = MEMORY[0x1E0C80A78](v118);
  v319 = (char *)&v261 - v121;
  v122 = MEMORY[0x1E0C80A78](v120);
  v316 = (char *)&v261 - v123;
  v124 = MEMORY[0x1E0C80A78](v122);
  v314 = (char *)&v261 - v125;
  v126 = MEMORY[0x1E0C80A78](v124);
  v312 = (char *)&v261 - v127;
  v128 = MEMORY[0x1E0C80A78](v126);
  v309 = (char *)&v261 - v129;
  v130 = MEMORY[0x1E0C80A78](v128);
  v307 = (char *)&v261 - v131;
  v132 = MEMORY[0x1E0C80A78](v130);
  v304 = (char *)&v261 - v133;
  v134 = MEMORY[0x1E0C80A78](v132);
  v302 = (char *)&v261 - v135;
  v136 = MEMORY[0x1E0C80A78](v134);
  v300 = (char *)&v261 - v137;
  v138 = MEMORY[0x1E0C80A78](v136);
  v296 = (char *)&v261 - v139;
  v140 = MEMORY[0x1E0C80A78](v138);
  v293 = (char *)&v261 - v141;
  v142 = MEMORY[0x1E0C80A78](v140);
  v288 = (char *)&v261 - v143;
  v144 = MEMORY[0x1E0C80A78](v142);
  v285 = (char *)&v261 - v145;
  v146 = MEMORY[0x1E0C80A78](v144);
  v282 = (char *)&v261 - v147;
  v148 = MEMORY[0x1E0C80A78](v146);
  v281 = (char *)&v261 - v149;
  v150 = MEMORY[0x1E0C80A78](v148);
  v280 = (char *)&v261 - v151;
  v152 = MEMORY[0x1E0C80A78](v150);
  v279 = (char *)&v261 - v153;
  v154 = MEMORY[0x1E0C80A78](v152);
  v277 = (char *)&v261 - v155;
  v156 = MEMORY[0x1E0C80A78](v154);
  v276 = (char *)&v261 - v157;
  v158 = MEMORY[0x1E0C80A78](v156);
  v275 = (char *)&v261 - v159;
  v160 = MEMORY[0x1E0C80A78](v158);
  v274 = (char *)&v261 - v161;
  v162 = MEMORY[0x1E0C80A78](v160);
  v273 = (char *)&v261 - v163;
  v164 = MEMORY[0x1E0C80A78](v162);
  v272 = (char *)&v261 - v165;
  v166 = MEMORY[0x1E0C80A78](v164);
  v271 = (char *)&v261 - v167;
  v168 = MEMORY[0x1E0C80A78](v166);
  v270 = (char *)&v261 - v169;
  v170 = MEMORY[0x1E0C80A78](v168);
  v269 = (char *)&v261 - v171;
  v172 = MEMORY[0x1E0C80A78](v170);
  v268 = (char *)&v261 - v173;
  v174 = MEMORY[0x1E0C80A78](v172);
  v267 = (char *)&v261 - v175;
  v176 = MEMORY[0x1E0C80A78](v174);
  v266 = (char *)&v261 - v177;
  v178 = MEMORY[0x1E0C80A78](v176);
  v265 = (char *)&v261 - v179;
  v180 = MEMORY[0x1E0C80A78](v178);
  v264 = (char *)&v261 - v181;
  v182 = MEMORY[0x1E0C80A78](v180);
  v263 = (char *)&v261 - v183;
  v184 = MEMORY[0x1E0C80A78](v182);
  v262 = (char *)&v261 - v185;
  v186 = MEMORY[0x1E0C80A78](v184);
  v188 = (char *)&v261 - v187;
  v189 = MEMORY[0x1E0C80A78](v186);
  v191 = (char *)&v261 - v190;
  v192 = MEMORY[0x1E0C80A78](v189);
  v194 = (char *)&v261 - v193;
  MEMORY[0x1E0C80A78](v192);
  v196 = (char *)&v261 - v195;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a66, a65, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a66, a65, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v196, v278, v66);
  v199 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v199(v196, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v194, v283, v66);
  v199(v194, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v191, v284, v66);
  v199(v191, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v188, v287, v66);
  v199(v188, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  v200 = v262;
  memcpy(v262, v290, v66);
  v199(v200, 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  v201 = v263;
  memcpy(v263, v292, v66);
  v199(v201, 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  v202 = v264;
  memcpy(v264, v295, v66);
  v199(v202, 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  v203 = v265;
  memcpy(v265, v298, v66);
  v199(v203, 7, AssociatedTypeWitness, AssociatedConformanceWitness);
  v204 = v266;
  memcpy(v266, v286, v66);
  v199(v204, 8, AssociatedTypeWitness, AssociatedConformanceWitness);
  v205 = v267;
  memcpy(v267, v289, v66);
  v199(v205, 9, AssociatedTypeWitness, AssociatedConformanceWitness);
  v206 = v268;
  memcpy(v268, v291, v66);
  v199(v206, 10, AssociatedTypeWitness, AssociatedConformanceWitness);
  v207 = v269;
  memcpy(v269, v294, v66);
  v199(v207, 11, AssociatedTypeWitness, AssociatedConformanceWitness);
  v208 = v270;
  memcpy(v270, v297, v66);
  v199(v208, 12, AssociatedTypeWitness, AssociatedConformanceWitness);
  v209 = v271;
  memcpy(v271, v299, v66);
  v199(v209, 13, AssociatedTypeWitness, AssociatedConformanceWitness);
  v210 = v272;
  memcpy(v272, v301, v66);
  v199(v210, 14, AssociatedTypeWitness, AssociatedConformanceWitness);
  v211 = v273;
  memcpy(v273, v303, v66);
  v199(v211, 15, AssociatedTypeWitness, AssociatedConformanceWitness);
  v212 = v274;
  memcpy(v274, v305, v66);
  v199(v212, 16, AssociatedTypeWitness, AssociatedConformanceWitness);
  v213 = v275;
  memcpy(v275, v306, v66);
  v199(v213, 17, AssociatedTypeWitness, AssociatedConformanceWitness);
  v214 = v276;
  memcpy(v276, v308, v66);
  v199(v214, 18, AssociatedTypeWitness, AssociatedConformanceWitness);
  v215 = v277;
  memcpy(v277, v310, v66);
  v199(v215, 19, AssociatedTypeWitness, AssociatedConformanceWitness);
  v216 = v279;
  memcpy(v279, v311, v66);
  v199(v216, 20, AssociatedTypeWitness, AssociatedConformanceWitness);
  v217 = v280;
  memcpy(v280, v313, v66);
  v199(v217, 21, AssociatedTypeWitness, AssociatedConformanceWitness);
  v218 = v281;
  memcpy(v281, v315, v66);
  v199(v218, 22, AssociatedTypeWitness, AssociatedConformanceWitness);
  v219 = v282;
  memcpy(v282, v317, v66);
  v199(v219, 23, AssociatedTypeWitness, AssociatedConformanceWitness);
  v220 = v285;
  memcpy(v285, v318, v66);
  v199(v220, 24, AssociatedTypeWitness, AssociatedConformanceWitness);
  v221 = v288;
  memcpy(v288, v320, v66);
  v199(v221, 25, AssociatedTypeWitness, AssociatedConformanceWitness);
  v222 = v293;
  memcpy(v293, v322, v66);
  v199(v222, 26, AssociatedTypeWitness, AssociatedConformanceWitness);
  v223 = v296;
  memcpy(v296, v324, v66);
  v199(v223, 27, AssociatedTypeWitness, AssociatedConformanceWitness);
  v224 = v300;
  memcpy(v300, v325, v66);
  v199(v224, 28, AssociatedTypeWitness, AssociatedConformanceWitness);
  v225 = v302;
  memcpy(v302, v327, v66);
  v199(v225, 29, AssociatedTypeWitness, AssociatedConformanceWitness);
  v226 = v304;
  memcpy(v304, v329, v66);
  v199(v226, 30, AssociatedTypeWitness, AssociatedConformanceWitness);
  v227 = v307;
  memcpy(v307, v330, v66);
  v199(v227, 31, AssociatedTypeWitness, AssociatedConformanceWitness);
  v228 = v309;
  memcpy(v309, v332, v66);
  v199(v228, 32, AssociatedTypeWitness, AssociatedConformanceWitness);
  v229 = v312;
  memcpy(v312, v334, v66);
  v199(v229, 33, AssociatedTypeWitness, AssociatedConformanceWitness);
  v230 = v314;
  memcpy(v314, v336, v66);
  v199(v230, 34, AssociatedTypeWitness, AssociatedConformanceWitness);
  v231 = v316;
  memcpy(v316, v337, v66);
  v199(v231, 35, AssociatedTypeWitness, AssociatedConformanceWitness);
  v232 = v319;
  memcpy(v319, v339, v66);
  v199(v232, 36, AssociatedTypeWitness, AssociatedConformanceWitness);
  v233 = v321;
  memcpy(v321, v341, v66);
  v199(v233, 37, AssociatedTypeWitness, AssociatedConformanceWitness);
  v234 = v323;
  memcpy(v323, v342, v66);
  v199(v234, 38, AssociatedTypeWitness, AssociatedConformanceWitness);
  v235 = v326;
  memcpy(v326, v344, v66);
  v199(v235, 39, AssociatedTypeWitness, AssociatedConformanceWitness);
  v236 = v328;
  memcpy(v328, v346, v66);
  v199(v236, 40, AssociatedTypeWitness, AssociatedConformanceWitness);
  v237 = v331;
  memcpy(v331, v348, v66);
  v199(v237, 41, AssociatedTypeWitness, AssociatedConformanceWitness);
  v238 = v333;
  memcpy(v333, v349, v66);
  v199(v238, 42, AssociatedTypeWitness, AssociatedConformanceWitness);
  v239 = v335;
  memcpy(v335, v351, v66);
  v199(v239, 43, AssociatedTypeWitness, AssociatedConformanceWitness);
  v240 = v338;
  memcpy(v338, v353, v66);
  v199(v240, 44, AssociatedTypeWitness, AssociatedConformanceWitness);
  v241 = v340;
  memcpy(v340, v354, v66);
  v199(v241, 45, AssociatedTypeWitness, AssociatedConformanceWitness);
  v242 = v343;
  memcpy(v343, v358, v66);
  v199(v242, 46, AssociatedTypeWitness, AssociatedConformanceWitness);
  v243 = v345;
  memcpy(v345, v360, v66);
  v199(v243, 47, AssociatedTypeWitness, AssociatedConformanceWitness);
  v244 = v347;
  memcpy(v347, v361, v66);
  v199(v244, 48, AssociatedTypeWitness, AssociatedConformanceWitness);
  v245 = v350;
  memcpy(v350, v363, v66);
  v199(v245, 49, AssociatedTypeWitness, AssociatedConformanceWitness);
  v246 = v352;
  memcpy(v352, v365, v66);
  v199(v246, 50, AssociatedTypeWitness, AssociatedConformanceWitness);
  v247 = v355;
  memcpy(v355, v367, v66);
  v199(v247, 51, AssociatedTypeWitness, AssociatedConformanceWitness);
  v248 = v356;
  memcpy(v356, v368, v66);
  v199(v248, 52, AssociatedTypeWitness, AssociatedConformanceWitness);
  v249 = v357;
  memcpy(v357, v370, v66);
  v199(v249, 53, AssociatedTypeWitness, AssociatedConformanceWitness);
  v250 = v359;
  memcpy(v359, v372, v66);
  v199(v250, 54, AssociatedTypeWitness, AssociatedConformanceWitness);
  v251 = v362;
  memcpy(v362, v374, v66);
  v199(v251, 55, AssociatedTypeWitness, AssociatedConformanceWitness);
  v252 = v364;
  memcpy(v364, v376, v66);
  v199(v252, 56, AssociatedTypeWitness, AssociatedConformanceWitness);
  v253 = v366;
  memcpy(v366, v378, v66);
  v199(v253, 57, AssociatedTypeWitness, AssociatedConformanceWitness);
  v254 = v369;
  memcpy(v369, v379, v66);
  v199(v254, 58, AssociatedTypeWitness, AssociatedConformanceWitness);
  v255 = v371;
  memcpy(v371, v381, v66);
  v199(v255, 59, AssociatedTypeWitness, AssociatedConformanceWitness);
  v256 = v373;
  memcpy(v373, v382, v66);
  v199(v256, 60, AssociatedTypeWitness, AssociatedConformanceWitness);
  v257 = v375;
  memcpy(v375, v383, v66);
  v199(v257, 61, AssociatedTypeWitness, AssociatedConformanceWitness);
  v258 = v377;
  memcpy(v377, v384, v66);
  v199(v258, 62, AssociatedTypeWitness, AssociatedConformanceWitness);
  v259 = v380;
  memcpy(v380, v385, v66);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v199)(v259, 63, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD64.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v15)(uint64_t, uint64_t);

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = type metadata accessor for SIMD64(0, a3, (uint64_t)a4, v10);
  specialized SIMD64.lowHalf.setter(a1, v11);
  v13 = type metadata accessor for SIMD32(0, a3, (uint64_t)a4, v12);
  v15 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v13 - 8) + 8);
  v15(a1, v13);
  specialized SIMD64.highHalf.setter(a2, v11);
  return ((uint64_t (*)(uint64_t, uint64_t))v15)(a2, v13);
}

uint64_t SIMD64.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.lowHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32);
}

uint64_t SIMD64.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.highHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32);
}

uint64_t SIMD64.lowHalf.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  const char *v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;
  uint64_t result;
  uint64_t v14;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = *(const char **)(v2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v8 = swift_getAssociatedTypeWitness(255, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v9 = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v10 = 0;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    v12 = swift_checkMetadataState(0, v8);
    v11(v10, v12, v9);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v4, v10++, AssociatedTypeWitness, AssociatedConformanceWitness);
  }
  while (v10 != 32);
  return result;
}

uint64_t key path getter for SIMD64.lowHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, SIMD64.lowHalf.getter);
}

uint64_t key path setter for SIMD64.lowHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, specialized SIMD64.lowHalf.setter);
}

void (*SIMD64.lowHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD32(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD64.lowHalf.getter(a2);
  return SIMD64.lowHalf.modify;
}

void SIMD64.lowHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD64.lowHalf.setter);
}

uint64_t SIMD64.highHalf.getter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  const char *v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;
  uint64_t result;
  uint64_t v14;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = *(const char **)(v2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v8 = swift_getAssociatedTypeWitness(255, v5, v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v9 = swift_getAssociatedConformanceWitness((uint64_t)v5, v1, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v10 = 0;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v9 + 56);
  do
  {
    v12 = swift_checkMetadataState(0, v8);
    v11(v10 + 32, v12, v9);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v4, v10++, AssociatedTypeWitness, AssociatedConformanceWitness);
  }
  while (v10 != 32);
  return result;
}

uint64_t key path getter for SIMD64.highHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, SIMD64.highHalf.getter);
}

uint64_t key path setter for SIMD64.highHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, specialized SIMD64.highHalf.setter);
}

void (*SIMD64.highHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD32(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v5[5] = malloc(v9);
  SIMD64.highHalf.getter(a2);
  return SIMD64.highHalf.modify;
}

void SIMD64.highHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD64.highHalf.setter);
}

uint64_t SIMD64.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  const char *v7;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v10)(unint64_t, unint64_t);
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *(const char **)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v13 = 0;
  v14 = 0;
  v15 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  do
  {
    v16 = swift_checkMetadataState(0, v11);
    v15(v13, v16, v12);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v6, v14, AssociatedTypeWitness, AssociatedConformanceWitness);
    v13 += 2;
    ++v14;
  }
  while (v14 != 32);
  return result;
}

uint64_t key path getter for SIMD64.evenHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, (uint64_t (*)(uint64_t))SIMD64.evenHalf.getter);
}

uint64_t key path setter for SIMD64.evenHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, specialized SIMD64.evenHalf.setter);
}

uint64_t SIMD64.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.evenHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32);
}

void (*SIMD64.evenHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  void *v10;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD32(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD64.evenHalf.modify;
}

void SIMD64.evenHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD64.evenHalf.setter);
}

uint64_t SIMD64.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  const char *v7;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v10)(unint64_t, unint64_t);
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void (*v14)(uint64_t, unint64_t *, unint64_t);
  uint64_t v15;
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v18 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = *(const char **)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v10 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v18 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v13 = 0;
  v14 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v12 + 56);
  v15 = 1;
  do
  {
    v16 = swift_checkMetadataState(0, v11);
    v14(v15, v16, v12);
    result = (*(uint64_t (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                            + 64))(v6, v13, AssociatedTypeWitness, AssociatedConformanceWitness);
    v15 += 2;
    ++v13;
  }
  while (v13 != 32);
  return result;
}

uint64_t key path getter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, (uint64_t (*)(uint64_t))SIMD64.oddHalf.getter);
}

uint64_t key path setter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD64, specialized SIMD64.oddHalf.setter);
}

uint64_t SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.oddHalf.setter, (uint64_t (*)(_QWORD, _QWORD, _QWORD))type metadata accessor for SIMD32);
}

void (*SIMD64.oddHalf.modify(_QWORD *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  void *v10;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = a2;
  v5[1] = v2;
  v7 = type metadata accessor for SIMD32(0, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24), v6);
  v5[2] = v7;
  v8 = *(_QWORD *)(v7 - 8);
  v5[3] = v8;
  v9 = *(_QWORD *)(v8 + 64);
  v5[4] = malloc(v9);
  v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD64.oddHalf.modify;
}

void SIMD64.oddHalf.modify(uint64_t **a1, char a2)
{
  SIMD64.oddHalf.modify(a1, a2, (void (*)(void *, uint64_t))specialized SIMD64.oddHalf.setter);
}

Swift::Int SIMD64.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD64<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD64<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD64Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD64<A>(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD64<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x453uLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD64<A>(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x40)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD64<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD64<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD64<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD64<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD, _QWORD, _QWORD);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t);
  const char *v23;
  unint64_t AssociatedTypeWitness;
  char *v25;
  unint64_t AssociatedConformanceWitness;
  void (*v27)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v28;
  void (*v29)(char *, uint64_t);
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;

  v3 = a3;
  v44 = a2;
  v4 = a1;
  v39 = *(_QWORD *)(a3 + 16);
  v5 = MEMORY[0x1E0C80A78](a1);
  v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = MEMORY[0x1E0C80A78](v5);
  v42 = (char *)&v37 - v8;
  v9 = MEMORY[0x1E0C80A78](v7);
  v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v37 - v13;
  v15 = 0;
  v16 = 1;
  v18 = v17;
  v19 = *(void (**)(_QWORD, _QWORD, _QWORD))(v17 + 16);
  v40 = v12;
  v41 = v20;
  v37 = v19;
  v38 = v17;
  v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      v23 = *(const char **)(v3 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
      v25 = v11;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
      v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      v28 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      v30 = v28;
      v19 = v37;
      v31 = AssociatedConformanceWitness;
      v11 = v25;
      v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      v32 = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      v33 = (uint64_t)v23;
      v4 = v40;
      v34 = swift_getAssociatedConformanceWitness(v33, v21, v32, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      v35 = swift_getAssociatedConformanceWitness(v34, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v18 = v38;
      v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35 + 8) + 8))(v42, v43, v21);
    }
    else
    {
      v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      v16 = 0;
    }
    if (++v15 == 64)
      break;
    v19(v14, v4, v3);
  }
  return v16 & 1;
}

uint64_t SIMD64<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 96))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 64);
  v28 = type metadata accessor for SIMD64(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD64<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 8) + 104))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 64);
  v28 = type metadata accessor for SIMD64(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD64<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  const char *v20;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v23)(unint64_t, unint64_t);
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  unint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  const char *v34;
  void (*v35)(uint64_t, unint64_t *, unint64_t);
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  uint64_t v44;

  v40 = a5;
  v41 = a7;
  v38 = a2;
  v44 = a1;
  v42 = a9;
  v13 = MEMORY[0x1E0C80A78](a1);
  v14 = MEMORY[0x1E0C80A78](v13);
  v16 = (char *)&v33 - v15;
  MEMORY[0x1E0C80A78](v14);
  v18 = (char *)&v33 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  v43 = associated type descriptor for SIMDScalar.SIMD64Storage;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v20, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v39 = a3;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v23 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v37 = AssociatedTypeWitness;
  v23(AssociatedTypeWitness, AssociatedConformanceWitness);
  v24 = swift_getAssociatedTypeWitness(255, a8, (uint64_t)a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, v43);
  v34 = a8;
  v43 = a4;
  v36 = v24;
  v25 = swift_getAssociatedConformanceWitness((uint64_t)a8, (uint64_t)a4, v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v26 = 0;
  v35 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v25 + 56);
  v27 = v41;
  v28 = v43;
  do
  {
    v29 = swift_checkMetadataState(0, v36);
    v35(v26, v29, v25);
    (*(void (**)(uint64_t, _DWORD *))(*(_QWORD *)(v27 + 16) + 304))(v38, v28);
    (*(void (**)(char *, _DWORD *, uint64_t))(*(_QWORD *)(v40 + 8) + 80))(v16, v28, v27);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v18, v26++, v37, AssociatedConformanceWitness);
  }
  while (v26 != 64);
  v31 = type metadata accessor for SIMD64(0, (uint64_t)v43, (uint64_t)v34, v30);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v31 - 8) + 8))(v44, v31);
}

uint64_t SIMD64.debugDescription.getter(uint64_t a1)
{
  Class *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  char *v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  uint64_t v131;
  char *v132;
  uint64_t v133;
  Swift::String v134;
  Swift::String v135;
  const char *v136;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v139)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v140;
  Swift::String v141;
  Swift::String v142;
  Swift::String v143;
  uint64_t v144;
  Swift::String v145;
  uint64_t v146;
  Swift::String v147;
  uint64_t v148;
  Swift::String v149;
  uint64_t v150;
  Swift::String v151;
  uint64_t v152;
  Swift::String v153;
  uint64_t v154;
  Swift::String v155;
  uint64_t v156;
  Swift::String v157;
  uint64_t v158;
  Swift::String v159;
  uint64_t v160;
  Swift::String v161;
  uint64_t v162;
  Swift::String v163;
  uint64_t v164;
  Swift::String v165;
  uint64_t v166;
  Swift::String v167;
  uint64_t v168;
  Swift::String v169;
  uint64_t v170;
  Swift::String v171;
  uint64_t v172;
  Swift::String v173;
  uint64_t v174;
  Swift::String v175;
  uint64_t v176;
  Swift::String v177;
  uint64_t v178;
  Swift::String v179;
  uint64_t v180;
  Swift::String v181;
  uint64_t v182;
  Swift::String v183;
  uint64_t v184;
  Swift::String v185;
  uint64_t v186;
  Swift::String v187;
  uint64_t v188;
  Swift::String v189;
  uint64_t v190;
  Swift::String v191;
  uint64_t v192;
  Swift::String v193;
  uint64_t v194;
  Swift::String v195;
  uint64_t v196;
  Swift::String v197;
  uint64_t v198;
  Swift::String v199;
  uint64_t v200;
  Swift::String v201;
  uint64_t v202;
  Swift::String v203;
  uint64_t v204;
  Swift::String v205;
  uint64_t v206;
  Swift::String v207;
  uint64_t v208;
  Swift::String v209;
  uint64_t v210;
  Swift::String v211;
  uint64_t v212;
  Swift::String v213;
  uint64_t v214;
  Swift::String v215;
  uint64_t v216;
  Swift::String v217;
  uint64_t v218;
  Swift::String v219;
  uint64_t v220;
  Swift::String v221;
  uint64_t v222;
  Swift::String v223;
  uint64_t v224;
  Swift::String v225;
  uint64_t v226;
  Swift::String v227;
  uint64_t v228;
  Swift::String v229;
  uint64_t v230;
  Swift::String v231;
  uint64_t v232;
  Swift::String v233;
  uint64_t v234;
  Swift::String v235;
  uint64_t v236;
  Swift::String v237;
  uint64_t v238;
  Swift::String v239;
  uint64_t v240;
  Swift::String v241;
  uint64_t v242;
  Swift::String v243;
  uint64_t v244;
  Swift::String v245;
  uint64_t v246;
  Swift::String v247;
  uint64_t v248;
  Swift::String v249;
  uint64_t v250;
  Swift::String v251;
  uint64_t v252;
  Swift::String v253;
  uint64_t v254;
  Swift::String v255;
  uint64_t v256;
  Swift::String v257;
  uint64_t v258;
  Swift::String v259;
  uint64_t v260;
  Swift::String v261;
  uint64_t v262;
  Swift::String v263;
  uint64_t v264;
  Swift::String v265;
  char *v267;
  char *v268;
  char *v269;
  char *v270;
  char *v271;
  char *v272;
  char *v273;
  char *v274;
  char *v275;
  char *v276;
  char *v277;
  char *v278;
  char *v279;
  char *v280;
  char *v281;
  char *v282;
  char *v283;
  char *v284;
  char *v285;
  char *v286;
  char *v287;
  char *v288;
  char *v289;
  char *v290;
  char *v291;
  char *v292;
  char *v293;
  char *v294;
  char *v295;
  char *v296;
  char *v297;
  char *v298;
  char *v299;
  char *v300;
  char *v301;
  char *v302;
  char *v303;
  char *v304;
  char *v305;
  char *v306;
  char *v307;
  char *v308;
  char *v309;
  char *v310;
  char *v311;
  char *v312;
  char *v313;
  char *v314;
  char *v315;
  char *v316;
  char *v317;
  char *v318;
  char *v319;
  char *v320;
  char *v321;
  char *v322;
  char *v323;
  char *v324;
  char *v325;
  char *v326;
  char *v327;
  _QWORD v328[2];

  v2 = *(Class **)(a1 + 16);
  v3 = MEMORY[0x1E0C80A78](a1);
  v327 = (char *)&v267 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v5 = MEMORY[0x1E0C80A78](v3);
  v326 = (char *)&v267 - v6;
  v7 = MEMORY[0x1E0C80A78](v5);
  v325 = (char *)&v267 - v8;
  v9 = MEMORY[0x1E0C80A78](v7);
  v324 = (char *)&v267 - v10;
  v11 = MEMORY[0x1E0C80A78](v9);
  v323 = (char *)&v267 - v12;
  v13 = MEMORY[0x1E0C80A78](v11);
  v322 = (char *)&v267 - v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v321 = (char *)&v267 - v16;
  v17 = MEMORY[0x1E0C80A78](v15);
  v320 = (char *)&v267 - v18;
  v19 = MEMORY[0x1E0C80A78](v17);
  v319 = (char *)&v267 - v20;
  v21 = MEMORY[0x1E0C80A78](v19);
  v318 = (char *)&v267 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v317 = (char *)&v267 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v316 = (char *)&v267 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v315 = (char *)&v267 - v28;
  v29 = MEMORY[0x1E0C80A78](v27);
  v314 = (char *)&v267 - v30;
  v31 = MEMORY[0x1E0C80A78](v29);
  v313 = (char *)&v267 - v32;
  v33 = MEMORY[0x1E0C80A78](v31);
  v312 = (char *)&v267 - v34;
  v35 = MEMORY[0x1E0C80A78](v33);
  v311 = (char *)&v267 - v36;
  v37 = MEMORY[0x1E0C80A78](v35);
  v310 = (char *)&v267 - v38;
  v39 = MEMORY[0x1E0C80A78](v37);
  v309 = (char *)&v267 - v40;
  v41 = MEMORY[0x1E0C80A78](v39);
  v308 = (char *)&v267 - v42;
  v43 = MEMORY[0x1E0C80A78](v41);
  v307 = (char *)&v267 - v44;
  v45 = MEMORY[0x1E0C80A78](v43);
  v306 = (char *)&v267 - v46;
  v47 = MEMORY[0x1E0C80A78](v45);
  v305 = (char *)&v267 - v48;
  v49 = MEMORY[0x1E0C80A78](v47);
  v304 = (char *)&v267 - v50;
  v51 = MEMORY[0x1E0C80A78](v49);
  v303 = (char *)&v267 - v52;
  v53 = MEMORY[0x1E0C80A78](v51);
  v302 = (char *)&v267 - v54;
  v55 = MEMORY[0x1E0C80A78](v53);
  v301 = (char *)&v267 - v56;
  v57 = MEMORY[0x1E0C80A78](v55);
  v300 = (char *)&v267 - v58;
  v59 = MEMORY[0x1E0C80A78](v57);
  v299 = (char *)&v267 - v60;
  v61 = MEMORY[0x1E0C80A78](v59);
  v298 = (char *)&v267 - v62;
  v63 = MEMORY[0x1E0C80A78](v61);
  v297 = (char *)&v267 - v64;
  v65 = MEMORY[0x1E0C80A78](v63);
  v296 = (char *)&v267 - v66;
  v67 = MEMORY[0x1E0C80A78](v65);
  v295 = (char *)&v267 - v68;
  v69 = MEMORY[0x1E0C80A78](v67);
  v294 = (char *)&v267 - v70;
  v71 = MEMORY[0x1E0C80A78](v69);
  v293 = (char *)&v267 - v72;
  v73 = MEMORY[0x1E0C80A78](v71);
  v292 = (char *)&v267 - v74;
  v75 = MEMORY[0x1E0C80A78](v73);
  v291 = (char *)&v267 - v76;
  v77 = MEMORY[0x1E0C80A78](v75);
  v290 = (char *)&v267 - v78;
  v79 = MEMORY[0x1E0C80A78](v77);
  v289 = (char *)&v267 - v80;
  v81 = MEMORY[0x1E0C80A78](v79);
  v288 = (char *)&v267 - v82;
  v83 = MEMORY[0x1E0C80A78](v81);
  v287 = (char *)&v267 - v84;
  v85 = MEMORY[0x1E0C80A78](v83);
  v286 = (char *)&v267 - v86;
  v87 = MEMORY[0x1E0C80A78](v85);
  v285 = (char *)&v267 - v88;
  v89 = MEMORY[0x1E0C80A78](v87);
  v284 = (char *)&v267 - v90;
  v91 = MEMORY[0x1E0C80A78](v89);
  v283 = (char *)&v267 - v92;
  v93 = MEMORY[0x1E0C80A78](v91);
  v282 = (char *)&v267 - v94;
  v95 = MEMORY[0x1E0C80A78](v93);
  v281 = (char *)&v267 - v96;
  v97 = MEMORY[0x1E0C80A78](v95);
  v280 = (char *)&v267 - v98;
  v99 = MEMORY[0x1E0C80A78](v97);
  v279 = (char *)&v267 - v100;
  v101 = MEMORY[0x1E0C80A78](v99);
  v278 = (char *)&v267 - v102;
  v103 = MEMORY[0x1E0C80A78](v101);
  v277 = (char *)&v267 - v104;
  v105 = MEMORY[0x1E0C80A78](v103);
  v276 = (char *)&v267 - v106;
  v107 = MEMORY[0x1E0C80A78](v105);
  v275 = (char *)&v267 - v108;
  v109 = MEMORY[0x1E0C80A78](v107);
  v274 = (char *)&v267 - v110;
  v111 = MEMORY[0x1E0C80A78](v109);
  v273 = (char *)&v267 - v112;
  v113 = MEMORY[0x1E0C80A78](v111);
  v272 = (char *)&v267 - v114;
  v115 = MEMORY[0x1E0C80A78](v113);
  v271 = (char *)&v267 - v116;
  v117 = MEMORY[0x1E0C80A78](v115);
  v270 = (char *)&v267 - v118;
  v119 = MEMORY[0x1E0C80A78](v117);
  v269 = (char *)&v267 - v120;
  v121 = MEMORY[0x1E0C80A78](v119);
  v268 = (char *)&v267 - v122;
  v123 = MEMORY[0x1E0C80A78](v121);
  v267 = (char *)&v267 - v124;
  v125 = MEMORY[0x1E0C80A78](v123);
  v127 = (char *)&v267 - v126;
  v128 = MEMORY[0x1E0C80A78](v125);
  v130 = (char *)&v267 - v129;
  MEMORY[0x1E0C80A78](v128);
  v132 = (char *)&v267 - v131;
  v328[0] = specialized static String._createEmpty(withInitialCapacity:)(266);
  v328[1] = v133;
  v134._countAndFlagsBits = 0x3C3436444D4953;
  v134._object = (void *)0xE700000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v134);
  swift_bridgeObjectRelease(0xE700000000000000);
  DefaultStringInterpolation.appendInterpolation(_:)(v2);
  v135._countAndFlagsBits = 10302;
  v135._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v135);
  swift_bridgeObjectRelease(0xE200000000000000);
  v136 = *(const char **)(a1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v136, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v136, (uint64_t)v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v139 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v140 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v139(0, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v132, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v141._countAndFlagsBits = 8236;
  v141._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v141);
  swift_bridgeObjectRelease(0xE200000000000000);
  v139(1, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v130, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v142._countAndFlagsBits = 8236;
  v142._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v142);
  swift_bridgeObjectRelease(0xE200000000000000);
  v139(2, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v127, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v143._countAndFlagsBits = 8236;
  v143._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v143);
  swift_bridgeObjectRelease(0xE200000000000000);
  v144 = (uint64_t)v267;
  v139(3, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v144, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v145._countAndFlagsBits = 8236;
  v145._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v145);
  swift_bridgeObjectRelease(0xE200000000000000);
  v146 = (uint64_t)v268;
  v139(4, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v146, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v147._countAndFlagsBits = 8236;
  v147._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v147);
  swift_bridgeObjectRelease(0xE200000000000000);
  v148 = (uint64_t)v269;
  v139(5, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v148, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v149._countAndFlagsBits = 8236;
  v149._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v149);
  swift_bridgeObjectRelease(0xE200000000000000);
  v150 = (uint64_t)v270;
  v139(6, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v150, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v151._countAndFlagsBits = 8236;
  v151._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v151);
  swift_bridgeObjectRelease(0xE200000000000000);
  v152 = (uint64_t)v271;
  v139(7, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v152, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v153._countAndFlagsBits = 8236;
  v153._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v153);
  swift_bridgeObjectRelease(0xE200000000000000);
  v154 = (uint64_t)v272;
  v139(8, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v154, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v155._countAndFlagsBits = 8236;
  v155._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v155);
  swift_bridgeObjectRelease(0xE200000000000000);
  v156 = (uint64_t)v273;
  v139(9, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v156, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v157._countAndFlagsBits = 8236;
  v157._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v157);
  swift_bridgeObjectRelease(0xE200000000000000);
  v158 = (uint64_t)v274;
  v139(10, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v158, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v159._countAndFlagsBits = 8236;
  v159._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v159);
  swift_bridgeObjectRelease(0xE200000000000000);
  v160 = (uint64_t)v275;
  v139(11, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v160, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v161._countAndFlagsBits = 8236;
  v161._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v161);
  swift_bridgeObjectRelease(0xE200000000000000);
  v162 = (uint64_t)v276;
  v139(12, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v162, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v163._countAndFlagsBits = 8236;
  v163._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v163);
  swift_bridgeObjectRelease(0xE200000000000000);
  v164 = (uint64_t)v277;
  v139(13, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v164, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v165._countAndFlagsBits = 8236;
  v165._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v165);
  swift_bridgeObjectRelease(0xE200000000000000);
  v166 = (uint64_t)v278;
  v139(14, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v166, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v167._countAndFlagsBits = 8236;
  v167._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v167);
  swift_bridgeObjectRelease(0xE200000000000000);
  v168 = (uint64_t)v279;
  v139(15, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v168, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v169._countAndFlagsBits = 8236;
  v169._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v169);
  swift_bridgeObjectRelease(0xE200000000000000);
  v170 = (uint64_t)v280;
  v139(16, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v170, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v171._countAndFlagsBits = 8236;
  v171._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v171);
  swift_bridgeObjectRelease(0xE200000000000000);
  v172 = (uint64_t)v281;
  v139(17, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v172, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v173._countAndFlagsBits = 8236;
  v173._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v173);
  swift_bridgeObjectRelease(0xE200000000000000);
  v174 = (uint64_t)v282;
  v139(18, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v174, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v175._countAndFlagsBits = 8236;
  v175._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v175);
  swift_bridgeObjectRelease(0xE200000000000000);
  v176 = (uint64_t)v283;
  v139(19, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v176, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v177._countAndFlagsBits = 8236;
  v177._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v177);
  swift_bridgeObjectRelease(0xE200000000000000);
  v178 = (uint64_t)v284;
  v139(20, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v178, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v179._countAndFlagsBits = 8236;
  v179._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v179);
  swift_bridgeObjectRelease(0xE200000000000000);
  v180 = (uint64_t)v285;
  v139(21, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v180, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v181._countAndFlagsBits = 8236;
  v181._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v181);
  swift_bridgeObjectRelease(0xE200000000000000);
  v182 = (uint64_t)v286;
  v139(22, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v182, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v183._countAndFlagsBits = 8236;
  v183._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v183);
  swift_bridgeObjectRelease(0xE200000000000000);
  v184 = (uint64_t)v287;
  v139(23, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v184, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v185._countAndFlagsBits = 8236;
  v185._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v185);
  swift_bridgeObjectRelease(0xE200000000000000);
  v186 = (uint64_t)v288;
  v139(24, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v186, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v187._countAndFlagsBits = 8236;
  v187._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v187);
  swift_bridgeObjectRelease(0xE200000000000000);
  v188 = (uint64_t)v289;
  v139(25, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v188, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v189._countAndFlagsBits = 8236;
  v189._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v189);
  swift_bridgeObjectRelease(0xE200000000000000);
  v190 = (uint64_t)v290;
  v139(26, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v190, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v191._countAndFlagsBits = 8236;
  v191._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v191);
  swift_bridgeObjectRelease(0xE200000000000000);
  v192 = (uint64_t)v291;
  v139(27, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v192, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v193._countAndFlagsBits = 8236;
  v193._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v193);
  swift_bridgeObjectRelease(0xE200000000000000);
  v194 = (uint64_t)v292;
  v139(28, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v194, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v195._countAndFlagsBits = 8236;
  v195._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v195);
  swift_bridgeObjectRelease(0xE200000000000000);
  v196 = (uint64_t)v293;
  v139(29, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v196, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v197._countAndFlagsBits = 8236;
  v197._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v197);
  swift_bridgeObjectRelease(0xE200000000000000);
  v198 = (uint64_t)v294;
  v139(30, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v198, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v199._countAndFlagsBits = 8236;
  v199._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v199);
  swift_bridgeObjectRelease(0xE200000000000000);
  v200 = (uint64_t)v295;
  v139(31, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v200, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v201._countAndFlagsBits = 8236;
  v201._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v201);
  swift_bridgeObjectRelease(0xE200000000000000);
  v202 = (uint64_t)v296;
  v139(32, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v202, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v203._countAndFlagsBits = 8236;
  v203._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v203);
  swift_bridgeObjectRelease(0xE200000000000000);
  v204 = (uint64_t)v297;
  v139(33, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v204, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v205._countAndFlagsBits = 8236;
  v205._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v205);
  swift_bridgeObjectRelease(0xE200000000000000);
  v206 = (uint64_t)v298;
  v139(34, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v206, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v207._countAndFlagsBits = 8236;
  v207._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v207);
  swift_bridgeObjectRelease(0xE200000000000000);
  v208 = (uint64_t)v299;
  v139(35, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v208, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v209._countAndFlagsBits = 8236;
  v209._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v209);
  swift_bridgeObjectRelease(0xE200000000000000);
  v210 = (uint64_t)v300;
  v139(36, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v210, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v211._countAndFlagsBits = 8236;
  v211._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v211);
  swift_bridgeObjectRelease(0xE200000000000000);
  v212 = (uint64_t)v301;
  v139(37, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v212, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v213._countAndFlagsBits = 8236;
  v213._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v213);
  swift_bridgeObjectRelease(0xE200000000000000);
  v214 = (uint64_t)v302;
  v139(38, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v214, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v215._countAndFlagsBits = 8236;
  v215._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v215);
  swift_bridgeObjectRelease(0xE200000000000000);
  v216 = (uint64_t)v303;
  v139(39, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v216, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v217._countAndFlagsBits = 8236;
  v217._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v217);
  swift_bridgeObjectRelease(0xE200000000000000);
  v218 = (uint64_t)v304;
  v139(40, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v218, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v219._countAndFlagsBits = 8236;
  v219._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v219);
  swift_bridgeObjectRelease(0xE200000000000000);
  v220 = (uint64_t)v305;
  v139(41, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v220, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v221._countAndFlagsBits = 8236;
  v221._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v221);
  swift_bridgeObjectRelease(0xE200000000000000);
  v222 = (uint64_t)v306;
  v139(42, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v222, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v223._countAndFlagsBits = 8236;
  v223._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v223);
  swift_bridgeObjectRelease(0xE200000000000000);
  v224 = (uint64_t)v307;
  v139(43, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v224, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v225._countAndFlagsBits = 8236;
  v225._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v225);
  swift_bridgeObjectRelease(0xE200000000000000);
  v226 = (uint64_t)v308;
  v139(44, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v226, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v227._countAndFlagsBits = 8236;
  v227._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v227);
  swift_bridgeObjectRelease(0xE200000000000000);
  v228 = (uint64_t)v309;
  v139(45, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v228, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v229._countAndFlagsBits = 8236;
  v229._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v229);
  swift_bridgeObjectRelease(0xE200000000000000);
  v230 = (uint64_t)v310;
  v139(46, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v230, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v231._countAndFlagsBits = 8236;
  v231._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v231);
  swift_bridgeObjectRelease(0xE200000000000000);
  v232 = (uint64_t)v311;
  v139(47, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v232, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v233._countAndFlagsBits = 8236;
  v233._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v233);
  swift_bridgeObjectRelease(0xE200000000000000);
  v234 = (uint64_t)v312;
  v139(48, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v234, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v235._countAndFlagsBits = 8236;
  v235._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v235);
  swift_bridgeObjectRelease(0xE200000000000000);
  v236 = (uint64_t)v313;
  v139(49, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v236, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v237._countAndFlagsBits = 8236;
  v237._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v237);
  swift_bridgeObjectRelease(0xE200000000000000);
  v238 = (uint64_t)v314;
  v139(50, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v238, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v239._countAndFlagsBits = 8236;
  v239._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v239);
  swift_bridgeObjectRelease(0xE200000000000000);
  v240 = (uint64_t)v315;
  v139(51, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v240, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v241._countAndFlagsBits = 8236;
  v241._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v241);
  swift_bridgeObjectRelease(0xE200000000000000);
  v242 = (uint64_t)v316;
  v139(52, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v242, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v243._countAndFlagsBits = 8236;
  v243._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v243);
  swift_bridgeObjectRelease(0xE200000000000000);
  v244 = (uint64_t)v317;
  v139(53, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v244, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v245._countAndFlagsBits = 8236;
  v245._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v245);
  swift_bridgeObjectRelease(0xE200000000000000);
  v246 = (uint64_t)v318;
  v139(54, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v246, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v247._countAndFlagsBits = 8236;
  v247._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v247);
  swift_bridgeObjectRelease(0xE200000000000000);
  v248 = (uint64_t)v319;
  v139(55, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v248, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v249._countAndFlagsBits = 8236;
  v249._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v249);
  swift_bridgeObjectRelease(0xE200000000000000);
  v250 = (uint64_t)v320;
  v139(56, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v250, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v251._countAndFlagsBits = 8236;
  v251._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v251);
  swift_bridgeObjectRelease(0xE200000000000000);
  v252 = (uint64_t)v321;
  v139(57, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v252, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v253._countAndFlagsBits = 8236;
  v253._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v253);
  swift_bridgeObjectRelease(0xE200000000000000);
  v254 = (uint64_t)v322;
  v139(58, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v254, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v255._countAndFlagsBits = 8236;
  v255._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v255);
  swift_bridgeObjectRelease(0xE200000000000000);
  v256 = (uint64_t)v323;
  v139(59, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v256, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v257._countAndFlagsBits = 8236;
  v257._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v257);
  swift_bridgeObjectRelease(0xE200000000000000);
  v258 = (uint64_t)v324;
  v139(60, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v258, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v259._countAndFlagsBits = 8236;
  v259._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v259);
  swift_bridgeObjectRelease(0xE200000000000000);
  v260 = (uint64_t)v325;
  v139(61, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v260, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v261._countAndFlagsBits = 8236;
  v261._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v261);
  swift_bridgeObjectRelease(0xE200000000000000);
  v262 = (uint64_t)v326;
  v139(62, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v262, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v263._countAndFlagsBits = 8236;
  v263._object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v263);
  swift_bridgeObjectRelease(0xE200000000000000);
  v264 = (uint64_t)v327;
  v139(63, v140, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v264, (uint64_t)v328, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v265._countAndFlagsBits = 41;
  v265._object = (void *)0xE100000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v265);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v328[0];
}

uint64_t SIMD64<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a4;
  v35 = a6;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v32 = AssociatedTypeWitness;
  v33 = a8;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v36 = a3;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v22);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v34 + 16) + 72))(v14, v36, *(_QWORD *)(v35 + 8), a2);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v32, AssociatedConformanceWitness);
  }
  while (v24 != 64);
  v28 = type metadata accessor for SIMD64(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v20)(unint64_t, unint64_t);
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  void (*v25)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v31 = a7;
  v34 = a6;
  v35 = a8;
  v37 = a1;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v16 = (char *)&v30 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v20 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48);
  v33 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  v21 = v31;
  v22 = swift_getAssociatedTypeWitness(255, v31, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  v36 = a3;
  v32 = v22;
  v23 = swift_getAssociatedConformanceWitness((uint64_t)v21, a3, v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v24 = 0;
  v25 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v23 + 56);
  do
  {
    v26 = swift_checkMetadataState(0, v32);
    v25(v24, v26, v23);
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(v14, v36, v34, a2, a4);
    (*(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64))(v16, v24++, v33, AssociatedConformanceWitness);
  }
  while (v24 != 64);
  v28 = type metadata accessor for SIMD64(0, v36, (uint64_t)v31, v27);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v28 - 8) + 8))(v37, v28);
}

uint64_t SIMD3._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage, a2);
}

uint64_t SIMD3._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t EnumeratedSequence.Iterator._base.setter(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v4;
  unint64_t AssociatedTypeWitness;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a2 + 24), *(_QWORD *)(a2 + 16), a3, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 40))(v4, a1, AssociatedTypeWitness);
}

uint64_t (*SIMD3._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD3.scalarCount.getter()
{
  return 3;
}

uint64_t key path getter for SIMD3.subscript(_:) : <A>SIMD3<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v8)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v9;

  v3 = *a2;
  if ((unint64_t)*a2 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  v4 = *(const char **)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v8 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD3.subscript(_:) : <A>SIMD3<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  char *v7;
  unint64_t *v8;
  unint64_t v9;
  const void *v10;
  size_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v14)(char *, unint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t v17;

  v4 = *(_QWORD *)(a4 + a3 - 16);
  v5 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v7 = (char *)&v17 - v6;
  v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x58BuLL, 0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v14 = *(uint64_t (**)(char *, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                 + 64);
  v15 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD3.subscript.modify(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

void SIMD2.subscript.modify(uint64_t **a1, char a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;

  v2 = *a1;
  v3 = (*a1)[6];
  v4 = (*a1)[7];
  v6 = (void *)(*a1)[4];
  v5 = (void *)(*a1)[5];
  v7 = (void *)(*a1)[3];
  v8 = **a1;
  if ((a2 & 1) != 0)
    v9 = (void *)(*a1)[3];
  else
    v9 = (void *)(*a1)[4];
  memcpy(v9, v5, (*a1)[2]);
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v3 + 64))(v9, v8, v4, v3);
  free(v5);
  free(v6);
  free(v7);
  free(v2);
}

uint64_t SIMD3.init(_:_:_:)(const void *a1, const void *a2, const void *a3, uint64_t a4, const char *a5)
{
  size_t v10;
  uint64_t v11;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v14)(char *, uint64_t, unint64_t, unint64_t);
  uint64_t v16;

  v10 = *(_QWORD *)(*(_QWORD *)(a4 - 8) + 64);
  MEMORY[0x1E0C80A78](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a5, a4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v10);
  v14 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v14((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v10);
  v14((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v10);
  return ((uint64_t (*)(char *, uint64_t, unint64_t, unint64_t))v14)((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD3.x.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t SIMD3.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

void (*SIMD3.x.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(_QWORD, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(0, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

uint64_t SIMD3.y.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t SIMD3.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

void (*SIMD3.y.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(1, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

uint64_t SIMD3.z.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t SIMD2.x.getter(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  const char *v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v10;
  uint64_t (*v12)(uint64_t, unint64_t *, unint64_t);

  v7 = *(_QWORD *)(a1 + 16);
  v6 = *(const char **)(a1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a2);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  v12 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v10 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v12(a4, v10, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  const char *v9;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v12)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v13;

  v8 = *(_QWORD *)(a3 + a2 - 16);
  v9 = *(const char **)(a3 + a2 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v9, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a5);
  v12 = *(uint64_t (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v13 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v12(a6, v13, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  char *v13;
  const void *v14;
  size_t v15;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v18)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v19;
  uint64_t v21;

  v10 = *(_QWORD *)(a4 + a3 - 16);
  v11 = *(const char **)(a4 + a3 - 8);
  MEMORY[0x1E0C80A78](a1);
  v13 = (char *)&v21 - v12;
  memcpy((char *)&v21 - v12, v14, v15);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a5);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v11, v10, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a6);
  v18 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 64);
  v19 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v18(v13, a7, v19, AssociatedConformanceWitness);
}

uint64_t SIMD3.z.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t SIMD2.x.setter(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  char *v11;
  const void *v12;
  const char *v13;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t (*v16)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v17;
  uint64_t v19;

  v9 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  memcpy(v11, v12, v10);
  v13 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, v9, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v13, v9, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  v16 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 64);
  v17 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v16(v11, a5, v17, AssociatedConformanceWitness);
}

void (*SIMD3.z.modify(_QWORD *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;

  v5 = malloc(0x30uLL);
  *a1 = v5;
  *v5 = v2;
  v6 = *(_QWORD *)(a2 + 16);
  v7 = *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  v8 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v5[5] = v12;
  v11(2, v12, AssociatedConformanceWitness);
  return SIMD4.z.modify;
}

void SIMD2.x.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;

  v4 = *(void **)a1;
  v6 = *(_QWORD *)(*(_QWORD *)a1 + 32);
  v5 = *(_QWORD *)(*(_QWORD *)a1 + 40);
  v8 = *(void **)(*(_QWORD *)a1 + 16);
  v7 = *(void **)(*(_QWORD *)a1 + 24);
  memcpy(v8, v7, *(_QWORD *)(*(_QWORD *)a1 + 8));
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v6 + 64))(v8, a3, v5, v6);
  free(v7);
  free(v8);
  free(v4);
}

Swift::Int SIMD3.hashValue.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, (uint64_t)&protocol conformance descriptor for SIMD3<A>, a3);
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMD3<A>()
{
  return 3;
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD2<A>(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;

  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(const char **)(a1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  return (*(uint64_t (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD3<A>(unint64_t a1, uint64_t a2)
{
  const char *v3;
  uint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v7;
  uint64_t (*v9)(unint64_t, unint64_t *, unint64_t);

  if (a1 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  v4 = *(_QWORD *)(a2 + 16);
  v3 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v9 = *(uint64_t (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                        + 56);
  v7 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD3<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  unint64_t *v9;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t *, unint64_t);

  if (a2 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x58BuLL, 0);
  v6 = *(_QWORD *)(a3 + 16);
  v5 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness
                                                                                                  + 64);
  v9 = swift_checkMetadataState(0, AssociatedTypeWitness);
  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD3<A>(_QWORD *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v3;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(unint64_t, unint64_t *, unint64_t);
  unint64_t *v14;

  v7 = malloc(0x40uLL);
  *a1 = v7;
  *v7 = a2;
  v7[1] = v3;
  v8 = *(_QWORD *)(a3 + 16);
  v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  v10 = *(const char **)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  v13 = *(void (**)(unint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD3<A>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.encode(to:)(a1, a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD3<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.init(from:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD3<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.hash(into:)(a1, a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD3<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD3<A>);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t WitnessTable;
  _QWORD v7[5];
  __int128 v8;
  __int128 v9;

  v7[0] = 0;
  v7[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v7[2] = unk_1ECD25520 ^ 0x646F72616E646F6DLL;
  v7[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v7[4] = unk_1ECD25520 ^ 0x7465646279746573;
  v8 = 0u;
  v9 = 0u;
  WitnessTable = swift_getWitnessTable(a4, a2, a3);
  SIMD.hash(into:)((uint64_t)v7, a2, WitnessTable);
  return Hasher._finalize()();
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD3<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a1, a3);
  return SIMD.description.getter(a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD3<A>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.init(arrayLiteral:)(a1, a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD3<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD, _QWORD, _QWORD);
  uint64_t v20;
  uint64_t v21;
  void (*v22)(char *, uint64_t);
  const char *v23;
  unint64_t AssociatedTypeWitness;
  char *v25;
  unint64_t AssociatedConformanceWitness;
  void (*v27)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v28;
  void (*v29)(char *, uint64_t);
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v37)(_QWORD, _QWORD, _QWORD);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;

  v3 = a3;
  v44 = a2;
  v4 = a1;
  v39 = *(_QWORD *)(a3 + 16);
  v5 = MEMORY[0x1E0C80A78](a1);
  v43 = (char *)&v37 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = MEMORY[0x1E0C80A78](v5);
  v42 = (char *)&v37 - v8;
  v9 = MEMORY[0x1E0C80A78](v7);
  v11 = (char *)&v37 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v9);
  v14 = (char *)&v37 - v13;
  v15 = 0;
  v16 = 1;
  v18 = v17;
  v19 = *(void (**)(_QWORD, _QWORD, _QWORD))(v17 + 16);
  v40 = v12;
  v41 = v20;
  v37 = v19;
  v38 = v17;
  v21 = v39;
  v19((char *)&v37 - v13, v4, v3);
  while (1)
  {
    v19(v11, v44, v3);
    if ((v16 & 1) != 0)
    {
      v23 = *(const char **)(v3 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
      v25 = v11;
      AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
      v27 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
      v28 = swift_checkMetadataState(0, AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      v29 = *(void (**)(char *, uint64_t))(v18 + 8);
      v29(v14, v41);
      v30 = v28;
      v19 = v37;
      v31 = AssociatedConformanceWitness;
      v11 = v25;
      v3 = v41;
      v27(v15, v30, v31);
      v29(v11, v3);
      v32 = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      v33 = (uint64_t)v23;
      v4 = v40;
      v34 = swift_getAssociatedConformanceWitness(v33, v21, v32, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      v35 = swift_getAssociatedConformanceWitness(v34, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      v18 = v38;
      v16 = (*(uint64_t (**)(char *, char *, uint64_t))(*(_QWORD *)(v35 + 8) + 8))(v42, v43, v21);
    }
    else
    {
      v22 = *(void (**)(char *, uint64_t))(v18 + 8);
      v22(v11, v3);
      v22(v14, v3);
      v16 = 0;
    }
    if (++v15 == 3)
      break;
    v19(v14, v4, v3);
  }
  return v16 & 1;
}

uint64_t SIMD3<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  void (*v21)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v22;
  void (*v23)(char *, uint64_t, uint64_t, uint64_t);
  char *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  void (*v28)(uint64_t, unint64_t *, unint64_t);
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  void (*v32)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v39)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  unint64_t v42;
  void (*v43)(uint64_t, unint64_t *, unint64_t);
  char *v44;
  uint64_t v45;
  const char *v46;
  unint64_t AssociatedConformanceWitness;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v45 = a6;
  v51 = a4;
  v52 = a1;
  v49 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v44 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v48 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = (uint64_t)a7;
  v46 = a7;
  v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v50 = a3;
  v20 = swift_getAssociatedConformanceWitness(v18, a3, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v21 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v20 + 56);
  v42 = v20;
  v43 = v21;
  v40 = v19;
  v22 = swift_checkMetadataState(0, v19);
  v21(0, v22, v20);
  v51 = *(_QWORD *)(v51 + 8);
  v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v51 + 96);
  v24 = v44;
  v45 = *(_QWORD *)(v45 + 8);
  v25 = v45;
  v23(v14, a3, v45, a2);
  v41 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23;
  v26 = v48;
  v39 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v39)(v24, 0, v48);
  v27 = swift_checkMetadataState(0, v19);
  v29 = v42;
  v28 = v43;
  v43(1, v27, v42);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23)(v14, v50, v25, a2, v51);
  v30 = v26;
  v31 = AssociatedConformanceWitness;
  v32 = v39;
  v39(v24, 1, v30, AssociatedConformanceWitness);
  v33 = swift_checkMetadataState(0, v40);
  v34 = v52;
  v28(2, v33, v29);
  v35 = v50;
  v41(v14, v50, v45, a2, v51);
  v32(v24, 2, v48, v31);
  v37 = type metadata accessor for SIMD3(0, v35, (uint64_t)v46, v36);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v37 - 8) + 8))(v34, v37);
}

uint64_t SIMD3<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  void (*v21)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v22;
  void (*v23)(char *, uint64_t, uint64_t, uint64_t);
  char *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  void (*v28)(uint64_t, unint64_t *, unint64_t);
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  void (*v32)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v39)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  unint64_t v42;
  void (*v43)(uint64_t, unint64_t *, unint64_t);
  char *v44;
  uint64_t v45;
  const char *v46;
  unint64_t AssociatedConformanceWitness;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v45 = a6;
  v51 = a4;
  v52 = a1;
  v49 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v44 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v48 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = (uint64_t)a7;
  v46 = a7;
  v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v50 = a3;
  v20 = swift_getAssociatedConformanceWitness(v18, a3, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v21 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v20 + 56);
  v42 = v20;
  v43 = v21;
  v40 = v19;
  v22 = swift_checkMetadataState(0, v19);
  v21(0, v22, v20);
  v51 = *(_QWORD *)(v51 + 8);
  v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v51 + 104);
  v24 = v44;
  v45 = *(_QWORD *)(v45 + 8);
  v25 = v45;
  v23(v14, a3, v45, a2);
  v41 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23;
  v26 = v48;
  v39 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v39)(v24, 0, v48);
  v27 = swift_checkMetadataState(0, v19);
  v29 = v42;
  v28 = v43;
  v43(1, v27, v42);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23)(v14, v50, v25, a2, v51);
  v30 = v26;
  v31 = AssociatedConformanceWitness;
  v32 = v39;
  v39(v24, 1, v30, AssociatedConformanceWitness);
  v33 = swift_checkMetadataState(0, v40);
  v34 = v52;
  v28(2, v33, v29);
  v35 = v50;
  v41(v14, v50, v45, a2, v51);
  v32(v24, 2, v48, v31);
  v37 = type metadata accessor for SIMD3(0, v35, (uint64_t)v46, v36);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v37 - 8) + 8))(v34, v37);
}

uint64_t SIMD3<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, const char *a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  unint64_t AssociatedTypeWitness;
  const char *v20;
  unint64_t v21;
  unint64_t v22;
  void (*v23)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v24;
  uint64_t v25;
  void (*v26)(uint64_t, uint64_t, uint64_t);
  char *v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  char *v31;
  unint64_t *v32;
  unint64_t v33;
  void (*v34)(uint64_t, unint64_t *, unint64_t);
  char *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  void (*v46)(_QWORD, unint64_t *, unint64_t);
  char *v47;
  unint64_t AssociatedConformanceWitness;
  unint64_t v49;
  uint64_t v50;
  char *v51;
  void (*v52)(char *, uint64_t, unint64_t, unint64_t);
  void (*v53)(char *, uint64_t, uint64_t, uint64_t);
  uint64_t v54;
  uint64_t v55;
  void (*v56)(uint64_t, uint64_t, uint64_t);
  unint64_t v57;
  uint64_t v58;
  const char *v59;
  uint64_t v60;

  v59 = a8;
  v60 = a7;
  v54 = a5;
  v45 = a2;
  v58 = a1;
  v50 = a9;
  v13 = MEMORY[0x1E0C80A78](a1);
  v14 = MEMORY[0x1E0C80A78](v13);
  v51 = (char *)&v43 - v15;
  MEMORY[0x1E0C80A78](v14);
  v47 = (char *)&v43 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v18, v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v49 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v20 = v59;
  v21 = swift_getAssociatedTypeWitness(255, v59, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v57 = v21;
  v22 = swift_getAssociatedConformanceWitness((uint64_t)v20, a4, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v46 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v22 + 56);
  v23 = v46;
  v24 = swift_checkMetadataState(0, v21);
  v44 = v22;
  v23(0, v24, v22);
  v25 = v60;
  v26 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v60 + 16) + 304);
  v55 = *(_QWORD *)(v60 + 16);
  v56 = v26;
  v27 = v51;
  ((void (*)(uint64_t, uint64_t))v26)(a2, a4);
  v28 = *(_QWORD *)(v54 + 8);
  v53 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v28 + 80);
  v54 = v28;
  v29 = v47;
  v53(v27, a4, v25, a3);
  v30 = v49;
  v52 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v31 = v29;
  ((void (*)(char *, _QWORD, unint64_t))v52)(v29, 0, v49);
  v32 = swift_checkMetadataState(0, v57);
  v33 = v22;
  v34 = v46;
  v46(1, v32, v33);
  v35 = v51;
  v36 = v45;
  v56(v45, a4, v55);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v53)(v35, a4, v60, a3, v54);
  v37 = AssociatedConformanceWitness;
  v52(v31, 1, v30, AssociatedConformanceWitness);
  v38 = swift_checkMetadataState(0, v57);
  v39 = v58;
  v34(2, v38, v44);
  v56(v36, a4, v55);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v53)(v35, a4, v60, a3, v54);
  v52(v31, 2, v49, v37);
  v41 = type metadata accessor for SIMD3(0, a4, (uint64_t)v59, v40);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v41 - 8) + 8))(v39, v41);
}

uint64_t SIMD3.debugDescription.getter(uint64_t a1)
{
  uint64_t v1;
  Class *v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  int64_t v47;
  int64_t v48;
  char v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  Swift::String::Index v58;
  Swift::String::Index v59;
  Swift::String::Index v60;
  Swift::String::Index v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  char *v73;
  size_t v74;
  uint8x16_t *TypeName;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  size_t v79;
  uint64_t *v80;
  uint8x16_t *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t countAndFlagsBits;
  unint64_t object;
  char v86;
  uint64_t v87;
  unsigned __int8 *v88;
  uint8x16_t *i;
  unsigned int v90;
  unsigned int v91;
  unsigned __int8 *v92;
  unsigned int v93;
  unsigned __int8 *v94;
  unsigned int v95;
  _QWORD *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  size_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  int64x2_t v127;
  int8x16_t v128;
  int8x16_t v129;
  int64x2_t v130;
  int64x2_t v131;
  int64x2_t v132;
  int64x2_t v133;
  uint8x8_t *v134;
  int8x16_t v135;
  unint64_t v136;
  int64x2_t v137;
  int8x16_t v138;
  int8x16_t v139;
  uint8x8_t v140;
  uint16x8_t v141;
  uint32x4_t v142;
  uint64x2_t v143;
  uint64x2_t v144;
  uint64x2_t v145;
  uint32x4_t v146;
  uint64x2_t v147;
  int8x16_t v148;
  uint16x8_t v149;
  int8x16_t v150;
  uint16x8_t v151;
  int8x16_t v152;
  int8x16_t v153;
  int8x8_t v154;
  int8x16_t v155;
  int8x8_t v156;
  uint64x2_t v157;
  int8x16_t v158;
  int8x16_t v159;
  int8x16_t v160;
  int8x16_t v161;
  unsigned __int8 *v162;
  unint64_t v163;
  unsigned int v164;
  unint64_t v165;
  int8x8_t v166;
  unint64_t v167;
  unint64_t v168;
  int64x2_t v169;
  int8x16_t v170;
  int8x16_t v171;
  int64x2_t v172;
  int64x2_t v173;
  int64x2_t v174;
  int64x2_t v175;
  uint8x8_t *v176;
  int8x16_t v177;
  unint64_t v178;
  int64x2_t v179;
  int8x16_t v180;
  int8x16_t v181;
  uint8x8_t v182;
  uint16x8_t v183;
  uint32x4_t v184;
  uint64x2_t v185;
  uint64x2_t v186;
  uint64x2_t v187;
  uint32x4_t v188;
  uint64x2_t v189;
  int8x16_t v190;
  uint8x16_t *v191;
  int64x2_t v192;
  int64x2_t v193;
  int64x2_t v194;
  int64x2_t v195;
  int64x2_t v196;
  int64x2_t v197;
  int8x16_t v198;
  int64x2_t v199;
  int64x2_t v200;
  int8x16_t v201;
  int8x16_t v202;
  int64x2_t v203;
  unint64_t v204;
  int8x16_t v205;
  int8x16_t v206;
  int8x16_t v207;
  int8x16_t v208;
  int8x16_t v209;
  int8x16_t v210;
  uint8x16_t v211;
  uint16x8_t v212;
  uint32x4_t v213;
  uint64x2_t v214;
  uint64x2_t v215;
  uint16x8_t v216;
  uint32x4_t v217;
  uint64x2_t v218;
  uint64x2_t v219;
  uint64x2_t v220;
  uint32x4_t v221;
  uint64x2_t v222;
  uint32x4_t v223;
  uint64x2_t v224;
  uint64x2_t v225;
  int8x16_t v226;
  uint64_t v227;
  unsigned __int8 *v228;
  unsigned int v229;
  unint64_t v230;
  uint64_t v231;
  unint64_t v232;
  uint64_t v233;
  unint64_t v234;
  unint64_t v235;
  unint64_t v236;
  uint64_t v237;
  uint64_t v238;
  char *v239;
  uint64_t v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  const char *v244;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v247)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v248;
  const void *v249;
  _QWORD *v250;
  uint64_t *v251;
  swift::SwiftError **v252;
  _QWORD *DynamicType;
  uint64_t *v254;
  Class *v255;
  uint64_t v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  uint64_t v260;
  unint64_t v261;
  uint64_t v262;
  uint64_t v263;
  char *v264;
  uint64_t *v265;
  void *v266;
  uint64_t v267;
  unint64_t v268;
  unint64_t v269;
  unint64_t v270;
  unint64_t v271;
  const void *v272;
  _QWORD *v273;
  uint64_t *v274;
  swift::SwiftError **v275;
  _QWORD *v276;
  uint64_t *v277;
  Class *v278;
  uint64_t v279;
  uint64_t v280;
  unint64_t v281;
  unint64_t v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t v285;
  uint64_t v286;
  char *v287;
  uint64_t *v288;
  void *v289;
  uint64_t v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t v293;
  unint64_t v294;
  _QWORD *v295;
  uint64_t *v296;
  swift::SwiftError **v297;
  _QWORD *v298;
  uint64_t *v299;
  Class *v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  unint64_t v304;
  uint64_t v305;
  unint64_t v306;
  uint64_t v307;
  uint64_t v308;
  char *v309;
  uint64_t *v310;
  void *v311;
  uint64_t v312;
  unint64_t v313;
  unint64_t v314;
  unint64_t v315;
  uint64_t *v317;
  Class *v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t *v321;
  Class *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t *v325;
  Class *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t *v329;
  Class *v330;
  uint64_t *v331;
  Class *v332;
  uint64_t *v333;
  Class *v334;
  uint64_t *v335;
  Class *v336;
  uint64_t *v337;
  Class *v338;
  uint64_t *v339;
  Class *v340;
  _QWORD *v341;
  void *v342;
  uint64_t v343;
  _QWORD *v344;
  void *v345;
  uint64_t v346;
  _QWORD *v347;
  void *v348;
  uint64_t v349;
  Swift::Int v350;
  unint64_t v351;
  uint64_t v352;
  char *v353;
  size_t v354;
  Class *v355;
  uint64_t *v356;
  uint64_t *v357;
  uint64_t *v358;
  uint64_t *v359;
  uint64_t *v360;
  uint64_t *v361;
  uint64_t *v362;
  uint64_t *v363;
  uint64_t *v364;
  uint64_t *v365;
  uint64_t *v366;
  uint64_t *v367;
  uint64_t v368;
  uint64_t v369;
  char *v370;
  char *v371;
  uint64_t *v372;
  Swift::String v373;
  uint64_t *v374;
  uint64_t v375;
  __int128 v376;
  __int128 v377;
  uint64_t v378;
  unint64_t v379;
  unint64_t v380;
  size_t v381;

  v369 = a1;
  v2 = *(Class **)(a1 + 16);
  v3 = *((_QWORD *)*(v2 - 1) + 8);
  v4 = MEMORY[0x1E0C80A78](a1);
  v5 = MEMORY[0x1E0C80A78](v4);
  v361 = (uint64_t *)((char *)&v352 - v6);
  v7 = MEMORY[0x1E0C80A78](v5);
  v364 = (uint64_t *)((char *)&v352 - v8);
  v9 = MEMORY[0x1E0C80A78](v7);
  v367 = (uint64_t *)((char *)&v352 - v10);
  v11 = MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v352 - v12;
  v14 = MEMORY[0x1E0C80A78](v11);
  v357 = (uint64_t *)((char *)&v352 - v15);
  v16 = MEMORY[0x1E0C80A78](v14);
  v360 = (uint64_t *)((char *)&v352 - v17);
  v18 = MEMORY[0x1E0C80A78](v16);
  v363 = (uint64_t *)((char *)&v352 - v19);
  v20 = MEMORY[0x1E0C80A78](v18);
  v366 = (uint64_t *)((char *)&v352 - v21);
  v22 = MEMORY[0x1E0C80A78](v20);
  v371 = (char *)&v352 - v23;
  v24 = MEMORY[0x1E0C80A78](v22);
  v356 = (uint64_t *)((char *)&v352 - v25);
  v26 = MEMORY[0x1E0C80A78](v24);
  v359 = (uint64_t *)((char *)&v352 - v27);
  v28 = MEMORY[0x1E0C80A78](v26);
  v362 = (uint64_t *)((char *)&v352 - v29);
  v30 = MEMORY[0x1E0C80A78](v28);
  v365 = (uint64_t *)((char *)&v352 - v31);
  v32 = MEMORY[0x1E0C80A78](v30);
  v372 = (uint64_t *)((char *)&v352 - v33);
  MEMORY[0x1E0C80A78](v32);
  v370 = (char *)&v352 - v34;
  v35 = specialized static String._createEmpty(withInitialCapacity:)(21);
  v39 = v35;
  v40 = v36;
  v379 = v35;
  v380 = v36;
  if ((v36 & 0x2000000000000000) != 0)
    v41 = HIBYTE(v36) & 0xF;
  else
    v41 = v35 & 0xFFFFFFFFFFFFLL;
  v358 = (uint64_t *)((char *)&v352 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  v368 = v1;
  if (!v41 && (v35 & ~v36 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v36);
    v379 = 0x3C33444D4953;
    v380 = 0xE600000000000000;
    goto LABEL_25;
  }
  if ((v36 & 0x2000000000000000) != 0)
  {
    v42 = specialized _SmallString.init(_:appending:)(v35, v36, 0x3C33444D4953uLL, 0xE600000000000000);
    if ((v37 & 1) == 0)
    {
      v44 = v42;
      v45 = v43;
      swift_bridgeObjectRelease(v40);
      swift_bridgeObjectRelease(0xE600000000000000);
      v379 = v44;
      v380 = v45;
      goto LABEL_25;
    }
  }
  swift_bridgeObjectRetain_n(0xE600000000000000, 6, v37, v38);
  if ((v40 & 0x1000000000000000) == 0)
  {
    v46 = __OFADD__(v41, 6);
    v47 = v41 + 6;
    if (!v46)
      goto LABEL_11;
LABEL_250:
    __break(1u);
    goto LABEL_251;
  }
  v350 = String.UTF8View._foreignCount()();
  v47 = v350 + 6;
  if (__OFADD__(v350, 6))
    goto LABEL_250;
LABEL_11:
  if ((v39 & ~v40 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v40 & 0xFFFFFFFFFFFFFFFLL))
  {
    v48 = _StringGuts.nativeUnusedCapacity.getter(v39, v40);
    if ((v49 & 1) != 0)
    {
      v351 = 258;
      goto LABEL_255;
    }
    v50 = (v40 >> 61) & 1;
    if (v48 < 6)
      LODWORD(v50) = 1;
    if (v47 <= 15 && (_DWORD)v50)
    {
LABEL_18:
      v51 = v13;
      swift_bridgeObjectRelease_n(0xE600000000000000, 5);
      swift_bridgeObjectRetain(v40, v52, v53, v54);
      v55 = _StringGuts._convertedToSmall()(v39, v40);
      v57 = v56;
      swift_bridgeObjectRelease(v40);
      v58._rawBits = 1;
      v59._rawBits = 393217;
      v60._rawBits = _StringGuts.validateScalarRange(_:)(v58, v59, 0x3C33444D4953uLL, 0xE600000000000000);
      if (v60._rawBits < 0x10000)
        v60._rawBits |= 3;
      v62 = specialized String.init(_:)(v60, v61, 0x3C33444D4953uLL, 0xE600000000000000);
      v64 = v63;
      swift_bridgeObjectRelease(0xE600000000000000);
      v65 = _StringGuts._convertedToSmall()(v62, v64);
      v67 = v66;
      swift_bridgeObjectRelease(v64);
      v68 = specialized _SmallString.init(_:appending:)(v55, v57, v65, v67);
      if ((v70 & 1) == 0)
      {
        v71 = v68;
        v72 = v69;
        swift_bridgeObjectRelease(v40);
        swift_bridgeObjectRelease(0xE600000000000000);
        v379 = v71;
        v380 = v72;
        v13 = v51;
        goto LABEL_25;
      }
      v351 = 266;
LABEL_255:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v351, 0);
    }
  }
  else if (v47 <= 15)
  {
    goto LABEL_18;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v47, 6);
  swift_bridgeObjectRelease_n(0xE600000000000000, 6);
  v373 = (Swift::String)xmmword_1816ABF60;
  v73 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 6, (uint64_t)&v373, 6);
  _StringGuts.appendInPlace(_:isASCII:)(v73, v74, 1);
  swift_bridgeObjectRelease(0xE600000000000000);
LABEL_25:
  TypeName = (uint8x16_t *)swift_getTypeName(v2, 0);
  if (v76 < 0)
    goto LABEL_247;
  v79 = v76;
  if (!v76)
  {
    countAndFlagsBits = 0;
    object = 0xE000000000000000;
    goto LABEL_143;
  }
  v80 = (uint64_t *)TypeName;
  v81 = TypeName;
  if ((v76 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0)
      goto LABEL_47;
    v81 = TypeName + 1;
    while (v81 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFF0])
    {
      v82 = v81->i64[0];
      v83 = v81->i64[1];
      ++v81;
      if (((v83 | v82) & 0x8080808080808080) != 0)
        goto LABEL_47;
    }
  }
  if (v81 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v81->i64[0] & 0x8080808080808080) != 0)
      goto LABEL_47;
    v81 = (uint8x16_t *)((char *)v81 + 8);
  }
  if (v81 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v81->i32[0] & 0x80808080) != 0)
      goto LABEL_47;
    v81 = (uint8x16_t *)((char *)v81 + 4);
  }
  if (v81 >= (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_43:
    if (v81 >= (uint8x16_t *)&TypeName->i8[v76] || (v81->i8[0] & 0x80000000) == 0)
    {
      if (v76 > 15)
      {
        v86 = 1;
LABEL_106:
        object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v76, v76, v86 & 1);
        countAndFlagsBits = *(_QWORD *)(object + 24);
        goto LABEL_143;
      }
LABEL_107:
      v122 = v76 - 8;
      v123 = 8;
      if (v76 < 8)
        v123 = v76;
      if ((v123 & 0x8000000000000000) == 0)
      {
        if (v123 >= 8)
        {
          if (v123 >= 0x10)
          {
            v124 = v123 & 0xFFFFFFFFFFFFFFF0;
            v149 = vmovl_high_u8(*TypeName);
            v150 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v149.i8);
            v151 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            v152 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v151.i8);
            v153 = (int8x16_t)vmovl_high_u16(v149);
            v154 = (int8x8_t)vextq_s8(v153, v153, 8uLL).u64[0];
            v155 = (int8x16_t)vmovl_high_u16(v151);
            v156 = (int8x8_t)vextq_s8(v155, v155, 8uLL).u64[0];
            *(int8x8_t *)v155.i8 = vorr_s8(*(int8x8_t *)v155.i8, *(int8x8_t *)v153.i8);
            v157.i64[0] = v155.u32[0];
            v157.i64[1] = v155.u32[1];
            v158 = (int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1816ABC20);
            *(int8x8_t *)v153.i8 = vorr_s8(*(int8x8_t *)v152.i8, *(int8x8_t *)v150.i8);
            v157.i64[0] = v153.u32[0];
            v157.i64[1] = v153.u32[1];
            v159 = vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1816ABC10), v158);
            *(int8x8_t *)v153.i8 = vorr_s8(v156, v154);
            v157.i64[0] = v153.u32[0];
            v157.i64[1] = v153.u32[1];
            v160 = (int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1816ABC00);
            *(int8x8_t *)v150.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v152, v152, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v150, v150, 8uLL));
            v157.i64[0] = v150.u32[0];
            v157.i64[1] = v150.u32[1];
            v161 = vorrq_s8(v159, vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_1816ABBF0), v160));
            countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v161.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v161, v161, 8uLL));
            if (v123 == (v123 & 0xFFFFFFFFFFFFFFF0))
              goto LABEL_124;
            v125 = 8 * v124;
            if ((v123 & 8) == 0)
              goto LABEL_122;
          }
          else
          {
            countAndFlagsBits = 0;
            v125 = 0;
            v124 = 0;
          }
          v126 = v124;
          v127 = vdupq_n_s64(v125);
          v124 = v123 & 0xFFFFFFFFFFFFFFF8;
          v125 = 8 * (v123 & 0xFFFFFFFFFFFFFFF8);
          v128 = 0uLL;
          v129 = (int8x16_t)(unint64_t)countAndFlagsBits;
          v130 = vaddq_s64(v127, (int64x2_t)xmmword_1816ABC00);
          v131 = vaddq_s64(v127, (int64x2_t)xmmword_1816ABC20);
          v132 = vaddq_s64(v127, (int64x2_t)xmmword_1816ABBF0);
          v133 = vaddq_s64(v127, (int64x2_t)xmmword_1816ABC10);
          v134 = (uint8x8_t *)&TypeName->i8[v126];
          v135 = (int8x16_t)vdupq_n_s64(0x38uLL);
          v136 = v126 - (v123 & 0xFFFFFFFFFFFFFFF8);
          v137 = vdupq_n_s64(0x40uLL);
          v138 = 0uLL;
          v139 = 0uLL;
          do
          {
            v140 = *v134++;
            v141 = vmovl_u8(v140);
            v142 = vmovl_high_u16(v141);
            v143.i64[0] = v142.u32[2];
            v143.i64[1] = v142.u32[3];
            v144 = v143;
            v143.i64[0] = v142.u32[0];
            v143.i64[1] = v142.u32[1];
            v145 = v143;
            v146 = vmovl_u16(*(uint16x4_t *)v141.i8);
            v143.i64[0] = v146.u32[2];
            v143.i64[1] = v146.u32[3];
            v147 = v143;
            v143.i64[0] = v146.u32[0];
            v143.i64[1] = v146.u32[1];
            v139 = vorrq_s8((int8x16_t)vshlq_u64(v144, (uint64x2_t)vandq_s8((int8x16_t)v130, v135)), v139);
            v138 = vorrq_s8((int8x16_t)vshlq_u64(v145, (uint64x2_t)vandq_s8((int8x16_t)v131, v135)), v138);
            v128 = vorrq_s8((int8x16_t)vshlq_u64(v147, (uint64x2_t)vandq_s8((int8x16_t)v132, v135)), v128);
            v129 = vorrq_s8((int8x16_t)vshlq_u64(v143, (uint64x2_t)vandq_s8((int8x16_t)v133, v135)), v129);
            v131 = vaddq_s64(v131, v137);
            v132 = vaddq_s64(v132, v137);
            v133 = vaddq_s64(v133, v137);
            v130 = vaddq_s64(v130, v137);
            v136 += 8;
          }
          while (v136);
          v148 = vorrq_s8(vorrq_s8(v129, v138), vorrq_s8(v128, v139));
          countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v148.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v148, v148, 8uLL));
          if (v123 == v124)
          {
LABEL_124:
            if (v76 < 9)
            {
              v166 = 0;
LABEL_140:
              v230 = 0xA000000000000000;
              if (((*(_QWORD *)&v166 | countAndFlagsBits) & 0x8080808080808080) == 0)
                v230 = 0xE000000000000000;
              object = v230 | (v76 << 56) | *(_QWORD *)&v166;
              goto LABEL_143;
            }
            if (v122 < 8)
            {
              v165 = 0;
              v166 = 0;
              v167 = 0;
LABEL_138:
              v227 = v76 - v165 - 8;
              v228 = &TypeName->u8[v165 + 8];
              do
              {
                v229 = *v228++;
                *(_QWORD *)&v166 |= (unint64_t)v229 << (v167 & 0x38);
                v167 += 8;
                --v227;
              }
              while (v227);
              goto LABEL_140;
            }
            if (v122 >= 0x10)
            {
              v191 = (uint8x16_t *)&TypeName->u64[1];
              v165 = v122 & 0xFFFFFFFFFFFFFFF0;
              v192 = (int64x2_t)xmmword_1816ABCA0;
              v193 = (int64x2_t)xmmword_1816ABCB0;
              v194 = (int64x2_t)xmmword_1816ABCC0;
              v195 = (int64x2_t)xmmword_1816ABCD0;
              v196 = (int64x2_t)xmmword_1816ABC00;
              v197 = (int64x2_t)xmmword_1816ABC20;
              v198 = (int8x16_t)vdupq_n_s64(0x38uLL);
              v199 = vdupq_n_s64(0x80uLL);
              v200 = (int64x2_t)xmmword_1816ABBF0;
              v167 = 8 * (v122 & 0xFFFFFFFFFFFFFFF0);
              v201 = 0uLL;
              v202 = 0uLL;
              v203 = (int64x2_t)xmmword_1816ABC10;
              v204 = v122 & 0xFFFFFFFFFFFFFFF0;
              v205 = 0uLL;
              v206 = 0uLL;
              v207 = 0uLL;
              v208 = 0uLL;
              v209 = 0uLL;
              v210 = 0uLL;
              do
              {
                v211 = *v191++;
                v212 = vmovl_u8(*(uint8x8_t *)v211.i8);
                v213 = vmovl_high_u16(v212);
                v214.i64[0] = v213.u32[2];
                v214.i64[1] = v213.u32[3];
                v215 = v214;
                v216 = vmovl_high_u8(v211);
                v217 = vmovl_u16(*(uint16x4_t *)v216.i8);
                v214.i64[0] = v217.u32[2];
                v214.i64[1] = v217.u32[3];
                v218 = v214;
                v214.i64[0] = v217.u32[0];
                v214.i64[1] = v217.u32[1];
                v219 = v214;
                v214.i64[0] = v213.u32[0];
                v214.i64[1] = v213.u32[1];
                v220 = v214;
                v221 = vmovl_u16(*(uint16x4_t *)v212.i8);
                v214.i64[0] = v221.u32[2];
                v214.i64[1] = v221.u32[3];
                v222 = v214;
                v223 = vmovl_high_u16(v216);
                v214.i64[0] = v223.u32[0];
                v214.i64[1] = v223.u32[1];
                v224 = v214;
                v214.i64[0] = v221.u32[0];
                v214.i64[1] = v221.u32[1];
                v225 = v214;
                v214.i64[0] = v223.u32[2];
                v214.i64[1] = v223.u32[3];
                v206 = vorrq_s8((int8x16_t)vshlq_u64(v215, (uint64x2_t)vandq_s8((int8x16_t)v196, v198)), v206);
                v208 = vorrq_s8((int8x16_t)vshlq_u64(v218, (uint64x2_t)vandq_s8((int8x16_t)v194, v198)), v208);
                v207 = vorrq_s8((int8x16_t)vshlq_u64(v219, (uint64x2_t)vandq_s8((int8x16_t)v195, v198)), v207);
                v205 = vorrq_s8((int8x16_t)vshlq_u64(v220, (uint64x2_t)vandq_s8((int8x16_t)v197, v198)), v205);
                v202 = vorrq_s8((int8x16_t)vshlq_u64(v222, (uint64x2_t)vandq_s8((int8x16_t)v200, v198)), v202);
                v209 = vorrq_s8((int8x16_t)vshlq_u64(v224, (uint64x2_t)vandq_s8((int8x16_t)v193, v198)), v209);
                v201 = vorrq_s8((int8x16_t)vshlq_u64(v225, (uint64x2_t)vandq_s8((int8x16_t)v203, v198)), v201);
                v210 = vorrq_s8((int8x16_t)vshlq_u64(v214, (uint64x2_t)vandq_s8((int8x16_t)v192, v198)), v210);
                v197 = vaddq_s64(v197, v199);
                v200 = vaddq_s64(v200, v199);
                v203 = vaddq_s64(v203, v199);
                v196 = vaddq_s64(v196, v199);
                v195 = vaddq_s64(v195, v199);
                v194 = vaddq_s64(v194, v199);
                v193 = vaddq_s64(v193, v199);
                v192 = vaddq_s64(v192, v199);
                v204 -= 16;
              }
              while (v204);
              v226 = vorrq_s8(vorrq_s8(vorrq_s8(v201, v207), vorrq_s8(v205, v209)), vorrq_s8(vorrq_s8(v202, v208), vorrq_s8(v206, v210)));
              v166 = vorr_s8(*(int8x8_t *)v226.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v226, v226, 8uLL));
              if (v122 == v165)
                goto LABEL_140;
              if ((v122 & 8) == 0)
                goto LABEL_138;
            }
            else
            {
              v166 = 0;
              v167 = 0;
              v165 = 0;
            }
            v168 = v165;
            v165 = v122 & 0xFFFFFFFFFFFFFFF8;
            v169 = vdupq_n_s64(v167);
            v167 = 8 * (v122 & 0xFFFFFFFFFFFFFFF8);
            v170 = (int8x16_t)(unint64_t)v166;
            v171 = 0uLL;
            v172 = vaddq_s64(v169, (int64x2_t)xmmword_1816ABC00);
            v173 = vaddq_s64(v169, (int64x2_t)xmmword_1816ABC20);
            v174 = vaddq_s64(v169, (int64x2_t)xmmword_1816ABBF0);
            v175 = vaddq_s64(v169, (int64x2_t)xmmword_1816ABC10);
            v176 = (uint8x8_t *)((char *)&TypeName->u64[1] + v168);
            v177 = (int8x16_t)vdupq_n_s64(0x38uLL);
            v178 = v168 - (v122 & 0xFFFFFFFFFFFFFFF8);
            v179 = vdupq_n_s64(0x40uLL);
            v180 = 0uLL;
            v181 = 0uLL;
            do
            {
              v182 = *v176++;
              v183 = vmovl_u8(v182);
              v184 = vmovl_high_u16(v183);
              v185.i64[0] = v184.u32[2];
              v185.i64[1] = v184.u32[3];
              v186 = v185;
              v185.i64[0] = v184.u32[0];
              v185.i64[1] = v184.u32[1];
              v187 = v185;
              v188 = vmovl_u16(*(uint16x4_t *)v183.i8);
              v185.i64[0] = v188.u32[2];
              v185.i64[1] = v188.u32[3];
              v189 = v185;
              v185.i64[0] = v188.u32[0];
              v185.i64[1] = v188.u32[1];
              v181 = vorrq_s8((int8x16_t)vshlq_u64(v186, (uint64x2_t)vandq_s8((int8x16_t)v172, v177)), v181);
              v180 = vorrq_s8((int8x16_t)vshlq_u64(v187, (uint64x2_t)vandq_s8((int8x16_t)v173, v177)), v180);
              v171 = vorrq_s8((int8x16_t)vshlq_u64(v189, (uint64x2_t)vandq_s8((int8x16_t)v174, v177)), v171);
              v170 = vorrq_s8((int8x16_t)vshlq_u64(v185, (uint64x2_t)vandq_s8((int8x16_t)v175, v177)), v170);
              v173 = vaddq_s64(v173, v179);
              v174 = vaddq_s64(v174, v179);
              v175 = vaddq_s64(v175, v179);
              v172 = vaddq_s64(v172, v179);
              v178 += 8;
            }
            while (v178);
            v190 = vorrq_s8(vorrq_s8(v170, v180), vorrq_s8(v171, v181));
            v166 = vorr_s8(*(int8x8_t *)v190.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v190, v190, 8uLL));
            if (v122 == v165)
              goto LABEL_140;
            goto LABEL_138;
          }
        }
        else
        {
          v124 = 0;
          countAndFlagsBits = 0;
          v125 = 0;
        }
LABEL_122:
        v162 = &TypeName->u8[v124];
        v163 = v123 - v124;
        do
        {
          v164 = *v162++;
          countAndFlagsBits |= (unint64_t)v164 << (v125 & 0x38);
          v125 += 8;
          --v163;
        }
        while (v163);
        goto LABEL_124;
      }
LABEL_252:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    goto LABEL_47;
  }
  if ((v81->i16[0] & 0x8080) == 0)
  {
    v81 = (uint8x16_t *)((char *)v81 + 2);
    goto LABEL_43;
  }
LABEL_47:
  v87 = 0;
  v88 = &TypeName->u8[v76];
  v86 = 1;
  for (i = TypeName; ; i = (uint8x16_t *)((char *)i + 3))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (!i || v88 == (unsigned __int8 *)i)
          {
            if (v76 > 15)
              goto LABEL_106;
            goto LABEL_107;
          }
          v91 = i->u8[0];
          i = (uint8x16_t *)((char *)i + 1);
          v90 = v91;
          if ((v90 & 0x80) != 0)
            break;
          ++v87;
        }
        if ((v90 + 62) > 0x32u)
          goto LABEL_96;
        if (v90 > 0xDF)
          break;
        if (!i || v88 == (unsigned __int8 *)i || (i->i8[0] & 0xC0) != 0x80)
          goto LABEL_96;
        v86 = 0;
        i = (uint8x16_t *)((char *)i + 1);
        v87 += 2;
      }
      if (v90 != 224)
        break;
      if (!i)
        goto LABEL_96;
      if (v88 == (unsigned __int8 *)i)
        goto LABEL_96;
      v92 = &i->u8[1];
      if ((i->i8[0] & 0xE0) != 0xA0)
        goto LABEL_96;
LABEL_74:
      if (v92 == v88 || (*v92 & 0xC0) != 0x80)
        goto LABEL_96;
      v86 = 0;
      i = (uint8x16_t *)((char *)i + 2);
      v87 += 3;
    }
    if (v90 <= 0xEC)
    {
LABEL_66:
      if (!i || v88 == (unsigned __int8 *)i)
        goto LABEL_96;
      v92 = &i->u8[1];
      LOBYTE(v93) = i->i8[0];
LABEL_73:
      if ((v93 & 0xC0) != 0x80)
        goto LABEL_96;
      goto LABEL_74;
    }
    if (v90 == 237)
    {
      if (!i)
        goto LABEL_96;
      if (v88 == (unsigned __int8 *)i)
        goto LABEL_96;
      v92 = &i->u8[1];
      v93 = i->u8[0];
      if (v93 > 0x9F)
        goto LABEL_96;
      goto LABEL_73;
    }
    if (v90 <= 0xEF)
      goto LABEL_66;
    if (v90 != 240)
      break;
    if (!i)
      goto LABEL_96;
    if (v88 == (unsigned __int8 *)i)
      goto LABEL_96;
    v94 = &i->u8[1];
    if ((i->i8[0] + 64) < 0xD0u)
      goto LABEL_96;
LABEL_91:
    if (v94 == v88 || (i->i8[1] & 0xC0) != 0x80 || &i->i16[1] == (__int16 *)v88 || (i->i8[2] & 0xC0) != 0x80)
      goto LABEL_96;
    v86 = 0;
    v87 += 4;
  }
  if ((v90 + 15) <= 2u)
  {
    if (!i || v88 == (unsigned __int8 *)i)
      goto LABEL_96;
    v94 = &i->u8[1];
    LOBYTE(v95) = i->i8[0];
    goto LABEL_90;
  }
  if (i)
  {
    if (v88 != (unsigned __int8 *)i)
    {
      v94 = &i->u8[1];
      v95 = i->u8[0];
      if (v95 <= 0x8F)
      {
LABEL_90:
        if ((v95 & 0xC0) != 0x80)
          goto LABEL_96;
        goto LABEL_91;
      }
    }
  }
LABEL_96:
  v96 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v96);
  v97 = specialized Collection.subscript.getter(v87, (uint64_t)v80, v79);
  v102 = findInvalidRange #1 (_:) in validateUTF8(_:)(v97, v98, v99, v100);
  v373._countAndFlagsBits = 0;
  v373._object = (void *)0xE000000000000000;
  if (__OFADD__(v79, 15))
  {
LABEL_251:
    __break(1u);
    goto LABEL_252;
  }
  v103 = v101;
  v353 = v13;
  v354 = v3;
  v355 = v2;
  _StringGuts.reserveCapacity(_:)(v79 + 15);
  while (1)
  {
    v104 = specialized Collection.subscript.getter(v102, (uint64_t)v80, v79);
    v108 = v373._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v373._object & 0x2000000000000000) != 0)
      v108 = ((unint64_t)v373._object >> 56) & 0xF;
    v46 = __OFADD__(v108, v79);
    v109 = v108 + v79;
    if (v46)
    {
      __break(1u);
LABEL_246:
      __break(1u);
LABEL_247:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    v110 = v104;
    if (__OFADD__(v109, 3))
      goto LABEL_246;
    v111 = v105;
    v112 = v106;
    v113 = v107;
    _StringGuts.reserveCapacity(_:)(v109 + 3);
    v114 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v110, v111, v112, v113);
    _StringGuts.appendInPlace(_:isASCII:)(v114, v115, 0);
    v381 = 3;
    *(_QWORD *)&v376 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v376, &v381, &v373);
    v116 = specialized Collection.subscript.getter(v103, (uint64_t)v80, v79);
    v80 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v116, v117, v118, v119);
    v79 = v120;
    v121 = validateUTF8(_:)(v80, v120);
    if ((v77 & 1) == 0)
      break;
    v102 = v121;
    v103 = v76;
    if (!v79)
      goto LABEL_113;
  }
  _StringGuts.appendInPlace(_:isASCII:)((char *)v80, v79, 0);
LABEL_113:
  object = (unint64_t)v373._object;
  countAndFlagsBits = v373._countAndFlagsBits;
  v2 = v355;
  v3 = v354;
  v13 = v353;
LABEL_143:
  v231 = v380;
  v232 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000) == 0)
    v232 = v379 & 0xFFFFFFFFFFFFLL;
  if (!v232 && (v379 & ~v380 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v380);
    v379 = countAndFlagsBits;
    v380 = object;
    goto LABEL_156;
  }
  if ((v380 & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) != 0)
    {
      v234 = specialized _SmallString.init(_:appending:)(v379, v380, countAndFlagsBits, object);
      if ((v77 & 1) != 0)
        goto LABEL_154;
      v235 = v234;
      v236 = v76;
      swift_bridgeObjectRelease(v231);
      swift_bridgeObjectRelease(object);
      v379 = v235;
      v380 = v236;
      object = v236;
      countAndFlagsBits = v235;
      goto LABEL_156;
    }
LABEL_151:
    v233 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_155;
  }
  if ((object & 0x2000000000000000) == 0)
    goto LABEL_151;
LABEL_154:
  v233 = HIBYTE(object) & 0xF;
LABEL_155:
  swift_bridgeObjectRetain(object, v76, v77, v78);
  _StringGuts.append(_:)(countAndFlagsBits, object, 0, v233);
  swift_bridgeObjectRelease_n(object, 2);
  countAndFlagsBits = v379;
  object = v380;
LABEL_156:
  v240 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0)
    v240 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (v240 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (v241 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x283EuLL, 0xE200000000000000),
          (v238 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v237, v238, v239);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v242 = v241;
      v243 = v237;
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE200000000000000);
      v379 = v242;
      v380 = v243;
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    v379 = 10302;
    v380 = 0xE200000000000000;
  }
  v244 = *(const char **)(v369 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v244, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v244, (uint64_t)v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v247 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v248 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v249 = v370;
  v247(0, v248, AssociatedConformanceWitness);
  v374 = (uint64_t *)v2;
  v250 = __swift_allocate_boxed_opaque_existential_0Tm(&v373);
  memcpy(v250, v249, v3);
  v251 = v374;
  v252 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
  DynamicType = (_QWORD *)swift_getDynamicType(v252, v251, 1);
  LODWORD(v251) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
  if ((_DWORD)v251)
  {
    v254 = v372;
    memcpy(v372, v249, v3);
    v255 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v373, v254, v2, v255, 7uLL);
    goto LABEL_166;
  }
  v265 = v365;
  memcpy(v365, v249, v3);
  if ((swift_dynamicCast((char *)&v373, v265, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v266 = v373._object;
    String.append(_:)(v373);
    swift_bridgeObjectRelease((uint64_t)v266);
    goto LABEL_174;
  }
  v317 = v362;
  memcpy(v362, v249, v3);
  v318 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v376, v317, v2, v318, 6uLL))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
    v319 = (uint64_t)v374;
    v320 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v320 + 8))(&v379, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v319, v320);
LABEL_171:
    __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
    goto LABEL_174;
  }
  v378 = 0;
  v376 = 0u;
  v377 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for TextOutputStreamable?);
  v329 = v359;
  memcpy(v359, v249, v3);
  v330 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v376, v329, v2, v330, 6uLL)
    || (v378 = 0,
        v376 = 0u,
        v377 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for CustomStringConvertible?), v331 = v356, memcpy(v356, v249, v3), v332 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v376, v331, v2, v332, 6uLL)))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
LABEL_166:
    v256 = (uint64_t)v374;
    v257 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    v259 = (*(uint64_t (**)(uint64_t, uint64_t))(v257 + 8))(v256, v257);
    v260 = v258;
    v261 = HIBYTE(v380) & 0xF;
    if ((v380 & 0x2000000000000000) == 0)
      v261 = v379 & 0xFFFFFFFFFFFFLL;
    if (v261 || (v379 & ~v380 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v259, v258);
      swift_bridgeObjectRelease(v260);
    }
    else
    {
      swift_bridgeObjectRelease(v380);
      v379 = v259;
      v380 = v260;
    }
    goto LABEL_171;
  }
  v378 = 0;
  v376 = 0u;
  v377 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((_QWORD *)&v377 + 1) = v2;
  v341 = __swift_allocate_boxed_opaque_existential_0Tm(&v376);
  memcpy(v341, v249, v3);
  Mirror.init(reflecting:)((uint64_t *)&v376, (uint64_t)&v373);
  v342 = v373._object;
  v343 = v375;
  ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v249, &v373, &v379, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v343);
  swift_release((uint64_t)v342);
LABEL_174:
  v267 = v380;
  v268 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000) == 0)
    v268 = v379 & 0xFFFFFFFFFFFFLL;
  if (v268 || (v379 & ~v380 & 0x2000000000000000) != 0)
  {
    if ((v380 & 0x2000000000000000) == 0
      || (v269 = specialized _SmallString.init(_:appending:)(v379, v380, 0x202CuLL, 0xE200000000000000),
          (v263 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v262, v263, v264);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v270 = v269;
      v271 = v262;
      swift_bridgeObjectRelease(v267);
      swift_bridgeObjectRelease(0xE200000000000000);
      v379 = v270;
      v380 = v271;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v380);
    v379 = 8236;
    v380 = 0xE200000000000000;
  }
  v272 = v371;
  v247(1, v248, AssociatedConformanceWitness);
  v374 = (uint64_t *)v2;
  v273 = __swift_allocate_boxed_opaque_existential_0Tm(&v373);
  memcpy(v273, v272, v3);
  v274 = v374;
  v275 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
  v276 = (_QWORD *)swift_getDynamicType(v275, v274, 1);
  LODWORD(v274) = swift_isOptionalType(v276);
  __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
  if ((_DWORD)v274)
  {
    v277 = v372;
    memcpy(v372, v272, v3);
    v278 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v373, v277, v2, v278, 7uLL);
    goto LABEL_184;
  }
  v288 = v366;
  memcpy(v366, v272, v3);
  if ((swift_dynamicCast((char *)&v373, v288, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v289 = v373._object;
    String.append(_:)(v373);
    swift_bridgeObjectRelease((uint64_t)v289);
    goto LABEL_192;
  }
  v321 = v363;
  memcpy(v363, v272, v3);
  v322 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v376, v321, v2, v322, 6uLL))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
    v323 = (uint64_t)v374;
    v324 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v324 + 8))(&v379, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v323, v324);
LABEL_189:
    __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
    goto LABEL_192;
  }
  v378 = 0;
  v376 = 0u;
  v377 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for TextOutputStreamable?);
  v333 = v360;
  memcpy(v360, v272, v3);
  v334 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v376, v333, v2, v334, 6uLL)
    || (v378 = 0,
        v376 = 0u,
        v377 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for CustomStringConvertible?), v335 = v357, memcpy(v357, v272, v3), v336 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v376, v335, v2, v336, 6uLL)))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
LABEL_184:
    v279 = (uint64_t)v374;
    v280 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    v282 = (*(uint64_t (**)(uint64_t, uint64_t))(v280 + 8))(v279, v280);
    v283 = v281;
    v284 = HIBYTE(v380) & 0xF;
    if ((v380 & 0x2000000000000000) == 0)
      v284 = v379 & 0xFFFFFFFFFFFFLL;
    if (v284 || (v379 & ~v380 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v282, v281);
      swift_bridgeObjectRelease(v283);
    }
    else
    {
      swift_bridgeObjectRelease(v380);
      v379 = v282;
      v380 = v283;
    }
    goto LABEL_189;
  }
  v378 = 0;
  v376 = 0u;
  v377 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((_QWORD *)&v377 + 1) = v2;
  v344 = __swift_allocate_boxed_opaque_existential_0Tm(&v376);
  memcpy(v344, v272, v3);
  Mirror.init(reflecting:)((uint64_t *)&v376, (uint64_t)&v373);
  v345 = v373._object;
  v346 = v375;
  ((void (*)(const void *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v272, &v373, &v379, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v346);
  swift_release((uint64_t)v345);
LABEL_192:
  v290 = v380;
  v291 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000) == 0)
    v291 = v379 & 0xFFFFFFFFFFFFLL;
  if (v291 || (v379 & ~v380 & 0x2000000000000000) != 0)
  {
    if ((v380 & 0x2000000000000000) == 0
      || (v292 = specialized _SmallString.init(_:appending:)(v379, v380, 0x202CuLL, 0xE200000000000000),
          (v286 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000, v285, v286, v287);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      v293 = v292;
      v294 = v285;
      swift_bridgeObjectRelease(v290);
      swift_bridgeObjectRelease(0xE200000000000000);
      v379 = v293;
      v380 = v294;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v380);
    v379 = 8236;
    v380 = 0xE200000000000000;
  }
  v247(2, v248, AssociatedConformanceWitness);
  v374 = (uint64_t *)v2;
  v295 = __swift_allocate_boxed_opaque_existential_0Tm(&v373);
  memcpy(v295, v13, v3);
  v296 = v374;
  v297 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
  v298 = (_QWORD *)swift_getDynamicType(v297, v296, 1);
  LODWORD(v296) = swift_isOptionalType(v298);
  __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
  if ((_DWORD)v296)
  {
    v299 = v372;
    memcpy(v372, v13, v3);
    v300 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v373, v299, v2, v300, 7uLL);
    goto LABEL_202;
  }
  v310 = v367;
  memcpy(v367, v13, v3);
  if ((swift_dynamicCast((char *)&v373, v310, v2, (Class *)&type metadata for String, 6uLL) & 1) != 0)
  {
    v311 = v373._object;
    String.append(_:)(v373);
    swift_bridgeObjectRelease((uint64_t)v311);
    goto LABEL_210;
  }
  v325 = v364;
  memcpy(v364, v13, v3);
  v326 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v376, v325, v2, v326, 6uLL))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
    v327 = (uint64_t)v374;
    v328 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v328 + 8))(&v379, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v327, v328);
LABEL_207:
    __swift_destroy_boxed_opaque_existential_1Tm(&v373._countAndFlagsBits);
    goto LABEL_210;
  }
  v378 = 0;
  v376 = 0u;
  v377 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for TextOutputStreamable?);
  v337 = v361;
  memcpy(v361, v13, v3);
  v338 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v376, v337, v2, v338, 6uLL)
    || (v378 = 0,
        v376 = 0u,
        v377 = 0u,
        outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for CustomStringConvertible?), v339 = v358, memcpy(v358, v13, v3), v340 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v376, v339, v2, v340, 6uLL)))
  {
    outlined init with take of MirrorPath(&v376, (uint64_t)&v373);
LABEL_202:
    v301 = (uint64_t)v374;
    v302 = v375;
    __swift_project_boxed_opaque_existential_0Tm(&v373, (uint64_t)v374);
    v304 = (*(uint64_t (**)(uint64_t, uint64_t))(v302 + 8))(v301, v302);
    v305 = v303;
    v306 = HIBYTE(v380) & 0xF;
    if ((v380 & 0x2000000000000000) == 0)
      v306 = v379 & 0xFFFFFFFFFFFFLL;
    if (v306 || (v379 & ~v380 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v304, v303);
      swift_bridgeObjectRelease(v305);
    }
    else
    {
      swift_bridgeObjectRelease(v380);
      v379 = v304;
      v380 = v305;
    }
    goto LABEL_207;
  }
  v378 = 0;
  v376 = 0u;
  v377 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v376, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((_QWORD *)&v377 + 1) = v2;
  v347 = __swift_allocate_boxed_opaque_existential_0Tm(&v376);
  memcpy(v347, v13, v3);
  Mirror.init(reflecting:)((uint64_t *)&v376, (uint64_t)&v373);
  v348 = v373._object;
  v349 = v375;
  ((void (*)(char *, Swift::String *, unint64_t *, _QWORD, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v13, &v373, &v379, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v349);
  swift_release((uint64_t)v348);
LABEL_210:
  v312 = v380;
  v313 = HIBYTE(v380) & 0xF;
  if ((v380 & 0x2000000000000000) == 0)
    v313 = v379 & 0xFFFFFFFFFFFFLL;
  if (v313 || (v379 & ~v380 & 0x2000000000000000) != 0)
  {
    if ((v380 & 0x2000000000000000) == 0
      || (v314 = specialized _SmallString.init(_:appending:)(v379, v380, 0x29uLL, 0xE100000000000000), (v308 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000, v307, v308, v309);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      return v379;
    }
    else
    {
      v315 = v314;
      swift_bridgeObjectRelease(v312);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v380);
    return 41;
  }
  return v315;
}

uint64_t SIMD3<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, const char *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  void (*v21)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v22;
  void (*v23)(char *, uint64_t, uint64_t, uint64_t);
  char *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  void (*v28)(uint64_t, unint64_t *, unint64_t);
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  void (*v32)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void (*v39)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t v40;
  void (*v41)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  unint64_t v42;
  void (*v43)(uint64_t, unint64_t *, unint64_t);
  char *v44;
  uint64_t v45;
  const char *v46;
  unint64_t AssociatedConformanceWitness;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v45 = a6;
  v51 = a4;
  v52 = a1;
  v49 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v44 = (char *)&v39 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v48 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v18 = (uint64_t)a7;
  v46 = a7;
  v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v50 = a3;
  v20 = swift_getAssociatedConformanceWitness(v18, a3, v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v21 = *(void (**)(uint64_t, unint64_t *, unint64_t))(v20 + 56);
  v42 = v20;
  v43 = v21;
  v40 = v19;
  v22 = swift_checkMetadataState(0, v19);
  v21(0, v22, v20);
  v51 = *(_QWORD *)(v51 + 16);
  v23 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v51 + 72);
  v24 = v44;
  v45 = *(_QWORD *)(v45 + 8);
  v25 = v45;
  v23(v14, a3, v45, a2);
  v41 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23;
  v26 = v48;
  v39 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, _QWORD, unint64_t))v39)(v24, 0, v48);
  v27 = swift_checkMetadataState(0, v19);
  v29 = v42;
  v28 = v43;
  v43(1, v27, v42);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v23)(v14, v50, v25, a2, v51);
  v30 = v26;
  v31 = AssociatedConformanceWitness;
  v32 = v39;
  v39(v24, 1, v30, AssociatedConformanceWitness);
  v33 = swift_checkMetadataState(0, v40);
  v34 = v52;
  v28(2, v33, v29);
  v35 = v50;
  v41(v14, v50, v45, a2, v51);
  v32(v24, 2, v48, v31);
  v37 = type metadata accessor for SIMD3(0, v35, (uint64_t)v46, v36);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v37 - 8) + 8))(v34, v37);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  const char *v16;
  unint64_t AssociatedTypeWitness;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  void (*v22)(_QWORD, unint64_t *, unint64_t);
  unint64_t *v23;
  char *v24;
  uint64_t v25;
  void (*v26)(char *, uint64_t, uint64_t, uint64_t);
  char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  void (*v31)(uint64_t, unint64_t *, unint64_t);
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  void (*v36)(char *, uint64_t, unint64_t, unint64_t);
  unint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  void (*v43)(char *, uint64_t, unint64_t, unint64_t);
  void (*v44)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  void (*v45)(_QWORD, unint64_t *, unint64_t);
  char *v46;
  const char *v47;
  unint64_t AssociatedConformanceWitness;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;

  v54 = a4;
  v55 = a6;
  v53 = a1;
  v50 = a8;
  v12 = MEMORY[0x1E0C80A78](a1);
  v46 = (char *)&v42 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v12);
  v15 = (char *)&v42 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v49 = AssociatedTypeWitness;
  (*(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  v47 = a7;
  v18 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v19 = (uint64_t)a7;
  v20 = a3;
  v51 = v18;
  v21 = swift_getAssociatedConformanceWitness(v19, a3, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v45 = *(void (**)(_QWORD, unint64_t *, unint64_t))(v21 + 56);
  v22 = v45;
  v52 = v21;
  v23 = swift_checkMetadataState(0, v18);
  v24 = v46;
  v22(0, v23, v21);
  v25 = v55;
  v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v54 + 80);
  v27 = v15;
  v28 = v20;
  v26(v24, v20, v55, a2);
  v29 = v49;
  v43 = *(void (**)(char *, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness + 64);
  v44 = (void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v26;
  ((void (*)(char *, _QWORD, unint64_t))v43)(v15, 0, v49);
  v30 = swift_checkMetadataState(0, v51);
  v31 = v45;
  v45(1, v30, v52);
  v32 = v25;
  v33 = v54;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v26)(v24, v28, v32, a2, v54);
  v34 = v29;
  v35 = AssociatedConformanceWitness;
  v36 = v43;
  v43(v27, 1, v34, AssociatedConformanceWitness);
  v37 = swift_checkMetadataState(0, v51);
  v38 = v53;
  v31(2, v37, v52);
  v44(v24, v28, v55, a2, v33);
  v36(v27, 2, v49, v35);
  v40 = type metadata accessor for SIMD3(0, v28, (uint64_t)v47, v39);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(v40 - 8) + 8))(v38, v40);
}

uint64_t UInt8.SIMD2Storage._value.setter(uint64_t result)
{
  _WORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt8.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t UInt8.SIMD2Storage.init()()
{
  return 0;
}

uint64_t (*UInt8.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  _BYTE *v3;
  double v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  v5 = a3;
  *(_BYTE *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD2Storage(uint64_t a1, uint64_t a2, double a3))()
{
  _BYTE *v3;
  double v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  v5 = a3;
  *(_BYTE *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t UInt8.SIMD4Storage._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt8.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

uint64_t UInt8.SIMD4Storage.init()()
{
  return 0;
}

uint64_t (*UInt8.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  __int32 *v3;
  unint64_t v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  v5 = vmovl_u8(a3).u64[0];
  *(_BYTE *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD4Storage(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  __int32 *v3;
  unint64_t v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  v5 = vmovl_u8(a3).u64[0];
  *(_BYTE *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

void UInt8.SIMD8Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*UInt8.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt8.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t *v2;
  uint64_t v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v4 = *v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD8Storage@<D0>(_QWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = 0;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t *v2;
  uint64_t v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v4 = *v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

void UInt8.SIMD16Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*UInt8.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt8.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD16Storage@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt8.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt8.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD32Storage@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt8.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt8.SIMD64Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[4];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[4];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t Int8.SIMD2Storage._value.setter(uint64_t result)
{
  _WORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int8.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t Int8.SIMD2Storage.init()()
{
  return 0;
}

uint64_t Int8.SIMD2Storage.subscript.getter(char a1, __int16 a2)
{
  uint64_t v2;
  uint64_t v4;

  LODWORD(v2) = a2;
  HIDWORD(v2) = HIBYTE(a2);
  v4 = v2;
  return *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

__n128 key path getter for Int8.SIMD2Storage.subscript(_:) : Int8.SIMD2Storage@<Q0>(_BYTE *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>, double a4@<D0>)
{
  _DWORD *v4;
  __n128 result;
  double v6;

  LOBYTE(a4) = *a1;
  BYTE4(a4) = a1[1];
  v4 = (_DWORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1)));
  v6 = a4;
  *a3 = *v4;
  result.n128_u32[0] = LODWORD(a4);
  result.n128_u8[4] = BYTE4(a4);
  return result;
}

_BYTE *key path setter for Int8.SIMD2Storage.subscript(_:) : Int8.SIMD2Storage(_BYTE *result, uint64_t a2, unsigned int *a3)
{
  *(_BYTE *)(a2 + *a3) = *result;
  return result;
}

uint64_t Int8.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  _BYTE *v3;
  double v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  v5 = a3;
  *(_BYTE *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD2Storage@<Q0>(char a1@<W0>, _BYTE *a2@<X8>, double a3@<D0>)
{
  _BYTE *v3;
  __n128 result;
  double v5;

  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  v5 = a3;
  *a2 = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
  result.n128_u32[0] = LODWORD(a3);
  result.n128_u8[4] = BYTE4(a3);
  return result;
}

_BYTE *protocol witness for SIMDStorage.subscript.setter in conformance Int8.SIMD2Storage(_BYTE *result, unsigned int a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + a2) = *result;
  return result;
}

unsigned int *UInt8.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_BYTE *)(*((_QWORD *)result + 1) + *result) = *((_BYTE *)result + 16);
  return result;
}

uint64_t Int8.SIMD4Storage._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int8.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

uint64_t Int8.SIMD4Storage.init()()
{
  return 0;
}

uint64_t Int8.SIMD4Storage.subscript.getter(char a1, __int32 a2, int8x8_t a3)
{
  int8x8_t v4;

  a3.i32[0] = a2;
  v4 = vzip1_s8(a3, a3);
  return *(unsigned __int16 *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

double key path getter for Int8.SIMD4Storage.subscript(_:) : Int8.SIMD4Storage@<D0>(__int32 *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>, uint8x8_t a4@<D0>)
{
  double result;
  _WORD *v5;
  double v6;

  a4.i32[0] = *a1;
  *(_QWORD *)&result = vmovl_u8(a4).u64[0];
  v5 = (_WORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFF9 | (2 * (*a2 & 3)));
  v6 = result;
  *a3 = *v5;
  return result;
}

uint64_t Int8.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  __int32 *v3;
  unint64_t v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  v5 = vmovl_u8(a3).u64[0];
  *(_BYTE *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD4Storage@<D0>(char a1@<W0>, _BYTE *a2@<X8>, uint8x8_t a3@<D0>)
{
  __int32 *v3;
  double result;
  double v5;

  a3.i32[0] = *v3;
  *(_QWORD *)&result = vmovl_u8(a3).u64[0];
  v5 = result;
  *a2 = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
  return result;
}

void Int8.SIMD8Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*Int8.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int8.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD8Storage.subscript.getter(char a1, double a2)
{
  double v3;

  v3 = a2;
  return *(unsigned __int8 *)((unint64_t)&v3 | a1 & 7);
}

double key path getter for Int8.SIMD8Storage.subscript(_:) : Int8.SIMD8Storage@<D0>(double *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  double result;
  _BYTE *v4;
  double v5;

  result = *a1;
  v4 = (_BYTE *)((unint64_t)&v5 | *a2 & 7);
  v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int8.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t *v2;
  uint64_t v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v4 = *v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD8Storage@<D0>(char a1@<W0>, _BYTE *a2@<X8>)
{
  double *v2;
  double result;
  double v4;

  result = *v2;
  v4 = *v2;
  *a2 = *(_BYTE *)((unint64_t)&v4 | a1 & 7);
  return result;
}

void Int8.SIMD16Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Int8.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int8.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD16Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *(unsigned __int8 *)((unint64_t)&v2 | a1 & 0xF);
}

__n128 key path getter for Int8.SIMD16Storage.subscript(_:) : Int8.SIMD16Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  __n128 result;
  _BYTE *v4;
  __n128 v5;

  result = *a1;
  v4 = (_BYTE *)((unint64_t)&v5 | *a2 & 0xF);
  v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int8.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD16Storage@<Q0>(char a1@<W0>, _BYTE *a2@<X8>)
{
  __n128 *v2;
  __n128 result;
  __int128 v4;

  result = *v2;
  *a2 = *(_BYTE *)((unint64_t)&v4 | a1 & 0xF);
  return result;
}

void Int8.SIMD32Storage._value.setter(__n128 a1, __n128 a2)
{
  __n128 *v2;

  *v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int8.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int8.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD32Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *((unsigned __int8 *)&v2 + (a1 & 0x1F));
}

__n128 key path getter for Int8.SIMD32Storage.subscript(_:) : Int8.SIMD32Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  __n128 result;
  __int128 v4;

  result = *a1;
  *a3 = *((_BYTE *)&v4 + (*a2 & 0x1F));
  return result;
}

uint64_t Int8.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD32Storage@<Q0>(char a1@<W0>, _BYTE *a2@<X8>)
{
  __n128 *v2;
  __n128 result;
  __int128 v4;

  result = *v2;
  *a2 = *((_BYTE *)&v4 + (a1 & 0x1F));
  return result;
}

void Int8.SIMD64Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 *v4;

  v4[2] = a3;
  v4[3] = a4;
  *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int8.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int8.SIMD64Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD64Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  _OWORD v6[4];

  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned __int8 *)v6 + (a1 & 0x3F));
}

__n128 key path getter for Int8.SIMD64Storage.subscript(_:) : Int8.SIMD64Storage@<Q0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  __n128 result;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  _OWORD v7[4];

  result = *(__n128 *)a1;
  v4 = *(_OWORD *)(a1 + 16);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *a2 & 0x3F;
  v7[2] = *(_OWORD *)(a1 + 32);
  v7[3] = v5;
  v7[0] = result;
  v7[1] = v4;
  *a3 = *((_BYTE *)v7 + v6);
  return result;
}

uint64_t Int8.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_BYTE *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[4];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_BYTE *)(a1 + 16) = *((_BYTE *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD64Storage@<Q0>(char a1@<W0>, _BYTE *a2@<X8>)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;
  __int128 v5;
  _OWORD v6[4];

  result = *(__n128 *)v2;
  v4 = *(_OWORD *)(v2 + 16);
  v5 = *(_OWORD *)(v2 + 48);
  v6[2] = *(_OWORD *)(v2 + 32);
  v6[3] = v5;
  v6[0] = result;
  v6[1] = v4;
  *a2 = *((_BYTE *)v6 + (a1 & 0x3F));
  return result;
}

uint64_t UInt16.SIMD2Storage._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*UInt16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t UInt16.SIMD2Storage.init()()
{
  return 0;
}

uint64_t (*UInt16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  _WORD *v3;
  double v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD2Storage(uint64_t a1, uint64_t a2, double a3))()
{
  _WORD *v3;
  double v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

void UInt16.SIMD4Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*UInt16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt16.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t *v2;
  uint64_t v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t *v2;
  uint64_t v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

void UInt16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*UInt16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt16.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt16.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt16.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[4];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[4];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _OWORD v11[8];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[2];
  v6 = v2[3];
  v7 = v2[4];
  v8 = v2[5];
  v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt16.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _OWORD v11[8];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[2];
  v6 = v2[3];
  v7 = v2[4];
  v8 = v2[5];
  v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t Int16.SIMD2Storage._value.setter(uint64_t result)
{
  _DWORD *v1;

  *v1 = result;
  return result;
}

uint64_t (*Int16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t Int16.SIMD2Storage.init()()
{
  return 0;
}

uint64_t Int16.SIMD2Storage.subscript.getter(char a1, __int32 a2, uint16x4_t a3)
{
  unint64_t v4;

  a3.i32[0] = a2;
  v4 = vmovl_u16(a3).u64[0];
  return *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

__n128 key path getter for Int16.SIMD2Storage.subscript(_:) : Int16.SIMD2Storage@<Q0>(_WORD *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>, double a4@<D0>)
{
  _DWORD *v4;
  __n128 result;
  double v6;

  LOWORD(a4) = *a1;
  WORD2(a4) = a1[1];
  v4 = (_DWORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1)));
  v6 = a4;
  *a3 = *v4;
  result.n128_u32[0] = LODWORD(a4);
  result.n128_u16[2] = WORD2(a4);
  return result;
}

_WORD *key path setter for Int16.SIMD2Storage.subscript(_:) : Int16.SIMD2Storage(_WORD *result, uint64_t a2, unsigned int *a3)
{
  *(_WORD *)(a2 + 2 * *a3) = *result;
  return result;
}

uint64_t Int16.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  _WORD *v3;
  double v5;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v3;
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD2Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>, double a3@<D0>)
{
  _WORD *v3;
  __n128 result;
  double v5;

  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  v5 = a3;
  *a2 = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
  result.n128_u32[0] = LODWORD(a3);
  result.n128_u16[2] = WORD2(a3);
  return result;
}

_WORD *protocol witness for SIMDStorage.subscript.setter in conformance Int16.SIMD2Storage(_WORD *result, unsigned int a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * a2) = *result;
  return result;
}

unsigned int *UInt16.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_WORD *)(*((_QWORD *)result + 1) + 2 * *result) = *((_WORD *)result + 8);
  return result;
}

void Int16.SIMD4Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*Int16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int16.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD4Storage.subscript.getter(char a1, double a2)
{
  double v3;

  v3 = a2;
  return *(unsigned __int16 *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

double key path getter for Int16.SIMD4Storage.subscript(_:) : Int16.SIMD4Storage@<D0>(double *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  double result;
  _WORD *v4;
  double v5;

  result = *a1;
  v4 = (_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (*a2 & 3)));
  v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int16.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t *v2;
  uint64_t v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD4Storage@<D0>(char a1@<W0>, _WORD *a2@<X8>)
{
  double *v2;
  double result;
  double v4;

  result = *v2;
  v4 = *v2;
  *a2 = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
  return result;
}

void Int16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Int16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int16.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD8Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *(unsigned __int16 *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF1 | (2 * (a1 & 7)));
}

__n128 key path getter for Int16.SIMD8Storage.subscript(_:) : Int16.SIMD8Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result;
  _WORD *v4;
  __n128 v5;

  result = *a1;
  v4 = (_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF1 | (2 * (*a2 & 7)));
  v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int16.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD8Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 *v2;
  __n128 result;
  __int128 v4;

  result = *v2;
  *a2 = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a1 & 7)));
  return result;
}

void Int16.SIMD16Storage._value.setter(__n128 a1, __n128 a2)
{
  __n128 *v2;

  *v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int16.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD16Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *((unsigned __int16 *)&v2 + (a1 & 0xF));
}

__n128 key path getter for Int16.SIMD16Storage.subscript(_:) : Int16.SIMD16Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result;
  __int128 v4;

  result = *a1;
  *a3 = *((_WORD *)&v4 + (*a2 & 0xF));
  return result;
}

uint64_t Int16.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;
  __int128 v4;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD16Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 *v2;
  __n128 result;
  __int128 v4;

  result = *v2;
  *a2 = *((_WORD *)&v4 + (a1 & 0xF));
  return result;
}

void Int16.SIMD32Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 *v4;

  v4[2] = a3;
  v4[3] = a4;
  *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int16.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD32Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  _OWORD v6[4];

  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned __int16 *)v6 + (a1 & 0x1F));
}

__n128 key path getter for Int16.SIMD32Storage.subscript(_:) : Int16.SIMD32Storage@<Q0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  _OWORD v7[4];

  result = *(__n128 *)a1;
  v4 = *(_OWORD *)(a1 + 16);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *a2 & 0x1F;
  v7[2] = *(_OWORD *)(a1 + 32);
  v7[3] = v5;
  v7[0] = result;
  v7[1] = v4;
  *a3 = *((_WORD *)v7 + v6);
  return result;
}

uint64_t Int16.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  _OWORD v7[4];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD32Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;
  __int128 v5;
  _OWORD v6[4];

  result = *(__n128 *)v2;
  v4 = *(_OWORD *)(v2 + 16);
  v5 = *(_OWORD *)(v2 + 48);
  v6[2] = *(_OWORD *)(v2 + 32);
  v6[3] = v5;
  v6[0] = result;
  v6[1] = v4;
  *a2 = *((_WORD *)v6 + (a1 & 0x1F));
  return result;
}

__n128 Int16.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int16.SIMD64Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int16.SIMD64Storage.subscript.getter(char a1)
{
  __int128 *v1;
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  _OWORD v10[8];

  v2 = *v1;
  v3 = v1[1];
  v4 = v1[2];
  v5 = v1[3];
  v6 = v1[4];
  v7 = v1[5];
  v8 = v1[7];
  v10[6] = v1[6];
  v10[7] = v8;
  v10[4] = v6;
  v10[5] = v7;
  v10[2] = v4;
  v10[3] = v5;
  v10[0] = v2;
  v10[1] = v3;
  return *((unsigned __int16 *)v10 + (a1 & 0x3F));
}

__n128 key path getter for Int16.SIMD64Storage.subscript(_:) : Int16.SIMD64Storage@<Q0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  _OWORD v11[8];

  result = *(__n128 *)a1;
  v4 = *(_OWORD *)(a1 + 16);
  v5 = *(_OWORD *)(a1 + 32);
  v6 = *(_OWORD *)(a1 + 48);
  v7 = *(_OWORD *)(a1 + 64);
  v8 = *(_OWORD *)(a1 + 80);
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *a2 & 0x3F;
  v11[6] = *(_OWORD *)(a1 + 96);
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = result;
  v11[1] = v4;
  *a3 = *((_WORD *)v11 + v10);
  return result;
}

uint64_t Int16.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  __int128 *v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _OWORD v11[8];

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[2];
  v6 = v2[3];
  v7 = v2[4];
  v8 = v2[5];
  v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD64Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __n128 result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _OWORD v10[8];

  result = *(__n128 *)v2;
  v4 = *(_OWORD *)(v2 + 16);
  v5 = *(_OWORD *)(v2 + 32);
  v6 = *(_OWORD *)(v2 + 48);
  v7 = *(_OWORD *)(v2 + 64);
  v8 = *(_OWORD *)(v2 + 80);
  v9 = *(_OWORD *)(v2 + 112);
  v10[6] = *(_OWORD *)(v2 + 96);
  v10[7] = v9;
  v10[4] = v7;
  v10[5] = v8;
  v10[2] = v5;
  v10[3] = v6;
  v10[0] = result;
  v10[1] = v4;
  *a2 = *((_WORD *)v10 + (a1 & 0x3F));
  return result;
}

void UInt32.SIMD2Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*UInt32.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double UInt32.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD2Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

void UInt32.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*UInt32.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt32.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt32.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt32.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt32.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt32.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt32.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt32.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt32.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

void Int32.SIMD2Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*Int32.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Int32.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD2Storage.subscript.getter(char a1, double a2)
{
  double v3;

  v3 = a2;
  return *(unsigned int *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

uint64_t key path getter for Int32.SIMD2Storage.subscript(_:) : Int32.SIMD2Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 1));
  return result;
}

_DWORD *key path setter for Int32.SIMD2Storage.subscript(_:) : Int32.SIMD2Storage(_DWORD *result, uint64_t a2, unsigned int *a3)
{
  *(_DWORD *)(a2 + 4 * *a3) = *result;
  return result;
}

uint64_t Int32.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD2Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_DWORD *)(v2 + 4 * (result & 1));
  return result;
}

_DWORD *protocol witness for SIMDStorage.subscript.setter in conformance Int32.SIMD2Storage(_DWORD *result, unsigned int a2)
{
  uint64_t v2;

  *(_DWORD *)(v2 + 4 * a2) = *result;
  return result;
}

unsigned int *UInt32.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_DWORD *)(*((_QWORD *)result + 1) + 4 * *result) = result[4];
  return result;
}

void Int32.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Int32.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int32.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD4Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *(unsigned int *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF3 | (4 * (a1 & 3)));
}

uint64_t key path getter for Int32.SIMD4Storage.subscript(_:) : Int32.SIMD4Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 3));
  return result;
}

uint64_t Int32.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD4Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_DWORD *)(v2 + 4 * (result & 3));
  return result;
}

void Int32.SIMD8Storage._value.setter(__n128 a1, __n128 a2)
{
  __n128 *v2;

  *v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int32.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int32.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD8Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *((unsigned int *)&v2 + (a1 & 7));
}

uint64_t key path getter for Int32.SIMD8Storage.subscript(_:) : Int32.SIMD8Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 7));
  return result;
}

uint64_t Int32.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD8Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_DWORD *)(v2 + 4 * (result & 7));
  return result;
}

void Int32.SIMD16Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 *v4;

  v4[2] = a3;
  v4[3] = a4;
  *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int32.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int32.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD16Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  _OWORD v6[4];

  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned int *)v6 + (a1 & 0xF));
}

uint64_t key path getter for Int32.SIMD16Storage.subscript(_:) : Int32.SIMD16Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0xFLL));
  return result;
}

uint64_t Int32.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD16Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_DWORD *)(v2 + 4 * (result & 0xF));
  return result;
}

__n128 Int32.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int32.SIMD32Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int32.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int32.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int32.SIMD32Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(unsigned int *)(v1 + 4 * (a1 & 0x1F));
}

uint64_t key path getter for Int32.SIMD32Storage.subscript(_:) : Int32.SIMD32Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0x1FLL));
  return result;
}

uint64_t Int32.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD32Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_DWORD *)(v2 + 4 * (result & 0x1F));
  return result;
}

__n128 Int32.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 96);
  v9 = *(_OWORD *)(v1 + 112);
  v10 = *(_OWORD *)(v1 + 128);
  v11 = *(_OWORD *)(v1 + 144);
  v12 = *(_OWORD *)(v1 + 160);
  v13 = *(_OWORD *)(v1 + 176);
  v14 = *(_OWORD *)(v1 + 192);
  v15 = *(_OWORD *)(v1 + 208);
  v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int32.SIMD64Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 96);
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *(_OWORD *)(a1 + 128);
  v11 = *(_OWORD *)(a1 + 144);
  v12 = *(_OWORD *)(a1 + 160);
  v13 = *(_OWORD *)(a1 + 176);
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int32.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int32.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int32.SIMD64Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(unsigned int *)(v1 + 4 * (a1 & 0x3F));
}

uint64_t key path getter for Int32.SIMD64Storage.subscript(_:) : Int32.SIMD64Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0x3FLL));
  return result;
}

uint64_t Int32.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD64Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_DWORD *)(v2 + 4 * (result & 0x3F));
  return result;
}

void UInt64.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*UInt64.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double UInt64.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD2Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD2Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt64.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD4Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD4Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt64.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD8Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD8Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt64.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD16Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD16Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt64.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD32Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD32Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt64.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD64Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt64.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD64Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void Int64.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Int64.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Int64.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD2Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int64.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD4Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int64.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD8Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int64.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD16Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int64.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD32Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int64.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD64Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void UInt.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*UInt.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double UInt.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD2Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD4Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD8Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD16Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD32Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD64Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void Int.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Int.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Int.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD2Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *(_QWORD *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF7 | (8 * (a1 & 1)));
}

uint64_t key path getter for Int.SIMD2Storage.subscript(_:) : Int.SIMD2Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *(_QWORD *)(result + 8 * (*a2 & 1));
  return result;
}

_QWORD *key path setter for Int.SIMD2Storage.subscript(_:) : Int.SIMD2Storage(_QWORD *result, uint64_t a2, unsigned int *a3)
{
  *(_QWORD *)(a2 + 8 * *a3) = *result;
  return result;
}

uint64_t Int.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD2Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD2Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_QWORD *)(v2 + 8 * (result & 1));
  return result;
}

_QWORD *protocol witness for SIMDStorage.subscript.setter in conformance Int.SIMD2Storage(_QWORD *result, unsigned int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8 * a2) = *result;
  return result;
}

uint64_t UInt64.SIMD2Storage.subscript.modify(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 16) + 8 * *(unsigned int *)(result + 8)) = *(_QWORD *)result;
  return result;
}

void Int.SIMD4Storage._value.setter(__n128 a1, __n128 a2)
{
  __n128 *v2;

  *v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD4Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *((_QWORD *)&v2 + (a1 & 3));
}

uint64_t key path getter for Int.SIMD4Storage.subscript(_:) : Int.SIMD4Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *(_QWORD *)(result + 8 * (*a2 & 3));
  return result;
}

uint64_t Int.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD4Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD4Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_QWORD *)(v2 + 8 * (result & 3));
  return result;
}

void Int.SIMD8Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 *v4;

  v4[2] = a3;
  v4[3] = a4;
  *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD8Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  _OWORD v6[4];

  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((_QWORD *)v6 + (a1 & 7));
}

uint64_t key path getter for Int.SIMD8Storage.subscript(_:) : Int.SIMD8Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *(_QWORD *)(result + 8 * (*a2 & 7));
  return result;
}

uint64_t Int.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD8Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD8Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_QWORD *)(v2 + 8 * (result & 7));
  return result;
}

__n128 Int.SIMD16Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD16Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD16Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(_QWORD *)(v1 + 8 * (a1 & 0xF));
}

uint64_t key path getter for Int.SIMD16Storage.subscript(_:) : Int.SIMD16Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *(_QWORD *)(result + 8 * (*a2 & 0xFLL));
  return result;
}

uint64_t Int.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD16Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD16Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_QWORD *)(v2 + 8 * (result & 0xF));
  return result;
}

__n128 Int.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 96);
  v9 = *(_OWORD *)(v1 + 112);
  v10 = *(_OWORD *)(v1 + 128);
  v11 = *(_OWORD *)(v1 + 144);
  v12 = *(_OWORD *)(v1 + 160);
  v13 = *(_OWORD *)(v1 + 176);
  v14 = *(_OWORD *)(v1 + 192);
  v15 = *(_OWORD *)(v1 + 208);
  v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD32Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 96);
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *(_OWORD *)(a1 + 128);
  v11 = *(_OWORD *)(a1 + 144);
  v12 = *(_OWORD *)(a1 + 160);
  v13 = *(_OWORD *)(a1 + 176);
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD32Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(_QWORD *)(v1 + 8 * (a1 & 0x1F));
}

uint64_t key path getter for Int.SIMD32Storage.subscript(_:) : Int.SIMD32Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *(_QWORD *)(result + 8 * (*a2 & 0x1FLL));
  return result;
}

uint64_t Int.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD32Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD32Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_QWORD *)(v2 + 8 * (result & 0x1F));
  return result;
}

__n128 Int.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 96);
  v9 = *(_OWORD *)(v1 + 112);
  v10 = *(_OWORD *)(v1 + 128);
  v11 = *(_OWORD *)(v1 + 144);
  v12 = *(_OWORD *)(v1 + 160);
  v13 = *(_OWORD *)(v1 + 176);
  v14 = *(_OWORD *)(v1 + 192);
  v15 = *(_OWORD *)(v1 + 208);
  v16 = *(_OWORD *)(v1 + 224);
  v17 = *(_OWORD *)(v1 + 240);
  v18 = *(_OWORD *)(v1 + 256);
  v19 = *(_OWORD *)(v1 + 272);
  v20 = *(_OWORD *)(v1 + 288);
  v21 = *(_OWORD *)(v1 + 304);
  v22 = *(_OWORD *)(v1 + 320);
  v23 = *(_OWORD *)(v1 + 336);
  v24 = *(_OWORD *)(v1 + 352);
  v25 = *(_OWORD *)(v1 + 368);
  v26 = *(_OWORD *)(v1 + 384);
  v27 = *(_OWORD *)(v1 + 400);
  v28 = *(_OWORD *)(v1 + 416);
  v29 = *(_OWORD *)(v1 + 432);
  v30 = *(_OWORD *)(v1 + 448);
  v31 = *(_OWORD *)(v1 + 464);
  v32 = *(_OWORD *)(v1 + 496);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(v1 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 400) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 320) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD64Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 96);
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *(_OWORD *)(a1 + 128);
  v11 = *(_OWORD *)(a1 + 144);
  v12 = *(_OWORD *)(a1 + 160);
  v13 = *(_OWORD *)(a1 + 176);
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 224);
  v17 = *(_OWORD *)(a1 + 240);
  v18 = *(_OWORD *)(a1 + 256);
  v19 = *(_OWORD *)(a1 + 272);
  v20 = *(_OWORD *)(a1 + 288);
  v21 = *(_OWORD *)(a1 + 304);
  v22 = *(_OWORD *)(a1 + 320);
  v23 = *(_OWORD *)(a1 + 336);
  v24 = *(_OWORD *)(a1 + 352);
  v25 = *(_OWORD *)(a1 + 368);
  v26 = *(_OWORD *)(a1 + 384);
  v27 = *(_OWORD *)(a1 + 400);
  v28 = *(_OWORD *)(a1 + 416);
  v29 = *(_OWORD *)(a1 + 432);
  v30 = *(_OWORD *)(a1 + 448);
  v31 = *(_OWORD *)(a1 + 464);
  v32 = *(_OWORD *)(a1 + 496);
  *(_OWORD *)(v1 + 480) = *(_OWORD *)(a1 + 480);
  *(_OWORD *)(v1 + 496) = v32;
  *(_OWORD *)(v1 + 448) = v30;
  *(_OWORD *)(v1 + 464) = v31;
  *(_OWORD *)(v1 + 416) = v28;
  *(_OWORD *)(v1 + 432) = v29;
  *(_OWORD *)(v1 + 384) = v26;
  *(_OWORD *)(v1 + 400) = v27;
  *(_OWORD *)(v1 + 352) = v24;
  *(_OWORD *)(v1 + 368) = v25;
  *(_OWORD *)(v1 + 320) = v22;
  *(_OWORD *)(v1 + 336) = v23;
  *(_OWORD *)(v1 + 288) = v20;
  *(_OWORD *)(v1 + 304) = v21;
  *(_OWORD *)(v1 + 256) = v18;
  *(_OWORD *)(v1 + 272) = v19;
  *(_OWORD *)(v1 + 224) = v16;
  *(_OWORD *)(v1 + 240) = v17;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD64Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(_QWORD *)(v1 + 8 * (a1 & 0x3F));
}

uint64_t key path getter for Int.SIMD64Storage.subscript(_:) : Int.SIMD64Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, _QWORD *a3@<X8>)
{
  *a3 = *(_QWORD *)(result + 8 * (*a2 & 0x3FLL));
  return result;
}

uint64_t Int.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD64Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD64Storage@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  *a2 = *(_QWORD *)(v2 + 8 * (result & 0x3F));
  return result;
}

__n128 Float16.SIMD2Storage._value.setter(__n128 result, __n128 a2)
{
  _DWORD *v2;

  result.n128_u16[1] = a2.n128_u16[0];
  *v2 = result.n128_u32[0];
  return result;
}

uint64_t (*Float16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

float Float16.SIMD2Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD2Storage.subscript.getter@<H0>(char a1@<W0>, double a2@<D0>, __n128 a3@<Q1>)
{
  double v4;

  WORD1(a2) = a3.n128_u16[0];
  v4 = a2;
  return *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

__int16 key path getter for Float16.SIMD2Storage.subscript(_:) : Float16.SIMD2Storage@<H0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  result = *(_WORD *)(a1 + 2 * (*a2 & 1));
  *a3 = result;
  return result;
}

__int16 key path setter for Float16.SIMD2Storage.subscript(_:) : Float16.SIMD2Storage@<H0>(__int16 *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>)
{
  __int16 result;

  result = *a1;
  *(_WORD *)(a2 + 2 * *a3) = *a1;
  return result;
}

uint64_t Float16.SIMD2Storage.subscript.setter(uint64_t result, __n128 a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 1));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD2Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __int16 result;

  result = *(_WORD *)(v2 + 2 * (a1 & 1));
  *a2 = result;
  return result;
}

__int16 protocol witness for SIMDStorage.subscript.setter in conformance Float16.SIMD2Storage@<H0>(__int16 *a1@<X0>, unsigned int a2@<W1>)
{
  uint64_t v2;
  __int16 result;

  result = *a1;
  *(_WORD *)(v2 + 2 * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD2Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 1));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 Float16.SIMD2Storage.subscript.modify@<H0>(unsigned int *a1@<X0>)
{
  __int16 result;

  result = *((_WORD *)a1 + 8);
  *(_WORD *)(*((_QWORD *)a1 + 1) + 2 * *a1) = result;
  return result;
}

void Float16.SIMD4Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*Float16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Float16.SIMD4Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD4Storage.subscript.getter@<H0>(char a1@<W0>, double a2@<D0>)
{
  double v3;

  v3 = a2;
  return *(_WORD *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

__int16 key path getter for Float16.SIMD4Storage.subscript(_:) : Float16.SIMD4Storage@<H0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  result = *(_WORD *)(a1 + 2 * (*a2 & 3));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD4Storage.subscript.setter(uint64_t result, __n128 a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 3));
  return Float16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance Float16.SIMD4Storage@<D0>(_QWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = 0;
  return result;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD4Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __int16 result;

  result = *(_WORD *)(v2 + 2 * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 3));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Float16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Float16.SIMD8Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD8Storage.subscript.getter@<H0>(char a1@<W0>)
{
  __int128 v2;

  return *(_WORD *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF1 | (2 * (a1 & 7)));
}

__int16 key path getter for Float16.SIMD8Storage.subscript(_:) : Float16.SIMD8Storage@<H0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  result = *(_WORD *)(a1 + 2 * (*a2 & 7));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD8Storage.subscript.setter(uint64_t result, __n128 a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 7));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD8Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __int16 result;

  result = *(_WORD *)(v2 + 2 * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 7));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD16Storage._value.setter(__n128 a1, __n128 a2)
{
  __n128 *v2;

  *v2 = a1;
  v2[1] = a2;
}

uint64_t (*Float16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Float16.SIMD16Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD16Storage.subscript.getter@<H0>(char a1@<W0>)
{
  __int128 v2;

  return *((_WORD *)&v2 + (a1 & 0xF));
}

__int16 key path getter for Float16.SIMD16Storage.subscript(_:) : Float16.SIMD16Storage@<H0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  result = *(_WORD *)(a1 + 2 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD16Storage.subscript.setter(uint64_t result, __n128 a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0xF));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD16Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __int16 result;

  result = *(_WORD *)(v2 + 2 * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0xF));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD32Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 *v4;

  v4[2] = a3;
  v4[3] = a4;
  *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Float16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Float16.SIMD32Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD32Storage.subscript.getter@<H0>(char a1@<W0>, __n128 a2@<Q0>, __n128 a3@<Q1>, __n128 a4@<Q2>, __n128 a5@<Q3>)
{
  _OWORD v6[4];

  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((_WORD *)v6 + (a1 & 0x1F));
}

__int16 key path getter for Float16.SIMD32Storage.subscript(_:) : Float16.SIMD32Storage@<H0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  result = *(_WORD *)(a1 + 2 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD32Storage.subscript.setter(uint64_t result, __n128 a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x1F));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD32Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __int16 result;

  result = *(_WORD *)(v2 + 2 * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x1F));
  return Float16.SIMD2Storage.subscript.modify;
}

__n128 Float16.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float16.SIMD64Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Float16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

__int16 Float16.SIMD64Storage.subscript.getter@<H0>(char a1@<W0>)
{
  uint64_t v1;

  return *(_WORD *)(v1 + 2 * (a1 & 0x3F));
}

__int16 key path getter for Float16.SIMD64Storage.subscript(_:) : Float16.SIMD64Storage@<H0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result;

  result = *(_WORD *)(a1 + 2 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD64Storage.subscript.setter(uint64_t result, __n128 a2)
{
  uint64_t v2;

  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x3F));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD64Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  uint64_t v2;
  __int16 result;

  result = *(_WORD *)(v2 + 2 * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x3F));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float.SIMD2Storage._value.setter(double a1)
{
  double *v1;

  *v1 = a1;
}

uint64_t (*Float.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Float.SIMD2Storage.init()()
{
  return 0.0;
}

float Float.SIMD2Storage.subscript.getter(char a1, double a2)
{
  double v3;

  v3 = a2;
  return *(float *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

float key path getter for Float.SIMD2Storage.subscript(_:) : Float.SIMD2Storage@<S0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *(float *)(a1 + 4 * (*a2 & 1));
  *a3 = result;
  return result;
}

float key path setter for Float.SIMD2Storage.subscript(_:) : Float.SIMD2Storage(float *a1, uint64_t a2, unsigned int *a3)
{
  float result;

  result = *a1;
  *(float *)(a2 + 4 * *a3) = *a1;
  return result;
}

uint64_t Float.SIMD2Storage.subscript.setter(uint64_t result, float a2)
{
  uint64_t v2;

  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD2Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  uint64_t v2;
  float result;

  result = *(float *)(v2 + 4 * (a1 & 1));
  *a2 = result;
  return result;
}

float protocol witness for SIMDStorage.subscript.setter in conformance Float.SIMD2Storage(float *a1, unsigned int a2)
{
  uint64_t v2;
  float result;

  result = *a1;
  *(float *)(v2 + 4 * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD2Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return Float.SIMD2Storage.subscript.modify;
}

float Float.SIMD2Storage.subscript.modify(float *a1)
{
  float result;

  result = a1[4];
  *(float *)(*((_QWORD *)a1 + 1) + 4 * *(unsigned int *)a1) = result;
  return result;
}

void Float.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Float.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Float.SIMD4Storage.init()()
{
  return 0.0;
}

float Float.SIMD4Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *(float *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF3 | (4 * (a1 & 3)));
}

float key path getter for Float.SIMD4Storage.subscript(_:) : Float.SIMD4Storage@<S0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *(float *)(a1 + 4 * (*a2 & 3));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD4Storage.subscript.setter(uint64_t result, float a2)
{
  uint64_t v2;

  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD4Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  uint64_t v2;
  float result;

  result = *(float *)(v2 + 4 * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return Float.SIMD2Storage.subscript.modify;
}

void Float.SIMD8Storage._value.setter(__n128 a1, __n128 a2)
{
  __n128 *v2;

  *v2 = a1;
  v2[1] = a2;
}

uint64_t (*Float.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Float.SIMD8Storage.init()()
{
  return 0.0;
}

float Float.SIMD8Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *((float *)&v2 + (a1 & 7));
}

float key path getter for Float.SIMD8Storage.subscript(_:) : Float.SIMD8Storage@<S0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *(float *)(a1 + 4 * (*a2 & 7));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD8Storage.subscript.setter(uint64_t result, float a2)
{
  uint64_t v2;

  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD8Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  uint64_t v2;
  float result;

  result = *(float *)(v2 + 4 * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return Float.SIMD2Storage.subscript.modify;
}

void Float.SIMD16Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 *v4;

  v4[2] = a3;
  v4[3] = a4;
  *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Float.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Float.SIMD16Storage.init()()
{
  return 0.0;
}

float Float.SIMD16Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  _OWORD v6[4];

  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((float *)v6 + (a1 & 0xF));
}

float key path getter for Float.SIMD16Storage.subscript(_:) : Float.SIMD16Storage@<S0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *(float *)(a1 + 4 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD16Storage.subscript.setter(uint64_t result, float a2)
{
  uint64_t v2;

  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD16Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  uint64_t v2;
  float result;

  result = *(float *)(v2 + 4 * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return Float.SIMD2Storage.subscript.modify;
}

__n128 Float.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float.SIMD32Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Float.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

float Float.SIMD32Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(float *)(v1 + 4 * (a1 & 0x1F));
}

float key path getter for Float.SIMD32Storage.subscript(_:) : Float.SIMD32Storage@<S0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *(float *)(a1 + 4 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD32Storage.subscript.setter(uint64_t result, float a2)
{
  uint64_t v2;

  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD32Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  uint64_t v2;
  float result;

  result = *(float *)(v2 + 4 * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return Float.SIMD2Storage.subscript.modify;
}

__n128 Float.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 96);
  v9 = *(_OWORD *)(v1 + 112);
  v10 = *(_OWORD *)(v1 + 128);
  v11 = *(_OWORD *)(v1 + 144);
  v12 = *(_OWORD *)(v1 + 160);
  v13 = *(_OWORD *)(v1 + 176);
  v14 = *(_OWORD *)(v1 + 192);
  v15 = *(_OWORD *)(v1 + 208);
  v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float.SIMD64Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 96);
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *(_OWORD *)(a1 + 128);
  v11 = *(_OWORD *)(a1 + 144);
  v12 = *(_OWORD *)(a1 + 160);
  v13 = *(_OWORD *)(a1 + 176);
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Float.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

float Float.SIMD64Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(float *)(v1 + 4 * (a1 & 0x3F));
}

float key path getter for Float.SIMD64Storage.subscript(_:) : Float.SIMD64Storage@<S0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, float *a3@<X8>)
{
  float result;

  result = *(float *)(a1 + 4 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD64Storage.subscript.setter(uint64_t result, float a2)
{
  uint64_t v2;

  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD64Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  uint64_t v2;
  float result;

  result = *(float *)(v2 + 4 * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  uint64_t v2;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return Float.SIMD2Storage.subscript.modify;
}

void Double.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1;

  *v1 = a1;
}

uint64_t (*Double.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Double.SIMD2Storage.init()()
{
  return 0.0;
}

double Double.SIMD2Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *(double *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF7 | (8 * (a1 & 1)));
}

double key path getter for Double.SIMD2Storage.subscript(_:) : Double.SIMD2Storage@<D0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *(double *)(a1 + 8 * (*a2 & 1));
  *a3 = result;
  return result;
}

double key path setter for Double.SIMD2Storage.subscript(_:) : Double.SIMD2Storage(double *a1, uint64_t a2, unsigned int *a3)
{
  double result;

  result = *a1;
  *(double *)(a2 + 8 * *a3) = *a1;
  return result;
}

uint64_t Double.SIMD2Storage.subscript.setter(uint64_t result, double a2)
{
  uint64_t v2;

  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD2Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 1));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD2Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  uint64_t v2;
  double result;

  result = *(double *)(v2 + 8 * (a1 & 1));
  *a2 = result;
  return result;
}

double protocol witness for SIMDStorage.subscript.setter in conformance Double.SIMD2Storage(double *a1, unsigned int a2)
{
  uint64_t v2;
  double result;

  result = *a1;
  *(double *)(v2 + 8 * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD2Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 1));
  return Double.SIMD2Storage.subscript.modify;
}

double Double.SIMD2Storage.subscript.modify(uint64_t a1)
{
  double result;

  result = *(double *)a1;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * *(unsigned int *)(a1 + 8)) = *(_QWORD *)a1;
  return result;
}

void Double.SIMD4Storage._value.setter(__n128 a1, __n128 a2)
{
  __n128 *v2;

  *v2 = a1;
  v2[1] = a2;
}

uint64_t (*Double.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Double.SIMD4Storage.init()()
{
  return 0.0;
}

double Double.SIMD4Storage.subscript.getter(char a1)
{
  __int128 v2;

  return *((double *)&v2 + (a1 & 3));
}

double key path getter for Double.SIMD4Storage.subscript(_:) : Double.SIMD4Storage@<D0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *(double *)(a1 + 8 * (*a2 & 3));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD4Storage.subscript.setter(uint64_t result, double a2)
{
  uint64_t v2;

  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD4Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 3));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD4Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  uint64_t v2;
  double result;

  result = *(double *)(v2 + 8 * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD4Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 3));
  return Double.SIMD2Storage.subscript.modify;
}

void Double.SIMD8Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 *v4;

  v4[2] = a3;
  v4[3] = a4;
  *v4 = a1;
  v4[1] = a2;
}

uint64_t (*Double.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Double.SIMD8Storage.init()()
{
  return 0.0;
}

double Double.SIMD8Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  _OWORD v6[4];

  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((double *)v6 + (a1 & 7));
}

double key path getter for Double.SIMD8Storage.subscript(_:) : Double.SIMD8Storage@<D0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *(double *)(a1 + 8 * (*a2 & 7));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD8Storage.subscript.setter(uint64_t result, double a2)
{
  uint64_t v2;

  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD8Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 7));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD8Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  uint64_t v2;
  double result;

  result = *(double *)(v2 + 8 * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD8Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 7));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD16Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD16Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Double.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD16Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(double *)(v1 + 8 * (a1 & 0xF));
}

double key path getter for Double.SIMD16Storage.subscript(_:) : Double.SIMD16Storage@<D0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *(double *)(a1 + 8 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD16Storage.subscript.setter(uint64_t result, double a2)
{
  uint64_t v2;

  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD16Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0xF));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD16Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  uint64_t v2;
  double result;

  result = *(double *)(v2 + 8 * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD16Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0xF));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 96);
  v9 = *(_OWORD *)(v1 + 112);
  v10 = *(_OWORD *)(v1 + 128);
  v11 = *(_OWORD *)(v1 + 144);
  v12 = *(_OWORD *)(v1 + 160);
  v13 = *(_OWORD *)(v1 + 176);
  v14 = *(_OWORD *)(v1 + 192);
  v15 = *(_OWORD *)(v1 + 208);
  v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD32Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 96);
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *(_OWORD *)(a1 + 128);
  v11 = *(_OWORD *)(a1 + 144);
  v12 = *(_OWORD *)(a1 + 160);
  v13 = *(_OWORD *)(a1 + 176);
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Double.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD32Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(double *)(v1 + 8 * (a1 & 0x1F));
}

double key path getter for Double.SIMD32Storage.subscript(_:) : Double.SIMD32Storage@<D0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *(double *)(a1 + 8 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD32Storage.subscript.setter(uint64_t result, double a2)
{
  uint64_t v2;

  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD32Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x1F));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD32Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  uint64_t v2;
  double result;

  result = *(double *)(v2 + 8 * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD32Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x1F));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  v4 = *(_OWORD *)(v1 + 32);
  v5 = *(_OWORD *)(v1 + 48);
  v6 = *(_OWORD *)(v1 + 64);
  v7 = *(_OWORD *)(v1 + 80);
  v8 = *(_OWORD *)(v1 + 96);
  v9 = *(_OWORD *)(v1 + 112);
  v10 = *(_OWORD *)(v1 + 128);
  v11 = *(_OWORD *)(v1 + 144);
  v12 = *(_OWORD *)(v1 + 160);
  v13 = *(_OWORD *)(v1 + 176);
  v14 = *(_OWORD *)(v1 + 192);
  v15 = *(_OWORD *)(v1 + 208);
  v16 = *(_OWORD *)(v1 + 224);
  v17 = *(_OWORD *)(v1 + 240);
  v18 = *(_OWORD *)(v1 + 256);
  v19 = *(_OWORD *)(v1 + 272);
  v20 = *(_OWORD *)(v1 + 288);
  v21 = *(_OWORD *)(v1 + 304);
  v22 = *(_OWORD *)(v1 + 320);
  v23 = *(_OWORD *)(v1 + 336);
  v24 = *(_OWORD *)(v1 + 352);
  v25 = *(_OWORD *)(v1 + 368);
  v26 = *(_OWORD *)(v1 + 384);
  v27 = *(_OWORD *)(v1 + 400);
  v28 = *(_OWORD *)(v1 + 416);
  v29 = *(_OWORD *)(v1 + 432);
  v30 = *(_OWORD *)(v1 + 448);
  v31 = *(_OWORD *)(v1 + 464);
  v32 = *(_OWORD *)(v1 + 496);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(v1 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 400) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 320) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD64Storage._value.setter(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  v4 = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 48);
  v6 = *(_OWORD *)(a1 + 64);
  v7 = *(_OWORD *)(a1 + 80);
  v8 = *(_OWORD *)(a1 + 96);
  v9 = *(_OWORD *)(a1 + 112);
  v10 = *(_OWORD *)(a1 + 128);
  v11 = *(_OWORD *)(a1 + 144);
  v12 = *(_OWORD *)(a1 + 160);
  v13 = *(_OWORD *)(a1 + 176);
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 224);
  v17 = *(_OWORD *)(a1 + 240);
  v18 = *(_OWORD *)(a1 + 256);
  v19 = *(_OWORD *)(a1 + 272);
  v20 = *(_OWORD *)(a1 + 288);
  v21 = *(_OWORD *)(a1 + 304);
  v22 = *(_OWORD *)(a1 + 320);
  v23 = *(_OWORD *)(a1 + 336);
  v24 = *(_OWORD *)(a1 + 352);
  v25 = *(_OWORD *)(a1 + 368);
  v26 = *(_OWORD *)(a1 + 384);
  v27 = *(_OWORD *)(a1 + 400);
  v28 = *(_OWORD *)(a1 + 416);
  v29 = *(_OWORD *)(a1 + 432);
  v30 = *(_OWORD *)(a1 + 448);
  v31 = *(_OWORD *)(a1 + 464);
  v32 = *(_OWORD *)(a1 + 496);
  *(_OWORD *)(v1 + 480) = *(_OWORD *)(a1 + 480);
  *(_OWORD *)(v1 + 496) = v32;
  *(_OWORD *)(v1 + 448) = v30;
  *(_OWORD *)(v1 + 464) = v31;
  *(_OWORD *)(v1 + 416) = v28;
  *(_OWORD *)(v1 + 432) = v29;
  *(_OWORD *)(v1 + 384) = v26;
  *(_OWORD *)(v1 + 400) = v27;
  *(_OWORD *)(v1 + 352) = v24;
  *(_OWORD *)(v1 + 368) = v25;
  *(_OWORD *)(v1 + 320) = v22;
  *(_OWORD *)(v1 + 336) = v23;
  *(_OWORD *)(v1 + 288) = v20;
  *(_OWORD *)(v1 + 304) = v21;
  *(_OWORD *)(v1 + 256) = v18;
  *(_OWORD *)(v1 + 272) = v19;
  *(_OWORD *)(v1 + 224) = v16;
  *(_OWORD *)(v1 + 240) = v17;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Double.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD64Storage.subscript.getter(char a1)
{
  uint64_t v1;

  return *(double *)(v1 + 8 * (a1 & 0x3F));
}

double key path getter for Double.SIMD64Storage.subscript(_:) : Double.SIMD64Storage@<D0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, double *a3@<X8>)
{
  double result;

  result = *(double *)(a1 + 8 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD64Storage.subscript.setter(uint64_t result, double a2)
{
  uint64_t v2;

  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD64Storage.subscript.modify(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x3F));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD64Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  uint64_t v2;
  double result;

  result = *(double *)(v2 + 8 * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD64Storage(_QWORD *a1, uint64_t a2))()
{
  uint64_t v2;

  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(_QWORD *)(v2 + 8 * (a2 & 0x3F));
  return Double.SIMD2Storage.subscript.modify;
}

__int16 *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(__int16 *result@<X0>, uint64_t a2@<X8>)
{
  __int16 v2;

  v2 = *result;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 40) = &type metadata for UInt16;
  *(_WORD *)(a2 + 16) = v2;
  return result;
}

char *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  char v2;

  v2 = *result;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 40) = &type metadata for UInt8;
  *(_BYTE *)(a2 + 16) = v2;
  return result;
}

int *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v2;

  v2 = *result;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 40) = &type metadata for Unicode.Scalar;
  *(_DWORD *)(a2 + 16) = v2;
  return result;
}

void specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[5] = &unk_1E0EB1298;
}

unint64_t specialized String.UTF16View._foreignIndex(after:)(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000) + 65544;
}

unint64_t specialized String.UTF16View._foreignIndex(before:)(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000) - 65528;
}

char *specialized _ArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0)
    goto LABEL_7;
  v5 = (char *)(a4 + 8 * a1 + 32);
  v6 = 8 * v4;
  v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  memcpy(__dst, v5, v6);
  return v7;
}

{
  size_t v4;
  char *v5;
  char *v6;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if ((v4 & 0x8000000000000000) != 0)
    goto LABEL_7;
  v5 = (char *)(a4 + a1 + 32);
  v6 = &__dst[v4];
  if (v5 < &__dst[v4] && &v5[v4] > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  memcpy(__dst, v5, v4);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  char *v6;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0)
    goto LABEL_7;
  v5 = (char *)(a4 + 32 * a1 + 32);
  v6 = &__dst[32 * v4];
  if (v5 < v6 && &v5[32 * v4] > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  swift_arrayInitWithCopy(__dst, v5, v4, (uint64_t)&unk_1E0EB1338);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0)
    goto LABEL_7;
  v5 = (char *)(a4 + 16 * a1 + 32);
  v6 = 16 * v4;
  v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  memcpy(__dst, v5, v6);
  return v7;
}

{
  uint64_t v4;
  char *v5;
  char *v6;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0)
    goto LABEL_7;
  v5 = (char *)(a4 + 8 * a1 + 32);
  v6 = &__dst[8 * v4];
  if (v5 < v6 && &v5[8 * v4] > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  swift_arrayInitWithCopy(__dst, v5, v4, (uint64_t)&unk_1E0EAD8F0);
  return v6;
}

unint64_t specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(int a1, unsigned int a2)
{
  BOOL v2;
  unsigned __int8 v3;
  unsigned int v4;

  v2 = (a1 - 4352) <= 0x12 && a2 >= 0x1161;
  if (v2 && a2 >> 1 <= 0x8BA)
  {
    v3 = 0;
    v4 = 28 * a2 + 588 * a1 - 2639516;
  }
  else
  {
    v4 = 0;
    v3 = 1;
    if ((a1 - 44032) >> 2 <= 0xAE8
      && a2 >> 3 >= 0x235
      && a2 <= 0x11C2
      && (unsigned __int16)(a1 + 21504) == 28 * ((153391690 * (unint64_t)(unsigned __int16)(a1 + 21504)) >> 32))
    {
      v3 = 0;
      v4 = a1 + a2 - 4519;
    }
  }
  return v4 | ((unint64_t)v3 << 32);
}

int64_t specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(char *a1, size_t a2, int64_t a3, char a4)
{
  unint64_t v6;
  uint64_t v7;
  int64_t v8;
  uint64_t v9;

  v6 = a2 | 0xC000000000000000;
  if ((a4 & 1) == 0)
    v6 = a2;
  v7 = v6 | 0x3000000000000000;
  v8 = _allocateStringStorage(codeUnitCapacity:)(a3);
  *(_QWORD *)(v8 + 16) = v9;
  *(_QWORD *)(v8 + 24) = v7;
  if (v9 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v7 = *(_QWORD *)(v8 + 24);
  }
  *(_BYTE *)(v8 + 32 + (v7 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)(a1, a2, (char *)(v8 + 32));
  return v8;
}

uint64_t specialized static String._uncheckedFromUTF8(_:isASCII:)(uint8x16_t *a1, uint64_t a2, char a3)
{
  int8x8_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int64x2_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int64x2_t v12;
  int64x2_t v13;
  int64x2_t v14;
  int64x2_t v15;
  uint8x8_t *v16;
  int8x16_t v17;
  unint64_t v18;
  int64x2_t v19;
  int8x16_t v20;
  int8x16_t v21;
  uint8x8_t v22;
  uint16x8_t v23;
  uint32x4_t v24;
  uint64x2_t v25;
  uint64x2_t v26;
  uint64x2_t v27;
  uint32x4_t v28;
  uint64x2_t v29;
  int8x16_t v30;
  uint16x8_t v31;
  int8x16_t v32;
  uint16x8_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x8_t v36;
  int8x16_t v37;
  int8x8_t v38;
  uint64x2_t v39;
  int8x16_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  unsigned __int8 *v44;
  unint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int8 *v49;
  unsigned int v50;

  if (!a2)
    return 0;
  if (a2 > 15)
    return *(uint64_t *)(specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(a1->i8, a2, a2, a3 & 1)+ 24);
  v4 = a2 - 8;
  if (a2 >= 8)
    v5 = 8;
  else
    v5 = a2;
  if ((v5 & 0x8000000000000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (v5 < 8)
  {
    v6 = 0;
    v3 = 0;
    v7 = 0;
    goto LABEL_19;
  }
  if (v5 >= 0x10)
  {
    v6 = v5 & 0xFFFFFFFFFFFFFFF0;
    v31 = vmovl_high_u8(*a1);
    v32 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v31.i8);
    v33 = vmovl_u8(*(uint8x8_t *)a1->i8);
    v34 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v33.i8);
    v35 = (int8x16_t)vmovl_high_u16(v31);
    v36 = (int8x8_t)vextq_s8(v35, v35, 8uLL).u64[0];
    v37 = (int8x16_t)vmovl_high_u16(v33);
    v38 = (int8x8_t)vextq_s8(v37, v37, 8uLL).u64[0];
    *(int8x8_t *)v37.i8 = vorr_s8(*(int8x8_t *)v37.i8, *(int8x8_t *)v35.i8);
    v39.i64[0] = v37.u32[0];
    v39.i64[1] = v37.u32[1];
    v40 = (int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1816ABC20);
    *(int8x8_t *)v35.i8 = vorr_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)v32.i8);
    v39.i64[0] = v35.u32[0];
    v39.i64[1] = v35.u32[1];
    v41 = vorrq_s8((int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1816ABC10), v40);
    *(int8x8_t *)v35.i8 = vorr_s8(v38, v36);
    v39.i64[0] = v35.u32[0];
    v39.i64[1] = v35.u32[1];
    v42 = (int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1816ABC00);
    *(int8x8_t *)v32.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
    v39.i64[0] = v32.u32[0];
    v39.i64[1] = v32.u32[1];
    v43 = vorrq_s8(v41, vorrq_s8((int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_1816ABBF0), v42));
    v3 = vorr_s8(*(int8x8_t *)v43.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
    if (v5 == (v5 & 0xFFFFFFFFFFFFFFF0))
      goto LABEL_21;
    v7 = 8 * v6;
    if ((v5 & 8) == 0)
      goto LABEL_19;
  }
  else
  {
    v3 = 0;
    v7 = 0;
    v6 = 0;
  }
  v8 = v6;
  v9 = vdupq_n_s64(v7);
  v6 = v5 & 0xFFFFFFFFFFFFFFF8;
  v7 = 8 * (v5 & 0xFFFFFFFFFFFFFFF8);
  v10 = 0uLL;
  v11 = (int8x16_t)(unint64_t)v3;
  v12 = vaddq_s64(v9, (int64x2_t)xmmword_1816ABC00);
  v13 = vaddq_s64(v9, (int64x2_t)xmmword_1816ABC20);
  v14 = vaddq_s64(v9, (int64x2_t)xmmword_1816ABBF0);
  v15 = vaddq_s64(v9, (int64x2_t)xmmword_1816ABC10);
  v16 = (uint8x8_t *)&a1->i8[v8];
  v17 = (int8x16_t)vdupq_n_s64(0x38uLL);
  v18 = v8 - (v5 & 0xFFFFFFFFFFFFFFF8);
  v19 = vdupq_n_s64(0x40uLL);
  v20 = 0uLL;
  v21 = 0uLL;
  do
  {
    v22 = *v16++;
    v23 = vmovl_u8(v22);
    v24 = vmovl_high_u16(v23);
    v25.i64[0] = v24.u32[2];
    v25.i64[1] = v24.u32[3];
    v26 = v25;
    v25.i64[0] = v24.u32[0];
    v25.i64[1] = v24.u32[1];
    v27 = v25;
    v28 = vmovl_u16(*(uint16x4_t *)v23.i8);
    v25.i64[0] = v28.u32[2];
    v25.i64[1] = v28.u32[3];
    v29 = v25;
    v25.i64[0] = v28.u32[0];
    v25.i64[1] = v28.u32[1];
    v21 = vorrq_s8((int8x16_t)vshlq_u64(v26, (uint64x2_t)vandq_s8((int8x16_t)v12, v17)), v21);
    v20 = vorrq_s8((int8x16_t)vshlq_u64(v27, (uint64x2_t)vandq_s8((int8x16_t)v13, v17)), v20);
    v10 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)vandq_s8((int8x16_t)v14, v17)), v10);
    v11 = vorrq_s8((int8x16_t)vshlq_u64(v25, (uint64x2_t)vandq_s8((int8x16_t)v15, v17)), v11);
    v13 = vaddq_s64(v13, v19);
    v14 = vaddq_s64(v14, v19);
    v15 = vaddq_s64(v15, v19);
    v12 = vaddq_s64(v12, v19);
    v18 += 8;
  }
  while (v18);
  v30 = vorrq_s8(vorrq_s8(v11, v20), vorrq_s8(v10, v21));
  v3 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
  if (v5 != v6)
  {
LABEL_19:
    v44 = &a1->u8[v6];
    v45 = v5 - v6;
    do
    {
      v46 = *v44++;
      *(_QWORD *)&v3 |= (unint64_t)v46 << (v7 & 0x38);
      v7 += 8;
      --v45;
    }
    while (v45);
  }
LABEL_21:
  if (a2 >= 9)
  {
    v47 = 0;
    v48 = 0;
    v49 = &a1->u8[8];
    do
    {
      v50 = *v49++;
      v47 |= (unint64_t)v50 << v48;
      v48 += 8;
      --v4;
    }
    while (v4);
  }
  return (uint64_t)v3;
}

uint64_t specialized static String._uncheckedFromUTF8(_:)(uint8x16_t *a1, uint64_t a2)
{
  uint8x16_t *v2;
  uint64_t v3;
  uint64_t v4;
  char v5;

  if (!a2)
    goto LABEL_20;
  if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFF0) < 1)
  {
    v2 = a1;
  }
  else
  {
    if (((a1->i64[1] | a1->i64[0]) & 0x8080808080808080) != 0)
      goto LABEL_22;
    v2 = a1 + 1;
    while (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFF0])
    {
      v3 = v2->i64[0];
      v4 = v2->i64[1];
      ++v2;
      if (((v4 | v3) & 0x8080808080808080) != 0)
        goto LABEL_22;
    }
  }
  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v2->i64[0] & 0x8080808080808080) != 0)
      goto LABEL_22;
    v2 = (uint8x16_t *)((char *)v2 + 8);
  }
  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v2->i32[0] & 0x80808080) != 0)
      goto LABEL_22;
    v2 = (uint8x16_t *)((char *)v2 + 4);
  }
  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFFELL])
  {
    if ((v2->i16[0] & 0x8080) == 0)
    {
      v2 = (uint8x16_t *)((char *)v2 + 2);
      goto LABEL_18;
    }
LABEL_22:
    v5 = 0;
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v5);
  }
LABEL_18:
  if (v2 < (uint8x16_t *)&a1->i8[a2] && v2->i8[0] < 0)
    goto LABEL_22;
LABEL_20:
  v5 = 1;
  return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v5);
}

uint64_t specialized static String._copying(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 v4;
  int64_t v5;
  id v6;
  uint64_t v7;
  uint8x16_t *v8;
  uint64_t v9;
  uint8x16_t *v11;
  uint64_t v12;
  int64_t v13;
  _QWORD v14[2];

  if ((a4 & 0x1000000000000000) != 0)
  {
    v11 = (uint8x16_t *)specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2, a3, a4);
    v12 = specialized static String._uncheckedFromUTF8(_:)(v11 + 2, v11[1].i64[0]);
    swift_release((uint64_t)v11);
    return v12;
  }
  else
  {
    v4 = a1._rawBits >> 16;
    v5 = a2._rawBits >> 16;
    if ((a4 & 0x2000000000000000) == 0)
    {
      if ((a3 & 0x1000000000000000) != 0)
      {
        v6 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        v7 = a3 & 0xFFFFFFFFFFFFLL;
        if ((uint64_t)(a3 & 0xFFFFFFFFFFFFLL) >= v5)
        {
LABEL_5:
          v8 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v4, v5, (uint64_t)v6, v7);
          return specialized static String._uncheckedFromUTF8(_:)(v8, v9);
        }
      }
      else
      {
        v6 = _StringObject.sharedUTF8.getter(a3, a4);
        v7 = v13;
        if (v13 >= v5)
          goto LABEL_5;
      }
LABEL_12:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    v14[0] = a3;
    v14[1] = a4 & 0xFFFFFFFFFFFFFFLL;
    if ((HIBYTE(a4) & 0xF) < (unint64_t)v5)
      goto LABEL_12;
    if ((uint64_t)(v5 - v4) < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    return specialized static String._uncheckedFromUTF8(_:)((uint8x16_t *)((char *)v14 + v4), v5 - v4);
  }
}

uint64_t specialized static String._copying(_:)(unint64_t a1, unint64_t a2)
{
  Swift::UInt64 v2;
  uint64_t v3;
  Swift::UInt64 v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  Swift::String::Index v9;
  Swift::String::Index v10;
  uint64_t v11;

  v2 = specialized Collection.subscript.getter(a1, a2);
  v4 = v3;
  v6 = v5;
  v8 = (unint64_t)v7;
  swift_bridgeObjectRetain((unint64_t)v7, v3, v5, v7);
  v9._rawBits = v2;
  v10._rawBits = v4;
  v11 = specialized static String._copying(_:)(v9, v10, v6, v8);
  swift_bridgeObjectRelease(v8);
  return v11;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, unint64_t *a2)
{
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  v4 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(_QWORD *)(v4 + 16) = v5;
  *(_QWORD *)(v4 + 24) = 0x3000000000000000;
  if (v5 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v6 = *(_QWORD *)(v4 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = 0;
  }
  *(_BYTE *)(v4 + 32 + v6) = 0;
  if (a1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  v7 = _StringGuts._foreignCopyUTF8(into:)(v4 + 32, a1, *a2, a2[1]);
  if ((v8 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000029, 0x80000001817670E0, "Swift/StringGutsRangeReplaceable.swift", 38, 2, 0x91uLL, 0);
  *(_QWORD *)(v4 + 24) = v7 | 0x3000000000000000;
  *(_BYTE *)(v4 + 32 + (v7 & 0xFFFFFFFFFFFFLL)) = 0;
  return v4;
}

uint64_t specialized Slice.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v3 = a3 - a1;
  if (__OFSUB__(a3, a1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x62DuLL, 0);
  if (a2 < 1)
  {
    if (v3 > 0 || v3 <= a2)
      goto LABEL_9;
    return 0;
  }
  if ((v3 & 0x8000000000000000) == 0 && v3 < (unint64_t)a2)
    return 0;
LABEL_9:
  v5 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v5)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x635uLL, 0);
  return result;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, unint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  Swift::Int v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  Swift::Int v59;
  uint64_t v60;
  char v61;
  char *v62;
  uint64_t v63;
  unsigned __int8 *v64;
  unsigned __int8 *i;
  unsigned int v66;
  unsigned int v67;
  unsigned __int8 *v68;
  unsigned int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  size_t v77;
  uint64_t v78;

  v4 = (_QWORD *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2);
  if (v3)
    return v2;
  v5 = v4;
  v6 = v4[3];
  v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0)
    goto LABEL_20;
  v8 = (char *)(v4 + 4);
  v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080) != 0)
      goto LABEL_22;
    v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0) + 32)
    {
      v10 = *(_QWORD *)v9;
      v11 = *((_QWORD *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080) != 0)
        goto LABEL_22;
    }
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8])
  {
    if ((*(_QWORD *)v9 & 0x8080808080808080) != 0)
      goto LABEL_22;
    v9 += 8;
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0)
      goto LABEL_22;
    v9 += 4;
  }
  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }
LABEL_22:
  v13 = 0;
  v14 = &v8[v7];
  v12 = 1;
  v15 = (unsigned __int8 *)(v4 + 4);
  v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    v18 = (char)*v16++;
    v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      v19 = 1;
      goto LABEL_25;
    }
    if ((v17 + 11) <= 0xCCu)
      goto LABEL_68;
    if (v17 < 0xE0u)
    {
      if (v16 == (unsigned __int8 *)v14 || (*v16 & 0xC0) != 0x80)
        goto LABEL_68;
      v12 = 0;
      v16 = v15 + 2;
      v19 = 2;
      goto LABEL_25;
    }
    if (v17 == 224)
      break;
    if (v17 <= 0xECu)
      goto LABEL_50;
    if (v17 == 237)
    {
      if (v16 == (unsigned __int8 *)v14)
        goto LABEL_68;
      v22 = v15[1];
      if (v22 > 0x9F)
        goto LABEL_68;
LABEL_52:
      if ((v22 & 0xC0) != 0x80)
        goto LABEL_68;
      v20 = (char *)(v15 + 2);
      if (v15 + 2 == (unsigned __int8 *)v14)
        goto LABEL_68;
LABEL_54:
      if ((*v20 & 0xC0) != 0x80)
        goto LABEL_68;
      v12 = 0;
      v16 = v15 + 3;
      v19 = 3;
      goto LABEL_25;
    }
    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v16 == (unsigned __int8 *)v14)
        goto LABEL_68;
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }
    if (v17 == 240)
    {
      if (v16 == (unsigned __int8 *)v14 || (v15[1] + 64) < 0xD0u)
        goto LABEL_68;
    }
    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        if (v16 == (unsigned __int8 *)v14)
          goto LABEL_68;
        LOBYTE(v23) = v15[1];
      }
      else
      {
        if (v16 == (unsigned __int8 *)v14)
          goto LABEL_68;
        v23 = v15[1];
        if (v23 > 0x8F)
          goto LABEL_68;
      }
      if ((v23 & 0xC0) != 0x80)
        goto LABEL_68;
    }
    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    v12 = 0;
    v16 = v15 + 4;
    v19 = 4;
LABEL_25:
    v13 += v19;
    v15 = v16;
    if (v16 == (unsigned __int8 *)v14)
      goto LABEL_21;
  }
  if (v16 != (unsigned __int8 *)v14)
  {
    v20 = (char *)(v15 + 2);
    if ((v15[1] + 64) >= 0xE0u && v20 != v14)
      goto LABEL_54;
  }
LABEL_68:
  v24 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  v29 = v25;
  v30 = v26;
  v31 = v27;
  v32 = v28;
  v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    v33 = v29 + 1;
    if (__OFADD__(v29, 1))
    {
      v73 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v73, 0);
    }
  }
  v34 = 0;
  v35 = v30 + v29 - v33;
  if (v30 <= v33)
    v36 = v33;
  else
    v36 = v30;
  if (v32 <= v33)
    v37 = v33;
  else
    v37 = v32;
  v38 = v37 - v33;
  v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34)
      goto LABEL_87;
    if (v33 < v29)
    {
      v73 = 1812;
      goto LABEL_168;
    }
    if (v39 == v34)
    {
      v73 = 1813;
      goto LABEL_168;
    }
    if (v33 < 0)
    {
      v73 = 1781;
      goto LABEL_168;
    }
    if (v38 == v34)
    {
      v73 = 1782;
      goto LABEL_168;
    }
    if ((*(_BYTE *)(v31 + v33 + v34) & 0xC0) != 0x80)
      goto LABEL_86;
    v40 = v29 + v34++;
  }
  while (!__OFADD__(v40, 1));
  __break(1u);
LABEL_86:
  v35 = v29 + v34;
LABEL_87:
  if (v35 < v29)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  v41 = v35 + 1;
  if (__OFADD__(v35, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v30 < v41)
  {
LABEL_176:
    v73 = 1820;
    goto LABEL_168;
  }
  v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  v44 = v43;
  v74 = (uint64_t)v5;
  v75 = 0;
  v45 = v5[3];
  v76 = 0xE000000000000000;
  v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15)
      _StringGuts.grow(_:)(v46 + 15);
  }
  while (2)
  {
    if (v42 < 0)
      goto LABEL_169;
    v55 = v46;
    if (v46 < v42)
    {
      v73 = 1861;
      goto LABEL_168;
    }
    v56 = v76;
    v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000) != 0)
      v57 = HIBYTE(v76) & 0xF;
    v58 = v57 + v55;
    v59 = v58 + 3;
    if (__OFADD__(v58, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v59 >= 16)
    {
      v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        v56 = v76;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    v75 = *(_QWORD *)(v56 + 24);
    v77 = 3;
    v78 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44)
LABEL_169:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v44 < 0)
    {
LABEL_172:
      v73 = 1860;
      goto LABEL_168;
    }
    v46 = v55 - v44;
    if (v55 - v44 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }
    v63 = 0;
    v64 = (unsigned __int8 *)&v8[v55];
    if (!v8)
      v64 = 0;
    for (i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64)
          goto LABEL_161;
        v67 = *i++;
        v66 = v67;
        if ((v66 & 0x80) != 0)
          break;
        ++v63;
      }
      if ((v66 + 62) > 0x32u)
        goto LABEL_95;
      if (v66 > 0xDF)
        break;
      if (!i || i == v64 || (*i & 0xC0) != 0x80)
        goto LABEL_95;
      v63 += 2;
    }
    if (v66 == 224)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v68 = i + 1;
      if ((*i & 0xE0) != 0xA0)
        goto LABEL_95;
      goto LABEL_140;
    }
    if (v66 < 0xED)
      goto LABEL_136;
    if (v66 == 237)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v68 = i + 1;
      v69 = *i;
      if (v69 > 0x9F)
        goto LABEL_95;
      goto LABEL_139;
    }
    if (v66 < 0xF0)
    {
LABEL_136:
      if (!i || i == v64)
        goto LABEL_95;
      v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80)
        goto LABEL_95;
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80)
        goto LABEL_95;
      i += 2;
      v63 += 3;
      goto LABEL_113;
    }
    if (v66 == 240)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v70 = i + 1;
      if ((*i + 64) < 0xD0u)
        goto LABEL_95;
      goto LABEL_156;
    }
    if ((v66 + 15) < 3u)
    {
      if (!i || i == v64)
        goto LABEL_95;
      v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v64)
      {
        v70 = i + 1;
        v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80)
            goto LABEL_95;
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80)
            goto LABEL_95;
          i += 3;
          v63 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    v49 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    v44 = v54;
    v8 = v62;
    if (v46)
      continue;
    break;
  }
  v2 = v75;
  swift_release(v74);
  return v2;
}

uint64_t specialized static String._createEmpty(withInitialCapacity:)(Swift::Int a1)
{
  if (a1 < 16)
    return 0;
  _StringGuts.grow(_:)(a1);
  return 0;
}

uint64_t specialized String.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v5;

  v4 = a3;
  v5 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000) == 0)
    v5 = a3 & 0xFFFFFFFFFFFFLL;
  if (a1._rawBits >> 16 || a2._rawBits >> 16 != v5)
    return specialized static String._copying(_:)(a1, a2, a3, a4);
  swift_bridgeObjectRetain(a4, a2._rawBits, a3, (char *)a4);
  return v4;
}

unint64_t specialized _SmallString.init(_:appending:)(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v4 = HIBYTE(a2) & 0xF;
  v5 = HIBYTE(a4) & 0xF;
  if ((unint64_t)(v5 + v4) > 0xF)
    return 0;
  if (v5)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = v4 + v7;
      v9 = v7 + 1;
      if (v7 >= 8)
        v10 = a4;
      else
        v10 = a3;
      v11 = v10 >> (v6 & 0x38);
      v12 = (8 * v4 + v6) & 0x38;
      v13 = (-255 << v12) - 1;
      v14 = (unint64_t)v11 << v12;
      v15 = v14 | v13 & a2;
      v16 = v14 | v13 & result;
      if (v8 < 8)
        result = v16;
      else
        a2 = v15;
      v6 += 8;
      v7 = v9;
    }
    while (v5 != v9);
  }
  return result;
}

BOOL specialized static __CocoaSet.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a1 < 0)
    v7 = a1;
  else
    v7 = a1 & 0xFFFFFFFFFFFFFF8;
  v8 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8))
    goto LABEL_11;
  if (a3 >= 0)
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  if (!swift_dynamicCastClass(a3, v8))
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(_QWORD *)(v7 + 16) != *(_QWORD *)(a3 + 16))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different sets", 37, 2, "Swift/SetBridging.swift", 23, 2, 0x1FFuLL, 0);
  return a2 < a4;
}

BOOL specialized _StringGutsSlice._isScalarNFCQC(_:_:)(unsigned int a1, _BYTE *a2)
{
  unsigned int NormData;
  char v4;
  _BOOL4 v5;
  _BOOL8 result;

  if (a1 >= 0x300)
    NormData = _swift_stdlib_getNormData(a1);
  else
    NormData = 0;
  v4 = NormData >> 3;
  if (v4)
    v5 = *a2 <= (NormData >> 3);
  else
    v5 = 1;
  result = (NormData & 6) == 0 && v5;
  if (result)
    *a2 = v4;
  return result;
}

uint64_t specialized _ArrayBuffer._nonNative.getter(uint64_t result)
{
  if (result >= 0)
    return result & 0xFFFFFFFFFFFFFF8;
  return result;
}

uint64_t specialized static Hasher._hash(seed:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  v2 = unk_1ECD25520 ^ a2 ^ 0x7465646279746573;
  v3 = ((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1ECD25520 ^ 0x646F72616E646F6DLL)) ^ __ROR8__(unk_1ECD25520 ^ 0x646F72616E646F6DLL, 51);
  v4 = (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261) + v2;
  v5 = __ROR8__(v2, 48);
  v6 = __ROR8__((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1ECD25520 ^ 0x646F72616E646F6DLL), 32)+ (v4 ^ v5);
  v7 = v6 ^ __ROR8__(v4 ^ v5, 43);
  v8 = v3 + v4;
  v9 = __ROR8__(v8, 32);
  v10 = v8 ^ __ROR8__(v3, 47);
  v11 = (v6 ^ a2) + v10;
  v12 = __ROR8__(v11, 32);
  v13 = v11 ^ __ROR8__(v10, 51);
  v14 = (v7 ^ 0x800000000000000) + v9;
  *((_QWORD *)&v15 + 1) = v7;
  *(_QWORD *)&v15 = v7 ^ 0x800000000000000;
  v16 = (v15 >> 48) ^ v14;
  v17 = v16 + v12;
  v18 = (v16 + v12) ^ __ROR8__(v16, 43);
  v19 = v14 + v13;
  v20 = v19 ^ __ROR8__(v13, 47);
  v21 = (v17 ^ 0x800000000000000) + v20;
  v22 = v21 ^ __ROR8__(v20, 51);
  v23 = (__ROR8__(v19, 32) ^ 0xFFLL) + v18;
  *(_QWORD *)&v15 = __ROR8__(v18, 48);
  v24 = __ROR8__(v21, 32) + (v23 ^ v15);
  v25 = v24 ^ __ROR8__(v23 ^ v15, 43);
  v26 = v22 + v23;
  v27 = __ROR8__(v26, 32);
  v28 = v26 ^ __ROR8__(v22, 47);
  v29 = v24 + v28;
  v30 = (v24 + v28) ^ __ROR8__(v28, 51);
  v31 = v27 + v25;
  v32 = (v27 + v25) ^ __ROR8__(v25, 48);
  v33 = __ROR8__(v29, 32) + v32;
  v34 = v33 ^ __ROR8__(v32, 43);
  v35 = v30 + v31;
  v36 = v35 ^ __ROR8__(v30, 47);
  v37 = __ROR8__(v35, 32) + v34;
  v38 = (v33 + v36) ^ __ROR8__(v36, 51);
  return __ROR8__(v37 ^ __ROR8__(v34, 48), 43) ^ __ROR8__(v38 + v37, 32) ^ (v38 + v37) ^ __ROR8__(v38, 47);
}

uint64_t specialized static Hasher._hash(seed:bytes:count:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v3 = a2 | (a3 << 56);
  v4 = v3 ^ 0x7465646279746573 ^ unk_1ECD25520;
  v5 = ((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1ECD25520 ^ 0x646F72616E646F6DLL)) ^ __ROR8__(unk_1ECD25520 ^ 0x646F72616E646F6DLL, 51);
  v6 = (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261) + v4;
  v7 = __ROR8__(v4, 48);
  v8 = __ROR8__((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1ECD25520 ^ 0x646F72616E646F6DLL), 32)+ (v6 ^ v7);
  v9 = v8 ^ __ROR8__(v6 ^ v7, 43);
  v10 = v5 + v6;
  v11 = v10 ^ __ROR8__(v5, 47);
  v12 = (v8 ^ v3) + v11;
  v13 = v12 ^ __ROR8__(v11, 51);
  v14 = (__ROR8__(v10, 32) ^ 0xFFLL) + v9;
  v15 = __ROR8__(v9, 48);
  v16 = __ROR8__(v12, 32) + (v14 ^ v15);
  v17 = v16 ^ __ROR8__(v14 ^ v15, 43);
  v18 = v13 + v14;
  v19 = __ROR8__(v18, 32);
  v20 = v18 ^ __ROR8__(v13, 47);
  v21 = v16 + v20;
  v22 = v21 ^ __ROR8__(v20, 51);
  v23 = v19 + v17;
  v24 = (v19 + v17) ^ __ROR8__(v17, 48);
  v25 = __ROR8__(v21, 32) + v24;
  v26 = v25 ^ __ROR8__(v24, 43);
  v27 = v22 + v23;
  v28 = v27 ^ __ROR8__(v22, 47);
  v29 = __ROR8__(v27, 32) + v26;
  v30 = (v25 + v28) ^ __ROR8__(v28, 51);
  return __ROR8__(v29 ^ __ROR8__(v26, 48), 43) ^ __ROR8__(v30 + v29, 32) ^ (v30 + v29) ^ __ROR8__(v30, 47);
}

uint64_t specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (result < a4 || (uint64_t)(a5 >> 1) <= result)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/SliceBuffer.swift", 23, 2, 0x132uLL, 0);
  return result;
}

BOOL specialized static __CocoaDictionary.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a1 < 0)
    v7 = a1;
  else
    v7 = a1 & 0xFFFFFFFFFFFFFF8;
  v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8))
    goto LABEL_11;
  if (a3 >= 0)
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  if (!swift_dynamicCastClass(a3, v8))
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(_QWORD *)(v7 + 16) != *(_QWORD *)(a3 + 16))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x2AFuLL, 0);
  return a2 < a4;
}

uint64_t specialized AnyCollection.endIndex.getter(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t specialized AnyCollection.startIndex.getter(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

unint64_t specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (result >> 14 < a3 >> 14 || a4 >> 14 < a2 >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  return result;
}

uint64_t specialized KeyPathBuffer.init(base:)(uint64_t a1)
{
  if ((a1 & 3) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  return a1 + 8;
}

void specialized static KeyPathComponent.== infix(_:_:)(__int128 *a1)
{
  _QWORD v1[3];

  outlined init with take of KeyPathComponent(a1, (uint64_t)v1);
  __asm { BR              X10 }
}

BOOL sub_181599C60()
{
  __int128 *v0;
  uint64_t v1;
  uint64_t v2;
  _QWORD v5[24];

  v5[8] = v2 & 0x1FFFFFFFFFFFFFFFLL;
  outlined init with take of KeyPathComponent(v0, (uint64_t)v5);
  return !(v5[1] >> 61) && v1 == v5[0];
}

uint64_t specialized static AnyKeyPath.== infix(_:_:)(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t result;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t *v26;
  unsigned int *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45[3];
  uint64_t v46[8];

  if (a1 == a2)
    return 1;
  if (*a1 != *a2)
    return 0;
  v3 = specialized KeyPathBuffer.init(base:)((uint64_t)(a1 + 3));
  v5 = v4;
  v7 = v6;
  v43 = v3;
  v44 = v4;
  v8 = specialized KeyPathBuffer.init(base:)((uint64_t)(a2 + 3));
  v41 = v8;
  v42 = v9;
  if (((v7 ^ v10) & 0x100) != 0)
    return 0;
  if (v3 && v5 != v3)
  {
    while (1)
    {
      v13 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v43, 1);
      if (!v13)
        goto LABEL_82;
      v14 = *v13;
      v15 = v43;
      v16 = BYTE3(v14) & 0x7F;
      if (v16 == 1)
        goto LABEL_19;
      if (v16 != 2)
        break;
      v17 = 28;
      if ((v14 & 0x400000) == 0)
        v17 = 20;
      if ((v14 & 0x80000) != 0)
      {
        if (!v43)
          goto LABEL_82;
        v20 = 24;
        if ((v14 & 0x400000) == 0)
          v20 = 16;
        v21 = v43 + v20 + 4;
        if ((v21 & 7) != 0)
          goto LABEL_77;
        v22 = v17 + 16;
        v23 = *(_QWORD *)v21;
        v24 = __OFADD__(v22, v23);
        v17 = v22 + v23;
        if (v24)
        {
          __break(1u);
LABEL_79:
          __break(1u);
LABEL_80:
          __break(1u);
LABEL_81:
          __break(1u);
LABEL_82:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
        }
        if ((v14 & 0x10) != 0)
        {
          v24 = __OFADD__(v17, 8);
          v17 += 8;
          if (v24)
            goto LABEL_80;
        }
        if (v17 < 0)
          goto LABEL_76;
        goto LABEL_36;
      }
LABEL_26:
      if (!v43)
        goto LABEL_83;
LABEL_36:
      v19 = v43 + v17;
      v18 = v17;
LABEL_37:
      specialized _pop<A>(from:as:count:)(&v43, v18);
      if (v43 && v44 != v43)
      {
        v26 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v43, 1);
        if (!v26)
          goto LABEL_82;
        v25 = *v26;
      }
      else
      {
        v25 = 0;
      }
      v27 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v41, 1);
      if (!v27)
        goto LABEL_82;
      v28 = *v27;
      v29 = v41;
      v30 = BYTE3(v28) & 0x7F;
      if (v30 == 1 || v30 == 3)
      {
        if ((~(_DWORD)v28 & 0x7FFFFF) == 0)
        {
          v31 = 4;
LABEL_60:
          if (!v41)
LABEL_83:
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
LABEL_63:
          v36 = v41 + v31;
          v37 = v31;
          goto LABEL_64;
        }
      }
      else if (v30 == 2)
      {
        v31 = 28;
        if ((v28 & 0x400000) == 0)
          v31 = 20;
        if ((v28 & 0x80000) == 0)
          goto LABEL_60;
        if (!v41)
          goto LABEL_82;
        v32 = 24;
        if ((v28 & 0x400000) == 0)
          v32 = 16;
        v33 = v41 + v32 + 4;
        if ((v33 & 7) != 0)
LABEL_77:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
        v34 = v31 + 16;
        v35 = *(_QWORD *)v33;
        v24 = __OFADD__(v34, v35);
        v31 = v34 + v35;
        if (v24)
          goto LABEL_79;
        if ((v28 & 0x10) != 0)
        {
          v24 = __OFADD__(v31, 8);
          v31 += 8;
          if (v24)
            goto LABEL_81;
        }
        if (v31 < 0)
LABEL_76:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
        goto LABEL_63;
      }
      v31 = 0;
      v36 = 0;
      v37 = 0;
      if (v41)
        goto LABEL_63;
LABEL_64:
      specialized _pop<A>(from:as:count:)(&v41, v37);
      if (v41 && v42 != v41)
      {
        v39 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v41, 1);
        if (!v39)
          goto LABEL_82;
        v38 = *v39;
        if (((v28 ^ v14) & 0x80000000) != 0)
          return 0;
      }
      else
      {
        v38 = 0;
        if (((v28 ^ v14) & 0x80000000) != 0)
          return 0;
      }
      RawKeyPathComponent.value.getter(v14, v15, v19, (uint64_t *)v45);
      RawKeyPathComponent.value.getter(v28, v29, v36, v46);
      specialized static KeyPathComponent.== infix(_:_:)(v45);
      if ((v40 & 1) == 0)
        return 0;
      if (!v25)
        return v38 == 0;
      result = 0;
      if (!v38 || v25 != v38)
        return result;
    }
    if (v16 != 3)
      goto LABEL_21;
LABEL_19:
    if ((~(_DWORD)v14 & 0x7FFFFF) != 0)
    {
LABEL_21:
      v17 = 0;
      v18 = 0;
      v19 = 0;
      if (!v43)
        goto LABEL_37;
      goto LABEL_36;
    }
    v17 = 4;
    goto LABEL_26;
  }
  return !v8 || v9 == v8;
}

BOOL specialized static __CocoaSet.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a1 < 0)
    v7 = a1;
  else
    v7 = a1 & 0xFFFFFFFFFFFFFF8;
  v8 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8))
    goto LABEL_11;
  if (a3 >= 0)
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  if (!swift_dynamicCastClass(a3, v8))
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(_QWORD *)(v7 + 16) != *(_QWORD *)(a3 + 16))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different sets", 37, 2, "Swift/SetBridging.swift", 23, 2, 0x1F5uLL, 0);
  return a2 == a4;
}

BOOL specialized _StringGuts.checkIfInEmojiSequence(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  int32x4_t v12;
  int GraphemeBreakProperty;

  closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v6 & 1) == 0)
  {
    v7 = v5;
    while (1)
    {
      v8 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v7, a2, a3);
      if ((v10 & 1) != 0 || v8 < 0x20)
        break;
      v11 = 0;
      v12 = vdupq_n_s32(v8);
      if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v12, (int32x4_t)xmmword_1816ABF70), (uint32x4_t)xmmword_1816ABF90), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v12, (int32x4_t)xmmword_1816ABF80), (uint32x4_t)xmmword_1816ABFA0)))) & 1) != 0|| v8 < 0x7F|| v8 == 8205)
      {
        return v11;
      }
      if (v8 - 131070 > 0xFFFFFC01)
        return 1;
      if (v8 - 921600 > 0xFFFFF1EF)
        return 0;
      v7 = v9;
      GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v8);
      if (GraphemeBreakProperty != 1)
        return (GraphemeBreakProperty - 4) <= 1;
    }
  }
  return 0;
}

uint64_t specialized _StringGuts.checkIfInIndicSequence(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  char v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  char v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int GraphemeBreakProperty;
  uint64_t v18;
  char v19;
  char v20;
  unsigned int v21;
  unint64_t v22;
  BOOL v23;
  unsigned int v24;
  unint64_t v25;

  v5 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v7 & 1) == 0)
  {
    v8 = v5;
    v9 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v6, a2, a3);
    if ((v11 & 1) == 0)
    {
      v12 = v9;
      v13 = v10;
      HIDWORD(v14) = v8 - 2381;
      LODWORD(v14) = v8 - 2381;
      v15 = ((v14 >> 7) < 9) & (0x15Bu >> (v14 >> 7));
      while (1)
      {
        if (v12 < 0x20)
        {
LABEL_20:
          LOBYTE(v16) = 1;
          goto LABEL_22;
        }
        if (v12 < 0x7F)
          goto LABEL_21;
        if (v12 == 8205)
        {
          LOBYTE(v16) = 12;
          goto LABEL_22;
        }
        LOBYTE(v16) = 4;
        if (v12 - 4448 <= 0xFFFFFF9F && v12 - 43389 < 0xFFFFFFE3)
        {
          LOBYTE(v16) = 11;
          if (v12 - 4520 <= 0xFFFFFFB7 && v12 - 55239 <= 0xFFFFFFE8)
          {
            LOBYTE(v16) = 10;
            if (v12 - 4608 <= 0xFFFFFFA7 && v12 - 55292 <= 0xFFFFFFCE)
            {
              if (v12 - 55204 > 0xFFFFD45B)
              {
                HIDWORD(v25) = -1227133513 * ((unsigned __int16)v12 - 16);
                LODWORD(v25) = HIDWORD(v25);
                if ((v25 >> 2) < 0x9249249)
                  LOBYTE(v16) = 5;
                else
                  LOBYTE(v16) = 6;
              }
              else if (v12 - 127488 > 0xFFFFFFE5)
              {
                LOBYTE(v16) = 8;
              }
              else
              {
                if (v12 - 131070 <= 0xFFFFFC01)
                {
                  if (v12 - 921600 > 0xFFFFF1EF)
                    goto LABEL_20;
                  GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v12);
                  if (GraphemeBreakProperty < 6)
                  {
                    v16 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                    goto LABEL_22;
                  }
LABEL_21:
                  LOBYTE(v16) = 0;
                  goto LABEL_22;
                }
                LOBYTE(v16) = 3;
              }
            }
          }
        }
LABEL_22:
        if (_swift_stdlib_isLinkingConsonant(v12))
        {
          v19 = v15;
          return v19 & 1;
        }
        if (v16 == 2)
        {
          if (v12 < 0x300)
            break;
          v19 = _swift_stdlib_getNormData(v12) >> 3;
          if (!v19)
            return v19 & 1;
          HIDWORD(v22) = v12 - 2381;
          LODWORD(v22) = v12 - 2381;
          v21 = v22 >> 7;
          v23 = v21 > 8;
          v24 = (0x15Bu >> v21) | v15;
          if (!v23)
            v15 = v24;
        }
        else if (v16 != 12)
        {
          break;
        }
        v12 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v13, a2, a3);
        v13 = v18;
        v19 = 0;
        if ((v20 & 1) != 0)
          return v19 & 1;
      }
    }
  }
  v19 = 0;
  return v19 & 1;
}

{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int GraphemeBreakProperty;
  char v17;
  unsigned int v18;
  unint64_t v19;
  BOOL v20;
  unsigned int v21;
  unint64_t v22;

  if (a2 >= a1)
    return 0;
  v5 = a1;
  v6 = a3 - 1;
  do
    v7 = *(_BYTE *)(v6 + v5--) & 0xC0;
  while (v7 == 128);
  v8 = _decodeScalar(_:startingAt:)(a3, a2, v5);
  if (v5 <= a2)
  {
LABEL_40:
    v17 = 0;
    return v17 & 1;
  }
  HIDWORD(v10) = v8 - 2381;
  LODWORD(v10) = v8 - 2381;
  v11 = ((v10 >> 7) < 9) & (0x15Bu >> (v10 >> 7));
  while (1)
  {
    do
      v12 = *(_BYTE *)(v6 + v5--) & 0xC0;
    while (v12 == 128);
    v13 = _decodeScalar(_:startingAt:)(a3, v9, v5);
    v14 = v13;
    if (v13 < 0x20)
    {
LABEL_23:
      LOBYTE(v15) = 1;
      goto LABEL_25;
    }
    if (v13 < 0x7F)
      goto LABEL_24;
    if (v13 == 8205)
    {
      LOBYTE(v15) = 12;
      goto LABEL_25;
    }
    LOBYTE(v15) = 4;
    if (v13 - 4448 <= 0xFFFFFF9F && v13 - 43389 < 0xFFFFFFE3)
    {
      LOBYTE(v15) = 11;
      if (v13 - 4520 <= 0xFFFFFFB7 && v13 - 55239 <= 0xFFFFFFE8)
      {
        LOBYTE(v15) = 10;
        if (v13 - 4608 <= 0xFFFFFFA7 && v13 - 55292 <= 0xFFFFFFCE)
        {
          if (v13 - 55204 > 0xFFFFD45B)
          {
            HIDWORD(v22) = -1227133513 * ((unsigned __int16)v13 - 16);
            LODWORD(v22) = HIDWORD(v22);
            if ((v22 >> 2) < 0x9249249)
              LOBYTE(v15) = 5;
            else
              LOBYTE(v15) = 6;
          }
          else if (v13 - 127488 > 0xFFFFFFE5)
          {
            LOBYTE(v15) = 8;
          }
          else
          {
            if (v13 - 131070 <= 0xFFFFFC01)
            {
              if (v13 - 921600 > 0xFFFFF1EF)
                goto LABEL_23;
              GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v13);
              if (GraphemeBreakProperty < 6)
              {
                v15 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                goto LABEL_25;
              }
LABEL_24:
              LOBYTE(v15) = 0;
              goto LABEL_25;
            }
            LOBYTE(v15) = 3;
          }
        }
      }
    }
LABEL_25:
    if (_swift_stdlib_isLinkingConsonant(v14))
      break;
    if (v15 == 2)
    {
      if (v14 < 0x300)
        goto LABEL_40;
      v17 = _swift_stdlib_getNormData(v14) >> 3;
      if (!v17)
        return v17 & 1;
      HIDWORD(v19) = v14 - 2381;
      LODWORD(v19) = v14 - 2381;
      v18 = v19 >> 7;
      v20 = v18 > 8;
      v21 = (0x15Bu >> v18) | v11;
      if (!v20)
        v11 = v21;
    }
    else if (v15 != 12)
    {
      goto LABEL_40;
    }
    v17 = 0;
    if (v5 <= a2)
      return v17 & 1;
  }
  v17 = v11;
  return v17 & 1;
}

uint64_t specialized _StringGuts.countRIs(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char v6;
  uint64_t i;
  unsigned int v8;
  char v9;

  closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v6 & 1) != 0)
    return 0;
  for (i = 0; ; ++i)
  {
    v8 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v5, a2, a3);
    if ((v9 & 1) != 0
      || v8 < 0x20
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)vaddq_s32(vdupq_n_s32(v8), (int32x4_t)xmmword_1816ABF70), (uint32x4_t)xmmword_1816ABF90))) & 1) != 0|| v8 - 4608 > 0xFFFFFFA7|| v8 - 55292 > 0xFFFFFFCE|| v8 - 55204 > 0xFFFFD45B|| v8 < 0x7F|| v8 == 8205)
    {
      break;
    }
    if (v8 - 127488 <= 0xFFFFFFE5)
    {
      if (v8 - 131070 <= 0xFFFFFC01 && v8 - 921600 <= 0xFFFFF1EF)
        _swift_stdlib_getGraphemeBreakProperty(v8);
      return i & 1;
    }
    if (__OFADD__(i, 1))
    {
      __break(1u);
      return 0;
    }
  }
  return i & 1;
}

uint64_t specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(unsigned int a1, unsigned int a2, uint64_t a3, char *a4, unint64_t a5)
{
  int32x4_t v10;
  int32x4_t v11;
  char v12;
  char v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  BOOL isLinkingConsonant;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char v23;
  char v24;
  char v25;

  if (a1 == 13 && a2 == 10)
  {
LABEL_15:
    v12 = 0;
    return v12 & 1;
  }
  v10 = vdupq_n_s32(a1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1816ABE80), (uint32x4_t)xmmword_1816ABEA0), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1816ABE90), (uint32x4_t)xmmword_1816ABEB0)))) & 1) != 0|| a1 - 65438 > 0xFFFFFF62|| a1 < 0x300)
  {
    v11 = vdupq_n_s32(a2);
    v12 = 1;
    if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1816ABE80), (uint32x4_t)xmmword_1816ABEA0), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1816ABE90), (uint32x4_t)xmmword_1816ABEB0)))) & 1) != 0|| a2 - 65438 > 0xFFFFFF62|| a2 <= 0x2FF)
    {
      return v12 & 1;
    }
  }
  swift_bridgeObjectRetain_n(a5, 4, a3, a4);
  v13 = Unicode._GraphemeBreakProperty.init(from:)(a1);
  v14 = Unicode._GraphemeBreakProperty.init(from:)(a2);
  if (v13 == 1)
  {
LABEL_32:
    swift_bridgeObjectRelease_n(a5, 4);
    v12 = 1;
    return v12 & 1;
  }
  if (!v13)
  {
    switch(v14)
    {
      case 0:
      case 1:
        goto LABEL_32;
      case 2:
      case 9:
      case 12:
        goto LABEL_14;
      default:
        goto LABEL_12;
    }
  }
  switch(v14)
  {
    case 1:
      goto LABEL_32;
    case 2:
    case 9:
    case 12:
      goto LABEL_14;
    case 4:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 5:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 6:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 10:
      switch(v13)
      {
        case 5:
        case 6:
        case 7:
        case 10:
        case 11:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 11:
      switch(v13)
      {
        case 4:
        case 5:
        case 7:
        case 11:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    default:
      if (v13 == 12)
      {
        if (v14 == 3)
        {
          swift_bridgeObjectRetain(a5, v15, v16, v17);
          v23 = specialized _StringGuts.checkIfInEmojiSequence(at:with:)(a3, (uint64_t)a4, a5);
LABEL_38:
          v24 = v23;
          swift_bridgeObjectRelease_n(a5, 5);
          v12 = v24 ^ 1;
          return v12 & 1;
        }
LABEL_36:
        if (!_swift_stdlib_isLinkingConsonant(a2))
          goto LABEL_32;
LABEL_37:
        swift_bridgeObjectRetain(a5, v19, v20, v21);
        v23 = specialized _StringGuts.checkIfInIndicSequence(at:with:)(a3, (uint64_t)a4, a5);
        goto LABEL_38;
      }
      if (v13 != 8)
      {
        if (v13 == 7)
        {
LABEL_14:
          swift_bridgeObjectRelease_n(a5, 4);
          goto LABEL_15;
        }
LABEL_25:
        isLinkingConsonant = _swift_stdlib_isLinkingConsonant(a2);
        if (v13 == 12)
        {
          if (!isLinkingConsonant)
            goto LABEL_32;
        }
        else if (v13 != 2
               || !isLinkingConsonant
               || a1 < 0x300
               || !(_swift_stdlib_getNormData(a1) >> 3))
        {
          goto LABEL_32;
        }
        goto LABEL_37;
      }
      if (v14 != 8)
      {
LABEL_12:
        _swift_stdlib_isLinkingConsonant(a2);
        goto LABEL_32;
      }
      swift_bridgeObjectRetain(a5, v15, v16, v17);
      v25 = specialized _StringGuts.countRIs(at:with:)(a3, (uint64_t)a4, a5);
      swift_bridgeObjectRelease_n(a5, 5);
      return v25 & 1;
  }
}

BOOL specialized _StringGuts.checkIfInEmojiSequence(at:with:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  _BOOL8 result;
  int32x4_t v11;
  int GraphemeBreakProperty;

  if (a1 < 1)
    return 0;
  v3 = a1;
  v4 = a2 - 1;
  do
    v5 = *(_BYTE *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  _decodeScalar(_:startingAt:)(a2, a2, v3);
  while (v3 >= 1)
  {
    do
      v7 = *(_BYTE *)(v4 + v3--) & 0xC0;
    while (v7 == 128);
    v8 = _decodeScalar(_:startingAt:)(a2, v6, v3);
    if (v8 < 0x20)
      break;
    v9 = v8;
    result = 0;
    v11 = vdupq_n_s32(v9);
    if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1816ABF70), (uint32x4_t)xmmword_1816ABF90), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1816ABF80), (uint32x4_t)xmmword_1816ABFA0)))) & 1) != 0|| v9 < 0x7F|| v9 == 8205)
    {
      return result;
    }
    if (v9 - 131070 > 0xFFFFFC01)
      return 1;
    if (v9 - 921600 > 0xFFFFF1EF)
      return 0;
    GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v9);
    if (GraphemeBreakProperty != 1)
      return (GraphemeBreakProperty - 4) <= 1;
  }
  return 0;
}

uint64_t specialized _StringGuts.checkIfInIndicSequence(at:with:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  unsigned int GraphemeBreakProperty;
  char v15;
  unsigned int v16;
  unint64_t v17;
  BOOL v18;
  unsigned int v19;
  unint64_t v20;

  if (a1 < 1)
    return 0;
  v3 = a1;
  v4 = a2 - 1;
  do
    v5 = *(_BYTE *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  v6 = _decodeScalar(_:startingAt:)(a2, a2, v3);
  if (v3 < 1)
  {
LABEL_39:
    v15 = 0;
    return v15 & 1;
  }
  HIDWORD(v8) = v6 - 2381;
  LODWORD(v8) = v6 - 2381;
  v9 = ((v8 >> 7) < 9) & (0x15Bu >> (v8 >> 7));
  while (1)
  {
    do
      v10 = *(_BYTE *)(v4 + v3--) & 0xC0;
    while (v10 == 128);
    v11 = _decodeScalar(_:startingAt:)(a2, v7, v3);
    v12 = v11;
    if (v11 < 0x20)
    {
LABEL_23:
      LOBYTE(v13) = 1;
      goto LABEL_25;
    }
    if (v11 < 0x7F)
      goto LABEL_24;
    if (v11 == 8205)
    {
      LOBYTE(v13) = 12;
      goto LABEL_25;
    }
    LOBYTE(v13) = 4;
    if (v11 - 4448 <= 0xFFFFFF9F && v11 - 43389 < 0xFFFFFFE3)
    {
      LOBYTE(v13) = 11;
      if (v11 - 4520 <= 0xFFFFFFB7 && v11 - 55239 <= 0xFFFFFFE8)
      {
        LOBYTE(v13) = 10;
        if (v11 - 4608 <= 0xFFFFFFA7 && v11 - 55292 <= 0xFFFFFFCE)
        {
          if (v11 - 55204 > 0xFFFFD45B)
          {
            HIDWORD(v20) = -1227133513 * ((unsigned __int16)v11 - 16);
            LODWORD(v20) = HIDWORD(v20);
            if ((v20 >> 2) < 0x9249249)
              LOBYTE(v13) = 5;
            else
              LOBYTE(v13) = 6;
          }
          else if (v11 - 127488 > 0xFFFFFFE5)
          {
            LOBYTE(v13) = 8;
          }
          else
          {
            if (v11 - 131070 <= 0xFFFFFC01)
            {
              if (v11 - 921600 > 0xFFFFF1EF)
                goto LABEL_23;
              GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v11);
              if (GraphemeBreakProperty < 6)
              {
                v13 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                goto LABEL_25;
              }
LABEL_24:
              LOBYTE(v13) = 0;
              goto LABEL_25;
            }
            LOBYTE(v13) = 3;
          }
        }
      }
    }
LABEL_25:
    if (_swift_stdlib_isLinkingConsonant(v12))
      break;
    if (v13 == 2)
    {
      if (v12 < 0x300)
        goto LABEL_39;
      v15 = _swift_stdlib_getNormData(v12) >> 3;
      if (!v15)
        return v15 & 1;
      HIDWORD(v17) = v12 - 2381;
      LODWORD(v17) = v12 - 2381;
      v16 = v17 >> 7;
      v18 = v16 > 8;
      v19 = (0x15Bu >> v16) | v9;
      if (!v18)
        v9 = v19;
    }
    else if (v13 != 12)
    {
      goto LABEL_39;
    }
    v15 = 0;
    if (v3 <= 0)
      return v15 & 1;
  }
  v15 = v9;
  return v15 & 1;
}

uint64_t specialized _StringGuts.countRIs(at:with:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t i;
  int v8;
  unsigned int v9;

  if (a1 < 1)
    return 0;
  v3 = a1;
  v4 = a2 - 1;
  do
    v5 = *(_BYTE *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  _decodeScalar(_:startingAt:)(a2, a2, v3);
  for (i = 0; v3 >= 1; ++i)
  {
    do
      v8 = *(_BYTE *)(v4 + v3--) & 0xC0;
    while (v8 == 128);
    v9 = _decodeScalar(_:startingAt:)(a2, v6, v3);
    if (v9 < 0x20
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)vaddq_s32(vdupq_n_s32(v9), (int32x4_t)xmmword_1816ABF70), (uint32x4_t)xmmword_1816ABF90))) & 1) != 0|| v9 - 4608 > 0xFFFFFFA7|| v9 - 55292 > 0xFFFFFFCE|| v9 - 55204 > 0xFFFFD45B|| v9 < 0x7F|| v9 == 8205)
    {
      break;
    }
    if (v9 - 127488 <= 0xFFFFFFE5)
    {
      if (v9 - 131070 <= 0xFFFFFC01 && v9 - 921600 <= 0xFFFFF1EF)
        _swift_stdlib_getGraphemeBreakProperty(v9);
      return i & 1;
    }
    if (__OFADD__(i, 1))
    {
      __break(1u);
      return 0;
    }
  }
  return i & 1;
}

uint64_t specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8;
  int32x4_t v10;
  int32x4_t v11;
  unsigned __int8 v12;
  char v13;
  int v14;
  BOOL isLinkingConsonant;
  BOOL v16;

  if (a1 == 13 && a2 == 10)
  {
LABEL_3:
    LOBYTE(v8) = 0;
    return v8 & 1;
  }
  v10 = vdupq_n_s32(a1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1816ABDC0), (uint32x4_t)xmmword_1816ABDD0), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_1816ABE90), (uint32x4_t)xmmword_1816ABEB0)))) & 1) != 0|| a1 - 65438 > 0xFFFFFF62|| a1 < 0x300)
  {
    v11 = vdupq_n_s32(a2);
    LOBYTE(v8) = 1;
    if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1816ABE80), (uint32x4_t)xmmword_1816ABEA0), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_1816ABE90), (uint32x4_t)xmmword_1816ABEB0)))) & 1) != 0|| a2 - 65438 > 0xFFFFFF62|| a2 <= 0x2FF)
    {
      return v8 & 1;
    }
  }
  v12 = Unicode._GraphemeBreakProperty.init(from:)(a1);
  v13 = Unicode._GraphemeBreakProperty.init(from:)(a2);
  LOBYTE(v8) = v12;
  if (v12 == 1)
    return v8 & 1;
  if (!v12)
  {
    if (((0x1207u >> v13) & 1) != 0)
    {
      v8 = (0xDFBu >> v13) & 1;
      return v8 & 1;
    }
LABEL_14:
    _swift_stdlib_isLinkingConsonant(a2);
LABEL_15:
    LOBYTE(v8) = 1;
    return v8 & 1;
  }
  LOBYTE(v8) = 1;
  switch(v13)
  {
    case 1:
      return v8 & 1;
    case 2:
    case 9:
    case 12:
      goto LABEL_3;
    case 4:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }
      return v8 & 1;
    case 5:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }
      return v8 & 1;
    case 6:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }
      return v8 & 1;
    case 10:
      v14 = v12;
      if (v12 > 0xCu)
        goto LABEL_35;
      if (((1 << v12) & 0xCE0) == 0)
        goto LABEL_31;
      goto LABEL_3;
    case 11:
      v14 = v12;
      if (v12 > 0xCu)
        goto LABEL_35;
      if (((1 << v12) & 0x8B0) != 0)
        goto LABEL_3;
LABEL_31:
      if (v14 == 8)
        goto LABEL_14;
      if (v14 == 12)
        goto LABEL_33;
      goto LABEL_35;
    default:
      if (v12 == 7)
        goto LABEL_3;
      if (v12 != 8)
      {
        if (v12 == 12)
        {
          if (v13 == 3)
          {
            LOBYTE(v8) = !specialized _StringGuts.checkIfInEmojiSequence(at:with:)(a3, a4);
            return v8 & 1;
          }
LABEL_33:
          if (!_swift_stdlib_isLinkingConsonant(a2))
            goto LABEL_15;
        }
        else
        {
LABEL_35:
          isLinkingConsonant = _swift_stdlib_isLinkingConsonant(a2);
          if (v12 == 12)
          {
            if (!isLinkingConsonant)
              goto LABEL_15;
          }
          else
          {
            if (v12 != 2)
              goto LABEL_15;
            v16 = a1 > 0x2FF && isLinkingConsonant;
            if (!v16 || !(_swift_stdlib_getNormData(a1) >> 3))
              goto LABEL_15;
          }
        }
        LOBYTE(v8) = specialized _StringGuts.checkIfInIndicSequence(at:with:)(a3, a4) ^ 1;
        return v8 & 1;
      }
      if (v13 != 8)
        goto LABEL_14;
      return specialized _StringGuts.countRIs(at:with:)(a3, a4);
  }
}

BOOL specialized static __CocoaDictionary.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a1 < 0)
    v7 = a1;
  else
    v7 = a1 & 0xFFFFFFFFFFFFFF8;
  v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8))
    goto LABEL_11;
  if (a3 >= 0)
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  if (!swift_dynamicCastClass(a3, v8))
LABEL_11:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(_QWORD *)(v7 + 16) != *(_QWORD *)(a3 + 16))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x2A2uLL, 0);
  return a2 == a4;
}

BOOL specialized static Unicode._CharacterRecognizer.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return ((*(_DWORD *)a1 != *(_DWORD *)a2) | ((*(_BYTE *)(a1 + 4) ^ *(_BYTE *)(a2 + 4)) | (*(_BYTE *)(a1 + 5) ^ *(_BYTE *)(a2 + 5))) & 1 | ((*(_BYTE *)(a1 + 6) ^ *(_BYTE *)(a2 + 6)) | (*(_BYTE *)(a2 + 7) ^ *(_BYTE *)(a1 + 7))) & 1) == 0;
}

uint64_t specialized closure #1 in _StringGuts._foreignOpaqueCharacterStride(endingAt:in:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  Swift::String::Index v7;
  id v8;
  uint64_t v9;
  Swift::UInt64 v10;
  int v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  int v16;
  Swift::String::Index v17;
  Swift::String::Index v18;
  _QWORD *v19;
  Swift::UInt64 rawBits;
  Swift::String::Index v21;
  Swift::UInt64 v22;
  uint64_t v23;
  Swift::UInt64 v24;
  uint64_t v25;
  uint64_t v26;

  if (a2 >= a1)
    return 0;
  v7._rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  if (!(v7._rawBits >> 14))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  if ((a4 & 0x1000000000000000) != 0)
  {
    rawBits = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
    v21._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)rawBits)._rawBits;
    LODWORD(result) = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v21._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
  }
  else
  {
    if ((a4 & 0x2000000000000000) != 0)
    {
      v25 = a3;
      v26 = a4 & 0xFFFFFFFFFFFFFFLL;
      v13 = (char *)&v25 + (v7._rawBits >> 16);
      if ((*(v13 - 1) & 0xC0) == 0x80)
      {
        v14 = 0;
        v15 = v13 - 2;
        do
          v16 = v15[v14--] & 0xC0;
        while (v16 == 128);
        v12 = 1 - v14;
      }
      else
      {
        v12 = 1;
      }
    }
    else
    {
      if ((a3 & 0x1000000000000000) != 0)
      {
        v8 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        v22 = v7._rawBits;
        v8 = _StringObject.sharedUTF8.getter(a3, a4);
        v7._rawBits = v22;
      }
      v9 = 0;
      v10 = (Swift::UInt64)v8 + (v7._rawBits >> 16) - 1;
      do
        v11 = *(_BYTE *)(v10 + v9--) & 0xC0;
      while (v11 == 128);
      v12 = -v9;
    }
    v18._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)((v7._rawBits - (v12 << 16)) & 0xFFFFFFFFFFFF0000 | 5))._rawBits >> 16;
    if ((a4 & 0x2000000000000000) != 0)
    {
      v25 = a3;
      v26 = a4 & 0xFFFFFFFFFFFFFFLL;
      v19 = &v25;
    }
    else if ((a3 & 0x1000000000000000) != 0)
    {
      v19 = (_QWORD *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v23 = a4;
      v24 = v18._rawBits;
      v19 = _StringObject.sharedUTF8.getter(a3, v23);
      v18._rawBits = v24;
    }
    LODWORD(result) = _decodeScalar(_:startingAt:)((uint64_t)v19, v17._rawBits, v18._rawBits);
  }
  return result;
}

uint64_t specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int v5;

  if (a2 >= a1)
    return 0;
  v4 = a1;
  do
    v5 = *(_BYTE *)(a3 - 1 + v4--) & 0xC0;
  while (v5 == 128);
  return _decodeScalar(_:startingAt:)(a3, a2, v4);
}

uint64_t specialized _UIntBuffer._elementWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result < a2 || result >= a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  return result;
}

unint64_t specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || result >> 14 >= a3 >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  return result;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2)
{
  if (a2 < result || HIDWORD(a2) >= result)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  return result;
}

uint64_t specialized __CocoaDictionary.Index.key.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (a1 < 0)
    v3 = a1;
  else
    v3 = a1 & 0xFFFFFFFFFFFFFF8;
  v4 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v3, v4))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  v5 = *(_QWORD *)(v3 + 24);
  if (*(_QWORD *)(v5 + 16) <= a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
  return *(_QWORD *)(v5 + 8 * a2 + 24);
}

uint64_t specialized __CocoaDictionary.key(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a1 < 0)
    v5 = a1;
  else
    v5 = a1 & 0xFFFFFFFFFFFFFF8;
  v6 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v5, v6))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(_QWORD *)(v5 + 16) != a3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x225uLL, 0);
  v7 = *(_QWORD *)(v5 + 24);
  if (*(_QWORD *)(v7 + 16) <= a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
  return *(_QWORD *)(v7 + 8 * a2 + 24);
}

uint64_t specialized __CocoaSet.Index.element.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (a1 < 0)
    v3 = a1;
  else
    v3 = a1 & 0xFFFFFFFFFFFFFF8;
  v4 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v3, v4))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  v5 = *(_QWORD *)(v3 + 24);
  if (*(_QWORD *)(v5 + 16) <= a2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/SetBridging.swift", 23, 2, 0x1E1uLL, 0);
  return *(_QWORD *)(v5 + 8 * a2 + 24);
}

Swift::UInt64 specialized String.UnicodeScalarView.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits;
  Swift::UInt64 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  Swift::UInt64 v12;
  unint64_t v13;
  uint64_t v14;

  rawBits = a2._rawBits;
  v7 = a1._rawBits;
  v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000) == 0)
    LOBYTE(v8) = 1;
  v9 = a1._rawBits & 0xC;
  v10 = 4 << v8;
  v11 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v9 == v10 || (a2._rawBits & 1) == 0 || v11 == v10)
  {
    if (v11 == v10)
    {
      rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v9 != v10)
        goto LABEL_13;
    }
    else if (v9 != v10)
    {
      goto LABEL_13;
    }
    v7 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v7)._rawBits;
LABEL_13:
    v14 = a3 & 0xFFFFFFFFFFFFLL;
    if ((a4 & 0x2000000000000000) != 0)
      v14 = HIBYTE(a4) & 0xF;
    if (rawBits >> 14 > 4 * v14 || rawBits >> 14 < v7 >> 14)
    {
      v13 = 80;
LABEL_21:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, v13, 0);
    }
    if ((v7 & 1) != 0)
    {
      if ((rawBits & 1) != 0)
        return v7;
    }
    else
    {
      v7 = v7 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v7)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
      if ((rawBits & 1) != 0)
        return v7;
    }
    _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    return v7;
  }
  v12 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000) == 0)
    v12 = a3 & 0xFFFFFFFFFFFFLL;
  if (v12 < a2._rawBits >> 16)
  {
    v13 = 210;
    goto LABEL_21;
  }
  return v7;
}

Swift::UInt64 specialized String.UTF8View.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  rawBits = a2._rawBits;
  v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000) == 0)
    LOBYTE(v8) = 1;
  v9 = 4 << v8;
  if ((a2._rawBits & 0xC) == 4 << v8)
    rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  if ((a1._rawBits & 0xC) == v9)
    a1._rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  v10 = a3 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000) != 0)
    v10 = HIBYTE(a4) & 0xF;
  if (rawBits >> 14 > 4 * v10 || rawBits >> 14 < a1._rawBits >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x50uLL, 0);
  return a1._rawBits;
}

Swift::UInt64 specialized Substring.UTF8View.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits;
  uint64_t v10;
  uint64_t v11;

  rawBits = a2._rawBits;
  v10 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000) == 0)
    LOBYTE(v10) = 1;
  v11 = 4 << v10;
  if ((a2._rawBits & 0xC) == 4 << v10)
    rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  if ((a1._rawBits & 0xC) == v11)
    a1._rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  if (a1._rawBits >> 14 < a3 >> 14 || rawBits >> 14 < a1._rawBits >> 14 || a4 >> 14 < rawBits >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index range is out of bounds", 38, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x63uLL, 0);
  return a1._rawBits;
}

Swift::UInt64 specialized Substring.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits;
  Swift::UInt64 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  rawBits = a2._rawBits;
  v9 = a1._rawBits;
  v10 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000) == 0)
    LOBYTE(v10) = 1;
  v11 = a1._rawBits & 0xC;
  v12 = 4 << v10;
  v13 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v11 == v12 || (a2._rawBits & 1) == 0 || v13 == v12)
  {
    if (v13 == v12)
    {
      rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v11 != v12)
        goto LABEL_12;
    }
    else if (v11 != v12)
    {
LABEL_12:
      if (v9 >> 14 < a3 >> 14 || rawBits >> 14 < v9 >> 14 || a4 >> 14 < rawBits >> 14)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index range is out of bounds", 38, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x63uLL, 0);
      if ((rawBits & 1) != 0)
      {
        if ((v9 & 1) != 0)
          return v9;
      }
      else
      {
        _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
        if ((v9 & 1) != 0)
          return v9;
      }
      return v9 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    }
    v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
    goto LABEL_12;
  }
  if (a1._rawBits >> 14 < a3 >> 14 || a4 >> 14 < a2._rawBits >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0xECuLL, 0);
  return v9;
}

uint64_t specialized _SliceBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  return a3;
}

uint64_t specialized ContiguousArray.subscript.getter(Swift::Int a1, Swift::Int a2, uint64_t a3)
{
  ContiguousArray._checkIndex(_:)(a1);
  ContiguousArray._checkIndex(_:)(a2);
  if (a2 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  return a3;
}

uint64_t specialized _ContiguousArrayBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  return a3;
}

uint64_t specialized CollectionDifference.index(after:)(uint64_t a1)
{
  BOOL v1;
  uint64_t result;

  v1 = __OFADD__(a1, 1);
  result = a1 + 1;
  if (v1)
    __break(1u);
  return result;
}

uint64_t specialized static Duration.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4;
  uint64_t result;
  int v6;

  v4 = __CFADD__(a1, a3);
  result = a1 + a3;
  v6 = v4;
  if (__OFADD__(a2, a4) || v6 && a2 + a4 == 0x7FFFFFFFFFFFFFFFLL)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  return result;
}

unint64_t specialized static Duration.- infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  unint64_t result;

  v4 = __OFSUB__(a2, a4);
  v5 = a2 - a4;
  v6 = v4;
  v7 = a1 >= a3;
  result = a1 - a3;
  if (v7)
  {
    if (v6)
      goto LABEL_8;
  }
  else
  {
    if (v5 == 0x8000000000000000)
      LOBYTE(v6) = 1;
    if ((v6 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
  }
  return result;
}

unint64_t specialized String.UTF16View._foreignDistance(from:to:)(unint64_t a1, unint64_t a2)
{
  return (a2 >> 16) - (a1 >> 16);
}

unint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || a3 >> 14 < result >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  return result;
}

unint64_t specialized RandomAccessCollection<>.distance(from:to:)(unint64_t a1, unint64_t a2)
{
  if (a1 >= 2 || a2 >= 2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  return a2 - a1;
}

{
  if (a1 >= 3 || a2 >= 3)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  return a2 - a1;
}

void **specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)(void **result, uint64_t a2, void **a3, id a4)
{
  void **v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;

  if (__OFSUB__(a2, result))
  {
    __break(1u);
  }
  else
  {
    v4 = a3;
    v6 = (uint64_t)result;
    objc_msgSend(a4, sel_getObjects_range_, a3, result, a2 - (_QWORD)result);
    v10 = a2 - v6;
    if (a2 != v6)
    {
      if (a2 <= v6)
        v11 = v6;
      else
        v11 = a2;
      v12 = v11 - v6;
      do
      {
        if (!v12)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v13 = *v4++;
        swift_unknownObjectRetain(v13, v7, v8, v9);
        --v12;
        --v10;
      }
      while (v10);
    }
    return v4;
  }
  return result;
}

uint64_t specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5;
  uint64_t result;
  BOOL v7;

  v5 = a3 - a1;
  if (__OFSUB__(a3, a1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a4, 0);
  if (a2 < 1)
  {
    if (v5 > 0 || v5 <= a2)
      goto LABEL_9;
    return 0;
  }
  if ((v5 & 0x8000000000000000) == 0 && v5 < (unint64_t)a2)
    return 0;
LABEL_9:
  v7 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v7)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  return result;
}

uint64_t specialized Array.index(_:offsetBy:limitedBy:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;

  v3 = a3 - result;
  if (__OFSUB__(a3, result))
  {
    __break(1u);
    goto LABEL_12;
  }
  if (a2 >= 1)
  {
    if (v3 < 0 || v3 >= (unint64_t)a2)
      goto LABEL_9;
    return 0;
  }
  if (v3 <= 0 && v3 > a2)
    return 0;
LABEL_9:
  v4 = __OFADD__(result, a2);
  result += a2;
  if (v4)
LABEL_12:
    __break(1u);
  return result;
}

unint64_t specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(unint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  unint64_t result;
  BOOL v5;

  if (a1 >= 2 || a3 >= 2)
LABEL_3:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  v3 = a3 - a1;
  if (a2 >= 1)
  {
    if (v3 < 0 || v3 >= (unint64_t)a2)
      goto LABEL_11;
    return 0;
  }
  if (v3 <= 0 && v3 > a2)
    return 0;
LABEL_11:
  v5 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v5)
  {
    __break(1u);
  }
  else if (result >= 2)
  {
    goto LABEL_3;
  }
  return result;
}

{
  uint64_t v3;
  unint64_t result;
  BOOL v5;

  if (a1 >= 3 || a3 >= 3)
LABEL_3:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  v3 = a3 - a1;
  if (a2 >= 1)
  {
    if (v3 < 0 || v3 >= (unint64_t)a2)
      goto LABEL_11;
    return 0;
  }
  if (v3 <= 0 && v3 > a2)
    return 0;
LABEL_11:
  v5 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v5)
  {
    __break(1u);
  }
  else if (result >= 3)
  {
    goto LABEL_3;
  }
  return result;
}

unint64_t specialized RandomAccessCollection<>.index(_:offsetBy:)(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  unint64_t result;

  v2 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v2)
  {
    __break(1u);
  }
  else if (result >= 2)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return result;
}

{
  BOOL v2;
  unint64_t result;

  v2 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v2)
  {
    __break(1u);
  }
  else if (result >= 3)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return result;
}

char *specialized _BidirectionalCollectionBox.init(_base:)(uint64_t a1)
{
  char *v1;
  char *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t AssociatedConformanceWitness;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  void (*v15)(char *, char *, unint64_t);
  char *v16;
  uint64_t v18;

  v2 = v1;
  v4 = *(_QWORD *)v2;
  v5 = *(_QWORD *)(*(_QWORD *)v2 + 368);
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 376) + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(&v2[*(_QWORD *)(v4 + 384)], a1, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v5, v6);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v13 = type metadata accessor for _IndexBox(0, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  v14 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
  v15(&v14[*(_QWORD *)(*(_QWORD *)v14 + 96)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  v16 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15(&v16[*(_QWORD *)(*(_QWORD *)v16 + 96)], v10, AssociatedTypeWitness);
  *((_QWORD *)v2 + 2) = v14;
  *((_QWORD *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((_QWORD *)v2 + 4) = v16;
  *((_QWORD *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

char *specialized _RandomAccessCollectionBox.init(_base:)(uint64_t a1)
{
  char *v1;
  char *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t AssociatedConformanceWitness;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  void (*v15)(char *, char *, unint64_t);
  char *v16;
  uint64_t v18;

  v2 = v1;
  v4 = *(_QWORD *)v2;
  v5 = *(_QWORD *)(*(_QWORD *)v2 + 376);
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 384) + 8) + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 16))(&v2[*(_QWORD *)(v4 + 392)], a1, v5);
  (*(void (**)(uint64_t, uint64_t))(v6 + 64))(v5, v6);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, v5, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v13 = type metadata accessor for _IndexBox(0, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  v14 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
  v15(&v14[*(_QWORD *)(*(_QWORD *)v14 + 96)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v5, v6);
  v16 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15(&v16[*(_QWORD *)(*(_QWORD *)v16 + 96)], v10, AssociatedTypeWitness);
  *((_QWORD *)v2 + 2) = v14;
  *((_QWORD *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((_QWORD *)v2 + 4) = v16;
  *((_QWORD *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

char *specialized _CollectionBox.init(_base:)(uint64_t a1)
{
  char *v1;
  char *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t AssociatedConformanceWitness;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  void (*v15)(char *, char *, unint64_t);
  char *v16;
  uint64_t v18;

  v2 = v1;
  v4 = *(_QWORD *)v2;
  v6 = *(_QWORD *)(*(_QWORD *)v2 + 344);
  v5 = *(_QWORD *)(*(_QWORD *)v2 + 352);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v6 - 8) + 16))(&v2[*(_QWORD *)(v4 + 360)], a1, v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v6, v5);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v13 = type metadata accessor for _IndexBox(0, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  v14 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15 = *(void (**)(char *, char *, unint64_t))(v8 + 32);
  v15(&v14[*(_QWORD *)(*(_QWORD *)v14 + 96)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v5 + 72))(v6, v5);
  v16 = (char *)swift_allocObject(v13, *(unsigned int *)(v13 + 48), *(unsigned __int16 *)(v13 + 52));
  v15(&v16[*(_QWORD *)(*(_QWORD *)v16 + 96)], v10, AssociatedTypeWitness);
  *((_QWORD *)v2 + 2) = v14;
  *((_QWORD *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((_QWORD *)v2 + 4) = v16;
  *((_QWORD *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

uint64_t specialized _UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, uint64_t, uint64_t), unint64_t a5)
{
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t result;
  char v13;
  uint64_t v14;

  MEMORY[0x1E0C80A78](a1);
  v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v11 + 16))(v10);
  result = a4(v10, a2, a3);
  if ((v13 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000028, 0x8000000181763C20, "Swift/LegacyInt128.swift", 24, 2, a5, 0);
  return result;
}

uint64_t specialized UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v7 + 16))(v6);
  result = UInt128.init<A>(exactly:)(v6, a2, a3);
  if ((v9 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000052, 0x8000000181766AF0, "Swift/UInt128.swift", 19, 2, 0x96uLL, 0);
  return result;
}

uint64_t specialized Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;

  MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v7 + 16))(v6);
  result = Int128.init<A>(exactly:)((uint64_t)v6, a2, a3);
  if ((v9 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000051, 0x8000000181766B80, "Swift/Int128.swift", 18, 2, 0x99uLL, 0);
  return result;
}

__objc2_class **specialized DiscontiguousSlice._copyToContiguousArray()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t AssociatedConformanceWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __objc2_class **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t WitnessTable;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t *v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  char *v37;
  void (*v38)(char *, uint64_t, uint64_t);
  unint64_t v39;
  char *v40;
  void (*v41)(char *, uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v49;
  uint64_t *v50;
  unint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  unint64_t AssociatedTypeWitness;
  uint64_t v59;
  _QWORD v60[2];
  unint64_t *v61;
  unint64_t v62;
  __objc2_class **v63;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)a3, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v57 = (char *)&v49 - v6;
  v7 = swift_getAssociatedTypeWitness(255, (const char *)a3, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, v7, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v10 = type metadata accessor for Range(0, v7, AssociatedConformanceWitness, v9);
  v55 = *(_QWORD *)(v10 - 8);
  v56 = v10;
  v11 = MEMORY[0x1E0C80A78](v10);
  v54 = (char *)&v49 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v11);
  v53 = (char *)&v49 - v13;
  v14 = (uint64_t *)swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  _swift_isClassOrObjCExistentialType((uint64_t)v14, v14);
  v15 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v14);
  if (v15)
  {
    v18 = (__objc2_class **)v15;
  }
  else
  {
    v61 = (unint64_t *)&_swiftEmptyArrayStorage;
    v19 = type metadata accessor for Array(0, (uint64_t)v14, v16, v17);
    WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for [A], v19, v20);
    v18 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v61, v19, WitnessTable);
  }
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  v63 = v18;
  v23 = *(int *)(type metadata accessor for DiscontiguousSlice(0, a2, a3, v22) + 36);
  v59 = a1;
  v61 = *(unint64_t **)(a1 + v23);
  v62 = 0;
  v24 = v61[2];
  v28 = swift_retain(v61, v25, v26, v27);
  if (v24)
  {
    v29 = 0;
    v52 = (char *)&v62;
    v30 = v54;
    do
    {
      if (v29 >= v24)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      v50 = v14;
      v31 = v55;
      v32 = v56;
      (*(void (**)(char *, unint64_t, uint64_t))(v55 + 16))(v30, (unint64_t)v28+ ((*(unsigned __int8 *)(v31 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v31 + 80))+ *(_QWORD *)(v55 + 72) * v29, v56);
      v60[0] = 0;
      v60[1] = v24;
      v34 = type metadata accessor for RangeSet.Ranges(0, v7, AssociatedConformanceWitness, v33);
      v36 = (const char *)swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, v34, v35);
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v52, (uint64_t)v60, v34, v36);
      v62 = v29 + 1;
      v37 = v53;
      (*(void (**)(char *, char *, uint64_t))(v31 + 32))(v53, v30, v32);
      v38 = *(void (**)(char *, uint64_t, uint64_t))(a3 + 88);
      v51 = AssociatedConformanceWitness;
      v39 = v7;
      v40 = v57;
      v38(v37, a2, a3);
      v41 = *(void (**)(char *, uint64_t))(v31 + 8);
      v14 = v50;
      v41(v37, v32);
      v44 = type metadata accessor for ContiguousArray(0, (uint64_t)v14, v42, v43);
      v45 = AssociatedTypeWitness;
      v46 = *(_QWORD *)(swift_getAssociatedConformanceWitness(a3, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection)+ 8);
      v47 = (uint64_t)v40;
      v7 = v39;
      AssociatedConformanceWitness = v51;
      ContiguousArray.append<A>(contentsOf:)(v47, v44, v45, v46);
      v28 = v61;
      v29 = v62;
      v24 = v61[2];
    }
    while (v62 != v24);
    v18 = v63;
  }
  swift_release((uint64_t)v28);
  return v18;
}

uint64_t specialized AnySequence._copyToContiguousArray()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 144))();
}

_QWORD *specialized AnyBidirectionalCollection._copyContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t WitnessTable;
  uint64_t v11;
  uint64_t v12;
  _QWORD *result;

  v5 = (*(uint64_t (**)(void))(*(_QWORD *)a3 + 152))();
  v8 = type metadata accessor for AnyIterator(255, a4, v6, v7);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyIterator<A>, v8, v9);
  v12 = type metadata accessor for _IteratorBox(0, v8, WitnessTable, v11);
  result = swift_allocObject(v12, 0x18uLL, 7uLL);
  result[2] = v5;
  return result;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  unint64_t AssociatedConformanceWitness;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(char *, uint64_t, unint64_t);
  uint64_t (*v25)(char *, char *, unint64_t, unint64_t);
  char *v26;
  char v27;
  void (*v28)(char *, uint64_t);
  void (*v29)(char *, unint64_t);
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v34 = (char *)&v31 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v10);
  v13 = (char *)&v31 - v12;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v16 = type metadata accessor for ClosedRange(0, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  v17 = MEMORY[0x1E0C80A78](v16);
  v19 = (char *)&v31 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v31 - v20;
  v32 = v22;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 16);
  v23((char *)&v31 - v20, a2, v16);
  v33 = v9;
  v24 = *(void (**)(char *, uint64_t, unint64_t))(v9 + 16);
  v24(v13, a1, AssociatedTypeWitness);
  v25 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  LOBYTE(a2) = v25(v21, v13, AssociatedTypeWitness, AssociatedConformanceWitness);
  v24(v34, (uint64_t)v13, AssociatedTypeWitness);
  v23(v19, (uint64_t)v21, v16);
  if ((a2 & 1) == 0)
  {
    (*(void (**)(char *, uint64_t))(v32 + 8))(v19, v16);
    (*(void (**)(char *, unint64_t))(v33 + 8))(v34, AssociatedTypeWitness);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  v26 = v34;
  v27 = v25(v34, &v19[*(int *)(v16 + 36)], AssociatedTypeWitness, AssociatedConformanceWitness);
  v28 = *(void (**)(char *, uint64_t))(v32 + 8);
  v28(v19, v16);
  v29 = *(void (**)(char *, unint64_t))(v33 + 8);
  v29(v26, AssociatedTypeWitness);
  if ((v27 & 1) == 0)
    goto LABEL_5;
  v29(v13, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, uint64_t))v28)(v21, v16);
}

uint64_t specialized Range<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)a4, a3, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v12 = (char *)&v15 - v11;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 40))(a2, a3, a4);
  v13 = specialized numericCast<A, B>(_:)((uint64_t)v12, AssociatedTypeWitness, *(_QWORD *)(a5 + 8));
  (*(void (**)(char *, unint64_t))(v10 + 8))(v12, AssociatedTypeWitness);
  return v13;
}

uint64_t specialized static AnyIndex.== infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t ObjectType;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;

  ObjectType = swift_getObjectType(a1);
  v9 = (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
  v10 = swift_getObjectType(a3);
  if (v9 != (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 8))(v10, a4))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Base index types differ", 23, 2, "Swift/ExistentialCollection.swift", 33, 2, 0x747uLL, 0);
  v11 = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t, unint64_t, uint64_t))(a2 + 24))(a3, a4, v11, a2) & 1;
}

uint64_t specialized static AnyHashable.== infix(_:_:)(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10[5];
  uint64_t v11[3];
  uint64_t v12;
  uint64_t v13;

  v3 = a1[3];
  v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v11, v3, v4);
  v5 = v12;
  v6 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  v7 = a2[3];
  v8 = a2[4];
  __swift_project_boxed_opaque_existential_0Tm(a2, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v10, v7, v8);
  LOBYTE(a2) = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v6 + 16))(v10, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  return a2 & 1;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(char *a1, char *a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  void (*v24)(char *, char *, uint64_t);
  uint64_t (*v25)(char *, char *, unint64_t, unint64_t);
  char v26;
  void (*v27)(char *, uint64_t);
  void (*v29)(char *, uint64_t);
  uint64_t v30;
  uint64_t v31;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v11 = type metadata accessor for Range(0, AssociatedTypeWitness, AssociatedConformanceWitness, v10);
  v12 = MEMORY[0x1E0C80A78](v11);
  v14 = (char *)&v30 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  v15 = MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v30 - v16;
  v18 = MEMORY[0x1E0C80A78](v15);
  v20 = (char *)&v30 - v19;
  MEMORY[0x1E0C80A78](v18);
  v22 = (char *)&v30 - v21;
  v31 = v23;
  v24 = *(void (**)(char *, char *, uint64_t))(v23 + 16);
  v24((char *)&v30 - v21, a2, v11);
  v24(v20, a1, v11);
  v25 = *(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24);
  LOBYTE(a1) = v25(v22, v20, AssociatedTypeWitness, AssociatedConformanceWitness);
  v24(v17, v20, v11);
  v24(v14, v22, v11);
  if ((a1 & 1) == 0)
  {
    v29 = *(void (**)(char *, uint64_t))(v31 + 8);
    v29(v14, v11);
    v29(v17, v11);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  v26 = v25(&v17[*(int *)(v11 + 36)], &v14[*(int *)(v11 + 36)], AssociatedTypeWitness, AssociatedConformanceWitness);
  v27 = *(void (**)(char *, uint64_t))(v31 + 8);
  v27(v14, v11);
  v27(v17, v11);
  if ((v26 & 1) == 0)
    goto LABEL_5;
  v27(v20, v11);
  return ((uint64_t (*)(char *, uint64_t))v27)(v22, v11);
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(char *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t AssociatedConformanceWitness;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  void (*v23)(char *, uint64_t, uint64_t);
  void (*v24)(char *, char *, unint64_t);
  char *v25;
  char v26;
  void (*v27)(char *, uint64_t);
  void (*v28)(char *, unint64_t);
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;

  v32 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v8 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v9 = MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v11 = (char *)&v30 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v9);
  v13 = (char *)&v30 - v12;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v16 = type metadata accessor for Range(0, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  v17 = MEMORY[0x1E0C80A78](v16);
  v19 = (char *)&v30 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v30 - v20;
  v31 = v22;
  v23 = *(void (**)(char *, uint64_t, uint64_t))(v22 + 16);
  v23((char *)&v30 - v20, a2, v16);
  v33 = v8;
  v24 = *(void (**)(char *, char *, unint64_t))(v8 + 16);
  v24(v13, v32, AssociatedTypeWitness);
  LOBYTE(a2) = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                             + 24))(v21, v13, AssociatedTypeWitness, AssociatedConformanceWitness);
  v32 = v11;
  v24(v11, v13, AssociatedTypeWitness);
  v23(v19, (uint64_t)v21, v16);
  if ((a2 & 1) == 0)
  {
    (*(void (**)(char *, uint64_t))(v31 + 8))(v19, v16);
    (*(void (**)(char *, unint64_t))(v33 + 8))(v32, AssociatedTypeWitness);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  v25 = v32;
  v26 = (*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 16))(v32, &v19[*(int *)(v16 + 36)], AssociatedTypeWitness, AssociatedConformanceWitness);
  v27 = *(void (**)(char *, uint64_t))(v31 + 8);
  v27(v19, v16);
  v28 = *(void (**)(char *, unint64_t))(v33 + 8);
  v28(v25, AssociatedTypeWitness);
  if ((v26 & 1) == 0)
    goto LABEL_5;
  v28(v13, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, uint64_t))v27)(v21, v16);
}

uint64_t specialized static AnyIndex.< infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t ObjectType;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;

  ObjectType = swift_getObjectType(a1);
  v9 = (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
  v10 = swift_getObjectType(a3);
  if (v9 != (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 8))(v10, a4))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Base index types differ", 23, 2, "Swift/ExistentialCollection.swift", 33, 2, 0x755uLL, 0);
  v11 = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t, unint64_t, uint64_t))(a2 + 32))(a3, a4, v11, a2) & 1;
}

uint64_t specialized UInt128.init<A>(truncatingIfNeeded:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t);
  uint64_t v12;
  unint64_t v13;
  void (*v14)(uint64_t, uint64_t);
  uint64_t v16;
  uint64_t v17;

  v6 = *(_QWORD *)(a2 - 8);
  v7 = MEMORY[0x1E0C80A78](a1);
  v9 = (char *)&v16 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v17 = 64;
  v11 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v10 + 240);
  v13 = lazy protocol witness table accessor for type Int and conformance Int(v7, v12, v10);
  v11(a1, &v17, &type metadata for Int, v13, a2, a3);
  v14 = *(void (**)(uint64_t, uint64_t))(a3 + 120);
  v14(a2, a3);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  return ((uint64_t (*)(uint64_t, uint64_t))v14)(a2, a3);
}

_QWORD *specialized static _Int128.+= infix(_:_:)(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _BOOL4 v4;
  BOOL v5;
  uint64_t v6;
  BOOL v7;

  v3 = result[1];
  v4 = __CFADD__(*result, a2);
  v5 = __OFADD__(v3, a3);
  v6 = v3 + a3;
  if (v5 || (v4 ? (v7 = v6 == 0x7FFFFFFFFFFFFFFFLL) : (v7 = 0), v7))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x264uLL, 0);
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

_QWORD *specialized static Duration.+= infix(_:_:)(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _BOOL4 v4;
  BOOL v5;
  uint64_t v6;
  BOOL v7;

  v3 = result[1];
  v4 = __CFADD__(*result, a2);
  v5 = __OFADD__(v3, a3);
  v6 = v3 + a3;
  if (v5 || (v4 ? (v7 = v6 == 0x7FFFFFFFFFFFFFFFLL) : (v7 = 0), v7))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

_QWORD *specialized static _UInt128.+= infix(_:_:)(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _BOOL4 v4;
  BOOL v5;
  uint64_t v6;
  BOOL v7;

  v3 = result[1];
  v4 = __CFADD__(*result, a2);
  v5 = __CFADD__(v3, a3);
  v6 = v3 + a3;
  if (v5 || (v4 ? (v7 = v6 == -1) : (v7 = 0), v7))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x71uLL, 0);
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

char *partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(char *a1, uint64_t a2)
{
  return partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(a1, a2);
}

{
  uint64_t v2;

  return closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(a1, a2, *(_QWORD *)(v2 + 48), *(char **)(v2 + 56), *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 32));
}

uint64_t type metadata accessor for _ArrayBuffer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ArrayBuffer, &flag for loading of canonical specialized generic type metadata for _ArrayBuffer);
}

char *specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  unint64_t v12;

  v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v5 < 0)
    goto LABEL_9;
  v6 = *(_QWORD *)(a5 - 8);
  v7 = *(unsigned __int8 *)(v6 + 80);
  v8 = *(_QWORD *)(v6 + 72);
  v9 = (char *)(a4 + ((v7 + 32) & ~v7) + v8 * a1);
  v10 = v8 * v5;
  v11 = &__dst[v10];
  v12 = (unint64_t)&v9[v10];
  if (v9 < v11 && v12 > (unint64_t)__dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  swift_arrayInitWithCopy(__dst, v9, v5, a5);
  return v11;
}

char *specialized _ArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  char *v7;
  char *v8;
  uint64_t v10;

  v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v5 < 0)
    goto LABEL_9;
  v7 = (char *)(a4 + 40 * a1 + 32);
  v8 = &a3[40 * v5];
  if (v7 < v8 && &v7[40 * v5] > a3)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  v10 = __swift_instantiateConcreteTypeFromMangledName(a5);
  swift_arrayInitWithCopy(a3, v7, v5, v10);
  return v8;
}

uint64_t specialized _ArrayBuffer.owner.getter(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000) != 0))
  {
    if (a1 < 0)
      return a1;
    else
      return a1 & 0xFFFFFFFFFFFFFF8;
  }
  else if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    return a1 & 0xFFFFFFFFFFFFFF8;
  }
  else
  {
    return a1;
  }
}

uint64_t type metadata accessor for CollectionOfOne(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionOfOne, &flag for loading of canonical specialized generic type metadata for CollectionOfOne);
}

void specialized _ArrayBuffer.subscript.setter()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0x6C706D6920746F6ELL, 0xEF6465746E656D65, "Swift/ArrayBuffer.swift", 23, 2, 0x15CuLL, 0);
}

uint64_t partial apply for closure #1 in MutableCollection<>.partition(by:)@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v1;

  return closure #1 in MutableCollection<>.partition(by:)(*(uint64_t (**)(char *))(v1 + 40), *(_QWORD *)(v1 + 48), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24), a1);
}

uint64_t type metadata accessor for ClosedRange(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ClosedRange, &flag for loading of canonical specialized generic type metadata for ClosedRange);
}

uint64_t type metadata accessor for Range(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Range, &flag for loading of canonical specialized generic type metadata for Range);
}

uint64_t type metadata accessor for __StaticArrayStorage()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for __SwiftDeferredNSArray()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for __SwiftDeferredStaticNSArray(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for __SwiftDeferredStaticNSArray);
}

uint64_t type metadata accessor for _ContiguousArrayStorage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ContiguousArrayStorage, &flag for loading of canonical specialized generic type metadata for _ContiguousArrayStorage);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>()
{
  type metadata accessor for __ContiguousArrayStorageBase();
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>()
{
  type metadata accessor for __ContiguousArrayStorageBase();
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>()
{
  type metadata accessor for __ContiguousArrayStorageBase();
  return objc_opt_self();
}

void partial apply for closure #1 in _assertionFailure(_:_:flags:)(const char *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  uint64_t v7;
  unint64_t v8;
  int v9;
  const char *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD v14[2];

  v7 = *(_QWORD *)(v4 + 16);
  v8 = *(_QWORD *)(v4 + 24);
  v9 = *(_DWORD *)(v4 + 32);
  swift_bridgeObjectRetain(v8, a2, a3, a4);
  if ((v8 & 0x1000000000000000) != 0)
  {
    v7 = specialized static String._copying(_:)(v7, v8);
    v13 = v12;
    swift_bridgeObjectRelease(v8);
    v8 = v13;
    if ((v13 & 0x2000000000000000) == 0)
      goto LABEL_3;
LABEL_7:
    v14[0] = v7;
    v14[1] = v8 & 0xFFFFFFFFFFFFFFLL;
    closure #1 in closure #1 in _assertionFailure(_:_:flags:)((const char *)v14, HIBYTE(v8) & 0xF, a1, a2, v9);
    swift_bridgeObjectRelease(v8);
    return;
  }
  if ((v8 & 0x2000000000000000) != 0)
    goto LABEL_7;
LABEL_3:
  if ((v7 & 0x1000000000000000) != 0)
  {
    v10 = (const char *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
    v11 = v7 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v10 = (const char *)_StringObject.sharedUTF8.getter(v7, v8);
  }
  closure #1 in closure #1 in _assertionFailure(_:_:flags:)(v10, v11, a1, a2, v9);
  swift_bridgeObjectRelease(v8);
}

uint64_t type metadata accessor for UnsafePointer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnsafePointer, &flag for loading of canonical specialized generic type metadata for UnsafePointer);
}

uint64_t type metadata accessor for ContiguousArray(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ContiguousArray, &flag for loading of canonical specialized generic type metadata for ContiguousArray);
}

uint64_t type metadata accessor for Array(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Array, &flag for loading of canonical specialized generic type metadata for Array);
}

_OWORD *outlined init with take of Any(_OWORD *a1, _OWORD *a2)
{
  __int128 v2;

  v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

uint64_t type metadata accessor for ArraySlice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ArraySlice);
}

uint64_t specialized static _HashTable.scale(forCapacity:)(uint64_t result)
{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  unsigned int v5;

  if (result <= 1)
    v1 = 1;
  else
    v1 = result;
  v2 = ceil((double)v1 / 0.75);
  if ((~*(_QWORD *)&v2 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v2 <= -9.22337204e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v2 >= 9.22337204e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  v3 = __OFADD__(v1, 1);
  v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
  }
  else
  {
    if (v4 <= (uint64_t)v2)
      v4 = (uint64_t)v2;
    v5 = 64 - __clz(v4 - 1);
    if ((unint64_t)v4 <= 2)
      return 1;
    else
      return v5;
  }
  return result;
}

uint64_t specialized static _HashTable.capacity(forScale:)(char a1)
{
  double v1;

  v1 = (double)(1 << a1) * 0.75;
  if ((~*(_QWORD *)&v1 & 0x7FF0000000000000) == 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v1 <= -9.22337204e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v1 >= 9.22337204e18)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  return (uint64_t)v1;
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  double v5;
  BOOL v6;
  uint64_t v7;
  char v10;
  unsigned __int8 v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int64x2_t *v21;
  double v22;
  uint64_t *v23;
  int64x2_t *v24;
  uint64_t v25;
  uint64_t *v26;

  if (result <= 1)
    v4 = 1;
  else
    v4 = result;
  v5 = ceil((double)v4 / 0.75);
  if ((~*(_QWORD *)&v5 & 0x7FF0000000000000) == 0)
    goto LABEL_23;
  if (v5 <= -9.22337204e18)
    goto LABEL_24;
  if (v5 >= 9.22337204e18)
    goto LABEL_25;
  v6 = __OFADD__(v4, 1);
  v7 = v4 + 1;
  if (v6)
  {
    __break(1u);
    return result;
  }
  if (v7 <= (uint64_t)v5)
    v7 = (uint64_t)v5;
  v10 = 64 - __clz(v7 - 1);
  v11 = (unint64_t)v7 <= 2 ? 1 : v10;
  v12 = 1 << v11;
  v13 = (unint64_t)((1 << v11) + 63) >> 6;
  v14 = type metadata accessor for _DictionaryStorage(0, a2, a3, a4);
  v15 = *(_QWORD *)(a2 - 8);
  v16 = *(unsigned __int8 *)(v15 + 80);
  v17 = v16 + 8 * v13;
  v18 = *(_QWORD *)(a3 - 8);
  v19 = *(unsigned __int8 *)(v18 + 80);
  v20 = (*(_QWORD *)(v15 + 72) << v11) + v19;
  v21 = (int64x2_t *)swift_allocObject(v14, ((((v17 + 64) & ~v16) + v20) & ~v19) + (*(_QWORD *)(v18 + 72) << v11), v16 | v19 | 7);
  v21[1].i64[0] = 0;
  v22 = (double)(1 << v11) * 0.75;
  if ((~*(_QWORD *)&v22 & 0x7FF0000000000000) == 0)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v22 <= -9.22337204e18)
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v22 >= 9.22337204e18)
LABEL_25:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  v23 = (uint64_t *)v21;
  v24 = v21 + 4;
  v25 = ((unint64_t)v21[4].u64 + v17) & ~v16;
  v21[1].i64[1] = (uint64_t)v22;
  v21[2].i8[0] = v11;
  v21[2].i8[1] = 0;
  v21[2].i16[1] = 0;
  v21[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v21);
  if ((_BYTE)qword_1ECD25528)
    v26 = (uint64_t *)v11;
  else
    v26 = v23;
  v23[5] = (uint64_t)v26;
  v23[6] = v25;
  v23[7] = (v25 + v20) & ~v19;
  if (v12 > 63)
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v13, v24);
  else
    v24->i64[0] = -1 << v12;
  return (uint64_t)v23;
}

void specialized EmptyCollection.subscript.setter()
{
  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x6AuLL, 0);
}

char *specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  char *v6;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0)
    goto LABEL_7;
  v5 = (char *)(a4 + 16 * a1 + 32);
  v6 = &__dst[16 * v4];
  if (v5 < v6 && &v5[16 * v4] > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  swift_arrayInitWithCopy(__dst, v5, v4, (uint64_t)&type metadata for String);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;

  v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0)
    goto LABEL_7;
  v5 = (char *)(a4 + 4 * a1 + 32);
  v6 = 4 * v4;
  v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  memcpy(__dst, v5, v6);
  return v7;
}

uint64_t type metadata accessor for EmptyCollection(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for EmptyCollection, &flag for loading of canonical specialized generic type metadata for EmptyCollection);
}

uint64_t specialized Collection.subscript.getter(Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 rawBits;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  Swift::UInt64 v9;
  unint64_t v10;
  uint64_t v11;

  rawBits = a1._rawBits;
  v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0)
    LOBYTE(v6) = 1;
  v7 = 4 << v6;
  v8 = a1._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v7)
  {
    if (v8 == v7)
      rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
    v11 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000) == 0)
      v11 = a2 & 0xFFFFFFFFFFFFLL;
    if (4 * v11 < rawBits >> 14)
    {
      v10 = 80;
LABEL_15:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, v10, 0);
    }
    if ((rawBits & 1) == 0)
      _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits);
  }
  else
  {
    v9 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000) == 0)
      v9 = a2 & 0xFFFFFFFFFFFFLL;
    if (v9 < a1._rawBits >> 16)
    {
      v10 = 210;
      goto LABEL_15;
    }
  }
  return 15;
}

unint64_t specialized static String.+ infix(_:_:)(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v5;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char v11;
  unint64_t v12;

  v5 = a3;
  v8 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v8 = a1 & 0xFFFFFFFFFFFFLL;
  if (!v8 && (a1 & ~a2 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRetain(a4, a2, a3, (char *)a4);
    return v5;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRetain(a2, a2, a3, (char *)a4);
    if ((a4 & 0x2000000000000000) != 0)
      goto LABEL_12;
LABEL_9:
    v9 = v5 & 0xFFFFFFFFFFFFLL;
LABEL_13:
    _StringGuts.append(_:)(v5, a4, 0, v9);
    return a1;
  }
  swift_bridgeObjectRetain(a2, a2, a3, (char *)a4);
  if ((a4 & 0x2000000000000000) == 0)
    goto LABEL_9;
  v10 = specialized _SmallString.init(_:appending:)(a1, a2, v5, a4);
  if ((v11 & 1) != 0)
  {
LABEL_12:
    v9 = HIBYTE(a4) & 0xF;
    goto LABEL_13;
  }
  v12 = v10;
  swift_bridgeObjectRelease(a2);
  return v12;
}

Swift::UInt64 specialized Collection.subscript.getter(Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  Swift::UInt64 v7;
  Swift::UInt64 rawBits;
  Swift::UInt64 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000) != 0)
    v3 = HIBYTE(a3) & 0xF;
  v4 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0)
    LODWORD(v4) = 1;
  v5 = 11;
  if ((_DWORD)v4)
    v5 = 7;
  v6 = 4 * v3;
  v7 = a1._rawBits >> 14;
  if (4 * v3 < a1._rawBits >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  rawBits = a1._rawBits;
  v9 = v5 | (v3 << 16);
  v10 = a1._rawBits & 0xC;
  v11 = 4 << v4;
  v12 = v5 & 0xC;
  if ((a1._rawBits & 1) == 0 || v10 == v11 || v12 == v11)
  {
    if (v12 == v11)
    {
      v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
      if (v10 != v11)
        goto LABEL_13;
    }
    else if (v10 != v11)
    {
LABEL_13:
      if (v6 < v9 >> 14 || v9 >> 14 < v7)
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x50uLL, 0);
      if ((rawBits & 1) != 0)
      {
        if ((v9 & 1) != 0)
          return rawBits;
      }
      else
      {
        rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
        if ((v9 & 1) != 0)
          return rawBits;
      }
      _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits;
      return rawBits;
    }
    rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    v7 = rawBits >> 14;
    goto LABEL_13;
  }
  return rawBits;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  Swift::UInt64 v7;
  Swift::UInt64 rawBits;
  Swift::UInt64 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000) != 0)
    v3 = HIBYTE(a3) & 0xF;
  v4 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0)
    LODWORD(v4) = 1;
  v5 = 11;
  if ((_DWORD)v4)
    v5 = 7;
  v6 = 4 * v3;
  v7 = a1._rawBits >> 14;
  if (4 * v3 < a1._rawBits >> 14)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  rawBits = a1._rawBits;
  v9 = v5 | (v3 << 16);
  v10 = a1._rawBits & 0xC;
  v11 = 4 << v4;
  v12 = v5 & 0xC;
  if ((a1._rawBits & 1) != 0 && v10 != v11 && v12 != v11)
    goto LABEL_17;
  if (v12 == v11)
  {
    v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
    if (v10 != v11)
      goto LABEL_13;
  }
  else if (v10 != v11)
  {
    goto LABEL_13;
  }
  rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  v7 = rawBits >> 14;
LABEL_13:
  if (v6 < v9 >> 14 || v9 >> 14 < v7)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x50uLL, 0);
  if ((rawBits & 1) != 0)
  {
    if ((v9 & 1) != 0)
      goto LABEL_17;
  }
  else
  {
    rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if ((v9 & 1) != 0)
      goto LABEL_17;
  }
  _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits;
LABEL_17:
  if (rawBits >= 0x10000)
    return rawBits;
  else
    return rawBits | 3;
}

Swift::Int specialized LazyMapSequence<>.formIndex(after:)(Swift::String::Index *a1, uint64_t a2, unint64_t a3)
{
  Swift::String::Index v6;
  Swift::UInt64 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  Swift::UInt64 v12;
  char *v13;
  uint64_t v14;
  int v15;
  int v17;
  BOOL v18;
  Swift::UInt64 v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  Swift::Int result;
  Swift::Int v24;
  int v25;
  char *v26;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v6._rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  v7 = (v6._rawBits >> 8) & 0x3F;
  v8 = a3 & 0x2000000000000000;
  v9 = HIBYTE(a3) & 0xF;
  v10 = a2 & 0xFFFFFFFFFFFFLL;
  if (v7)
    goto LABEL_27;
  if (v8)
    v11 = HIBYTE(a3) & 0xF;
  else
    v11 = a2 & 0xFFFFFFFFFFFFLL;
  if (v6._rawBits >> 14 == 4 * v11)
  {
    v7 = 0;
    goto LABEL_27;
  }
  v12 = v6._rawBits >> 16;
  if ((a3 & 0x1000000000000000) != 0)
    goto LABEL_56;
  if (!v8)
  {
    if ((a2 & 0x1000000000000000) != 0)
    {
      v13 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      v14 = a2 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      v13 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      v12 = v6._rawBits >> 16;
    }
    if (v12 + 1 != v14)
    {
      if (!v13)
        goto LABEL_59;
      v15 = *(unsigned __int16 *)&v13[v12];
      if (v15 == 2573 || (v15 & 0x80808080) != 0)
        goto LABEL_56;
    }
    v8 = 0;
LABEL_26:
    v7 = 1;
    goto LABEL_27;
  }
  v31 = a2;
  v32 = a3 & 0xFFFFFFFFFFFFFFLL;
  if (v12 + 1 == v9
    || ((v17 = *(unsigned __int16 *)((char *)&v31 + v12), v17 != 2573) ? (v18 = (v17 & 0x80808080) == 0) : (v18 = 0), v18))
  {
    v8 = 1;
    goto LABEL_26;
  }
LABEL_56:
  v7 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v12);
LABEL_27:
  v19 = v6._rawBits + (v7 << 16);
  v20 = v19 & 0xFFFFFFFFFFFF0000;
  if (v8)
    v21 = HIBYTE(a3) & 0xF;
  else
    v21 = a2 & 0xFFFFFFFFFFFFLL;
  v22 = a3 & 0x1000000000000000;
  if (v20 >> 14 == 4 * v21)
  {
    result = 0;
LABEL_47:
    v20 |= result << 8;
    goto LABEL_48;
  }
  v24 = v19 >> 16;
  if (!v22)
  {
    if (v8)
    {
      v31 = a2;
      v32 = a3 & 0xFFFFFFFFFFFFFFLL;
      if (v24 + 1 == v9)
        goto LABEL_46;
      v25 = *(unsigned __int16 *)((char *)&v31 + v24);
LABEL_41:
      if (v25 == 2573 || (v25 & 0x8080) != 0)
        goto LABEL_54;
LABEL_46:
      v22 = 0;
      result = 1;
      goto LABEL_47;
    }
    if ((a2 & 0x1000000000000000) != 0)
    {
      v26 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v26 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      v10 = v30;
    }
    if (v24 + 1 == v10)
      goto LABEL_46;
    if (v26)
    {
      v25 = *(unsigned __int16 *)&v26[v24];
      goto LABEL_41;
    }
LABEL_59:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
LABEL_54:
  result = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v24);
  if (result <= 63)
    goto LABEL_47;
LABEL_48:
  v28 = (a2 & 0x800000000000000) != 0 || v22 == 0;
  v29 = 7;
  if (!v28)
    v29 = 11;
  a1->_rawBits = v20 | v29;
  return result;
}

uint64_t specialized LazyMapSequence<>.distance(from:to:)(Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, unint64_t a4)
{
  Swift::String::Index v7;
  Swift::String::Index v8;
  uint64_t v9;
  int64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  int64_t v14;
  int v15;
  int v16;
  int64_t v18;
  Swift::Int v19;
  char *v20;
  char *v21;
  int v22;
  uint64_t v25;
  uint64_t v26;

  v7._rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(a1)._rawBits;
  v8._rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(a2)._rawBits;
  v9 = v7._rawBits >> 16;
  if (v7._rawBits >> 14 < v8._rawBits >> 14)
  {
    v10 = v8._rawBits >> 16;
    if (v9 < v8._rawBits >> 16)
    {
      v11 = 1;
      if ((a4 & 0x1000000000000000) == 0)
        goto LABEL_6;
LABEL_19:
      v14 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9) + v9;
      while (v14 < v10)
      {
        ++v11;
        v9 = v14;
        if ((a4 & 0x1000000000000000) != 0)
          goto LABEL_19;
LABEL_6:
        if ((a4 & 0x2000000000000000) != 0)
        {
          v25 = a3;
          v26 = a4 & 0xFFFFFFFFFFFFFFLL;
          v14 = v9 + 1;
          if (v9 + 1 != (HIBYTE(a4) & 0xF))
          {
            v16 = *(unsigned __int16 *)((char *)&v25 + v9);
            if (v16 == 2573 || (v16 & 0x80808080) != 0)
              goto LABEL_19;
          }
        }
        else
        {
          v12 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v13 = a3 & 0xFFFFFFFFFFFFLL;
          if ((a3 & 0x1000000000000000) == 0)
            v12 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
          v14 = v9 + 1;
          if (v9 + 1 != v13)
          {
            if (!v12)
              goto LABEL_43;
            v15 = *(unsigned __int16 *)&v12[v9];
            if (v15 == 2573 || (v15 & 0x80808080) != 0)
              goto LABEL_19;
          }
        }
      }
      return v11;
    }
    return 0;
  }
  if (v8._rawBits >> 14 >= v7._rawBits >> 14)
    return 0;
  v18 = v8._rawBits >> 16;
  if (v8._rawBits >> 16 >= v9)
    return 0;
  v11 = -1;
  if (v9 >= 2)
    goto LABEL_28;
  while (1)
  {
    v19 = 1;
LABEL_26:
    v9 -= v19;
    if (v18 >= v9)
      return v11;
    while (1)
    {
      --v11;
      if (v9 < 2)
        break;
LABEL_28:
      if ((a4 & 0x1000000000000000) != 0)
        goto LABEL_41;
      if ((a4 & 0x2000000000000000) != 0)
      {
        v25 = a3;
        v26 = a4 & 0xFFFFFFFFFFFFFFLL;
        v21 = (char *)&v25 + v9;
      }
      else
      {
        v20 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a3 & 0x1000000000000000) == 0)
        {
          v20 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
          if (!v20)
LABEL_43:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
        }
        v21 = &v20[v9];
      }
      v22 = *((unsigned __int16 *)v21 - 1);
      if (v22 == 2573 || (v22 & 0x80808080) != 0)
      {
LABEL_41:
        v19 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v9);
        goto LABEL_26;
      }
      if (v18 >= --v9)
        return v11;
    }
  }
}

unint64_t specialized _StringGuts.uniqueNativeReplaceSubrange(_:with:isASCII:)(unint64_t result, unint64_t a2, char *a3, size_t a4)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v13;

  v5 = result >> 16;
  v6 = (result >> 16) + a4;
  if (__OFADD__(result >> 16, a4))
  {
    __break(1u);
  }
  else
  {
    v7 = a2 >> 16;
    v8 = v4[1];
    if ((v8 & 0x2000000000000000) != 0)
      v9 = HIBYTE(v8) & 0xF;
    else
      v9 = *v4 & 0xFFFFFFFFFFFFLL;
    v10 = v9 - v7;
    result = v6 + v10;
    if (!__OFADD__(v6, v10))
    {
      _StringGuts.reserveCapacity(_:)(result);
      v13 = v4[1];
      __StringStorage.replace(from:to:with:)(v5, v7, a3, a4);
      *v4 = *(_QWORD *)(v13 + 24);
      return v5;
    }
  }
  __break(1u);
  return result;
}

_QWORD *specialized _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  unint64_t *v20;
  uint64_t v21;
  _QWORD v22[8];
  uint64_t v23;
  unint64_t *v24;

  v8 = a2 - (_QWORD)result;
  if (__OFSUB__(a2, result))
  {
    __break(1u);
    goto LABEL_7;
  }
  v10 = a4 - v8;
  if (__OFSUB__(a4, v8))
  {
LABEL_7:
    __break(1u);
    goto LABEL_8;
  }
  v16 = result;
  v17 = *(_QWORD *)(*(_QWORD *)(a7 + 8) + 8);
  v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 112))(a5, v17);
  v19 = __OFADD__(v18, v10);
  result = (_QWORD *)(v18 + v10);
  if (v19)
  {
LABEL_8:
    __break(1u);
    goto LABEL_9;
  }
  v20 = (unint64_t *)_ArrayBufferProtocol._forceCreateUniqueMutableBuffer(newCount:requiredCapacity:)((uint64_t)result, (uint64_t)result, a5, a7);
  v24 = v20;
  result = (*(_QWORD *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v17 + 64))(&v23, a5, v17);
  if (!__OFSUB__(v16, v23))
  {
    MEMORY[0x1E0C80A78](result);
    v22[2] = a5;
    v22[3] = a6;
    v22[4] = a7;
    v22[5] = a8;
    v22[6] = a3;
    _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)(&v24, v21, a4, (void (*)(char *, uint64_t))partial apply for closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:), (uint64_t)v22, a5, (uint64_t (**)(uint64_t, uint64_t, char *))a7);
    return (_QWORD *)swift_release((uint64_t)v20);
  }
LABEL_9:
  __break(1u);
  return result;
}

uint64_t specialized _UIntBuffer.capacity.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(void))(a2 + 56))();
  if (!v2)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  return 32 / v2;
}

Swift::UInt64 specialized LazyMapSequence<>.formIndex(after:)(Swift::String::Index *a1, uint64_t a2, uint64_t a3)
{
  Swift::String::Index v6;
  Swift::UInt64 v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  unsigned int v11;
  Swift::UInt64 result;
  _QWORD v13[2];

  v6._rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((a3 & 0x1000000000000000) != 0)
  {
    result = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }
  else
  {
    v7 = v6._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      v13[0] = a2;
      v13[1] = a3 & 0xFFFFFFFFFFFFFFLL;
      v9 = *((unsigned __int8 *)v13 + v7);
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0)
        v8 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      else
        v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
      v9 = v8[v7];
    }
    v10 = (char)v9;
    v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0)
      LOBYTE(v11) = 1;
    result = ((v7 + v11) << 16) | 5;
  }
  a1->_rawBits = result;
  return result;
}

uint64_t specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(uint64_t a1, Swift::String::Index a2, uint64_t a3, uint64_t a4)
{
  unint64_t *v4;
  Swift::UInt64 v9;
  unint64_t v10;

  v9 = _StringGuts.validateScalarRange_5_7(_:)(a2, a2, *v4, v4[1]);
  return _StringGuts.replaceSubrange<A>(_:with:)(v9, v10, a1, a3, a4);
}

uint64_t specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(int a1, Swift::String::Index a2)
{
  return Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(a2, a2);
}

void specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(unint64_t *a1, Swift::UInt64 a2, ValueMetadata *a3, Swift::UInt64 a4)
{
  Substring._replaceSubrange<A>(_:with:)(a2, a2, a1, a3, a4);
}

uint64_t type metadata accessor for PartialRangeFrom(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PartialRangeFrom, &flag for loading of canonical specialized generic type metadata for PartialRangeFrom);
}

void sub_1815A04EC()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  return closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, *(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 32), a2);
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameAbstract(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result < 0)
  {
    result = swift_getTypeByMangledNameInContextInMetadataState2(255, (char *)a1 + (int)result, -(result >> 32), 0, 0);
    *a1 = result;
  }
  return result;
}

uint64_t type metadata accessor for LazyMapSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyMapSequence);
}

uint64_t type metadata accessor for _CollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _CollectionBox);
}

uint64_t canonical specialized generic type metadata accessor for _IndexBox<Int>()
{
  return objc_opt_self();
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result < 0)
  {
    result = swift_getTypeByMangledNameInContext2((char *)a1 + (int)result, -(result >> 32), 0, 0);
    *a1 = result;
  }
  return result;
}

uint64_t type metadata accessor for LazySequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazySequence);
}

unint64_t outlined consume of Mirror.AncestorRepresentation(unint64_t result, uint64_t a2)
{
  if (result >= 2)
    return swift_release(a2);
  return result;
}

void sub_1815A05E0()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t type metadata accessor for _IndexBox(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _IndexBox, flag for loading of canonical specialized generic type metadata for _IndexBox);
}

unint64_t specialized static String._uncheckedFromASCII(_:)(uint8x16_t *a1, uint64_t a2)
{
  unint64_t v4;
  int64_t v5;
  uint64_t v6;
  unint64_t result;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int64x2_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int64x2_t v16;
  int64x2_t v17;
  int64x2_t v18;
  int64x2_t v19;
  uint8x8_t *v20;
  int8x16_t v21;
  unint64_t v22;
  int64x2_t v23;
  int8x16_t v24;
  int8x16_t v25;
  uint8x8_t v26;
  uint16x8_t v27;
  uint32x4_t v28;
  uint64x2_t v29;
  uint64x2_t v30;
  uint64x2_t v31;
  uint32x4_t v32;
  uint64x2_t v33;
  int8x16_t v34;
  uint16x8_t v35;
  int8x16_t v36;
  uint16x8_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x8_t v40;
  int8x16_t v41;
  int8x8_t v42;
  uint64x2_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  unint64_t v48;
  unsigned __int8 *v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int8 *v53;
  unsigned int v54;

  if (!a2)
    return 0;
  if (a2 > 15)
  {
    v4 = a2 | 0xF000000000000000;
    v5 = _allocateStringStorage(codeUnitCapacity:)(a2);
    *(_QWORD *)(v5 + 16) = v6;
    *(_QWORD *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
      v4 = *(_QWORD *)(v5 + 24);
    }
    *(_BYTE *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)(a1->i8, a2, (char *)(v5 + 32));
    return *(_QWORD *)(v5 + 24);
  }
  v8 = a2 - 8;
  v9 = 8;
  if (a2 < 8)
    v9 = a2;
  if ((v9 & 0x8000000000000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (v9 < 8)
  {
    v10 = 0;
    result = 0;
    v11 = 0;
    goto LABEL_20;
  }
  if (v9 >= 0x10)
  {
    v10 = v9 & 0xFFFFFFFFFFFFFFF0;
    v35 = vmovl_high_u8(*a1);
    v36 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v35.i8);
    v37 = vmovl_u8(*(uint8x8_t *)a1->i8);
    v38 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v37.i8);
    v39 = (int8x16_t)vmovl_high_u16(v35);
    v40 = (int8x8_t)vextq_s8(v39, v39, 8uLL).u64[0];
    v41 = (int8x16_t)vmovl_high_u16(v37);
    v42 = (int8x8_t)vextq_s8(v41, v41, 8uLL).u64[0];
    *(int8x8_t *)v41.i8 = vorr_s8(*(int8x8_t *)v41.i8, *(int8x8_t *)v39.i8);
    v43.i64[0] = v41.u32[0];
    v43.i64[1] = v41.u32[1];
    v44 = (int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1816ABC20);
    *(int8x8_t *)v39.i8 = vorr_s8(*(int8x8_t *)v38.i8, *(int8x8_t *)v36.i8);
    v43.i64[0] = v39.u32[0];
    v43.i64[1] = v39.u32[1];
    v45 = vorrq_s8((int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1816ABC10), v44);
    *(int8x8_t *)v39.i8 = vorr_s8(v42, v40);
    v43.i64[0] = v39.u32[0];
    v43.i64[1] = v39.u32[1];
    v46 = (int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1816ABC00);
    *(int8x8_t *)v36.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL));
    v43.i64[0] = v36.u32[0];
    v43.i64[1] = v36.u32[1];
    v47 = vorrq_s8(v45, vorrq_s8((int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_1816ABBF0), v46));
    result = (unint64_t)vorr_s8(*(int8x8_t *)v47.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL));
    if (v9 == (v9 & 0xFFFFFFFFFFFFFFF0))
      goto LABEL_22;
    v11 = 8 * v10;
    if ((v9 & 8) == 0)
      goto LABEL_20;
  }
  else
  {
    result = 0;
    v11 = 0;
    v10 = 0;
  }
  v12 = v10;
  v13 = vdupq_n_s64(v11);
  v10 = v9 & 0xFFFFFFFFFFFFFFF8;
  v11 = 8 * (v9 & 0xFFFFFFFFFFFFFFF8);
  v14 = 0uLL;
  v15 = (int8x16_t)result;
  v16 = vaddq_s64(v13, (int64x2_t)xmmword_1816ABC00);
  v17 = vaddq_s64(v13, (int64x2_t)xmmword_1816ABC20);
  v18 = vaddq_s64(v13, (int64x2_t)xmmword_1816ABBF0);
  v19 = vaddq_s64(v13, (int64x2_t)xmmword_1816ABC10);
  v20 = (uint8x8_t *)&a1->i8[v12];
  v21 = (int8x16_t)vdupq_n_s64(0x38uLL);
  v22 = v12 - (v9 & 0xFFFFFFFFFFFFFFF8);
  v23 = vdupq_n_s64(0x40uLL);
  v24 = 0uLL;
  v25 = 0uLL;
  do
  {
    v26 = *v20++;
    v27 = vmovl_u8(v26);
    v28 = vmovl_high_u16(v27);
    v29.i64[0] = v28.u32[2];
    v29.i64[1] = v28.u32[3];
    v30 = v29;
    v29.i64[0] = v28.u32[0];
    v29.i64[1] = v28.u32[1];
    v31 = v29;
    v32 = vmovl_u16(*(uint16x4_t *)v27.i8);
    v29.i64[0] = v32.u32[2];
    v29.i64[1] = v32.u32[3];
    v33 = v29;
    v29.i64[0] = v32.u32[0];
    v29.i64[1] = v32.u32[1];
    v25 = vorrq_s8((int8x16_t)vshlq_u64(v30, (uint64x2_t)vandq_s8((int8x16_t)v16, v21)), v25);
    v24 = vorrq_s8((int8x16_t)vshlq_u64(v31, (uint64x2_t)vandq_s8((int8x16_t)v17, v21)), v24);
    v14 = vorrq_s8((int8x16_t)vshlq_u64(v33, (uint64x2_t)vandq_s8((int8x16_t)v18, v21)), v14);
    v15 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)vandq_s8((int8x16_t)v19, v21)), v15);
    v17 = vaddq_s64(v17, v23);
    v18 = vaddq_s64(v18, v23);
    v19 = vaddq_s64(v19, v23);
    v16 = vaddq_s64(v16, v23);
    v22 += 8;
  }
  while (v22);
  v34 = vorrq_s8(vorrq_s8(v15, v24), vorrq_s8(v14, v25));
  result = (unint64_t)vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  if (v9 != v10)
  {
LABEL_20:
    v48 = v9 - v10;
    v49 = &a1->u8[v10];
    do
    {
      v50 = *v49++;
      result |= (unint64_t)v50 << (v11 & 0x38);
      v11 += 8;
      --v48;
    }
    while (v48);
  }
LABEL_22:
  if (a2 >= 9)
  {
    v51 = 0;
    v52 = 0;
    v53 = &a1->u8[8];
    do
    {
      v54 = *v53++;
      v51 |= (unint64_t)v54 << v52;
      v52 += 8;
      --v8;
    }
    while (v8);
  }
  return result;
}

unint64_t specialized static _UInt128.* infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  BOOL v4;
  BOOL v5;
  BOOL v6;
  _BOOL4 v7;
  BOOL v8;

  v4 = !is_mul_ok(a2, a3);
  v5 = !is_mul_ok(a1, a4);
  v6 = __CFADD__(a2 * a3, a1 * a4);
  v7 = __CFADD__(a2 * a3 + a1 * a4, (a3 * (unsigned __int128)a1) >> 64);
  if (a4)
    v8 = a2 == 0;
  else
    v8 = 1;
  if (!v8 || v4 || v5 || v6 || v7)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in *", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0xA3uLL, 0);
  return a3 * a1;
}

double specialized Double.init(sign:exponentBitPattern:significandBitPattern:)(uint64_t a1, __int16 a2, uint64_t a3)
{
  double result;

  *(_QWORD *)&result = ((unint64_t)(a2 & 0x7FF) << 52) | (a1 << 63) | a3 & 0xFFFFFFFFFFFFFLL;
  return result;
}

uint64_t specialized UnsafeMutableBufferPointer.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  BOOL v5;

  v3 = a3 - a1;
  if (__OFSUB__(a3, a1))
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x10FuLL, 0);
  if (a2 < 1)
  {
    if (v3 > 0 || v3 <= a2)
      goto LABEL_9;
    return 0;
  }
  if ((v3 & 0x8000000000000000) == 0 && v3 < (unint64_t)a2)
    return 0;
LABEL_9:
  v5 = __OFADD__(a1, a2);
  result = a1 + a2;
  if (v5)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x117uLL, 0);
  return result;
}

uint64_t specialized UInt8.init(ascii:)(uint64_t result)
{
  if (result >= 0x80)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Code point value does not fit into ASCII", 40, 2, "Swift/UnicodeScalar.swift", 25, 2, 0x16BuLL, 0);
  return result;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;

  v11 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(_QWORD *)(v11 + 16) = v12;
  *(_QWORD *)(v11 + 24) = 0x3000000000000000;
  if (v12 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v13 = *(_QWORD *)(v11 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v13 = 0;
  }
  *(_BYTE *)(v11 + 32 + v13) = 0;
  if (a1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  closure #1 in StaticBigInt.debugDescription.getter(v11 + 32, a1, a2, a3 & 1, a4, a5);
  if (v5)
  {
    swift_release(v11);
  }
  else
  {
    *(_QWORD *)(v11 + 24) = a2 | 0x3000000000000000;
    *(_BYTE *)(v11 + 32 + (a2 & 0xFFFFFFFFFFFFLL)) = 0;
  }
  return v11;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  Swift::Int v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char *v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unsigned __int8 v20;
  int v21;
  uint64_t v22;
  char *v23;
  unsigned int v25;
  unsigned int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  Swift::Int v62;
  uint64_t v63;
  char v64;
  char *v65;
  uint64_t v66;
  unsigned __int8 *v67;
  unsigned __int8 *i;
  unsigned int v69;
  unsigned int v70;
  unsigned __int8 *v71;
  unsigned int v72;
  unsigned __int8 *v73;
  unsigned int v74;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  size_t v80;
  uint64_t v81;

  v7 = (_QWORD *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2, a3, a4, a5);
  if (v6)
    return v5;
  v8 = v7;
  v9 = v7[3];
  v10 = v9 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0xFFFFFFFFFFFFLL) == 0)
    goto LABEL_20;
  v11 = (char *)(v7 + 4);
  v12 = (char *)(v7 + 4);
  if ((v9 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v7[5] | v7[4]) & 0x8080808080808080) != 0)
      goto LABEL_22;
    v12 = (char *)(v7 + 6);
    while (v12 < (char *)v7 + (v9 & 0xFFFFFFFFFFF0) + 32)
    {
      v13 = *(_QWORD *)v12;
      v14 = *((_QWORD *)v12 + 1);
      v12 += 16;
      if (((v14 | v13) & 0x8080808080808080) != 0)
        goto LABEL_22;
    }
  }
  if (v12 < &v11[v9 & 0xFFFFFFFFFFF8])
  {
    if ((*(_QWORD *)v12 & 0x8080808080808080) != 0)
      goto LABEL_22;
    v12 += 8;
  }
  if (v12 < &v11[v9 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v12 & 0x80808080) != 0)
      goto LABEL_22;
    v12 += 4;
  }
  if (v12 >= &v11[v9 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v12 >= &v11[v10] || (*v12 & 0x80000000) == 0)
    {
LABEL_20:
      v15 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v10, v15 & 1);
      return v8[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v12 & 0x8080) == 0)
  {
    v12 += 2;
    goto LABEL_18;
  }
LABEL_22:
  v16 = 0;
  v17 = &v11[v10];
  v15 = 1;
  v18 = (unsigned __int8 *)(v7 + 4);
  v19 = (unsigned __int8 *)(v7 + 4);
  while (1)
  {
    v21 = (char)*v19++;
    v20 = v21;
    if ((v21 & 0x80000000) == 0)
    {
      v22 = 1;
      goto LABEL_25;
    }
    if ((v20 + 11) <= 0xCCu)
      goto LABEL_68;
    if (v20 < 0xE0u)
    {
      if (v19 == (unsigned __int8 *)v17 || (*v19 & 0xC0) != 0x80)
        goto LABEL_68;
      v15 = 0;
      v19 = v18 + 2;
      v22 = 2;
      goto LABEL_25;
    }
    if (v20 == 224)
      break;
    if (v20 <= 0xECu)
      goto LABEL_50;
    if (v20 == 237)
    {
      if (v19 == (unsigned __int8 *)v17)
        goto LABEL_68;
      v25 = v18[1];
      if (v25 > 0x9F)
        goto LABEL_68;
LABEL_52:
      if ((v25 & 0xC0) != 0x80)
        goto LABEL_68;
      v23 = (char *)(v18 + 2);
      if (v18 + 2 == (unsigned __int8 *)v17)
        goto LABEL_68;
LABEL_54:
      if ((*v23 & 0xC0) != 0x80)
        goto LABEL_68;
      v15 = 0;
      v19 = v18 + 3;
      v22 = 3;
      goto LABEL_25;
    }
    if ((v20 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v19 == (unsigned __int8 *)v17)
        goto LABEL_68;
      LOBYTE(v25) = v18[1];
      goto LABEL_52;
    }
    if (v20 == 240)
    {
      if (v19 == (unsigned __int8 *)v17 || (v18[1] + 64) < 0xD0u)
        goto LABEL_68;
    }
    else
    {
      if ((v20 + 12) >= 0xFDu)
      {
        if (v19 == (unsigned __int8 *)v17)
          goto LABEL_68;
        LOBYTE(v26) = v18[1];
      }
      else
      {
        if (v19 == (unsigned __int8 *)v17)
          goto LABEL_68;
        v26 = v18[1];
        if (v26 > 0x8F)
          goto LABEL_68;
      }
      if ((v26 & 0xC0) != 0x80)
        goto LABEL_68;
    }
    if (v18 + 2 == (unsigned __int8 *)v17
      || (v18[2] & 0xC0) != 0x80
      || v18 + 3 == (unsigned __int8 *)v17
      || (v18[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    v15 = 0;
    v19 = v18 + 4;
    v22 = 4;
LABEL_25:
    v16 += v22;
    v18 = v19;
    if (v19 == (unsigned __int8 *)v17)
      goto LABEL_21;
  }
  if (v19 != (unsigned __int8 *)v17)
  {
    v23 = (char *)(v18 + 2);
    if ((v18[1] + 64) >= 0xE0u && v23 != v17)
      goto LABEL_54;
  }
LABEL_68:
  v27 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v27);
  v28 = specialized Collection.subscript.getter(v16, (uint64_t)(v8 + 4), v10);
  v32 = v28;
  v33 = v29;
  v34 = v30;
  v35 = v31;
  v36 = v28;
  if (v28 != v29)
  {
    specialized Slice.subscript.getter(v28, v28, v29, v30, v31);
    v36 = v32 + 1;
    if (__OFADD__(v32, 1))
    {
      v76 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v76, 0);
    }
  }
  v37 = 0;
  v38 = v33 + v32 - v36;
  if (v33 <= v36)
    v39 = v36;
  else
    v39 = v33;
  if (v35 <= v36)
    v40 = v36;
  else
    v40 = v35;
  v41 = v40 - v36;
  v42 = v39 - v36;
  do
  {
    if (v33 - v36 == v37)
      goto LABEL_87;
    if (v36 < v32)
    {
      v76 = 1812;
      goto LABEL_168;
    }
    if (v42 == v37)
    {
      v76 = 1813;
      goto LABEL_168;
    }
    if (v36 < 0)
    {
      v76 = 1781;
      goto LABEL_168;
    }
    if (v41 == v37)
    {
      v76 = 1782;
      goto LABEL_168;
    }
    if ((*(_BYTE *)(v34 + v36 + v37) & 0xC0) != 0x80)
      goto LABEL_86;
    v43 = v32 + v37++;
  }
  while (!__OFADD__(v43, 1));
  __break(1u);
LABEL_86:
  v38 = v32 + v37;
LABEL_87:
  if (v38 < v32)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  v44 = v38 + 1;
  if (__OFADD__(v38, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v33 < v44)
  {
LABEL_176:
    v76 = 1820;
    goto LABEL_168;
  }
  v45 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v32, v44, v34, v35);
  v47 = v46;
  v77 = (uint64_t)v8;
  v78 = 0;
  v48 = v8[3];
  v79 = 0xE000000000000000;
  v49 = v48 & 0xFFFFFFFFFFFFLL;
  if ((v48 & 0xFFFFFFFFFFFFLL) != 0)
  {
    v50 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v51 & 1) != 0 || v50 < v49 + 15)
      _StringGuts.grow(_:)(v49 + 15);
  }
  while (2)
  {
    if (v45 < 0)
      goto LABEL_169;
    v58 = v49;
    if (v49 < v45)
    {
      v76 = 1861;
      goto LABEL_168;
    }
    v59 = v79;
    v60 = v78 & 0xFFFFFFFFFFFFLL;
    if ((v79 & 0x2000000000000000) != 0)
      v60 = HIBYTE(v79) & 0xF;
    v61 = v60 + v58;
    v62 = v61 + 3;
    if (__OFADD__(v61, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v62 >= 16)
    {
      v63 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v64 & 1) != 0 || v63 < v62)
      {
        _StringGuts.grow(_:)(v62);
        v59 = v79;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v59 & 0xFFFFFFFFFFFFFFFLL, v11, v45, 0);
    v78 = *(_QWORD *)(v59 + 24);
    v80 = 3;
    v81 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v81, &v80, &v78);
    if (v58 < v47)
LABEL_169:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v47 < 0)
    {
LABEL_172:
      v76 = 1860;
      goto LABEL_168;
    }
    v49 = v58 - v47;
    if (v58 - v47 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    v65 = &v11[v47];
    if (_allASCII(_:)((uint64_t *)&v11[v47], v58 - v47))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v11[v47], v58 - v47, 0);
      break;
    }
    v66 = 0;
    v67 = (unsigned __int8 *)&v11[v58];
    if (!v11)
      v67 = 0;
    for (i = (unsigned __int8 *)&v11[v47]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v67)
          goto LABEL_161;
        v70 = *i++;
        v69 = v70;
        if ((v69 & 0x80) != 0)
          break;
        ++v66;
      }
      if ((v69 + 62) > 0x32u)
        goto LABEL_95;
      if (v69 > 0xDF)
        break;
      if (!i || i == v67 || (*i & 0xC0) != 0x80)
        goto LABEL_95;
      v66 += 2;
    }
    if (v69 == 224)
    {
      if (!i)
        goto LABEL_95;
      if (i == v67)
        goto LABEL_95;
      v71 = i + 1;
      if ((*i & 0xE0) != 0xA0)
        goto LABEL_95;
      goto LABEL_140;
    }
    if (v69 < 0xED)
      goto LABEL_136;
    if (v69 == 237)
    {
      if (!i)
        goto LABEL_95;
      if (i == v67)
        goto LABEL_95;
      v71 = i + 1;
      v72 = *i;
      if (v72 > 0x9F)
        goto LABEL_95;
      goto LABEL_139;
    }
    if (v69 < 0xF0)
    {
LABEL_136:
      if (!i || i == v67)
        goto LABEL_95;
      v71 = i + 1;
      LOBYTE(v72) = *i;
LABEL_139:
      if ((v72 & 0xC0) != 0x80)
        goto LABEL_95;
LABEL_140:
      if (v71 == v67 || (*v71 & 0xC0) != 0x80)
        goto LABEL_95;
      i += 2;
      v66 += 3;
      goto LABEL_113;
    }
    if (v69 == 240)
    {
      if (!i)
        goto LABEL_95;
      if (i == v67)
        goto LABEL_95;
      v73 = i + 1;
      if ((*i + 64) < 0xD0u)
        goto LABEL_95;
      goto LABEL_156;
    }
    if ((v69 + 15) < 3u)
    {
      if (!i || i == v67)
        goto LABEL_95;
      v73 = i + 1;
      LOBYTE(v74) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v67)
      {
        v73 = i + 1;
        v74 = *i;
        if (v74 <= 0x8F)
        {
LABEL_155:
          if ((v74 & 0xC0) != 0x80)
            goto LABEL_95;
LABEL_156:
          if (v73 == v67 || (i[1] & 0xC0) != 0x80 || i + 2 == v67 || (i[2] & 0xC0) != 0x80)
            goto LABEL_95;
          i += 3;
          v66 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    v52 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v52);
    v53 = specialized Collection.subscript.getter(v66, (uint64_t)&v11[v47], v58 - v47);
    v45 = findInvalidRange #1 (_:) in validateUTF8(_:)(v53, v54, v55, v56);
    v47 = v57;
    v11 = v65;
    if (v49)
      continue;
    break;
  }
  v5 = v78;
  swift_release(v77);
  return v5;
}

unint64_t specialized String.init(validatingUTF8:)(uint64_t a1)
{
  int64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t result;
  uint64_t v8;
  _BYTE *v9;
  char v10;
  _BYTE *v11;
  _BYTE *v12;
  unsigned __int8 v13;
  int v14;
  uint64_t v15;
  _BYTE *v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  int64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int64x2_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  uint8x8_t *v54;
  int8x16_t v55;
  unint64_t v56;
  int64x2_t v57;
  int8x16_t v58;
  int8x16_t v59;
  uint8x8_t v60;
  uint16x8_t v61;
  uint32x4_t v62;
  uint64x2_t v63;
  uint64x2_t v64;
  uint64x2_t v65;
  uint32x4_t v66;
  uint64x2_t v67;
  int8x16_t v68;
  int64x2_t v69;
  int64x2_t v70;
  int64x2_t v71;
  int64x2_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int64x2_t v75;
  unint64_t v76;
  uint8x16_t *v77;
  int64x2_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int64x2_t v81;
  int8x16_t v82;
  int8x16_t v83;
  int64x2_t v84;
  int8x16_t v85;
  int8x16_t v86;
  int64x2_t v87;
  int8x16_t v88;
  uint8x16_t v89;
  uint16x8_t v90;
  uint32x4_t v91;
  uint64x2_t v92;
  uint64x2_t v93;
  uint16x8_t v94;
  uint32x4_t v95;
  uint64x2_t v96;
  uint64x2_t v97;
  uint64x2_t v98;
  uint32x4_t v99;
  uint64x2_t v100;
  uint32x4_t v101;
  uint64x2_t v102;
  uint64x2_t v103;
  int8x16_t v104;
  unsigned __int8 *v105;
  unint64_t v106;
  unsigned int v107;
  unint64_t v108;
  int8x8_t v109;
  unint64_t v110;
  unint64_t v111;
  int64x2_t v112;
  int8x16_t v113;
  int8x16_t v114;
  int64x2_t v115;
  int64x2_t v116;
  int64x2_t v117;
  int64x2_t v118;
  uint8x8_t *v119;
  int8x16_t v120;
  unint64_t v121;
  int64x2_t v122;
  int8x16_t v123;
  int8x16_t v124;
  uint8x8_t v125;
  uint16x8_t v126;
  uint32x4_t v127;
  uint64x2_t v128;
  uint64x2_t v129;
  uint64x2_t v130;
  uint32x4_t v131;
  uint64x2_t v132;
  int8x16_t v133;
  uint8x16_t *v134;
  int64x2_t v135;
  int64x2_t v136;
  int64x2_t v137;
  int64x2_t v138;
  int64x2_t v139;
  int64x2_t v140;
  int8x16_t v141;
  int64x2_t v142;
  int64x2_t v143;
  int8x16_t v144;
  int8x16_t v145;
  int64x2_t v146;
  unint64_t v147;
  int8x16_t v148;
  int8x16_t v149;
  int8x16_t v150;
  int8x16_t v151;
  int8x16_t v152;
  int8x16_t v153;
  uint8x16_t v154;
  uint16x8_t v155;
  uint32x4_t v156;
  uint64x2_t v157;
  uint64x2_t v158;
  uint16x8_t v159;
  uint32x4_t v160;
  uint64x2_t v161;
  uint64x2_t v162;
  uint64x2_t v163;
  uint32x4_t v164;
  uint64x2_t v165;
  uint32x4_t v166;
  uint64x2_t v167;
  uint64x2_t v168;
  int8x16_t v169;
  uint64_t v170;
  unsigned __int8 *v171;
  unsigned int v172;
  unint64_t v173;

  v2 = _swift_stdlib_strlen((const char *)a1);
  if (v2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v3 = v2;
  if (!v2)
    return 0;
  v4 = (uint64_t *)a1;
  if ((v2 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((*(_QWORD *)(a1 + 8) | *(_QWORD *)a1) & 0x8080808080808080) != 0)
      goto LABEL_23;
    v4 = (uint64_t *)(a1 + 16);
    while ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFF0))
    {
      v5 = *v4;
      v6 = v4[1];
      v4 += 2;
      if (((v6 | v5) & 0x8080808080808080) != 0)
        goto LABEL_23;
    }
  }
  if ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFF8))
  {
    if ((*v4 & 0x8080808080808080) != 0)
      goto LABEL_23;
    ++v4;
  }
  if ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFFCLL))
  {
    if ((*(_DWORD *)v4 & 0x80808080) != 0)
      goto LABEL_23;
    v4 = (uint64_t *)((char *)v4 + 4);
  }
  if ((unint64_t)v4 >= a1 + (v2 & 0xFFFFFFFFFFFFFFFELL))
  {
LABEL_19:
    if ((unint64_t)v4 >= a1 + v2 || (*(char *)v4 & 0x80000000) == 0)
    {
      if (v2 > 15)
        goto LABEL_94;
LABEL_98:
      v42 = v2 - 8;
      v43 = 8;
      if (v2 < 8)
        v43 = v2;
      if ((v43 & (unint64_t)~(v43 >> 63)) <= v43 - 1)
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
      if ((unint64_t)v43 < 8)
      {
        v44 = 0;
        result = 0;
        v45 = 0;
        goto LABEL_114;
      }
      if ((unint64_t)v43 >= 0x10)
      {
        v44 = v43 & 0xFFFFFFFFFFFFFFF0;
        v69 = (int64x2_t)xmmword_1816ABCA0;
        v70 = (int64x2_t)xmmword_1816ABCB0;
        v71 = (int64x2_t)xmmword_1816ABCC0;
        v72 = (int64x2_t)xmmword_1816ABCD0;
        v45 = 8 * (v43 & 0xFFFFFFFFFFFFFFF0);
        v73 = 0uLL;
        v74 = (int8x16_t)vdupq_n_s64(0x38uLL);
        v75 = vdupq_n_s64(0x80uLL);
        v76 = v43 & 0xFFFFFFFFFFFFFFF0;
        v77 = (uint8x16_t *)a1;
        v78 = (int64x2_t)xmmword_1816ABC00;
        v79 = 0uLL;
        v80 = 0uLL;
        v81 = (int64x2_t)xmmword_1816ABC20;
        v82 = 0uLL;
        v83 = 0uLL;
        v84 = (int64x2_t)xmmword_1816ABBF0;
        v85 = 0uLL;
        v86 = 0uLL;
        v87 = (int64x2_t)xmmword_1816ABC10;
        v88 = 0uLL;
        do
        {
          v89 = *v77++;
          v90 = vmovl_u8(*(uint8x8_t *)v89.i8);
          v91 = vmovl_high_u16(v90);
          v92.i64[0] = v91.u32[2];
          v92.i64[1] = v91.u32[3];
          v93 = v92;
          v94 = vmovl_high_u8(v89);
          v95 = vmovl_u16(*(uint16x4_t *)v94.i8);
          v92.i64[0] = v95.u32[2];
          v92.i64[1] = v95.u32[3];
          v96 = v92;
          v92.i64[0] = v95.u32[0];
          v92.i64[1] = v95.u32[1];
          v97 = v92;
          v92.i64[0] = v91.u32[0];
          v92.i64[1] = v91.u32[1];
          v98 = v92;
          v99 = vmovl_u16(*(uint16x4_t *)v90.i8);
          v92.i64[0] = v99.u32[2];
          v92.i64[1] = v99.u32[3];
          v100 = v92;
          v101 = vmovl_high_u16(v94);
          v92.i64[0] = v101.u32[0];
          v92.i64[1] = v101.u32[1];
          v102 = v92;
          v92.i64[0] = v99.u32[0];
          v92.i64[1] = v99.u32[1];
          v103 = v92;
          v92.i64[0] = v101.u32[2];
          v92.i64[1] = v101.u32[3];
          v82 = vorrq_s8((int8x16_t)vshlq_u64(v93, (uint64x2_t)vandq_s8((int8x16_t)v78, v74)), v82);
          v85 = vorrq_s8((int8x16_t)vshlq_u64(v96, (uint64x2_t)vandq_s8((int8x16_t)v71, v74)), v85);
          v83 = vorrq_s8((int8x16_t)vshlq_u64(v97, (uint64x2_t)vandq_s8((int8x16_t)v72, v74)), v83);
          v80 = vorrq_s8((int8x16_t)vshlq_u64(v98, (uint64x2_t)vandq_s8((int8x16_t)v81, v74)), v80);
          v79 = vorrq_s8((int8x16_t)vshlq_u64(v100, (uint64x2_t)vandq_s8((int8x16_t)v84, v74)), v79);
          v86 = vorrq_s8((int8x16_t)vshlq_u64(v102, (uint64x2_t)vandq_s8((int8x16_t)v70, v74)), v86);
          v73 = vorrq_s8((int8x16_t)vshlq_u64(v103, (uint64x2_t)vandq_s8((int8x16_t)v87, v74)), v73);
          v88 = vorrq_s8((int8x16_t)vshlq_u64(v92, (uint64x2_t)vandq_s8((int8x16_t)v69, v74)), v88);
          v81 = vaddq_s64(v81, v75);
          v84 = vaddq_s64(v84, v75);
          v87 = vaddq_s64(v87, v75);
          v78 = vaddq_s64(v78, v75);
          v72 = vaddq_s64(v72, v75);
          v71 = vaddq_s64(v71, v75);
          v70 = vaddq_s64(v70, v75);
          v69 = vaddq_s64(v69, v75);
          v76 -= 16;
        }
        while (v76);
        v104 = vorrq_s8(vorrq_s8(vorrq_s8(v73, v83), vorrq_s8(v80, v86)), vorrq_s8(vorrq_s8(v79, v85), vorrq_s8(v82, v88)));
        result = (unint64_t)vorr_s8(*(int8x8_t *)v104.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v104, v104, 8uLL));
        if (v43 == v44)
          goto LABEL_116;
        if ((v43 & 8) == 0)
        {
LABEL_114:
          v105 = (unsigned __int8 *)(a1 + v44);
          v106 = v43 - v44;
          do
          {
            v107 = *v105++;
            result |= (unint64_t)v107 << (v45 & 0x38);
            v45 += 8;
            --v106;
          }
          while (v106);
          goto LABEL_116;
        }
      }
      else
      {
        result = 0;
        v45 = 0;
        v44 = 0;
      }
      v46 = v44;
      v47 = vdupq_n_s64(v45);
      v44 = v43 & 0xFFFFFFFFFFFFFFF8;
      v45 = 8 * (v43 & 0xFFFFFFFFFFFFFFF8);
      v48 = 0uLL;
      v49 = (int8x16_t)result;
      v50 = vaddq_s64(v47, (int64x2_t)xmmword_1816ABC00);
      v51 = vaddq_s64(v47, (int64x2_t)xmmword_1816ABC20);
      v52 = vaddq_s64(v47, (int64x2_t)xmmword_1816ABBF0);
      v53 = vaddq_s64(v47, (int64x2_t)xmmword_1816ABC10);
      v54 = (uint8x8_t *)(a1 + v46);
      v55 = (int8x16_t)vdupq_n_s64(0x38uLL);
      v56 = v46 - (v43 & 0xFFFFFFFFFFFFFFF8);
      v57 = vdupq_n_s64(0x40uLL);
      v58 = 0uLL;
      v59 = 0uLL;
      do
      {
        v60 = *v54++;
        v61 = vmovl_u8(v60);
        v62 = vmovl_high_u16(v61);
        v63.i64[0] = v62.u32[2];
        v63.i64[1] = v62.u32[3];
        v64 = v63;
        v63.i64[0] = v62.u32[0];
        v63.i64[1] = v62.u32[1];
        v65 = v63;
        v66 = vmovl_u16(*(uint16x4_t *)v61.i8);
        v63.i64[0] = v66.u32[2];
        v63.i64[1] = v66.u32[3];
        v67 = v63;
        v63.i64[0] = v66.u32[0];
        v63.i64[1] = v66.u32[1];
        v59 = vorrq_s8((int8x16_t)vshlq_u64(v64, (uint64x2_t)vandq_s8((int8x16_t)v50, v55)), v59);
        v58 = vorrq_s8((int8x16_t)vshlq_u64(v65, (uint64x2_t)vandq_s8((int8x16_t)v51, v55)), v58);
        v48 = vorrq_s8((int8x16_t)vshlq_u64(v67, (uint64x2_t)vandq_s8((int8x16_t)v52, v55)), v48);
        v49 = vorrq_s8((int8x16_t)vshlq_u64(v63, (uint64x2_t)vandq_s8((int8x16_t)v53, v55)), v49);
        v51 = vaddq_s64(v51, v57);
        v52 = vaddq_s64(v52, v57);
        v53 = vaddq_s64(v53, v57);
        v50 = vaddq_s64(v50, v57);
        v56 += 8;
      }
      while (v56);
      v68 = vorrq_s8(vorrq_s8(v49, v58), vorrq_s8(v48, v59));
      result = (unint64_t)vorr_s8(*(int8x8_t *)v68.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
      if (v43 != v44)
        goto LABEL_114;
LABEL_116:
      if (v3 < 9)
        return result;
      if (v42 < 8)
      {
        v108 = 0;
        v109 = 0;
        v110 = 0;
        goto LABEL_130;
      }
      if (v42 >= 0x10)
      {
        v134 = (uint8x16_t *)(a1 + 8);
        v108 = v42 & 0xFFFFFFFFFFFFFFF0;
        v135 = (int64x2_t)xmmword_1816ABCA0;
        v136 = (int64x2_t)xmmword_1816ABCB0;
        v137 = (int64x2_t)xmmword_1816ABCC0;
        v138 = (int64x2_t)xmmword_1816ABCD0;
        v139 = (int64x2_t)xmmword_1816ABC00;
        v140 = (int64x2_t)xmmword_1816ABC20;
        v141 = (int8x16_t)vdupq_n_s64(0x38uLL);
        v142 = vdupq_n_s64(0x80uLL);
        v143 = (int64x2_t)xmmword_1816ABBF0;
        v110 = 8 * (v42 & 0xFFFFFFFFFFFFFFF0);
        v144 = 0uLL;
        v145 = 0uLL;
        v146 = (int64x2_t)xmmword_1816ABC10;
        v147 = v42 & 0xFFFFFFFFFFFFFFF0;
        v148 = 0uLL;
        v149 = 0uLL;
        v150 = 0uLL;
        v151 = 0uLL;
        v152 = 0uLL;
        v153 = 0uLL;
        do
        {
          v154 = *v134++;
          v155 = vmovl_u8(*(uint8x8_t *)v154.i8);
          v156 = vmovl_high_u16(v155);
          v157.i64[0] = v156.u32[2];
          v157.i64[1] = v156.u32[3];
          v158 = v157;
          v159 = vmovl_high_u8(v154);
          v160 = vmovl_u16(*(uint16x4_t *)v159.i8);
          v157.i64[0] = v160.u32[2];
          v157.i64[1] = v160.u32[3];
          v161 = v157;
          v157.i64[0] = v160.u32[0];
          v157.i64[1] = v160.u32[1];
          v162 = v157;
          v157.i64[0] = v156.u32[0];
          v157.i64[1] = v156.u32[1];
          v163 = v157;
          v164 = vmovl_u16(*(uint16x4_t *)v155.i8);
          v157.i64[0] = v164.u32[2];
          v157.i64[1] = v164.u32[3];
          v165 = v157;
          v166 = vmovl_high_u16(v159);
          v157.i64[0] = v166.u32[0];
          v157.i64[1] = v166.u32[1];
          v167 = v157;
          v157.i64[0] = v164.u32[0];
          v157.i64[1] = v164.u32[1];
          v168 = v157;
          v157.i64[0] = v166.u32[2];
          v157.i64[1] = v166.u32[3];
          v149 = vorrq_s8((int8x16_t)vshlq_u64(v158, (uint64x2_t)vandq_s8((int8x16_t)v139, v141)), v149);
          v151 = vorrq_s8((int8x16_t)vshlq_u64(v161, (uint64x2_t)vandq_s8((int8x16_t)v137, v141)), v151);
          v150 = vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)vandq_s8((int8x16_t)v138, v141)), v150);
          v148 = vorrq_s8((int8x16_t)vshlq_u64(v163, (uint64x2_t)vandq_s8((int8x16_t)v140, v141)), v148);
          v145 = vorrq_s8((int8x16_t)vshlq_u64(v165, (uint64x2_t)vandq_s8((int8x16_t)v143, v141)), v145);
          v152 = vorrq_s8((int8x16_t)vshlq_u64(v167, (uint64x2_t)vandq_s8((int8x16_t)v136, v141)), v152);
          v144 = vorrq_s8((int8x16_t)vshlq_u64(v168, (uint64x2_t)vandq_s8((int8x16_t)v146, v141)), v144);
          v153 = vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)vandq_s8((int8x16_t)v135, v141)), v153);
          v140 = vaddq_s64(v140, v142);
          v143 = vaddq_s64(v143, v142);
          v146 = vaddq_s64(v146, v142);
          v139 = vaddq_s64(v139, v142);
          v138 = vaddq_s64(v138, v142);
          v137 = vaddq_s64(v137, v142);
          v136 = vaddq_s64(v136, v142);
          v135 = vaddq_s64(v135, v142);
          v147 -= 16;
        }
        while (v147);
        v169 = vorrq_s8(vorrq_s8(vorrq_s8(v144, v150), vorrq_s8(v148, v152)), vorrq_s8(vorrq_s8(v145, v151), vorrq_s8(v149, v153)));
        v109 = vorr_s8(*(int8x8_t *)v169.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v169, v169, 8uLL));
        if (v42 == v108)
          return result;
        if ((v42 & 8) == 0)
        {
LABEL_130:
          v170 = v3 - v108 - 8;
          v171 = (unsigned __int8 *)(v108 + a1 + 8);
          do
          {
            v172 = *v171++;
            *(_QWORD *)&v109 |= (unint64_t)v172 << (v110 & 0x38);
            v110 += 8;
            --v170;
          }
          while (v170);
          return result;
        }
      }
      else
      {
        v109 = 0;
        v110 = 0;
        v108 = 0;
      }
      v111 = v108;
      v108 = v42 & 0xFFFFFFFFFFFFFFF8;
      v112 = vdupq_n_s64(v110);
      v110 = 8 * (v42 & 0xFFFFFFFFFFFFFFF8);
      v113 = (int8x16_t)(unint64_t)v109;
      v114 = 0uLL;
      v115 = vaddq_s64(v112, (int64x2_t)xmmword_1816ABC00);
      v116 = vaddq_s64(v112, (int64x2_t)xmmword_1816ABC20);
      v117 = vaddq_s64(v112, (int64x2_t)xmmword_1816ABBF0);
      v118 = vaddq_s64(v112, (int64x2_t)xmmword_1816ABC10);
      v119 = (uint8x8_t *)(v111 + a1 + 8);
      v120 = (int8x16_t)vdupq_n_s64(0x38uLL);
      v121 = v111 - (v42 & 0xFFFFFFFFFFFFFFF8);
      v122 = vdupq_n_s64(0x40uLL);
      v123 = 0uLL;
      v124 = 0uLL;
      do
      {
        v125 = *v119++;
        v126 = vmovl_u8(v125);
        v127 = vmovl_high_u16(v126);
        v128.i64[0] = v127.u32[2];
        v128.i64[1] = v127.u32[3];
        v129 = v128;
        v128.i64[0] = v127.u32[0];
        v128.i64[1] = v127.u32[1];
        v130 = v128;
        v131 = vmovl_u16(*(uint16x4_t *)v126.i8);
        v128.i64[0] = v131.u32[2];
        v128.i64[1] = v131.u32[3];
        v132 = v128;
        v128.i64[0] = v131.u32[0];
        v128.i64[1] = v131.u32[1];
        v124 = vorrq_s8((int8x16_t)vshlq_u64(v129, (uint64x2_t)vandq_s8((int8x16_t)v115, v120)), v124);
        v123 = vorrq_s8((int8x16_t)vshlq_u64(v130, (uint64x2_t)vandq_s8((int8x16_t)v116, v120)), v123);
        v114 = vorrq_s8((int8x16_t)vshlq_u64(v132, (uint64x2_t)vandq_s8((int8x16_t)v117, v120)), v114);
        v113 = vorrq_s8((int8x16_t)vshlq_u64(v128, (uint64x2_t)vandq_s8((int8x16_t)v118, v120)), v113);
        v116 = vaddq_s64(v116, v122);
        v117 = vaddq_s64(v117, v122);
        v118 = vaddq_s64(v118, v122);
        v115 = vaddq_s64(v115, v122);
        v121 += 8;
      }
      while (v121);
      v133 = vorrq_s8(vorrq_s8(v113, v123), vorrq_s8(v114, v124));
      v109 = vorr_s8(*(int8x8_t *)v133.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v133, v133, 8uLL));
      if (v42 == v108)
        return result;
      goto LABEL_130;
    }
    goto LABEL_23;
  }
  if ((*(_WORD *)v4 & 0x8080) == 0)
  {
    v4 = (uint64_t *)((char *)v4 + 2);
    goto LABEL_19;
  }
LABEL_23:
  v8 = 0;
  v9 = (_BYTE *)(a1 + v2);
  v10 = 1;
  v11 = (_BYTE *)a1;
  v12 = (_BYTE *)a1;
  do
  {
    v14 = (char)*v12++;
    v13 = v14;
    if ((v14 & 0x80000000) == 0)
    {
      v15 = 1;
      goto LABEL_26;
    }
    if ((v13 + 11) <= 0xCCu)
      goto LABEL_69;
    if (v13 <= 0xDFu)
    {
      if (v12 == v9 || (*v12 & 0xC0) != 0x80)
        goto LABEL_69;
      v10 = 0;
      v12 = v11 + 2;
      v15 = 2;
    }
    else
    {
      if (v13 == 224)
      {
        if (v12 == v9
          || ((v16 = v11 + 2, (v11[1] + 64) >= 0xE0u) ? (v17 = v16 == v9) : (v17 = 1), v17))
        {
LABEL_69:
          v20 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
          swift_willThrow();
          swift_errorRelease(v20);
          v21 = specialized Collection.subscript.getter(v8, a1, v3);
          v25 = v21;
          v26 = v22;
          v27 = v23;
          v28 = v24;
          v29 = v21;
          if (v21 != v22
            && (specialized Slice.subscript.getter(v21, v21, v22, v23, v24), v29 = v25 + 1, __OFADD__(v25, 1)))
          {
            v173 = 1525;
          }
          else
          {
            v30 = 0;
            v31 = v26 + v25 - v29;
            if (v26 <= v29)
              v32 = v29;
            else
              v32 = v26;
            if (v28 <= v29)
              v33 = v29;
            else
              v33 = v28;
            v34 = v33 - v29;
            v35 = v32 - v29;
            do
            {
              if (v26 - v29 == v30)
                goto LABEL_88;
              if (v29 < v25)
              {
                v173 = 1812;
                goto LABEL_137;
              }
              if (v35 == v30)
              {
                v173 = 1813;
                goto LABEL_137;
              }
              if (v29 < 0)
              {
                v173 = 1781;
                goto LABEL_137;
              }
              if (v34 == v30)
              {
                v173 = 1782;
                goto LABEL_137;
              }
              if ((*(_BYTE *)(v27 + v29 + v30) & 0xC0) != 0x80)
                goto LABEL_87;
              v36 = v25 + v30++;
            }
            while (!__OFADD__(v36, 1));
            __break(1u);
LABEL_87:
            v31 = v25 + v30;
LABEL_88:
            if (v31 < v25)
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
            v37 = v31 + 1;
            if (__OFADD__(v31, 1))
            {
              __break(1u);
            }
            else if (v26 >= v37)
            {
              _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v25, v37, v27, v28);
              return 0;
            }
            v173 = 1820;
          }
LABEL_137:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v173, 0);
        }
        goto LABEL_55;
      }
      if (v13 <= 0xECu)
        goto LABEL_51;
      if (v13 == 237)
      {
        if (v12 == v9)
          goto LABEL_69;
        v18 = v11[1];
        if (v18 > 0x9F)
          goto LABEL_69;
LABEL_53:
        if ((v18 & 0xC0) != 0x80)
          goto LABEL_69;
        v16 = v11 + 2;
        if (v11 + 2 == v9)
          goto LABEL_69;
LABEL_55:
        if ((*v16 & 0xC0) != 0x80)
          goto LABEL_69;
        v10 = 0;
        v12 = v11 + 3;
        v15 = 3;
        goto LABEL_26;
      }
      if ((v13 + 16) >= 0xFEu)
      {
LABEL_51:
        if (v12 == v9)
          goto LABEL_69;
        LOBYTE(v18) = v11[1];
        goto LABEL_53;
      }
      if (v13 == 240)
      {
        if (v12 == v9 || (v11[1] + 64) < 0xD0u)
          goto LABEL_69;
      }
      else
      {
        if ((v13 + 12) >= 0xFDu)
        {
          if (v12 == v9)
            goto LABEL_69;
          LOBYTE(v19) = v11[1];
        }
        else
        {
          if (v12 == v9)
            goto LABEL_69;
          v19 = v11[1];
          if (v19 > 0x8F)
            goto LABEL_69;
        }
        if ((v19 & 0xC0) != 0x80)
          goto LABEL_69;
      }
      if (v11 + 2 == v9 || (v11[2] & 0xC0) != 0x80 || v11 + 3 == v9 || (v11[3] & 0xC0) != 0x80)
        goto LABEL_69;
      v10 = 0;
      v12 = v11 + 4;
      v15 = 4;
    }
LABEL_26:
    v8 += v15;
    v11 = v12;
  }
  while (v12 != v9);
  if (v2 <= 15)
    goto LABEL_98;
  v38 = v2;
  if ((v10 & 1) != 0)
LABEL_94:
    v38 = v2 | 0xC000000000000000;
  v39 = v38 | 0x3000000000000000;
  v40 = _allocateStringStorage(codeUnitCapacity:)(v2);
  *(_QWORD *)(v40 + 16) = v41;
  *(_QWORD *)(v40 + 24) = v39;
  if (v41 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v39 = *(_QWORD *)(v40 + 24);
  }
  *(_BYTE *)(v40 + 32 + (v39 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)a1, v3, (char *)(v40 + 32));
  return *(_QWORD *)(v40 + 24);
}

uint64_t specialized Collection._makeKeyValuePairDescription<A, B>(withTypeName:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *TupleTypeMetadata2;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t AssociatedTypeWitness;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  void (*v29)(uint64_t, uint64_t);
  char v30;
  uint64_t v31;
  char *v32;
  _QWORD *v33;
  _QWORD *v34;
  char *v35;
  char *v36;
  void (*v37)(char *, char *, uint64_t);
  unint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  BOOL v51;
  uint64_t v52;
  uint64_t v53;
  int64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  unint64_t v59;
  Swift::String::Index v60;
  Swift::String::Index v61;
  Swift::String::Index v62;
  Swift::String::Index v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  char v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  int64_t v82;
  char v83;
  BOOL v85;
  uint64_t v86;
  uint64_t v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  size_t v92;
  unint64_t v93;
  uint64_t v94;
  _QWORD *inited;
  char *boxed_opaque_existential_0Tm;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  char v106;
  uint64_t v107;
  uint64_t v108;
  int64_t v109;
  char v110;
  uint64_t v111;
  uint64_t v112;
  char *v113;
  unint64_t v114;
  Swift::String::Index v115;
  Swift::String::Index v116;
  Swift::String::Index v117;
  Swift::String::Index v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  char v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  char v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  int64_t v137;
  char v138;
  uint64_t v140;
  uint64_t v141;
  char v142;
  uint64_t v143;
  uint64_t v144;
  char *v145;
  size_t v146;
  unint64_t v147;
  Swift::Int v148;
  unsigned __int8 *v149;
  uint64_t v150;
  unsigned __int8 *v151;
  unsigned __int8 *v152;
  uint64_t v153;
  unsigned __int8 *v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  char *v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  int64_t v166;
  char v167;
  int64_t v168;
  char v169;
  BOOL v171;
  uint64_t v172;
  uint64_t v173;
  char *v174;
  Swift::String::Index v175;
  Swift::String::Index v176;
  Swift::String::Index v177;
  Swift::String::Index v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  char v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  char v188;
  uint64_t v189;
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  uint64_t v193;
  char v194;
  uint64_t v195;
  uint64_t v196;
  char *v197;
  size_t v198;
  Swift::Int v200;
  unsigned __int8 *v201;
  uint64_t v202;
  unsigned __int8 *v203;
  unint64_t v204;
  uint64_t v205;
  uint64_t v206;
  unint64_t v207;
  uint64_t v208;
  uint64_t v209;
  __int128 v210;
  __int128 v211;
  uint64_t v212;
  unint64_t *i;
  char *v214;
  void (*v215)(unint64_t, unint64_t);
  unint64_t AssociatedConformanceWitness;
  uint64_t v217;
  uint64_t v218;
  char *v219;
  unint64_t v220;
  char *v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  char *v225;
  __int128 v226;
  uint64_t v227[8];
  uint64_t v228[3];
  __int128 v229;
  uint64_t v230;
  unint64_t v231;

  v5 = a3;
  v218 = *(_QWORD *)(a3 - 8);
  v7 = MEMORY[0x1E0C80A78](a1);
  v9 = (char *)&v208 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  v217 = *(_QWORD *)(v10 - 8);
  MEMORY[0x1E0C80A78](v7);
  v225 = (char *)&v208 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v224 = v12;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, v12, v13, "key value ", 0);
  v223 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v15, v16);
  v222 = *(_QWORD *)(v223 - 8);
  v17 = MEMORY[0x1E0C80A78](v223);
  v221 = (char *)&v208 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  v19 = MEMORY[0x1E0C80A78](v17);
  v21 = (char *)&v208 - v20;
  v220 = *(_QWORD *)(a1 - 8);
  MEMORY[0x1E0C80A78](v19);
  v23 = (char *)&v208 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  v24 = *(_QWORD *)(a4 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v24, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v209 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v27 = (char *)&v208 - v26;
  if (((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 104))(a1, a4) & 1) != 0)
    return 6109787;
  v230 = 91;
  v231 = 0xE100000000000000;
  (*(void (**)(char *, _QWORD, uint64_t))(v220 + 16))(v23, v226, a1);
  v29 = *(void (**)(uint64_t, uint64_t))(v24 + 32);
  v219 = v27;
  v29(a1, v24);
  v220 = AssociatedTypeWitness;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v24, a1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v215 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v30 = 1;
  v226 = xmmword_1816ABBA0;
  v211 = xmmword_1816ABC50;
  v28 = -255;
  v210 = xmmword_1816ABBB0;
  v212 = v5;
  v31 = v224;
  v32 = v225;
  v214 = v9;
  for (i = TupleTypeMetadata2; ; TupleTypeMetadata2 = i)
  {
    v35 = v221;
    v215(v220, AssociatedConformanceWitness);
    (*(void (**)(char *, char *, uint64_t))(v222 + 32))(v21, v35, v223);
    if ((*(unsigned int (**)(char *, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 48))(v21, 1, TupleTypeMetadata2) == 1)break;
    v36 = &v21[*((int *)TupleTypeMetadata2 + 12)];
    v37 = *(void (**)(char *, char *, uint64_t))(v217 + 32);
    v37(v32, v21, v31);
    v38 = *(_QWORD *)(v218 + 32);
    ((void (*)(char *, char *, uint64_t))v38)(v9, v36, v5);
    if ((v30 & 1) != 0)
      goto LABEL_76;
    v42 = v230;
    v41 = v231;
    v43 = HIBYTE(v231) & 0xF;
    v44 = v230 & 0xFFFFFFFFFFFFLL;
    if ((v231 & 0x2000000000000000) != 0)
      v45 = HIBYTE(v231) & 0xF;
    else
      v45 = v230 & 0xFFFFFFFFFFFFLL;
    if (v45 || (v230 & ~v231 & 0x2000000000000000) != 0)
    {
      if ((v231 & 0x2000000000000000) != 0 && v43 <= 0xD)
      {
        v46 = 8 * (HIBYTE(v231) & 7);
        v47 = (-255 << v46) - 1;
        v48 = 44 << v46;
        v49 = v43 + 1;
        if (v43 >= 8)
        {
          v50 = v48 | v47 & v231;
          v31 = v224;
LABEL_59:
          v86 = (32 << (8 * (v49 & 7u))) | ((-255 << (8 * (v49 & 7u))) - 1) & v50;
        }
        else
        {
          v42 = v48 | v47 & v230;
          v31 = v224;
          if (v43 == 7)
          {
            v49 = 8;
            v50 = v231;
            goto LABEL_59;
          }
          v42 = (32 << (8 * (v49 & 7u))) | ((-255 << (8 * (v49 & 7u))) - 1) & v42;
          v86 = v231;
        }
        swift_bridgeObjectRelease(v231);
        swift_bridgeObjectRelease(0xE200000000000000);
        v93 = 0xE000000000000000;
        if (v42 & 0x8080808080808080 | v86 & 0x80808080808080)
          v93 = 0xA000000000000000;
        v230 = v42;
        v231 = (v93 & 0xFF00000000000000 | (v43 << 56) | v86 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
        goto LABEL_75;
      }
      swift_bridgeObjectRetain_n(0xE200000000000000, 6, v39, v40);
      if ((v41 & 0x1000000000000000) != 0)
        v45 = String.UTF8View._foreignCount()();
      v51 = __OFADD__(v45, 2);
      v52 = v45 + 2;
      v32 = v225;
      if (v51)
        goto LABEL_227;
      v53 = v42 & ~v41;
      if ((v53 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
      {
        v54 = _StringGuts.nativeUnusedCapacity.getter(v42, v41);
        if ((v55 & 1) != 0)
          goto LABEL_243;
        if (v52 > 15)
        {
LABEL_48:
          v82 = _StringGuts.nativeUnusedCapacity.getter(v42, v41);
          v85 = (v83 & 1) == 0 && v82 > 1;
          if ((v53 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
          {
            v5 = v212;
            if (v85)
              goto LABEL_68;
LABEL_61:
            v87 = _StringGuts.nativeCapacity.getter(v42, v41);
            if ((v88 & 1) != 0)
              v89 = 0;
            else
              v89 = v87;
            if (v89 + 0x4000000000000000 < 0)
              goto LABEL_229;
            v90 = 2 * v89;
            if (v90 > v52)
              v52 = v90;
          }
          else
          {
            v5 = v212;
            if (!v85)
              goto LABEL_61;
          }
          _StringGuts.grow(_:)(v52);
LABEL_68:
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          v229 = v210;
          v91 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v229, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v91, v92, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
          v31 = v224;
          goto LABEL_76;
        }
        if ((v41 & 0x2000000000000000) == 0)
        {
          if (v54 > 1)
            goto LABEL_48;
          goto LABEL_28;
        }
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
LABEL_29:
        v59 = v41;
      }
      else
      {
        if (v52 > 15)
          goto LABEL_48;
LABEL_28:
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        if ((v41 & 0x2000000000000000) != 0)
          goto LABEL_29;
        if ((v41 & 0x1000000000000000) != 0)
        {
          v42 = _StringGuts._foreignConvertedToSmall()(v42, v41);
          v59 = v160;
        }
        else
        {
          if ((v42 & 0x1000000000000000) != 0)
          {
            v154 = (unsigned __int8 *)((v41 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            v154 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v42, v41);
            v44 = v56;
          }
          swift_bridgeObjectRetain(v41, v56, v57, v58);
          closure #1 in _StringGuts._convertedToSmall()(v154, v44, &v229);
          swift_bridgeObjectRelease(v41);
          v59 = *((_QWORD *)&v229 + 1);
          v42 = v229;
        }
      }
      v60._rawBits = 1;
      v61._rawBits = 131073;
      v62._rawBits = _StringGuts.validateScalarRange(_:)(v60, v61, 0x202CuLL, 0xE200000000000000);
      if (v62._rawBits < 0x10000)
        v62._rawBits |= 3;
      v64 = specialized String.init(_:)(v62, v63, 0x202CuLL, 0xE200000000000000);
      v66 = v65;
      swift_bridgeObjectRelease(0xE200000000000000);
      if ((v66 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v66);
      }
      else if ((v66 & 0x1000000000000000) != 0)
      {
        v64 = _StringGuts._foreignConvertedToSmall()(v64, v66);
        v159 = v158;
        swift_bridgeObjectRelease(v66);
        v66 = v159;
      }
      else
      {
        if ((v64 & 0x1000000000000000) != 0)
        {
          v152 = (unsigned __int8 *)((v66 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v153 = v64 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v152 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v64, v66);
        }
        closure #1 in _StringGuts._convertedToSmall()(v152, v153, &v229);
        swift_bridgeObjectRelease(v66);
        v66 = *((_QWORD *)&v229 + 1);
        v64 = v229;
      }
      v67 = HIBYTE(v59) & 0xF;
      v68 = HIBYTE(v66) & 0xF;
      v69 = v68 + v67;
      if ((unint64_t)(v68 + v67) > 0xF)
        goto LABEL_242;
      if (v68)
      {
        v70 = 0;
        v71 = 0;
        do
        {
          v72 = v67 + v71;
          v73 = v71 + 1;
          if (v71 >= 8)
            v74 = v66;
          else
            v74 = v64;
          v75 = v74 >> (v70 & 0x38);
          v76 = (8 * v67 + v70) & 0x38;
          v77 = (-255 << v76) - 1;
          v78 = (unint64_t)v75 << v76;
          v79 = v78 | v77 & v59;
          v80 = v78 | v77 & v42;
          if (v72 < 8)
            v42 = v80;
          else
            v59 = v79;
          v70 += 8;
          v71 = v73;
        }
        while (v68 != v73);
      }
      swift_bridgeObjectRelease(v41);
      swift_bridgeObjectRelease(0xE200000000000000);
      v81 = 0xE000000000000000;
      if (v42 & 0x8080808080808080 | v59 & 0x80808080808080)
        v81 = 0xA000000000000000;
      v230 = v42;
      v231 = v81 & 0xFF00000000000000 | (v69 << 56) | v59 & 0xFFFFFFFFFFFFFFLL;
      v5 = v212;
      goto LABEL_70;
    }
    swift_bridgeObjectRelease(v231);
    v230 = 8236;
    v231 = 0xE200000000000000;
LABEL_70:
    v31 = v224;
LABEL_75:
    v32 = v225;
LABEL_76:
    v94 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v94, v228);
    *((_OWORD *)inited + 1) = v226;
    inited[7] = v31;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v37(boxed_opaque_existential_0Tm, v32, v31);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v230);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    v100 = v230;
    v99 = v231;
    v101 = HIBYTE(v231) & 0xF;
    v41 = v230 & 0xFFFFFFFFFFFFLL;
    if ((v231 & 0x2000000000000000) != 0)
      v102 = HIBYTE(v231) & 0xF;
    else
      v102 = v230 & 0xFFFFFFFFFFFFLL;
    if (!v102 && (v230 & ~v231 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v231);
      v230 = 8250;
      v231 = 0xE200000000000000;
LABEL_5:
      v31 = v224;
      goto LABEL_6;
    }
    if ((v231 & 0x2000000000000000) == 0 || v101 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000, 6, v97, v98);
      if ((v99 & 0x1000000000000000) != 0)
      {
        v148 = String.UTF8View._foreignCount()();
        v52 = v148 + 2;
        if (__OFADD__(v148, 2))
        {
LABEL_226:
          __break(1u);
LABEL_227:
          __break(1u);
LABEL_228:
          __break(1u);
LABEL_229:
          __break(1u);
LABEL_230:
          v200 = String.UTF8View._foreignCount()();
          v164 = v200 + 1;
          if (!__OFADD__(v200, 1))
            goto LABEL_180;
LABEL_232:
          __break(1u);
LABEL_233:
          if ((v164 & 0x1000000000000000) != 0)
          {
            v52 = _StringGuts._foreignConvertedToSmall()(v52, v164);
            v206 = v205;
            swift_bridgeObjectRelease(v164);
            v164 = v206;
          }
          else
          {
            if ((v52 & 0x1000000000000000) != 0)
            {
              v201 = (unsigned __int8 *)((v164 & 0xFFFFFFFFFFFFFFFLL) + 32);
              v202 = v52 & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              v201 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v52, v164);
            }
            closure #1 in _StringGuts._convertedToSmall()(v201, v202, &v229);
            swift_bridgeObjectRelease(v164);
            v164 = *((_QWORD *)&v229 + 1);
            v52 = v229;
          }
          goto LABEL_203;
        }
      }
      else
      {
        v51 = __OFADD__(v102, 2);
        v52 = v102 + 2;
        if (v51)
          goto LABEL_226;
      }
      v108 = v100 & ~v99;
      if ((v108 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v99 & 0xFFFFFFFFFFFFFFFLL))
      {
        v109 = _StringGuts.nativeUnusedCapacity.getter(v100, v99);
        if ((v110 & 1) != 0)
          goto LABEL_243;
        if (v52 > 15)
          goto LABEL_114;
        if ((v99 & 0x2000000000000000) == 0)
        {
          if (v109 <= 1)
            goto LABEL_94;
LABEL_114:
          v137 = _StringGuts.nativeUnusedCapacity.getter(v100, v99);
          v41 = (v138 & 1) == 0 && v137 > 1;
          if ((v108 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(v99 & 0xFFFFFFFFFFFFFFFLL))
          {
            v5 = v212;
            if ((v41 & 1) != 0)
              goto LABEL_134;
LABEL_127:
            v141 = _StringGuts.nativeCapacity.getter(v100, v99);
            if ((v142 & 1) != 0)
              v143 = 0;
            else
              v143 = v141;
            if (v143 + 0x4000000000000000 < 0)
              goto LABEL_228;
            v144 = 2 * v143;
            if (v144 > v52)
              v52 = v144;
          }
          else
          {
            v5 = v212;
            if ((v41 & 1) == 0)
              goto LABEL_127;
          }
          _StringGuts.grow(_:)(v52);
LABEL_134:
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          v229 = v211;
          v145 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v229, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v145, v146, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
          goto LABEL_5;
        }
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
LABEL_95:
        v114 = v99;
      }
      else
      {
        if (v52 > 15)
          goto LABEL_114;
LABEL_94:
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        if ((v99 & 0x2000000000000000) != 0)
          goto LABEL_95;
        if ((v99 & 0x1000000000000000) != 0)
        {
          v100 = _StringGuts._foreignConvertedToSmall()(v100, v99);
          v114 = v157;
        }
        else
        {
          if ((v100 & 0x1000000000000000) != 0)
          {
            v151 = (unsigned __int8 *)((v99 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            v151 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v100, v99);
            v41 = v111;
          }
          swift_bridgeObjectRetain(v99, v111, v112, v113);
          closure #1 in _StringGuts._convertedToSmall()(v151, v41, &v229);
          swift_bridgeObjectRelease(v99);
          v114 = *((_QWORD *)&v229 + 1);
          v100 = v229;
        }
      }
      v115._rawBits = 1;
      v116._rawBits = 131073;
      v117._rawBits = _StringGuts.validateScalarRange(_:)(v115, v116, 0x203AuLL, 0xE200000000000000);
      if (v117._rawBits < 0x10000)
        v117._rawBits |= 3;
      v119 = specialized String.init(_:)(v117, v118, 0x203AuLL, 0xE200000000000000);
      v121 = v120;
      swift_bridgeObjectRelease(0xE200000000000000);
      if ((v121 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v121);
      }
      else if ((v121 & 0x1000000000000000) != 0)
      {
        v119 = _StringGuts._foreignConvertedToSmall()(v119, v121);
        v156 = v155;
        swift_bridgeObjectRelease(v121);
        v121 = v156;
      }
      else
      {
        if ((v119 & 0x1000000000000000) != 0)
        {
          v149 = (unsigned __int8 *)((v121 & 0xFFFFFFFFFFFFFFFLL) + 32);
          v150 = v119 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          v149 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v119, v121);
        }
        closure #1 in _StringGuts._convertedToSmall()(v149, v150, &v229);
        swift_bridgeObjectRelease(v121);
        v121 = *((_QWORD *)&v229 + 1);
        v119 = v229;
      }
      v122 = HIBYTE(v114) & 0xF;
      v123 = HIBYTE(v121) & 0xF;
      v124 = v123 + v122;
      if ((unint64_t)(v123 + v122) > 0xF)
        goto LABEL_242;
      if (v123)
      {
        v125 = 0;
        v126 = 0;
        do
        {
          v127 = v122 + v126;
          v128 = v126 + 1;
          if (v126 >= 8)
            v129 = v121;
          else
            v129 = v119;
          v130 = v129 >> (v125 & 0x38);
          v131 = (8 * v122 + v125) & 0x38;
          v132 = (-255 << v131) - 1;
          v133 = (unint64_t)v130 << v131;
          v134 = v133 | v132 & v114;
          v135 = v133 | v132 & v100;
          if (v127 < 8)
            v100 = v135;
          else
            v114 = v134;
          v125 += 8;
          v126 = v128;
        }
        while (v123 != v128);
      }
      swift_bridgeObjectRelease(v99);
      swift_bridgeObjectRelease(0xE200000000000000);
      v136 = 0xE000000000000000;
      if (v100 & 0x8080808080808080 | v114 & 0x80808080808080)
        v136 = 0xA000000000000000;
      v230 = v100;
      v231 = v136 & 0xFF00000000000000 | (v124 << 56) | v114 & 0xFFFFFFFFFFFFFFLL;
      v5 = v212;
      goto LABEL_5;
    }
    v103 = 8 * (HIBYTE(v231) & 7);
    v104 = (-255 << v103) - 1;
    v105 = 58 << v103;
    v106 = v101 + 1;
    if (v101 >= 8)
    {
      v107 = v105 | v104 & v231;
      v31 = v224;
    }
    else
    {
      v100 = v105 | v104 & v230;
      v31 = v224;
      if (v101 != 7)
      {
        v100 = (32 << (8 * (v106 & 7u))) | ((-255 << (8 * (v106 & 7u))) - 1) & v100;
        v140 = v231;
        goto LABEL_136;
      }
      v106 = 8;
      v107 = v231;
    }
    v140 = (32 << (8 * (v106 & 7u))) | ((-255 << (8 * (v106 & 7u))) - 1) & v107;
LABEL_136:
    swift_bridgeObjectRelease(v231);
    swift_bridgeObjectRelease(0xE200000000000000);
    v147 = 0xE000000000000000;
    if (v100 & 0x8080808080808080 | v140 & 0x80808080808080)
      v147 = 0xA000000000000000;
    v230 = v100;
    v231 = (v147 & 0xFF00000000000000 | (v101 << 56) | v140 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
LABEL_6:
    v33 = swift_initStackObject(v94, v227);
    *((_OWORD *)v33 + 1) = v226;
    v33[7] = v5;
    v34 = __swift_allocate_boxed_opaque_existential_0Tm(v33 + 4);
    v9 = v214;
    ((void (*)(_QWORD *, char *, uint64_t))v38)(v34, v214, v5);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)v33, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v230);
    swift_bridgeObjectRelease((uint64_t)v33);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    v30 = 0;
    v32 = v225;
  }
  (*(void (**)(char *, unint64_t))(v209 + 8))(v219, v220);
  v28 = v230;
  v41 = v231;
  v52 = HIBYTE(v231) & 0xF;
  v38 = v230 & 0xFFFFFFFFFFFFLL;
  if ((v231 & 0x2000000000000000) != 0)
    v163 = HIBYTE(v231) & 0xF;
  else
    v163 = v230 & 0xFFFFFFFFFFFFLL;
  if (!v163 && (v230 & ~v231 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v231);
    return 93;
  }
  if ((v231 & 0x2000000000000000) == 0 || v52 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6, v161, v162);
    if ((v41 & 0x1000000000000000) != 0)
      goto LABEL_230;
    v51 = __OFADD__(v163, 1);
    v164 = v163 + 1;
    if (v51)
      goto LABEL_232;
LABEL_180:
    v165 = v28 & ~v41;
    if ((v165 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
    {
      v166 = _StringGuts.nativeUnusedCapacity.getter(v28, v41);
      if ((v167 & 1) != 0)
      {
LABEL_243:
        v204 = 258;
LABEL_244:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v204, 0);
      }
      if (v164 > 15)
        goto LABEL_186;
      if ((v41 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        goto LABEL_198;
      }
      if (v166 > 0)
      {
LABEL_186:
        v168 = _StringGuts.nativeUnusedCapacity.getter(v28, v41);
        v171 = (v169 & 1) == 0 && v168 > 0;
        if ((v165 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v41 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v171)
            goto LABEL_222;
        }
        else if (v171)
        {
LABEL_221:
          _StringGuts.grow(_:)(v164);
LABEL_222:
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          v229 = xmmword_1816ABBC0;
          v197 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v229, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v197, v198, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v230;
        }
        v193 = _StringGuts.nativeCapacity.getter(v28, v41);
        if ((v194 & 1) != 0)
          v195 = 0;
        else
          v195 = v193;
        if (v195 + 0x4000000000000000 >= 0)
        {
          v196 = 2 * v195;
          if (v196 > v164)
            v164 = v196;
          goto LABEL_221;
        }
        __break(1u);
        goto LABEL_242;
      }
    }
    else if (v164 > 15)
    {
      goto LABEL_186;
    }
    swift_bridgeObjectRelease_n(0xE100000000000000, 5);
    if ((v41 & 0x2000000000000000) == 0)
    {
      if ((v41 & 0x1000000000000000) != 0)
      {
        v28 = _StringGuts._foreignConvertedToSmall()(v28, v41);
        v38 = v207;
      }
      else
      {
        if ((v28 & 0x1000000000000000) != 0)
        {
          v203 = (unsigned __int8 *)((v41 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          v203 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v28, v41);
          v38 = v172;
        }
        swift_bridgeObjectRetain(v41, v172, v173, v174);
        closure #1 in _StringGuts._convertedToSmall()(v203, v38, &v229);
        swift_bridgeObjectRelease(v41);
        v38 = *((_QWORD *)&v229 + 1);
        v28 = v229;
      }
      goto LABEL_199;
    }
LABEL_198:
    v38 = v41;
LABEL_199:
    v175._rawBits = 65537;
    v176._rawBits = 1;
    v177._rawBits = _StringGuts.validateScalarRange(_:)(v176, v175, 0x5DuLL, 0xE100000000000000);
    if (v177._rawBits < 0x10000)
      v177._rawBits |= 3;
    v52 = specialized String.init(_:)(v177, v178, 0x5DuLL, 0xE100000000000000);
    v164 = v179;
    swift_bridgeObjectRelease(0xE100000000000000);
    if ((v164 & 0x2000000000000000) == 0)
      goto LABEL_233;
    swift_bridgeObjectRelease(v164);
LABEL_203:
    v180 = HIBYTE(v38) & 0xF;
    v181 = HIBYTE(v164) & 0xF;
    if ((unint64_t)(v181 + v180) <= 0xF)
    {
      if (v181)
      {
        v182 = 0;
        v183 = 0;
        do
        {
          v184 = v180 + v183;
          v185 = v183 + 1;
          if (v183 >= 8)
            v186 = v164;
          else
            v186 = v52;
          v187 = v186 >> (v182 & 0x38);
          v188 = (8 * v180 + v182) & 0x38;
          v189 = (-255 << v188) - 1;
          v190 = (unint64_t)v187 << v188;
          v191 = v190 | v189 & v38;
          v192 = v190 | v189 & v28;
          if (v184 < 8)
            v28 = v192;
          else
            v38 = v191;
          v182 += 8;
          v183 = v185;
        }
        while (v181 != v185);
      }
      swift_bridgeObjectRelease(v41);
      swift_bridgeObjectRelease(0xE100000000000000);
      return v28;
    }
LABEL_242:
    v204 = 266;
    goto LABEL_244;
  }
  if ((unint64_t)v52 < 8)
    v28 = (93 << (8 * (HIBYTE(v231) & 7u))) | ((-255 << (8 * (HIBYTE(v231) & 7u))) - 1) & v230;
  swift_bridgeObjectRelease(v231);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v28;
}

uint64_t specialized _bridgeCocoaArray<A>(_:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000 | a1;
}

uint64_t type metadata accessor for _ArrayAnyHashableBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _ArrayAnyHashableBox);
}

BOOL specialized _deallocateUninitializedArray<A>(_:)(uint64_t a1, uint64_t *a2)
{
  _BOOL8 result;
  uint64_t v4;

  result = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  v4 = a1 & 0xFFFFFFFFFFFFF8;
  if (!result)
    v4 = a1;
  *(_QWORD *)(v4 + 16) = 0;
  return result;
}

uint64_t type metadata accessor for __ContiguousArrayStorageBase()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _SliceBuffer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SliceBuffer, &flag for loading of canonical specialized generic type metadata for _SliceBuffer);
}

uint64_t type metadata accessor for IteratorSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for IteratorSequence);
}

void sub_1815A32C8()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t type metadata accessor for _ContiguousArrayBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _ContiguousArrayBuffer);
}

void partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:)(const char *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const char *v10;
  char v11;
  unint64_t v12;
  int v13;
  const char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD v18[2];

  v7 = *(_QWORD *)(v4 + 16);
  v8 = *(_QWORD *)(v4 + 24);
  v10 = *(const char **)(v4 + 32);
  v9 = *(_QWORD *)(v4 + 40);
  v11 = *(_BYTE *)(v4 + 48);
  v12 = *(_QWORD *)(v4 + 56);
  v13 = *(_DWORD *)(v4 + 64);
  swift_bridgeObjectRetain(v8, a2, a3, a4);
  if ((v8 & 0x1000000000000000) != 0)
  {
    v7 = specialized static String._copying(_:)(v7, v8);
    v17 = v16;
    swift_bridgeObjectRelease(v8);
    v8 = v17;
    if ((v17 & 0x2000000000000000) == 0)
      goto LABEL_3;
LABEL_7:
    v18[0] = v7;
    v18[1] = v8 & 0xFFFFFFFFFFFFFFLL;
    closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)((const char *)v18, HIBYTE(v8) & 0xF, v10, v9, v11, a1, a2, v12, v13);
    swift_bridgeObjectRelease(v8);
    return;
  }
  if ((v8 & 0x2000000000000000) != 0)
    goto LABEL_7;
LABEL_3:
  if ((v7 & 0x1000000000000000) != 0)
  {
    v14 = (const char *)((v8 & 0xFFFFFFFFFFFFFFFLL) + 32);
    v15 = v7 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v14 = (const char *)_StringObject.sharedUTF8.getter(v7, v8);
  }
  closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(v14, v15, v10, v9, v11, a1, a2, v12, v13);
  swift_bridgeObjectRelease(v8);
}

uint64_t partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:)(const char *a1, uint64_t a2)
{
  uint64_t v2;

  return closure #1 in _assertionFailure(_:_:file:line:flags:)(a1, a2, *(const char **)(v2 + 16), *(_QWORD *)(v2 + 24), *(_BYTE *)(v2 + 32), *(const char **)(v2 + 40), *(_QWORD *)(v2 + 48), *(_BYTE *)(v2 + 56), *(_QWORD *)(v2 + 64), *(_DWORD *)(v2 + 72));
}

void partial apply for closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(const char *a1, uint64_t a2)
{
  uint64_t v2;

  closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(a1, a2, *(const char **)(v2 + 16), *(_QWORD *)(v2 + 24), *(_BYTE *)(v2 + 32), *(const char **)(v2 + 40), *(_QWORD *)(v2 + 48), *(_BYTE *)(v2 + 56), *(_QWORD *)(v2 + 64), *(_QWORD *)(v2 + 72));
}

uint64_t type metadata accessor for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideToIterator);
}

unint64_t lazy protocol witness table accessor for type Int and conformance Int(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int, &type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

uint64_t type metadata accessor for _SwiftNSMutableArray()
{
  return objc_opt_self();
}

uint64_t *outlined destroy of Any?(uint64_t *a1)
{
  if (!swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::OpaqueExistentialBox<0u>>,true,32ul,8ul,true>::getEnumTagSinglePayload((uint64_t)a1, 1))swift::metadataimpl::ValueWitnesses<swift::metadataimpl::OpaqueExistentialBox<0u>>::destroy(a1);
  return a1;
}

uint64_t type metadata accessor for AutoreleasingUnsafeMutablePointer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AutoreleasingUnsafeMutablePointer);
}

void sub_1815A3554()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

_QWORD *__swift_allocate_boxed_opaque_existential_0Tm(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1;
  v2 = a1[3];
  if ((*(_BYTE *)(*(_QWORD *)(v2 - 8) + 82) & 2) != 0)
  {
    *v1 = swift_allocBox(v2);
    return (_QWORD *)v3;
  }
  return v1;
}

uint64_t type metadata accessor for _KeyedEncodingContainerBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _KeyedEncodingContainerBox);
}

uint64_t type metadata accessor for _KeyedDecodingContainerBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _KeyedDecodingContainerBox);
}

_QWORD *outlined init with copy of EncodingError(_QWORD *a1, _QWORD *a2)
{
  return initializeWithCopy for EncodingError(a2, a1);
}

uint64_t __swift_destroy_boxed_opaque_existential_1Tm(uint64_t *a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1[3] - 8);
  if ((*(_BYTE *)(v1 + 82) & 2) != 0)
    return swift_release(*a1);
  else
    return (*(uint64_t (**)(void))(v1 + 8))();
}

uint64_t type metadata accessor for _DictionaryStorage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _DictionaryStorage, &flag for loading of canonical specialized generic type metadata for _DictionaryStorage);
}

uint64_t type metadata accessor for Dictionary._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary._Variant);
}

uint64_t outlined init with copy of DecodingError(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  return initializeWithCopy for DecodingError(a2, a1, a3, a4);
}

uint64_t outlined destroy of DecodingError(uint64_t a1)
{
  destroy for DecodingError(a1);
  return a1;
}

_QWORD *__swift_project_boxed_opaque_existential_0Tm(_QWORD *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(_QWORD *)(a2 - 8) + 80) & 0x20000) != 0)
    return (_QWORD *)(*result
                    + ((*(_DWORD *)(*(_QWORD *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(_QWORD *)(a2 - 8) + 80)));
  return result;
}

unint64_t specialized RangeReplaceableCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __objc2_class **v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  v3 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5((void (*)(uint64_t *__return_ptr, char *))protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar, 0, a2, a3);
  v4 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v3, 1);
  v6 = v5;
  swift_bridgeObjectRelease((uint64_t)v3);
  if (!v6)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/String.swift", 18, 2, 0x1C9uLL, 0);
  v7 = specialized static String.+ infix(_:_:)(0, 0xE000000000000000, v4, v6);
  swift_bridgeObjectRelease(v6);
  return v7;
}

unint64_t specialized _GenericIndexKey.init(intValue:)(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  unint64_t v24;
  unint64_t v26;
  unint64_t v27;

  v2 = specialized static String._createEmpty(withInitialCapacity:)(8);
  v4 = v3;
  v26 = v2;
  v27 = v3;
  v5 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0)
    v5 = v2 & 0xFFFFFFFFFFFFLL;
  if (v5 || (v2 & ~v3 & 0x2000000000000000) != 0)
  {
    if ((v3 & 0x2000000000000000) == 0
      || (v6 = specialized _SmallString.init(_:appending:)(v2, v3, 0x207865646E49uLL, 0xE600000000000000),
          (v8 & 1) != 0))
    {
      _StringGuts.append(_:)(0x207865646E49, 0xE600000000000000, 0, 6);
      v9 = v26;
      v10 = v27;
      goto LABEL_11;
    }
    v9 = v6;
    v10 = v7;
    swift_bridgeObjectRelease(v4);
  }
  else
  {
    v9 = 0x207865646E49;
    swift_bridgeObjectRelease(v3);
    v10 = 0xE600000000000000;
  }
  v26 = v9;
  v27 = v10;
LABEL_11:
  v12 = _int64ToString(_:radix:uppercase:)(a1, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
  v13 = v11;
  v14 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000) == 0)
    v14 = v9 & 0xFFFFFFFFFFFFLL;
  if (v14 || (v9 & ~v10 & 0x2000000000000000) != 0)
  {
    if ((v10 & 0x2000000000000000) != 0)
    {
      if ((v11 & 0x2000000000000000) != 0)
      {
        v16 = specialized _SmallString.init(_:appending:)(v9, v10, v12, v11);
        if ((v18 & 1) == 0)
        {
          v19 = v16;
          v20 = v17;
          swift_bridgeObjectRelease(v10);
          swift_bridgeObjectRelease(v13);
          v26 = v19;
          v13 = v20;
          v12 = v19;
          goto LABEL_24;
        }
        goto LABEL_22;
      }
    }
    else if ((v11 & 0x2000000000000000) != 0)
    {
LABEL_22:
      v15 = HIBYTE(v13) & 0xF;
      goto LABEL_23;
    }
    v15 = v12 & 0xFFFFFFFFFFFFLL;
LABEL_23:
    _StringGuts.append(_:)(v12, v13, 0, v15);
    swift_bridgeObjectRelease(v13);
    v12 = v26;
    v13 = v27;
    goto LABEL_24;
  }
  swift_bridgeObjectRelease(v10);
  v26 = v12;
LABEL_24:
  v21 = HIBYTE(v13) & 0xF;
  if ((v13 & 0x2000000000000000) == 0)
    v21 = v12 & 0xFFFFFFFFFFFFLL;
  if (v21 || (v12 & ~v13 & 0x2000000000000000) != 0)
  {
    if ((v13 & 0x2000000000000000) == 0
      || (v22 = specialized _SmallString.init(_:appending:)(v12, v13, 0, 0xE000000000000000), (v23 & 1) != 0))
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      swift_bridgeObjectRelease(0xE000000000000000);
      return v26;
    }
    else
    {
      v24 = v22;
      swift_bridgeObjectRelease(v13);
      swift_bridgeObjectRelease(0xE000000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v13);
    return 0;
  }
  return v24;
}

void sub_1815A3978()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 24));
  swift_deallocObject(v0);
}

uint64_t *__swift_mutable_project_boxed_opaque_existential_1(uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  if ((*(_DWORD *)(*(_QWORD *)(a2 - 8) + 80) & 0x20000) != 0)
  {
    swift_makeBoxUnique(result, a2, *(_DWORD *)(*(_QWORD *)(a2 - 8) + 80));
    return (uint64_t *)v2;
  }
  return result;
}

float specialized Float16.init(from:)(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37[3];
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;

  outlined init with copy of MirrorPath((uint64_t)a1, (uint64_t)&v40);
  v4 = v42;
  v5 = v43;
  __swift_project_boxed_opaque_existential_0Tm(&v40, v42);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v37, v4, v5);
  if (v1)
  {
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v40);
  }
  else
  {
    v6 = v38;
    v7 = v39;
    __swift_project_boxed_opaque_existential_0Tm(v37, v38);
    _S8 = (*(float (**)(uint64_t, uint64_t))(v7 + 48))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v37);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v40);
    __asm { FCVT            H9, S8 }
    if ((LOWORD(_S9) & 0x7FFF) == 0x7C00 && (~LODWORD(_S8) & 0x7F800000) != 0)
    {
      swift_allocError((uint64_t)&type metadata for DecodingError, (uint64_t)&protocol witness table for DecodingError, 0, 0);
      v15 = v14;
      v16 = a1[3];
      v17 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v16);
      v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 8))(v16, v17);
      v19 = specialized static String._createEmpty(withInitialCapacity:)(46);
      v21 = v20;
      v40 = v19;
      v41 = v20;
      v22 = HIBYTE(v20) & 0xF;
      if ((v20 & 0x2000000000000000) == 0)
        v22 = v19 & 0xFFFFFFFFFFFFLL;
      if (v22 || (v19 & ~v20 & 0x2000000000000000) != 0)
      {
        if ((v20 & 0x2000000000000000) != 0
          && ((unint64_t)"ffer is not allowed" & 0x2000000000000000) != 0
          && (v23 = specialized _SmallString.init(_:appending:)(v19, v20, 0xD000000000000013, 0x8000000181767340),
              (v25 & 1) == 0))
        {
          v26 = v23;
          v27 = v24;
          swift_bridgeObjectRelease(v21);
          v40 = v26;
          v41 = v27;
        }
        else
        {
          if (((unint64_t)"ffer is not allowed" & 0x2000000000000000) != 0)
            v28 = (0x8000000181767340 >> 56) & 0xF;
          else
            v28 = 19;
          _StringGuts.append(_:)(0xD000000000000013, 0x8000000181767340, 0, v28);
        }
      }
      else
      {
        swift_bridgeObjectRelease(v20);
        v40 = 0xD000000000000013;
        v41 = 0x8000000181767340;
      }
      specialized Float.write<A>(to:)();
      v29 = v41;
      v30 = HIBYTE(v41) & 0xF;
      if ((v41 & 0x2000000000000000) == 0)
        v30 = v40 & 0xFFFFFFFFFFFFLL;
      if (v30 || (v40 & ~v41 & 0x2000000000000000) != 0)
      {
        if ((v41 & 0x2000000000000000) != 0
          && ((unint64_t)"Parsed JSON number " & 0x2000000000000000) != 0
          && (v31 = specialized _SmallString.init(_:appending:)(v40, v41, 0xD000000000000019, 0x8000000181767360),
              (v33 & 1) == 0))
        {
          v34 = v31;
          v35 = v32;
          swift_bridgeObjectRelease(v29);
        }
        else
        {
          if (((unint64_t)"Parsed JSON number " & 0x2000000000000000) != 0)
            v36 = (0x8000000181767360 >> 56) & 0xF;
          else
            v36 = 25;
          _StringGuts.append(_:)(0xD000000000000019, 0x8000000181767360, 0, v36);
          v34 = v40;
          v35 = v41;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v41);
        v34 = 0xD000000000000019;
        v35 = 0x8000000181767360;
      }
      *(_QWORD *)v15 = v18;
      *(_QWORD *)(v15 + 8) = v34;
      *(_QWORD *)(v15 + 16) = v35;
      *(_QWORD *)(v15 + 24) = 0;
      *(_BYTE *)(v15 + 72) = 3;
      swift_willThrow();
    }
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return _S9;
}

uint64_t type metadata accessor for __CocoaSet.Iterator()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for Set._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Set._Variant);
}

unint64_t lazy protocol witness table accessor for type UInt8 and conformance UInt8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt8, &type metadata for UInt8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt8, &type metadata for UInt8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt8, &type metadata for UInt8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }
  return result;
}

uint64_t specialized _DictionaryCodingKey.init(stringValue:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  int v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  BOOL v23;
  char v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  BOOL v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int8 *v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;
  char v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned __int8 *v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  BOOL v66;
  char v67;
  uint64_t v68;
  unsigned __int8 *v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  BOOL v73;
  char v74;
  _QWORD v76[2];
  char v77;

  v6 = HIBYTE(a2) & 0xF;
  v7 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0)
    v8 = HIBYTE(a2) & 0xF;
  else
    v8 = a1 & 0xFFFFFFFFFFFFLL;
  if (v8)
  {
    if ((a2 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain(a2, a2, a3, a4);
      specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, (char *)specialized closure #1 in _parseInteger<A, B>(ascii:radix:));
      goto LABEL_86;
    }
    if ((a2 & 0x2000000000000000) == 0)
    {
      if ((a1 & 0x1000000000000000) != 0)
      {
        v9 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a1 & 0xFFFFFFFFFFFFLL) != 0)
          goto LABEL_9;
      }
      else
      {
        v9 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
        v7 = a2;
        if (a2 > 0)
        {
LABEL_9:
          v10 = *v9;
          if (v10 == 43)
          {
            swift_bridgeObjectRetain(a2, a2, a3, a4);
            v11 = 1;
            v38 = specialized Collection.subscript.getter(1, (uint64_t)v9, v7);
            v42 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v38, v39, v40, v41);
            if (!v43)
              goto LABEL_82;
            if (v42)
            {
              v44 = 0;
              while (1)
              {
                v45 = *v42 - 48;
                if (v45 > 9)
                  goto LABEL_76;
                v46 = (unsigned __int128)(v44 * (__int128)10) >> 64;
                v47 = 10 * v44;
                v48 = v46 != v47 >> 63;
                v23 = __OFADD__(v47, v45);
                v44 = v47 + v45;
                v49 = v23;
                v11 = 1;
                if (!v48 && (v49 & 1) == 0)
                {
                  v11 = 0;
                  ++v42;
                  if (--v43)
                    continue;
                }
                goto LABEL_82;
              }
            }
          }
          else
          {
            if (v10 != 45)
            {
              v50 = 0;
              while (1)
              {
                v51 = *v9 - 48;
                if (v51 > 9)
                  break;
                v52 = (unsigned __int128)(v50 * (__int128)10) >> 64;
                v53 = 10 * v50;
                v54 = v52 != v53 >> 63;
                v23 = __OFADD__(v53, v51);
                v50 = v53 + v51;
                v55 = v23;
                v11 = 1;
                if (v54 || (v55 & 1) != 0)
                  goto LABEL_81;
                ++v9;
                if (!--v7)
                {
                  v11 = 0;
                  goto LABEL_81;
                }
              }
              v11 = 1;
LABEL_81:
              swift_bridgeObjectRetain(a2, a2, a3, a4);
              goto LABEL_82;
            }
            swift_bridgeObjectRetain(a2, a2, a3, a4);
            v11 = 1;
            v12 = specialized Collection.subscript.getter(1, (uint64_t)v9, v7);
            v16 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v12, v13, v14, v15);
            if (!v17)
            {
LABEL_82:
              v77 = v11;
LABEL_86:
              swift_bridgeObjectRelease(a2);
              return a1;
            }
            if (v16)
            {
              v18 = 0;
              while (1)
              {
                v19 = *v16 - 48;
                if (v19 > 9)
                  break;
                v20 = (unsigned __int128)(v18 * (__int128)10) >> 64;
                v21 = 10 * v18;
                v22 = v20 != v21 >> 63;
                v23 = __OFSUB__(v21, v19);
                v18 = v21 - v19;
                v24 = v23;
                v11 = 1;
                if (!v22 && (v24 & 1) == 0)
                {
                  v11 = 0;
                  ++v16;
                  if (--v17)
                    continue;
                }
                goto LABEL_82;
              }
LABEL_76:
              v11 = 1;
              goto LABEL_82;
            }
          }
          v11 = 0;
          goto LABEL_82;
        }
      }
LABEL_91:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
    }
    v76[0] = a1;
    v76[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (!v6)
      goto LABEL_91;
    if (a1 == 43)
    {
      swift_bridgeObjectRetain(a2, a2, a3, a4);
      v25 = 1;
      v56 = specialized Collection.subscript.getter(1, (uint64_t)v76, v6);
      v60 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v56, v57, v58, v59);
      if (!v61)
        goto LABEL_85;
      if (v60)
      {
        v62 = 0;
        while (1)
        {
          v63 = *v60 - 48;
          if (v63 > 9)
            goto LABEL_77;
          v64 = (unsigned __int128)(v62 * (__int128)10) >> 64;
          v65 = 10 * v62;
          v66 = v64 != v65 >> 63;
          v23 = __OFADD__(v65, v63);
          v62 = v65 + v63;
          v67 = v23;
          v25 = 1;
          if (!v66 && (v67 & 1) == 0)
          {
            v25 = 0;
            ++v60;
            if (--v61)
              continue;
          }
          goto LABEL_85;
        }
      }
    }
    else
    {
      if (a1 != 45)
      {
        v68 = 0;
        v69 = (unsigned __int8 *)v76;
        while (1)
        {
          v70 = *v69 - 48;
          if (v70 > 9)
            break;
          v71 = (unsigned __int128)(v68 * (__int128)10) >> 64;
          v72 = 10 * v68;
          v73 = v71 != v72 >> 63;
          v23 = __OFADD__(v72, v70);
          v68 = v72 + v70;
          v74 = v23;
          v25 = 1;
          if (v73 || (v74 & 1) != 0)
            goto LABEL_84;
          ++v69;
          if (!--v6)
          {
            v25 = 0;
            goto LABEL_84;
          }
        }
        v25 = 1;
LABEL_84:
        swift_bridgeObjectRetain(a2, a2, a3, a4);
        goto LABEL_85;
      }
      swift_bridgeObjectRetain(a2, a2, a3, a4);
      v25 = 1;
      v26 = specialized Collection.subscript.getter(1, (uint64_t)v76, v6);
      v30 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v26, v27, v28, v29);
      if (!v31)
      {
LABEL_85:
        v77 = v25;
        goto LABEL_86;
      }
      if (v30)
      {
        v32 = 0;
        while (1)
        {
          v33 = *v30 - 48;
          if (v33 > 9)
            break;
          v34 = (unsigned __int128)(v32 * (__int128)10) >> 64;
          v35 = 10 * v32;
          v36 = v34 != v35 >> 63;
          v23 = __OFSUB__(v35, v33);
          v32 = v35 - v33;
          v37 = v23;
          v25 = 1;
          if (!v36 && (v37 & 1) == 0)
          {
            v25 = 0;
            ++v30;
            if (--v31)
              continue;
          }
          goto LABEL_85;
        }
LABEL_77:
        v25 = 1;
        goto LABEL_85;
      }
    }
    v25 = 0;
    goto LABEL_85;
  }
  return a1;
}

unint64_t specialized _DictionaryCodingKey.init(intValue:)(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v22;
  unint64_t v23;

  v2 = specialized static String._createEmpty(withInitialCapacity:)(2);
  v4 = v2;
  v5 = v3;
  v22 = v2;
  v23 = v3;
  v6 = HIBYTE(v3) & 0xF;
  v7 = v2 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000) != 0)
    v7 = HIBYTE(v3) & 0xF;
  if (v7 || (v2 & ~v3 & 0x2000000000000000) != 0)
  {
    if ((v3 & 0x2000000000000000) == 0)
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      v4 = v22;
      v8 = v23;
      goto LABEL_12;
    }
    swift_bridgeObjectRelease(v3);
    v9 = 0xA000000000000000;
    if (!(v5 & 0x80808080808080 | v4 & 0x8080808080808080))
      v9 = 0xE000000000000000;
    v8 = v9 & 0xFF00000000000000 | (v6 << 56) | v5 & 0xFFFFFFFFFFFFFFLL;
    v22 = v4;
  }
  else
  {
    swift_bridgeObjectRelease(v3);
    v4 = 0;
    v8 = 0xE000000000000000;
    v22 = 0;
  }
  v23 = v8;
LABEL_12:
  v11 = _int64ToString(_:radix:uppercase:)(a1, 10, 0, (uint64_t (*)(__int128 *, uint64_t, uint64_t, uint64_t, _QWORD))swift_int64ToString);
  v12 = v10;
  v13 = HIBYTE(v8) & 0xF;
  if ((v8 & 0x2000000000000000) == 0)
    v13 = v4 & 0xFFFFFFFFFFFFLL;
  if (v13 || (v4 & ~v8 & 0x2000000000000000) != 0)
  {
    if ((v8 & 0x2000000000000000) != 0)
    {
      if ((v10 & 0x2000000000000000) != 0)
      {
        v15 = specialized _SmallString.init(_:appending:)(v4, v8, v11, v10);
        if ((v17 & 1) == 0)
        {
          v18 = v15;
          v19 = v16;
          swift_bridgeObjectRelease(v8);
          swift_bridgeObjectRelease(v12);
          v22 = v18;
          v12 = v19;
          v11 = v18;
          goto LABEL_25;
        }
        goto LABEL_23;
      }
    }
    else if ((v10 & 0x2000000000000000) != 0)
    {
LABEL_23:
      v14 = HIBYTE(v12) & 0xF;
      goto LABEL_24;
    }
    v14 = v11 & 0xFFFFFFFFFFFFLL;
LABEL_24:
    _StringGuts.append(_:)(v11, v12, 0, v14);
    swift_bridgeObjectRelease(v12);
    v11 = v22;
    v12 = v23;
    goto LABEL_25;
  }
  swift_bridgeObjectRelease(v8);
  v22 = v11;
LABEL_25:
  v20 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v12 & 0x2000000000000000) != 0)
    v20 = HIBYTE(v12) & 0xF;
  if (v20 || (v11 & ~v12 & 0x2000000000000000) != 0)
  {
    if ((v12 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v12);
    }
    else
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      return v22;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v12);
    return 0;
  }
  return v11;
}

uint64_t specialized Int.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 40))(a2, a3);
}

uint64_t specialized String.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
}

uint64_t type metadata accessor for __CocoaDictionary.Iterator()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _NativeDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _NativeDictionary);
}

uint64_t type metadata accessor for Slice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Slice);
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error)(uint64_t a1, _QWORD *a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error)(a1, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  result = (*(uint64_t (**)(void))(v2 + 40))();
  if (v3)
    *a2 = v3;
  return result;
}

void sub_1815A44A0()
{
  uint64_t v0;

  swift_bridgeObjectRelease(*(_QWORD *)(v0 + 16));
  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(uint64_t a1)
{
  return partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(a1) & 1;
}

{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = v1[2];
  v4 = v1[3];
  v6 = v1[4];
  v5 = v1[5];
  swift_getAssociatedTypeWitness(0, *(const char **)(v4 + 8), v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t partial apply for closure #1 in BidirectionalCollection.last(where:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  return closure #1 in BidirectionalCollection.last(where:)(a1, *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24), a2);
}

uint64_t partial apply for closure #1 in BidirectionalCollection<>.lastIndex(of:)(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = v1[2];
  v4 = v1[3];
  v6 = v1[4];
  v5 = v1[5];
  swift_getAssociatedTypeWitness(0, *(const char **)(*(_QWORD *)(v4 + 8) + 8), v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t specialized static _UInt128.% infix(_:_:)(Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, unint64_t a4)
{
  uint64_t v7;
  Swift::UInt64 v8;
  Swift::UInt64 v9;
  Swift::tuple_high_UInt64_low_UInt64 v10;

  if (!(a4 | a3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in %=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1DCuLL, 0);
  v10.low = a2;
  v10.high = (Swift::UInt64)&v7;
  specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, a1, a4, a3);
  return v7;
}

uint64_t specialized Array.init(repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(uint64_t, uint64_t, uint64_t);

  v5 = a2;
  v7 = a4(a2, a3);
  if (v5 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v9 = v7;
  if (v5)
  {
    v10 = v8;
    v11 = *(_QWORD *)(a3 - 8);
    v12 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 16);
    do
    {
      v12(v10, a1, a3);
      v10 += *(_QWORD *)(v11 + 72);
      --v5;
    }
    while (v5);
  }
  return v9;
}

uint64_t outlined init with copy of Any(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t outlined init with copy of Any?(uint64_t a1, uint64_t a2)
{
  return initializeWithCopy for ClosedRange<>.Index(a2, a1, &unk_1E0EACE20);
}

void sub_1815A47B0()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Substring.withUnsafeBytes<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  return closure #1 in Substring.withUnsafeBytes<A>(_:)(a1, a2, *(uint64_t (**)(uint64_t, uint64_t))(v2 + 24));
}

uint64_t type metadata accessor for ClosedRange<>.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ClosedRange<>.Index);
}

uint64_t type metadata accessor for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DefaultIndices);
}

uint64_t specialized _ContiguousArrayStorage.countByEnumerating(with:objects:count:)(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t result;
  uint64_t v4;

  if (*a1)
    return 0;
  result = v1[2];
  v4 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*v1 + 144) - 8) + 80);
  *a1 = 1;
  a1[1] = (char *)v1 + ((v4 + 32) & ~v4);
  a1[2] = &_fastEnumerationStorageMutationsTarget;
  return result;
}

void specialized _ContiguousArrayBuffer.subscript.setter()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0x6C706D6920746F6ELL, 0xEF6465746E656D65, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x304uLL, 0);
}

uint64_t type metadata accessor for UnsafeBufferPointer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnsafeBufferPointer, &flag for loading of canonical specialized generic type metadata for UnsafeBufferPointer);
}

uint64_t specialized _StringGuts._slowWithCString<A>(_:)(unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  int v4;
  __objc2_class **v5;

  v4 = a3;
  v5 = String.utf8CString.getter(a1, a2, a3, a4);
  LOBYTE(v4) = _swift_stdlib_NSObject_isKindOfClass(v4, (char *)v5 + 32);
  swift_release((uint64_t)v5);
  return v4 & 1;
}

id specialized String.withCString<A>(_:)(unint64_t a1, unint64_t a2, void *a3, char *a4)
{
  char *v5;
  int v6;
  char isKindOfClass;
  int v8;
  id result;
  _QWORD v10[2];

  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000))
    return (id)(specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (uint64_t)a3, a4) & 1);
  if ((a2 & 0x2000000000000000) != 0)
  {
    v10[0] = a1;
    v10[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    v8 = swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
    isKindOfClass = _swift_stdlib_NSObject_isKindOfClass(v8, (char *)v10);
    swift_unknownObjectRelease(a3);
  }
  else
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      v5 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      v5 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
      if (!v5)
      {
        result = swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
        __break(1u);
        return result;
      }
    }
    v6 = swift_unknownObjectRetain(a3, a2, (uint64_t)a3, a4);
    isKindOfClass = _swift_stdlib_NSObject_isKindOfClass(v6, v5);
    swift_unknownObjectRelease(a3);
  }
  return (id)(isKindOfClass & 1);
}

uint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(unint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  char v4;
  uint8x16_t *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = a2;
  v6 = (uint8x16_t *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 16);
  swift_bridgeObjectRetain(a1, a2, a3, a4);
  if (_allASCII(_:)(v6->i64, v7) && (v8 = specialized static String._uncheckedFromASCII(_:)(v6, v7), v9))
  {
    v10 = v8;
    swift_bridgeObjectRelease(a1);
  }
  else
  {
    v10 = specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1, v4 & 1);
    swift_bridgeObjectRelease(a1);
  }
  return v10;
}

unint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(uint8x16_t *a1, uint64_t a2, char a3)
{
  __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t result;
  uint64_t v10;

  if (a2 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  if (a2)
  {
    if (!a1)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
    goto LABEL_6;
  }
  if (a1)
  {
LABEL_6:
    v6 = &a1->i8[a2];
    goto LABEL_7;
  }
  v6 = 0;
LABEL_7:
  v7 = v6 - (__int8 *)a1;
  if (a1)
    v8 = v7;
  else
    v8 = 0;
  if (!_allASCII(_:)(a1->i64, v8))
    return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1->i8, a2, a3 & 1);
  result = specialized static String._uncheckedFromASCII(_:)(a1, v8);
  if (!v10)
    return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1->i8, a2, a3 & 1);
  return result;
}

unint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(uint8x16_t *a1, uint64_t a2, ValueMetadata *a3, char *a4)
{
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for UnsafeBufferPointer<UInt8>
    && a3 == &type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, a2, a4 & 1);
  }
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for [UInt8]
    && a3 == &type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)((unint64_t)a1, a4 & 1, (uint64_t)a3, a4);
  }
  return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)((unsigned __int16 *)a1, a2, a4 & 1);
}

unint64_t partial apply for closure #2 in static String._fromCodeUnits<A, B>(_:encoding:repair:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  uint64_t v3;
  unint64_t AssociatedTypeWitness;
  uint64_t *v8;
  uint64_t v9;
  uint8x16_t *v10;
  uint64_t v11;
  unint64_t result;
  unint64_t v13;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(*(_QWORD *)(v3 + 32) + 8), *(_QWORD *)(v3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v8 = (uint64_t *)UnsafeRawBufferPointer.init<A>(_:)(a1, a2, AssociatedTypeWitness);
  v10 = (uint8x16_t *)v8;
  if (v8)
  {
    v11 = v9 - (_QWORD)v8;
    if (v9 - (uint64_t)v8 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  else
  {
    v11 = 0;
  }
  if (_allASCII(_:)(v8, v11))
  {
    result = specialized static String._uncheckedFromASCII(_:)(v10, v11);
  }
  else
  {
    result = 0;
    v13 = 0;
  }
  *a3 = result;
  a3[1] = v13;
  return result;
}

uint64_t partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:)()
{
  return partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:)();
}

{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 40))();
}

uint64_t outlined init with copy of AnyHashable?(uint64_t a1, uint64_t a2)
{
  return initializeWithCopy for ClosedRange<>.Index(a2, a1, &unk_1E0EACBD0);
}

uint64_t *outlined destroy of AnyHashable?(uint64_t *a1)
{
  if ((unint64_t)a1[3] >= 0xFFFFFFFF)
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return a1;
}

uint64_t *outlined destroy of AnyHashable(uint64_t *a1)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return a1;
}

unint64_t specialized String.init(repeating:count:)(unint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v18;
  unint64_t v19;

  if ((a3 & 0x8000000000000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative count not allowed", 26, 2, "Swift/StringLegacy.swift", 24, 2, 0x1FuLL, 0);
  v3 = a3;
  v5 = a1;
  if (a3 >= 2)
  {
    v18 = 0;
    v19 = 0xE000000000000000;
    if ((a2 & 0x2000000000000000) != 0)
      v6 = HIBYTE(a2) & 0xF;
    else
      v6 = a1 & 0xFFFFFFFFFFFFLL;
    String.reserveCapacity(_:)(v6 * a3);
    while (1)
    {
      while (1)
      {
        if (!v3)
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        v10 = HIBYTE(v19) & 0xF;
        if ((v19 & 0x2000000000000000) == 0)
          v10 = v18 & 0xFFFFFFFFFFFFLL;
        if (v10 || (v18 & ~v19 & 0x2000000000000000) != 0)
          break;
        swift_bridgeObjectRetain(a2, v7, v8, v9);
        swift_bridgeObjectRelease(v19);
        v18 = v5;
        v19 = a2;
        if (!--v3)
        {
LABEL_23:
          swift_bridgeObjectRelease(a2);
          return v18;
        }
      }
      v11 = v5 & 0xFFFFFFFFFFFFLL;
      if ((v19 & 0x2000000000000000) == 0)
        break;
      if ((a2 & 0x2000000000000000) != 0)
      {
        v12 = specialized _SmallString.init(_:appending:)(v18, v19, v5, a2);
        if ((v14 & 1) != 0)
          goto LABEL_19;
        v15 = v12;
        v16 = v13;
        swift_bridgeObjectRelease(v19);
        v18 = v15;
        v19 = v16;
        if (!--v3)
          goto LABEL_23;
      }
      else
      {
LABEL_20:
        _StringGuts.append(_:)(v5, a2, 0, v11);
        if (!--v3)
          goto LABEL_23;
      }
    }
    if ((a2 & 0x2000000000000000) == 0)
      goto LABEL_20;
LABEL_19:
    v11 = HIBYTE(a2) & 0xF;
    goto LABEL_20;
  }
  if (!a3)
  {
    swift_bridgeObjectRelease(a2);
    return 0;
  }
  return v5;
}

uint64_t outlined init with copy of AnyHashable(uint64_t a1, uint64_t a2)
{
  __int128 v3;

  v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

unint64_t specialized static _DebuggerSupport.stringForPrintObject(_:)(uint64_t a1)
{
  uint64_t v3[4];
  uint64_t v4[4];
  unint64_t v5[2];
  __objc2_class **v6;
  uint64_t v7;
  _BYTE v8[48];

  v7 = 0x7FFFFFFFFFFFFFFFLL;
  v6 = &_swiftEmptySetSingleton;
  v5[0] = 0;
  v5[1] = 0xE000000000000000;
  outlined init with copy of Any(a1, (uint64_t)v4);
  outlined init with copy of Any(a1, (uint64_t)v3);
  Mirror.init(reflecting:)(v3, (uint64_t)v8);
  specialized static _DebuggerSupport.printForDebuggerImpl<A>(value:mirror:name:indent:maxDepth:isRoot:parentCollectionStatus:refsAlreadySeen:maxItemCounter:target:)((uint64_t)v4, (uint64_t)v8, 0, 0, 0, 0x7FFFFFFFFFFFFFFFLL, 1, 0, (uint64_t)&v6, &v7, v5);
  outlined release of Mirror((uint64_t)v8);
  outlined destroy of Any?(v4);
  swift_bridgeObjectRelease((uint64_t)v6);
  return v5[0];
}

uint64_t type metadata accessor for Dictionary(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary, &flag for loading of canonical specialized generic type metadata for Dictionary);
}

uint64_t partial apply for closure #1 in Dictionary.init<A>(uniqueKeysWithValues:)()
{
  swift_allocError((uint64_t)&type metadata for _MergeError, (uint64_t)&protocol witness table for _MergeError, 0, 0);
  return swift_willThrow();
}

void specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)(void (*a1)(char *, uint64_t, Class *), char a2, void (*a3)(char *, char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  Class *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *TupleTypeMetadata2;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t AssociatedTypeWitness;
  uint64_t v35;
  char *v36;
  char *v37;
  unint64_t AssociatedConformanceWitness;
  void (*v39)(unint64_t, unint64_t);
  unint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(char *, uint64_t, Class *);
  char *v45;
  Class *v46;
  uint64_t v47;
  void (*v48)(char *, char *, uint64_t);
  _QWORD *v49;
  uint64_t v50;
  char v51;
  unint64_t v52;
  uint64_t v53;
  _BOOL8 v54;
  Swift::Int v55;
  char v56;
  unint64_t v57;
  char v58;
  _QWORD *v59;
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  void *v64;
  void (*v65)(char *, uint64_t);
  char *v66;
  Class *v67;
  char *v68;
  uint64_t v69;
  BOOL v70;
  uint64_t v71;
  void (*v72)(char *, uint64_t);
  char *v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  char v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  char *v97;
  void (*v98)(char *, char *);
  uint64_t v99;
  char *v100;
  unint64_t *v101;
  unsigned int (*v102)(char *, uint64_t, unint64_t *);
  void (*v103)(unint64_t, unint64_t);
  unint64_t v104;
  uint64_t v105;
  void *v106;
  char *v107;
  unint64_t v108;
  void (*v109)(char *, uint64_t, Class *);
  uint64_t v110;
  uint64_t v111;
  char *v112;
  char *v113;
  Class *v114;
  uint64_t v115;
  unint64_t v116;
  unint64_t v117;
  id v118;

  v98 = a3;
  v99 = a4;
  v109 = a1;
  v111 = *(_QWORD *)(*(_QWORD *)(a5 + 24) - 8);
  v10 = MEMORY[0x1E0C80A78](a1);
  v97 = (char *)&v91 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = MEMORY[0x1E0C80A78](v10);
  v96 = (char *)&v91 - v13;
  v14 = MEMORY[0x1E0C80A78](v12);
  v95 = (char *)&v91 - v15;
  v16 = MEMORY[0x1E0C80A78](v14);
  v112 = (char *)&v91 - v17;
  v110 = v18;
  v92 = *(_QWORD *)(*(_QWORD *)(v18 + 16) - 8);
  v19 = MEMORY[0x1E0C80A78](v16);
  v94 = (char *)&v91 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v19);
  v113 = (char *)&v91 - v22;
  v114 = v21;
  v105 = v23;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2((const char *)0xFF, (uint64_t)v21, v23, 0, 0);
  v27 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v25, v26);
  v28 = MEMORY[0x1E0C80A78](v27);
  v30 = (char *)&v91 - v29;
  v31 = *(_QWORD *)(a6 - 8);
  MEMORY[0x1E0C80A78](v28);
  v33 = (char *)&v91 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)a7, a6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v93 = *(_QWORD *)(AssociatedTypeWitness - 8);
  MEMORY[0x1E0C80A78](AssociatedTypeWitness);
  v36 = (char *)&v91 - v35;
  (*(void (**)(char *, _QWORD, uint64_t))(v31 + 16))(v33, v109, a6);
  v37 = v30;
  (*(void (**)(uint64_t))(a7 + 32))(a6);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, a6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  v39 = *(void (**)(unint64_t, unint64_t))(AssociatedConformanceWitness + 16);
  v107 = v36;
  v108 = AssociatedTypeWitness;
  v103 = v39;
  v104 = AssociatedConformanceWitness;
  ((void (*)(unint64_t))v39)(AssociatedTypeWitness);
  v40 = TupleTypeMetadata2;
  v102 = *(unsigned int (**)(char *, uint64_t, unint64_t *))(*(TupleTypeMetadata2 - 1) + 48);
  if (v102(v30, 1, TupleTypeMetadata2) == 1)
  {
LABEL_2:
    (*(void (**)(char *, unint64_t))(v93 + 8))(v107, v108);
    return;
  }
  v41 = v92;
  v109 = *(void (**)(char *, uint64_t, Class *))(v92 + 32);
  v42 = v111;
  v43 = v105;
  v100 = v30;
  v101 = v40;
  v44 = v109;
  while (1)
  {
    v45 = &v37[*((int *)v40 + 12)];
    v47 = (uint64_t)v113;
    v46 = v114;
    v109(v113, (uint64_t)v37, v114);
    v48 = *(void (**)(char *, char *, uint64_t))(v42 + 32);
    v48(v112, v45, v43);
    v49 = *(_QWORD **)v115;
    v50 = *(_QWORD *)(v110 + 32);
    v52 = __RawDictionaryStorage.find<A>(_:)(v47, (uint64_t)v46, v50);
    v53 = v49[2];
    v54 = (v51 & 1) == 0;
    v55 = v53 + v54;
    if (__OFADD__(v53, v54))
    {
      __break(1u);
LABEL_19:
      __break(1u);
LABEL_20:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v114);
    }
    v56 = v51;
    if (v49[3] >= v55)
    {
      if ((a2 & 1) == 0)
        _NativeDictionary.copy()();
    }
    else
    {
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v55, a2 & 1);
      v57 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v113, (uint64_t)v114, v50);
      if ((v56 & 1) != (v58 & 1))
        goto LABEL_20;
      v52 = v57;
    }
    v59 = *(_QWORD **)v115;
    if ((v56 & 1) != 0)
      break;
    v66 = v94;
    v67 = v114;
    v44(v94, (uint64_t)v113, v114);
    v68 = v97;
    v43 = v105;
    v48(v97, v112, v105);
    v59[(v52 >> 6) + 8] |= 1 << v52;
    v44((char *)(v59[6] + *(_QWORD *)(v41 + 72) * v52), (uint64_t)v66, v67);
    v48((char *)(v59[7] + *(_QWORD *)(v111 + 72) * v52), v68, v43);
    v69 = v59[2];
    v70 = __OFADD__(v69, 1);
    v71 = v69 + 1;
    if (v70)
      goto LABEL_19;
    v59[2] = v71;
    v42 = v111;
LABEL_4:
    v37 = v100;
    v103(v108, v104);
    a2 = 1;
    v40 = v101;
    if (v102(v37, 1, v101) == 1)
      goto LABEL_2;
  }
  v42 = v111;
  v60 = *(_QWORD *)(v111 + 72) * v52;
  v61 = v96;
  v43 = v105;
  (*(void (**)(char *, unint64_t, uint64_t))(v111 + 16))(v96, v59[7] + v60, v105);
  v62 = v95;
  v63 = v112;
  v64 = v106;
  v98(v61, v112);
  if (!v64)
  {
    v106 = 0;
    v65 = *(void (**)(char *, uint64_t))(v42 + 8);
    v65(v61, v43);
    v65(v63, v43);
    (*(void (**)(char *, Class *))(v41 + 8))(v113, v114);
    (*(void (**)(unint64_t, char *, uint64_t))(v42 + 40))(*(_QWORD *)(*(_QWORD *)v115 + 56) + v60, v62, v43);
    goto LABEL_4;
  }
  v72 = *(void (**)(char *, uint64_t))(v42 + 8);
  v72(v61, v43);
  v118 = v64;
  swift_errorRetain(v64);
  v73 = (char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
  if (swift_dynamicCast(v73, (uint64_t *)&v118, (Class *)v73, (Class *)&type metadata for _MergeError, 0))
  {
    v74 = specialized static String._createEmpty(withInitialCapacity:)(30);
    v76 = v75;
    v116 = v74;
    v117 = v75;
    v77 = HIBYTE(v75) & 0xF;
    if ((v75 & 0x2000000000000000) == 0)
      v77 = v74 & 0xFFFFFFFFFFFFLL;
    if (v77 || (v74 & ~v75 & 0x2000000000000000) != 0)
    {
      if ((v75 & 0x2000000000000000) != 0
        && ((unint64_t)"ment" & 0x2000000000000000) != 0
        && (v78 = specialized _SmallString.init(_:appending:)(v74, v75, 0xD00000000000001BLL, 0x8000000181767230),
            (v80 & 1) == 0))
      {
        v81 = v78;
        v82 = v79;
        swift_bridgeObjectRelease(v76);
        v116 = v81;
        v117 = v82;
      }
      else
      {
        if (((unint64_t)"ment" & 0x2000000000000000) != 0)
          v83 = (0x8000000181767230 >> 56) & 0xF;
        else
          v83 = 27;
        _StringGuts.append(_:)(0xD00000000000001BLL, 0x8000000181767230, 0, v83);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v75);
      v116 = 0xD00000000000001BLL;
      v117 = 0x8000000181767230;
    }
    _print_unlocked<A, B>(_:_:)((uint64_t)v113, (uint64_t)&v116, v114, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
    v84 = v117;
    v85 = HIBYTE(v117) & 0xF;
    if ((v117 & 0x2000000000000000) == 0)
      v85 = v116 & 0xFFFFFFFFFFFFLL;
    if (v85 || (v116 & ~v117 & 0x2000000000000000) != 0)
    {
      if ((v117 & 0x2000000000000000) == 0
        || (v88 = specialized _SmallString.init(_:appending:)(v116, v117, 0x27uLL, 0xE100000000000000), (v90 & 1) != 0))
      {
        _StringGuts.append(_:)(39, 0xE100000000000000, 0, 1);
        v87 = v116;
        v86 = v117;
      }
      else
      {
        v87 = v88;
        v86 = v89;
        swift_bridgeObjectRelease(v84);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v117);
      v86 = 0xE100000000000000;
      v87 = 39;
    }
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)v87, v86, "Swift/NativeDictionary.swift", 28, 2, 0x30FuLL, 0);
  }
  v72(v63, v43);
  (*(void (**)(char *, Class *))(v41 + 8))(v113, v114);
  (*(void (**)(char *, unint64_t))(v93 + 8))(v107, v108);
  swift_errorRelease(v118);
}

unint64_t type metadata accessor for __BridgingBufferStorage(const char *a1)
{
  return type metadata accessor for __BridgingBufferStorage(a1, (unint64_t *)&type metadata singleton initialization cache for __BridgingBufferStorage, (unsigned int *)&nominal type descriptor for __BridgingBufferStorage);
}

uint64_t type metadata accessor for __CocoaDictionary.Index.Storage()
{
  return objc_opt_self();
}

void sub_1815A5870()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

void sub_1815A5884()
{
  uint64_t v0;

  swift_release(*(_QWORD *)(v0 + 48));
  swift_deallocObject(v0);
}

void sub_1815A58AC()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Dictionary.merge(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t v9;

  v8 = *(_QWORD *)(v4 + 16);
  v9 = *(_QWORD *)(v4 + 24);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v8 - 8) + 16))(a1, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v9 - 8) + 16))(a2, a4, v9);
}

uint64_t partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  return thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)(a1, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 40), *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24), a2);
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)(uint64_t result)
{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1)
    v1 = 1;
  else
    v1 = result;
  v2 = ceil((double)v1 / 0.75);
  if ((~*(_QWORD *)&v2 & 0x7FF0000000000000) == 0)
    goto LABEL_23;
  if (v2 <= -9.22337204e18)
    goto LABEL_24;
  if (v2 >= 9.22337204e18)
    goto LABEL_25;
  v3 = __OFADD__(v1, 1);
  v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2)
    v4 = (uint64_t)v2;
  v5 = 64 - __clz(v4 - 1);
  v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  v7 = 1 << v6;
  v8 = (unint64_t)((1 << v6) + 63) >> 6;
  v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, String>();
  v10 = (int64x2_t *)swift_allocObject(v9, (((16 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (16 << v6), 7uLL);
  v10[1].i64[0] = 0;
  v11 = (double)(1 << v6) * 0.75;
  if ((~*(_QWORD *)&v11 & 0x7FF0000000000000) == 0)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18)
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18)
LABEL_25:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  v12 = (uint64_t *)v10;
  v13 = v10 + 4;
  v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1ECD25528)
    v15 = (uint64_t *)v6;
  else
    v15 = v12;
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63)
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  else
    v13->i64[0] = -1 << v7;
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1)
    v1 = 1;
  else
    v1 = result;
  v2 = ceil((double)v1 / 0.75);
  if ((~*(_QWORD *)&v2 & 0x7FF0000000000000) == 0)
    goto LABEL_23;
  if (v2 <= -9.22337204e18)
    goto LABEL_24;
  if (v2 >= 9.22337204e18)
    goto LABEL_25;
  v3 = __OFADD__(v1, 1);
  v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2)
    v4 = (uint64_t)v2;
  v5 = 64 - __clz(v4 - 1);
  v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  v7 = 1 << v6;
  v8 = (unint64_t)((1 << v6) + 63) >> 6;
  v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, AnyHashable>();
  v10 = (int64x2_t *)swift_allocObject(v9, (((16 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (40 << v6), 7uLL);
  v10[1].i64[0] = 0;
  v11 = (double)(1 << v6) * 0.75;
  if ((~*(_QWORD *)&v11 & 0x7FF0000000000000) == 0)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18)
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18)
LABEL_25:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  v12 = (uint64_t *)v10;
  v13 = v10 + 4;
  v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1ECD25528)
    v15 = (uint64_t *)v6;
  else
    v15 = v12;
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63)
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  else
    v13->i64[0] = -1 << v7;
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1)
    v1 = 1;
  else
    v1 = result;
  v2 = ceil((double)v1 / 0.75);
  if ((~*(_QWORD *)&v2 & 0x7FF0000000000000) == 0)
    goto LABEL_23;
  if (v2 <= -9.22337204e18)
    goto LABEL_24;
  if (v2 >= 9.22337204e18)
    goto LABEL_25;
  v3 = __OFADD__(v1, 1);
  v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2)
    v4 = (uint64_t)v2;
  v5 = 64 - __clz(v4 - 1);
  v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  v7 = 1 << v6;
  v8 = (unint64_t)((1 << v6) + 63) >> 6;
  v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, String>();
  v10 = (int64x2_t *)swift_allocObject(v9, (((40 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (16 << v6), 7uLL);
  v10[1].i64[0] = 0;
  v11 = (double)(1 << v6) * 0.75;
  if ((~*(_QWORD *)&v11 & 0x7FF0000000000000) == 0)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18)
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18)
LABEL_25:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  v12 = (uint64_t *)v10;
  v13 = v10 + 4;
  v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1ECD25528)
    v15 = (uint64_t *)v6;
  else
    v15 = v12;
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 40 * v7;
  if (v7 > 63)
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  else
    v13->i64[0] = -1 << v7;
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1)
    v1 = 1;
  else
    v1 = result;
  v2 = ceil((double)v1 / 0.75);
  if ((~*(_QWORD *)&v2 & 0x7FF0000000000000) == 0)
    goto LABEL_23;
  if (v2 <= -9.22337204e18)
    goto LABEL_24;
  if (v2 >= 9.22337204e18)
    goto LABEL_25;
  v3 = __OFADD__(v1, 1);
  v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2)
    v4 = (uint64_t)v2;
  v5 = 64 - __clz(v4 - 1);
  v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  v7 = 1 << v6;
  v8 = (unint64_t)((1 << v6) + 63) >> 6;
  v9 = canonical specialized generic type metadata accessor for _DictionaryStorage<String, Int>();
  v10 = (int64x2_t *)swift_allocObject(v9, (((16 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (8 << v6), 7uLL);
  v10[1].i64[0] = 0;
  v11 = (double)(1 << v6) * 0.75;
  if ((~*(_QWORD *)&v11 & 0x7FF0000000000000) == 0)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18)
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18)
LABEL_25:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  v12 = (uint64_t *)v10;
  v13 = v10 + 4;
  v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1ECD25528)
    v15 = (uint64_t *)v6;
  else
    v15 = v12;
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63)
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  else
    v13->i64[0] = -1 << v7;
  return (uint64_t)v12;
}

uint64_t partial apply for closure #1 in Sequence<>.contains(_:)(uint64_t a1)
{
  return partial apply for closure #1 in Sequence<>.contains(_:)(a1) & 1;
}

{
  _QWORD *v1;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = v1[2];
  v3 = (const char *)v1[3];
  v6 = v1[4];
  v5 = v1[5];
  swift_getAssociatedTypeWitness(0, v3, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t type metadata accessor for Dictionary.Keys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Keys);
}

uint64_t type metadata accessor for _DictionaryAnyHashableBox(const char *a1, uint64_t a2)
{
  return swift_getCanonicalPrespecializedGenericMetadata(a1, a2, &nominal type descriptor for _DictionaryAnyHashableBox, &flag for loading of canonical specialized generic type metadata for _DictionaryAnyHashableBox);
}

uint64_t type metadata accessor for Dictionary.Iterator._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Iterator._Variant);
}

uint64_t type metadata accessor for _SwiftDeferredNSDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SwiftDeferredNSDictionary);
}

uint64_t type metadata accessor for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DiscontiguousSlice);
}

uint64_t type metadata accessor for DiscontiguousSlice.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DiscontiguousSlice.Index);
}

uint64_t type metadata accessor for RangeSet.Ranges(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for RangeSet.Ranges);
}

uint64_t partial apply for closure #1 in DiscontiguousSlice.distance(from:to:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v3;

  return closure #1 in DiscontiguousSlice.distance(from:to:)(a1, a2, *(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24), a3);
}

uint64_t partial apply for closure #1 in DiscontiguousSlice._index(of:)(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  uint64_t v9;

  v3 = v1[2];
  v4 = (const char *)v1[3];
  v5 = v1[4];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v9 = type metadata accessor for Range(0, AssociatedTypeWitness, AssociatedConformanceWitness, v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(AssociatedConformanceWitness
                                                                                         + 32))(a1 + *(int *)(v9 + 36), v5, AssociatedTypeWitness, AssociatedConformanceWitness) & 1;
}

uint64_t type metadata accessor for EnumeratedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for EnumeratedSequence);
}

uint64_t type metadata accessor for RangeSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for RangeSet);
}

uint64_t type metadata accessor for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyDropWhileSequence);
}

uint64_t type metadata accessor for LazyDropWhileSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyDropWhileSequence.Iterator);
}

uint64_t specialized _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)(uint64_t a1, char **a2)
{
  Swift::_HashTable::Bucket *v2;
  unint64_t v5;
  char **v6;
  Swift::UInt *v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t offset;
  uint64_t result;
  char *v13;
  Swift::_HashTable::Bucket v14;
  uint64_t v15;
  char **v16;
  Swift::UInt *v17;
  __int128 v18;
  __int128 v19;

  v5 = *(_QWORD *)a1;
  v6 = *(char ***)(a1 + 8);
  v7 = *(Swift::UInt **)(a1 + 16);
  v8 = *(_OWORD *)(a1 + 24);
  v9 = *(_OWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 56);
  offset = v2[4].offset;
  if (offset == v2[5].offset)
  {
    result = 0;
  }
  else
  {
    v18 = v9;
    v19 = v8;
    v13 = _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
    *a2 = v13;
    swift_unknownObjectRelease(v13);
    v14.offset = _HashTable.occupiedBucket(after:)(v2[4]).offset;
    v9 = v18;
    v8 = v19;
    v2[4].offset = v14.offset;
    result = 1;
  }
  if (v5 <= 1)
    v15 = 1;
  else
    v15 = v5;
  if (v5)
    v16 = v6;
  else
    v16 = a2;
  *(_QWORD *)a1 = v15;
  *(_QWORD *)(a1 + 8) = v16;
  v17 = &_fastEnumerationStorageMutationsTarget;
  if (v5)
    v17 = v7;
  *(_QWORD *)(a1 + 16) = v17;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 40) = v9;
  *(_QWORD *)(a1 + 56) = v10;
  return result;
}

void specialized _SwiftDictionaryNSEnumerator.init(coder:)()
{
  closure #1 in _unimplementedInitializer(className:initName:file:line:column:)("Swift._SwiftDictionaryNSEnumerator", 34, "init(coder:)", 12, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x38uLL, 0x16uLL);
  __break(1u);
}

void specialized _SwiftDeferredNSDictionary.init(objects:forKeys:count:)()
{
  uint64_t v0;

  *(_QWORD *)(v0 + 16) = 0;
  *(_QWORD *)(v0 + 24) = 0;
  swift_release(v0);
  __break(1u);
}

uint64_t specialized _SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:using:)(uint64_t a1)
{
  _QWORD *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  id *v14;
  void (**v15)(void *, void *, char *, _BYTE *);
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  int64_t v28;
  unint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t v35;
  int64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char *v40;
  id *v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  void (**v47)(void *, void *, char *, _BYTE *);
  id *v48;
  char *v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v52;
  id *v53;
  id *v54;
  id *v55;
  uint64_t v56;
  char *v57;
  id *v59;
  id *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int64_t v65;
  char *v66;
  char *v67;
  id *v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t **)(*v1 + 104);
  v69 = *(v2 - 1);
  v3 = MEMORY[0x1E0C80A78](a1);
  v59 = (id *)((char *)&v59 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0));
  v63 = v4;
  v5 = MEMORY[0x1E0C80A78](v3);
  v68 = (id *)((char *)&v59 - v6);
  v8 = *(uint64_t **)(v7 + 96);
  v9 = *(v8 - 1);
  v10 = MEMORY[0x1E0C80A78](v5);
  v60 = (id *)((char *)&v59 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  v64 = v11;
  v12 = (const void *)MEMORY[0x1E0C80A78](v10);
  v14 = (id *)((char *)&v59 - v13);
  v15 = (void (**)(void *, void *, char *, _BYTE *))_Block_copy(v12);
  v16 = (char *)_SwiftDeferredNSDictionary.bridgeKeys()((uint64_t)v15);
  v19 = (char *)_SwiftDeferredNSDictionary.bridgeValues()((uint64_t)v16);
  v73 = 0;
  v70 = v1;
  v71 = (uint64_t)v16;
  v20 = v1[4];
  v21 = 1 << *(_BYTE *)(v20 + 32);
  v22 = v20 + 64;
  v23 = -1;
  if (v21 < 64)
    v23 = ~(-1 << v21);
  v24 = v23 & *(_QWORD *)(v20 + 64);
  v67 = v16 + 40;
  v65 = (unint64_t)(v21 + 63) >> 6;
  v66 = v19 + 40;
  v61 = v20;
  swift_retain_n(v20, 2, v17, v18);
  v28 = 0;
  v62 = v22;
  if (!v24)
    goto LABEL_7;
LABEL_4:
  v72 = (v24 - 1) & v24;
  v29 = __clz(__rbit64(v24)) | (v28 << 6);
  if (v71)
  {
LABEL_5:
    v30 = *(void **)&v67[8 * v29];
    swift_unknownObjectRetain(v30, v25, v26, v27);
    if (v19)
      goto LABEL_20;
LABEL_22:
    (*(void (**)(id *, unint64_t, uint64_t *))(v69 + 16))(v68, *(_QWORD *)(v70[4] + 56) + *(_QWORD *)(v69 + 72) * v29, v2);
    if (!_swift_isClassOrObjCExistentialType((uint64_t)v2, v2))
    {
      v55 = v59;
      (*(void (**)(id *, id *, uint64_t *))(v69 + 32))(v59, v68, v2);
      v40 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v55, v2, v56, v57);
      goto LABEL_25;
    }
    if (v63 == 8)
    {
      v47 = v15;
      v48 = v14;
      v49 = v19;
      v50 = v8;
      v51 = v2;
      v52 = v9;
      v53 = v68;
      v40 = (char *)*v68;
      swift_unknownObjectRetain(*v68, v44, v45, v46);
      v54 = v53;
      v9 = v52;
      v2 = v51;
      v8 = v50;
      v19 = v49;
      v14 = v48;
      v15 = v47;
      v22 = v62;
      (*(void (**)(id *, uint64_t *))(v69 + 8))(v54, v2);
      goto LABEL_25;
    }
LABEL_33:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  }
  while (1)
  {
    (*(void (**)(id *, unint64_t, uint64_t *))(v9 + 16))(v14, *(_QWORD *)(v70[4] + 48) + *(_QWORD *)(v9 + 72) * v29, v8);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v8, v8))
    {
      if (v64 != 8)
        goto LABEL_33;
      v30 = *v14;
      swift_unknownObjectRetain(*v14, v37, v38, v39);
      (*(void (**)(id *, uint64_t *))(v9 + 8))(v14, v8);
      if (!v19)
        goto LABEL_22;
    }
    else
    {
      v41 = v60;
      (*(void (**)(id *, id *, uint64_t *))(v9 + 32))(v60, v14, v8);
      v30 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v41, v8, v42, v43);
      if (!v19)
        goto LABEL_22;
    }
LABEL_20:
    v40 = *(char **)&v66[8 * v29];
    swift_unknownObjectRetain(v40, v31, v32, v33);
LABEL_25:
    v15[2](v15, v30, v40, &v73);
    if (v73)
    {
      swift_release_n(v61, 2);
      _Block_release(v15);
      swift_unknownObjectRelease(v30);
      swift_unknownObjectRelease(v40);
      swift_release((uint64_t)v19);
      return swift_release(v71);
    }
    swift_unknownObjectRelease(v30);
    swift_unknownObjectRelease(v40);
    v24 = v72;
    if (v72)
      goto LABEL_4;
LABEL_7:
    if (__OFADD__(v28++, 1))
      __break(1u);
    if (v28 >= v65)
      break;
    v35 = *(_QWORD *)(v22 + 8 * v28);
    if (!v35)
    {
      v36 = v28 + 1;
      if (v28 + 1 >= v65)
        break;
      v35 = *(_QWORD *)(v22 + 8 * v36);
      if (!v35)
      {
        while (1)
        {
          v28 = v36 + 1;
          if (__OFADD__(v36, 1))
            break;
          if (v28 >= v65)
            goto LABEL_29;
          v35 = *(_QWORD *)(v22 + 8 * v28);
          ++v36;
          if (v35)
            goto LABEL_16;
        }
        __break(1u);
        goto LABEL_33;
      }
      ++v28;
    }
LABEL_16:
    v72 = (v35 - 1) & v35;
    v29 = __clz(__rbit64(v35)) + (v28 << 6);
    if (v71)
      goto LABEL_5;
  }
LABEL_29:
  _Block_release(v15);
  swift_release((uint64_t)v19);
  swift_release_n(v61, 2);
  return swift_release(v71);
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)(uint64_t result, uint64_t (*a2)(_QWORD))
{
  uint64_t v2;
  double v3;
  BOOL v4;
  uint64_t v5;
  char v6;
  unsigned __int8 v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int64x2_t *v11;
  double v12;
  uint64_t *v13;
  int64x2_t *v14;
  uint64_t v15;
  uint64_t *v16;

  if (result <= 1)
    v2 = 1;
  else
    v2 = result;
  v3 = ceil((double)v2 / 0.75);
  if ((~*(_QWORD *)&v3 & 0x7FF0000000000000) == 0)
    goto LABEL_23;
  if (v3 <= -9.22337204e18)
    goto LABEL_24;
  if (v3 >= 9.22337204e18)
    goto LABEL_25;
  v4 = __OFADD__(v2, 1);
  v5 = v2 + 1;
  if (v4)
  {
    __break(1u);
    return result;
  }
  if (v5 <= (uint64_t)v3)
    v5 = (uint64_t)v3;
  v6 = 64 - __clz(v5 - 1);
  v7 = (unint64_t)v5 <= 2 ? 1 : v6;
  v8 = 1 << v7;
  v9 = (unint64_t)((1 << v7) + 63) >> 6;
  v10 = a2(0);
  v11 = (int64x2_t *)swift_allocObject(v10, (((8 << v7) + 8 * v9 + 71) & 0xFFFFFFFFFFFFFFF8) + (8 << v7), 7uLL);
  v11[1].i64[0] = 0;
  v12 = (double)(1 << v7) * 0.75;
  if ((~*(_QWORD *)&v12 & 0x7FF0000000000000) == 0)
LABEL_23:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v12 <= -9.22337204e18)
LABEL_24:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v12 >= 9.22337204e18)
LABEL_25:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  v13 = (uint64_t *)v11;
  v14 = v11 + 4;
  v15 = (uint64_t)&v11[4].i64[v9];
  v11[1].i64[1] = (uint64_t)v12;
  v11[2].i8[0] = v7;
  v11[2].i8[1] = 0;
  v11[2].i16[1] = 0;
  v11[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v11);
  if ((_BYTE)qword_1ECD25528)
    v16 = (uint64_t *)v7;
  else
    v16 = v13;
  v13[5] = (uint64_t)v16;
  v13[6] = v15;
  v13[7] = v15 + 8 * v8;
  if (v8 > 63)
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v9, v14);
  else
    v14->i64[0] = -1 << v8;
  return (uint64_t)v13;
}

uint64_t specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, _QWORD *a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  Swift::Int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t WitnessTable;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  id v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[3];
  Swift::Int v45;

  v10 = type metadata accessor for Range(0, a4, a5, a4);
  v11 = *(_QWORD *)(v10 - 8);
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v38 - v13;
  v15 = a2[2];
  if ((unint64_t)v15 < 2)
  {
    if (v15)
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v11 + 16))(v14, (unint64_t)a2+ ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80)), v10);
      if (((*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 16))(a1 + *(int *)(v10 + 36), v14, a4, a5) & 1) == 0)
      {
        v32 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 40))(a1, &v14[*(int *)(v10 + 36)], a4, a5);
        (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
        return v32 & 1;
      }
      (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    }
    return 0;
  }
  else
  {
    v39 = &v38;
    v44[2] = a2;
    MEMORY[0x1E0C80A78](v12);
    v34 = a4;
    v35 = a5;
    LOBYTE(v36) = a3 & 1;
    v37 = a1;
    v18 = type metadata accessor for ContiguousArray(0, v10, v16, v17);
    v38 = a1;
    v19 = v18;
    WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, v18, v20);
    Collection._partitioningIndex(where:)((uint64_t (*)(char *))partial apply for closure #1 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:), (uint64_t)(&v38 - 6), v19, WitnessTable, (char *)&v45);
    v22 = v45;
    if (v15 < v45)
      goto LABEL_4;
    ContiguousArray._checkIndex(_:)(v45);
    ContiguousArray._checkIndex(_:)(v15);
    v39 = &v38;
    v40 = a2;
    v41 = (char *)a2 + ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80));
    v42 = v22;
    v43 = (2 * v15) | 1;
    MEMORY[0x1E0C80A78](v23);
    v34 = a4;
    v35 = a5;
    LOBYTE(v36) = a3 & 1;
    v37 = v38;
    v26 = type metadata accessor for ArraySlice(0, v10, v24, v25);
    swift_retain(a2, v27, v28, v29);
    v31 = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, v26, v30);
    Collection._partitioningIndex(where:)((uint64_t (*)(char *))partial apply for closure #2 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:), (uint64_t)(&v38 - 6), v26, v31, (char *)v44);
    swift_unknownObjectRelease(v40);
    if (v44[0] < v22)
LABEL_4:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return v22;
}

uint64_t specialized EmptyCollection.subscript.setter(uint64_t result, uint64_t a2)
{
  if (result | a2)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x76uLL, 0);
  return result;
}

uint64_t type metadata accessor for __SharedStringStorage()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _IteratorBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _IteratorBox);
}

uint64_t type metadata accessor for _ClosureBasedIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _ClosureBasedIterator);
}

uint64_t type metadata accessor for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DropFirstSequence);
}

uint64_t type metadata accessor for _SequenceBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SequenceBox);
}

uint64_t type metadata accessor for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DropWhileSequence);
}

uint64_t type metadata accessor for PrefixSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for PrefixSequence);
}

uint64_t type metadata accessor for _BidirectionalCollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _BidirectionalCollectionBox);
}

uint64_t type metadata accessor for _RandomAccessCollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _RandomAccessCollectionBox);
}

uint64_t type metadata accessor for _ClosureBasedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _ClosureBasedSequence);
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error)(uint64_t a1, _QWORD *a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error)(a1, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  result = (*(uint64_t (**)(void))(v2 + 32))();
  if (v3)
    *a2 = v3;
  return result;
}

_QWORD *partial apply for specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)(uint64_t a1)
{
  uint64_t v1;

  return specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)(a1, *(uint64_t (**)(uint64_t, uint64_t *))(v1 + 32));
}

uint64_t type metadata accessor for _AnyBidirectionalCollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnyBidirectionalCollectionBox);
}

uint64_t type metadata accessor for _AnyRandomAccessCollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnyRandomAccessCollectionBox);
}

uint64_t type metadata accessor for LazyFilterSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyFilterSequence);
}

uint64_t type metadata accessor for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyFilterSequence.Iterator);
}

void sub_1815A7134(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v5 = *(_QWORD *)(v4 + 16);
  v6 = type metadata accessor for LazyFilterSequence(0, v5, *(_QWORD *)(v4 + 24), a4);
  v7 = *(_QWORD *)(v6 - 8);
  v8 = (*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80);
  v9 = (*(_QWORD *)(v7 + 64) + v8 + 7) & 0xFFFFFFFFFFFFFFF8;
  v10 = v4 + v8;
  (*(void (**)(unint64_t, uint64_t))(*(_QWORD *)(v5 - 8) + 8))(v4 + v8, v5);
  swift_release(*(_QWORD *)(v10 + *(int *)(v6 + 36) + 8));
  swift_release(*(_QWORD *)(v4 + v9 + 8));
  swift_deallocObject(v4);
}

uint64_t partial apply for closure #1 in LazyFilterSequence.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v6 = *(_QWORD *)(v4 + 16);
  v7 = *(const char **)(v4 + 24);
  v8 = *(_QWORD *)(type metadata accessor for LazyFilterSequence(0, v6, (uint64_t)v7, a4) - 8);
  v9 = (*(unsigned __int8 *)(v8 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);
  v10 = v4 + ((*(_QWORD *)(v8 + 64) + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  return closure #1 in LazyFilterSequence.filter(_:)(a1, v4 + v9, *(uint64_t (**)(char *))v10, *(_QWORD *)(v10 + 8), v6, v7);
}

void sub_1815A7250()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

void sub_1815A7264()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t partial apply for closure #2 in LazySequenceProtocol.compactMap<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  return closure #2 in LazySequenceProtocol.compactMap<A>(_:)(a1, *(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 32), a2);
}

uint64_t type metadata accessor for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for FlattenSequence.Iterator);
}

uint64_t type metadata accessor for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for FlattenSequence<>.Index);
}

float specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(int a1, char a2, __int16 a3)
{
  float result;

  LODWORD(result) = (a1 << 15) | ((a2 & 0x1F) << 10) | a3 & 0x3FF;
  return result;
}

float specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(int a1, unsigned __int8 a2, int a3)
{
  float result;

  LODWORD(result) = (a1 << 31) | (a2 << 23) | a3 & 0x7FFFFF;
  return result;
}

uint64_t type metadata accessor for _ConcreteHashableBox(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ConcreteHashableBox, &flag for loading of canonical specialized generic type metadata for _ConcreteHashableBox);
}

uint64_t outlined assign with take of AnyHashable(__int128 *a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;

  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a2);
  v4 = *a1;
  v5 = a1[1];
  *(_QWORD *)(a2 + 32) = *((_QWORD *)a1 + 4);
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = v5;
  return a2;
}

uint64_t partial apply for closure #1 in FixedWidthInteger.init<A>(_:radix:)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  return closure #1 in FixedWidthInteger.init<A>(_:radix:)(a1, a2, v3[6], v3[2], v3[4], a3);
}

unint64_t lazy protocol witness table accessor for type UInt16 and conformance UInt16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16, &type metadata for UInt16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type UInt and conformance UInt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt, &type metadata for UInt, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt, &type metadata for UInt, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt, &type metadata for UInt, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type UInt64 and conformance UInt64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt64, &type metadata for UInt64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt64, &type metadata for UInt64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt64, &type metadata for UInt64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }
  return result;
}

uint64_t type metadata accessor for JoinedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for JoinedSequence);
}

uint64_t type metadata accessor for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for JoinedSequence.Iterator);
}

uint64_t specialized static _Int128./= infix(_:_:)(_QWORD *a1, Swift::_Int128 dividingBy)
{
  uint64_t result;
  uint64_t v5;

  if (dividingBy.high == -1)
  {
    if (dividingBy.low == -1 && a1[1] == 0x8000000000000000 && *a1 == 0)
LABEL_11:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  else if (!dividingBy.high && !dividingBy.low)
  {
    goto LABEL_11;
  }
  *(_OWORD *)&result = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(dividingBy);
  *a1 = result;
  a1[1] = v5;
  return result;
}

Swift::UInt64 specialized static _UInt128./ infix(_:_:)(Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, unint64_t a4)
{
  char v7;
  Swift::UInt64 v8;
  Swift::UInt64 v9;
  Swift::tuple_high_UInt64_low_UInt64 v10;

  if (!(a4 | a3))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1CEuLL, 0);
  v10.low = a2;
  v10.high = (Swift::UInt64)&v7;
  specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, a1, a4, a3);
  return v9;
}

unint64_t specialized static _Int128.* infix(_:_:)(unint64_t a1, int64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  int64_t v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  _BOOL4 v9;
  unint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  BOOL v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  if (a2)
  {
    if (!a4)
    {
      v5 = (unsigned __int128)-(__int128)__PAIR128__(v4, a1) >> 64;
      a4 = 0;
      if (a2 >= 0)
      {
        LODWORD(v5) = 0;
      }
      else
      {
        a1 = -(uint64_t)a1;
        a2 = v5;
        LODWORD(v5) = a3 != 0;
      }
      goto LABEL_19;
    }
    if (((a4 ^ a2) & 0x8000000000000000) == 0)
    {
      if (a2 < 0)
      {
LABEL_17:
        v5 = (a4 ^ a2) >> 63;
        v6 = a1 == 0;
        a1 = -(uint64_t)a1;
        a2 = -(a2 + !v6);
        if ((a4 & 0x8000000000000000) == 0)
          goto LABEL_19;
        goto LABEL_18;
      }
      goto LABEL_9;
    }
    if (a2 < 0)
      goto LABEL_17;
    LODWORD(v5) = 1;
    if ((a4 & 0x8000000000000000) == 0)
      goto LABEL_19;
  }
  else
  {
    if ((a4 & 0x8000000000000000) == 0 || !a1)
    {
LABEL_9:
      LODWORD(v5) = 0;
      if ((a4 & 0x8000000000000000) == 0)
        goto LABEL_19;
      goto LABEL_18;
    }
    a2 = 0;
    LODWORD(v5) = 1;
  }
LABEL_18:
  v6 = a3 == 0;
  a3 = -(uint64_t)a3;
  a4 = -(uint64_t)(a4 + !v6);
LABEL_19:
  v7 = !is_mul_ok(a2, a3);
  v8 = !is_mul_ok(a1, a4);
  v9 = __CFADD__(a2 * a3, a1 * a4);
  v10 = a1 * a3;
  v11 = (__PAIR128__(a4, a3) * __PAIR128__(a2, a1)) >> 64;
  v12 = __CFADD__(a2 * a3 + a1 * a4, (a1 * (unsigned __int128)a3) >> 64);
  if (a4)
    v13 = a2 == 0;
  else
    v13 = 1;
  if (!v13 || v7 || v8 || v9)
  {
    if (!(_DWORD)v5)
      goto LABEL_47;
    v14 = -v11;
    v12 = 1;
    v6 = v10 == 0;
    v15 = -(uint64_t)v10;
    if (v6)
      goto LABEL_40;
    goto LABEL_39;
  }
  if (!(_DWORD)v5)
    goto LABEL_44;
  v14 = -v11;
  v6 = v10 == 0;
  v15 = -(uint64_t)v10;
  if (!v6)
LABEL_39:
    --v14;
LABEL_40:
  v6 = v15 != 0;
  v16 = v15 - 1;
  v17 = !v6;
  v11 = (__PAIR128__(v14, v16) + __PAIR128__(v17 << 63 >> 63, 1)) >> 64;
  v10 = v16 + 1;
LABEL_44:
  if (v12 || ((v5 ^ (v11 >= 0)) & 1) == 0)
LABEL_47:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in *", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x29AuLL, 0);
  return v10;
}

uint64_t *specialized static _UInt128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = *result;
  v3 = result[1];
  v4 = v3 >> a2;
  v5 = (v3 << -a2) | ((unint64_t)*result >> a2);
  if ((a2 & 0x7F) != 0)
  {
    v3 >>= a2;
    v2 = v5;
  }
  if ((a2 & 0x7Fu) > 0x3FuLL)
  {
    v3 = 0;
    v2 = v4;
  }
  *result = v2;
  result[1] = v3;
  return result;
}

uint64_t *specialized static _Int128.&<<= infix(_:_:)(uint64_t *result, char a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *result;
  v3 = result[1];
  if ((a2 & 0x7F) != 0)
  {
    v3 = (v3 << a2) | ((unint64_t)*result >> -a2);
    v2 = *result << a2;
  }
  if ((a2 & 0x7Fu) > 0x3FuLL)
  {
    v3 = *result << a2;
    v2 = 0;
  }
  *result = v2;
  result[1] = v3;
  return result;
}

void specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[7];
  __int128 v19[3];
  _BYTE v20[8];

  v18[6] = a2;
  v12 = type metadata accessor for Optional(0, a7, a3, a4);
  v13 = MEMORY[0x1E0C80A78](v12);
  v14 = *(_QWORD *)(a6 - 8);
  v18[3] = a6;
  v18[4] = v14;
  v15 = MEMORY[0x1E0C80A78](v13);
  v16 = MEMORY[0x1E0C80A78](v15);
  v18[5] = a7;
  MEMORY[0x1E0C80A78](v16);
  v18[2] = (char *)v18 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  RawKeyPathComponent.value.getter(a3, a4, a5, (uint64_t *)v19);
  outlined init with take of KeyPathComponent(v19, (uint64_t)v20);
  __asm { BR              X11 }
}

uint64_t sub_1815A7910()
{
  uint64_t v0;
  uint64_t v1;

  return v0 + *(_QWORD *)(v1 - 144);
}

uint64_t type metadata accessor for RawKeyPathComponent.ProjectionResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for RawKeyPathComponent.ProjectionResult);
}

uint64_t type metadata accessor for KeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for KeyPath);
}

uint64_t type metadata accessor for PartialKeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for PartialKeyPath);
}

uint64_t type metadata accessor for ReferenceWritableKeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ReferenceWritableKeyPath);
}

void partial apply for closure #1 in closure #1 in closure #1 in _appendingKeyPaths<A, B, C, D>(root:leaf:)(char *a1, void *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 v9;
  char v10;
  int v11;
  uint64_t v12;
  Swift::UnsafeMutableRawBufferPointer v13;
  char v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char v18;
  Swift::UnsafeMutableRawBufferPointer v19;
  uint64_t v20;
  char v21;
  char v22;
  uint64_t v23;
  Swift::UnsafeMutableRawBufferPointer v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  Swift::UnsafeMutableRawBufferPointer v28;
  Swift::UnsafeMutableRawBufferPointer into;

  v3 = *(_QWORD *)(v2 + 48);
  v4 = *(uint64_t **)(v2 + 56);
  v6 = *(_QWORD *)(v2 + 64);
  v5 = *(_QWORD *)(v2 + 72);
  v7 = *v4;
  if (*(uint64_t *)(v2 + 32) < 1)
  {
    v8 = *v4;
  }
  else
  {
    if (!a1)
      goto LABEL_31;
    **(_QWORD **)(v2 + 40) = &a1[v3];
    a1 = (char *)specialized UnsafeMutableRawBufferPointer.init<A>(_:)((uint64_t)a1, v3);
    v8 = *v4;
  }
  into._position.value._rawValue = a1;
  into._end.value._rawValue = a2;
  v9 = (*(uint64_t (**)(void))(v8 + 160))();
  if (__OFSUB__(v3, 8))
  {
    __break(1u);
LABEL_31:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if (*(_BYTE *)(v6 + 16) == 1)
    v10 = *(_BYTE *)(v5 + 16);
  else
    v10 = 0;
  v11 = v9;
  v12 = specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)(v3 - 8, v10, *(_BYTE *)(v6 + 17) & 1u | (v9 == 2));
  v13 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v12, 0, (uint64_t)v13._position.value._rawValue, (uint64_t)v13._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  v14 = *(_BYTE *)(v5 + 17);
  v16 = KeyPathBuffer.next()();
  if (v15)
  {
    v17 = v15;
    do
    {
      if (v16 < 0)
        v18 = v14 ^ 1;
      else
        v18 = 0;
      RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v18);
      v19 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8, 8);
      if (!v19._position.value._rawValue
        || (char *)v19._end.value._rawValue - (char *)v19._position.value._rawValue <= 7)
      {
LABEL_29:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes out of bounds", 54, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BDuLL, 0);
      }
      *(_QWORD *)v19._position.value._rawValue = v17;
      v16 = KeyPathBuffer.next()();
      v17 = v20;
    }
    while (v20);
  }
  if (v11 == 2)
    v21 = 1;
  else
    v21 = v14;
  if ((v21 & 1) != 0)
    v22 = v14 ^ 1;
  else
    v22 = v16 < 0;
  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v22);
  v23 = *(_QWORD *)(v7 + 144);
  v24 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8, 8);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v23, 0, (uint64_t)v24._position.value._rawValue, (uint64_t)v24._end.value._rawValue);
  while (1)
  {
    v25 = KeyPathBuffer.next()();
    v27 = v26;
    RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v25 < 0);
    if (!v27)
      break;
    v28 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8, 8);
    if (!v28._position.value._rawValue || (char *)v28._end.value._rawValue - (char *)v28._position.value._rawValue <= 7)
      goto LABEL_29;
    *(_QWORD *)v28._position.value._rawValue = v27;
  }
}

uint64_t type metadata accessor for WritableKeyPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for WritableKeyPath);
}

unint64_t partial apply for closure #1 in _swift_getKeyPath(pattern:arguments:)(_DWORD *a1, _BYTE *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t result;

  v3 = *(_QWORD *)(v2 + 16);
  result = _instantiateKeyPathBuffer(_:_:_:_:)(*(_QWORD *)(v2 + 24), a1, a2, *(void **)(v2 + 32), *(void **)(v2 + 40));
  *(_DWORD *)v3 = result;
  *(_BYTE *)(v3 + 4) = BYTE4(result) & 1;
  return result;
}

void partial apply for closure #2 in _rerootKeyPath<A>(_:to:)(void *a1, void *a2)
{
  uint64_t v2;
  unint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  Swift::UnsafeMutableRawBufferPointer v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  unint64_t v12;
  _DWORD *v13;
  int v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  Swift::UnsafeMutableRawBufferPointer into;

  v3 = *(_QWORD *)(v2 + 16);
  v4 = *(_BYTE *)(v2 + 24);
  v5 = *(_BYTE *)(v2 + 25);
  v6 = *(_QWORD *)(v2 + 32);
  into._position.value._rawValue = a1;
  into._end.value._rawValue = a2;
  v7 = specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)(v3, v4, v5);
  v8 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v7, 0, (uint64_t)v8._position.value._rawValue, (uint64_t)v8._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  if ((((_BYTE)v6 + 24) & 3) != 0)
LABEL_32:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  v9 = v6 + 32 + (*(_DWORD *)(v6 + 24) & 0xFFFFFF);
  v25 = v6 + 32;
  v26 = v9;
  while (1)
  {
    v10 = (int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v25, v26);
    if (!v10)
      goto LABEL_35;
    v12 = v11 - (_QWORD)v10 - 4;
    if (__OFSUB__(v11 - (_QWORD)v10, 4))
    {
      __break(1u);
      goto LABEL_32;
    }
    if ((v12 & 0x8000000000000000) != 0)
      goto LABEL_30;
    v13 = v10 + 1;
    v14 = *v10;
    v15 = HIBYTE(*v10) & 0x7F;
    if (v15 != 1)
    {
      if (v15 == 2)
      {
        if ((v14 & 0x400000) != 0)
          v16 = 28;
        else
          v16 = 20;
        if ((v14 & 0x80000) != 0)
        {
          if ((v14 & 0x400000) != 0)
            v17 = 6;
          else
            v17 = 4;
          v18 = (uint64_t)&v10[v17 + 2];
          if ((v18 & 7) != 0)
            goto LABEL_32;
          v19 = v16 + 16;
          v20 = *(_QWORD *)v18;
          v21 = __OFADD__(v19, v20);
          v16 = v19 + v20;
          if (v21)
          {
            __break(1u);
LABEL_34:
            __break(1u);
LABEL_35:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
          }
          if ((v14 & 0x10) != 0)
          {
            v21 = __OFADD__(v16, 8);
            v16 += 8;
            if (v21)
              goto LABEL_34;
          }
          if ((v16 & 0x8000000000000000) != 0)
            goto LABEL_30;
        }
        goto LABEL_22;
      }
      if (v15 != 3)
      {
        v16 = 0;
        v22 = (uint64_t)(v10 + 1);
        goto LABEL_25;
      }
    }
    v16 = 4 * ((~v14 & 0x7FFFFF) == 0);
LABEL_22:
    if (v12 < v16)
LABEL_30:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
    v22 = (uint64_t)v13 + v16;
LABEL_25:
    v25 = v22;
    v26 = (uint64_t)v13 + v12;
    if (v12 == v16)
      break;
    v23 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v25, 1);
    if (!v23)
      goto LABEL_35;
    v24 = *v23;
    RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v14 < 0);
    if (!v24)
      return;
  }
  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v14 < 0);
}

uint64_t type metadata accessor for KeyValuePairs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for KeyValuePairs);
}

uint64_t partial apply for closure #1 in _StringGuts.withCString<A>(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 24))();
}

uint64_t partial apply for closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)(void *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;

  return closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)(a1, *(_QWORD *)(v4 + 16), *(_QWORD *)(v4 + 24), a4);
}

uint64_t type metadata accessor for ManagedBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ManagedBuffer);
}

uint64_t type metadata accessor for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyMapSequence.Iterator);
}

void sub_1815A8270()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v1 = v0[2];
  v2 = type metadata accessor for LazyMapSequence(0, v1, v0[3], v0[5]);
  v3 = *(unsigned __int8 *)(*(_QWORD *)(v2 - 8) + 80);
  v4 = (v3 + 64) & ~v3;
  swift_release(v0[7]);
  v5 = (char *)v0 + v4;
  (*(void (**)(char *, uint64_t))(*(_QWORD *)(v1 - 8) + 8))(v5, v1);
  swift_release(*(_QWORD *)&v5[*(int *)(v2 + 44) + 8]);
  swift_deallocObject((uint64_t)v0);
}

uint64_t partial apply for closure #1 in LazyMapSequence.map<A>(_:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(v1 + 16);
  v4 = *(_QWORD *)(v1 + 24);
  v5 = *(unsigned __int8 *)(*(_QWORD *)(type metadata accessor for LazyMapSequence(0, v3, v4, *(_QWORD *)(v1 + 40)) - 8)
                          + 80);
  return closure #1 in LazyMapSequence.map<A>(_:)(a1, *(void (**)(char *))(v1 + 48), *(_QWORD *)(v1 + 56), v1 + ((v5 + 64) & ~v5), v3, v4);
}

void sub_1815A838C()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v1 = v0[2];
  v2 = type metadata accessor for LazyMapSequence(0, v1, v0[3], *(_QWORD *)(v0[5] + 8));
  v3 = *(unsigned __int8 *)(*(_QWORD *)(v2 - 8) + 80);
  v4 = (v3 + 64) & ~v3;
  swift_release(v0[7]);
  v5 = (char *)v0 + v4;
  (*(void (**)(char *, uint64_t))(*(_QWORD *)(v1 - 8) + 8))(v5, v1);
  swift_release(*(_QWORD *)&v5[*(int *)(v2 + 44) + 8]);
  swift_deallocObject((uint64_t)v0);
}

uint64_t partial apply for closure #1 in LazyMapSequence<>.map<A>(_:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(_QWORD *)(v1 + 16);
  v4 = *(_QWORD *)(v1 + 24);
  v5 = *(unsigned __int8 *)(*(_QWORD *)(type metadata accessor for LazyMapSequence(0, v3, v4, *(_QWORD *)(*(_QWORD *)(v1 + 40) + 8))- 8)+ 80);
  return closure #1 in LazyMapSequence<>.map<A>(_:)(a1, *(void (**)(char *))(v1 + 48), *(_QWORD *)(v1 + 56), v1 + ((v5 + 64) & ~v5), v3, v4);
}

uint64_t specialized RawKeyPathComponent.Header.init(computedWithIDKind:mutating:settable:hasArguments:instantiatedFromExternalWithArguments:)(char a1, char a2, char a3, char a4, char a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if ((a2 & 1) == 0)
  {
    if ((a3 & 1) == 0)
    {
      v7 = 0;
      if ((a4 & 1) != 0)
        v5 = 0x80000;
      else
        v5 = 0;
      if ((a5 & 1) == 0)
        goto LABEL_24;
      goto LABEL_22;
    }
    if ((a4 & 1) == 0)
    {
      v5 = 0x400000;
      if ((a5 & 1) != 0)
        goto LABEL_22;
LABEL_23:
      v7 = 0;
      goto LABEL_24;
    }
    v5 = 4718592;
LABEL_14:
    if ((a5 & 1) != 0)
      goto LABEL_22;
    goto LABEL_23;
  }
  if ((a3 & 1) != 0)
    v5 = 13107200;
  else
    v5 = 8912896;
  if ((a3 & 1) != 0)
    v6 = 12582912;
  else
    v6 = 0x800000;
  if ((a4 & 1) != 0)
    goto LABEL_14;
  v5 = v6;
  if ((a5 & 1) == 0)
    goto LABEL_23;
LABEL_22:
  v7 = 16;
LABEL_24:
  v8 = v5 | v7;
  if (a1)
  {
    v9 = v8 | 0x200000;
    v8 |= 0x100000u;
    if (a1 == 1)
      v8 = v9;
  }
  return v8 | 0x2000000u;
}

uint64_t specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)(unint64_t a1, char a2, char a3)
{
  int v3;

  if ((a1 & 0x8000000000000000) != 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  if (HIDWORD(a1))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  if ((a2 & 1) == 0)
  {
    if ((a3 & 1) != 0)
      goto LABEL_5;
LABEL_7:
    v3 = 0;
    return a1 | v3;
  }
  LODWORD(a1) = a1 | 0x80000000;
  if ((a3 & 1) == 0)
    goto LABEL_7;
LABEL_5:
  v3 = 0x40000000;
  return a1 | v3;
}

uint64_t specialized GetKeyPathClassAndInstanceSizeFromPattern.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)(uint64_t result, uint64_t a2, uint64_t (*a3)(_QWORD), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  uint64_t v8;
  unint64_t v9;
  char v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;

  if (a2)
  {
    if ((result & 1) != 0)
      goto LABEL_6;
    v11 = 2;
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v8 + 8) = v11;
LABEL_6:
  v12 = *(_QWORD *)v8 + 4;
  if (__OFADD__(*(_QWORD *)v8, 4))
  {
    __break(1u);
    goto LABEL_36;
  }
  *(_QWORD *)v8 = v12;
  v13 = __OFADD__(v12, 7);
  v14 = v12 + 7;
  if (v13)
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }
  v15 = v14 & 0xFFFFFFFFFFFFFFF8;
  v13 = __OFADD__(v15, 16);
  v16 = v15 + 16;
  if (v13)
  {
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }
  *(_QWORD *)v8 = v16;
  if (!a2)
    goto LABEL_12;
  v13 = __OFADD__(v16, 8);
  v16 += 8;
  if (v13)
  {
LABEL_38:
    __break(1u);
    goto LABEL_39;
  }
  *(_QWORD *)v8 = v16;
LABEL_12:
  if (a3)
  {
    v9 = v16 + 16;
    LOBYTE(v16) = __OFADD__(v16, 16);
    if ((a8 & 1) != 0)
      goto LABEL_31;
    if ((v16 & 1) == 0)
    {
      result = a3(*(_QWORD *)(v8 + 40));
      v17 = v9 + result;
      if (!__OFADD__(v9, result))
      {
        *(_QWORD *)v8 = v17;
        v13 = __OFADD__(v17, 7);
        v18 = v17 + 7;
        if (!v13)
        {
          v19 = v18 & 0xFFFFFFFFFFFFFFF8;
          v13 = __OFADD__(v19, 8);
          v20 = v19 + 8;
          if (!v13)
          {
            if ((unint64_t)(a7 - 0x1000000000000000) >> 61 == 7)
            {
              v13 = __OFADD__(v20, 8 * a7);
              v16 = v20 + 8 * a7;
              if (!v13)
                goto LABEL_33;
              __break(1u);
              goto LABEL_25;
            }
LABEL_43:
            __break(1u);
            goto LABEL_44;
          }
LABEL_42:
          __break(1u);
          goto LABEL_43;
        }
LABEL_41:
        __break(1u);
        goto LABEL_42;
      }
LABEL_40:
      __break(1u);
      goto LABEL_41;
    }
LABEL_39:
    __break(1u);
    goto LABEL_40;
  }
LABEL_25:
  if ((a8 & 1) != 0)
    return result;
  v13 = __OFADD__(v16, 16);
  v21 = v16 + 16;
  if (v13)
    goto LABEL_46;
  if ((unint64_t)(a7 - 0x1000000000000000) >> 61 != 7)
  {
LABEL_47:
    __break(1u);
    return result;
  }
  v13 = __OFADD__(v21, 8 * a7);
  v16 = v21 + 8 * a7;
  if (!v13)
    goto LABEL_33;
  __break(1u);
LABEL_31:
  if ((v16 & 1) != 0)
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  result = a3(*(_QWORD *)(v8 + 40));
  v16 = v9 + result;
  if (__OFADD__(v9, result))
  {
LABEL_45:
    __break(1u);
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }
LABEL_33:
  *(_QWORD *)v8 = v16;
  return result;
}

uint64_t specialized MutableCollection<>.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v9;
  uint64_t v10;
  uint64_t WitnessTable;

  v9 = type metadata accessor for Slice(0, a3, *(_QWORD *)(a4 + 8), a4);
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, v9, v10);
  return _writeBackMutableSlice<A, B>(_:bounds:slice:)(v4, a2, a1, a3, v9, a4, WitnessTable);
}

uint64_t partial apply for closure #1 in MutableCollection.moveSubranges(_:to:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  const char *v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_QWORD *)(v1 + 16);
  v4 = *(const char **)(*(_QWORD *)(v1 + 24) + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v8 = type metadata accessor for RangeSet.Ranges(0, AssociatedTypeWitness, AssociatedConformanceWitness, v7);
  return RangeSet.Ranges._contains(_:)(a1, v8) & 1;
}

BOOL partial apply for closure #2 in MutableCollection.moveSubranges(_:to:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  const char *v4;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_QWORD *)(v1 + 16);
  v4 = *(const char **)(*(_QWORD *)(v1 + 24) + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v3, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v8 = type metadata accessor for RangeSet.Ranges(0, AssociatedTypeWitness, AssociatedConformanceWitness, v7);
  return (RangeSet.Ranges._contains(_:)(a1, v8) & 1) == 0;
}

uint64_t type metadata accessor for _SetStorage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SetStorage, &flag for loading of canonical specialized generic type metadata for _SetStorage);
}

uint64_t type metadata accessor for _NativeSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _NativeSet);
}

uint64_t type metadata accessor for __CocoaSet.Index.Storage()
{
  return objc_opt_self();
}

uint64_t type metadata accessor for _NewtypeWrapperAnyHashableBox(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for _NewtypeWrapperAnyHashableBox);
}

unint64_t *outlined copy of (@escaping @callee_guaranteed (@guaranteed String) -> ())?(unint64_t *result, unint64_t *a2, uint64_t a3, char *a4)
{
  if (result)
    return swift_retain(a2, (uint64_t)a2, a3, a4);
  return result;
}

uint64_t outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?(uint64_t result, uint64_t a2)
{
  if (result)
    return swift_release(a2);
  return result;
}

uint64_t type metadata accessor for LazyPrefixWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence);
}

uint64_t type metadata accessor for LazyPrefixWhileSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence.Iterator);
}

uint64_t type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence<>._IndexRepresentation);
}

uint64_t type metadata accessor for LazyPrefixWhileSequence<>.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for LazyPrefixWhileSequence<>.Index);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<AnyHashable>()
{
  type metadata accessor for __ContiguousArrayStorageBase();
  return objc_opt_self();
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int64>()
{
  type metadata accessor for __ContiguousArrayStorageBase();
  return objc_opt_self();
}

void specialized MutableCollection.subscript.setter()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0, 0xE000000000000000, "Swift/MutableCollection.swift", 29, 2, 0x131uLL, 0);
}

Swift::UInt64 specialized Collection.subscript.getter(unint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  Swift::String::Index v6;
  Swift::String::Index v7;
  Swift::UInt64 result;

  v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0)
    v4 = a1;
  v5 = 7;
  if (((a2 >> 60) & ((a1 & 0x800000000000000) == 0)) != 0)
    v5 = 11;
  v6._rawBits = v5 | (v4 << 16);
  v7._rawBits = 15;
  result = _StringGuts.validateScalarRange(_:)(v7, v6, a1, a2);
  if (result < 0x10000)
    result |= 3uLL;
  return result;
}

void specialized _SliceBuffer.subscript.setter()
{
  _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0x6C706D6920746F6ELL, 0xEF6465746E656D65, "Swift/SliceBuffer.swift", 23, 2, 0x198uLL, 0);
}

uint64_t specialized Slice<>.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t WitnessTable;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  v12 = a4;
  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a3, &v12);
  v10 = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a3, v9);
  return _writeBackMutableSlice<A, B>(_:bounds:slice:)(v4, a2, a1, a3, a3, WitnessTable, v10);
}

uint64_t specialized MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  const char *v12;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v20;

  v12 = *(const char **)(a5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v12, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RangeExpression, (uint64_t)&associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  v16 = type metadata accessor for Range(0, AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  MEMORY[0x1E0C80A78](v16);
  v18 = (char *)&v20 - v17;
  (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(a6 + 24))(v6, a3, v12, a4, a6);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 40))(a1, v18, a3, a5);
}

uint64_t specialized MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t AssociatedConformanceWitness;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  void (*v36)(uint64_t, uint64_t);
  void (*v37)(char *, char *, unint64_t);
  void (*v38)(char *, unint64_t);
  void (*v39)(char *, char *, unint64_t);
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  unint64_t *v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  char *v52;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t *TupleTypeMetadata2;
  char *v64;
  uint64_t v65;
  char *v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;

  v65 = a1;
  v6 = *(_QWORD *)(a3 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (const char *)v6, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, AssociatedTypeWitness, AssociatedTypeWitness, "lower upper ", 0);
  v8 = MEMORY[0x1E0C80A78](TupleTypeMetadata2);
  v64 = (char *)&v54 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1E0C80A78](v8);
  v60 = (char *)&v54 - v10;
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v6, a2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
  v13 = type metadata accessor for Range(0, AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  v61 = *(_QWORD *)(v13 - 8);
  v62 = v13;
  v14 = MEMORY[0x1E0C80A78](v13);
  v59 = (char *)&v54 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  v16 = MEMORY[0x1E0C80A78](v14);
  v58 = (char *)&v54 - v17;
  v18 = *(_QWORD **)(AssociatedTypeWitness - 8);
  v19 = MEMORY[0x1E0C80A78](v16);
  v66 = (char *)&v54 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
  v21 = MEMORY[0x1E0C80A78](v19);
  v68 = (char *)&v54 - v22;
  v23 = MEMORY[0x1E0C80A78](v21);
  v69 = (char *)&v54 - v24;
  v25 = MEMORY[0x1E0C80A78](v23);
  v67 = (char *)&v54 - v26;
  v27 = MEMORY[0x1E0C80A78](v25);
  v29 = (char *)&v54 - v28;
  MEMORY[0x1E0C80A78](v27);
  v31 = (char *)&v54 - v30;
  v33 = type metadata accessor for PartialRangeFrom(0, AssociatedTypeWitness, AssociatedConformanceWitness, v32);
  v56 = *(_QWORD *)(v33 - 8);
  v57 = v33;
  MEMORY[0x1E0C80A78](v33);
  v35 = (char *)&v54 - v34;
  v36 = *(void (**)(uint64_t, uint64_t))(v6 + 64);
  v70 = a2;
  v71 = v3;
  v36(a2, v6);
  v37 = (void (*)(char *, char *, unint64_t))v18[2];
  v37(v29, v31, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t))(*(_QWORD *)(AssociatedConformanceWitness + 8) + 8))(v29, v29, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range cannot have an unordered lower bound.", 43, 2, "Swift/Range.swift", 17, 2, 0x34FuLL, 0);
  v55 = a3;
  v38 = (void (*)(char *, unint64_t))v18[1];
  v38(v29, AssociatedTypeWitness);
  v39 = (void (*)(char *, char *, unint64_t))v18[4];
  v39(v35, v31, AssociatedTypeWitness);
  v40 = v67;
  v37(v67, v35, AssociatedTypeWitness);
  v41 = v69;
  (*(void (**)(uint64_t, uint64_t))(v6 + 72))(v70, v6);
  v42 = v68;
  v37(v68, v40, AssociatedTypeWitness);
  v43 = v66;
  v37(v66, v41, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, unint64_t, unint64_t))(AssociatedConformanceWitness + 24))(v42, v43, AssociatedTypeWitness, AssociatedConformanceWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  v38(v43, AssociatedTypeWitness);
  v38(v68, AssociatedTypeWitness);
  (*(void (**)(char *, uint64_t))(v56 + 8))(v35, v57);
  v44 = TupleTypeMetadata2;
  v45 = v60;
  v46 = &v60[*((int *)TupleTypeMetadata2 + 12)];
  v39(v60, v67, AssociatedTypeWitness);
  v39(v46, v69, AssociatedTypeWitness);
  v47 = v64;
  v48 = &v64[*((int *)v44 + 12)];
  v37(v64, v45, AssociatedTypeWitness);
  v37(v48, v46, AssociatedTypeWitness);
  v49 = v59;
  v39(v59, v47, AssociatedTypeWitness);
  v38(v48, AssociatedTypeWitness);
  v50 = &v47[*((int *)v44 + 12)];
  v39(v47, v45, AssociatedTypeWitness);
  v39(v50, v46, AssociatedTypeWitness);
  v51 = v62;
  v39(&v49[*(int *)(v62 + 36)], v50, AssociatedTypeWitness);
  v38(v47, AssociatedTypeWitness);
  v52 = v58;
  (*(void (**)(char *, char *, uint64_t))(v61 + 32))(v58, v49, v51);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v55 + 40))(v65, v52, v70);
}

uint64_t type metadata accessor for Repeated(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Repeated, flag for loading of canonical specialized generic type metadata for Repeated);
}

uint64_t partial apply for closure #1 in RangeSet.Ranges.init(_unorderedRanges:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)(v0 + 24) + 16))() & 1;
}

uint64_t partial apply for closure #1 in RangeSet.Ranges._contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = v4[2];
  v7 = v4[3];
  v8 = v4[4];
  v9 = type metadata accessor for Range(0, v6, v7, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 40))(a1 + *(int *)(v9 + 36), v8, v6, v7) & 1;
}

uint64_t type metadata accessor for _Pair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _Pair);
}

uint64_t partial apply for closure #1 in RangeSet.isSubset(of:)(uint64_t a1)
{
  uint64_t *v1;

  return closure #1 in RangeSet.isSubset(of:)(a1, v1[4], v1[2], v1[3]) & 1;
}

uint64_t type metadata accessor for Zip2Sequence(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Zip2Sequence);
}

uint64_t type metadata accessor for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Zip2Sequence.Iterator);
}

void partial apply for closure #1 in MutableCollection<>.sort(by:)(uint64_t a1)
{
  uint64_t v1;

  closure #1 in MutableCollection<>.sort(by:)(a1, *(uint64_t (**)(char *, char *))(v1 + 40), *(_QWORD *)(v1 + 48), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

uint64_t type metadata accessor for Result(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Result);
}

uint64_t type metadata accessor for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ReversedCollection.Iterator);
}

uint64_t type metadata accessor for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ReversedCollection.Index);
}

uint64_t type metadata accessor for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for PrefixSequence.Iterator);
}

uint64_t type metadata accessor for DropWhileSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for DropWhileSequence.Iterator);
}

unint64_t specialized RangeReplaceableCollection.init(repeating:count:)(int a1, uint64_t a2)
{
  __objc2_class **v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  if (!a2)
    return 0;
  if (a2 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  v2 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s8RepeatedVys7UnicodeO6ScalarVG_Tg506_sSS17gh42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n(a2, a1);
  v3 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v2, 1);
  v5 = v4;
  swift_bridgeObjectRelease((uint64_t)v2);
  if (!v5)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/String.swift", 18, 2, 0x1C9uLL, 0);
  v6 = specialized static String.+ infix(_:_:)(0, 0xE000000000000000, v3, v5);
  swift_bridgeObjectRelease(v5);
  return v6;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  Swift::String::Index v3;
  Swift::String::Index v4;

  if (!a2)
    return 15;
  v2 = a2;
  if (a2 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  do
  {
    v3._rawBits = 7;
    v4._rawBits = 7;
    specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v3, v4);
    --v2;
  }
  while (v2);
  return 15;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(unint64_t a1, unint64_t a2, uint64_t a3, char *a4)
{
  if (a3)
  {
    if (a3 < 0)
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
    specialized String.append<A>(contentsOf:)(a3, a1, a2, a4);
    swift_bridgeObjectRelease(a2);
  }
  else
  {
    swift_bridgeObjectRelease(a2);
  }
  return 15;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(char a1, uint64_t a2)
{
  uint64_t result;
  int v4;

  if (!a2)
    return 0;
  if (a2 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  LODWORD(result) = 0;
  v4 = (a1 + 1);
  do
  {
    if (BYTE3(result))
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
    result = (v4 << (-(__clz(result) & 0x18) & 0x18)) | result;
    --a2;
  }
  while (a2);
  return result;
}

__objc2_class **specialized Set.init(_nonEmptyArrayLiteral:)(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  Swift::Int v18;
  uint64_t v19;
  Swift::Int v20;
  uint64_t v21;
  uint64_t v22;
  __objc2_class **v23;
  unint64_t v24;
  BOOL v25;
  char v26;
  unint64_t v27;
  void (*v28)(char *, char *, uint64_t *);
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t (*v36)(char *, char *, uint64_t *, uint64_t);
  uint64_t v37;
  uint64_t v38;
  char *v39;
  void (*v40)(char *, uint64_t *);
  uint64_t v41;
  char *v42;
  void (*v43)(char *, char *, uint64_t *);
  __objc2_class *v44;
  __objc2_class *v45;
  id v46;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  Swift::Int v55;
  unint64_t v56;
  void (*v57)(char *, char *, uint64_t *);
  char *v58;
  void (*v59)(char *, unint64_t, uint64_t *);
  __objc2_class **v60;
  __objc2_class **v61;
  char *v62;
  id v63;

  v6 = a1;
  v7 = *(a2 - 1);
  v8 = MEMORY[0x1E0C80A78](a1);
  v58 = (char *)&v48 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = MEMORY[0x1E0C80A78](v8);
  v62 = (char *)&v48 - v11;
  v12 = MEMORY[0x1E0C80A78](v10);
  v14 = (char *)&v48 - v13;
  v49 = v15;
  MEMORY[0x1E0C80A78](v12);
  v17 = (char *)&v48 - v16;
  v18 = Array._getCount()();
  if (v18)
  {
    v20 = v18;
    v21 = type metadata accessor for _SetStorage(0, (uint64_t)a2, a3, v19);
    v22 = v20;
    v3 = v21;
    v23 = (__objc2_class **)static _SetStorage.allocate(capacity:)(v22);
  }
  else
  {
    v23 = &_swiftEmptySetSingleton;
  }
  v55 = Array._getCount()();
  if (v55)
  {
    v24 = 0;
    v53 = a3;
    v54 = v6 & 0xC000000000000001;
    v60 = v23;
    v61 = v23 + 7;
    v50 = v14;
    v51 = v6;
    v52 = v17;
    while (1)
    {
      v25 = v54 == 0;
      v26 = v25 | ~_swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v24, v26 & 1);
      if ((v26 & 1) != 0)
      {
        v27 = v6
            + ((*(unsigned __int8 *)(v7 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80))
            + *(_QWORD *)(v7 + 72) * v24;
        v59 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
        v59(v14, v27, a2);
      }
      else
      {
        v46 = _ArrayBuffer._getElementSlowPath(_:)(v24, v6, a2);
        v3 = (uint64_t)v46;
        if (v49 != 8)
          goto LABEL_24;
        v63 = v46;
        v59 = *(void (**)(char *, unint64_t, uint64_t *))(v7 + 16);
        v59(v14, (unint64_t)&v63, a2);
        swift_unknownObjectRelease((id)v3);
      }
      v28 = *(void (**)(char *, char *, uint64_t *))(v7 + 32);
      v28(v17, v14, a2);
      v29 = __OFADD__(v24++, 1);
      if (v29)
        break;
      v57 = v28;
      v28(v62, v17, a2);
      v30 = (*(uint64_t (**)(__objc2_class *, uint64_t *, uint64_t))(a3 + 32))(v23[5], a2, a3);
      v31 = -1 << *((_BYTE *)v23 + 32);
      v32 = v30 & ~v31;
      v3 = v32 >> 6;
      v33 = 1 << v32;
      if (((1 << v32) & (unint64_t)v61[v32 >> 6]) != 0)
      {
        v56 = v24;
        v34 = ~v31;
        v35 = *(_QWORD *)(a3 + 8);
        v36 = *(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v35 + 8);
        v37 = v7;
        v38 = *(_QWORD *)(v7 + 72);
        while (1)
        {
          v39 = v58;
          v59(v58, (unint64_t)v60[6] + v38 * v32, a2);
          v3 = v36(v39, v62, a2, v35);
          v40 = *(void (**)(char *, uint64_t *))(v37 + 8);
          v40(v39, a2);
          if ((v3 & 1) != 0)
            break;
          v32 = (v32 + 1) & v34;
          v3 = v32 >> 6;
          v33 = 1 << v32;
          if (((unint64_t)v61[v32 >> 6] & (1 << v32)) == 0)
          {
            v7 = v37;
            v14 = v50;
            v41 = v51;
            v24 = v56;
            goto LABEL_17;
          }
        }
        v40(v62, a2);
        a3 = v53;
        v7 = v37;
        v14 = v50;
        v6 = v51;
        v23 = v60;
        v24 = v56;
      }
      else
      {
        v41 = v6;
LABEL_17:
        v43 = v57;
        v42 = v58;
        v57(v58, v62, a2);
        v61[v3] = (__objc2_class *)((unint64_t)v61[v3] | v33);
        v23 = v60;
        v43((char *)v60[6] + *(_QWORD *)(v7 + 72) * v32, v42, a2);
        v44 = v23[2];
        v29 = __OFADD__(v44, 1);
        v45 = (__objc2_class *)((char *)&v44->isa + 1);
        if (v29)
          goto LABEL_23;
        v23[2] = v45;
        v6 = v41;
        a3 = v53;
      }
      v17 = v52;
      if (v24 == v55)
        return v23;
    }
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    swift_unknownObjectRelease((id)v3);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  }
  return v23;
}

uint64_t type metadata accessor for _SetAnyHashableBox(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SetAnyHashableBox, &flag for loading of canonical specialized generic type metadata for _SetAnyHashableBox);
}

uint64_t type metadata accessor for Set(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Set, &flag for loading of canonical specialized generic type metadata for Set);
}

uint64_t type metadata accessor for Set.Iterator._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Set.Iterator._Variant);
}

void sub_1815A9BF0()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t type metadata accessor for Set.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Set.Index);
}

uint64_t outlined init with take of AnyHashable?(uint64_t a1, uint64_t a2)
{
  return initializeWithTake for ClosedRange<>.Index(a2, a1, &unk_1E0EACBD0);
}

uint64_t type metadata accessor for _SwiftDeferredNSSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SwiftDeferredNSSet);
}

uint64_t partial apply for implicit closure #1 in Sequence<>.sorted()(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, unint64_t, uint64_t);
  unint64_t AssociatedTypeWitness;

  v5 = *(_QWORD *)(v2 + 32);
  v6 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(v5 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(v2 + 24), *(_QWORD *)(v2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

uint64_t partial apply for implicit closure #1 in MutableCollection<>.sort()(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, unint64_t, uint64_t);
  unint64_t AssociatedTypeWitness;

  v5 = v2[5];
  v6 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(v5 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(*(_QWORD *)(v2[3] + 8) + 8), v2[2], (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

uint64_t type metadata accessor for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideTo);
}

uint64_t type metadata accessor for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideThroughIterator);
}

uint64_t type metadata accessor for StrideThrough(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for StrideThrough);
}

uint64_t partial apply for closure #1 in String.init<A, B>(decoding:as:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3;

  return closure #1 in String.init<A, B>(decoding:as:)(a1, a2, *(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 32), a3);
}

uint64_t type metadata accessor for Unicode.ParseResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Unicode.ParseResult);
}

unint64_t partial apply for closure #1 in String.init<A, B>(validating:as:)@<X0>(uint8x16_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  uint64_t v3;
  unint64_t result;
  unint64_t v6;

  result = static String._validate<A>(_:as:)(a1, a2, *(ValueMetadata **)(v3 + 16), *(_QWORD *)(v3 + 16), *(const char **)(v3 + 32));
  *a3 = result;
  a3[1] = v6;
  return result;
}

{
  uint64_t v3;

  return closure #1 in String.init<A, B>(validating:as:)(a1, a2, *(ValueMetadata **)(v3 + 16), *(const char **)(v3 + 32), a3);
}

uint64_t type metadata accessor for UnsafeBufferPointer.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for UnsafeBufferPointer.Iterator);
}

void partial apply for closure #1 in String._slowWithCString<A, B>(encodedAs:_:)(unsigned __int8 *a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;

  closure #1 in String._slowWithCString<A, B>(encodedAs:_:)(a1, a2, *(uint64_t (**)())(v3 + 40), *(_QWORD *)(v3 + 48), *(void (**)(unint64_t))(v3 + 64), *(_QWORD *)(v3 + 72), *(char **)(v3 + 16), *(_QWORD *)(v3 + 24), a3, *(_QWORD *)(v3 + 32));
}

uint64_t specialized _SwiftSetNSEnumerator.countByEnumerating(with:objects:count:)(uint64_t a1, char **a2)
{
  Swift::_HashTable::Bucket *v2;
  unint64_t v5;
  char **v6;
  Swift::UInt *v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t offset;
  uint64_t result;
  char *v13;
  Swift::_HashTable::Bucket v14;
  uint64_t v15;
  char **v16;
  Swift::UInt *v17;
  __int128 v18;
  __int128 v19;

  v5 = *(_QWORD *)a1;
  v6 = *(char ***)(a1 + 8);
  v7 = *(Swift::UInt **)(a1 + 16);
  v8 = *(_OWORD *)(a1 + 24);
  v9 = *(_OWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 56);
  offset = v2[4].offset;
  if (offset == v2[5].offset)
  {
    result = 0;
  }
  else
  {
    v18 = v9;
    v19 = v8;
    v13 = _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
    *a2 = v13;
    swift_unknownObjectRelease(v13);
    v14.offset = _HashTable.occupiedBucket(after:)(v2[4]).offset;
    v9 = v18;
    v8 = v19;
    v2[4].offset = v14.offset;
    result = 1;
  }
  if (v5 <= 1)
    v15 = 1;
  else
    v15 = v5;
  if (v5)
    v16 = v6;
  else
    v16 = a2;
  *(_QWORD *)a1 = v15;
  *(_QWORD *)(a1 + 8) = v16;
  v17 = &_fastEnumerationStorageMutationsTarget;
  if (v5)
    v17 = v7;
  *(_QWORD *)(a1 + 16) = v17;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 40) = v9;
  *(_QWORD *)(a1 + 56) = v10;
  return result;
}

void specialized _SwiftSetNSEnumerator.init(coder:)()
{
  closure #1 in _unimplementedInitializer(className:initName:file:line:column:)("Swift._SwiftSetNSEnumerator", 27, "init(coder:)", 12, 2, "Swift/SetBridging.swift", 23, 2, 0x37uLL, 0x16uLL);
  __break(1u);
}

void specialized _SwiftDeferredNSSet.init(objects:count:)()
{
  uint64_t v0;

  *(_QWORD *)(v0 + 16) = 0;
  swift_release(v0);
  __break(1u);
}

void specialized _SetStorage.init(objects:count:)()
{
  uint64_t v0;

  swift_release(v0);
  __break(1u);
}

uint64_t specialized _SetStorage.copy(with:)()
{
  uint64_t v0;

  return v0;
}

uint64_t specialized Substring.init<A>(_:)(uint64_t result, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;

  if (&full type metadata for [Character] == &full type metadata for String)
  {
    __break(1u);
  }
  else if (&full type metadata for [Character] != &full type metadata for Substring)
  {
    v4 = result;
    specialized String.append<A>(contentsOf:)(result, a2, a3, a4);
    swift_bridgeObjectRelease(v4);
    return 15;
  }
  __break(1u);
  return result;
}

unint64_t specialized _SmallString.init(taggedCocoa:)(void *a1, uint64_t a2)
{
  uint64_t v3;
  char v4;
  char v5;
  char v6;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = xmmword_1816ABD30;
  v3 = _NSStringCopyBytes(_:encoding:into:)(a1, a2, (uint64_t)&v8, (unint64_t)&v8 | 0xF);
  v5 = v4;
  swift_unknownObjectRelease(a1);
  if ((v5 & 1) != 0)
    return 0;
  if (v3 < 1)
  {
    if (v3)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SmallString.swift", 23, 2, 0x109uLL, 0);
    return 0;
  }
  else
  {
    v6 = 8;
    if (v3 < 8)
      v6 = v3;
    return v8 & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v6) & 0x38));
  }
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, uint64_t (*a2)(int64_t, int64_t))
{
  uint64_t v2;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(_QWORD *)(v5 + 16) = v6;
  *(_QWORD *)(v5 + 24) = 0x3000000000000000;
  if (v6 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v7 = *(_QWORD *)(v5 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(v5 + 32 + v7) = 0;
  if (a1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  v8 = a2(v5 + 32, a1);
  if (v2)
  {
    swift_release(v5);
  }
  else
  {
    *(_QWORD *)(v5 + 24) = v8 | 0x3000000000000000;
    *(_BYTE *)(v5 + 32 + (v8 & 0xFFFFFFFFFFFFLL)) = 0;
  }
  return v5;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, uint64_t (*a2)(int64_t, int64_t))
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  Swift::Int v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  Swift::Int v59;
  uint64_t v60;
  char v61;
  char *v62;
  uint64_t v63;
  unsigned __int8 *v64;
  unsigned __int8 *i;
  unsigned int v66;
  unsigned int v67;
  unsigned __int8 *v68;
  unsigned int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  size_t v77;
  uint64_t v78;

  v4 = (_QWORD *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2);
  if (v3)
    return v2;
  v5 = v4;
  v6 = v4[3];
  v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0)
    goto LABEL_20;
  v8 = (char *)(v4 + 4);
  v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080) != 0)
      goto LABEL_22;
    v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0) + 32)
    {
      v10 = *(_QWORD *)v9;
      v11 = *((_QWORD *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080) != 0)
        goto LABEL_22;
    }
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8])
  {
    if ((*(_QWORD *)v9 & 0x8080808080808080) != 0)
      goto LABEL_22;
    v9 += 8;
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0)
      goto LABEL_22;
    v9 += 4;
  }
  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }
LABEL_22:
  v13 = 0;
  v14 = &v8[v7];
  v12 = 1;
  v15 = (unsigned __int8 *)(v4 + 4);
  v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    v18 = (char)*v16++;
    v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      v19 = 1;
      goto LABEL_25;
    }
    if ((v17 + 11) < 0xCDu)
      goto LABEL_68;
    if (v17 <= 0xDFu)
    {
      if (v16 == (unsigned __int8 *)v14 || (*v16 & 0xC0) != 0x80)
        goto LABEL_68;
      v12 = 0;
      v16 = v15 + 2;
      v19 = 2;
      goto LABEL_25;
    }
    if (v17 == 224)
      break;
    if (v17 <= 0xECu)
      goto LABEL_50;
    if (v17 == 237)
    {
      if (v16 == (unsigned __int8 *)v14)
        goto LABEL_68;
      v22 = v15[1];
      if (v22 > 0x9F)
        goto LABEL_68;
LABEL_52:
      if ((v22 & 0xC0) != 0x80)
        goto LABEL_68;
      v20 = (char *)(v15 + 2);
      if (v15 + 2 == (unsigned __int8 *)v14)
        goto LABEL_68;
LABEL_54:
      if ((*v20 & 0xC0) != 0x80)
        goto LABEL_68;
      v12 = 0;
      v16 = v15 + 3;
      v19 = 3;
      goto LABEL_25;
    }
    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v16 == (unsigned __int8 *)v14)
        goto LABEL_68;
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }
    if (v17 == 240)
    {
      if (v16 == (unsigned __int8 *)v14 || (v15[1] + 64) < 0xD0u)
        goto LABEL_68;
    }
    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        if (v16 == (unsigned __int8 *)v14)
          goto LABEL_68;
        LOBYTE(v23) = v15[1];
      }
      else
      {
        if (v16 == (unsigned __int8 *)v14)
          goto LABEL_68;
        v23 = v15[1];
        if (v23 > 0x8F)
          goto LABEL_68;
      }
      if ((v23 & 0xC0) != 0x80)
        goto LABEL_68;
    }
    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    v12 = 0;
    v16 = v15 + 4;
    v19 = 4;
LABEL_25:
    v13 += v19;
    v15 = v16;
    if (v16 == (unsigned __int8 *)v14)
      goto LABEL_21;
  }
  if (v16 != (unsigned __int8 *)v14)
  {
    v20 = (char *)(v15 + 2);
    if ((v15[1] + 64) >= 0xE0u && v20 != v14)
      goto LABEL_54;
  }
LABEL_68:
  v24 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  v29 = v25;
  v30 = v26;
  v31 = v27;
  v32 = v28;
  v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    v33 = v29 + 1;
    if (__OFADD__(v29, 1))
    {
      v73 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v73, 0);
    }
  }
  v34 = 0;
  v35 = v30 + v29 - v33;
  if (v30 <= v33)
    v36 = v33;
  else
    v36 = v30;
  if (v32 <= v33)
    v37 = v33;
  else
    v37 = v32;
  v38 = v37 - v33;
  v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34)
      goto LABEL_87;
    if (v33 < v29)
    {
      v73 = 1812;
      goto LABEL_168;
    }
    if (v39 == v34)
    {
      v73 = 1813;
      goto LABEL_168;
    }
    if (v33 < 0)
    {
      v73 = 1781;
      goto LABEL_168;
    }
    if (v38 == v34)
    {
      v73 = 1782;
      goto LABEL_168;
    }
    if ((*(_BYTE *)(v31 + v33 + v34) & 0xC0) != 0x80)
      goto LABEL_86;
    v40 = v29 + v34++;
  }
  while (!__OFADD__(v40, 1));
  __break(1u);
LABEL_86:
  v35 = v29 + v34;
LABEL_87:
  if (v35 < v29)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  v41 = v35 + 1;
  if (__OFADD__(v35, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v30 < v41)
  {
LABEL_176:
    v73 = 1820;
    goto LABEL_168;
  }
  v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  v44 = v43;
  v74 = (uint64_t)v5;
  v75 = 0;
  v45 = v5[3];
  v76 = 0xE000000000000000;
  v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15)
      _StringGuts.grow(_:)(v46 + 15);
  }
  while (2)
  {
    if (v42 < 0)
      goto LABEL_169;
    v55 = v46;
    if (v46 < v42)
    {
      v73 = 1861;
      goto LABEL_168;
    }
    v56 = v76;
    v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000) != 0)
      v57 = HIBYTE(v76) & 0xF;
    v58 = v57 + v55;
    v59 = v58 + 3;
    if (__OFADD__(v58, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v59 >= 16)
    {
      v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        v56 = v76;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    v75 = *(_QWORD *)(v56 + 24);
    v77 = 3;
    v78 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44)
LABEL_169:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v44 < 0)
    {
LABEL_172:
      v73 = 1860;
      goto LABEL_168;
    }
    v46 = v55 - v44;
    if (v55 - v44 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }
    v63 = 0;
    v64 = (unsigned __int8 *)&v8[v55];
    if (!v8)
      v64 = 0;
    for (i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64)
          goto LABEL_161;
        v67 = *i++;
        v66 = v67;
        if ((v66 & 0x80) != 0)
          break;
        ++v63;
      }
      if ((v66 + 62) >= 0x33u)
        goto LABEL_95;
      if (v66 > 0xDF)
        break;
      if (!i || i == v64 || (*i & 0xC0) != 0x80)
        goto LABEL_95;
      v63 += 2;
    }
    if (v66 == 224)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v68 = i + 1;
      if ((*i & 0xE0) != 0xA0)
        goto LABEL_95;
      goto LABEL_140;
    }
    if (v66 <= 0xEC)
      goto LABEL_136;
    if (v66 == 237)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v68 = i + 1;
      v69 = *i;
      if (v69 > 0x9F)
        goto LABEL_95;
      goto LABEL_139;
    }
    if (v66 <= 0xEF)
    {
LABEL_136:
      if (!i || i == v64)
        goto LABEL_95;
      v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80)
        goto LABEL_95;
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80)
        goto LABEL_95;
      i += 2;
      v63 += 3;
      goto LABEL_113;
    }
    if (v66 == 240)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v70 = i + 1;
      if ((*i + 64) < 0xD0u)
        goto LABEL_95;
      goto LABEL_156;
    }
    if ((v66 + 15) <= 2u)
    {
      if (!i || i == v64)
        goto LABEL_95;
      v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v64)
      {
        v70 = i + 1;
        v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80)
            goto LABEL_95;
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80)
            goto LABEL_95;
          i += 3;
          v63 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    v49 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    v44 = v54;
    v8 = v62;
    if (v46)
      continue;
    break;
  }
  v2 = v75;
  swift_release(v74);
  return v2;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(unint64_t a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  int8x16_t v17;
  uint64x2_t v18;
  int8x16_t v19;
  unint64_t v20;
  int8x16_t *v21;
  int8x16_t *v22;
  int8x16_t v23;
  uint8x16_t v24;
  uint16x8_t v25;
  uint32x4_t v26;
  int64x2_t v27;
  int64x2_t v28;
  uint32x4_t v29;
  uint16x8_t v30;
  int64x2_t v31;
  uint32x4_t v32;
  int64x2_t v33;
  int8x16_t v34;
  unint64_t v35;
  unsigned __int8 *v36;
  _BYTE *v37;
  uint64_t v38;
  int v39;
  int8x16x4_t v41;
  int8x16x4_t v42;

  v9 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(_QWORD *)(v9 + 16) = v10;
  *(_QWORD *)(v9 + 24) = 0x3000000000000000;
  if (v10 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v11 = *(_QWORD *)(v9 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v9 + 32 + v11) = 0;
  if ((a1 & 0x8000000000000000) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  if (a3 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (a3)
  {
    v12 = a3 - 1;
    if (a3 - 1 >= a1)
      v12 = a1;
    v13 = v12 + 1;
    if (v13 > 0x10 && (unint64_t)(v9 - (_QWORD)a2 + 32) >= 0x10)
    {
      v15 = v13 & 0xF;
      if ((v13 & 0xF) == 0)
        v15 = 16;
      v14 = v13 - v15;
      v16.i64[0] = -1;
      v16.i64[1] = -1;
      v17.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
      v17.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
      v18 = (uint64x2_t)vdupq_n_s64(0x3FFE000000000uLL);
      v19.i64[0] = 0x2020202020202020;
      v19.i64[1] = 0x2020202020202020;
      v20 = v14;
      v21 = (int8x16_t *)(v9 + 32);
      v22 = a2;
      do
      {
        v23 = *v22++;
        v24 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v23, v16), 1uLL), v17);
        v25 = vmovl_u8(*(uint8x8_t *)v24.i8);
        v26 = vmovl_u16(*(uint16x4_t *)v25.i8);
        v27.i64[0] = v26.u32[0];
        v27.i64[1] = v26.u32[1];
        v28 = v27;
        v29 = vmovl_high_u16(v25);
        v30 = vmovl_high_u8(v24);
        v27.i64[0] = v29.u32[0];
        v27.i64[1] = v29.u32[1];
        v31 = v27;
        v32 = vmovl_u16(*(uint16x4_t *)v30.i8);
        v27.i64[0] = v32.u32[0];
        v27.i64[1] = v32.u32[1];
        v33 = v27;
        v34 = (int8x16_t)vmovl_high_u16(v30);
        v27.i64[0] = v34.u32[0];
        v27.i64[1] = v34.u32[1];
        v41.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, (uint32x4_t)v34));
        v41.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v32));
        v41.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v27));
        v41.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v33));
        v42.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v29));
        v42.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v26));
        v42.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v31));
        v42.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v28));
        v34.i64[0] = vqtbl4q_s8(v42, (int8x16_t)xmmword_1816ABD40).u64[0];
        v34.i64[1] = vqtbl4q_s8(v41, (int8x16_t)xmmword_1816ABD40).u64[0];
        *v21++ = vaddq_s8(vandq_s8(v34, v19), v23);
        v20 -= 16;
      }
      while (v20);
    }
    else
    {
      v14 = 0;
    }
    v35 = a1 - v14;
    v36 = &a2->u8[v14];
    v37 = (_BYTE *)(v14 + v9 + 32);
    v38 = a3 - v14;
    do
    {
      if (!v35)
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
      v39 = *v36++;
      *v37++ = ((0x3FFE000000000uLL >> ((v39 - 1) >> 1)) & 0x20) + v39;
      --v35;
      --v38;
    }
    while (v38);
  }
  *(_QWORD *)(v9 + 24) = a3 | 0x3000000000000000;
  *(_BYTE *)(v9 + 32 + (a3 & 0xFFFFFFFFFFFFLL)) = 0;
  return v9;
}

{
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  int8x16_t v17;
  uint64x2_t v18;
  int8x16_t v19;
  unint64_t v20;
  int8x16_t *v21;
  int8x16_t *v22;
  int8x16_t v23;
  uint8x16_t v24;
  uint16x8_t v25;
  uint32x4_t v26;
  int64x2_t v27;
  int64x2_t v28;
  uint32x4_t v29;
  uint16x8_t v30;
  int64x2_t v31;
  uint32x4_t v32;
  int64x2_t v33;
  int8x16_t v34;
  unint64_t v35;
  unsigned __int8 *v36;
  _BYTE *v37;
  uint64_t v38;
  int v39;
  int8x16x4_t v41;
  int8x16x4_t v42;

  v9 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(_QWORD *)(v9 + 16) = v10;
  *(_QWORD *)(v9 + 24) = 0x3000000000000000;
  if (v10 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v11 = *(_QWORD *)(v9 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v11 = 0;
  }
  *(_BYTE *)(v9 + 32 + v11) = 0;
  if ((a1 & 0x8000000000000000) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  if (a3 < 0)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  if (a3)
  {
    v12 = a3 - 1;
    if (a3 - 1 >= a1)
      v12 = a1;
    v13 = v12 + 1;
    if (v13 > 0x10 && (unint64_t)(v9 - (_QWORD)a2 + 32) >= 0x10)
    {
      v15 = v13 & 0xF;
      if ((v13 & 0xF) == 0)
        v15 = 16;
      v14 = v13 - v15;
      v16.i64[0] = -1;
      v16.i64[1] = -1;
      v17.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
      v17.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
      v18 = (uint64x2_t)vdupq_n_s64(0x1FFF000000000000uLL);
      v19.i64[0] = 0x2020202020202020;
      v19.i64[1] = 0x2020202020202020;
      v20 = v14;
      v21 = (int8x16_t *)(v9 + 32);
      v22 = a2;
      do
      {
        v23 = *v22++;
        v24 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v23, v16), 1uLL), v17);
        v25 = vmovl_u8(*(uint8x8_t *)v24.i8);
        v26 = vmovl_u16(*(uint16x4_t *)v25.i8);
        v27.i64[0] = v26.u32[0];
        v27.i64[1] = v26.u32[1];
        v28 = v27;
        v29 = vmovl_high_u16(v25);
        v30 = vmovl_high_u8(v24);
        v27.i64[0] = v29.u32[0];
        v27.i64[1] = v29.u32[1];
        v31 = v27;
        v32 = vmovl_u16(*(uint16x4_t *)v30.i8);
        v27.i64[0] = v32.u32[0];
        v27.i64[1] = v32.u32[1];
        v33 = v27;
        v34 = (int8x16_t)vmovl_high_u16(v30);
        v27.i64[0] = v34.u32[0];
        v27.i64[1] = v34.u32[1];
        v41.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, (uint32x4_t)v34));
        v41.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v32));
        v41.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v27));
        v41.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v33));
        v42.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v29));
        v42.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v26));
        v42.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v31));
        v42.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v28));
        v34.i64[0] = vqtbl4q_s8(v42, (int8x16_t)xmmword_1816ABD40).u64[0];
        v34.i64[1] = vqtbl4q_s8(v41, (int8x16_t)xmmword_1816ABD40).u64[0];
        *v21++ = vsubq_s8(v23, vandq_s8(vshlq_n_s8(v34, 5uLL), v19));
        v20 -= 16;
      }
      while (v20);
    }
    else
    {
      v14 = 0;
    }
    v35 = a1 - v14;
    v36 = &a2->u8[v14];
    v37 = (_BYTE *)(v14 + v9 + 32);
    v38 = a3 - v14;
    do
    {
      if (!v35)
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
      v39 = *v36++;
      *v37++ = v39 - 32 * ((0x1FFF000000000000uLL >> ((v39 - 1) >> 1)) & 1);
      --v35;
      --v38;
    }
    while (v38);
  }
  *(_QWORD *)(v9 + 24) = a3 | 0x3000000000000000;
  *(_BYTE *)(v9 + 32 + (a3 & 0xFFFFFFFFFFFFLL)) = 0;
  return v9;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void))
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  Swift::Int v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  char *v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 v22;
  int v23;
  uint64_t v24;
  char *v25;
  unsigned int v27;
  unsigned int v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  Swift::Int v64;
  uint64_t v65;
  char v66;
  char *v67;
  uint64_t v68;
  unsigned __int8 *v69;
  unsigned __int8 *i;
  unsigned int v71;
  unsigned int v72;
  unsigned __int8 *v73;
  unsigned int v74;
  unsigned __int8 *v75;
  unsigned int v76;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  size_t v83;
  uint64_t v84;

  v9 = (_QWORD *)a6();
  if (v7)
    return v6;
  v10 = v9;
  v11 = v9[3];
  v12 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v11 & 0xFFFFFFFFFFFFLL) == 0)
    goto LABEL_20;
  v13 = (char *)(v9 + 4);
  v14 = (char *)(v9 + 4);
  if ((v11 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v9[5] | v9[4]) & 0x8080808080808080) != 0)
      goto LABEL_22;
    v14 = (char *)(v9 + 6);
    while (v14 < (char *)v9 + (v11 & 0xFFFFFFFFFFF0) + 32)
    {
      v15 = *(_QWORD *)v14;
      v16 = *((_QWORD *)v14 + 1);
      v14 += 16;
      if (((v16 | v15) & 0x8080808080808080) != 0)
        goto LABEL_22;
    }
  }
  if (v14 < &v13[v11 & 0xFFFFFFFFFFF8])
  {
    if ((*(_QWORD *)v14 & 0x8080808080808080) != 0)
      goto LABEL_22;
    v14 += 8;
  }
  if (v14 < &v13[v11 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v14 & 0x80808080) != 0)
      goto LABEL_22;
    v14 += 4;
  }
  if (v14 >= &v13[v11 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v14 >= &v13[v12] || (*v14 & 0x80000000) == 0)
    {
LABEL_20:
      v17 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v12, v17 & 1);
      return v10[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v14 & 0x8080) == 0)
  {
    v14 += 2;
    goto LABEL_18;
  }
LABEL_22:
  v18 = 0;
  v19 = &v13[v12];
  v17 = 1;
  v20 = (unsigned __int8 *)(v9 + 4);
  v21 = (unsigned __int8 *)(v9 + 4);
  while (1)
  {
    v23 = (char)*v21++;
    v22 = v23;
    if ((v23 & 0x80000000) == 0)
    {
      v24 = 1;
      goto LABEL_25;
    }
    if ((v22 + 11) <= 0xCCu)
      goto LABEL_68;
    if (v22 < 0xE0u)
    {
      if (v21 == (unsigned __int8 *)v19 || (*v21 & 0xC0) != 0x80)
        goto LABEL_68;
      v17 = 0;
      v21 = v20 + 2;
      v24 = 2;
      goto LABEL_25;
    }
    if (v22 == 224)
      break;
    if (v22 <= 0xECu)
      goto LABEL_50;
    if (v22 == 237)
    {
      if (v21 == (unsigned __int8 *)v19)
        goto LABEL_68;
      v27 = v20[1];
      if (v27 > 0x9F)
        goto LABEL_68;
LABEL_52:
      if ((v27 & 0xC0) != 0x80)
        goto LABEL_68;
      v25 = (char *)(v20 + 2);
      if (v20 + 2 == (unsigned __int8 *)v19)
        goto LABEL_68;
LABEL_54:
      if ((*v25 & 0xC0) != 0x80)
        goto LABEL_68;
      v17 = 0;
      v21 = v20 + 3;
      v24 = 3;
      goto LABEL_25;
    }
    if ((v22 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v21 == (unsigned __int8 *)v19)
        goto LABEL_68;
      LOBYTE(v27) = v20[1];
      goto LABEL_52;
    }
    if (v22 == 240)
    {
      if (v21 == (unsigned __int8 *)v19 || (v20[1] + 64) < 0xD0u)
        goto LABEL_68;
    }
    else
    {
      if ((v22 + 12) >= 0xFDu)
      {
        if (v21 == (unsigned __int8 *)v19)
          goto LABEL_68;
        LOBYTE(v28) = v20[1];
      }
      else
      {
        if (v21 == (unsigned __int8 *)v19)
          goto LABEL_68;
        v28 = v20[1];
        if (v28 > 0x8F)
          goto LABEL_68;
      }
      if ((v28 & 0xC0) != 0x80)
        goto LABEL_68;
    }
    if (v20 + 2 == (unsigned __int8 *)v19
      || (v20[2] & 0xC0) != 0x80
      || v20 + 3 == (unsigned __int8 *)v19
      || (v20[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    v17 = 0;
    v21 = v20 + 4;
    v24 = 4;
LABEL_25:
    v18 += v24;
    v20 = v21;
    if (v21 == (unsigned __int8 *)v19)
      goto LABEL_21;
  }
  if (v21 != (unsigned __int8 *)v19)
  {
    v25 = (char *)(v20 + 2);
    if ((v20[1] + 64) >= 0xE0u && v25 != v19)
      goto LABEL_54;
  }
LABEL_68:
  v29 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v29);
  v30 = specialized Collection.subscript.getter(v18, (uint64_t)(v10 + 4), v12);
  v34 = v30;
  v35 = v31;
  v36 = v32;
  v37 = v33;
  v38 = v30;
  if (v30 != v31)
  {
    specialized Slice.subscript.getter(v30, v30, v31, v32, v33);
    v38 = v34 + 1;
    if (__OFADD__(v34, 1))
    {
      swift_bridgeObjectRelease(a5);
      v78 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v78, 0);
    }
  }
  v39 = 0;
  v40 = v35 + v34 - v38;
  if (v35 <= v38)
    v41 = v38;
  else
    v41 = v35;
  if (v37 <= v38)
    v42 = v38;
  else
    v42 = v37;
  v43 = v42 - v38;
  v44 = v41 - v38;
  do
  {
    if (v35 - v38 == v39)
      goto LABEL_87;
    if (v38 < v34)
    {
      swift_bridgeObjectRelease(a5);
      v78 = 1812;
      goto LABEL_168;
    }
    if (v44 == v39)
    {
      swift_bridgeObjectRelease(a5);
      v78 = 1813;
      goto LABEL_168;
    }
    if (v38 < 0)
    {
      swift_bridgeObjectRelease(a5);
      v78 = 1781;
      goto LABEL_168;
    }
    if (v43 == v39)
    {
      swift_bridgeObjectRelease(a5);
      v78 = 1782;
      goto LABEL_168;
    }
    if ((*(_BYTE *)(v36 + v38 + v39) & 0xC0) != 0x80)
      goto LABEL_86;
    v45 = v34 + v39++;
  }
  while (!__OFADD__(v45, 1));
  __break(1u);
LABEL_86:
  v40 = v34 + v39;
LABEL_87:
  if (v40 < v34)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  v46 = v40 + 1;
  if (__OFADD__(v40, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v35 < v46)
  {
LABEL_176:
    v78 = 1820;
    goto LABEL_168;
  }
  v79 = a5;
  v47 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v34, v46, v36, v37);
  v49 = v48;
  v80 = (uint64_t)v10;
  v81 = 0;
  v50 = v10[3];
  v82 = 0xE000000000000000;
  v51 = v50 & 0xFFFFFFFFFFFFLL;
  if ((v50 & 0xFFFFFFFFFFFFLL) != 0)
  {
    v52 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v53 & 1) != 0 || v52 < v51 + 15)
      _StringGuts.grow(_:)(v51 + 15);
  }
  while (2)
  {
    if (v47 < 0)
      goto LABEL_169;
    v60 = v51;
    if (v51 < v47)
    {
      swift_bridgeObjectRelease(v79);
      v78 = 1861;
      goto LABEL_168;
    }
    v61 = v82;
    v62 = v81 & 0xFFFFFFFFFFFFLL;
    if ((v82 & 0x2000000000000000) != 0)
      v62 = HIBYTE(v82) & 0xF;
    v63 = v62 + v60;
    v64 = v63 + 3;
    if (__OFADD__(v63, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v64 >= 16)
    {
      v65 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v66 & 1) != 0 || v65 < v64)
      {
        _StringGuts.grow(_:)(v64);
        v61 = v82;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v61 & 0xFFFFFFFFFFFFFFFLL, v13, v47, 0);
    v81 = *(_QWORD *)(v61 + 24);
    v83 = 3;
    v84 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v84, &v83, &v81);
    if (v60 < v49)
    {
LABEL_169:
      swift_bridgeObjectRelease(v79);
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    if (v49 < 0)
    {
LABEL_172:
      swift_bridgeObjectRelease(v79);
      v78 = 1860;
      goto LABEL_168;
    }
    v51 = v60 - v49;
    if (v60 - v49 < 0)
    {
      swift_bridgeObjectRelease(v79);
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    v67 = &v13[v49];
    if (_allASCII(_:)((uint64_t *)&v13[v49], v60 - v49))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v13[v49], v60 - v49, 0);
      break;
    }
    v68 = 0;
    v69 = (unsigned __int8 *)&v13[v60];
    if (!v13)
      v69 = 0;
    for (i = (unsigned __int8 *)&v13[v49]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v69)
          goto LABEL_161;
        v72 = *i++;
        v71 = v72;
        if ((v71 & 0x80) != 0)
          break;
        ++v68;
      }
      if ((v71 + 62) > 0x32u)
        goto LABEL_95;
      if (v71 > 0xDF)
        break;
      if (!i || i == v69 || (*i & 0xC0) != 0x80)
        goto LABEL_95;
      v68 += 2;
    }
    if (v71 == 224)
    {
      if (!i)
        goto LABEL_95;
      if (i == v69)
        goto LABEL_95;
      v73 = i + 1;
      if ((*i & 0xE0) != 0xA0)
        goto LABEL_95;
      goto LABEL_140;
    }
    if (v71 < 0xED)
      goto LABEL_136;
    if (v71 == 237)
    {
      if (!i)
        goto LABEL_95;
      if (i == v69)
        goto LABEL_95;
      v73 = i + 1;
      v74 = *i;
      if (v74 > 0x9F)
        goto LABEL_95;
      goto LABEL_139;
    }
    if (v71 < 0xF0)
    {
LABEL_136:
      if (!i || i == v69)
        goto LABEL_95;
      v73 = i + 1;
      LOBYTE(v74) = *i;
LABEL_139:
      if ((v74 & 0xC0) != 0x80)
        goto LABEL_95;
LABEL_140:
      if (v73 == v69 || (*v73 & 0xC0) != 0x80)
        goto LABEL_95;
      i += 2;
      v68 += 3;
      goto LABEL_113;
    }
    if (v71 == 240)
    {
      if (!i)
        goto LABEL_95;
      if (i == v69)
        goto LABEL_95;
      v75 = i + 1;
      if ((*i + 64) < 0xD0u)
        goto LABEL_95;
      goto LABEL_156;
    }
    if ((v71 + 15) < 3u)
    {
      if (!i || i == v69)
        goto LABEL_95;
      v75 = i + 1;
      LOBYTE(v76) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v69)
      {
        v75 = i + 1;
        v76 = *i;
        if (v76 <= 0x8F)
        {
LABEL_155:
          if ((v76 & 0xC0) != 0x80)
            goto LABEL_95;
LABEL_156:
          if (v75 == v69 || (i[1] & 0xC0) != 0x80 || i + 2 == v69 || (i[2] & 0xC0) != 0x80)
            goto LABEL_95;
          i += 3;
          v68 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    v54 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v54);
    v55 = specialized Collection.subscript.getter(v68, (uint64_t)&v13[v49], v60 - v49);
    v47 = findInvalidRange #1 (_:) in validateUTF8(_:)(v55, v56, v57, v58);
    v49 = v59;
    v13 = v67;
    if (v51)
      continue;
    break;
  }
  v6 = v81;
  swift_release(v80);
  return v6;
}

uint64_t type metadata accessor for __StringStorage()
{
  return objc_opt_self();
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, unsigned int a2)
{
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t ScalarName;

  v4 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(_QWORD *)(v4 + 16) = v5;
  *(_QWORD *)(v4 + 24) = 0x3000000000000000;
  if (v5 < 0)
  {
    *(_QWORD *)__StringStorage._breadcrumbsAddress.getter() = 0;
    v6 = *(_QWORD *)(v4 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    v6 = 0;
  }
  *(_BYTE *)(v4 + 32 + v6) = 0;
  if (a1 < 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  ScalarName = _swift_stdlib_getScalarName(a2, v4 + 32, a1);
  *(_QWORD *)(v4 + 24) = ScalarName | 0x3000000000000000;
  *(_BYTE *)(v4 + 32 + (ScalarName & 0xFFFFFFFFFFFFLL)) = 0;
  return v4;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  Swift::Int v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 v17;
  int v18;
  uint64_t v19;
  char *v20;
  unsigned int v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  Swift::Int v59;
  uint64_t v60;
  char v61;
  char *v62;
  uint64_t v63;
  unsigned __int8 *v64;
  unsigned __int8 *i;
  unsigned int v66;
  unsigned int v67;
  unsigned __int8 *v68;
  unsigned int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  size_t v77;
  uint64_t v78;

  v4 = (_QWORD *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2);
  if (v3)
    return v2;
  v5 = v4;
  v6 = v4[3];
  v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0)
    goto LABEL_20;
  v8 = (char *)(v4 + 4);
  v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080) != 0)
      goto LABEL_22;
    v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0) + 32)
    {
      v10 = *(_QWORD *)v9;
      v11 = *((_QWORD *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080) != 0)
        goto LABEL_22;
    }
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8])
  {
    if ((*(_QWORD *)v9 & 0x8080808080808080) != 0)
      goto LABEL_22;
    v9 += 8;
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0)
      goto LABEL_22;
    v9 += 4;
  }
  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }
LABEL_22:
  v13 = 0;
  v14 = &v8[v7];
  v12 = 1;
  v15 = (unsigned __int8 *)(v4 + 4);
  v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    v18 = (char)*v16++;
    v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      v19 = 1;
      goto LABEL_25;
    }
    if ((v17 + 11) <= 0xCCu)
      goto LABEL_68;
    if (v17 < 0xE0u)
    {
      if (v16 == (unsigned __int8 *)v14 || (*v16 & 0xC0) != 0x80)
        goto LABEL_68;
      v12 = 0;
      v16 = v15 + 2;
      v19 = 2;
      goto LABEL_25;
    }
    if (v17 == 224)
      break;
    if (v17 <= 0xECu)
      goto LABEL_50;
    if (v17 == 237)
    {
      if (v16 == (unsigned __int8 *)v14)
        goto LABEL_68;
      v22 = v15[1];
      if (v22 > 0x9F)
        goto LABEL_68;
LABEL_52:
      if ((v22 & 0xC0) != 0x80)
        goto LABEL_68;
      v20 = (char *)(v15 + 2);
      if (v15 + 2 == (unsigned __int8 *)v14)
        goto LABEL_68;
LABEL_54:
      if ((*v20 & 0xC0) != 0x80)
        goto LABEL_68;
      v12 = 0;
      v16 = v15 + 3;
      v19 = 3;
      goto LABEL_25;
    }
    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v16 == (unsigned __int8 *)v14)
        goto LABEL_68;
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }
    if (v17 == 240)
    {
      if (v16 == (unsigned __int8 *)v14 || (v15[1] + 64) < 0xD0u)
        goto LABEL_68;
    }
    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        if (v16 == (unsigned __int8 *)v14)
          goto LABEL_68;
        LOBYTE(v23) = v15[1];
      }
      else
      {
        if (v16 == (unsigned __int8 *)v14)
          goto LABEL_68;
        v23 = v15[1];
        if (v23 > 0x8F)
          goto LABEL_68;
      }
      if ((v23 & 0xC0) != 0x80)
        goto LABEL_68;
    }
    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    v12 = 0;
    v16 = v15 + 4;
    v19 = 4;
LABEL_25:
    v13 += v19;
    v15 = v16;
    if (v16 == (unsigned __int8 *)v14)
      goto LABEL_21;
  }
  if (v16 != (unsigned __int8 *)v14)
  {
    v20 = (char *)(v15 + 2);
    if ((v15[1] + 64) >= 0xE0u && v20 != v14)
      goto LABEL_54;
  }
LABEL_68:
  v24 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  v29 = v25;
  v30 = v26;
  v31 = v27;
  v32 = v28;
  v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    v33 = v29 + 1;
    if (__OFADD__(v29, 1))
    {
      v73 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v73, 0);
    }
  }
  v34 = 0;
  v35 = v30 + v29 - v33;
  if (v30 <= v33)
    v36 = v33;
  else
    v36 = v30;
  if (v32 <= v33)
    v37 = v33;
  else
    v37 = v32;
  v38 = v37 - v33;
  v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34)
      goto LABEL_87;
    if (v33 < v29)
    {
      v73 = 1812;
      goto LABEL_168;
    }
    if (v39 == v34)
    {
      v73 = 1813;
      goto LABEL_168;
    }
    if (v33 < 0)
    {
      v73 = 1781;
      goto LABEL_168;
    }
    if (v38 == v34)
    {
      v73 = 1782;
      goto LABEL_168;
    }
    if ((*(_BYTE *)(v31 + v33 + v34) & 0xC0) != 0x80)
      goto LABEL_86;
    v40 = v29 + v34++;
  }
  while (!__OFADD__(v40, 1));
  __break(1u);
LABEL_86:
  v35 = v29 + v34;
LABEL_87:
  if (v35 < v29)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  v41 = v35 + 1;
  if (__OFADD__(v35, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v30 < v41)
  {
LABEL_176:
    v73 = 1820;
    goto LABEL_168;
  }
  v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  v44 = v43;
  v74 = (uint64_t)v5;
  v75 = 0;
  v45 = v5[3];
  v76 = 0xE000000000000000;
  v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15)
      _StringGuts.grow(_:)(v46 + 15);
  }
  while (2)
  {
    if (v42 < 0)
      goto LABEL_169;
    v55 = v46;
    if (v46 < v42)
    {
      v73 = 1861;
      goto LABEL_168;
    }
    v56 = v76;
    v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000) != 0)
      v57 = HIBYTE(v76) & 0xF;
    v58 = v57 + v55;
    v59 = v58 + 3;
    if (__OFADD__(v58, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v59 >= 16)
    {
      v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        v56 = v76;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    v75 = *(_QWORD *)(v56 + 24);
    v77 = 3;
    v78 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44)
LABEL_169:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v44 < 0)
    {
LABEL_172:
      v73 = 1860;
      goto LABEL_168;
    }
    v46 = v55 - v44;
    if (v55 - v44 < 0)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }
    v63 = 0;
    v64 = (unsigned __int8 *)&v8[v55];
    if (!v8)
      v64 = 0;
    for (i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64)
          goto LABEL_161;
        v67 = *i++;
        v66 = v67;
        if ((v66 & 0x80) != 0)
          break;
        ++v63;
      }
      if ((v66 + 62) > 0x32u)
        goto LABEL_95;
      if (v66 > 0xDF)
        break;
      if (!i || i == v64 || (*i & 0xC0) != 0x80)
        goto LABEL_95;
      v63 += 2;
    }
    if (v66 == 224)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v68 = i + 1;
      if ((*i & 0xE0) != 0xA0)
        goto LABEL_95;
      goto LABEL_140;
    }
    if (v66 < 0xED)
      goto LABEL_136;
    if (v66 == 237)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v68 = i + 1;
      v69 = *i;
      if (v69 > 0x9F)
        goto LABEL_95;
      goto LABEL_139;
    }
    if (v66 < 0xF0)
    {
LABEL_136:
      if (!i || i == v64)
        goto LABEL_95;
      v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80)
        goto LABEL_95;
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80)
        goto LABEL_95;
      i += 2;
      v63 += 3;
      goto LABEL_113;
    }
    if (v66 == 240)
    {
      if (!i)
        goto LABEL_95;
      if (i == v64)
        goto LABEL_95;
      v70 = i + 1;
      if ((*i + 64) < 0xD0u)
        goto LABEL_95;
      goto LABEL_156;
    }
    if ((v66 + 15) < 3u)
    {
      if (!i || i == v64)
        goto LABEL_95;
      v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v64)
      {
        v70 = i + 1;
        v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80)
            goto LABEL_95;
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80)
            goto LABEL_95;
          i += 3;
          v63 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    v49 = swift_allocError((uint64_t)&unk_1E0EAAB90, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    v44 = v54;
    v8 = v62;
    if (v46)
      continue;
    break;
  }
  v2 = v75;
  swift_release(v74);
  return v2;
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = a2 >> 16;
  if ((a6 & 0x2000000000000000) != 0)
    v7 = HIBYTE(a6) & 0xF;
  else
    v7 = a5 & 0xFFFFFFFFFFFFLL;
  v8 = a1 >> 16;
  if (a3 == a5 && a4 == a6 && !v8 && v6 == v7)
    return 1;
  else
    return _stringCompareInternal(_:_:_:_:expecting:)(a3, a4, v8, v6, a5, a6, 0, v7, 0) & 1;
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((a2 & 0x2000000000000000) != 0)
    v7 = HIBYTE(a2) & 0xF;
  else
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  v8 = a4 >> 16;
  v9 = a3 >> 16;
  if (a1 == a5 && a2 == a6 && !v9 && v7 == v8)
    return 1;
  else
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v7, a5, a6, v9, v8, 0) & 1;
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  if ((a2 & 0x2000000000000000) != 0)
    v5 = HIBYTE(a2) & 0xF;
  else
    v5 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000) != 0)
    v6 = HIBYTE(a4) & 0xF;
  else
    v6 = a3 & 0xFFFFFFFFFFFFLL;
  if (a1 == a3 && a2 == a4 && v5 == v6)
    return 1;
  else
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v5, a3, a4, 0, v6, 0) & 1;
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = a2 >> 16;
  if ((a6 & 0x2000000000000000) != 0)
    v7 = HIBYTE(a6) & 0xF;
  else
    v7 = a5 & 0xFFFFFFFFFFFFLL;
  v8 = a1 >> 16;
  if (a3 == a5 && a4 == a6 && !v8 && v6 == v7)
    return 0;
  else
    return _stringCompareInternal(_:_:_:_:expecting:)(a3, a4, v8, v6, a5, a6, 0, v7, 1) & 1;
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((a2 & 0x2000000000000000) != 0)
    v7 = HIBYTE(a2) & 0xF;
  else
    v7 = a1 & 0xFFFFFFFFFFFFLL;
  v8 = a4 >> 16;
  v9 = a3 >> 16;
  if (a1 == a5 && a2 == a6 && !v9 && v7 == v8)
    return 0;
  else
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v7, a5, a6, v9, v8, 1) & 1;
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  if ((a2 & 0x2000000000000000) != 0)
    v5 = HIBYTE(a2) & 0xF;
  else
    v5 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000) != 0)
    v6 = HIBYTE(a4) & 0xF;
  else
    v6 = a3 & 0xFFFFFFFFFFFFLL;
  if (a1 == a3 && a2 == a4 && v5 == v6)
    return 0;
  else
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v5, a3, a4, 0, v6, 1) & 1;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF16.ForwardParser, &type metadata for Unicode.UTF16.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF16.ForwardParser, &type metadata for Unicode.UTF16.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser);
  }
  return result;
}

uint64_t type metadata accessor for ReversedCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for ReversedCollection);
}

Swift::UInt64 specialized String.Index.init(_:within:)(Swift::String::Index a1, unint64_t a2, uint64_t a3)
{
  Swift::UInt64 rawBits;
  uint64_t v5;
  Swift::Bool v6;

  rawBits = a1._rawBits;
  v5 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0)
    LOBYTE(v5) = 1;
  if ((a1._rawBits & 0xC) == 4 << v5)
    rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  v6 = String._isValidIndex(_:)((Swift::String::Index)rawBits);
  swift_bridgeObjectRelease(a3);
  if (v6)
    return rawBits | 3;
  else
    return 0;
}

Swift::UInt64 specialized String.Index.init(_:within:)(Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 rawBits;
  uint64_t v6;
  unint64_t v7;
  Swift::String::Index v9;
  BOOL v10;

  rawBits = a1._rawBits;
  v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0)
    LOBYTE(v6) = 1;
  if ((a1._rawBits & 0xC) == 4 << v6)
    rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0)
    v7 = a2 & 0xFFFFFFFFFFFFLL;
  if (v7 >= rawBits >> 16)
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      v9._rawBits = rawBits;
      v10 = String.Index._foreignIsWithin(_:)(a2, a3, v9);
      swift_bridgeObjectRelease(a3);
      if (v10)
        return rawBits;
    }
    else
    {
      swift_bridgeObjectRelease(a3);
      if ((rawBits & 0xC000) == 0)
        return rawBits;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a3);
  }
  return 0;
}

{
  Swift::UInt64 rawBits;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  BOOL v9;

  rawBits = a1._rawBits;
  v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0)
    LOBYTE(v6) = 1;
  if ((a1._rawBits & 0xC) == 4 << v6)
    rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0)
    v7 = a2 & 0xFFFFFFFFFFFFLL;
  if (v7 >= rawBits >> 16)
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      v8 = specialized String.Index._foreignIsWithin(_:)(rawBits);
    }
    else
    {
      if ((rawBits & 0xC000) != 0)
      {
        swift_bridgeObjectRelease(a3);
        return rawBits;
      }
      v8 = _StringGuts.isOnUnicodeScalarBoundary(_:)((Swift::String::Index)rawBits);
    }
    v9 = v8;
    swift_bridgeObjectRelease(a3);
    if (v9)
      return rawBits;
  }
  else
  {
    swift_bridgeObjectRelease(a3);
  }
  return 0;
}

{
  Swift::UInt64 rawBits;
  uint64_t v6;
  unint64_t v7;
  Swift::Bool v8;

  rawBits = a1._rawBits;
  v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0)
    LOBYTE(v6) = 1;
  if ((a1._rawBits & 0xC) == 4 << v6)
    rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0)
    v7 = a2 & 0xFFFFFFFFFFFFLL;
  if (v7 < rawBits >> 16)
  {
    swift_bridgeObjectRelease(a3);
    return 0;
  }
  v8 = _StringGuts.isOnUnicodeScalarBoundary(_:)((Swift::String::Index)rawBits);
  swift_bridgeObjectRelease(a3);
  if (!v8)
    return 0;
  return rawBits;
}

BOOL specialized String.Index._foreignIsWithin(_:)(__int16 a1)
{
  return (a1 & 0xC000) == 0;
}

double specialized _StringGuts.decidePostFormatBackward(between:and:with:)(char a1, unsigned __int8 a2, uint64_t a3, __n128 a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_BYTE *)(a3 + 57) = 18;
  switch(a1)
  {
    case 0:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
          goto LABEL_25;
        case 9u:
        case 0xBu:
        case 0xFu:
          goto LABEL_10;
        default:
          return a4.n128_f64[0];
      }
      return a4.n128_f64[0];
    case 2:
      if (a2 == 7)
      {
        v4 = *(_QWORD *)(a3 + 40);
        a4 = (__n128)xmmword_1816ABFB0;
        goto LABEL_36;
      }
      return a4.n128_f64[0];
    case 5:
      if (a2 <= 0xDu && (((1 << a2) & 0x2181) != 0 || a2 == 5))
        goto LABEL_25;
      return a4.n128_f64[0];
    case 7:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
        case 0xFu:
          goto LABEL_25;
        case 2u:
          if ((*(_BYTE *)(a3 + 32) & 1) != 0)
            return a4.n128_f64[0];
          if ((*(_BYTE *)(a3 + 16) & 1) != 0 && *(_OWORD *)a3 >= 2uLL)
            goto LABEL_53;
          *(_QWORD *)(a3 + 40) = *(_QWORD *)(a3 + 24);
          break;
        case 9u:
        case 0xBu:
LABEL_10:
          if ((*(_BYTE *)(a3 + 32) & 1) != 0)
            return a4.n128_f64[0];
          if ((*(_BYTE *)(a3 + 16) & 1) != 0 && *(_OWORD *)a3 == 0)
            goto LABEL_53;
          *(_QWORD *)(a3 + 40) = *(_QWORD *)(a3 + 24);
          break;
        default:
          return a4.n128_f64[0];
      }
      return a4.n128_f64[0];
    case 8:
      if (a2 == 5 || a2 == 8)
        goto LABEL_25;
      return a4.n128_f64[0];
    case 9:
      v5 = a2;
      if (a2)
        goto LABEL_33;
      goto LABEL_34;
    case 10:
      v6 = a2;
      goto LABEL_22;
    case 11:
      v6 = a2;
      if (!a2 || a2 == 7)
        goto LABEL_34;
LABEL_22:
      if (v6 == 13)
        goto LABEL_35;
      return a4.n128_f64[0];
    case 13:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
          goto LABEL_25;
        case 0xAu:
        case 0xBu:
        case 0xFu:
          if ((*(_BYTE *)(a3 + 32) & 1) == 0)
          {
            if ((*(_BYTE *)(a3 + 16) & 1) != 0 && !(*(_QWORD *)a3 ^ 1 | *(_QWORD *)(a3 + 8)))
            {
LABEL_53:
              a4.n128_u16[0] = 0;
              a4.n128_u8[2] = 0;
              a4.n128_u8[3] = 0;
              a4.n128_u8[4] = 0;
              a4.n128_u8[5] = 0;
              a4.n128_u8[6] = 0;
              a4.n128_u8[7] = 0;
              *(_OWORD *)a3 = 0u;
              *(_OWORD *)(a3 + 16) = 0u;
              *(_BYTE *)(a3 + 32) = 1;
              *(_QWORD *)(a3 + 48) = 0;
              *(_BYTE *)(a3 + 56) = 1;
            }
            else
            {
              *(_QWORD *)(a3 + 40) = *(_QWORD *)(a3 + 24);
            }
          }
          break;
        default:
          return a4.n128_f64[0];
      }
      return a4.n128_f64[0];
    case 14:
      if (a2 == 14)
      {
        v7 = *(_QWORD *)(a3 + 40);
        if ((*(_BYTE *)(a3 + 32) & 1) != 0)
        {
          v8 = 0;
          v9 = *(_QWORD *)(a3 + 48);
          if (*(_BYTE *)(a3 + 56))
            v9 = *(_QWORD *)(a3 + 40);
        }
        else if ((*(_BYTE *)(a3 + 16) & 1) != 0)
        {
          v8 = 0;
          v9 = *(_QWORD *)(a3 + 40);
        }
        else
        {
          v8 = *(_QWORD *)a3 + 1;
          if (__OFADD__(*(_QWORD *)a3, 1))
          {
            __break(1u);
            JUMPOUT(0x1815ACC70);
          }
          v9 = *(_QWORD *)(a3 + 24);
          if (*(_QWORD *)a3)
            v7 = *(_QWORD *)(a3 + 8);
        }
        *(_QWORD *)a3 = v8;
        *(_QWORD *)(a3 + 8) = v7;
        *(_QWORD *)(a3 + 16) = 0;
        *(_QWORD *)(a3 + 24) = v9;
        *(_BYTE *)(a3 + 32) = 0;
LABEL_25:
        *(_QWORD *)(a3 + 48) = 0;
        *(_BYTE *)(a3 + 56) = 1;
      }
      return a4.n128_f64[0];
    case 15:
      v5 = a2;
      if (!a2)
        goto LABEL_34;
      if (a2 == 13)
      {
LABEL_35:
        v4 = *(_QWORD *)(a3 + 40);
        a4 = (__n128)xmmword_1816ABC70;
LABEL_36:
        *(__n128 *)a3 = a4;
      }
      else
      {
LABEL_33:
        if (v5 != 7)
          return a4.n128_f64[0];
LABEL_34:
        v4 = *(_QWORD *)(a3 + 40);
        *(_QWORD *)a3 = 0;
        *(_QWORD *)(a3 + 8) = 0;
      }
      *(_QWORD *)(a3 + 16) = 1;
      *(_QWORD *)(a3 + 24) = v4;
      *(_BYTE *)(a3 + 32) = 0;
      return a4.n128_f64[0];
    default:
      return a4.n128_f64[0];
  }
}

uint64_t specialized _StringGuts.previousWordBoundary(endingAt:previousScalar:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  uint64_t v6;
  char v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  __n128 v12;
  char v13;
  uint64_t v14;
  unsigned __int8 v15;
  char v16;
  uint64_t v17;
  char v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int WordBreakProperty;
  unsigned int v24;
  uint64_t result;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  __int16 v33;

  v5 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v7 & 1) != 0)
  {
    swift_bridgeObjectRelease(a3);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringWordBreaking.swift", 30, 2, 0xB5uLL, 0);
  }
  v8 = v5;
  v9 = v6;
  v27 = 0u;
  v28 = 0u;
  v29 = 1;
  v30 = v6;
  v31 = 0;
  v32 = 1;
  v33 = 18;
  v10 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v6, a2, a3);
  if ((v13 & 1) != 0)
  {
LABEL_68:
    if ((v29 & 1) != 0)
      return v30;
    result = *((_QWORD *)&v28 + 1);
    if ((v28 & 1) == 0)
    {
      v26 = *((_QWORD *)&v27 + 1);
      if ((v27 & 1) != 0)
        v26 = *((_QWORD *)&v28 + 1);
      if ((_QWORD)v27)
        return v26;
      else
        return v30;
    }
    return result;
  }
  v14 = v11;
  while (1)
  {
    v19 = v8;
    v8 = v10;
    if (v10 == 13 && v19 == 10)
      goto LABEL_9;
    v20 = 12;
    if (v10 - 10 >= 4 && v10 != 133 && v10 - 8234 < 0xFFFFFFFE)
    {
      switch(v10)
      {
        case 0x22u:
          v20 = 2;
          break;
        case 0x200Du:
          v20 = 17;
          break;
        case 0x27u:
          v20 = 15;
          break;
        default:
          if (v10 - 127488 > 0xFFFFFFE5)
          {
            v20 = 14;
          }
          else
          {
            WordBreakProperty = _swift_stdlib_getWordBreakProperty(v10);
            if (WordBreakProperty >= 0xC)
              v20 = 1;
            else
              v20 = byte_1816B7D80[(char)WordBreakProperty];
          }
          break;
      }
    }
    v21 = 12;
    if (v19 - 10 >= 4 && v19 != 133)
    {
      if (v19 - 8234 >= 0xFFFFFFFE)
      {
        v21 = 12;
      }
      else
      {
        switch(v19)
        {
          case 0x22u:
            v21 = 2;
            break;
          case 0x200Du:
            v21 = 17;
            break;
          case 0x27u:
            v21 = 15;
            break;
          default:
            if (v19 - 127488 > 0xFFFFFFE5)
            {
              v21 = 14;
            }
            else
            {
              v24 = _swift_stdlib_getWordBreakProperty(v19);
              if (v24 >= 0xC)
                v21 = 1;
              else
                v21 = byte_1816B7D80[(char)v24];
            }
            break;
        }
      }
    }
    if (v20 == 1)
    {
      if (v21 > 0x11)
        goto LABEL_5;
      if (((1 << v21) & 0x20048) == 0)
      {
        if (((1 << v21) & 0x1002) != 0)
          goto LABEL_67;
        goto LABEL_5;
      }
LABEL_26:
      if (v33 == 18)
        goto LABEL_9;
      goto LABEL_5;
    }
    if (v20 == 12)
      goto LABEL_67;
    if (v21 != 4)
      break;
    if (v20 == 3 || v20 == 6)
    {
LABEL_45:
      LOBYTE(v33) = v21;
      if (v29)
        v22 = v9;
      else
        v22 = *((_QWORD *)&v28 + 1);
      v31 = v22;
      v32 = 0;
      goto LABEL_9;
    }
    if (v20 != 17)
      goto LABEL_5;
LABEL_9:
    v9 = v14;
    v30 = v14;
    v10 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v14, a2, a3);
    v14 = v17;
    if ((v18 & 1) != 0)
      goto LABEL_67;
  }
  if (v21 == 16)
  {
    switch(v20)
    {
      case 3u:
      case 6u:
      case 0x11u:
        goto LABEL_45;
      case 0x10u:
        goto LABEL_9;
      default:
        goto LABEL_5;
    }
  }
  if (v21 != 12)
  {
    if (v20 <= 0x11 && ((1 << v20) & 0x20048) != 0)
    {
      if (v21 > 0x11 || ((1 << v21) & 0x20048) == 0)
        goto LABEL_45;
      goto LABEL_9;
    }
    if (v21 > 0x11 || ((1 << v21) & 0x20048) == 0)
    {
LABEL_5:
      if (v33 == 18)
        v15 = v21;
      else
        v15 = v33;
      specialized _StringGuts.decidePostFormatBackward(between:and:with:)(v20, v15, (uint64_t)&v27, v12);
      if ((v16 & 1) != 0)
        goto LABEL_67;
      goto LABEL_9;
    }
    goto LABEL_26;
  }
LABEL_67:
  if (v32 == 1)
    goto LABEL_68;
  return v31;
}

uint64_t specialized _StringGuts.previousWordBoundary(endingAt:previousScalar:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned __int8 v11;
  char v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  __n128 v17;
  unsigned int v18;
  unsigned int WordBreakProperty;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  __int16 v31;

  if (a1 < 1)
  {
    swift_bridgeObjectRelease(a3);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringWordBreaking.swift", 30, 2, 0xB5uLL, 0);
  }
  v5 = a1;
  v6 = a4 - 1;
  do
    v7 = *(_BYTE *)(v6 + v5--) & 0xC0;
  while (v7 == 128);
  v8 = _decodeScalar(_:startingAt:)(a4, a2, v5);
  v25 = 0u;
  v26 = 0u;
  v27 = 1;
  v28 = v5;
  v29 = 0;
  v30 = 1;
  v31 = 18;
  if (v5 < 1)
  {
LABEL_77:
    if ((v27 & 1) != 0)
      return v28;
    result = *((_QWORD *)&v26 + 1);
    if ((v26 & 1) == 0)
    {
      v24 = *((_QWORD *)&v25 + 1);
      if ((v25 & 1) != 0)
        v24 = *((_QWORD *)&v26 + 1);
      if ((_QWORD)v25)
        return v24;
      else
        return v28;
    }
    return result;
  }
  v10 = v8;
  while (1)
  {
    v13 = v10;
    v14 = v5;
    do
      v15 = *(_BYTE *)(v6 + v5--) & 0xC0;
    while (v15 == 128);
    v16 = _decodeScalar(_:startingAt:)(a4, v9, v5);
    v10 = v16;
    if (v16 == 13 && v13 == 10)
      goto LABEL_11;
    v18 = 12;
    if (v16 - 10 >= 4 && v16 != 133 && v16 - 8234 < 0xFFFFFFFE)
    {
      switch(v16)
      {
        case 0x22u:
          v18 = 2;
          break;
        case 0x200Du:
          v18 = 17;
          break;
        case 0x27u:
          v18 = 15;
          break;
        default:
          if (v16 - 127488 > 0xFFFFFFE5)
          {
            v18 = 14;
          }
          else
          {
            WordBreakProperty = _swift_stdlib_getWordBreakProperty(v16);
            if (WordBreakProperty >= 0xC)
              v18 = 1;
            else
              v18 = byte_1816B7D80[(char)WordBreakProperty];
          }
          break;
      }
    }
    v20 = 12;
    if (v13 - 10 < 4 || v13 == 133)
      goto LABEL_49;
    if (v13 - 8234 >= 0xFFFFFFFE)
    {
      v20 = 12;
      if (v18 == 1)
        goto LABEL_72;
      goto LABEL_50;
    }
    switch(v13)
    {
      case 0x22u:
        v20 = 2;
        if (v18 == 1)
          goto LABEL_72;
        goto LABEL_50;
      case 0x200Du:
        v20 = 17;
        if (v18 == 1)
          goto LABEL_72;
        goto LABEL_50;
      case 0x27u:
        v20 = 15;
        if (v18 == 1)
          goto LABEL_72;
        goto LABEL_50;
    }
    if (v13 - 127488 > 0xFFFFFFE5)
    {
      v20 = 14;
LABEL_49:
      if (v18 == 1)
        goto LABEL_72;
      goto LABEL_50;
    }
    v21 = _swift_stdlib_getWordBreakProperty(v13);
    if (v21 >= 0xC)
    {
      v20 = 1;
      if (v18 == 1)
      {
LABEL_72:
        if (v20 > 0x11)
          goto LABEL_7;
        if (((1 << v20) & 0x20048) == 0)
        {
          if (((1 << v20) & 0x1002) != 0)
            goto LABEL_76;
          goto LABEL_7;
        }
LABEL_74:
        if (v31 == 18)
          goto LABEL_11;
        goto LABEL_7;
      }
    }
    else
    {
      v20 = byte_1816B7D80[(char)v21];
      if (v18 == 1)
        goto LABEL_72;
    }
LABEL_50:
    if (v18 == 12)
      goto LABEL_76;
    if (v20 != 4)
      break;
    if (v18 == 3 || v18 == 6)
    {
LABEL_64:
      LOBYTE(v31) = v20;
      if (v27)
        v22 = v14;
      else
        v22 = *((_QWORD *)&v26 + 1);
      v29 = v22;
      v30 = 0;
      goto LABEL_11;
    }
    if (v18 != 17)
      goto LABEL_7;
LABEL_11:
    v28 = v5;
    if (v5 <= 0)
      goto LABEL_76;
  }
  if (v20 == 16)
  {
    switch(v18)
    {
      case 3u:
      case 6u:
      case 0x11u:
        goto LABEL_64;
      case 0x10u:
        goto LABEL_11;
      default:
        goto LABEL_7;
    }
  }
  if (v20 != 12)
  {
    if (v18 <= 0x11 && ((1 << v18) & 0x20048) != 0)
    {
      if (v20 > 0x11 || ((1 << v20) & 0x20048) == 0)
        goto LABEL_64;
      goto LABEL_11;
    }
    if (v20 > 0x11 || ((1 << v20) & 0x20048) == 0)
    {
LABEL_7:
      if (v31 == 18)
        v11 = v20;
      else
        v11 = v31;
      specialized _StringGuts.decidePostFormatBackward(between:and:with:)(v18, v11, (uint64_t)&v25, v17);
      if ((v12 & 1) != 0)
        goto LABEL_76;
      goto LABEL_11;
    }
    goto LABEL_74;
  }
LABEL_76:
  if (v30 == 1)
    goto LABEL_77;
  return v29;
}

uint64_t specialized _StringGuts.nextWordBoundary(startingAt:nextScalar:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6;
  unsigned int v8;
  uint64_t v9;
  char v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  unsigned int v23;
  int v24;
  int v25;
  char v26;
  char v27;
  unsigned int v28;
  int WordBreakProperty;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v36;
  unint64_t v37;
  char v38;

  v6 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0)
    v6 = a2 & 0xFFFFFFFFFFFFLL;
  if (v6 <= a1)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/StringWordBreaking.swift", 30, 2, 0x9AuLL, 0);
  }
  v8 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(a1, a4, a5);
  if ((v10 & 1) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringWordBreaking.swift", 30, 2, 0x9CuLL, 0);
  }
  v11 = v8;
  v12 = v9;
  v13 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(v9, a4, a5);
  if ((v15 & 1) != 0)
    return v12;
  v16 = v14;
  v36 = 0;
  v17 = 0;
  v37 = 0;
  v38 = 0;
  v18 = 18;
  v19 = 1;
  do
  {
    v23 = v11;
    v11 = v13;
    if (v23 == 13 && v13 == 10)
      goto LABEL_9;
    if (v23 - 10 < 4 || v23 == 133 || v23 - 8234 >= 0xFFFFFFFE)
      break;
    switch(v23)
    {
      case 0x200Du:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133)
            goto LABEL_281;
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A)
              goto LABEL_281;
            v25 = 17;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 17;
              goto LABEL_67;
            }
            goto LABEL_226;
          }
        }
        v24 = 17;
        break;
      case 0x27u:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133)
            goto LABEL_281;
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A)
              goto LABEL_281;
            v25 = 15;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 15;
              goto LABEL_67;
            }
LABEL_226:
            v30 = 0;
            v26 = 0;
            v27 = 0;
            v28 = 14;
            goto LABEL_232;
          }
        }
        v24 = 15;
        break;
      case 0x22u:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133)
            goto LABEL_281;
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A)
              goto LABEL_281;
            v25 = 2;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 2;
              goto LABEL_67;
            }
            goto LABEL_226;
          }
        }
        v24 = 2;
        break;
      default:
        if (v23 - 127488 < 0xFFFFFFE6)
        {
          switch(_swift_stdlib_getWordBreakProperty(v23))
          {
            case 0u:
              if (v11 < 0xA)
                goto LABEL_45;
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 < 0x405)
              {
LABEL_45:
                v24 = 3;
                goto LABEL_33;
              }
              if (v11 < 0x202A)
                goto LABEL_281;
              v25 = 3;
              if (v11 - 127488 >= 0xFFFFFFE6)
                goto LABEL_226;
              LOBYTE(v24) = 3;
              goto LABEL_67;
            case 1u:
              if (v11 < 0xA)
                goto LABEL_89;
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 < 0x405)
              {
LABEL_89:
                v24 = 6;
                goto LABEL_33;
              }
              if (v11 < 0x202A)
                goto LABEL_281;
              v25 = 6;
              if (v11 - 127488 >= 0xFFFFFFE6)
                goto LABEL_226;
              LOBYTE(v24) = 6;
              goto LABEL_67;
            case 2u:
              if (v11 < 0xA)
              {
                v24 = 8;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 8;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_198;
                goto LABEL_226;
              }
              v25 = 8;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                  goto LABEL_69;
LABEL_198:
                LOBYTE(v24) = 8;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 3u:
              if (v11 < 0xA)
              {
                v24 = 7;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 7;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_201;
                goto LABEL_226;
              }
              v25 = 7;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                  goto LABEL_69;
LABEL_201:
                LOBYTE(v24) = 7;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 4u:
              if (v11 < 0xA)
              {
                v25 = 0;
                LOBYTE(v24) = 0;
                goto LABEL_34;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_204;
                v30 = 0;
                v26 = 0;
                v27 = 0;
                v25 = 0;
                v28 = 14;
                goto LABEL_232;
              }
              if (v11 == 34)
              {
                v26 = 0;
                v27 = 0;
                v25 = 0;
                goto LABEL_38;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 0;
                  goto LABEL_9;
                }
LABEL_204:
                v25 = 0;
                LOBYTE(v24) = 0;
                goto LABEL_67;
              }
              v25 = 0;
              goto LABEL_230;
            case 5u:
              if (v11 < 0xA)
              {
                v24 = 11;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 11;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_207;
                goto LABEL_226;
              }
              v25 = 11;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 11;
                  goto LABEL_9;
                }
LABEL_207:
                LOBYTE(v24) = 11;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 6u:
              if (v11 < 0xA)
              {
                v24 = 9;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 9;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_210;
                goto LABEL_226;
              }
              v25 = 9;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 9;
                  goto LABEL_9;
                }
LABEL_210:
                LOBYTE(v24) = 9;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 7u:
              if (v11 < 0xA)
              {
                v24 = 10;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 10;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_213;
                goto LABEL_226;
              }
              v25 = 10;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 10;
                  goto LABEL_9;
                }
LABEL_213:
                LOBYTE(v24) = 10;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 8u:
              if (v11 < 0xA)
              {
                v24 = 13;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 13;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_216;
                goto LABEL_226;
              }
              v25 = 13;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 13;
                  goto LABEL_9;
                }
LABEL_216:
                LOBYTE(v24) = 13;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 9u:
              if (v11 < 0xA)
              {
                v24 = 5;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 5;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_219;
                goto LABEL_226;
              }
              v25 = 5;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 5;
                  goto LABEL_9;
                }
LABEL_219:
                LOBYTE(v24) = 5;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 0xAu:
              if (v11 < 0xA)
              {
                v24 = 16;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 16;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_222;
                goto LABEL_226;
              }
              v25 = 16;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 16;
                  goto LABEL_9;
                }
LABEL_222:
                LOBYTE(v24) = 16;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 0xBu:
              if (v11 < 0xA)
              {
                v24 = 4;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 4;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_225;
                goto LABEL_226;
              }
              v25 = 4;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 4;
                  goto LABEL_9;
                }
LABEL_225:
                LOBYTE(v24) = 4;
                goto LABEL_67;
              }
              break;
            default:
              if (v11 < 0xA)
              {
                LOBYTE(v24) = 1;
                v25 = 1;
                goto LABEL_67;
              }
              if (v11 < 0xE || v11 == 133)
                goto LABEL_281;
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A)
                  goto LABEL_281;
                v25 = 1;
                if (v11 - 127488 < 0xFFFFFFE6)
                  goto LABEL_195;
                goto LABEL_226;
              }
              v25 = 1;
              if (v11 == 34)
                goto LABEL_37;
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  v18 = 1;
                  goto LABEL_9;
                }
LABEL_195:
                LOBYTE(v24) = 1;
                goto LABEL_67;
              }
              goto LABEL_230;
          }
          goto LABEL_230;
        }
        if (v13 < 0xA)
        {
          LOBYTE(v24) = 14;
          v25 = 14;
          goto LABEL_67;
        }
        if (v13 < 0xE || v13 == 133)
          goto LABEL_281;
        if (v13 >> 3 > 0x404)
        {
          if (v13 < 0x202A)
            goto LABEL_281;
          v25 = 14;
          if (v13 - 127488 >= 0xFFFFFFE6)
            goto LABEL_226;
        }
        else
        {
          v25 = 14;
          switch(v13)
          {
            case 0x22u:
              goto LABEL_37;
            case 0x27u:
              goto LABEL_230;
            case 0x200Du:
              v18 = 14;
              goto LABEL_9;
          }
        }
        LOBYTE(v24) = 14;
        goto LABEL_67;
    }
LABEL_33:
    v25 = v24;
LABEL_34:
    if (v11 != 8205)
    {
      if (v11 != 39)
      {
        if (v11 == 34)
        {
LABEL_37:
          v26 = 0;
          v27 = 0;
LABEL_38:
          v28 = 2;
LABEL_231:
          v30 = 1;
LABEL_232:
          if (v18 == 18)
            v31 = v25;
          else
            v31 = v18;
          switch(v31)
          {
            case 0:
              if (v28 > 0xF)
                goto LABEL_281;
              v32 = 1 << v28;
              if ((v32 & 0x20A1) != 0)
                goto LABEL_272;
              if ((v32 & 0x8A00) == 0)
                goto LABEL_281;
              goto LABEL_255;
            case 2:
              if ((v27 & 1) == 0)
                goto LABEL_281;
              if ((v19 & 1) != 0)
                return v12;
              if ((v38 & 1) == 0)
                return v17;
              v12 = v17;
              if (v37 < 2)
                return v12;
              goto LABEL_8;
            case 5:
              if (v28 > 0xD || ((1 << v28) & 0x21A1) == 0)
                goto LABEL_281;
              goto LABEL_272;
            case 7:
              if (v28 > 0xF)
                goto LABEL_281;
              if (((1 << v28) & 0xA0A1) != 0)
                goto LABEL_272;
              if (((1 << v28) & 0xA00) != 0)
              {
LABEL_255:
                v37 = 0;
                v19 = 0;
                v18 = 18;
              }
              else
              {
                if (v28 != 2)
                  goto LABEL_281;
                v19 = 0;
                v18 = 18;
                v34 = 2;
LABEL_279:
                v37 = v34;
              }
              v38 = 1;
              v17 = v12;
              goto LABEL_9;
            case 8:
              v18 = 18;
              if (v28 != 5 && v28 != 8)
                goto LABEL_281;
              goto LABEL_9;
            case 9:
              if (v28 && v28 != 7)
                goto LABEL_281;
              goto LABEL_261;
            case 10:
              if ((v26 & 1) == 0)
                goto LABEL_281;
              goto LABEL_266;
            case 11:
            case 15:
              if (!v28 || v28 == 7)
              {
LABEL_261:
                if ((v19 & 1) != 0)
                  return v12;
                if ((v38 & 1) == 0)
                  return v17;
                v12 = v17;
                if (v37)
                  return v12;
              }
              else
              {
                if (v28 != 13)
                  goto LABEL_281;
LABEL_266:
                if ((v19 & 1) != 0)
                  return v12;
                if ((v38 & 1) == 0)
                  return v17;
                v12 = v17;
                if (v37 != 1)
                  return v12;
              }
LABEL_8:
              v37 = 0;
              v38 = 0;
              v17 = 0;
              v18 = 18;
              v19 = 1;
              break;
            case 13:
              if (v28 > 0xF)
                goto LABEL_281;
              v33 = 1 << v28;
              if ((v33 & 0x20A1) != 0)
              {
LABEL_272:
                v18 = 18;
                goto LABEL_9;
              }
              if ((v33 & 0x8C00) == 0)
                goto LABEL_281;
              v19 = 0;
              v18 = 18;
              v34 = 1;
              goto LABEL_279;
            case 14:
              if (((v30 | v36) & 1) != 0)
                goto LABEL_281;
              v18 = 18;
              v36 = 1;
              goto LABEL_9;
            default:
              goto LABEL_281;
          }
          goto LABEL_9;
        }
LABEL_67:
        WordBreakProperty = _swift_stdlib_getWordBreakProperty(v11);
        v26 = 0;
        v27 = 0;
        v28 = 8;
        v30 = 1;
        switch(WordBreakProperty)
        {
          case 0:
          case 1:
            goto LABEL_68;
          case 2:
            goto LABEL_232;
          case 3:
            v26 = 0;
            v28 = 7;
            v27 = 1;
            goto LABEL_232;
          case 4:
            v26 = 0;
            v27 = 0;
            v28 = 0;
            goto LABEL_232;
          case 5:
            v26 = 0;
            v27 = 0;
            v28 = 11;
            goto LABEL_232;
          case 6:
            v26 = 0;
            v27 = 0;
            v28 = 9;
            goto LABEL_232;
          case 7:
            v26 = 0;
            v27 = 0;
            v28 = 10;
            goto LABEL_232;
          case 8:
            v27 = 0;
            v28 = 13;
            v26 = 1;
            goto LABEL_232;
          case 9:
            v26 = 0;
            v27 = 0;
            v28 = 5;
            goto LABEL_232;
          case 10:
            if (v25 == 16)
              goto LABEL_9;
            v26 = 0;
            v27 = 0;
            v28 = 16;
            break;
          case 11:
            if (v25 == 17)
              goto LABEL_9;
            v26 = 0;
            v27 = 0;
            v28 = 4;
            break;
          default:
            if (v25 == 1)
              goto LABEL_281;
            v26 = 0;
            v27 = 0;
            v30 = 1;
            v28 = 1;
            break;
        }
        goto LABEL_232;
      }
LABEL_230:
      v26 = 0;
      v27 = 0;
      v28 = 15;
      goto LABEL_231;
    }
LABEL_68:
    if (((1 << v24) & 0x20048) == 0)
LABEL_69:
      v18 = v25;
LABEL_9:
    v12 = v16;
    v13 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(v16, a4, a5);
    v16 = v21;
  }
  while ((v22 & 1) == 0);
LABEL_281:
  v20 = v12;
  v12 = v17;
  if ((v19 & 1) != 0)
    return v20;
  return v12;
}

id outlined copy of _StringRepresentation._Form(id result, uint64_t a2, uint64_t a3, char *a4)
{
  if (a2 <= 1u)
    return swift_unknownObjectRetain(result, a2, a3, a4);
  return result;
}

void outlined consume of _StringRepresentation._Form(id a1, unsigned __int8 a2)
{
  if (a2 <= 1u)
    swift_unknownObjectRelease(a1);
}

uint64_t type metadata accessor for SIMDMask(uint64_t a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for SIMDMask);
}

uint64_t specialized Substring.init(cString:)(uint8x16_t *a1)
{
  size_t v2;
  int64_t v3;
  int64_t v4;
  int64_t v5;
  char v6;

  v2 = _swift_stdlib_strlen(a1->i8);
  if ((v2 & 0x8000000000000000) != 0)
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  v3 = v2;
  v4 = validateUTF8(_:)(a1->i64, v2);
  if ((v6 & 1) != 0)
    repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v3, v4, v5);
  else
    specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v3, v4 & 1);
  return 15;
}

Swift::UInt64 specialized Substring.init(_:)(Swift::String::Index a1, Swift::String::Index a2)
{
  Swift::UInt64 rawBits;

  rawBits = a1._rawBits;
  if ((a1._rawBits & 1) == 0)
  {
    rawBits = a1._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a1)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if ((a2._rawBits & 1) != 0)
      return rawBits;
LABEL_5:
    _StringGuts.scalarAlignSlow(_:)(a2)._rawBits;
    return rawBits;
  }
  if ((a2._rawBits & 1) == 0)
    goto LABEL_5;
  return rawBits;
}

uint64_t partial apply for closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)()
{
  uint64_t v0;

  return _StringGuts.replaceSubrange<A>(_:with:)(*(_QWORD *)(v0 + 32), *(_QWORD *)(v0 + 40), *(_QWORD *)(v0 + 48), *(_QWORD *)(v0 + 16), *(_QWORD *)(v0 + 24));
}

unint64_t lazy protocol witness table accessor for type UInt32 and conformance UInt32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt32, &type metadata for UInt32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt32, &type metadata for UInt32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt32, &type metadata for UInt32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }
  return result;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>()
{
  type metadata accessor for __ContiguousArrayStorageBase();
  return objc_opt_self();
}

uint64_t type metadata accessor for UnsafeMutablePointer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for UnsafeMutablePointer);
}

uint64_t type metadata accessor for _UIntBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _UIntBuffer);
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF8.ForwardParser, &type metadata for Unicode.UTF8.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF8.ForwardParser, &type metadata for Unicode.UTF8.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser);
  }
  return result;
}

void sub_1815AE5EC()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

BOOL partial apply for closure #1 in LazySequenceProtocol.compactMap<A>(_:)(uint64_t a1)
{
  uint64_t v1;

  return (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(v1 + 24) - 8) + 48))(a1, 1) != 1;
}

void sub_1815AE628()
{
  uint64_t v0;

  swift_deallocObject(v0);
}

uint64_t outlined destroy of _PlaygroundQuickLook?(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 32) <= 0x12u)
    destroy for _PlaygroundQuickLook(a1);
  return a1;
}

uint64_t outlined init with take of _PlaygroundQuickLook(__int128 *a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;

  v2 = *a1;
  v3 = a1[1];
  *(_BYTE *)(a2 + 32) = *((_BYTE *)a1 + 32);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

uint64_t type metadata accessor for CollectionDifference.Change(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CollectionDifference.Change);
}

void partial apply for closure #3 in CollectionDifference<A>.inferringMoves()(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;

  closure #3 in CollectionDifference<A>.inferringMoves()(a1, v2[4], v2[5], v2[2], v2[3], a2);
}

uint64_t type metadata accessor for CollectionDifference.Change<A>._CodingKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CollectionDifference.Change<A>._CodingKeys);
}

unint64_t lazy protocol witness table accessor for type Int? and conformance <A> A?()
{
  unint64_t result;
  _UNKNOWN **v1;

  result = lazy protocol witness table cache variable for type Int? and conformance <A> A?;
  if (!lazy protocol witness table cache variable for type Int? and conformance <A> A?)
  {
    v1 = &protocol witness table for Int;
    result = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, &unk_1E0EACF60, &v1);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int? and conformance <A> A?);
  }
  return result;
}

{
  unint64_t result;
  _UNKNOWN **v1;

  result = lazy protocol witness table cache variable for type Int? and conformance <A> A?;
  if (!lazy protocol witness table cache variable for type Int? and conformance <A> A?)
  {
    v1 = &protocol witness table for Int;
    result = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, &unk_1E0EACF60, &v1);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int? and conformance <A> A?);
  }
  return result;
}

uint64_t type metadata accessor for CollectionDifference.CodingKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CollectionDifference.CodingKeys);
}

unint64_t *partial apply for closure #1 in RangeReplaceableCollection.applying(_:)(uint64_t a1)
{
  uint64_t v1;

  return closure #1 in RangeReplaceableCollection.applying(_:)(a1, *(_QWORD **)(v1 + 32), *(_QWORD *)(v1 + 40), *(_QWORD *)(v1 + 48), *(_QWORD *)(v1 + 56), *(_QWORD **)(v1 + 64), *(_QWORD **)(v1 + 72), *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24));
}

uint64_t type metadata accessor for CollectionDifference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for CollectionDifference);
}

void partial apply for closure #1 in _myers<A, B>(from:to:using:)(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  partial apply for closure #1 in _myers<A, B>(from:to:using:)(a1, a2);
}

{
  uint64_t *v2;

  closure #1 in _myers<A, B>(from:to:using:)(a1, v2[6], v2[2], v2[3], v2[4], a2);
}

uint64_t partial apply for implicit closure #1 in BidirectionalCollection<>.difference<A>(from:)(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, unint64_t, uint64_t);
  unint64_t AssociatedTypeWitness;

  v5 = v2[6];
  v6 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(v5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(*(_QWORD *)(v2[4] + 8) + 8), v2[2], (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

unint64_t lazy protocol witness table accessor for type Int64 and conformance Int64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64, &type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

__objc2_class *specialized _SwiftNSMutableArray.countByEnumerating(with:objects:count:)(_QWORD *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  __objc2_class *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v14;
  __objc2_class **v15;

  if (*a1)
    return 0;
  v7 = a1[3];
  v8 = a1[4];
  v9 = a1[5];
  v10 = a1[6];
  v11 = a1[7];
  v12 = *(_QWORD *)(v4 + 16);
  if ((v12 & 0x8000000000000000) != 0 || (v12 & 0x4000000000000000) != 0)
  {
    v14 = swift_bridgeObjectRetain(*(_QWORD *)(v4 + 16), a2, a3, a4);
    v15 = specialized _copyCollectionToContiguousArray<A>(_:)(v14);
    v5 = v15[2];
    *a1 = 1;
    a1[1] = v15 + 4;
    a1[2] = &_fastEnumerationStorageMutationsTarget;
    a1[3] = v7;
    a1[4] = v8;
    a1[5] = v9;
    a1[6] = v10;
    a1[7] = v11;
    swift_release((uint64_t)v15);
  }
  else
  {
    v5 = *(__objc2_class **)((v12 & 0xFFFFFFFFFFFFFF8) + 0x10);
    *a1 = 1;
    a1[1] = (v12 & 0xFFFFFFFFFFFFFF8) + 32;
    a1[2] = &_fastEnumerationStorageMutationsTarget;
    swift_bridgeObjectRetain(v12, a2, a3, a4);
  }
  swift_bridgeObjectRelease(v12);
  return v5;
}

__objc2_class **specialized _SwiftNSMutableArray.copy(with:)(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;

  v5 = *(_QWORD *)(v4 + 16);
  if ((unint64_t)v5 >> 62)
  {
    if (v5 < 0)
      v8 = *(_QWORD *)(v4 + 16);
    else
      v8 = v5 & 0xFFFFFFFFFFFFFF8;
    swift_bridgeObjectRetain(v5, a2, a3, a4);
  }
  else
  {
    v6 = one-time initialization token for _bridgeInitializedSuccessfully;
    swift_bridgeObjectRetain_n(v5, 2, a3, a4);
    if (v6 != -1)
      swift_once(&one-time initialization token for _bridgeInitializedSuccessfully, (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully, v7);
    if (!_bridgeInitializedSuccessfully)
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0x82uLL, 0);
    v8 = v5 & 0xFFFFFFFFFFFFFF8;
    _orphanedFoundationSubclassesReparented = 1;
    if (*(_QWORD *)((v5 & 0xFFFFFFFFFFFFFF8) + 0x10))
    {
      v9 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
      swift_bridgeObjectRetain(v5, v10, v11, v12);
      _swift_setClassMetadata(v9, (_QWORD *)(v5 & 0xFFFFFFFFFFFFFF8));
      swift_bridgeObjectRelease_n(v5, 2);
    }
    else
    {
      swift_bridgeObjectRelease_n(v5, 2);
      return &_swiftEmptyArrayStorage;
    }
  }
  return (__objc2_class **)v8;
}

uint64_t specialized static Unicode.UTF16.encode(_:into:)(unsigned int a1, void (*a2)(__int16 *))
{
  __int16 *v3;
  unsigned int v5;
  __int16 v6;
  __int16 v7;

  if (HIWORD(a1))
  {
    v5 = ((a1 + 983040) >> 10) & 0x3FF | ((a1 & 0x3FF) << 16) | 0xDC00D800;
    v7 = ((a1 + 983040) >> 10) & 0x3FF | 0xD800;
    a2(&v7);
    v6 = HIWORD(v5);
    v3 = &v6;
  }
  else
  {
    v7 = a1;
    v3 = &v7;
  }
  return ((uint64_t (*)(__int16 *))a2)(v3);
}

uint64_t specialized Duration.init(_:scale:)(Swift::UInt64 a1, double a2)
{
  double v4;
  Swift::UInt64 low;
  Swift::Int64 high;
  unint64_t v7;
  uint64_t v8;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *TypeName;
  uint64_t v14;
  uint8x16_t *v15;
  int64_t v16;
  int64_t v17;
  int64_t v18;
  char v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint8x16_t *v40;
  int64_t v41;
  int64_t v42;
  int64_t v43;
  char v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  unint64_t v60;
  unint64_t v61;
  char v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char v66;
  Swift::tuple_partialValue__Int128_overflow_Bool v67;

  v4 = trunc(a2);
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v64, v4);
  if ((v66 & 1) != 0)
  {
    v10 = specialized static String._createEmpty(withInitialCapacity:)(80);
    v12 = v11;
    v64 = v10;
    v65 = v11;
    TypeName = (uint64_t *)swift_getTypeName((Class *)&type metadata for Double, 0);
    if (v14 < 0)
      goto LABEL_68;
    v15 = (uint8x16_t *)TypeName;
    v16 = v14;
    v17 = validateUTF8(_:)(TypeName, v14);
    if ((v19 & 1) != 0)
      v20 = repairUTF8(_:firstKnownBrokenRange:)(v15->i8, v16, v17, v18);
    else
      v20 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v15, v16, v17 & 1);
    v22 = v20;
    v23 = v21;
    v24 = HIBYTE(v12) & 0xF;
    if ((v12 & 0x2000000000000000) == 0)
      v24 = v10 & 0xFFFFFFFFFFFFLL;
    if (!v24 && (v10 & ~v12 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v12);
      v64 = v22;
      v65 = v23;
      goto LABEL_23;
    }
    if ((v12 & 0x2000000000000000) != 0)
    {
      if ((v21 & 0x2000000000000000) != 0)
      {
        v26 = specialized _SmallString.init(_:appending:)(v10, v12, v20, v21);
        if ((v28 & 1) == 0)
        {
          v29 = v26;
          v30 = v27;
          swift_bridgeObjectRelease(v12);
          swift_bridgeObjectRelease(v23);
          v64 = v29;
          v65 = v30;
          v23 = v30;
          v22 = v29;
          goto LABEL_23;
        }
        goto LABEL_21;
      }
    }
    else if ((v21 & 0x2000000000000000) != 0)
    {
LABEL_21:
      v25 = HIBYTE(v23) & 0xF;
      goto LABEL_22;
    }
    v25 = v20 & 0xFFFFFFFFFFFFLL;
LABEL_22:
    _StringGuts.append(_:)(v22, v23, 0, v25);
    swift_bridgeObjectRelease(v23);
    v22 = v64;
    v23 = v65;
LABEL_23:
    v31 = HIBYTE(v23) & 0xF;
    if ((v23 & 0x2000000000000000) == 0)
      v31 = v22 & 0xFFFFFFFFFFFFLL;
    if (v31 || (v22 & ~v23 & 0x2000000000000000) != 0)
    {
      if ((v23 & 0x2000000000000000) != 0
        && (0x8000000181762940 & 0x2000000000000000) != 0
        && (v32 = specialized _SmallString.init(_:appending:)(v22, v23, 0xD00000000000001ELL, 0x8000000181762940 | 0x8000000000000000), (v34 & 1) == 0))
      {
        v35 = v32;
        v36 = v33;
        swift_bridgeObjectRelease(v23);
        swift_bridgeObjectRelease(0x8000000181762940 | 0x8000000000000000);
        v64 = v35;
        v65 = v36;
      }
      else
      {
        if ((0x8000000181762940 & 0x2000000000000000) != 0)
          v37 = (0x8000000181762940 >> 56) & 0xF;
        else
          v37 = 30;
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x8000000181762940 | 0x8000000000000000, 0, v37);
        swift_bridgeObjectRelease(0x8000000181762940 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v23);
      v64 = 0xD00000000000001ELL;
      v65 = 0x8000000181762940 | 0x8000000000000000;
    }
    v38 = (uint64_t *)swift_getTypeName((Class *)&type metadata for _Int128, 0);
    if ((v39 & 0x8000000000000000) == 0)
    {
      v40 = (uint8x16_t *)v38;
      v41 = v39;
      v42 = validateUTF8(_:)(v38, v39);
      if ((v44 & 1) != 0)
        v45 = repairUTF8(_:firstKnownBrokenRange:)(v40->i8, v41, v42, v43);
      else
        v45 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v40, v41, v42 & 1);
      v47 = v45;
      v48 = v46;
      v49 = v65;
      v50 = HIBYTE(v65) & 0xF;
      if ((v65 & 0x2000000000000000) == 0)
        v50 = v64 & 0xFFFFFFFFFFFFLL;
      if (!v50 && (v64 & ~v65 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v65);
        v64 = v47;
        v65 = v48;
        goto LABEL_54;
      }
      if ((v65 & 0x2000000000000000) != 0)
      {
        if ((v46 & 0x2000000000000000) != 0)
        {
          v52 = specialized _SmallString.init(_:appending:)(v64, v65, v45, v46);
          if ((v54 & 1) == 0)
          {
            v55 = v52;
            v56 = v53;
            swift_bridgeObjectRelease(v49);
            swift_bridgeObjectRelease(v48);
            v64 = v55;
            v65 = v56;
            v48 = v56;
            v47 = v55;
            goto LABEL_54;
          }
          goto LABEL_52;
        }
      }
      else if ((v46 & 0x2000000000000000) != 0)
      {
LABEL_52:
        v51 = HIBYTE(v48) & 0xF;
        goto LABEL_53;
      }
      v51 = v45 & 0xFFFFFFFFFFFFLL;
LABEL_53:
      _StringGuts.append(_:)(v47, v48, 0, v51);
      swift_bridgeObjectRelease(v48);
      v47 = v64;
      v48 = v65;
LABEL_54:
      v57 = HIBYTE(v48) & 0xF;
      if ((v48 & 0x2000000000000000) == 0)
        v57 = v47 & 0xFFFFFFFFFFFFLL;
      if (v57 || (v47 & ~v48 & 0x2000000000000000) != 0)
      {
        if ((v48 & 0x2000000000000000) != 0
          && (0x8000000181762960 & 0x2000000000000000) != 0
          && (v60 = specialized _SmallString.init(_:appending:)(v47, v48, 0xD00000000000002ELL, 0x8000000181762960 | 0x8000000000000000), (v62 & 1) == 0))
        {
          v59 = (char *)v60;
          v58 = v61;
          swift_bridgeObjectRelease(v48);
          swift_bridgeObjectRelease(0x8000000181762960 | 0x8000000000000000);
        }
        else
        {
          if ((0x8000000181762960 & 0x2000000000000000) != 0)
            v63 = (0x8000000181762960 >> 56) & 0xF;
          else
            v63 = 46;
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x8000000181762960 | 0x8000000000000000, 0, v63);
          swift_bridgeObjectRelease(0x8000000181762960 | 0x8000000000000000);
          v59 = (char *)v64;
          v58 = v65;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v48);
        v58 = 0x8000000181762960 | 0x8000000000000000;
        v59 = (char *)0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v59, v58, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_68:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  v67 = _Int128.multipliedReportingOverflow(by:)(a1);
  if (v67.overflow)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in multiplication", 26, 2, "Swift/LegacyInt128.swift", 24, 2, 0x30CuLL, 0);
  low = v67.partialValue.low;
  high = v67.partialValue.high;
  v7 = specialized FixedWidthInteger.init<A>(_:)(round((a2 - v4) * (double)a1));
  return specialized static Duration.+ infix(_:_:)(low, high, v7, v8);
}

uint64_t specialized Duration.init(from:)(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10[3];
  uint64_t v11;
  uint64_t v12;

  v2 = a1[3];
  v3 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v3 + 32))(v10, v2, v3);
  v4 = v11;
  v5 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  (*(void (**)(uint64_t, uint64_t))(v5 + 112))(v4, v5);
  v6 = v11;
  v7 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 160))(v6, v7);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v8;
}

unint64_t *specialized static Duration.-= infix(_:_:)(unint64_t *result, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  int v7;
  BOOL v8;
  unint64_t v9;

  v4 = *result;
  v3 = result[1];
  v5 = __OFSUB__(v3, a3);
  v6 = v3 - a3;
  v7 = v5;
  v8 = v4 >= a2;
  v9 = v4 - a2;
  if (v8)
  {
    if (v7)
      goto LABEL_8;
  }
  else
  {
    if (v6 == 0x8000000000000000)
      LOBYTE(v7) = 1;
    if ((v7 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v6;
  }
  *result = v9;
  result[1] = v6;
  return result;
}

uint64_t specialized static Duration./ infix(_:_:)(unint64_t a1, uint64_t a2, double a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t *TypeName;
  uint64_t v9;
  uint8x16_t *v10;
  int64_t v11;
  int64_t v12;
  int64_t v13;
  char v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  double v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char v29;
  double v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint8x16_t *v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  char v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  char v49;
  double v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  unint64_t v55;
  unint64_t v56;
  char v57;
  unint64_t v58;
  double v59;
  unint64_t v60;
  char v61;

  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v59, a1, a2);
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v59, v59 / a3);
  if ((v61 & 1) != 0)
  {
    *(double *)&v5 = COERCE_DOUBLE(specialized static String._createEmpty(withInitialCapacity:)(80));
    v7 = v6;
    v59 = *(double *)&v5;
    v60 = v6;
    TypeName = (uint64_t *)swift_getTypeName((Class *)&type metadata for Double, 0);
    if (v9 < 0)
      goto LABEL_66;
    v10 = (uint8x16_t *)TypeName;
    v11 = v9;
    v12 = validateUTF8(_:)(TypeName, v9);
    if ((v14 & 1) != 0)
      v15 = repairUTF8(_:firstKnownBrokenRange:)(v10->i8, v11, v12, v13);
    else
      v15 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v10, v11, v12 & 1);
    v17 = v15;
    v18 = v16;
    v19 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000) == 0)
      v19 = v5 & 0xFFFFFFFFFFFFLL;
    if (!v19 && (v5 & ~v7 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v7);
      v59 = *(double *)&v17;
      v60 = v18;
      goto LABEL_21;
    }
    if ((v7 & 0x2000000000000000) != 0)
    {
      if ((v16 & 0x2000000000000000) != 0)
      {
        v21 = specialized _SmallString.init(_:appending:)(v5, v7, v15, v16);
        if ((v23 & 1) == 0)
        {
          v24 = *(double *)&v21;
          v25 = v22;
          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v18);
          v59 = v24;
          v60 = v25;
          v18 = v25;
          *(double *)&v17 = v24;
          goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    else if ((v16 & 0x2000000000000000) != 0)
    {
LABEL_19:
      v20 = HIBYTE(v18) & 0xF;
      goto LABEL_20;
    }
    v20 = v15 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v17, v18, 0, v20);
    swift_bridgeObjectRelease(v18);
    *(double *)&v17 = v59;
    v18 = v60;
LABEL_21:
    v26 = HIBYTE(v18) & 0xF;
    if ((v18 & 0x2000000000000000) == 0)
      v26 = v17 & 0xFFFFFFFFFFFFLL;
    if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
    {
      if ((v18 & 0x2000000000000000) != 0
        && (0x8000000181762940 & 0x2000000000000000) != 0
        && (v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0xD00000000000001ELL, 0x8000000181762940 | 0x8000000000000000), (v29 & 1) == 0))
      {
        v30 = *(double *)&v27;
        v31 = v28;
        swift_bridgeObjectRelease(v18);
        swift_bridgeObjectRelease(0x8000000181762940 | 0x8000000000000000);
        v59 = v30;
        v60 = v31;
      }
      else
      {
        if ((0x8000000181762940 & 0x2000000000000000) != 0)
          v32 = (0x8000000181762940 >> 56) & 0xF;
        else
          v32 = 30;
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x8000000181762940 | 0x8000000000000000, 0, v32);
        swift_bridgeObjectRelease(0x8000000181762940 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v18);
      v59 = -2.31584178e77;
      v60 = 0x8000000181762940 | 0x8000000000000000;
    }
    v33 = (uint64_t *)swift_getTypeName((Class *)&type metadata for _Int128, 0);
    if ((v34 & 0x8000000000000000) == 0)
    {
      v35 = (uint8x16_t *)v33;
      v36 = v34;
      v37 = validateUTF8(_:)(v33, v34);
      if ((v39 & 1) != 0)
        v40 = repairUTF8(_:firstKnownBrokenRange:)(v35->i8, v36, v37, v38);
      else
        v40 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v35, v36, v37 & 1);
      v42 = v40;
      v43 = v41;
      v44 = v60;
      v45 = HIBYTE(v60) & 0xF;
      if ((v60 & 0x2000000000000000) == 0)
        v45 = *(_QWORD *)&v59 & 0xFFFFFFFFFFFFLL;
      if (!v45 && (*(_QWORD *)&v59 & ~v60 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v60);
        v59 = *(double *)&v42;
        v60 = v43;
        goto LABEL_52;
      }
      if ((v60 & 0x2000000000000000) != 0)
      {
        if ((v41 & 0x2000000000000000) != 0)
        {
          v47 = specialized _SmallString.init(_:appending:)(*(unint64_t *)&v59, v60, v40, v41);
          if ((v49 & 1) == 0)
          {
            v50 = *(double *)&v47;
            v51 = v48;
            swift_bridgeObjectRelease(v44);
            swift_bridgeObjectRelease(v43);
            v59 = v50;
            v60 = v51;
            v43 = v51;
            *(double *)&v42 = v50;
            goto LABEL_52;
          }
          goto LABEL_50;
        }
      }
      else if ((v41 & 0x2000000000000000) != 0)
      {
LABEL_50:
        v46 = HIBYTE(v43) & 0xF;
        goto LABEL_51;
      }
      v46 = v40 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v42, v43, 0, v46);
      swift_bridgeObjectRelease(v43);
      *(double *)&v42 = v59;
      v43 = v60;
LABEL_52:
      v52 = HIBYTE(v43) & 0xF;
      if ((v43 & 0x2000000000000000) == 0)
        v52 = v42 & 0xFFFFFFFFFFFFLL;
      if (v52 || (v42 & ~v43 & 0x2000000000000000) != 0)
      {
        if ((v43 & 0x2000000000000000) != 0
          && (0x8000000181762960 & 0x2000000000000000) != 0
          && (v55 = specialized _SmallString.init(_:appending:)(v42, v43, 0xD00000000000002ELL, 0x8000000181762960 | 0x8000000000000000), (v57 & 1) == 0))
        {
          v54 = (char *)v55;
          v53 = v56;
          swift_bridgeObjectRelease(v43);
          swift_bridgeObjectRelease(0x8000000181762960 | 0x8000000000000000);
        }
        else
        {
          if ((0x8000000181762960 & 0x2000000000000000) != 0)
            v58 = (0x8000000181762960 >> 56) & 0xF;
          else
            v58 = 46;
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x8000000181762960 | 0x8000000000000000, 0, v58);
          swift_bridgeObjectRelease(0x8000000181762960 | 0x8000000000000000);
          v54 = *(char **)&v59;
          v53 = v60;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v43);
        v53 = 0x8000000181762960 | 0x8000000000000000;
        v54 = (char *)0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v54, v53, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_66:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return *(_QWORD *)&v59;
}

uint64_t specialized Int128.init<A>(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;
  char v11;

  MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = 4;
  (*(void (**)(char *))(*(_QWORD *)(v7 + 16) + 304))(&v11);
  result = Int128.init<A>(exactly:)(v6, a2, a3);
  if ((v9 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000051, 0x8000000181766B80, "Swift/Int128.swift", 18, 2, 0xD4uLL, 0);
  return result;
}

void sub_1815AF7F0()
{
  uint64_t v0;

  swift_release(*(_QWORD *)(v0 + 24));
  swift_release(*(_QWORD *)(v0 + 48));
  swift_deallocObject(v0);
}

uint64_t outlined init with take of MirrorPath(__int128 *a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;

  v2 = *a1;
  v3 = a1[1];
  *(_QWORD *)(a2 + 32) = *((_QWORD *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

uint64_t outlined retain of Mirror(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;

  v5 = *(unint64_t **)(a1 + 32);
  swift_retain(*(unint64_t **)(a1 + 8), a2, a3, a4);
  swift_retain(v5, v6, v7, v8);
  return a1;
}

uint64_t specialized UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t result;
  char v9;
  uint64_t v10;
  char v11;

  MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = 4;
  (*(void (**)(char *))(*(_QWORD *)(v7 + 16) + 304))(&v11);
  result = UInt128.init<A>(exactly:)(v6, a2, a3);
  if ((v9 & 1) != 0)
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, (char *)0xD000000000000052, 0x8000000181766AF0, "Swift/UInt128.swift", 19, 2, 0xC6uLL, 0);
  return result;
}

void sub_1815AF948()
{
  uint64_t v0;

  swift_release(*(_QWORD *)(v0 + 32));
  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in sequence<A>(first:next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  return closure #1 in sequence<A>(first:next:)(a1, *(void (**)(char *))(v2 + 24), *(_QWORD *)(v2 + 32), *(_QWORD *)(v2 + 16), a2);
}

uint64_t type metadata accessor for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for UnfoldSequence);
}

void *partial apply for closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(const void *a1, size_t a2)
{
  uint64_t v2;

  return closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(a1, a2, *(_QWORD *)(v2 + 32), *(_QWORD *)(v2 + 40), *(_QWORD *)(v2 + 48), *(void **)(v2 + 56), *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24));
}

uint64_t type metadata accessor for __VaListBuilder()
{
  return objc_opt_self();
}

void partial apply for closure #1 in SIMD.description.getter(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;

  closure #1 in SIMD.description.getter(a1, *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 + 24), a2);
}

BOOL partial apply for specialized closure #1 in Sequence<>.contains(_:)(unsigned __int16 *a1)
{
  uint64_t v1;

  return *a1 == **(unsigned __int16 **)(v1 + 16);
}

_BYTE *partial apply for closure #1 in closure #1 in Float.init<A>(_:)@<X0>(_BYTE *a1@<X0>, BOOL *a2@<X8>)
{
  return partial apply for closure #1 in closure #1 in Float.init<A>(_:)(a1, (uint64_t (*)(void))_swift_stdlib_strtof_clocale, a2);
}

_BYTE *partial apply for closure #1 in closure #1 in Double.init<A>(_:)@<X0>(_BYTE *a1@<X0>, BOOL *a2@<X8>)
{
  return partial apply for closure #1 in closure #1 in Float.init<A>(_:)(a1, (uint64_t (*)(void))_swift_stdlib_strtod_clocale, a2);
}

_BYTE *partial apply for closure #1 in closure #1 in Float.init<A>(_:)@<X0>(_BYTE *result@<X0>, uint64_t (*a2)(void)@<X1>, BOOL *a3@<X8>)
{
  unsigned int v4;
  BOOL v5;
  uint64_t v6;
  BOOL v7;
  BOOL v8;

  v4 = *result;
  v5 = v4 > 0x20;
  v6 = (1 << v4) & 0x100003E01;
  v7 = v5 || v6 == 0;
  v8 = v7 && (result = (_BYTE *)a2()) != 0 && *result == 0;
  *a3 = v8;
  return result;
}

__int16 specialized Float16.init(sign:exponent:significand:)@<H0>(char a1@<W0>, uint64_t a2@<X1>, float _S0@<S0>)
{
  float v3;
  int v10;
  uint64_t v11;

  v3 = _S0;
  __asm { FCVT            S0, H0 }
  _S0 = -_S0;
  __asm { FCVT            H0, S0 }
  if ((a1 & 1) == 0)
    _S0 = v3;
  v10 = (LODWORD(v3) >> 10) & 0x1F;
  if (v10 != 31 && v10 | LOWORD(v3) & 0x3FF)
  {
    if (a2 > -15)
    {
      if (a2 >= 16)
      {
        if (a2 >= 45)
          a2 = 45;
        do
        {
          a2 -= 15;
          __asm { FCVT            S0, H0 }
          _S0 = _S0 * 32768.0;
          __asm { FCVT            H0, S0 }
        }
        while ((unint64_t)a2 > 0xF);
      }
    }
    else
    {
      if (a2 <= -42)
        v11 = -42;
      else
        v11 = a2;
      do
      {
        LOWORD(a2) = v11 + 14;
        __asm { FCVT            S0, H0 }
        _S0 = _S0 * 0.000061035;
        __asm { FCVT            H0, S0 }
        _CF = __CFADD__(v11, 28);
        v11 += 14;
      }
      while (!_CF);
    }
    _H1 = (((_WORD)a2 << 10) + 15360) & 0x7C00;
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    _S0 = _S0 * _S1;
    __asm { FCVT            H0, S0 }
  }
  return LOWORD(_S0);
}

float _stdlib_squareRootf(float a1)
{
  return sqrtf(a1);
}

float specialized Float.init(sign:exponent:significand:)(char a1, uint64_t a2, float a3)
{
  float result;
  int v5;
  uint64_t v6;
  BOOL v7;

  result = -a3;
  if ((a1 & 1) == 0)
    result = a3;
  v5 = (LODWORD(a3) >> 23);
  if (v5 != 255 && v5 | LODWORD(a3) & 0x7FFFFF)
  {
    if (a2 > -127)
    {
      if (a2 >= 128)
      {
        if (a2 >= 381)
          a2 = 381;
        do
        {
          a2 -= 127;
          result = result * 1.7014e38;
        }
        while ((unint64_t)a2 > 0x7F);
      }
    }
    else
    {
      if (a2 <= -378)
        v6 = -378;
      else
        v6 = a2;
      do
      {
        LODWORD(a2) = v6 + 126;
        result = result * 1.1755e-38;
        v7 = __CFADD__(v6, 252);
        v6 += 126;
      }
      while (!v7);
    }
    return result * COERCE_FLOAT((((_DWORD)a2 << 23) + 1065353216) & 0x7F800000);
  }
  return result;
}

double specialized Double.init(sign:exponent:significand:)(char a1, uint64_t a2, double a3)
{
  double result;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;

  result = -a3;
  if ((a1 & 1) == 0)
    result = a3;
  v5 = (*(_QWORD *)&a3 >> 52) & 0x7FFLL;
  if (v5 != 2047 && v5 | *(_QWORD *)&a3 & 0xFFFFFFFFFFFFFLL)
  {
    if (a2 > -1023)
    {
      if (a2 >= 1024)
      {
        if (a2 >= 3069)
          a2 = 3069;
        do
        {
          a2 -= 1023;
          result = result * 8.98846567e307;
        }
        while ((unint64_t)a2 > 0x3FF);
      }
    }
    else
    {
      if (a2 <= -3066)
        v6 = -3066;
      else
        v6 = a2;
      do
      {
        a2 = v6 + 1022;
        result = result * 2.22507386e-308;
        v7 = __CFADD__(v6, 2044);
        v6 += 1022;
      }
      while (!v7);
    }
    return result * COERCE_DOUBLE(((a2 << 52) + 0x3FF0000000000000) & 0x7FF0000000000000);
  }
  return result;
}

double _stdlib_squareRoot(double a1)
{
  return sqrt(a1);
}

uint64_t type metadata accessor for UnsafeMutableBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for UnsafeMutableBufferPointer);
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error)(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  result = (*(uint64_t (**)(void))(v3 + 40))();
  if (v4)
    *a3 = v4;
  return result;
}

uint64_t type metadata accessor for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD2);
}

unint64_t *specialized static _UInt128.-= infix(_:_:)(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  int v7;
  unint64_t v8;

  v4 = *result;
  v3 = result[1];
  v5 = v3 >= a3;
  v6 = v3 - a3;
  v7 = !v5;
  v5 = v4 >= a2;
  v8 = v4 - a2;
  if (v5)
  {
    if (v7)
      goto LABEL_8;
  }
  else
  {
    if (!v6)
      LOBYTE(v7) = 1;
    if ((v7 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x65uLL, 0);
    --v6;
  }
  *result = v8;
  result[1] = v6;
  return result;
}

unint64_t *specialized static _UInt128.*= infix(_:_:)(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  BOOL v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  int v12;
  BOOL v13;

  v3 = *result;
  v4 = result[1];
  v5 = !is_mul_ok(v4, a2);
  v6 = !is_mul_ok(*result, a3);
  v7 = v4 * a2 + *result * a3;
  v8 = __CFADD__(v4 * a2, *result * a3);
  v9 = (v3 * (unsigned __int128)a2) >> 64;
  v10 = __CFADD__(v7, v9);
  v11 = v7 + v9;
  v12 = v10;
  if (a3)
    v13 = v4 == 0;
  else
    v13 = 1;
  if (!v13 || v5 || v6 || v8 || v12)
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in *=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0xA9uLL, 0);
  *result = v3 * a2;
  result[1] = v11;
  return result;
}

Swift::UInt64 specialized static _UInt128./= infix(_:_:)(Swift::UInt64 *a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 result;
  char v6;
  Swift::UInt64 v7;
  Swift::UInt64 v8;
  Swift::tuple_high_UInt64_low_UInt64 v9;

  if (!(a3 | a2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1CEuLL, 0);
  v9.low = a1[1];
  v9.high = (Swift::UInt64)&v6;
  result = specialized _wideDivide22<A>(_:by:)(&v8, &v7, v9, *a1, a3, a2);
  *a1 = v8;
  a1[1] = result;
  return result;
}

Swift::UInt64 specialized static _UInt128.%= infix(_:_:)(Swift::UInt64 *a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 result;
  Swift::UInt64 v6;
  Swift::UInt64 v7;
  Swift::UInt64 v8;
  Swift::UInt64 v9;
  Swift::tuple_high_UInt64_low_UInt64 v10;

  if (!(a3 | a2))
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in %=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1DCuLL, 0);
  v10.low = a1[1];
  v10.high = (Swift::UInt64)&v7;
  result = specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, *a1, a3, a2);
  v6 = v8;
  *a1 = v7;
  a1[1] = v6;
  return result;
}

unint64_t *specialized static _Int128.-= infix(_:_:)(unint64_t *result, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  int v7;
  BOOL v8;
  unint64_t v9;

  v4 = *result;
  v3 = result[1];
  v5 = __OFSUB__(v3, a3);
  v6 = v3 - a3;
  v7 = v5;
  v8 = v4 >= a2;
  v9 = v4 - a2;
  if (v8)
  {
    if (v7)
      goto LABEL_8;
  }
  else
  {
    if (v6 == 0x8000000000000000)
      LOBYTE(v7) = 1;
    if ((v7 & 1) != 0)
LABEL_8:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x258uLL, 0);
    --v6;
  }
  *result = v9;
  result[1] = v6;
  return result;
}

uint64_t type metadata accessor for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD4);
}

uint64_t specialized SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  const char *v8;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v11)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  void (*v15)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  unint64_t *v17;
  unint64_t *v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v21 = a3;
  v22 = a4;
  v4 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v20 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  v8 = *(const char **)(v7 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v4, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v11 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v11(0, v12, AssociatedConformanceWitness);
  v13 = swift_getAssociatedTypeWitness(255, v8, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  v14 = swift_getAssociatedConformanceWitness((uint64_t)v8, v4, v13, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v15 = *(void (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
  v16 = swift_checkMetadataState(0, v13);
  v15(v6, v21, v16, v14);
  v17 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v11(1, v17, AssociatedConformanceWitness);
  v18 = swift_checkMetadataState(0, v13);
  return ((uint64_t (*)(char *, uint64_t, unint64_t *, unint64_t))v15)(v6, v22, v18, v14);
}

uint64_t type metadata accessor for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD8);
}

uint64_t specialized SIMD8.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  const char *v10;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  void (*v13)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  void (*v17)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v18;
  unint64_t *v19;
  unint64_t *v20;
  unint64_t *v21;
  unint64_t *v22;
  unint64_t *v23;
  unint64_t *v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v29 = a5;
  v30 = a6;
  v27 = a3;
  v28 = a4;
  v6 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v8 = (char *)&v26 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10 = *(const char **)(v9 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v13 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v14 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v13(0, v14, AssociatedConformanceWitness);
  v15 = swift_getAssociatedTypeWitness(255, v10, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  v16 = swift_getAssociatedConformanceWitness((uint64_t)v10, v6, v15, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v17 = *(void (**)(char *, uint64_t, unint64_t *, unint64_t))(v16 + 64);
  v18 = swift_checkMetadataState(0, v15);
  v17(v8, v27, v18, v16);
  v19 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v13(1, v19, AssociatedConformanceWitness);
  v20 = swift_checkMetadataState(0, v15);
  v17(v8, v28, v20, v16);
  v21 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v13(2, v21, AssociatedConformanceWitness);
  v22 = swift_checkMetadataState(0, v15);
  v17(v8, v29, v22, v16);
  v23 = swift_checkMetadataState(0, AssociatedTypeWitness);
  v13(3, v23, AssociatedConformanceWitness);
  v24 = swift_checkMetadataState(0, v15);
  return ((uint64_t (*)(char *, uint64_t, unint64_t *, unint64_t))v17)(v8, v30, v24, v16);
}

uint64_t specialized SIMD16.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  void (*v9)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t (*v13)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v14;
  uint64_t result;
  uint64_t v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;

  v18 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v16 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v8 = 0;
  v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v10 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v9(v8, v10, AssociatedConformanceWitness);
    v11 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    v12 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    v13 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v12 + 64);
    v14 = swift_checkMetadataState(0, v11);
    result = v13(v4, v8++, v14, v12);
  }
  while (v8 != 8);
  return result;
}

uint64_t type metadata accessor for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD16);
}

uint64_t specialized SIMD16.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t (*v14)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t result;
  uint64_t v17;

  v17 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v9 = 0;
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v11 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v10(v9, v11, AssociatedConformanceWitness);
    v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    v14 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v13 + 64);
    v15 = swift_checkMetadataState(0, v12);
    result = v14(v4, v9 + 8, v15, v13);
    ++v9;
  }
  while (v9 != 8);
  return result;
}

uint64_t specialized SIMD16.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t (*v15)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;
  unint64_t AssociatedTypeWitness;
  uint64_t v20;

  v20 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v8 = 0;
  v9 = 0;
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v11 = v9 + 1;
    v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v10(v9, v12, AssociatedConformanceWitness);
    v13 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    v14 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v13, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    v16 = swift_checkMetadataState(0, v13);
    result = v15(v4, v8, v16, v14);
    v8 += 2;
    v9 = v11;
  }
  while (v11 != 8);
  return result;
}

uint64_t specialized SIMD16.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  void (*v9)(uint64_t, unint64_t *, unint64_t);
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t (*v15)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;
  unint64_t AssociatedTypeWitness;
  uint64_t v20;

  v20 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v8 = 0;
  v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v10 = 1;
  do
  {
    v11 = v8 + 1;
    v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v9(v8, v12, AssociatedConformanceWitness);
    v13 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    v14 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v13, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    v16 = swift_checkMetadataState(0, v13);
    result = v15(v4, v10, v16, v14);
    v10 += 2;
    v8 = v11;
  }
  while (v11 != 8);
  return result;
}

uint64_t specialized SIMD32.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  void (*v9)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t (*v13)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v14;
  uint64_t result;
  uint64_t v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;

  v18 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v16 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v8 = 0;
  v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v10 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v9(v8, v10, AssociatedConformanceWitness);
    v11 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    v12 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    v13 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v12 + 64);
    v14 = swift_checkMetadataState(0, v11);
    result = v13(v4, v8++, v14, v12);
  }
  while (v8 != 16);
  return result;
}

uint64_t type metadata accessor for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD32);
}

uint64_t specialized SIMD32.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t (*v14)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t result;
  uint64_t v17;

  v17 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v9 = 0;
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v11 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v10(v9, v11, AssociatedConformanceWitness);
    v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    v14 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v13 + 64);
    v15 = swift_checkMetadataState(0, v12);
    result = v14(v4, v9 + 16, v15, v13);
    ++v9;
  }
  while (v9 != 16);
  return result;
}

uint64_t specialized SIMD32.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t (*v15)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;
  unint64_t AssociatedTypeWitness;
  uint64_t v20;

  v20 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v8 = 0;
  v9 = 0;
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v11 = v9 + 1;
    v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v10(v9, v12, AssociatedConformanceWitness);
    v13 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    v14 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v13, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    v16 = swift_checkMetadataState(0, v13);
    result = v15(v4, v8, v16, v14);
    v8 += 2;
    v9 = v11;
  }
  while (v11 != 16);
  return result;
}

uint64_t specialized SIMD32.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  void (*v9)(uint64_t, unint64_t *, unint64_t);
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t (*v15)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;
  unint64_t AssociatedTypeWitness;
  uint64_t v20;

  v20 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v8 = 0;
  v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v10 = 1;
  do
  {
    v11 = v8 + 1;
    v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v9(v8, v12, AssociatedConformanceWitness);
    v13 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    v14 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v13, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    v16 = swift_checkMetadataState(0, v13);
    result = v15(v4, v10, v16, v14);
    v10 += 2;
    v8 = v11;
  }
  while (v11 != 16);
  return result;
}

uint64_t specialized SIMD64.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  void (*v9)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t (*v13)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v14;
  uint64_t result;
  uint64_t v16;
  unint64_t AssociatedTypeWitness;
  uint64_t v18;

  v18 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v16 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v8 = 0;
  v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v10 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v9(v8, v10, AssociatedConformanceWitness);
    v11 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    v12 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v13 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v12 + 64);
    v14 = swift_checkMetadataState(0, v11);
    result = v13(v4, v8++, v14, v12);
  }
  while (v8 != 32);
  return result;
}

uint64_t type metadata accessor for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD64);
}

uint64_t specialized SIMD64.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;
  uint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t (*v14)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v15;
  uint64_t result;
  uint64_t v17;

  v17 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v9 = 0;
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v11 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v10(v9, v11, AssociatedConformanceWitness);
    v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v14 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v13 + 64);
    v15 = swift_checkMetadataState(0, v12);
    result = v14(v4, v9 + 32, v15, v13);
    ++v9;
  }
  while (v9 != 32);
  return result;
}

uint64_t specialized SIMD64.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, unint64_t *, unint64_t);
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t (*v15)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;
  unint64_t AssociatedTypeWitness;
  uint64_t v20;

  v20 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v8 = 0;
  v9 = 0;
  v10 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    v11 = v9 + 1;
    v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v10(v9, v12, AssociatedConformanceWitness);
    v13 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    v14 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v13, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    v16 = swift_checkMetadataState(0, v13);
    result = v15(v4, v8, v16, v14);
    v8 += 2;
    v9 = v11;
  }
  while (v11 != 32);
  return result;
}

uint64_t specialized SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  const char *v6;
  unint64_t AssociatedConformanceWitness;
  uint64_t v8;
  void (*v9)(uint64_t, unint64_t *, unint64_t);
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t (*v15)(char *, uint64_t, unint64_t *, unint64_t);
  unint64_t *v16;
  uint64_t result;
  uint64_t v18;
  unint64_t AssociatedTypeWitness;
  uint64_t v20;

  v20 = a1;
  v2 = *(_QWORD *)(a2 + 16);
  MEMORY[0x1E0C80A78](a1);
  v4 = (char *)&v18 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(const char **)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v8 = 0;
  v9 = *(void (**)(uint64_t, unint64_t *, unint64_t))(AssociatedConformanceWitness + 56);
  v10 = 1;
  do
  {
    v11 = v8 + 1;
    v12 = swift_checkMetadataState(0, AssociatedTypeWitness);
    v9(v8, v12, AssociatedConformanceWitness);
    v13 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    v14 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, v13, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v15 = *(uint64_t (**)(char *, uint64_t, unint64_t *, unint64_t))(v14 + 64);
    v16 = swift_checkMetadataState(0, v13);
    result = v15(v4, v10, v16, v14);
    v10 += 2;
    v8 = v11;
  }
  while (v11 != 32);
  return result;
}

uint64_t type metadata accessor for SIMD3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for SIMD3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in EnumeratedSequence<A>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EnumeratedSequence<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for _ArrayBuffer<A>, (uint64_t)&protocol conformance descriptor for _ArrayBuffer<A>);
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _ArrayBuffer<A>()
{
  return &protocol witness table for Int;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for IndexingIterator<A>, a1, a3);
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _ArrayBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for [A], (uint64_t)&protocol conformance descriptor for [A]);
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for [A], a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for [A], a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for [A], a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <A> [A](uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <A> [A], a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in ArraySlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for ArraySlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for ArraySlice<A>, (uint64_t)&protocol conformance descriptor for ArraySlice<A>);
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> ArraySlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <A> ArraySlice<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>;
  if (!lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, &unk_1E0EAAC88, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser;
  if (!lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.ASCII.Parser, &type metadata for Unicode.ASCII.Parser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.ASCII and conformance Unicode.ASCII(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII;
  if (!lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.ASCII, &type metadata for Unicode.ASCII, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UnsafeBitset()
{
  return &protocol witness table for _UnsafeBitset.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UnsafeBitset.Word()
{
  return &protocol witness table for _UnsafeBitset.Word;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByBooleanLiteral.BooleanLiteralType : _ExpressibleByBuiltinBooleanLiteral in Bool()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in AutoreleasingUnsafeMutablePointer<A>()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in Character()
{
  return &protocol witness table for Character;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in Character()
{
  return &protocol witness table for Character;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(&lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>, (uint64_t)&protocol conformance descriptor for <> Range<A>, a3);
}

unint64_t lazy protocol witness table accessor for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, &unk_1E0EAAC48, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, &unk_1E0EAAC48, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, &unk_1E0EAAC48, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _CocoaArrayWrapper, &type metadata for _CocoaArrayWrapper, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _CocoaArrayWrapper, &type metadata for _CocoaArrayWrapper, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _CocoaArrayWrapper, &type metadata for _CocoaArrayWrapper, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(&lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>, (uint64_t)&protocol conformance descriptor for <> Range<A>, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(&lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>, (uint64_t)&protocol conformance descriptor for <> Range<A>, a3);
}

uint64_t lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  _QWORD v6[2];

  result = *a1;
  if (!result)
  {
    v6[0] = &protocol witness table for Int;
    v6[1] = lazy protocol witness table accessor for type Int and conformance Int(0, a2, a3);
    result = swift_getWitnessTable(a2, &unk_1E0EAAE60, v6);
    atomic_store(result, a1);
  }
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _CocoaArrayWrapper()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<_CocoaArrayWrapper>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in ContiguousArray<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for ContiguousArray<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for ContiguousArray<A>, (uint64_t)&protocol conformance descriptor for ContiguousArray<A>);
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> ContiguousArray<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <A> ContiguousArray<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for RangeExpression.Bound : Comparable in ClosedRange<A>(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 24);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> ClosedRange<A>()
{
  return &protocol witness table for ClosedRange<A><>.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in <> ClosedRange<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> ClosedRange<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <> ClosedRange<A>(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t result;
  __int128 v5;

  v5 = *a3;
  result = swift_getWitnessTable(&protocol conformance descriptor for <> ClosedRange<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;

  v5 = *a3;
  result = swift_getWitnessTable(&protocol conformance descriptor for <> ClosedRange<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;

  v5 = *a3;
  result = swift_getWitnessTable(&protocol conformance descriptor for <> ClosedRange<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> ClosedRange<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> ClosedRange<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> ClosedRange<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> ClosedRange<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t instantiation function for generic protocol witness table for _ContiguousArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for _ContiguousArrayBuffer<A>, (uint64_t)&protocol conformance descriptor for _ContiguousArrayBuffer<A>);
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in __CocoaDictionary()
{
  return &protocol witness table for __CocoaDictionary.Iterator;
}

uint64_t instantiation function for generic protocol witness table for <> DiscontiguousSlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> DiscontiguousSlice<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in DiscontiguousSlice<A>()
{
  return &protocol witness table for DiscontiguousSlice<A>.Index;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in DiscontiguousSlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for DiscontiguousSlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for DiscontiguousSlice<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> DiscontiguousSlice<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> DiscontiguousSlice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DiscontiguousSlice<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyDropWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyDropWhileSequence<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for LazyDropWhileSequence<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyDropWhileSequence<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyDropWhileSequence<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyDropWhileSequence<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyDropWhileSequence<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyDropWhileSequence<A>, (uint64_t)&protocol conformance descriptor for LazyDropWhileSequence<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in EmptyCollection<A>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in EmptyCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for EmptyCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in EmptyCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in EmptyCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in EmptyCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in AnyIterator<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyIterator<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in AnyCollection<A>()
{
  return &protocol witness table for AnyIndex;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for AnyCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for AnyCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in AnyBidirectionalCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in AnyBidirectionalCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyBidirectionalCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyBidirectionalCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyBidirectionalCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in AnyRandomAccessCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in AnyRandomAccessCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyRandomAccessCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in AnyRandomAccessCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in AnyRandomAccessCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyRandomAccessCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyFilterSequence<A>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection, (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for LazyFilterSequence<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyFilterSequence<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyFilterSequence<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>, (uint64_t)&protocol conformance descriptor for LazyFilterSequence<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection, (uint64_t)&protocol conformance descriptor for <> LazyFilterSequence<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in FlattenSequence<A>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for FlattenSequence<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> FlattenSequence<A>()
{
  return &protocol witness table for FlattenSequence<A><>.Index;
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for FlattenSequence<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> FlattenSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> FlattenSequence<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> FlattenSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> FlattenSequence<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t WitnessTable;
  int8x16_t v9;

  v9 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  WitnessTable = swift_getWitnessTable(a4, a2, &v9);
  return swift_getWitnessTable(a5, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return instantiation function for generic protocol witness table for <> FlattenSequence<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> FlattenSequence<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _HashTable()
{
  return &protocol witness table for _HashTable.Iterator;
}

unint64_t associated type witness table accessor for Collection.Index : Comparable in DefaultIndices<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
}

uint64_t instantiation function for generic protocol witness table for DefaultIndices<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> DefaultIndices<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> DefaultIndices<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for DefaultIndices<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> DefaultIndices<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in JoinedSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for JoinedSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in KeyValuePairs<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for KeyValuePairs<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in KeyValuePairs<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

unint64_t associated type witness table accessor for Collection.Index : Comparable in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a3 - 8), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Index: Comparable);
}

unint64_t associated type witness table accessor for Collection.Indices : Collection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a3 - 8), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Indices: Collection);
}

uint64_t instantiation function for generic protocol witness table for <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for LazySequence<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> LazySequence<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> LazySequence<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_QWORD *)(a3 - 8);
}

uint64_t instantiation function for generic protocol witness table for <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazySequence<A>, (uint64_t)&protocol conformance descriptor for LazySequence<A>);
}

unint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a3 - 8), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.Indices: BidirectionalCollection);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazySequence<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a3 - 8), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.Indices: RandomAccessCollection);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazySequence<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in <> Slice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in <> ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a1, a3);
}

unint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazySequence<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Sequence, (uint64_t)&associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyMapSequence<A, B>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.SubSequence: Collection, (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for LazyMapSequence<A, B>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, (uint64_t)&associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection, (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyMapSequence<A, B>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>, (uint64_t)&protocol conformance descriptor for LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, (uint64_t)&associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection, (uint64_t)&protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t AssociatedConformanceWitness;

  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(*(_QWORD *)(a3 - 8), *(_QWORD *)(a2 + 16), *(_QWORD *)(a1 + 16), a4, a5);
  return swift_getWitnessTable(a6, a1, &AssociatedConformanceWitness);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in Unicode.Scalar()
{
  return &protocol witness table for Unicode.Scalar;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF16View, &type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF16View, &type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF16View, &type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF16View, &type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.Scalar.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Unicode.Scalar.UTF16View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Unicode.Scalar.UTF16View>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF8View, &type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF8View, &type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF8View, &type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.Scalar.UTF8View, &type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.Scalar.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Unicode.Scalar.UTF8View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Unicode.Scalar.UTF8View>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _NativeDictionary<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _NativeDictionary<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _NativeSet<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _NativeSet<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <A> A?(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <A> A?, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Identifiable.ID : Hashable in Never()
{
  return &protocol witness table for Never;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyPrefixWhileSequence<A>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyPrefixWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyPrefixWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for LazyPrefixWhileSequence<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> LazyPrefixWhileSequence<A>()
{
  return &protocol witness table for LazyPrefixWhileSequence<A><>.Index;
}

uint64_t instantiation function for generic protocol witness table for <> LazyPrefixWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for LazyPrefixWhileSequence<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyPrefixWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyPrefixWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, (uint64_t)&protocol conformance descriptor for LazyPrefixWhileSequence<A>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  v10 = *a3;
  *(_QWORD *)(a1 + 8) = swift_getWitnessTable(a4, a2, &v10);
  result = swift_getWitnessTable(a5, a2, v8);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyPrefixWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyPrefixWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> Range<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4;

  v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> Range<A>(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t result;
  __int128 v5;

  v5 = *a3;
  result = swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;

  v5 = *a3;
  result = swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  __int128 v5;

  v5 = *a3;
  result = swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> Range<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4;

  v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> Range<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4;

  v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Range<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in <> PartialRangeFrom<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for PartialRangeFrom<A><>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for RangeSet<A>.Ranges(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in RangeSet<A>.Ranges(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in RangeSet<A>.Ranges(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Repeated<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for Repeated<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Repeated<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for Repeated<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> Result<A, B>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return instantiation function for generic protocol witness table for <> FlattenSequence<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> Result<A, B>);
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t result;
  _QWORD v7[2];

  v5 = *(_QWORD *)(a3[1] + 8);
  v7[0] = *(_QWORD *)(*a3 + 8);
  v7[1] = v5;
  result = swift_getWitnessTable(a4, a2, v7);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in ReversedCollection<A>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in ReversedCollection<A>()
{
  return &protocol witness table for ReversedCollection<A>.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> ReversedCollection<A>, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for <> ReversedCollection<A>, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t WitnessTable;
  uint64_t v9;

  v9 = *(_QWORD *)(a3 - 8);
  WitnessTable = swift_getWitnessTable(a4, a2, &v9);
  return swift_getWitnessTable(a5, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> ReversedCollection<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in PrefixSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for PrefixSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in DropWhileSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for DropWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in IteratorSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for IteratorSequence<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Set<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Set<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in Set<A>()
{
  return &protocol witness table for Set<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for Set<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for Set<A>, a2, a3);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in __CocoaSet()
{
  return &protocol witness table for __CocoaSet.Iterator;
}

unint64_t associated type witness table accessor for Collection.Indices : Collection in Slice<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, (uint64_t)&associated conformance descriptor for Collection.Collection.Indices: Collection);
}

uint64_t instantiation function for generic protocol witness table for Slice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> Slice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t instantiation function for generic protocol witness table for <> Slice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for Slice<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in <> Slice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> Slice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in <> Slice<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a3 - 8);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

unint64_t lazy protocol witness table accessor for type _SmallString and conformance _SmallString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SmallString, &type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SmallString, &type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SmallString, &type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SmallString, &type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _SmallString, &type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for _SmallString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _SmallString()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<_SmallString> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<_SmallString>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringLiteral.StringLiteralType : _ExpressibleByBuiltinStringLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in StrideTo<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for StrideToIterator<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in StrideThrough<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for StrideThroughIterator<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringLiteral.StringLiteralType : _ExpressibleByBuiltinStringLiteral in String()
{
  return &protocol witness table for String;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in String()
{
  return &protocol witness table for String;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in String()
{
  return &protocol witness table for String;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String>, (uint64_t (*)(void))lazy protocol witness table accessor for type String and conformance String, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type String and conformance String(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String and conformance String;
  if (!lazy protocol witness table cache variable for type String and conformance String)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String, &type metadata for String, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String and conformance String);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String and conformance String;
  if (!lazy protocol witness table cache variable for type String and conformance String)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String, &type metadata for String, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String and conformance String);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Substring and conformance Substring(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring, &type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type String and conformance String(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type String and conformance String(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in String()
{
  return &protocol witness table for String.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String>, (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String()
{
  return &protocol witness table for String.Iterator;
}

unint64_t lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View;
  if (!lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String.UTF16View, &type metadata for String.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View;
  if (!lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String.UTF16View, &type metadata for String.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String.UTF8View, &type metadata for String.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String.UTF8View, &type metadata for String.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String.UTF8View, &type metadata for String.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String.UnicodeScalarView, &type metadata for String.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for String.UnicodeScalarView, &type metadata for String.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringInterpolation.StringInterpolation : StringInterpolationProtocol in String()
{
  return &protocol witness table for DefaultStringInterpolation;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UnicodeScalarView> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UnicodeScalarView>, (uint64_t (*)(void))lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UnicodeScalarView, &type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UnicodeScalarView, &type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UnicodeScalarView, &type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UnicodeScalarView, &type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UnicodeScalarView> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UnicodeScalarView>, (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UnicodeScalarView()
{
  return &protocol witness table for String.UnicodeScalarView.Iterator;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF16View> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF16View>, (uint64_t (*)(void))lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UTF16View, &type metadata for Substring.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UTF16View, &type metadata for Substring.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UTF16View, &type metadata for Substring.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF16View> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF16View>, (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UTF16View()
{
  return &protocol witness table for String.UTF16View.Iterator;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF8View> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF8View>, (uint64_t (*)(void))lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UTF8View, &type metadata for Substring.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UTF8View, &type metadata for Substring.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Substring.UTF8View, &type metadata for Substring.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF8View> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF8View>, (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<String.UTF8View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<String.UTF8View>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in Substring()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<Substring> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<Substring>, (uint64_t (*)(void))lazy protocol witness table accessor for type Substring and conformance Substring, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in Substring()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<Substring> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<Substring>, (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring.UTF8View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring.UTF8View>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring.UTF16View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring.UTF16View>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring.UnicodeScalarView> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring.UnicodeScalarView>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UIntBuffer<A>.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _UIntBuffer<A>()
{
  return &protocol witness table for _UIntBuffer<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in _UIntBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._NFD()
{
  return &protocol witness table for Unicode._NFD.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._NFC()
{
  return &protocol witness table for Unicode._NFC.Iterator;
}

_UNKNOWN **_sSPyxGSxsRi_zrl6StrideSx_s13SignedNumericPWT()
{
  return &protocol witness table for Int;
}

unint64_t lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _ValidUTF8Buffer, &type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _ValidUTF8Buffer, &type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _ValidUTF8Buffer, &type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for _ValidUTF8Buffer, &type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF8.ReverseParser, &type metadata for Unicode.UTF8.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF8.ReverseParser, &type metadata for Unicode.UTF8.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8 and conformance Unicode.UTF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF8, &type metadata for Unicode.UTF8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8);
  }
  return result;
}

uint64_t associated type witness table accessor for _UnicodeEncoding.EncodedScalar : BidirectionalCollection in Unicode.UTF16()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type _UIntBuffer<UInt16> and conformance _UIntBuffer<A>, &demangling cache variable for type metadata for _UIntBuffer<UInt16>, (uint64_t)&protocol conformance descriptor for _UIntBuffer<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF16.ReverseParser, &type metadata for Unicode.UTF16.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF16.ReverseParser, &type metadata for Unicode.UTF16.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16 and conformance Unicode.UTF16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF16, &type metadata for Unicode.UTF16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>;
  if (!lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, &unk_1E0EAABB8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF32.Parser, &type metadata for Unicode.UTF32.Parser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF32 and conformance Unicode.UTF32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32;
  if (!lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Unicode.UTF32, &type metadata for Unicode.UTF32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.UTF8 and conformance Unicode.UTF8(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.UTF16 and conformance Unicode.UTF16(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Unicode.UTF32 and conformance Unicode.UTF32(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _ValidUTF8Buffer.Iterator()
{
  return &protocol witness table for _ValidUTF8Buffer.Iterator;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _ValidUTF8Buffer()
{
  return &protocol witness table for _ValidUTF8Buffer.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>, (uint64_t)&protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for _ValidUTF8Buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, (uint64_t)&protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in CollectionDifference<A>()
{
  return &protocol witness table for CollectionDifference<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for CollectionDifference<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> CollectionDifference<A>.Change(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <A> CollectionDifference<A>.Change, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> CollectionDifference<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  result = swift_getWitnessTable(&protocol conformance descriptor for <A> CollectionDifference<A>, a2, &v5);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for CollectionOfOne<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int128()
{
  return &protocol witness table for Int128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Int128()
{
  return &protocol witness table for UInt128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Int128()
{
  return &protocol witness table for UInt128;
}

unint64_t lazy protocol witness table accessor for type UInt128 and conformance UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt128, &type metadata for UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt128, &type metadata for UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt128, &type metadata for UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt128.Words, &type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt128.Words, &type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt128.Words, &type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt128.Words, &type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Int128 and conformance Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int128 and conformance Int128;
  if (!lazy protocol witness table cache variable for type Int128 and conformance Int128)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int128, &type metadata for Int128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int128 and conformance Int128);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int128 and conformance Int128(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for _SliceBuffer<A>, (uint64_t)&protocol conformance descriptor for _SliceBuffer<A>);
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for _ArrayBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t result;

  *(_QWORD *)(a1 + 8) = swift_getWitnessTable(a4, a2, a3);
  result = swift_getWitnessTable(a5, a2, v8);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in StaticBigInt()
{
  return &protocol witness table for StaticBigInt;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt128()
{
  return &protocol witness table for UInt128;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt128.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt128.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt128.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt128 and conformance UInt128(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnfoldSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for UnfoldSequence<A, B>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Zip2Sequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for Zip2Sequence<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : FixedWidthInteger in SIMDMask<A>(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 32);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : SignedInteger in SIMDMask<A>(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 40);
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

unint64_t instantiation function for generic protocol witness table for Float16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Float16 and conformance Float16(a1, a2, a3);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Float16 and conformance Float16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Float16 and conformance Float16;
  if (!lazy protocol witness table cache variable for type Float16 and conformance Float16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Float16, &type metadata for Float16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Float16 and conformance Float16);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Float16()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Float16()
{
  return &protocol witness table for Float16;
}

unint64_t instantiation function for generic protocol witness table for Float(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Float and conformance Float(a1, a2, a3);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Float and conformance Float(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Float and conformance Float;
  if (!lazy protocol witness table cache variable for type Float and conformance Float)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Float, &type metadata for Float, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Float and conformance Float);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Float()
{
  return &protocol witness table for Float;
}

unint64_t instantiation function for generic protocol witness table for Double(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Double and conformance Double(a1, a2, a3);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Double and conformance Double(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Double and conformance Double;
  if (!lazy protocol witness table cache variable for type Double and conformance Double)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Double, &type metadata for Double, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Double and conformance Double);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Double()
{
  return &protocol witness table for Double;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt8.Words, &type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt8.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt8.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt8.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt8 and conformance UInt8(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt8()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt8()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt8()
{
  return &protocol witness table for UInt8;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8.Words, &type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int8.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int8.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int8.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int8 and conformance Int8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int8, &type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int8 and conformance Int8(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int8()
{
  return &protocol witness table for Int8;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16.Words, &type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16.Words, &type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16.Words, &type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt16.Words, &type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt16.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt16.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt16.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt16 and conformance UInt16(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt16()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt16()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt16()
{
  return &protocol witness table for UInt16;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16.Words, &type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int16.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int16.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int16.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int16 and conformance Int16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int16, &type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int16 and conformance Int16(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int16()
{
  return &protocol witness table for Int16;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt32.Words, &type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt32.Words, &type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt32.Words, &type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt32.Words, &type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt32.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt32.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt32.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt32()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt32()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt32()
{
  return &protocol witness table for UInt32;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32.Words, &type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int32.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int32.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int32.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int32 and conformance Int32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int32, &type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int32 and conformance Int32(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int32()
{
  return &protocol witness table for Int32;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt64.Words, &type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt64.Words, &type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt64.Words, &type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt64.Words, &type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt64.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt64.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt64.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt64 and conformance UInt64(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt64()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt64()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt64()
{
  return &protocol witness table for UInt64;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int64.Words, &type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int64.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int64.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int64.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Int64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int64 and conformance Int64(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UInt.Words, &type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UInt and conformance UInt(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt()
{
  return &protocol witness table for UInt;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int.Words and conformance Int.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int.Words and conformance Int.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for Int.Words, &type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int.Words and conformance Int.Words, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int.Words>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int.Words>, (uint64_t)&protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Int(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int()
{
  return &protocol witness table for Int;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for UnsafeBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable;

  WitnessTable = swift_getWitnessTable(&protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &WitnessTable);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnsafeMutableRawBufferPointer()
{
  return &protocol witness table for UnsafeRawBufferPointer.Iterator;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableRawBufferPointer, &type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableRawBufferPointer, &type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableRawBufferPointer, &type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeMutableRawBufferPointer, &type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for UnsafeMutableRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>, (uint64_t)&protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeRawBufferPointer, &type metadata for UnsafeRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeRawBufferPointer, &type metadata for UnsafeRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    result = swift_getWitnessTable(&protocol conformance descriptor for UnsafeRawBufferPointer, &type metadata for UnsafeRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UnsafeRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;

  result = lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  result = lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer, (uint64_t)&protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD2<A>, a1, a3);
}

unint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : FixedWidthInteger in SIMD2<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMDMaskScalar: FixedWidthInteger);
}

unint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : SignedInteger in SIMD2<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMDMaskScalar: SignedInteger);
}

uint64_t instantiation function for generic protocol witness table for SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD2<A>, (uint64_t)&protocol conformance descriptor for SIMD2<A>);
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(a1, a2, a3, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Decodable);
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Encodable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(a1, a2, a3, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Encodable);
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Hashable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(a1, a2, a3, (uint64_t)&associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD4<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD4<A>, (uint64_t)&protocol conformance descriptor for SIMD4<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD8<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD8<A>, (uint64_t)&protocol conformance descriptor for SIMD8<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD16<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD16<A>, (uint64_t)&protocol conformance descriptor for SIMD16<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD32<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD32<A>, (uint64_t)&protocol conformance descriptor for SIMD32<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD64<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD64<A>, (uint64_t)&protocol conformance descriptor for SIMD64<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD3<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for SIMD3<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD3<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, (uint64_t)&protocol conformance descriptor for SIMD3<A>, (uint64_t)&protocol conformance descriptor for SIMD3<A>);
}

uint64_t instantiation function for generic protocol witness table for SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t result;

  *(_QWORD *)(a1 + 32) = swift_getWitnessTable(a4, a2, a3);
  result = swift_getWitnessTable(a5, a2, v8);
  *(_QWORD *)(a1 + 48) = result;
  return result;
}

unint64_t associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const char *v6;
  unint64_t AssociatedTypeWitness;
  unint64_t AssociatedConformanceWitness;

  v6 = *(const char **)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, a1, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, (uint64_t)&associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  return swift_getAssociatedConformanceWitness(AssociatedConformanceWitness, AssociatedTypeWitness, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, a4);
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

__int16 **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD8Storage;
}

uint64_t sub_1815B892C()
{
  return 8;
}

_QWORD *sub_1815B8938(_QWORD *result, _QWORD *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_1815B8944()
{
  return 8;
}

uint64_t sub_1815B8950()
{
  return 8;
}

uint64_t sub_1815B895C()
{
  return 8;
}

uint64_t sub_1815B8968()
{
  return 8;
}

uint64_t sub_1815B8974()
{
  return 8;
}

uint64_t sub_1815B8980()
{
  return 8;
}

uint64_t sub_1815B898C()
{
  return 8;
}

uint64_t sub_1815B8998()
{
  return 8;
}

uint64_t sub_1815B89A4()
{
  return 8;
}

uint64_t sub_1815B89B0()
{
  return 8;
}

uint64_t sub_1815B89BC()
{
  return 8;
}

uint64_t sub_1815B89C8()
{
  return 8;
}

uint64_t sub_1815B89D4()
{
  return 8;
}

uint64_t sub_1815B89E0()
{
  return 8;
}

uint64_t sub_1815B89EC()
{
  return 24;
}

__n128 sub_1815B89F8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8A0C()
{
  return 24;
}

__n128 sub_1815B8A18(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8A2C()
{
  return 24;
}

__n128 sub_1815B8A38(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8A4C()
{
  return 24;
}

__n128 sub_1815B8A58(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8A6C()
{
  return 24;
}

__n128 sub_1815B8A78(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8A8C()
{
  return 24;
}

__n128 sub_1815B8A98(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8AAC()
{
  return 24;
}

__n128 sub_1815B8AB8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8ACC()
{
  return 16;
}

__n128 sub_1815B8AD8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8AE4()
{
  return 8;
}

uint64_t sub_1815B8AF0()
{
  return 8;
}

uint64_t sub_1815B8AFC()
{
  return 16;
}

__n128 sub_1815B8B08(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8B14()
{
  return 16;
}

__n128 sub_1815B8B20(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8B2C()
{
  return 16;
}

__n128 sub_1815B8B38(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8B44()
{
  return 16;
}

__n128 sub_1815B8B50(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8B5C()
{
  return 24;
}

__n128 sub_1815B8B68(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_1815B8B7C()
{
  return 32;
}

__n128 sub_1815B8B88(uint64_t a1, _OWORD *a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

uint64_t sub_1815B8B94()
{
  return 16;
}

__n128 sub_1815B8BA0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8BAC()
{
  return 16;
}

__n128 sub_1815B8BB8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8BC4()
{
  return 16;
}

__n128 sub_1815B8BD0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8BDC()
{
  return 16;
}

__n128 sub_1815B8BE8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8BF4()
{
  return 16;
}

__n128 sub_1815B8C00(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8C0C()
{
  return 0;
}

uint64_t sub_1815B8C1C()
{
  return 0;
}

uint64_t sub_1815B8C2C()
{
  return 8;
}

uint64_t sub_1815B8C38()
{
  return 8;
}

uint64_t sub_1815B8C44()
{
  return 8;
}

uint64_t sub_1815B8C50()
{
  return 8;
}

uint64_t sub_1815B8C5C()
{
  return 8;
}

uint64_t sub_1815B8C68()
{
  return 8;
}

uint64_t sub_1815B8C74()
{
  return 8;
}

uint64_t sub_1815B8C80()
{
  return 8;
}

uint64_t sub_1815B8C8C()
{
  return 8;
}

uint64_t sub_1815B8C98()
{
  return 32;
}

__n128 sub_1815B8CA4(uint64_t a1, _OWORD *a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a1;
  v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

uint64_t sub_1815B8CB0()
{
  return 8;
}

uint64_t sub_1815B8CBC()
{
  return 8;
}

uint64_t sub_1815B8CC8()
{
  return 8;
}

uint64_t sub_1815B8CD4()
{
  return 0;
}

uint64_t sub_1815B8CE4()
{
  return 0;
}

uint64_t sub_1815B8CF4()
{
  return 0;
}

uint64_t sub_1815B8D04()
{
  return 0;
}

uint64_t sub_1815B8D14()
{
  return 16;
}

__n128 sub_1815B8D20(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8D2C()
{
  return 16;
}

__n128 sub_1815B8D38(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8D44()
{
  return 16;
}

__n128 sub_1815B8D50(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8D5C()
{
  return 16;
}

__n128 sub_1815B8D68(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8D74()
{
  return 16;
}

__n128 sub_1815B8D80(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8D8C()
{
  return 16;
}

__n128 sub_1815B8D98(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8DA4()
{
  return 16;
}

__n128 sub_1815B8DB0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8DBC()
{
  return 16;
}

__n128 sub_1815B8DC8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8DD4()
{
  return 16;
}

__n128 sub_1815B8DE0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8DEC()
{
  return 16;
}

__n128 sub_1815B8DF8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8E04()
{
  return 16;
}

__n128 sub_1815B8E10(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8E1C()
{
  return 16;
}

__n128 sub_1815B8E28(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8E34()
{
  return 16;
}

__n128 sub_1815B8E40(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8E4C()
{
  return 16;
}

__n128 sub_1815B8E58(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8E64()
{
  return 16;
}

__n128 sub_1815B8E70(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8E7C()
{
  return 16;
}

__n128 sub_1815B8E88(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8E94()
{
  return 16;
}

__n128 sub_1815B8EA0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8EAC()
{
  return 16;
}

__n128 sub_1815B8EB8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8EC4()
{
  return 16;
}

__n128 sub_1815B8ED0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8EDC()
{
  return 16;
}

__n128 sub_1815B8EE8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8EF4()
{
  return 16;
}

__n128 sub_1815B8F00(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8F0C()
{
  return 16;
}

__n128 sub_1815B8F18(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8F24()
{
  return 16;
}

__n128 sub_1815B8F30(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8F3C()
{
  return 16;
}

__n128 sub_1815B8F48(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8F54()
{
  return 16;
}

__n128 sub_1815B8F60(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8F6C()
{
  return 16;
}

__n128 sub_1815B8F78(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8F84()
{
  return 16;
}

__n128 sub_1815B8F90(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8F9C()
{
  return 16;
}

__n128 sub_1815B8FA8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8FB4()
{
  return 16;
}

__n128 sub_1815B8FC0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8FCC()
{
  return 16;
}

__n128 sub_1815B8FD8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8FE4()
{
  return 16;
}

__n128 sub_1815B8FF0(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B8FFC()
{
  return 16;
}

__n128 sub_1815B9008(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B9014()
{
  return 16;
}

__n128 sub_1815B9020(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B902C()
{
  return 16;
}

__n128 sub_1815B9038(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B9044()
{
  return 16;
}

__n128 sub_1815B9050(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B905C()
{
  return 16;
}

__n128 sub_1815B9068(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815B9074()
{
  return 0;
}

uint64_t sub_1815B9084()
{
  return 0;
}

uint64_t sub_1815B9094()
{
  return 0;
}

uint64_t sub_1815B90A4()
{
  return 0;
}

uint64_t sub_1815B90B4()
{
  return 0;
}

uint64_t sub_1815B90C4()
{
  return 0;
}

uint64_t sub_1815B90D4()
{
  return 0;
}

uint64_t sub_1815B90E4()
{
  return 0;
}

uint64_t sub_1815B90F4()
{
  return 0;
}

uint64_t sub_1815B9104()
{
  return 0;
}

uint64_t sub_1815B9114()
{
  return 0;
}

uint64_t sub_1815B9124()
{
  return 0;
}

uint64_t sub_1815B9134()
{
  return 0;
}

uint64_t sub_1815B9144()
{
  return 0;
}

uint64_t sub_1815B9154()
{
  return 0;
}

uint64_t sub_1815B9164()
{
  return 0;
}

uint64_t sub_1815B9174()
{
  return 0;
}

uint64_t sub_1815B9184()
{
  return 0;
}

uint64_t sub_1815B9194()
{
  return 0;
}

uint64_t sub_1815B91A4()
{
  return 0;
}

uint64_t sub_1815B91B4()
{
  return 0;
}

uint64_t sub_1815B91C4()
{
  return 0;
}

uint64_t sub_1815B91D4()
{
  return 0;
}

uint64_t sub_1815B91E4()
{
  return 0;
}

uint64_t sub_1815B91F4()
{
  return 0;
}

uint64_t sub_1815B9204()
{
  return 0;
}

uint64_t sub_1815B9214()
{
  return 0;
}

uint64_t sub_1815B9224()
{
  return 0;
}

uint64_t sub_1815B9234()
{
  return 0;
}

uint64_t sub_1815B9244()
{
  return 0;
}

uint64_t sub_1815B9254()
{
  return 0;
}

uint64_t sub_1815B9264()
{
  return 0;
}

uint64_t sub_1815B9274()
{
  return 0;
}

uint64_t sub_1815B9284()
{
  return 0;
}

uint64_t sub_1815B9294()
{
  return 0;
}

uint64_t sub_1815B92A4()
{
  return 0;
}

uint64_t sub_1815B92B4()
{
  return 0;
}

uint64_t sub_1815B92C4()
{
  return 0;
}

uint64_t sub_1815B92D4()
{
  return 0;
}

uint64_t sub_1815B92E4()
{
  return 0;
}

uint64_t sub_1815B92F4()
{
  return 0;
}

uint64_t sub_1815B9304()
{
  return 0;
}

uint64_t sub_1815B9314()
{
  return 0;
}

uint64_t sub_1815B9324()
{
  return 0;
}

uint64_t sub_1815B9334()
{
  return 0;
}

uint64_t sub_1815B9344()
{
  return 0;
}

uint64_t sub_1815B9354()
{
  return 0;
}

uint64_t sub_1815B9364()
{
  return 0;
}

uint64_t sub_1815B9374()
{
  return 0;
}

uint64_t sub_1815B9384()
{
  return 0;
}

uint64_t sub_1815B9394()
{
  return 0;
}

uint64_t sub_1815B93A4()
{
  return 0;
}

uint64_t sub_1815B93B4()
{
  return 0;
}

uint64_t sub_1815B93C4()
{
  return 0;
}

uint64_t sub_1815B93D4()
{
  return 0;
}

uint64_t sub_1815B93E4()
{
  return 0;
}

uint64_t sub_1815B93F4()
{
  return 0;
}

uint64_t sub_1815B9404()
{
  return 0;
}

uint64_t sub_1815B9414()
{
  return 0;
}

uint64_t sub_1815B9424()
{
  return 0;
}

uint64_t sub_1815B9434()
{
  return 0;
}

uint64_t sub_1815B9444()
{
  return 0;
}

uint64_t sub_1815B9454()
{
  return 0;
}

uint64_t sub_1815B9464()
{
  return 0;
}

uint64_t sub_1815B9474()
{
  return 0;
}

uint64_t sub_1815B9484()
{
  return 0;
}

uint64_t sub_1815B9494()
{
  return 0;
}

uint64_t sub_1815B94A4()
{
  return 0;
}

uint64_t sub_1815B94B4()
{
  return 0;
}

uint64_t sub_1815B94C4()
{
  return 0;
}

uint64_t sub_1815B94D4()
{
  return 0;
}

uint64_t sub_1815B94E4()
{
  return 0;
}

uint64_t sub_1815B94F4()
{
  return 0;
}

uint64_t sub_1815B9504()
{
  return 0;
}

uint64_t sub_1815B9514()
{
  return 0;
}

uint64_t sub_1815B9524()
{
  return 0;
}

uint64_t sub_1815B9534()
{
  return 0;
}

uint64_t sub_1815B9544()
{
  return 0;
}

uint64_t type metadata instantiation function for EnumeratedSequence(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x20);
}

unint64_t type metadata completion function for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, (uint64_t)&value witness table for Builtin.Int64.size);
}

unint64_t **initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator(unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t destroy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

void storeEnumTagSinglePayload for EnumeratedSequence.Iterator(unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  storeEnumTagSinglePayload for EnumeratedSequence.Iterator(a1, a2, a3, a4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

ValueMetadata *type metadata accessor for _ArrayBody()
{
  return &type metadata for _ArrayBody;
}

uint64_t type metadata instantiation function for _ArrayBuffer(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x18);
}

uint64_t dispatch thunk of _ArrayBufferProtocol.init(_buffer:shiftedToStartIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.init(copying:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.requestNativeBuffer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void))(a8 + 80))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 96))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 104))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.count.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.count.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.subscriptBaseAddress.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.identity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

ValueMetadata *type metadata accessor for _DependenceToken()
{
  return &type metadata for _DependenceToken;
}

__n128 __swift_memcpy32_8(_OWORD *a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t assignWithTake for ArraySlice(uint64_t a1, _OWORD *a2)
{
  __int128 v4;

  swift_unknownObjectRelease(*(id *)a1);
  v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  return a1;
}

uint64_t dispatch thunk of _ArrayProtocol._owner.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of _ArrayProtocol.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

ValueMetadata *type metadata accessor for Unicode.ASCII()
{
  return &type metadata for Unicode.ASCII;
}

ValueMetadata *type metadata accessor for Unicode.ASCII.Parser()
{
  return &type metadata for Unicode.ASCII.Parser;
}

uint64_t default associated conformance accessor for BidirectionalCollection.Collection.Indices: BidirectionalCollection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> DefaultIndices<A>, a1, &v4);
}

uint64_t default associated conformance accessor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  return swift_getWitnessTable(&protocol conformance descriptor for <> Slice<A>, a1, &v4);
}

uint64_t dispatch thunk of BidirectionalCollection.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of BidirectionalCollection.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of BidirectionalCollection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of BidirectionalCollection.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 56))();
}

uint64_t dispatch thunk of BidirectionalCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

ValueMetadata *type metadata accessor for _UnsafeBitset()
{
  return &type metadata for _UnsafeBitset;
}

ValueMetadata *type metadata accessor for _UnsafeBitset.Iterator()
{
  return &type metadata for _UnsafeBitset.Iterator;
}

ValueMetadata *type metadata accessor for _UnsafeBitset.Word()
{
  return &type metadata for _UnsafeBitset.Word;
}

_BYTE *__swift_memcpy1_1(_BYTE *result, _BYTE *a2)
{
  *result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for Bool()
{
  return &type metadata for Bool;
}

uint64_t dispatch thunk of static _ObjectiveCBridgeable._unconditionallyBridgeFromObjectiveC(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

_QWORD *__swift_memcpy8_8(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for _BridgeableMetatype()
{
  return &type metadata for _BridgeableMetatype;
}

uint64_t type metadata accessor for _BridgeStorage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _BridgeStorage);
}

_QWORD *initializeBufferWithCopyOfBuffer for Character(_QWORD *a1, _QWORD *a2, uint64_t a3, char *a4)
{
  unint64_t v5;

  v5 = a2[1];
  *a1 = *a2;
  a1[1] = v5;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  return a1;
}

void destroy for Character(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
}

_QWORD *assignWithTake for Character(_QWORD *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = a2[1];
  v4 = a1[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

ValueMetadata *type metadata accessor for Character()
{
  return &type metadata for Character;
}

ValueMetadata *type metadata accessor for _CocoaArrayWrapper()
{
  return &type metadata for _CocoaArrayWrapper;
}

uint64_t dispatch thunk of Encodable.encode(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of Decodable.init(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of CodingKey.stringValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of CodingKey.intValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of CodingKey.init(intValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of Encoder.container<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of Encoder.unkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Encoder.singleValueContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of Decoder.container<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of Decoder.unkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Decoder.singleValueContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeNil(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

{
  return (*(uint64_t (**)(void))(a4 + 120))();
}

{
  return (*(uint64_t (**)(void))(a4 + 128))();
}

{
  return (*(uint64_t (**)(void))(a4 + 136))();
}

{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

{
  return (*(uint64_t (**)(void))(a5 + 112))();
}

{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 168))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeConditional<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 176))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 184))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 192))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a5 + 200))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a5 + 216))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a5 + 248))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a5 + 264))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a5 + 296))(a1, a2 & 1);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(unint64_t))(a4 + 208))(a1 | ((HIDWORD(a1) & 1) << 32));
}

{
  return (*(uint64_t (**)(unint64_t))(a4 + 240))(a1 | ((HIDWORD(a1) & 1) << 32));
}

{
  return (*(uint64_t (**)(unint64_t))(a4 + 288))(a1 | ((HIDWORD(a1) & 1) << 32));
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD))(a4 + 224))(a1 & 0x1FF);
}

{
  return (*(uint64_t (**)(_QWORD))(a4 + 272))(a1 & 0x1FF);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD))(a4 + 232))(a1 & 0x1FFFF);
}

{
  return (*(uint64_t (**)(_QWORD))(a4 + 280))(a1 & 0x1FFFF);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a6 + 256))(a1, a2, a3 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a6 + 304))(a1, a2, a3 & 1);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 312))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 320))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.nestedUnkeyedContainer(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 328))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.superEncoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 336))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.superEncoder(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 344))();
}

uint64_t type metadata accessor for KeyedEncodingContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for KeyedEncodingContainer);
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeNil(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))() & 1;
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))() & 1;
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

{
  return (*(uint64_t (**)(void))(a3 + 152))();
}

{
  return (*(uint64_t (**)(void))(a3 + 160))();
}

{
  return (*(uint64_t (**)(void))(a3 + 168))();
}

{
  return (*(uint64_t (**)(void))(a3 + 176))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decode<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 184))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 192))();
}

{
  return (*(uint64_t (**)(void))(a3 + 200))();
}

{
  return (*(uint64_t (**)(void))(a3 + 208))();
}

{
  unint64_t v3;

  v3 = (*(uint64_t (**)(void))(a3 + 216))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 224))();
}

{
  return (*(uint64_t (**)(void))(a3 + 232))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a3 + 240))() & 0x1FFFF;
}

{
  unint64_t v3;

  v3 = (*(uint64_t (**)(void))(a3 + 248))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 256))();
}

{
  return (*(uint64_t (**)(void))(a3 + 264))();
}

{
  return (*(uint64_t (**)(void))(a3 + 272))();
}

{
  return (*(uint64_t (**)(void))(a3 + 280))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a3 + 288))() & 0x1FFFF;
}

{
  unint64_t v3;

  v3 = (*(uint64_t (**)(void))(a3 + 296))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 304))();
}

{
  return (*(uint64_t (**)(void))(a3 + 312))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 320))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 328))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.nestedUnkeyedContainer(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 336))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.superDecoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 344))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.superDecoder(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 352))();
}

uint64_t type metadata accessor for KeyedDecodingContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for KeyedDecodingContainer);
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encodeConditional<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 168))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 176))();
}

{
  return (*(uint64_t (**)(void))(a5 + 184))();
}

{
  return (*(uint64_t (**)(void))(a5 + 192))();
}

{
  return (*(uint64_t (**)(void))(a5 + 200))();
}

{
  return (*(uint64_t (**)(void))(a5 + 208))();
}

{
  return (*(uint64_t (**)(void))(a5 + 216))();
}

{
  return (*(uint64_t (**)(void))(a5 + 224))();
}

{
  return (*(uint64_t (**)(void))(a5 + 232))();
}

{
  return (*(uint64_t (**)(void))(a5 + 240))();
}

{
  return (*(uint64_t (**)(void))(a5 + 248))();
}

{
  return (*(uint64_t (**)(void))(a5 + 256))();
}

{
  return (*(uint64_t (**)(void))(a5 + 264))();
}

{
  return (*(uint64_t (**)(void))(a5 + 272))();
}

{
  return (*(uint64_t (**)(void))(a5 + 280))();
}

{
  return (*(uint64_t (**)(void))(a5 + 288))();
}

{
  return (*(uint64_t (**)(void))(a5 + 296))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 304))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.nestedContainer<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 312))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.nestedUnkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 320))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.superEncoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.isAtEnd.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.currentIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))() & 1;
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))() & 1;
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 176))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeIfPresent(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 184))();
}

{
  return (*(uint64_t (**)(void))(a2 + 192))();
}

{
  return (*(uint64_t (**)(void))(a2 + 200))();
}

{
  unint64_t v2;

  v2 = (*(uint64_t (**)(void))(a2 + 208))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 216))();
}

{
  return (*(uint64_t (**)(void))(a2 + 224))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a2 + 232))() & 0x1FFFF;
}

{
  unint64_t v2;

  v2 = (*(uint64_t (**)(void))(a2 + 240))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 248))();
}

{
  return (*(uint64_t (**)(void))(a2 + 256))();
}

{
  return (*(uint64_t (**)(void))(a2 + 264))();
}

{
  return (*(uint64_t (**)(void))(a2 + 272))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a2 + 280))() & 0x1FFFF;
}

{
  unint64_t v2;

  v2 = (*(uint64_t (**)(void))(a2 + 288))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 296))();
}

{
  return (*(uint64_t (**)(void))(a2 + 304))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeIfPresent<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 312))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.nestedContainer<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 320))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.nestedUnkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.superDecoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 336))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 152))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))() & 1;
}

{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 152))();
}

ValueMetadata *type metadata accessor for CodingUserInfoKey()
{
  return &type metadata for CodingUserInfoKey;
}

void destroy for EncodingError(uint64_t a1)
{
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 32));
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 48));
  swift_errorRelease(*(id *)(a1 + 56));
}

_QWORD *initializeWithCopy for EncodingError(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;

  v4 = a2[3];
  a1[3] = v4;
  (**(void (***)(void))(v4 - 8))();
  v5 = a2[4];
  v6 = a2[5];
  a1[4] = v5;
  a1[5] = v6;
  v8 = a2[6];
  v7 = (void *)a2[7];
  a1[6] = v8;
  swift_bridgeObjectRetain(v5, v9, v10, v11);
  swift_bridgeObjectRetain(v8, v12, v13, v14);
  swift_errorRetain(v7);
  a1[7] = v7;
  return a1;
}

uint64_t *assignWithCopy for EncodingError(uint64_t *a1, _QWORD *a2, uint64_t a3, char *a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  void *v16;
  void *v17;

  __swift_assign_boxed_opaque_existential_0(a1, (uint64_t)a2, a3, a4);
  v6 = a2[4];
  v7 = a1[4];
  a1[4] = v6;
  swift_bridgeObjectRetain(v6, v8, v9, v10);
  swift_bridgeObjectRelease(v7);
  a1[5] = a2[5];
  v11 = a2[6];
  v12 = a1[6];
  a1[6] = v11;
  swift_bridgeObjectRetain(v11, v13, v14, v15);
  swift_bridgeObjectRelease(v12);
  v16 = (void *)a1[7];
  v17 = (void *)a2[7];
  swift_errorRetain(v17);
  a1[7] = (uint64_t)v17;
  swift_errorRelease(v16);
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_0(uint64_t *result, uint64_t a2, uint64_t a3, char *a4)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  _BYTE v20[24];

  if (result != (uint64_t *)a2)
  {
    v5 = result;
    v6 = result[3];
    v7 = *(_QWORD *)(a2 + 24);
    if (v6 == v7)
    {
      v14 = *(_QWORD *)(v6 - 8);
      if ((*(_BYTE *)(v14 + 82) & 2) != 0)
      {
        v16 = *result;
        v17 = *(unint64_t **)a2;
        swift_retain(*(unint64_t **)a2, a2, a3, a4);
        result = (uint64_t *)swift_release(v16);
        *v5 = v17;
      }
      else
      {
        return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v14 + 24))(result, a2, result[3]);
      }
    }
    else
    {
      result[3] = v7;
      v8 = *(_QWORD *)(v6 - 8);
      v9 = *(_QWORD *)(v7 - 8);
      v10 = *(_DWORD *)(v9 + 80);
      if ((*(_BYTE *)(v8 + 82) & 2) != 0)
      {
        v15 = *result;
        if ((v10 & 0x20000) != 0)
        {
          v19 = *(unint64_t **)a2;
          *v5 = *(_QWORD *)a2;
          swift_retain(v19, a2, a3, a4);
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t))(v9 + 16))(result, a2, v7);
        }
        return (uint64_t *)swift_release(v15);
      }
      else
      {
        (*(void (**)(_BYTE *, uint64_t *, uint64_t))(v8 + 32))(v20, result, v6);
        if ((v10 & 0x20000) != 0)
        {
          v18 = *(unint64_t **)a2;
          *v5 = *(_QWORD *)a2;
          swift_retain(v18, v11, v12, v13);
        }
        else
        {
          (*(void (**)(_QWORD *, uint64_t, uint64_t))(v9 + 16))(v5, a2, v7);
        }
        return (uint64_t *)(*(uint64_t (**)(_BYTE *, uint64_t))(v8 + 8))(v20, v6);
      }
    }
  }
  return result;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for EncodingError(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  v5 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  swift_bridgeObjectRelease(v5);
  v6 = *(_QWORD *)(a2 + 48);
  v7 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v6;
  swift_bridgeObjectRelease(v7);
  v8 = *(void **)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  swift_errorRelease(v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for EncodingError(uint64_t a1, int a2)
{
  unint64_t v2;

  if (!a2)
    return 0;
  if (a2 < 0 && *(_BYTE *)(a1 + 64))
    return *(_DWORD *)a1 + 0x80000000;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF)
    LODWORD(v2) = -1;
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for EncodingError(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_QWORD *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_QWORD *)result = a2 ^ 0x80000000;
    if (a3 < 0)
      *(_BYTE *)(result + 64) = 1;
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2)
        return result;
LABEL_8:
      *(_QWORD *)(result + 24) = (a2 - 1);
      return result;
    }
    *(_BYTE *)(result + 64) = 0;
    if (a2)
      goto LABEL_8;
  }
  return result;
}

ValueMetadata *type metadata accessor for EncodingError()
{
  return &type metadata for EncodingError;
}

ValueMetadata *type metadata accessor for EncodingError.Context()
{
  return &type metadata for EncodingError.Context;
}

void destroy for DecodingError(uint64_t a1)
{
  int v2;
  id *v3;

  v2 = *(unsigned __int8 *)(a1 + 72);
  while (2)
  {
    switch(v2)
    {
      case 0:
      case 1:
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
        v3 = (id *)(a1 + 32);
        break;
      case 2:
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 40));
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 56));
        v3 = (id *)(a1 + 64);
        break;
      case 3:
        swift_bridgeObjectRelease(*(_QWORD *)a1);
        swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
        v3 = (id *)(a1 + 24);
        break;
      default:
        v2 = *(_DWORD *)a1 + 4;
        continue;
    }
    break;
  }
  swift_errorRelease(*v3);
}

uint64_t initializeWithCopy for DecodingError(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  int v6;
  unint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char v13;
  __int128 v14;
  unint64_t v15;
  uint64_t v16;
  void *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  void *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  unint64_t v32;
  unint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;

  v6 = *(unsigned __int8 *)(a2 + 72);
  while (2)
  {
    switch(v6)
    {
      case 0:
        v7 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)(a1 + 8) = v7;
        v8 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
        *(_QWORD *)(a1 + 24) = v8;
        v9 = *(void **)(a2 + 32);
        swift_bridgeObjectRetain(v7, a2, a3, a4);
        swift_bridgeObjectRetain(v8, v10, v11, v12);
        swift_errorRetain(v9);
        v13 = 0;
        *(_QWORD *)(a1 + 32) = v9;
        break;
      case 1:
        v32 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)(a1 + 8) = v32;
        v33 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
        *(_QWORD *)(a1 + 24) = v33;
        v34 = *(void **)(a2 + 32);
        swift_bridgeObjectRetain(v32, a2, a3, a4);
        swift_bridgeObjectRetain(v33, v35, v36, v37);
        swift_errorRetain(v34);
        *(_QWORD *)(a1 + 32) = v34;
        v13 = 1;
        break;
      case 2:
        v14 = *(_OWORD *)(a2 + 24);
        *(_OWORD *)(a1 + 24) = v14;
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        v15 = *(_QWORD *)(a2 + 40);
        v16 = *(_QWORD *)(a2 + 48);
        *(_QWORD *)(a1 + 40) = v15;
        *(_QWORD *)(a1 + 48) = v16;
        v18 = *(_QWORD *)(a2 + 56);
        v17 = *(void **)(a2 + 64);
        *(_QWORD *)(a1 + 56) = v18;
        swift_bridgeObjectRetain(v15, v19, v20, v21);
        swift_bridgeObjectRetain(v18, v22, v23, v24);
        swift_errorRetain(v17);
        *(_QWORD *)(a1 + 64) = v17;
        v13 = 2;
        break;
      case 3:
        v25 = *(_QWORD *)a2;
        v26 = *(_QWORD *)(a2 + 8);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)(a1 + 8) = v26;
        v28 = *(_QWORD *)(a2 + 16);
        v27 = *(void **)(a2 + 24);
        *(_QWORD *)(a1 + 16) = v28;
        swift_bridgeObjectRetain(v25, a2, a3, a4);
        swift_bridgeObjectRetain(v28, v29, v30, v31);
        swift_errorRetain(v27);
        *(_QWORD *)(a1 + 24) = v27;
        v13 = 3;
        break;
      default:
        v6 = *(_DWORD *)a2 + 4;
        continue;
    }
    break;
  }
  *(_BYTE *)(a1 + 72) = v13;
  return a1;
}

uint64_t assignWithCopy for DecodingError(uint64_t a1, uint64_t a2)
{
  int v4;
  id *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char v16;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  unint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;

  if (a1 != a2)
  {
    v4 = *(unsigned __int8 *)(a1 + 72);
    while (2)
    {
      switch(v4)
      {
        case 0:
        case 1:
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
          v5 = (id *)(a1 + 32);
          break;
        case 2:
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 40));
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 56));
          v5 = (id *)(a1 + 64);
          break;
        case 3:
          swift_bridgeObjectRelease(*(_QWORD *)a1);
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
          v5 = (id *)(a1 + 24);
          break;
        default:
          v4 = *(_DWORD *)a1 + 4;
          continue;
      }
      break;
    }
    swift_errorRelease(*v5);
    v9 = *(unsigned __int8 *)(a2 + 72);
    while (2)
    {
      switch(v9)
      {
        case 0:
          *(_QWORD *)a1 = *(_QWORD *)a2;
          v10 = *(_QWORD *)(a2 + 8);
          *(_QWORD *)(a1 + 8) = v10;
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
          v11 = *(_QWORD *)(a2 + 24);
          *(_QWORD *)(a1 + 24) = v11;
          v12 = *(void **)(a2 + 32);
          swift_bridgeObjectRetain(v10, v6, v7, v8);
          swift_bridgeObjectRetain(v11, v13, v14, v15);
          swift_errorRetain(v12);
          v16 = 0;
          *(_QWORD *)(a1 + 32) = v12;
          break;
        case 1:
          *(_QWORD *)a1 = *(_QWORD *)a2;
          v17 = *(_QWORD *)(a2 + 8);
          *(_QWORD *)(a1 + 8) = v17;
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
          v18 = *(_QWORD *)(a2 + 24);
          *(_QWORD *)(a1 + 24) = v18;
          v19 = *(void **)(a2 + 32);
          swift_bridgeObjectRetain(v17, v6, v7, v8);
          swift_bridgeObjectRetain(v18, v20, v21, v22);
          swift_errorRetain(v19);
          *(_QWORD *)(a1 + 32) = v19;
          v16 = 1;
          break;
        case 2:
          v23 = *(_QWORD *)(a2 + 24);
          *(_QWORD *)(a1 + 24) = v23;
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
          (**(void (***)(uint64_t, uint64_t))(v23 - 8))(a1, a2);
          v24 = *(_QWORD *)(a2 + 40);
          *(_QWORD *)(a1 + 40) = v24;
          *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
          v25 = *(_QWORD *)(a2 + 56);
          *(_QWORD *)(a1 + 56) = v25;
          v26 = *(void **)(a2 + 64);
          swift_bridgeObjectRetain(v24, v27, v28, v29);
          swift_bridgeObjectRetain(v25, v30, v31, v32);
          swift_errorRetain(v26);
          *(_QWORD *)(a1 + 64) = v26;
          v16 = 2;
          break;
        case 3:
          v33 = *(_QWORD *)a2;
          *(_QWORD *)a1 = *(_QWORD *)a2;
          *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
          v34 = *(_QWORD *)(a2 + 16);
          *(_QWORD *)(a1 + 16) = v34;
          v35 = *(void **)(a2 + 24);
          swift_bridgeObjectRetain(v33, v6, v7, v8);
          swift_bridgeObjectRetain(v34, v36, v37, v38);
          swift_errorRetain(v35);
          *(_QWORD *)(a1 + 24) = v35;
          v16 = 3;
          break;
        default:
          v9 = *(_DWORD *)a2 + 4;
          continue;
      }
      break;
    }
    *(_BYTE *)(a1 + 72) = v16;
  }
  return a1;
}

__n128 __swift_memcpy73_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_OWORD *)a1 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  v3 = *(_OWORD *)(a2 + 32);
  v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 57) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t assignWithTake for DecodingError(uint64_t a1, uint64_t a2)
{
  int v4;
  id *v5;
  int v6;
  char v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  if (a1 != a2)
  {
    v4 = *(unsigned __int8 *)(a1 + 72);
    while (2)
    {
      switch(v4)
      {
        case 0:
        case 1:
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 8));
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 24));
          v5 = (id *)(a1 + 32);
          break;
        case 2:
          __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 40));
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 56));
          v5 = (id *)(a1 + 64);
          break;
        case 3:
          swift_bridgeObjectRelease(*(_QWORD *)a1);
          swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
          v5 = (id *)(a1 + 24);
          break;
        default:
          v4 = *(_DWORD *)a1 + 4;
          continue;
      }
      break;
    }
    swift_errorRelease(*v5);
    v6 = *(unsigned __int8 *)(a2 + 72);
    while (2)
    {
      switch(v6)
      {
        case 0:
          v7 = 0;
          v8 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v8;
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
          break;
        case 1:
          v9 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v9;
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
          v7 = 1;
          break;
        case 2:
          v10 = *(_OWORD *)(a2 + 48);
          *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
          *(_OWORD *)(a1 + 48) = v10;
          *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
          v11 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v11;
          v7 = 2;
          break;
        case 3:
          v12 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v12;
          v7 = 3;
          break;
        default:
          v6 = *(_DWORD *)a2 + 4;
          continue;
      }
      break;
    }
    *(_BYTE *)(a1 + 72) = v7;
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for DecodingError(uint64_t a1, unsigned int a2)
{
  unsigned int v3;

  if (!a2)
    return 0;
  if (a2 >= 0xFD && *(_BYTE *)(a1 + 73))
    return (*(_DWORD *)a1 + 253);
  v3 = *(unsigned __int8 *)(a1 + 72);
  if (v3 >= 4)
    return (v3 ^ 0xFF) + 1;
  else
    return 0;
}

uint64_t storeEnumTagSinglePayload for DecodingError(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_OWORD *)(result + 57) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)result = a2 - 253;
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 73) = 1;
  }
  else
  {
    if (a3 >= 0xFD)
      *(_BYTE *)(result + 73) = 0;
    if (a2)
      *(_BYTE *)(result + 72) = -(char)a2;
  }
  return result;
}

uint64_t getEnumTag for DecodingError(uint64_t a1)
{
  uint64_t result;

  result = *(unsigned __int8 *)(a1 + 72);
  if (result >= 4)
    return (*(_DWORD *)a1 + 4);
  return result;
}

uint64_t destructiveInjectEnumTag for DecodingError(uint64_t result, unsigned int a2)
{
  if (a2 > 3)
  {
    *(_QWORD *)(result + 64) = 0;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)result = a2 - 4;
    LOBYTE(a2) = 4;
  }
  *(_BYTE *)(result + 72) = a2;
  return result;
}

ValueMetadata *type metadata accessor for DecodingError()
{
  return &type metadata for DecodingError;
}

void destroy for EncodingError.Context(uint64_t a1)
{
  swift_bridgeObjectRelease(*(_QWORD *)a1);
  swift_bridgeObjectRelease(*(_QWORD *)(a1 + 16));
  swift_errorRelease(*(id *)(a1 + 24));
}

unint64_t *initializeWithCopy for EncodingError.Context(unint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;

  v5 = *a2;
  v6 = a2[1];
  *a1 = *a2;
  a1[1] = v6;
  v7 = a2[2];
  v8 = (void *)a2[3];
  a1[2] = v7;
  swift_bridgeObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRetain(v7, v9, v10, v11);
  swift_errorRetain(v8);
  a1[3] = (unint64_t)v8;
  return a1;
}

uint64_t *assignWithCopy for EncodingError.Context(uint64_t *a1, unint64_t *a2, uint64_t a3, char *a4)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  void *v13;
  void *v14;

  v6 = *a2;
  v7 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v6, (uint64_t)a2, a3, a4);
  swift_bridgeObjectRelease(v7);
  a1[1] = a2[1];
  v8 = a2[2];
  v9 = a1[2];
  a1[2] = v8;
  swift_bridgeObjectRetain(v8, v10, v11, v12);
  swift_bridgeObjectRelease(v9);
  v13 = (void *)a1[3];
  v14 = (void *)a2[3];
  swift_errorRetain(v14);
  a1[3] = (uint64_t)v14;
  swift_errorRelease(v13);
  return a1;
}

uint64_t *assignWithTake for EncodingError.Context(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;

  v4 = *a1;
  *a1 = *(_QWORD *)a2;
  swift_bridgeObjectRelease(v4);
  a1[1] = *(_QWORD *)(a2 + 8);
  swift_bridgeObjectRelease(a1[2]);
  v5 = (void *)a1[3];
  *((_OWORD *)a1 + 1) = *(_OWORD *)(a2 + 16);
  swift_errorRelease(v5);
  return a1;
}

ValueMetadata *type metadata accessor for DecodingError.Context()
{
  return &type metadata for DecodingError.Context;
}

uint64_t type metadata accessor for _KeyedEncodingContainerBase()
{
  return objc_opt_self();
}

_QWORD *type metadata completion function for _KeyedEncodingContainerBox(uint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t v4;

  result = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 416));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 432);
    if (!result)
      return 0;
  }
  return result;
}

uint64_t type metadata accessor for _KeyedDecodingContainerBase()
{
  return objc_opt_self();
}

_QWORD *type metadata completion function for _KeyedDecodingContainerBox(uint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t v4;

  result = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 424));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 440);
    if (!result)
      return 0;
  }
  return result;
}

uint64_t dispatch thunk of CodingKeyRepresentable.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

unint64_t type metadata completion function for IndexingIterator(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t AssociatedTypeWitness;
  unint64_t v6;
  _QWORD v8[2];

  v2 = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 16));
  v3 = (unint64_t)v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 1) + 64;
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(319, *(const char **)(a1 + 24), (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    v3 = AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      v8[1] = *(_QWORD *)(AssociatedTypeWitness - 8) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, (char *)v8, a1 + 32);
      return 0;
    }
  }
  return v3;
}

unint64_t **initializeBufferWithCopyOfBuffer for IndexingIterator(unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(_QWORD *)(v6 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v12 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v13 = *(_DWORD *)(v12 + 80);
  v14 = v7 + v13;
  v15 = (*(_BYTE *)(v6 + 80) | *(_BYTE *)(v12 + 80));
  if (v15 > 7
    || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v12 + 80)) & 0x100000) != 0
    || (v14 & (unint64_t)~v13) + *(_QWORD *)(v12 + 64) > 0x18)
  {
    v18 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v18 + ((v15 + 16) & ~v15));
    swift_retain(v18, v9, v10, v11);
  }
  else
  {
    v19 = AssociatedTypeWitness;
    v20 = ~v13;
    (*(void (**)(unint64_t **, unint64_t **, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v12 + 16))(((unint64_t)a1 + v14) & v20, ((unint64_t)a2 + v14) & v20, v19);
  }
  return a1;
}

uint64_t destroy for IndexingIterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t AssociatedTypeWitness;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(v4 - 8);
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(a1, v4);
  v6 = *(_QWORD *)(v5 + 64) + a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a2 + 24), v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 8))((v6 + *(unsigned __int8 *)(*(_QWORD *)(AssociatedTypeWitness - 8) + 80)) & ~(unint64_t)*(unsigned __int8 *)(*(_QWORD *)(AssociatedTypeWitness - 8) + 80), AssociatedTypeWitness);
}

uint64_t initializeWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;

  v6 = *(_QWORD *)(a3 + 16);
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 16))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;

  v6 = *(_QWORD *)(a3 + 16);
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 24))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;

  v6 = *(_QWORD *)(a3 + 16);
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 32))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t AssociatedTypeWitness;
  uint64_t v10;

  v6 = *(_QWORD *)(a3 + 16);
  v7 = *(_QWORD *)(v6 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40))(a1, a2, v6);
  v8 = *(_QWORD *)(v7 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v10 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v10 + 40))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for IndexingIterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(_QWORD *)(v5 - 8);
  v7 = *(unsigned int *)(v6 + 84);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = *(unsigned int *)(v9 + 84);
  if (v10 <= v7)
    v11 = v7;
  else
    v11 = *(_DWORD *)(v9 + 84);
  if (!a2)
    return 0;
  v12 = *(unsigned __int8 *)(v9 + 80);
  v13 = *(_QWORD *)(v6 + 64) + v12;
  if (a2 <= v11)
    goto LABEL_23;
  v14 = (v13 & ~v12) + *(_QWORD *)(v9 + 64);
  v15 = 8 * v14;
  if (v14 <= 3)
  {
    v17 = ((a2 - v11 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      v16 = *(_DWORD *)(a1 + v14);
      if (!v16)
        goto LABEL_23;
      goto LABEL_14;
    }
    if (v17 > 0xFF)
    {
      v16 = *(unsigned __int16 *)(a1 + v14);
      if (!*(_WORD *)(a1 + v14))
        goto LABEL_23;
      goto LABEL_14;
    }
    if (v17 < 2)
    {
LABEL_23:
      if (v11)
      {
        if (v7 >= v10)
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(a1, v7, v5);
        else
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))((v13 + a1) & ~v12, v10, AssociatedTypeWitness);
      }
      return 0;
    }
  }
  v16 = *(unsigned __int8 *)(a1 + v14);
  if (!*(_BYTE *)(a1 + v14))
    goto LABEL_23;
LABEL_14:
  v18 = (v16 - 1) << v15;
  if (v14 > 3)
    v18 = 0;
  if ((_DWORD)v14)
  {
    if (v14 <= 3)
      v19 = v14;
    else
      v19 = 4;
    __asm { BR              X12 }
  }
  return v11 + v18 + 1;
}

void storeEnumTagSinglePayload for IndexingIterator(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  size_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;

  v7 = *(_QWORD *)(a4 + 16);
  v8 = *(_QWORD *)(v7 - 8);
  v9 = *(_DWORD *)(v8 + 84);
  v10 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, *(const char **)(a4 + 24), v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 8);
  if (*(_DWORD *)(v10 + 84) <= v9)
    v11 = v9;
  else
    v11 = *(_DWORD *)(v10 + 84);
  v12 = ((*(_QWORD *)(v8 + 64) + *(unsigned __int8 *)(v10 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80))
      + *(_QWORD *)(v10 + 64);
  if (a3 <= v11)
  {
    v13 = 0u;
  }
  else if (v12 <= 3)
  {
    v15 = ((a3 - v11 + ~(-1 << (8 * v12))) >> (8 * v12)) + 1;
    if (HIWORD(v15))
    {
      v13 = 4u;
    }
    else if (v15 >= 0x100)
    {
      v13 = 2;
    }
    else
    {
      v13 = v15 > 1;
    }
  }
  else
  {
    v13 = 1u;
  }
  if (v11 < a2)
  {
    v14 = ~v11 + a2;
    if (v12 < 4)
    {
      if ((_DWORD)v12)
      {
        v16 = v14 & ~(-1 << (8 * v12));
        bzero(a1, v12);
        if ((_DWORD)v12 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }
        else if ((_DWORD)v12 == 2)
        {
          *(_WORD *)a1 = v16;
        }
        else
        {
          *a1 = v16;
        }
      }
    }
    else
    {
      bzero(a1, v12);
      *(_DWORD *)a1 = v14;
    }
    __asm { BR              X10 }
  }
  __asm { BR              X13 }
}

uint64_t dispatch thunk of Collection.startIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of Collection.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of Collection.subscript.read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

uint64_t dispatch thunk of Collection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

uint64_t dispatch thunk of Collection.indices.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of Collection.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of Collection.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of Collection._customIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of Collection._customLastIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

uint64_t dispatch thunk of Collection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 136))();
}

uint64_t dispatch thunk of Collection.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 144))();
}

uint64_t dispatch thunk of Collection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of Collection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 160))();
}

{
  return (*(uint64_t (**)(void))(a4 + 168))();
}

{
  return (*(uint64_t (**)(void))(a4 + 176))();
}

uint64_t dispatch thunk of Collection.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 184))();
}

uint64_t dispatch thunk of Collection.formIndex(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 192))();
}

uint64_t dispatch thunk of static Comparable.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t dispatch thunk of static Comparable.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of static Comparable.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static Comparable.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of RawRepresentable.init(rawValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of RawRepresentable.rawValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t default associated conformance accessor for CaseIterable.CaseIterable.AllCases: Collection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(&protocol conformance descriptor for [A], a1, a3);
}

uint64_t dispatch thunk of ExpressibleByNilLiteral.init(nilLiteral:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of ExpressibleByFloatLiteral.init(floatLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinBooleanLiteral.init(_builtinBooleanLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

uint64_t dispatch thunk of ExpressibleByStringLiteral.init(stringLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of ExpressibleByArrayLiteral.init(arrayLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of ExpressibleByDictionaryLiteral.init(dictionaryLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of StringInterpolationProtocol.init(literalCapacity:interpolationCount:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of StringInterpolationProtocol.appendLiteral(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _ExpressibleByColorLiteral.init(_colorLiteralRed:green:blue:alpha:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByImageLiteral.init(imageLiteralResourceName:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t dispatch thunk of _HasContiguousBytes.withUnsafeBytes<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 8))();
}

uint64_t dispatch thunk of _HasContiguousBytes._providesContiguousBytesNoCopy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t getEnumTag for ClosedRange<>.Index(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 16) - 8) + 48))(a1, 1);
}

uint64_t destructiveInjectEnumTag for ClosedRange<>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a3 + 16) - 8) + 56))(a1, a2, 1);
}

uint64_t type metadata accessor for __EmptyArrayStorage()
{
  return objc_opt_self();
}

uint64_t method lookup function for __EmptyArrayStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __EmptyArrayStorage);
}

uint64_t dispatch thunk of __EmptyArrayStorage.__allocating_init(_doNotCallMe:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 144))();
}

uint64_t method lookup function for __StaticArrayStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __StaticArrayStorage);
}

swift *type metadata completion function for _ContiguousArrayStorage(uint64_t a1)
{
  _BYTE v2[8];

  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 152);
}

uint64_t initializeBufferWithCopyOfBuffer for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  unint64_t *v5;

  v5 = *(unint64_t **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_retain(v5, a2, a3, a4);
  return a1;
}

uint64_t *assignWithCopy for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, unint64_t **a2, uint64_t a3, char *a4)
{
  unint64_t *v6;
  uint64_t v7;

  v6 = *a2;
  v7 = *a1;
  *a1 = (uint64_t)*a2;
  swift_retain(v6, (uint64_t)a2, a3, a4);
  swift_release(v7);
  a1[1] = (uint64_t)a2[1];
  a1[2] = (uint64_t)a2[2];
  return a1;
}

__n128 __swift_memcpy24_8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

uint64_t *assignWithTake for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, uint64_t a2)
{
  swift_release(*a1);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(_QWORD *)(a2 + 16);
  return a1;
}

uint64_t type metadata accessor for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _UnsafePartiallyInitializedContiguousArrayBuffer);
}

ValueMetadata *type metadata accessor for OpaquePointer()
{
  return &type metadata for OpaquePointer;
}

ValueMetadata *type metadata accessor for CVaListPointer()
{
  return &type metadata for CVaListPointer;
}

ValueMetadata *type metadata accessor for _DebuggerSupport()
{
  return &type metadata for _DebuggerSupport;
}

uint64_t type metadata instantiation function for Dictionary(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x28);
}

uint64_t type metadata accessor for Dictionary.Values(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Values);
}

unint64_t *initializeBufferWithCopyOfBuffer for Dictionary.Keys.Iterator(unint64_t **a1, unint64_t **a2, uint64_t a3, char *a4)
{
  unint64_t *v4;
  unint64_t *v5;

  v4 = *a2;
  *a1 = *a2;
  v5 = v4 + 2;
  swift_retain(v4, (uint64_t)a2, a3, a4);
  return v5;
}

uint64_t destroy for Dictionary.Keys.Iterator(_QWORD *a1, uint64_t a2)
{
  return destroy for Dictionary.Keys.Iterator(a1, a2, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))outlined consume of [A : B].Iterator._Variant<A, B>);
}

_QWORD *initializeWithCopy for Dictionary.Keys.Iterator(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  return initializeWithCopy for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of [A : B].Iterator._Variant<A, B>);
}

uint64_t *assignWithCopy for Dictionary.Keys.Iterator(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of [A : B].Iterator._Variant<A, B>, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Iterator._Variant<A, B>);
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

_QWORD *assignWithTake for Dictionary.Keys.Iterator(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Iterator._Variant<A, B>);
}

uint64_t type metadata accessor for Dictionary.Keys.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Keys.Iterator);
}

uint64_t type metadata accessor for Dictionary.Values.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Values.Iterator);
}

ValueMetadata *type metadata accessor for _MergeError()
{
  return &type metadata for _MergeError;
}

uint64_t initializeBufferWithCopyOfBuffer for Dictionary.Index(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for Dictionary.Index(a1, a2, a3, (void (*)(_QWORD, uint64_t, uint64_t))outlined copy of [A : B].Index._Variant<A, B>);
}

uint64_t *assignWithCopy for Dictionary.Index(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Index(a1, a2, a3, (void (*)(_QWORD, uint64_t, uint64_t))outlined copy of [A : B].Index._Variant<A, B>, (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Index._Variant<A, B>);
}

__n128 __swift_memcpy17_8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

uint64_t *assignWithTake for Dictionary.Index(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Index(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Index._Variant<A, B>);
}

uint64_t type metadata accessor for Dictionary.Index(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Index, &flag for loading of canonical specialized generic type metadata for Dictionary.Index);
}

void destroy for Dictionary.Index._Variant(uint64_t a1)
{
  outlined consume of [A : B].Index._Variant<A, B>(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_BYTE *)(a1 + 16));
}

uint64_t getEnumTag for Dictionary.Index._Variant(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

uint64_t destructiveInjectEnumTag for Dictionary.Index._Variant(uint64_t result, char a2)
{
  *(_BYTE *)(result + 16) = a2 & 1;
  return result;
}

uint64_t type metadata accessor for Dictionary.Index._Variant(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for Dictionary.Index._Variant);
}

uint64_t type metadata accessor for Dictionary.Iterator(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Iterator, &flag for loading of canonical specialized generic type metadata for Dictionary.Iterator);
}

uint64_t getEnumTag for Dictionary.Iterator._Variant(_QWORD *a1)
{
  return *a1 >> 63;
}

_QWORD *destructiveProjectEnumData for Dictionary.Iterator._Variant(_QWORD *result)
{
  *result &= ~0x8000000000000000;
  return result;
}

uint64_t *destructiveInjectEnumTag for Dictionary.Iterator._Variant(uint64_t *result, uint64_t a2)
{
  *result = *result & 0xFFFFFFFFFFFFFF8 | (a2 << 63);
  return result;
}

swift *type metadata completion function for _SwiftDictionaryNSEnumerator(uint64_t a1)
{
  _QWORD v2[4];

  v2[0] = &unk_1E0EAFAA0;
  v2[1] = "\b";
  v2[2] = &value witness table for Builtin.Int64.size;
  v2[3] = &value witness table for Builtin.Int64.size;
  return swift_initClassMetadata2(a1, 0, 4uLL, (uint64_t)v2, a1 + 120);
}

uint64_t type metadata accessor for _SwiftDictionaryNSEnumerator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _SwiftDictionaryNSEnumerator);
}

swift *type metadata completion function for _SwiftDeferredNSDictionary(uint64_t a1)
{
  _QWORD v2[3];

  v2[0] = "\b";
  v2[1] = "\b";
  v2[2] = &unk_1E0EAFAA0;
  return swift_initClassMetadata2(a1, 0, 3uLL, (uint64_t)v2, a1 + 120);
}

ValueMetadata *type metadata accessor for __CocoaDictionary()
{
  return &type metadata for __CocoaDictionary;
}

ValueMetadata *type metadata accessor for __CocoaDictionary.Index()
{
  return &type metadata for __CocoaDictionary.Index;
}

uint64_t method lookup function for __CocoaDictionary.Iterator(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __CocoaDictionary.Iterator);
}

uint64_t type metadata accessor for _DictionaryBuilder(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _DictionaryBuilder);
}

uint64_t type metadata accessor for __RawDictionaryStorage()
{
  return objc_opt_self();
}

uint64_t method lookup function for __RawDictionaryStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __RawDictionaryStorage);
}

uint64_t type metadata accessor for __EmptyDictionarySingleton()
{
  return objc_opt_self();
}

uint64_t method lookup function for __EmptyDictionarySingleton(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for __EmptyDictionarySingleton);
}

swift *type metadata completion function for _DictionaryStorage(uint64_t a1)
{
  _BYTE v2[8];

  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 200);
}

uint64_t method lookup function for _DictionaryStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _DictionaryStorage);
}

unint64_t *type metadata completion function for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice(a1, a2, a3, (uint64_t)&unk_1E0EAFAA0);
}

unint64_t type metadata completion function for DiscontiguousSlice.Index(uint64_t a1)
{
  unint64_t result;
  unint64_t v3;
  _QWORD v4[2];

  v4[0] = &value witness table for Builtin.Int64.size;
  result = swift_getAssociatedTypeWitness(319, *(const char **)(a1 + 24), *(_QWORD *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    v4[1] = *(_QWORD *)(result - 8) + 64;
    swift_initStructMetadata(a1, 0, 2uLL, (char *)v4, a1 + 32);
    return 0;
  }
  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for DiscontiguousSlice.Index(unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v13;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = *(_DWORD *)(v9 + 80);
  if (v10 > 7
    || (*(_DWORD *)(v9 + 80) & 0x100000) != 0
    || ((v10 + 8) & (unint64_t)~v10) + *(_QWORD *)(v9 + 64) > 0x18)
  {
    v13 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v13 + ((v10 & 0xF8 ^ 0x1F8) & (v10 + 16)));
    swift_retain(v13, v6, v7, v8);
  }
  else
  {
    *a1 = *a2;
    (*(void (**)(unint64_t, unint64_t, unint64_t))(v9 + 16))(((unint64_t)a1 + v10 + 8) & ~v10, ((unint64_t)a2 + v10 + 8) & ~v10, AssociatedTypeWitness);
  }
  return a1;
}

uint64_t destroy for DiscontiguousSlice.Index(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a2 + 24), *(_QWORD *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  return (*(uint64_t (**)(unint64_t, unint64_t))(*(_QWORD *)(AssociatedTypeWitness - 8) + 8))((a1 + *(unsigned __int8 *)(*(_QWORD *)(AssociatedTypeWitness - 8) + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(_QWORD *)(AssociatedTypeWitness - 8) + 80), AssociatedTypeWitness);
}

_QWORD *initializeWithCopy for DiscontiguousSlice.Index(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;

  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 16))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

_QWORD *assignWithCopy for DiscontiguousSlice.Index(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;

  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 24))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

_QWORD *initializeWithTake for DiscontiguousSlice.Index(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;

  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 32))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

_QWORD *assignWithTake for DiscontiguousSlice.Index(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;

  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(unint64_t, unint64_t, unint64_t))(v6 + 40))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for DiscontiguousSlice.Index(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (!a2)
    return 0;
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v7 = *(unsigned int *)(v6 + 84);
  v8 = *(unsigned __int8 *)(v6 + 80);
  if (a2 <= v7)
    goto LABEL_20;
  v9 = ((v8 + 8) & ~v8) + *(_QWORD *)(v6 + 64);
  v10 = 8 * v9;
  if (v9 <= 3)
  {
    v12 = ((a2 - v7 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      v11 = *(_DWORD *)(a1 + v9);
      if (!v11)
        goto LABEL_20;
      goto LABEL_11;
    }
    if (v12 > 0xFF)
    {
      v11 = *(unsigned __int16 *)(a1 + v9);
      if (!*(_WORD *)(a1 + v9))
        goto LABEL_20;
      goto LABEL_11;
    }
    if (v12 < 2)
    {
LABEL_20:
      if ((_DWORD)v7)
        return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v6 + 48))((a1 + v8 + 8) & ~v8, v7, AssociatedTypeWitness);
      return 0;
    }
  }
  v11 = *(unsigned __int8 *)(a1 + v9);
  if (!*(_BYTE *)(a1 + v9))
    goto LABEL_20;
LABEL_11:
  v13 = (v11 - 1) << v10;
  if (v9 > 3)
    v13 = 0;
  if ((_DWORD)v9)
  {
    if (v9 <= 3)
      v14 = v9;
    else
      v14 = 4;
    __asm { BR              X11 }
  }
  return (v7 + v13 + 1);
}

void storeEnumTagSinglePayload for DiscontiguousSlice.Index(_BYTE *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  size_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;

  v7 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, *(const char **)(a4 + 24), *(_QWORD *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 8);
  v8 = *(_DWORD *)(v7 + 84);
  v9 = ((*(unsigned __int8 *)(v7 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80)) + *(_QWORD *)(v7 + 64);
  if (a3 <= v8)
  {
    v10 = 0u;
  }
  else if (v9 <= 3)
  {
    v12 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
    if (HIWORD(v12))
    {
      v10 = 4u;
    }
    else if (v12 >= 0x100)
    {
      v10 = 2;
    }
    else
    {
      v10 = v12 > 1;
    }
  }
  else
  {
    v10 = 1u;
  }
  if (v8 < a2)
  {
    v11 = ~v8 + a2;
    if (v9 < 4)
    {
      if ((_DWORD)v9)
      {
        v13 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if ((_DWORD)v9 == 3)
        {
          *(_WORD *)a1 = v13;
          a1[2] = BYTE2(v13);
        }
        else if ((_DWORD)v9 == 2)
        {
          *(_WORD *)a1 = v13;
        }
        else
        {
          *a1 = v13;
        }
      }
    }
    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
    }
    __asm { BR              X10 }
  }
  __asm { BR              X13 }
}

unint64_t *type metadata completion function for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice(a1, a2, a3, (uint64_t)&unk_1E0EB0CD8);
}

uint64_t type metadata instantiation function for EmptyCollection(_DWORD *a1, const char *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, (char *)0x10);
}

uint64_t type metadata accessor for EmptyCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for EmptyCollection.Iterator);
}

uint64_t dispatch thunk of static Equatable.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t type metadata accessor for AnyIterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnyIterator);
}

_QWORD *initializeBufferWithCopyOfBuffer for _ClosureBasedIterator(_QWORD *a1, _QWORD *a2, uint64_t a3, char *a4)
{
  unint64_t *v5;

  v5 = (unint64_t *)a2[1];
  *a1 = *a2;
  a1[1] = v5;
  swift_retain(v5, (uint64_t)a2, a3, a4);
  return a1;
}

uint64_t destroy for _ClosureBasedIterator(uint64_t a1)
{
  return swift_release(*(_QWORD *)(a1 + 8));
}

uint64_t assignWithTake for _ClosureBasedIterator(uint64_t a1, _OWORD *a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)a1 = *a2;
  swift_release(v3);
  return a1;
}

uint64_t type metadata accessor for _AnyIteratorBoxBase(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnyIteratorBoxBase);
}

uint64_t method lookup function for _AnyIteratorBoxBase(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnyIteratorBoxBase);
}

uint64_t dispatch thunk of _AnyIteratorBoxBase.next()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 96))();
}

_QWORD *type metadata completion function for _IteratorBox(uint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t v4;

  result = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 104));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 120);
    if (!result)
      return 0;
  }
  return result;
}

uint64_t method lookup function for _IteratorBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _IteratorBox);
}

uint64_t dispatch thunk of _IteratorBox.__allocating_init(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 128))();
}

swift *type metadata completion function for _AnyIteratorBoxBase(uint64_t a1)
{
  _BYTE v2[8];

  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 88);
}

uint64_t type metadata accessor for _AnySequenceBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnySequenceBox);
}

uint64_t method lookup function for _AnySequenceBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnySequenceBox);
}

uint64_t dispatch thunk of _AnySequenceBox.__allocating_init()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 88))();
}

uint64_t dispatch thunk of _AnySequenceBox._makeIterator()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 96))();
}

uint64_t dispatch thunk of _AnySequenceBox._underestimatedCount.getter()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 104))();
}

uint64_t dispatch thunk of _AnySequenceBox._map<A>(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 112))();
}

uint64_t dispatch thunk of _AnySequenceBox._filter(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 120))();
}

uint64_t dispatch thunk of _AnySequenceBox._forEach(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 128))();
}

uint64_t dispatch thunk of _AnySequenceBox.__customContainsEquatableElement(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 136))();
}

uint64_t dispatch thunk of _AnySequenceBox.__copyToContiguousArray()()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 144))();
}

uint64_t dispatch thunk of _AnySequenceBox.__copyContents(initializing:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 152))();
}

uint64_t dispatch thunk of _AnySequenceBox._drop(while:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 160))();
}

uint64_t dispatch thunk of _AnySequenceBox._dropFirst(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 168))();
}

uint64_t dispatch thunk of _AnySequenceBox._dropLast(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 176))();
}

uint64_t dispatch thunk of _AnySequenceBox._prefix(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 184))();
}

uint64_t dispatch thunk of _AnySequenceBox._prefix(while:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 192))();
}

uint64_t dispatch thunk of _AnySequenceBox._suffix(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 200))();
}

swift *type metadata completion function for _AnyCollectionBox(uint64_t a1)
{
  _QWORD v2[2];

  v2[0] = &unk_1816B4A08;
  v2[1] = &unk_1816B4A08;
  return swift_initClassMetadata2(a1, 0, 2uLL, (uint64_t)v2, a1 + 216);
}

uint64_t type metadata accessor for _AnyCollectionBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for _AnyCollectionBox);
}

uint64_t method lookup function for _AnyCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnyCollectionBox);
}

uint64_t dispatch thunk of _AnyCollectionBox._dropLast(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 232))();
}

uint64_t dispatch thunk of _AnyCollectionBox._prefix(while:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 240))();
}

uint64_t dispatch thunk of _AnyCollectionBox._suffix(_:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 248))();
}

uint64_t dispatch thunk of _AnyCollectionBox.subscript.getter()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 256))();
}

{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 336))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(after:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 264))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(after:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 272))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(_:offsetBy:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 280))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(_:offsetBy:limitedBy:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 288))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(_:offsetBy:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 296))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(_:offsetBy:limitedBy:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 304))();
}

uint64_t dispatch thunk of _AnyCollectionBox._distance(from:to:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 312))();
}

uint64_t dispatch thunk of _AnyCollectionBox._count.getter()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 320))();
}

uint64_t dispatch thunk of _AnyCollectionBox.__allocating_init(_startIndex:endIndex:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 328))();
}

swift *type metadata completion function for _AnyBidirectionalCollectionBox(uint64_t a1)
{
  _BYTE v2[8];

  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 352);
}

uint64_t method lookup function for _AnyBidirectionalCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _AnyBidirectionalCollectionBox);
}

uint64_t dispatch thunk of _AnyBidirectionalCollectionBox._index(before:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 352))();
}

uint64_t dispatch thunk of _AnyBidirectionalCollectionBox._formIndex(before:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(_QWORD *)v0 + 360))();
}

swift *type metadata completion function for _AnyRandomAccessCollectionBox(uint64_t a1)
{
  _BYTE v2[8];

  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 376);
}

_QWORD *type metadata completion function for _SequenceBox(uint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t v4;

  result = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 208));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 224);
    if (!result)
      return 0;
  }
  return result;
}

uint64_t method lookup function for _SequenceBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _SequenceBox);
}

uint64_t dispatch thunk of _SequenceBox.__allocating_init(_base:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 232))();
}

_QWORD *type metadata completion function for _CollectionBox(uint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t v4;

  result = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 344));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 360);
    if (!result)
      return 0;
  }
  return result;
}

uint64_t method lookup function for _CollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _CollectionBox);
}

uint64_t dispatch thunk of _CollectionBox.__allocating_init(_base:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 368))();
}

_QWORD *type metadata completion function for _BidirectionalCollectionBox(uint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t v4;

  result = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 368));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 384);
    if (!result)
      return 0;
  }
  return result;
}

uint64_t method lookup function for _BidirectionalCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _BidirectionalCollectionBox);
}

uint64_t dispatch thunk of _BidirectionalCollectionBox.__allocating_init(_base:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 392))();
}

_QWORD *type metadata completion function for _RandomAccessCollectionBox(uint64_t a1)
{
  _QWORD *result;
  unint64_t v3;
  uint64_t v4;

  result = swift_checkMetadataState((const char *)0x13F, *(_QWORD *)(a1 + 376));
  if (v3 <= 0x3F)
  {
    v4 = *(result - 1) + 64;
    result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 392);
    if (!result)
      return 0;
  }
  return result;
}

uint64_t method lookup function for _RandomAccessCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _RandomAccessCollectionBox);
}

uint64_t dispatch thunk of _RandomAccessCollectionBox.__allocating_init(_base:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 400))();
}

_QWORD *assignWithCopy for _ClosureBasedIterator(_QWORD *a1, _QWORD *a2, uint64_t a3, char *a4)
{
  unint64_t *v5;
  uint64_t v6;

  v5 = (unint64_t *)a2[1];
  v6 = a1[1];
  *a1 = *a2;
  a1[1] = v5;
  swift_retain(v5, (uint64_t)a2, a3, a4);
  swift_release(v6);
  return a1;
}

uint64_t type metadata accessor for AnySequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnySequence);
}

uint64_t dispatch thunk of _AnyIndexBox._unbox<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t dispatch thunk of _AnyIndexBox._isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of _AnyIndexBox._isLess(than:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t method lookup function for _IndexBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, (unsigned int *)&nominal type descriptor for _IndexBox);
}

uint64_t dispatch thunk of _IndexBox.__allocating_init(_base:)()
{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 104))();
}

__int128 *initializeBufferWithCopyOfBuffer for AnyIndex(__int128 *a1, __int128 *a2, uint64_t a3, char *a4)
{
  __int128 v5;

  v5 = *a2;
  *a1 = *a2;
  swift_unknownObjectRetain((id)v5, (uint64_t)a2, a3, a4);
  return a1;
}

uint64_t assignWithCopy for AnyIndex(uint64_t a1, void **a2, uint64_t a3, char *a4)
{
  void *v5;
  void *v6;
  void *v7;

  v5 = *a2;
  v6 = a2[1];
  v7 = *(void **)a1;
  *(_QWORD *)a1 = *a2;
  swift_unknownObjectRetain(v5, (uint64_t)a2, a3, a4);
  swift_unknownObjectRelease(v7);
  *(_QWORD *)(a1 + 8) = v6;
  return a1;
}

id *assignWithTake for AnyIndex(id *a1, _OWORD *a2)
{
  swift_unknownObjectRelease(*a1);
  *(_OWORD *)a1 = *a2;
  return a1;
}

ValueMetadata *type metadata accessor for AnyIndex()
{
  return &type metadata for AnyIndex;
}

uint64_t type metadata accessor for AnyCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnyCollection);
}

uint64_t type metadata accessor for AnyBidirectionalCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnyBidirectionalCollection);
}

uint64_t type metadata accessor for AnyRandomAccessCollection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for AnyRandomAccessCollection);
}

unint64_t type metadata completion function for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, (uint64_t)&unk_1E0EB0CD8);
}

unint64_t **initializeBufferWithCopyOfBuffer for LazyFilterSequence.Iterator(unint64_t **a1, unint64_t **a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v13;
  unint64_t *v14;
  _QWORD *v15;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = *(_DWORD *)(v9 + 80);
  if ((v11 & 0x1000F8) != 0 || ((v10 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    v14 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v14
                             + ((unsigned __int16)((v11 & 0xF8) + 23) & (unsigned __int16)~(v11 & 0xF8) & 0x1F8));
  }
  else
  {
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
    v13 = (_QWORD *)(((unint64_t)a2 + v10 + 7) & 0xFFFFFFFFFFFFFFF8);
    v14 = (unint64_t *)v13[1];
    v15 = (_QWORD *)(((unint64_t)a1 + v10 + 7) & 0xFFFFFFFFFFFFFFF8);
    *v15 = *v13;
    v15[1] = v14;
  }
  swift_retain(v14, v6, v7, v8);
  return a1;
}

uint64_t destroy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v4;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a2 + 24), *(_QWORD *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v4 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v4 + 8))(a1, AssociatedTypeWitness);
  return swift_release(*(_QWORD *)(((a1 + *(_QWORD *)(v4 + 64) + 7) & 0xFFFFFFFFFFFFF8) + 8));
}

uint64_t initializeWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 16))(a1, a2, AssociatedTypeWitness);
  v7 = *(_QWORD *)(v6 + 64) + 7;
  v8 = (_QWORD *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = (_QWORD *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v10 = (unint64_t *)v9[1];
  *v8 = *v9;
  v8[1] = v10;
  swift_retain(v10, v11, v12, v13);
  return a1;
}

uint64_t assignWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 24))(a1, a2, AssociatedTypeWitness);
  v7 = *(_QWORD *)(v6 + 64) + 7;
  v8 = (_QWORD *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  v9 = (_QWORD *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  v10 = (unint64_t *)v9[1];
  v11 = v8[1];
  *v8 = *v9;
  v8[1] = v10;
  swift_retain(v10, v12, v13, v14);
  swift_release(v11);
  return a1;
}

uint64_t initializeWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 32))(a1, a2, AssociatedTypeWitness);
  *(_OWORD *)((*(_QWORD *)(v6 + 64) + 7 + a1) & 0xFFFFFFFFFFFFF8) = *(_OWORD *)((*(_QWORD *)(v6 + 64) + 7 + a2) & 0xFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t AssociatedTypeWitness;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v6 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v6 + 40))(a1, a2, AssociatedTypeWitness);
  v7 = *(_QWORD *)(v6 + 64) + 7;
  v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  v9 = *(_QWORD *)(v8 + 8);
  *(_OWORD *)v8 = *(_OWORD *)((v7 + a2) & 0xFFFFFFFFFFFFF8);
  swift_release(v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyFilterSequence.Iterator(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v13;

  v5 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, *(const char **)(a3 + 24), *(_QWORD *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 8);
  v6 = *(_DWORD *)(v5 + 84);
  if (v6 <= 0x7FFFFFFF)
    v7 = 0x7FFFFFFF;
  else
    v7 = *(_DWORD *)(v5 + 84);
  if (!a2)
    return 0;
  v8 = *(_QWORD *)(v5 + 64);
  if (v7 < a2)
  {
    if (((((v8 + 7) & 0xFFFFFFFFFFFFFFF8) + 16) & 0xFFFFFFF8) != 0)
      v9 = 2;
    else
      v9 = a2 - v7 + 1;
    if (v9 >= 0x10000)
      v10 = 4;
    else
      v10 = 2;
    if (v9 < 0x100)
      v10 = 1;
    if (v9 >= 2)
      v11 = v10;
    else
      v11 = 0;
    __asm { BR              X15 }
  }
  if (v6 >= 0x7FFFFFFF)
    return (*(uint64_t (**)(uint64_t))(v5 + 48))(a1);
  v13 = *(_QWORD *)((a1 + v8 + 7) & 0xFFFFFFFFFFFFF8);
  if (v13 >= 0xFFFFFFFF)
    LODWORD(v13) = -1;
  return (v13 + 1);
}

void storeEnumTagSinglePayload for LazyFilterSequence.Iterator(unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;

  v7 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, *(const char **)(a4 + 24), *(_QWORD *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 8);
  if (*(_DWORD *)(v7 + 84) <= 0x7FFFFFFFu)
    v8 = 0x7FFFFFFF;
  else
    v8 = *(_DWORD *)(v7 + 84);
  if (v8 >= a3)
  {
    v11 = 0u;
    if (a2 <= v8)
      goto LABEL_17;
  }
  else
  {
    if (((*(_DWORD *)(v7 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF0)
      v9 = a3 - v8 + 1;
    else
      v9 = 2;
    if (v9 >= 0x10000)
      v10 = 4;
    else
      v10 = 2;
    if (v9 < 0x100)
      v10 = 1;
    if (v9 >= 2)
      v11 = v10;
    else
      v11 = 0;
    if (a2 <= v8)
LABEL_17:
      __asm { BR              X12 }
  }
  if (((*(_DWORD *)(v7 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
  {
    v12 = ~v8 + a2;
    bzero(a1, ((*(_QWORD *)(v7 + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 16);
    *a1 = v12;
  }
  __asm { BR              X10 }
}

void sub_1815BDD6C()
{
  uint64_t v0;
  uint64_t v1;
  char v2;

  *(_BYTE *)(v0 + v1) = v2;
  JUMPOUT(0x1815BDDE8);
}

void sub_1815BDD74()
{
  uint64_t v0;
  int v1;
  uint64_t v2;

  *(_DWORD *)(v0 + v2) = 0;
  if (v1)
    JUMPOUT(0x1815BDD7CLL);
  JUMPOUT(0x1815BDDE8);
}

void sub_1815BDDC0()
{
  uint64_t v0;
  uint64_t v1;
  __int16 v2;

  *(_WORD *)(v0 + v1) = v2;
  JUMPOUT(0x1815BDDE8);
}

void sub_1815BDDC8()
{
  uint64_t v0;
  uint64_t v1;
  int v2;

  *(_DWORD *)(v0 + v1) = v2;
  JUMPOUT(0x1815BDDE8);
}

uint64_t sub_1815BDDD0@<X0>(unsigned int a1@<W2>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_WORD *)(v3 + v5) = 0;
  if (!(_DWORD)v4)
    JUMPOUT(0x1815BDDE8);
  if (a1 < 0x7FFFFFFF)
  {
    if ((v4 & 0x80000000) == 0)
      JUMPOUT(0x1815BDDE4);
    JUMPOUT(0x1815BDDDCLL);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 56))(v3, v4);
}

uint64_t type metadata accessor for FlattenSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, (uint64_t)&nominal type descriptor for FlattenSequence);
}

unint64_t type metadata completion function for FlattenSequence.Iterator(_QWORD *a1)
{
  const char *v2;
  uint64_t v3;
  unint64_t result;
  unint64_t v5;
  const char *v6;
  unint64_t AssociatedTypeWitness;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD v12[2];

  v3 = a1[2];
  v2 = (const char *)a1[3];
  result = swift_getAssociatedTypeWitness(319, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v12[0] = *(_QWORD *)(result - 8) + 64;
    v6 = (const char *)a1[4];
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    v8 = swift_getAssociatedTypeWitness(255, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    result = type metadata accessor for Optional((const char *)0x13F, v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(_QWORD *)(result - 8) + 64;
      swift_initStructMetadata((uint64_t)a1, 0, 2uLL, (char *)v12, (uint64_t)(a1 + 5));
      return 0;
    }
  }
  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for FlattenSequence.Iterator(unint64_t **a1, unint64_t **a2, _QWORD *a3)
{
  const char *v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  int v22;
  uint64_t v23;
  int v24;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  const void *v30;

  v7 = a3[2];
  v6 = (const char *)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v17 = *(_QWORD *)(v13 - 8);
  v18 = *(_DWORD *)(v17 + 80);
  v19 = v18;
  v20 = v10 + v18;
  if (*(_DWORD *)(v17 + 84))
    v21 = *(_QWORD *)(v17 + 64);
  else
    v21 = *(_QWORD *)(v17 + 64) + 1;
  v22 = *(_DWORD *)(v9 + 80) | v18;
  v23 = (*(_BYTE *)(v9 + 80) | v18);
  v24 = v22 & 0x100000;
  if (v23 > 7 || v24 != 0 || ((v10 + v19) & ~v19) + v21 > 0x18)
  {
    v27 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v27 + ((v23 + 16) & ~v23));
    swift_retain(v27, v14, v15, v16);
  }
  else
  {
    v28 = v13;
    v29 = ~v19;
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
    v30 = (const void *)(((unint64_t)a2 + v20) & v29);
    if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v17 + 48))(v30, 1, v28))
    {
      memcpy((void *)(((unint64_t)a1 + v20) & v29), v30, v21);
    }
    else
    {
      (*(void (**)(unint64_t, const void *, unint64_t))(v17 + 16))(((unint64_t)a1 + v20) & v29, v30, v28);
      (*(void (**)(unint64_t, _QWORD, uint64_t, unint64_t))(v17 + 56))(((unint64_t)a1 + v20) & v29, 0, 1, v28);
    }
  }
  return a1;
}

uint64_t destroy for FlattenSequence.Iterator(uint64_t a1, _QWORD *a2)
{
  const char *v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t result;

  v5 = a2[2];
  v4 = (const char *)a2[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v7 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  v8 = *(_QWORD *)(v7 + 64) + a1;
  v9 = (const char *)a2[4];
  v10 = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = swift_getAssociatedTypeWitness(0, v9, v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v12 = *(_QWORD *)(v11 - 8);
  v13 = (v8 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  result = (*(uint64_t (**)(unint64_t, uint64_t, unint64_t))(v12 + 48))(v13, 1, v11);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(unint64_t, unint64_t))(v12 + 8))(v13, v11);
  return result;
}

uint64_t initializeWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  const char *v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const void *v17;
  size_t v18;

  v7 = a3[2];
  v6 = (const char *)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84))
      v18 = *(_QWORD *)(v14 + 64);
    else
      v18 = *(_QWORD *)(v14 + 64) + 1;
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 16))(v16, v17, v13);
    (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  const char *v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t (*v18)(void *, uint64_t, unint64_t);
  int v19;
  size_t v20;

  v7 = a3[2];
  v6 = (const char *)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 24))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (void *)((v10 + v15 + a2) & ~v15);
  v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  v19 = v18(v17, 1, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 24))(v16, v17, v13);
      return a1;
    }
    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }
  if (*(_DWORD *)(v14 + 84))
    v20 = *(_QWORD *)(v14 + 64);
  else
    v20 = *(_QWORD *)(v14 + 64) + 1;
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  const char *v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const void *v17;
  size_t v18;

  v7 = a3[2];
  v6 = (const char *)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 32))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84))
      v18 = *(_QWORD *)(v14 + 64);
    else
      v18 = *(_QWORD *)(v14 + 64) + 1;
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 32))(v16, v17, v13);
    (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  const char *v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t (*v18)(void *, uint64_t, unint64_t);
  int v19;
  size_t v20;

  v7 = a3[2];
  v6 = (const char *)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 40))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (void *)((v10 + v15 + a2) & ~v15);
  v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  v19 = v18(v17, 1, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 40))(v16, v17, v13);
      return a1;
    }
    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }
  if (*(_DWORD *)(v14 + 84))
    v20 = *(_QWORD *)(v14 + 64);
  else
    v20 = *(_QWORD *)(v14 + 64) + 1;
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence.Iterator(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  const char *v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;

  v7 = a3[2];
  v6 = (const char *)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = *(unsigned int *)(v9 + 84);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 8);
  v14 = *(_DWORD *)(v13 + 84);
  if (v14)
    v15 = v14 - 1;
  else
    v15 = 0;
  if (v15 <= v10)
    v16 = v10;
  else
    v16 = v15;
  if (v14)
    v17 = *(_QWORD *)(v13 + 64);
  else
    v17 = *(_QWORD *)(v13 + 64) + 1;
  if (!a2)
    return 0;
  v18 = *(unsigned __int8 *)(v13 + 80);
  v19 = *(_QWORD *)(v9 + 64) + v18;
  if (a2 <= v16)
    goto LABEL_29;
  v20 = v17 + (v19 & ~v18);
  v21 = 8 * v20;
  if (v20 <= 3)
  {
    v23 = ((a2 - v16 + ~(-1 << v21)) >> v21) + 1;
    if (HIWORD(v23))
    {
      v22 = *(_DWORD *)(a1 + v20);
      if (!v22)
        goto LABEL_29;
      goto LABEL_20;
    }
    if (v23 > 0xFF)
    {
      v22 = *(unsigned __int16 *)(a1 + v20);
      if (!*(_WORD *)(a1 + v20))
        goto LABEL_29;
      goto LABEL_20;
    }
    if (v23 < 2)
    {
LABEL_29:
      if (v16)
      {
        if (v10 >= v15)
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))(a1, v10, AssociatedTypeWitness);
        v26 = (*(uint64_t (**)(uint64_t))(v13 + 48))((v19 + a1) & ~v18);
        if (v26 >= 2)
          return v26 - 1;
        else
          return 0;
      }
      return 0;
    }
  }
  v22 = *(unsigned __int8 *)(a1 + v20);
  if (!*(_BYTE *)(a1 + v20))
    goto LABEL_29;
LABEL_20:
  v24 = (v22 - 1) << v21;
  if (v20 > 3)
    v24 = 0;
  if ((_DWORD)v20)
  {
    if (v20 <= 3)
      v25 = v20;
    else
      v25 = 4;
    __asm { BR              X12 }
  }
  return v16 + v24 + 1;
}

void storeEnumTagSinglePayload for FlattenSequence.Iterator(_BYTE *a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  const char *v12;
  unint64_t AssociatedTypeWitness;
  unsigned int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;

  v9 = a4[2];
  v8 = (const char *)a4[3];
  v10 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, v8, v9, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 8);
  v11 = *(_DWORD *)(v10 + 84);
  v12 = (const char *)a4[4];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v9, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v14 = 0u;
  v15 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, v12, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 8);
  v16 = *(_DWORD *)(v15 + 84);
  v17 = v16 - 1;
  if (!v16)
    v17 = 0;
  if (v17 <= v11)
    v18 = v11;
  else
    v18 = v17;
  v19 = *(unsigned __int8 *)(v15 + 80);
  if (v16)
    v21 = *(_QWORD *)(v15 + 64);
  else
    v21 = *(_QWORD *)(v15 + 64) + 1;
  v20 = *(_QWORD *)(v10 + 64) + v19;
  v22 = (v20 & ~(_DWORD)v19) + v21;
  if (a3 > v18)
  {
    if (v22 > 3)
    {
      v14 = 1u;
      if (v18 >= a2)
LABEL_25:
        __asm { BR              X14 }
LABEL_18:
      v24 = ~v18 + a2;
      if (v22 < 4)
      {
        if (v22)
        {
          v25 = v24 & ~(-1 << (8 * v22));
          bzero(a1, (v20 & ~v19) + v21);
          if (v22 == 3)
          {
            *(_WORD *)a1 = v25;
            a1[2] = BYTE2(v25);
          }
          else if (v22 == 2)
          {
            *(_WORD *)a1 = v25;
          }
          else
          {
            *a1 = v25;
          }
        }
      }
      else
      {
        bzero(a1, (v20 & ~v19) + v21);
        *(_DWORD *)a1 = v24;
      }
      __asm { BR              X10 }
    }
    v23 = ((a3 - v18 + ~(-1 << (8 * v22))) >> (8 * v22)) + 1;
    if (HIWORD(v23))
    {
      v14 = 4u;
      if (v18 >= a2)
        goto LABEL_25;
      goto LABEL_18;
    }
    if (v23 >= 0x100)
      v14 = 2;
    else
      v14 = v23 > 1;
  }
  if (v18 >= a2)
    goto LABEL_25;
  goto LABEL_18;
}

void sub_1815BEC10()
{
  char v0;
  uint64_t v1;
  uint64_t v2;

  *(_BYTE *)(v2 + v1) = v0;
}

void sub_1815BEC18()
{
  __int16 v0;
  uint64_t v1;
  uint64_t v2;

  *(_WORD *)(v2 + v1) = v0;
}

void sub_1815BEC44()
{
  uint64_t v0;
  int v1;

  *(_WORD *)v0 = v1;
  *(_BYTE *)(v0 + 2) = BYTE2(v1);
}

void sub_1815BEC54()
{
  _WORD *v0;
  __int16 v1;

  *v0 = v1;
}

void sub_1815BEC5C()
{
  _DWORD *v0;
  int v1;

  *v0 = v1;
}

unint64_t type metadata completion function for FlattenSequence<>.Index(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t result;
  unint64_t v5;
  const char *v6;
  unint64_t AssociatedTypeWitness;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD v12[2];

  v2 = a1[2];
  v3 = a1[3];
  result = swift_getAssociatedTypeWitness(319, (const char *)v3, v2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v5 <= 0x3F)
  {
    v12[0] = *(_QWORD *)(result - 8) + 64;
    v6 = (const char *)a1[4];
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(const char **)(v3 + 8), v2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    v8 = swift_getAssociatedTypeWitness(255, v6, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    result = type metadata accessor for Optional((const char *)0x13F, v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(_QWORD *)(result - 8) + 64;
      swift_initStructMetadata((uint64_t)a1, 0, 2uLL, (char *)v12, (uint64_t)(a1 + 5));
      return 0;
    }
  }
  return result;
}

unint64_t **initializeBufferWithCopyOfBuffer for FlattenSequence<>.Index(unint64_t **a1, unint64_t **a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  int v22;
  uint64_t v23;
  int v24;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  const void *v30;

  v7 = a3[2];
  v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, *(const char **)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v17 = *(_QWORD *)(v13 - 8);
  v18 = *(_DWORD *)(v17 + 80);
  v19 = v18;
  v20 = v10 + v18;
  if (*(_DWORD *)(v17 + 84))
    v21 = *(_QWORD *)(v17 + 64);
  else
    v21 = *(_QWORD *)(v17 + 64) + 1;
  v22 = *(_DWORD *)(v9 + 80) | v18;
  v23 = (*(_BYTE *)(v9 + 80) | v18);
  v24 = v22 & 0x100000;
  if (v23 > 7 || v24 != 0 || ((v10 + v19) & ~v19) + v21 > 0x18)
  {
    v27 = *a2;
    *a1 = *a2;
    a1 = (unint64_t **)((char *)v27 + ((v23 + 16) & ~v23));
    swift_retain(v27, v14, v15, v16);
  }
  else
  {
    v28 = v13;
    v29 = ~v19;
    (*(void (**)(unint64_t **, unint64_t **, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
    v30 = (const void *)(((unint64_t)a2 + v20) & v29);
    if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v17 + 48))(v30, 1, v28))
    {
      memcpy((void *)(((unint64_t)a1 + v20) & v29), v30, v21);
    }
    else
    {
      (*(void (**)(unint64_t, const void *, unint64_t))(v17 + 16))(((unint64_t)a1 + v20) & v29, v30, v28);
      (*(void (**)(unint64_t, _QWORD, uint64_t, unint64_t))(v17 + 56))(((unint64_t)a1 + v20) & v29, 0, 1, v28);
    }
  }
  return a1;
}

uint64_t destroy for FlattenSequence<>.Index(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t AssociatedTypeWitness;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t result;

  v5 = a2[2];
  v4 = a2[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v4, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v7 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, unint64_t))(v7 + 8))(a1, AssociatedTypeWitness);
  v8 = *(_QWORD *)(v7 + 64) + a1;
  v9 = (const char *)a2[4];
  v10 = swift_getAssociatedTypeWitness(255, *(const char **)(v4 + 8), v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v11 = swift_getAssociatedTypeWitness(0, v9, v10, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v12 = *(_QWORD *)(v11 - 8);
  v13 = (v8 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  result = (*(uint64_t (**)(unint64_t, uint64_t, unint64_t))(v12 + 48))(v13, 1, v11);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(unint64_t, unint64_t))(v12 + 8))(v13, v11);
  return result;
}

uint64_t initializeWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const void *v17;
  size_t v18;

  v7 = a3[2];
  v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, *(const char **)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84))
      v18 = *(_QWORD *)(v14 + 64);
    else
      v18 = *(_QWORD *)(v14 + 64) + 1;
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 16))(v16, v17, v13);
    (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t (*v18)(void *, uint64_t, unint64_t);
  int v19;
  size_t v20;

  v7 = a3[2];
  v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 24))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, *(const char **)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (void *)((v10 + v15 + a2) & ~v15);
  v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  v19 = v18(v17, 1, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 24))(v16, v17, v13);
      return a1;
    }
    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }
  if (*(_DWORD *)(v14 + 84))
    v20 = *(_QWORD *)(v14 + 64);
  else
    v20 = *(_QWORD *)(v14 + 64) + 1;
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const void *v17;
  size_t v18;

  v7 = a3[2];
  v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 32))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, *(const char **)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, unint64_t))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84))
      v18 = *(_QWORD *)(v14 + 64);
    else
      v18 = *(_QWORD *)(v14 + 64) + 1;
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, unint64_t))(v14 + 32))(v16, v17, v13);
    (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t (*v18)(void *, uint64_t, unint64_t);
  int v19;
  size_t v20;

  v7 = a3[2];
  v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 40))(a1, a2, AssociatedTypeWitness);
  v10 = *(_QWORD *)(v9 + 64);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, *(const char **)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v14 = *(_QWORD *)(v13 - 8);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = (void *)((v10 + v15 + a1) & ~v15);
  v17 = (void *)((v10 + v15 + a2) & ~v15);
  v18 = *(uint64_t (**)(void *, uint64_t, unint64_t))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  v19 = v18(v17, 1, v13);
  if ((_DWORD)v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, _QWORD, uint64_t, unint64_t))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, unint64_t))(v14 + 40))(v16, v17, v13);
      return a1;
    }
    (*(void (**)(void *, unint64_t))(v14 + 8))(v16, v13);
  }
  if (*(_DWORD *)(v14 + 84))
    v20 = *(_QWORD *)(v14 + 64);
  else
    v20 = *(_QWORD *)(v14 + 64) + 1;
  memcpy(v16, v17, v20);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence<>.Index(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t AssociatedTypeWitness;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;

  v7 = a3[2];
  v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (const char *)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  v9 = *(_QWORD *)(AssociatedTypeWitness - 8);
  v10 = *(unsigned int *)(v9 + 84);
  v11 = (const char *)a3[4];
  v12 = swift_getAssociatedTypeWitness(255, *(const char **)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v13 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, v11, v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 8);
  v14 = *(_DWORD *)(v13 + 84);
  if (v14)
    v15 = v14 - 1;
  else
    v15 = 0;
  if (v15 <= v10)
    v16 = v10;
  else
    v16 = v15;
  if (v14)
    v17 = *(_QWORD *)(v13 + 64);
  else
    v17 = *(_QWORD *)(v13 + 64) + 1;
  if (!a2)
    return 0;
  v18 = *(unsigned __int8 *)(v13 + 80);
  v19 = *(_QWORD *)(v9 + 64) + v18;
  if (a2 <= v16)
    goto LABEL_29;
  v20 = v17 + (v19 & ~v18);
  v21 = 8 * v20;
  if (v20 <= 3)
  {
    v23 = ((a2 - v16 + ~(-1 << v21)) >> v21) + 1;
    if (HIWORD(v23))
    {
      v22 = *(_DWORD *)(a1 + v20);
      if (!v22)
        goto LABEL_29;
      goto LABEL_20;
    }
    if (v23 > 0xFF)
    {
      v22 = *(unsigned __int16 *)(a1 + v20);
      if (!*(_WORD *)(a1 + v20))
        goto LABEL_29;
      goto LABEL_20;
    }
    if (v23 < 2)
    {
LABEL_29:
      if (v16)
      {
        if (v10 >= v15)
          return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(v9 + 48))(a1, v10, AssociatedTypeWitness);
        v26 = (*(uint64_t (**)(uint64_t))(v13 + 48))((v19 + a1) & ~v18);
        if (v26 >= 2)
          return v26 - 1;
        else
          return 0;
      }
      return 0;
    }
  }
  v22 = *(unsigned __int8 *)(a1 + v20);
  if (!*(_BYTE *)(a1 + v20))
    goto LABEL_29;
LABEL_20:
  v24 = (v22 - 1) << v21;
  if (v20 > 3)
    v24 = 0;
  if ((_DWORD)v20)
  {
    if (v20 <= 3)
      v25 = v20;
    else
      v25 = 4;
    __asm { BR              X12 }
  }
  return v16 + v24 + 1;
}

void storeEnumTagSinglePayload for FlattenSequence<>.Index(_BYTE *a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  const char *v12;
  unint64_t AssociatedTypeWitness;
  unsigned int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;

  v9 = a4[2];
  v8 = a4[3];
  v10 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, (const char *)v8, v9, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 8);
  v11 = *(_DWORD *)(v10 + 84);
  v12 = (const char *)a4[4];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(const char **)(v8 + 8), v9, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  v14 = 0u;
  v15 = *(_QWORD *)(swift_getAssociatedTypeWitness(0, v12, AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 8);
  v16 = *(_DWORD *)(v15 + 84);
  v17 = v16 - 1;
  if (!v16)
    v17 = 0;
  if (v17 <= v11)
    v18 = v11;
  else
    v18 = v17;
  v19 = *(unsigned __int8 *)(v15 + 80);
  if (v16)
    v21 = *(_QWORD *)(v15 + 64);
  else
    v21 = *(_QWORD *)(v15 + 64) + 1;
  v20 = *(_QWORD *)(v10 + 64) + v19;
  v22 = (v20 & ~(_DWORD)v19) + v21;
  if (a3 > v18)
  {
    if (v22 > 3)
    {
      v14 = 1u;
      if (v18 >= a2)
LABEL_25:
        __asm { BR              X14 }
LABEL_18:
      v24 = ~v18 + a2;
      if (v22 < 4)
      {
        if (v22)
        {
          v25 = v24 & ~(-1 << (8 * v22));
          bzero(a1, (v20 & ~v19) + v21);
          if (v22 == 3)
          {
            *(_WORD *)a1 = v25;
            a1[2] = BYTE2(v25);
          }
          else if (v22 == 2)
          {
            *(_WORD *)a1 = v25;
          }
          else
          {
            *a1 = v25;
          }
        }
      }
      else
      {
        bzero(a1, (v20 & ~v19) + v21);
        *(_DWORD *)a1 = v24;
      }
      __asm { BR              X10 }
    }
    v23 = ((a3 - v18 + ~(-1 << (8 * v22))) >> (8 * v22)) + 1;
    if (HIWORD(v23))
    {
      v14 = 4u;
      if (v18 >= a2)
        goto LABEL_25;
      goto LABEL_18;
    }
    if (v23 >= 0x100)
      v14 = 2;
    else
      v14 = v23 > 1;
  }
  if (v18 >= a2)
    goto LABEL_25;
  goto LABEL_18;
}

void sub_1815BFA9C()
{
  char v0;
  uint64_t v1;
  uint64_t v2;

  *(_BYTE *)(v2 + v1) = v0;
}

void sub_1815BFAA4()
{
  __int16 v0;
  uint64_t v1;
  uint64_t v2;

  *(_WORD *)(v2 + v1) = v0;
}

void sub_1815BFAD0()
{
  uint64_t v0;
  int v1;

  *(_WORD *)v0 = v1;
  *(_BYTE *)(v0 + 2) = BYTE2(v1);
}

void sub_1815BFAE0()
{
  _WORD *v0;
  __int16 v1;

  *v0 = v1;
}

void sub_1815BFAE8()
{
  _DWORD *v0;
  int v1;

  *v0 = v1;
}

uint64_t dispatch thunk of FloatingPoint.init(sign:exponent:significand:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(_QWORD))(a5 + 48))(a1 & 1);
}

uint64_t dispatch thunk of FloatingPoint.init(signOf:magnitudeOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of FloatingPoint.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of FloatingPoint.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of static FloatingPoint.radix.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

uint64_t dispatch thunk of static FloatingPoint.nan.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of static FloatingPoint.signalingNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of static FloatingPoint.infinity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of static FloatingPoint.greatestFiniteMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of static FloatingPoint.pi.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of FloatingPoint.ulp.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of static FloatingPoint.ulpOfOne.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of static FloatingPoint.leastNormalMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of static FloatingPoint.leastNonzeroMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of FloatingPoint.sign.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))() & 1;
}

uint64_t dispatch thunk of FloatingPoint.exponent.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 176))();
}

uint64_t dispatch thunk of FloatingPoint.significand.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 184))();
}

uint64_t dispatch thunk of static FloatingPoint./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 192))();
}

uint64_t dispatch thunk of static FloatingPoint./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 200))();
}

uint64_t dispatch thunk of FloatingPoint.remainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 208))();
}

uint64_t dispatch thunk of FloatingPoint.formRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 216))();
}

uint64_t dispatch thunk of FloatingPoint.truncatingRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 224))();
}

uint64_t dispatch thunk of FloatingPoint.formTruncatingRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 232))();
}

uint64_t dispatch thunk of FloatingPoint.squareRoot()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 240))();
}

uint64_t dispatch thunk of FloatingPoint.formSquareRoot()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 248))();
}

uint64_t dispatch thunk of FloatingPoint.addingProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 256))();
}

uint64_t dispatch thunk of FloatingPoint.addProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 264))();
}

uint64_t dispatch thunk of static FloatingPoint.minimum(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 272))();
}

uint64_t dispatch thunk of static FloatingPoint.maximum(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 280))();
}

uint64_t dispatch thunk of static FloatingPoint.minimumMagnitude(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 288))();
}

uint64_t dispatch thunk of static FloatingPoint.maximumMagnitude(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 296))();
}

uint64_t dispatch thunk of FloatingPoint.rounded(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 304))();
}

uint64_t dispatch thunk of FloatingPoint.round(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 312))();
}

uint64_t dispatch thunk of FloatingPoint.nextUp.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 320))();
}

uint64_t dispatch thunk of FloatingPoint.nextDown.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of FloatingPoint.isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 336))();
}

uint64_t dispatch thunk of FloatingPoint.isLess(than:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 344))();
}

uint64_t dispatch thunk of FloatingPoint.isLessThanOrEqualTo(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 352))();
}

uint64_t dispatch thunk of FloatingPoint.isTotallyOrdered(belowOrEqualTo:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 360))();
}

uint64_t dispatch thunk of FloatingPoint.isNormal.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 368))();
}

uint64_t dispatch thunk of FloatingPoint.isFinite.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 376))();
}

uint64_t dispatch thunk of FloatingPoint.isZero.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 384))();
}

uint64_t dispatch thunk of FloatingPoint.isSubnormal.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 392))();
}

uint64_t dispatch thunk of FloatingPoint.isInfinite.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 400))();
}

uint64_t dispatch thunk of FloatingPoint.isNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 408))();
}

uint64_t dispatch thunk of FloatingPoint.isSignalingNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 416))();
}

uint64_t dispatch thunk of FloatingPoint.floatingPointClass.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 424))();
}

uint64_t dispatch thunk of FloatingPoint.isCanonical.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 432))();
}

_BYTE *destructiveInjectEnumTag for FloatingPointSign(_BYTE *result, char a2)
{
  *result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointSign()
{
  return &type metadata for FloatingPointSign;
}

uint64_t getEnumTagSinglePayload for FloatingPointClassification(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xF7)
    goto LABEL_17;
  if (a2 + 9 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 9) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 9;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 9;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 9;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 0xA;
  v8 = v6 - 10;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for FloatingPointClassification(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 9 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 9) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xF7)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xF6)
    return ((uint64_t (*)(void))((char *)&loc_1815BFD94 + 4 * byte_1816AC2A8[v4]))();
  *a1 = a2 + 9;
  return ((uint64_t (*)(void))((char *)sub_1815BFDC8 + 4 * byte_1816AC2A3[v4]))();
}

uint64_t sub_1815BFDC8(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1815BFDD0(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1815BFDD8);
  return result;
}

uint64_t sub_1815BFDE4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1815BFDECLL);
  *(_BYTE *)result = a2 + 9;
  return result;
}

uint64_t sub_1815BFDF0(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1815BFDF8(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointClassification()
{
  return &type metadata for FloatingPointClassification;
}

uint64_t getEnumTagSinglePayload for FloatingPointRoundingRule(unsigned __int8 *a1, unsigned int a2)
{
  int v2;
  int v3;
  int v4;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (!a2)
    return 0;
  if (a2 < 0xFB)
    goto LABEL_17;
  if (a2 + 5 >= 0xFFFF00)
    v2 = 4;
  else
    v2 = 2;
  if ((a2 + 5) >> 8 < 0xFF)
    v3 = 1;
  else
    v3 = v2;
  if (v3 == 4)
  {
    v4 = *(_DWORD *)(a1 + 1);
    if (v4)
      return (*a1 | (v4 << 8)) - 5;
  }
  else
  {
    if (v3 == 2)
    {
      v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1))
        goto LABEL_17;
      return (*a1 | (v4 << 8)) - 5;
    }
    v4 = a1[1];
    if (a1[1])
      return (*a1 | (v4 << 8)) - 5;
  }
LABEL_17:
  v6 = *a1;
  v7 = v6 >= 6;
  v8 = v6 - 6;
  if (!v7)
    v8 = -1;
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for FloatingPointRoundingRule(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 5 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 5) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFB)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFA)
    return ((uint64_t (*)(void))((char *)&loc_1815BFEF0 + 4 * byte_1816AC2B2[v4]))();
  *a1 = a2 + 5;
  return ((uint64_t (*)(void))((char *)sub_1815BFF24 + 4 * byte_1816AC2AD[v4]))();
}

uint64_t sub_1815BFF24(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1815BFF2C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x1815BFF34);
  return result;
}

uint64_t sub_1815BFF40(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x1815BFF48);
  *(_BYTE *)result = a2 + 5;
  return result;
}

uint64_t sub_1815BFF4C(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1815BFF54(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointRoundingRule()
{
  return &type metadata for FloatingPointRoundingRule;
}

uint64_t dispatch thunk of BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(_QWORD))(a5 + 56))(a1 & 1);
}

uint64_t dispatch thunk of BinaryFloatingPoint.init(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 80))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 88))();
}

uint64_t dispatch thunk of static BinaryFloatingPoint.exponentBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of static BinaryFloatingPoint.significandBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.exponentBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.significandBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.binade.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.significandWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of Hashable.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Hashable.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of Hashable._rawHashValue(seed:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _HasCustomAnyHashableRepresentation._toCustomAnyHashable()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _AnyHashableBox._canonicalBox.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _AnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of _AnyHashableBox._hashValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of _AnyHashableBox._hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _AnyHashableBox._rawHashValue(_seed:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of _AnyHashableBox._base.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of _AnyHashableBox._unbox<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of _AnyHashableBox._downCastConditional<A>(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t destroy for AnyHashable(uint64_t *a1)
{
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t initializeWithCopy for AnyHashable(uint64_t a1, uint64_t a2)
{
  __int128 v3;

  v3 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 24) = v3;
  (**(void (***)(void))(v3 - 8))();
  return a1;
}

uint64_t *assignWithCopy for AnyHashable(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  __swift_assign_boxed_opaque_existential_1(a1, a2, a3, a4);
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_1(uint64_t *result, uint64_t a2, uint64_t a3, char *a4)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t *v19;
  _BYTE v20[24];

  if (result != (uint64_t *)a2)
  {
    v5 = result;
    v6 = result[3];
    v7 = *(_QWORD *)(a2 + 24);
    if (v6 == v7)
    {
      v14 = *(_QWORD *)(v6 - 8);
      if ((*(_BYTE *)(v14 + 82) & 2) != 0)
      {
        v16 = *result;
        v17 = *(unint64_t **)a2;
        swift_retain(*(unint64_t **)a2, a2, a3, a4);
        result = (uint64_t *)swift_release(v16);
        *v5 = v17;
      }
      else
      {
        return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v14 + 24))(result, a2, result[3]);
      }
    }
    else
    {
      result[3] = v7;
      result[4] = *(_QWORD *)(a2 + 32);
      v8 = *(_QWORD *)(v6 - 8);
      v9 = *(_QWORD *)(v7 - 8);
      v10 = *(_DWORD *)(v9 + 80);
      if ((*(_BYTE *)(v8 + 82) & 2) != 0)
      {
        v15 = *result;
        if ((v10 & 0x20000) != 0)
        {
          v19 = *(unint64_t **)a2;
          *v5 = *(_QWORD *)a2;
          swift_retain(v19, a2, a3, a4);
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t))(v9 + 16))(result, a2, v7);
        }
        return (uint64_t *)swift_release(v15);
      }
      else
      {
        (*(void (**)(_BYTE *, uint64_t *, uint64_t))(v8 + 32))(v20, result, v6);
        if ((v10 & 0x20000) != 0)
        {
          v18 = *(unint64_t **)a2;
          *v5 = *(_QWORD *)a2;
          swift_retain(v18, v11, v12, v13);
        }
        else
        {
          (*(void (**)(_QWORD *, uint64_t, uint64_t))(v9 + 16))(v5, a2, v7);
        }
        return (uint64_t *)(*(uint64_t (**)(_BYTE *, uint64_t))(v8 + 8))(v20, v6);
      }
    }
  }
  return result;
}

